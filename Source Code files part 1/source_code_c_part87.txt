 removed in the B1 stepping.  When executed on the B1, INSERT
;    and EXTRACT cause an int 6 (invalid opcode) exception.  This routine
;    can therefore discriminate between B1/later 386s and B0/earlier 386s.
;    It is intended to be used in sequence with other checks to determine
;    processor stepping by exercising specific bugs found in specific
;    steppings of the 386.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B1 or later stepping
;    Carry Flag set if B0 or prior
;
;--


    ASSUME ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386B0      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,6*4
        push    dword ptr [bx]          ; save old int 6 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt6
        mov     [bx].VectorSegment,cs         ; set vector to new int 6 handler

;
; Attempt execution of Extract Bit String instruction.  Execution on
; B0 or earlier with length (CL) = 0 will return 0 into the destination
; (CX in this case).  Execution on B1 or later will fail either due to
; taking the invalid opcode trap, or if the opcode is valid, we don't
; expect CX will be zeroed by any new instruction supported by newer
; steppings.  The dummy int 6 handler will clears the Carry Flag and
; returns execution to the appropriate label.  If the instruction
; actually executes, CX will *probably* remain unchanged in any new
; stepping that uses the opcode for something else.  The nops are meant
; to handle newer steppings with an unknown instruction length.
;

        xor     ax,ax
        mov     dx,ax
        mov     cx,0ff00h               ; Extract length (CL) == 0, (CX) != 0

b1c50:  db      0fh, 0a6h, 0cah         ; xbts cx,dx,ax,cl
        nop
        nop
        nop
        nop
        nop
        stc                             ; assume B0
        jcxz    short b1c70             ; jmp if B0
b1c60:  clc
b1c70:  pop     dword ptr [bx]          ; restore old int 6 vector

        pop     bx
        pop     ds
        ret

Check386B0      endp

;++
;
; BOOLEAN
; TemporaryInt6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an XTBS instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

TemporaryInt6    proc

        mov     word ptr [esp].IretIp,offset b1c60 ; set IP to clc instruction
        iret

TemporaryInt6   endp

;++
;
; BOOLEAN
; Check386D1 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 D1 Stepping.
;
;    It takes advantage of the fact that on pre-D1 386, if a REPeated
;    MOVS instruction is executed when single-stepping is enabled,
;    a single step trap is taken every TWO moves steps, but should
;    occuu each move step.
;
;    NOTE: This routine cannot distinguish between a D0 stepping and a D1
;    stepping.  If a need arises to make this distinction, this routine
;    will need modification.  D0 steppings will be recognized as D1.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D1 or later stepping
;    Carry Flag set if B1 or prior
;
;--

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

Check386D1      proc

        push    ds
        push    bx

        xor     ax,ax
        mov     ds,ax                   ; (DS) = 0 (real mode IDT)
        mov     bx,1*4
        push    dword ptr [bx]          ; save old int 1 vector

        mov     word ptr [bx].VectorOffset,offset TemporaryInt1
        mov     word ptr [bx].VectorSegment,cs ; set vector to new int 1 handler

;
; Attempt execution of rep movsb instruction with the Trace Flag set.
; Execution on B1 or earlier with length (CX) > 1 will trace over two
; iterations before accepting the trace trap.  Execution on D1 or later
; will accept the trace trap after a single iteration.  The dummy int 1
; handler will return execution to the instruction following the movsb
; instruction.  Examination of (CX) will reveal the stepping.
;

        sub     sp,4                    ; make room for target of movsb
        xor     si,si                   ; (ds:si) = 0:0
        push    ss                      ; (es:di) = ss:sp-4
        pop     es
        mov     di,sp
        mov     cx,2                    ; 2 iterations
        pushf
        or      word ptr [esp], EFLAGS_TF
        popf                            ; cause a single step trap
        rep movsb

d1c60:  add     sp,4                    ; clean off stack
        pop     dword ptr [bx]          ; restore old int 1 vector
        stc                             ; assume B1
        jcxz    short d1cx              ; jmp if <= B1
        clc                             ; else clear carry to indicate >= D1
d1cx:
        pop     bx
        pop     ds
        ret

Check386D1      endp

;++
;
; BOOLEAN
; TemporaryInt1 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 1 handler - assumes the cause of the exception was
;    trace trap at the above rep movs instruction.
;
; Arguments:
;
;    (esp)->eip of trapped instruction
;           cs  of trapped instruction
;           eflags of trapped instruction
;
;--

TemporaryInt1   proc

        and     word ptr [esp].IretFlags,not EFLAGS_TF ; clear caller's Trace Flag
        mov     word ptr [esp].IretIp,offset d1c60     ; set IP to next instruction
        iret

TemporaryInt1   endp

;++
;
; BOOLEAN
; MultiplyTest (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks the 386 32-bit multiply instruction.
;    The reason for this check is because some of the i386 fail to
;    perform this instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success
;    Carry Flag set on failure
;
;--
;

    assume ds:nothing, es:nothing, fs:nothing, gs:nothing, ss:nothing

MultiplyTest    proc

        xor     cx,cx                   ; 64K times is a nice round number
mlt00:  push    cx
        call    Multiply                ; does this chip's multiply work?
        pop     cx
        jc      short mltx              ; if c, No, exit
        loop    mlt00                   ; if nc, YEs, loop to try again
        clc
mltx:
        ret

MultiplyTest    endp

;++
;
; BOOLEAN
; Multiply (
;    VOID
;    )
;
; Routine Description:
;
;    This routine performs 32-bit multiplication test which is known to
;    fail on bad 386s.
;
;    Note, the supplied pattern values must be used for consistent results.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success.
;    Carry Flag set on failure.
;
;--

Multiply        proc

        mov     ecx, MULTIPLIER
        mov     eax, MULTIPLICAND
        mul     ecx

        cmp     edx, RESULT_HIGH        ; Q: high order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        cmp     eax, RESULT_LOW         ; Q: low order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        clc                             ; indicate success
mlpx:
        ret

Multiply        endp

;++
;
; BOOLEAN
; IsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.  If yes, the ET bit in CR0 will be set; otherwise
;     it will be reset.
;
;     Note that we do NOT determine its type (287, 387).
;     This code is extracted from Intel book.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;
;--

        public  _IsNpxPresent
_IsNpxPresent   proc    near

        push    bp                      ; Save caller's bp
.386p
        mov     eax, cr0
        and     eax, NOT CR0_ET         ; Assume no NPX
        mov     edx, 0
.287
        fninit                          ; Initialize NPX
        mov     cx, 5A5Ah               ; Put non-zero value
        push    cx                      ;   into the memory we are going to use
        mov     bp, sp
        fnstsw  word ptr [bp]           ; Retrieve status - must use non-wait
        cmp     byte ptr [bp], 0        ; All bits cleared by fninit?
        jne     Inp10

        or      eax, CR0_ET
        mov     edx, 1
Inp10:
        mov     cr0, eax
        pop     ax                      ; clear scratch value
        pop     bp                      ; Restore caller's bp
        mov     eax, edx
        ret

_IsNpxPresent   endp

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\disk.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    flo_data.h

Abstract:

    This file includes data and hardware declarations for the BIOS
    disk and floppy.

Author:

    Shie-Lin Tzong (shielint) Dec-26-1991.

Environment:

    x86 real mode.

Notes:

--*/



//
// CMOS related definitions and macros
//

#define CMOS_CONTROL_PORT 0x70          // cmos command port
#define CMOS_DATA_PORT 0x71             // cmos data port
#define CMOS_FLOPPY_CONFIG_BYTE 0x10

//
// The length of CBIOS floppy parameter table
//

#define FLOPPY_PARAMETER_TABLE_LENGTH 28

//
// The CM_FLOPPY_DEVICE_DATA we use here is the newly updated one.
// To distinguish this, we set the version number in the CM_FLOPPY_DEVICE_DATA
// to 2. (Otherwise, it should be < 2)
//

#define CURRENT_FLOPPY_DATA_VERSION 2

extern USHORT NumberBiosDisks;

//
// External References
//

extern
BOOLEAN
IsExtendedInt13Available (
    IN USHORT DriveNumber
    );

extern
USHORT
GetExtendedDriveParameters (
    IN USHORT DriveNumber,
    IN CM_DISK_GEOMETRY_DEVICE_DATA far *DeviceData
    );

//
// Partition table record and boot signature offsets in 16-bit words.
//

#define PARTITION_TABLE_OFFSET         (0x1be / 2)
#define BOOT_SIGNATURE_OFFSET          ((0x200 / 2) - 1)

//
// Boot record signature value.
//

#define BOOT_RECORD_SIGNATURE          (0xaa55)

VOID
GetDiskId(
    USHORT Drive,
    PUCHAR Identifier
    );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\cpu.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       cpu.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for INTEL 80x86 CPU specifiec information.  This include file
;       is mainly used by CPU.ASM to determine CPU type and stepping
;       number.
;
;   Author:
;
;       Shie-Lin (shielint) 1-Oct-1991
;
;   Revision History:
;
;--

;
; The following equates define the control bits of CR0 register
;

CR0_AM          equ     40000h
CR0_ET          equ     00010h

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_VM       equ     20000h
EFLAGS_RF       equ     10000h
EFLAGS_NF       equ     4000h
EFLAGS_IOPL     equ     3000h
EFLAGS_IF       equ     200h
EFLAGS_TF       equ     100h


;
; define the structure type for real mode interrupt vectore
;

RealModeVector  struc

VectorOffset    dw      0
VectorSegment   dw      0

RealModeVector  ends

;
; Define the iret frame
;

IretFrame       struc

IretIp         dw      0
IretCs         dw      0
IretFlags      dw      0

IretFrame       ends

;
; Misc. definitions
;

ADDRESS_OVERRIDE        equ     67h
OPERAND_OVERRIDE        equ     66h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\diskc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    diskc.c

Abstract:

    This is the NEC PD756 (aka AT, aka ISA, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette detection code for NT.  This file also
    collect BIOS disk drive parameters.

Author:

    Shie-Lin Tzong (shielint) Dec-26-1991.

Environment:

    x86 real mode.

Revision History:


Notes:

--*/

//
// Include files.
//

#include "hwdetect.h"
#include "disk.h"
#include <string.h>


FPFWCONFIGURATION_COMPONENT_DATA
GetFloppyInformation(
                    VOID
                    )

/*++

Routine Description:

    This routine tries to get floppy configuration information.

Arguments:

    None.

Return Value:

    A pointer to a FPCONFIGURATION_COMPONENT_DATA is returned.  It is
    the head of floppy component tree root.

--*/

{
    UCHAR DriveType;
    FPUCHAR ParameterTable;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA FirstController = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR FloppyNumber = 0;
    UCHAR FloppySkipped = 0;
    UCHAR DiskName[30];
    UCHAR FloppyParmTable[FLOPPY_PARAMETER_TABLE_LENGTH];
    FPUCHAR fpString;
    USHORT Length, z;
    ULONG MaxDensity = 0;
    CM_FLOPPY_DEVICE_DATA far *FloppyData;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    USHORT FloppyDataVersion;

    for (z = 0; z < FLOPPY_PARAMETER_TABLE_LENGTH; z++ ) {
        FloppyParmTable[z] = 0;
    }

    //
    // Initialize Controller data
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;

    //
    // Allocate space for Controller component and initialize it.
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                                                    sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    FirstController = CurrentEntry;
    Component = &CurrentEntry->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = DiskController;
    Component->Flags.Removable = 1;
    Component->Flags.Input = 1;
    Component->Flags.Output = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
    CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)0x3f0;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = (ULONG)0;
    ControlData.DescriptorList[z].u.Port.Length = 8;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
    CmResourceShareUndetermined;
    if (HwBusType == MACHINE_TYPE_MCA) {
        ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
    } else {
        ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    }
    ControlData.DescriptorList[z].u.Interrupt.Level = 6;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 6;
    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
    z++;

    //
    // Set up DMA information. Only set channel number.  Timming and
    // transferSize are defaulted - 8 bits and ISA compatible.
    //

    ControlData.NumberDmaEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_DMA;
    ControlData.DescriptorList[z].ShareDisposition =
    CmResourceShareUndetermined;
    ControlData.DescriptorList[z].Flags = 0;
    ControlData.DescriptorList[z].u.Dma.Channel = (ULONG)2;
    ControlData.DescriptorList[z].u.Dma.Port = 0;
    z++;

    CurrentEntry->ConfigurationData =
    HwSetUpResourceDescriptor(Component,
                              NULL,
                              &ControlData,
                              0,
                              NULL
                             );

    //
    // Collect disk peripheral data
    //
    while (1) {
        _asm {
            push   es

            mov    DriveType, 0
            mov    FloppyDataVersion, CURRENT_FLOPPY_DATA_VERSION

            mov    ah, 15h
            mov    dl, FloppyNumber
            int    13h
            jc     short CmosTest

            cmp    ah, 0
            je     short Exit

            cmp    ah, 2                   ; make sure this is floppy
            ja     short Exit

            mov    ah, 8
            mov    dl, FloppyNumber
            lea    di, word ptr FloppyParmTable ; use 'word ptr' to quiet compiler
            push   ds
            pop    es                      ; (es:di)->dummy FloppyParmTable
            int    13h
            jc     short CmosTest

            mov    DriveType, bl
            mov    ax, es
            mov    word ptr ParameterTable + 2, ax
            mov    word ptr ParameterTable, di
            jmp    short Exit

            CmosTest:

            ;
            ; ifint 13 fails, we know that floppy drive is present.
                ;So, we tryto get the Drive Type from CMOS.
            ;

            mov     al, CMOS_FLOPPY_CONFIG_BYTE
            mov     dx, CMOS_CONTROL_PORT   ; address port
            out     dx, al
            jmp     short delay1            ; I/O DELAY
            delay1:
            mov     dx, CMOS_DATA_PORT      ; READ IN REQUESTED CMOS DATA
            in      al, dx
            jmp     short delay2            ; I/O DELAY
            delay2:
            cmp     FloppyNumber, 0
            jne     short CmosTest1

            and     al, 0xf0
            shr     al, 4
            jmp     short Test2Cmos

            CmosTest1:
            cmp     FloppyNumber, 1
            jne     short Exit

            and     al, 0xf
            Test2Cmos:
            mov     DriveType, al
            mov     FloppyDataVersion, 0

            Exit:
            pop     es
        }

        if (DriveType) {

            //
            // Allocate space for first pripheral component and initialize it.
            //

            CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                                                            sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

            Component = &CurrentEntry->ComponentEntry;

            Component->Class = PeripheralClass;
            Component->Type = FloppyDiskPeripheral;
            Component->Version = 0;
            Component->Key = FloppyNumber - FloppySkipped;
            Component->AffinityMask = 0xffffffff;
            Component->ConfigurationDataLength = 0;

            //
            // Set up type string.
            //

            strcpy(DiskName, "FLOPPYx");
            DiskName[6] = FloppyNumber - FloppySkipped + (UCHAR)'1';
            Length = strlen(DiskName) + 1;
            fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
            _fstrcpy(fpString, DiskName);
            Component->IdentifierLength = Length;
            Component->Identifier = fpString;

            //
            // Set up floppy device specific data
            //

            switch (DriveType) {
                case 1:
                    MaxDensity = 360;
                    break;
                case 2:
                    MaxDensity = 1200;
                    break;
                case 3:
                    MaxDensity = 720;
                    break;
                case 4:
                    MaxDensity = 1440;
                    break;
                case 5:
                case 6:
                    MaxDensity = 2880;
                    break;
                case 0x10:
                    //
                    // Mark a removable atapi as a super floppy.
                    // Enable it to work around the problem of not having
                    // a floppy but only a LS-120
                    //
                    //N.B we can ONLY get away with using the high bit on the
                    // superfloppy. SFLOPPY doesn't use this field
                    // fdc does, but isn't loaded on these devices!
                    //
                    MaxDensity=(2880 | 0x80000000);
                    break;

                default:
                    MaxDensity = 0;
                    break;
            }
            if (FloppyDataVersion == CURRENT_FLOPPY_DATA_VERSION) {
                Length = sizeof(CM_FLOPPY_DEVICE_DATA);
            } else {
                Length = (SHORT)&(((CM_FLOPPY_DEVICE_DATA*)0)->StepRateHeadUnloadTime);
            }
            DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                                                         Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST),
                                                                         TRUE);
            CurrentEntry->ConfigurationData = DescriptorList;
            Component->ConfigurationDataLength =
            Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST);
            DescriptorList->Count = 1;
            DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
            DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
            Length;
            FloppyData = (CM_FLOPPY_DEVICE_DATA far *)(DescriptorList + 1);
            FloppyData->MaxDensity = MaxDensity;
            FloppyData->Version = FloppyDataVersion;
            if (FloppyDataVersion == CURRENT_FLOPPY_DATA_VERSION) {
                _fmemcpy((FPCHAR)&FloppyData->StepRateHeadUnloadTime,
                         ParameterTable,
                         sizeof(CM_FLOPPY_DEVICE_DATA) -
                         (SHORT)&(((CM_FLOPPY_DEVICE_DATA*)0)->StepRateHeadUnloadTime)
                        );
            }
            if ((FloppyNumber - FloppySkipped) == 0) {
                FirstController->Child = CurrentEntry;
            } else {
                PreviousEntry->Sibling = CurrentEntry;
            }
            CurrentEntry->Parent = FirstController;
            PreviousEntry = CurrentEntry;
            FloppyNumber++;
        } else {

            //
            // This is a *hack* for ntldr.  Here we create a arc name for
            // each bios disks such that ntldr can open them.
            //

            if (NumberBiosDisks != 0) {

                for (z = 0; z < NumberBiosDisks; z++) {

                    //
                    // Allocate space for disk peripheral component
                    //

                    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                                                                    sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

                    Component = &CurrentEntry->ComponentEntry;

                    Component->Class = PeripheralClass;
                    Component->Type = DiskPeripheral;
                    Component->Flags.Input = 1;
                    Component->Flags.Output = 1;
                    Component->Version = 0;
                    Component->Key = z;
                    Component->AffinityMask = 0xffffffff;

                    //
                    // Set up identifier string = 8 digit signature - 8 digit checksum
                    // for example: 00fe964d-005467dd
                    //

                    GetDiskId(0x80 + z, DiskName);
                    
                    if (DiskName[0] == (UCHAR)NULL) {
                        strcpy(DiskName, "BIOSDISKx");
                        DiskName[8] = (UCHAR)z + (UCHAR)'1';
                    }

                    Length = strlen(DiskName) + 1;
                    fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
                    _fstrcpy(fpString, DiskName);
                    Component->IdentifierLength = Length;
                    Component->Identifier = fpString;

                    //
                    // Set up BIOS disk device specific data.
                    // (If extended int 13 drive parameters are supported by
                    //  BIOS, we will collect them and store them here.)
                    //

                    if (IsExtendedInt13Available(0x80+z)) {
                        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                                                                     sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                                                                                     sizeof(CM_DISK_GEOMETRY_DEVICE_DATA),
                                                                                     TRUE);
                        Length = GetExtendedDriveParameters(
                                                           0x80 + z,
                                                           (CM_DISK_GEOMETRY_DEVICE_DATA far *)(DescriptorList + 1)
                                                           );
                        if (Length) {
                            CurrentEntry->ConfigurationData = DescriptorList;
                            Component->ConfigurationDataLength =
                            Length + sizeof(HWRESOURCE_DESCRIPTOR_LIST);
                            DescriptorList->Count = 1;
                            DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
                            DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                            Length;
                        } else {
                            HwFreeHeap(sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                                       sizeof(CM_DISK_GEOMETRY_DEVICE_DATA));
                        }
                    }

                    if (PreviousEntry == NULL) {
                        FirstController->Child = CurrentEntry;
                    } else {
                        PreviousEntry->Sibling = CurrentEntry;
                    }
                    CurrentEntry->Parent = FirstController;
                    PreviousEntry = CurrentEntry;
                }
            }
            return (FirstController);
        }
    }
}


#pragma warning(4:4146)     // unary minus operator applied to unsigned type (checksum on line 733)
VOID
GetDiskId(
         USHORT Disk,
         PUCHAR Identifier
         )

/*++

Routine Description:

    This routine reads the master boot sector of the specified harddisk drive,
    compute the checksum of the sector to form a drive identifier.

    The identifier will be set to "8-digit-checksum"+"-"+"8-digit-signature"
    For example:  00ff6396-6549071f

Arguments:

    Disk - supplies the BIOS drive number, i.e. 80h - 87h

    Identifier - Supplies a buffer to receive the disk id.

Return Value:

    None.  In the worst case, the Identifier will be empty.

--*/

{
    UCHAR Sector[512];
    ULONG Signature, Checksum;
    USHORT i, Length;
    PUCHAR BufferAddress;
    BOOLEAN Fail;

    Identifier[0] = 0;
    BufferAddress = &Sector[0];
    Fail = FALSE;

    //
    // Read in the first sector
    //

    _asm {
        push    es
        mov     ax, 0x201
        mov     cx, 1
        mov     dx, Disk
        push    ss
        pop     es
        mov     bx, BufferAddress
        int     0x13
        pop     es
        jnc     Gdixxx

        mov     Fail, 1
        Gdixxx:
    }

    if (Fail) {
#if DBG
        // could not get the sector, so return NULL DiskID
        BlPrint("Failed to read sector -- returning NULL DiskId\n");
#endif
        return;
    }

    Signature = ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];

    //
    // compute the checksum
    //

    Checksum = 0;
    for (i = 0; i < 128; i++) {
        Checksum += ((PULONG)Sector)[i];
    }
    Checksum = -Checksum;

    //
    // Zero the identifier
    //

    for (i=0; i < 30; i++) {
        Identifier[i]='0';
    }

    //
    // Put the dashes in the right places.
    //

    Identifier[8] = '-';
    Identifier[17] = '-';

    //
    // If the boot sector has a valid partition table signature,
    // attach an 'A.'  Otherwise we use 'X.'
    //

    if (((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        Identifier[18]='X';
    } else {
        Identifier[18]='A';
    }

    //
    // Reuse sector buffer to build checksum string.
    //

    ultoa(Checksum, Sector, 16);
    Length = strlen(Sector);

    for (i=0; i<Length; i++) {
        Identifier[7-i] = Sector[Length-i-1];
    }

    //
    // Reuse sector buffer to build signature string.
    //

    ultoa(Signature, Sector, 16);
    Length = strlen(Sector);

    for (i=0; i<Length; i++) {
        Identifier[16-i] = Sector[Length-i-1];
    }

    //
    // Terminate string.
    //

    Identifier[19] = 0;

#if DBG
    BlPrint("%s\n", Identifier);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\eisa.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisa.h

Abstract:

    This module contains the i386 EISA bus specific header file.

Author:

    Shie-Lin Tzong (shielint) 6-June-1991

Revision History:

--*/

//
// SU module's version of the memory descriptor
//
typedef struct _MEMORY_LIST_ENTRY {
    ULONG BlockBase;
    ULONG BlockSize;
} MEMORY_LIST_ENTRY, *PMEMORY_LIST_ENTRY;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _BTEISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT PhysicalAddress_LSW;
    UCHAR PhysicalAddress_MSB;
    USHORT MemorySize;
} BTEISA_MEMORY_CONFIGURATION, *PBTEISA_MEMORY_CONFIGURATION;

//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _BTEISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} BTEISA_IRQ_CONFIGURATION, *PBTEISA_IRQ_CONFIGURATION;

//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIG_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIG_BYTE0;

typedef struct _DMA_CONFIG_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIG_BYTE1;

typedef struct _BTEISA_DMA_CONFIGURATION {
    DMA_CONFIG_BYTE0 ConfigurationByte0;
    DMA_CONFIG_BYTE1 ConfigurationByte1;
} BTEISA_DMA_CONFIGURATION, *PBTEISA_DMA_CONFIGURATION;

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *TEISA_PORT_DESCRIPTOR;

typedef struct _BTEISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} BTEISA_PORT_CONFIGURATION, *PBTEISA_PORT_CONFIGURATION;

typedef struct _BTEISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} BTEISA_SLOT_INFORMATION, *PBTEISA_SLOT_INFORMATION,
  far *FPBTEISA_SLOT_INFORMATION;

typedef struct _BTEISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    BTEISA_MEMORY_CONFIGURATION EisaMemory[9];
    BTEISA_IRQ_CONFIGURATION EisaIrq[7];
    BTEISA_DMA_CONFIGURATION EisaDma[4];
    BTEISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} BTEISA_FUNCTION_INFORMATION, *PBTEISA_FUNCTION_INFORMATION,
  far *FPBTEISA_FUNCTION_INFORMATION;

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86

//
// Misc. definitions
//

#define _16MEGB                  ((ULONG)16 * 1024 * 1024)
#define _64MEGB                  ((ULONG)64 * 1024 * 1024)

BOOLEAN
FindFunctionInformation (
    IN UCHAR SlotFlags,
    IN UCHAR FunctionFlags,
    OUT PBTEISA_FUNCTION_INFORMATION Buffer,
    IN BOOLEAN FromBeginning
    );

USHORT
CountMemoryBlocks (
    VOID
    );

ULONG
EisaConstructMemoryDescriptors (
    VOID
    );

UCHAR
BtGetEisaSlotInformation (
   PBTEISA_SLOT_INFORMATION SlotInformation,
   UCHAR Slot
   );

UCHAR
BtGetEisaFunctionInformation (
   PBTEISA_FUNCTION_INFORMATION FunctionInformation,
   UCHAR Slot,
   UCHAR Function
   );

BOOLEAN
BtIsEisaSystem (
   VOID
   );

//
// External References
//

extern MEMORY_LIST_ENTRY _far *MemoryDescriptorList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\diska.asm ===
title  "Int13 Drive parameter information detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    diska.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to detect/collect
;    harddisk paramter information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 22-Feb-1992
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p

;
; Standard int 13 drive parameters.
;   The parameters returned from int 13 function 8
;

Int13DriveParameters    struc

        DriveSelect     dw      0
        MaxCylinders    dd      0
        SectorsPerTrack dw      0
        MaxHeads        dw      0
        NumberDrives    dw      0

Int13DriveParameters    ends

SIZE_OF_PARAMETERS      equ     12

;
; Extended int 13 drive parameters
;   The Drive Parameters returned from int 13 function 48h
;

ExInt13DriveParameters  struc

        ExBufferSize      dw      0
        ExFlags           dw      0
        ExCylinders       dd      0
        ExHeads           dd      0
        ExSectorsPerTrack dd      0
        ExSectorsPerDrive dd      0
                          dd      0
        ExSectorSize      dw      0
        ExReserved        dw      0

ExInt13DriveParameters    ends

SIZE_OF_EXTENDED_PARAMETERS       equ     28

;
; Structure used by nt kernel Configuration Manager
;

CmDiskGeometryDeviceData struc

        CmBytesPerSector    dd      0
        CmNumberOfCylinders dd      0
        CmSectorsPerTrack   dd      0
        CmNumberOfHeads     dd      0

CmDiskGeometryDeviceData ends

SIZE_OF_CM_DISK_DATA     EQU      16

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _NumberBiosDisks
_NumberBiosDisks dw      0

RomChain        db      8 * SIZE_OF_PARAMETERS dup(?)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:_DATA, SS:NOTHING

;++
;
; VOID
; GetInt13DriveParamters (
;    OUT PUCHAR Buffer,
;    OUT PUSHORT Size
;    )
;
; Routine Description:
;
;    This function calls real mode int 13h function 8 to get drive
;    parameters for drive 80h - 87h.
;
; Arguments:
;
;    Buffer - Supplies a pointer to a buffer to receive the drive paramter
;       information.
;
;    Size - Supplies a pointer to a USHORT to receive the size of the drive
;       parameter information returned.
;
; Return Value:
;
;    None.
;
;--

        Public _GetInt13DriveParameters
_GetInt13DriveParameters        proc

        push    bp
        mov     bp, sp
        push    si
        push    bx

        mov     dx, 80h         ; Starting from drive 80h
        mov     cx, 0           ; count
        mov     si, offset RomChain ; [si]->Buffer
gidp00:
        push    cx              ; save count
        push    dx              ; save drive select

;
; First check if drive is present.  It turns out function returns drive
; parameters even when the drive is not present.
;

        mov     ah, 15h
        int     13h             ; Get type of drive
        jc      short gidp99

        cmp     ah, 0           ; if ah=0 drive is not present
        jz      gidp99

        pop     dx
        pop     cx
        push    cx
        push    dx

        mov     ah, 8           ; int 13 function 8
        int     13h             ; call int 13
        jc      short gidp99    ; if c, fail, go exit

        inc     _NumberBiosDisks
        mov     al, cl
        and     al, 3fh         ; Only want bit 0 - 5
        mov     ah, 0
        mov     [si].SectorsPerTrack, ax
        shr     cl, 6
        xchg    cl, ch
        mov     word ptr [si].MaxCylinders, cx
        mov     word ptr [si + 2].MaxCylinders, 0
        mov     byte ptr [si].MaxHeads, dh
        mov     byte ptr [si + 1].MaxHeads, 0
        mov     byte ptr [si].NumberDrives, dl
        mov     byte ptr [si + 1].NumberDrives, 0
        pop     dx              ; get back current drive number
        mov     [si].DriveSelect, dx
        inc     dx
        pop     cx              ; get back count
        inc     cx              ; increase table count
        cmp     dx, 88h         ; Are we done? (dx == 88h)
        je      short gidp100

        add     si, SIZE_OF_PARAMETERS
        jmp     gidp00

gidp99: pop     dx
        pop     cx
gidp100:
        mov     ax, offset RomChain
        mov     si, [bp + 4]    ; [si]-> variable to receive buffer addr
        mov     [si], ax        ; return buffer address
        mov     si, [bp + 6]    ; [si]-> variable to receive buffer size
        mov     ax, cx
        mov     cl, SIZE_OF_PARAMETERS
        mul     cl
        mov     [si], ax        ; return buffer size

        pop     bx
        pop     si
        pop     bp
        ret

_GetInt13DriveParameters        endp

;++
;
; BOOLEAN
; IsExtendedInt13Available
;    USHORT DriveNumber
;    )
;
; Routine Description:
;
;    This function checks if extended int13 functions available.
;
; Arguments:
;
;    DriveNumber - the drive number to check for.
;
; Return Value:
;
;    TRUE if extended int 13 service is available.  Otherwise a value of
;    FALSE is returned.
;
;--

        Public _IsExtendedInt13Available
_IsExtendedInt13Available       proc

        push    bp
        mov     bp, sp
        push    bx

        mov     dl, [bp+4]     ; get DriveNumber parameter
        mov     ah, 41h
        mov     bx, 55aah
        int     13h
        jc      short Ieda90

        cmp     bx, 0AA55h
        jne     short Ieda90

        test    cx, 1           ; bit 0 = Extended disk access is supported
        jz      short Ieda90

        mov     ax, 1
        jmp     short IedaExit
Ieda90:
        xor     eax, eax
IedaExit:
        pop     bx
        pop     bp
        ret

_IsExtendedInt13Available       endp

;++
;
; USHORT
; GetExtendedDriveParameters
;    USHORT DriveNumber,
;    FPCM_DISK_GEOMETRY_DEVICE_DATA DeviceData
;    )
;
; Routine Description:
;
;    This function use extended int13 service function 48h to get
;    drive parameters.
;
; Arguments:
;
;    DriveNumber - the drive number to get the drive parameters.
;
;    DeviceData - supplies a far pointer to a buffer to receive the parameters.
;
;
; Return Value:
;
;    Size of DeviceData.  If the extended int 13 service is not available,
;    a zero value will be returned.
;
;--

        Public _GetExtendedDriveParameters
_GetExtendedDriveParameters     proc

        push    bp
        mov     bp, sp
        push    si
        push    bx
        sub     sp, SIZE_OF_EXTENDED_PARAMETERS

        mov     dl, [bp+4]      ; get DriveNumber parameter
        mov     si, sp          ; [si]-> Local buffer
        mov     word ptr [si].ExBufferSize, SIZE_OF_EXTENDED_PARAMETERS
        mov     ah, 48h
        int     13h
        jc      short Gedp90

        or      ah, ah          ; Make sure there is no error
        jnz     short Gedp90    ; if error, exit

        cmp     [si].ExBufferSize, ExReserved
        jl      short Gedp90    ; the retruned data is too small to be useful

        mov     bx, [bp+6]
        mov     ax, [bp+8]
        mov     es, ax          ; (es:bx)->Caller's buffer
        ASSUME  es:NOTHING

        mov     eax, [si].ExCylinders
        mov     es:[bx].CmNumberOfCylinders, eax
        mov     eax, [si].ExHeads
        mov     es:[bx].CmNumberOfHeads, eax
        mov     eax, [si].ExSectorsPerTrack
        mov     es:[bx].CmSectorsPerTrack, eax
        xor     eax, eax
        mov     ax, [si].ExSectorSize
        mov     es:[bx].CmBytesPerSector, eax
        mov     ax, SIZE_OF_CM_DISK_DATA
        jmp     short GedpExit
Gedp90:
        xor     eax, eax
GedpExit:
        add     sp, SIZE_OF_EXTENDED_PARAMETERS
        pop     bx
        pop     si
        pop     bp
        ret

_GetExtendedDriveParameters     endp
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow (tomp) Mar-01-90

Abstract:

    Video support routines.

    The SU module only need to be able to write to the video display
    in order to report errors, traps, etc.

    The routines in this file all write to a video buffer assumed to be
    at realmode address b800:0000, and 4k bytes in length. The segment
    portion of the far pointers used to access the video buffer are stamped
    with a protmode selector value when we switch to protect mode. This is
    done in the routine "ProtMode" in "misc386.asm".


--*/

#include "hwdetect.h"

#if DBG

#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))


#define ROWS 25
#define COLUMNS 80
#define SCREEN_WIDTH COLUMNS
#define SCREEN_SIZE ROWS * COLUMNS
#define NORMAL_ATTRIB 0x07
#define REVERSE_ATTRIB 0x70
#define SCREEN_START 0xb8000000

//
// Internal routines
//

VOID
putc(
    IN CHAR
    );
VOID
putu(
    IN ULONG
    );

VOID
BlPuts(
    IN PCHAR
    );

VOID
puti(
    IN LONG
    );

VOID
putx(
    IN ULONG
    );

VOID
scroll(
    VOID
    );

static
VOID
tab(
    VOID
    );

static
VOID
newline(
    VOID
    );

static
VOID
putzeros(
    USHORT,
    USHORT
    );


USHORT
Redirect = 0;



//
// Used by all BlPrint subordinate routines for padding computations.
//

CHAR sc=0;
ULONG fw=0;



VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
    USHORT b,c,w,len;
    PUCHAR ap;
    ULONG l;

    //
    // Cast a pointer to the first word on the stack
    //

    ap = (PUCHAR)&cp + sizeof(PCHAR);
    sc = ' '; // default padding char is space

    //
    // Process the arguments using the descriptor string
    //


    while (b = *cp++)
        {
        if (b == '%')
            {
            c = *cp++;

            switch (c)
                {
                case 'd':
                    puti((long)*((int *)ap));
                    ap += sizeof(int);
                    break;

                case 's':
                    BlPuts(*((PCHAR *)ap));
                    ap += sizeof (char *);
                    break;

                case 'c':
                    putc(*((char *)ap));
                    ap += sizeof(int);
                    break;

                case 'x':
                    w = *((USHORT *)ap);
                    len = ZLEN_SHORT(w);
                    while(len--) putc('0');
                    putx((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'u':
                    putu((ULONG)*((USHORT *)ap));
                    ap += sizeof(int);
                    break;

                case 'l':
                    c = *cp++;

                switch(c) {

                    case 'u':
                        putu(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'x':
                        l = *((ULONG *)ap);
                        len = ZLEN_LONG(l);
                        while(len--) putc('0');
                        putx(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                    case 'd':
                        puti(*((ULONG *)ap));
                        ap += sizeof(long);
                        break;

                }
                break;

                default :
                    putc((char)b);
                    putc((char)c);
                }
            }
        else
            putc((char)b);
        }

}

FPUCHAR vp = (FPUCHAR)SCREEN_START;
FPUCHAR ScreenStart = (FPUCHAR)SCREEN_START;

static int lcnt = 0;
static int row  = 0;


VOID BlPuts(
    PCHAR cp
    )
/*++

Routine Description:

    Writes a string on the display at the current cursor position

Arguments:

    cp - pointer to ASCIIZ string to display.


Returns:

    Nothing



--*/


{
    char c;

    while(c = *cp++)
        putc(c);
}


//
// Write a hex short to display
//


VOID putx(
    ULONG x
    )
/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x  - ulong to write.

Returns:

    Nothing


--*/

{
    ULONG j;

    if (x/16)
        putx(x/16);

    if((j=x%16) > 9) {
        putc((char)(j+'A'- 10));
    } else {
        putc((char)(j+'0'));
    }
}


VOID puti(
    LONG i
    )
/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing


--*/


{
    if (i<0)
        {
        i = -i;
        putc((char)'-');
        }

    if (i/10)
        puti(i/10);

    putc((char)((i%10)+'0'));
}



VOID putu(
    ULONG u
    )
/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned


--*/

{
    if (u/10)
        putu(u/10);

    putc((char)((u%10)+'0'));

}


VOID putc(
    CHAR c
    )
/*++

Routine Description:

    Writes a character on the display at the current position.

Arguments:

    c - character to write


Returns:

    Nothing


--*/

{
    switch (c)
        {
        case '\n':
            newline();
            break;

        case '\t':
            tab();
            break;

        default :
            if (FP_OFF(vp) >= (SCREEN_SIZE * 2)) {
                vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
                scroll();
            }
            *vp = c;
            vp += 2;
            ++lcnt;
      }
}


VOID newline(
    VOID
    )
/*++

Routine Description:

    Moves the cursor to the beginning of the next line. If the bottom
    of the display has been reached, the screen is scrolled one line up.

Arguments:

    None


Returns:

    Nothing


--*/

{
    vp += (SCREEN_WIDTH - lcnt)<<1;

    if (++row > ROWS-1) {

        vp = (FPUCHAR)((ScreenStart + (2*SCREEN_WIDTH*(ROWS-1))));
        scroll();

    }

    lcnt = 0;

}


VOID scroll(
    VOID
    )
/*++

Routine Description:

    Scrolls the display UP one line.

Arguments:

    None

Returns:

    Nothing

Notes:

    Currently we scroll the display by reading and writing directly from
    and to the video display buffer. We optionally switch to real mode
    and to int 10s

--*/

{
    USHORT i,j;
    USHORT far *p1 = (USHORT far *)ScreenStart;
    USHORT far *p2 = (USHORT far *)(ScreenStart + 2*SCREEN_WIDTH) ;

    for (i=0; i < ROWS - 1; i++)
        for (j=0; j < SCREEN_WIDTH; j++)
            *p1++ = *p2++;

    for (i=0; i < SCREEN_WIDTH; i++)
        *p1++ = REVERSE_ATTRIB*256 + ' ';

}


static
VOID tab(
    VOID
    )
/*++

Routine Description:


    Computes the next tab stop and moves the cursor to that location.


Arguments:


    None


Returns:

    Nothing

--*/

{
    int inc;

    inc = 8 - (lcnt % 8);
    vp += inc<<1;
    lcnt += inc;
}


VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
    int i,a;
    unsigned far *vwp = (unsigned far *)SCREEN_START;
    a = REVERSE_ATTRIB*256 + ' ';

    for (i = SCREEN_SIZE ; i ; i--)
        *vwp++ = a;

    row  = 0;
    lcnt = 0;
    vp = (FPUCHAR)ScreenStart;

}

#else

VOID
BlPrint(
    PCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.


Returns:

    Nothing


--*/

{
}

VOID clrscrn(
    VOID
    )
/*++

Routine Description:

    Clears the video display by writing blanks with the current
    video attribute over the entire display.


Arguments:

    None

Returns:

    Nothing


--*/

{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwapm.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwapm.c

Abstract:

Author:


Environment:

    Real mode.

Revision History:

--*/


#include "hwdetect.h"
#include <string.h>


#include "apm.h"
#include <ntapmsdk.h>

ULONG
HwWriteLog(
    PUCHAR  p,
    UCHAR   loc,
    ULONG  data
    );

UCHAR   DetName[] = "DETLOG1";

VOID Int15 (PULONG, PULONG, PULONG, PULONG, PULONG);

BOOLEAN
HwGetApmSystemData(
    PVOID   Buf
    )
{
    PAPM_REGISTRY_INFO  ApmEntry;
    ULONG       RegEax, RegEbx, RegEcx, RegEdx, CyFlag;
    UCHAR       ApmMajor, ApmMinor;
    PUCHAR      lp, p;

    ApmEntry = Buf;

    ApmEntry->Signature[0] = 'A';
    ApmEntry->Signature[1] = 'P';
    ApmEntry->Signature[2] = 'M';

    ApmEntry->Valid = 0;

    lp = &(ApmEntry->DetectLog[0]);
    p = DetName;

    while (*p != '\0') {
        *lp = *p;
        p++;
        lp++;
    }

    //
    // Perform APM installation check
    //
    RegEax = APM_INSTALLATION_CHECK;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag ||
        (RegEbx & 0xff) != 'M'  ||
        ((RegEbx >> 8) & 0xff) != 'P') {

        //
        // this is a case where int15 says apm just isn't there,
        // so tell the caller to not even create the node
        //
        return FALSE;
    }

    //
    // If we get here, we have an APM bios.  If we just call it,
    // we may get grief.  So we will connect in real mode, then
    // set our version to whatever the driver says it is, or 1.2,
    // whichever is LESS.  Then query options again.
    //

    ApmMajor = (UCHAR) (RegEax >> 8) & 0xff;
    ApmMinor = (UCHAR) RegEax & 0xff;

    if (ApmMajor > 1) ApmMajor = 1;
    if (ApmMinor > 2) ApmMinor = 2;

    //
    // Connect to Real mode interface
    //
    RegEax = APM_REAL_MODE_CONNECT;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'A', RegEax);
        return TRUE;
    }

    //
    // Call APM Driver Version in real mode, and set the driver
    // version to be MIN(v1.2, apm version of the machine)
    //
    RegEax = APM_DRIVER_VERSION;
    RegEbx = APM_DEVICE_BIOS;
    RegEcx = ((ApmMajor << 8) | ApmMinor) & 0xffff;

    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'B', RegEax);
        return TRUE;
    }


    //
    // Perform APM installation check again
    //
    RegEax = APM_INSTALLATION_CHECK;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'C', RegEax);
        return TRUE;
    }

    ApmEntry->ApmRevMajor = (UCHAR) (RegEax >> 8) & 0xff;
    ApmEntry->ApmRevMinor = (UCHAR) RegEax & 0xff;
    ApmEntry->ApmInstallFlags = (USHORT) RegEcx;

    //
    // Disconnect from real mode interface
    //
    RegEax = APM_DISCONNECT;
    RegEbx = APM_DEVICE_BIOS;
    Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

    if (CyFlag) {
        lp += HwWriteLog(lp, 'D', RegEax);
        return TRUE;
    }

    //
    // If we get this far, there's an APM bios in the machine,
    // and we've told it that we're the latest version we think
    // it and we like, so now, in theory, things should just work....
    //


    if (ApmEntry->ApmInstallFlags & APM_MODE_16BIT) {

        //
        // Connect to 16 bit interface
        //
        RegEax = APM_PROTECT_MODE_16bit_CONNECT;
        RegEbx = APM_DEVICE_BIOS;
        Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

        if (CyFlag) {
            lp += HwWriteLog(lp, 'E', RegEax);
            return TRUE;
        }

        ApmEntry->Code16BitSegment       = (USHORT) RegEax;
        ApmEntry->Code16BitOffset        = (USHORT) RegEbx;
        ApmEntry->Data16BitSegment       = (USHORT) RegEcx;

        //
        // On most bioses, the following call just works.
        // On some, it doesn't, and their authors point at the spec.
        // And finally, most bioses don't seem to need this call
        // in the first place.
        // We cannot do it in ntapm.sys because it's on the loader's
        // hibernate resume path as well as here.
        //
        // SO> make the call, report any error, but IGNORE it.
        //

        RegEax = APM_DRIVER_VERSION;
        RegEbx = APM_DEVICE_BIOS;
        RegEcx = ((ApmMajor << 8) | ApmMinor) & 0xffff;

        Int15 (&RegEax, &RegEbx, &RegEcx, &RegEdx, &CyFlag);

        if (CyFlag) {
            lp += HwWriteLog(lp, 'F', RegEax);
            ApmEntry->Valid = 1;  // pretend it worked....
            return TRUE;
        }

        ApmEntry->Valid = 1;
        return TRUE;
    }

    HwWriteLog(lp, 'H', ApmEntry->ApmInstallFlags);
    return TRUE;
}

ULONG
HwWriteLog(
    PUCHAR  p,
    UCHAR   loc,
    ULONG   data
    )
{
    p[0] = loc;
    p[1] = (UCHAR)(data & 0xff);
    p[2] = (UCHAR)((data & 0xff00) >> 8);
    return 4;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwdetect.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwdetect.c

Abstract:

    This is the main hardware detection module.  Its main function is
    to detect various system hardware and build a configuration tree.

    N.B. The configuration built in the detection module will needs to
    be adjusted later before we switch to FLAT mode.  The is because
    all the "POINTER" is a far pointer instead of a flat pointer.

Author:

    Shie-Lin Tzong (shielint) 16-Jan-92


Environment:

    Real mode.

Revision History:

    Kenneth Ray     (kenray)   Jan-1998
      - Add: get docking station info from PnP BIOS and add to firmware tree

--*/

#include "hwdetect.h"
typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);
typedef PVOID PDEVICE_OBJECT;
#include "pci.h"
#include <string.h>
#include "apm.h"
#include <ntapmsdk.h>
#include "pcibios.h"
#include "pcienum.h"

#if DBG

PUCHAR TypeName[] = {
    "ArcSystem",
    "CentralProcessor",
    "FloatingPointProcessor",
    "PrimaryICache",
    "PrimaryDCache",
    "SecondaryICache",
    "SecondaryDCache",
    "SecondaryCache",
    "EisaAdapter",
    "TcaAdapter",
    "ScsiAdapter",
    "DtiAdapter",
    "MultifunctionAdapter",
    "DiskController",
    "TapeController",
    "CdRomController",
    "WormController",
    "SerialController",
    "NetworkController",
    "DisplayController",
    "ParallelController",
    "PointerController",
    "KeyboardController",
    "AudioController",
    "OtherController",
    "DiskPeripheral",
    "FloppyDiskPeripheral",
    "TapePeripheral",
    "ModemPeripheral",
    "MonitorPeripheral",
    "PrinterPeripheral",
    "PointerPeripheral",
    "KeyboardPeripheral",
    "TerminalPeripheral",
    "OtherPeripheral",
    "LinePeripheral",
    "NetworkPeripheral",
    "SystemMemory",
    "DockingInformation",
    "RealModeIrqRoutingTable",
    "RealModePCIEnumeration",
    "MaximumType"
    };

VOID
CheckConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     );

extern
USHORT
HwGetKey(
    VOID
    );
#endif

VOID
GetIrqFromEisaData(
     FPFWCONFIGURATION_COMPONENT_DATA ControllerList,
     CONFIGURATION_TYPE ControllerType
     );

//
// HwBusType - defines the BUS type of the machine.
//     This variable is used by detection code only.
//

USHORT HwBusType = 0;

//
// AdapterEntry is the Configuration_Component_data for the bus adapter
//

FPFWCONFIGURATION_COMPONENT_DATA  AdapterEntry = NULL;

//
// FpRomBlock - A far pointer to our Rom Block
//

FPUCHAR FpRomBlock = NULL;
USHORT RomBlockLength = 0;

//
// HwEisaConfigurationData - A far pointer to the EISA configuration
//   data on EISA machine.
//

FPUCHAR HwEisaConfigurationData = NULL;
ULONG HwEisaConfigurationSize = 0L;

//
// DisableSerialMice - A bit flags to indicate the comports whose serial
//     mouse detection should be skipped.
//

USHORT DisableSerialMice = 0x0;

//
// FastDetect - A boolean value indicating if we should skip detection of
//      unsupported devices or devices that are detected by NT proper
//
UCHAR FastDetect = 0x0;

//
// DisablePccardIrqScan - A boolean value indicating if we should skip
//      detection of usable IRQs connected to pccard controllers
//
UCHAR DisablePccardIrqScan = 0;

//
// NoIRQRouting - Skip calling PCI BIOS to get IRQ routing options.
//

UCHAR NoIRQRouting = 0;

//
// PCIEnum - Enumerating the devices on the PCI Buses. Off by default.
//

UCHAR PCIEnum = 0;

//
// NoLegacy - Skip keyboard and all of the above.
//

UCHAR NoLegacy = 0;

//
// Internal references and definitions.
//

typedef enum _RELATIONSHIP_FLAGS {
    Child,
    Sibling,
    Parent
} RELATIONSHIP_FLAGS;


VOID
HardwareDetection(
     ULONG HeapStart,
     ULONG HeapSize,
     ULONG ConfigurationTree,
     ULONG HeapUsed,
     ULONG OptionString,
     ULONG OptionStringLength
     )
/*++

Routine Description:

    Main entrypoint of the HW recognizer test.  The routine builds
    a configuration tree and leaves it in the hardware heap.

Arguments:

    HeapStart - Supplies the starting address of the configuaration heap.

    HeapSize - Supplies the size of the heap in byte.

    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
        receive the hardware configuration tree.

    HeapUsed - Supplies a 32 bit FLAT address of the variable to receive
        the actual heap size in used.

    OptionString - Supplies a 32 bit FLAT address of load option string.

    OptionStringLength - Supplies the length of the OptionString

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA ConfigurationRoot;
    FPFWCONFIGURATION_COMPONENT_DATA FirstCom = NULL, FirstLpt = NULL;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry;
    FPFWCONFIGURATION_COMPONENT_DATA AcpiAdapterEntry = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    RELATIONSHIP_FLAGS NextRelationship;
    CHAR Identifier[256];
    USHORT BiosYear, BiosMonth, BiosDay;
    PUCHAR MachineId;
    USHORT Length, InitialLength, i, Count = 0;
    USHORT PnPBiosLength, SMBIOSLength;
    FPCHAR IdentifierString;
    PMOUSE_INFORMATION MouseInfo = 0;
    USHORT KeyboardId = 0;
    ULONG VideoAdapterType = 0;
    FPULONG BlConfigurationTree = NULL;
    FPULONG BlHeapUsed = NULL;
    FPCHAR BlOptions, EndOptions;
    PUCHAR RomChain;
    FPUCHAR FpRomChain = NULL, ConfigurationData, EndConfigurationData;
    SHORT FreeSize;
    FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    PCI_REGISTRY_INFO PciEntry;
    APM_REGISTRY_INFO ApmEntry;
    ULONG nDevIt;
    USHORT PCIDeviceCount = 0;


    DOCKING_STATION_INFO DockInfo = { 0, 0, 0, FW_DOCKINFO_BIOS_NOT_CALLED };
    FPPCI_IRQ_ROUTING_TABLE IrqRoutingTable;

    //
    // First initialize our hardware heap.
    //

    HwInitializeHeap(HeapStart, HeapSize);

    MAKE_FP(BlConfigurationTree, ConfigurationTree);
    MAKE_FP(BlHeapUsed, HeapUsed);
    MAKE_FP(BlOptions, OptionString);

    //
    // Parse OptionString to look for various ntdetect options
    //
    if (BlOptions && OptionStringLength <= 0x1000L && OptionStringLength > 0L) {
        EndOptions = BlOptions + OptionStringLength;

        if (*EndOptions == '\0') {

            if (_fstrstr(BlOptions, "NOIRQSCAN")) {
                DisablePccardIrqScan = 1;
            }

            if (_fstrstr(BlOptions, "NOIRQROUTING")) {
                NoIRQRouting = 1;
            }

            if (_fstrstr(BlOptions, "PCIENUM") ||
                _fstrstr(BlOptions, "RDBUILD") ) {
                PCIEnum = 1; // enable PCI enumeration
            }

            if (_fstrstr(BlOptions, "NOLEGACY")) {
                DisableSerialMice = 0xffff;
                FastDetect = 0x1;
                NoLegacy = 1;
            }

            if (_fstrstr(BlOptions, "FASTDETECT")) {
                DisableSerialMice = 0xffff;
                FastDetect = 0x1;
            } else {
                do {
                    if (BlOptions = _fstrstr(BlOptions, "NOSERIALMICE")) {
                        BlOptions += strlen("NOSERIALMICE");
                        while ((*BlOptions == ' ') || (*BlOptions == ':') ||
                               (*BlOptions == '=')) {
                            BlOptions++;
                        }

                        if (*BlOptions == 'C' && BlOptions[1] == 'O' &&
                            BlOptions[2] == 'M') {
                            BlOptions += 3;
                            while (TRUE) {
                                while (*BlOptions != '\0' && (*BlOptions == ' ' ||
                                       *BlOptions == ',' || *BlOptions == ';' ||
                                       *BlOptions == '0')) {
                                    BlOptions++;
                                }
                                if (*BlOptions >= '0' && *BlOptions <= '9') {
                                    if (BlOptions[1] < '0' || BlOptions[1] > '9') {
                                        DisableSerialMice |= 1 << (*BlOptions - '0');
                                        BlOptions++;
                                    } else {
                                        BlOptions++;
                                        while (*BlOptions && *BlOptions <= '9' &&
                                               *BlOptions >= '0') {
                                               BlOptions++;
                                        }
                                    }
                                } else {
                                    break;
                                }
                            }
                        } else {
                            DisableSerialMice = 0xffff;
                            break;
                        }
                    }
                } while (BlOptions && *BlOptions && (BlOptions < EndOptions)); // double checking
            }

        }
    }

    //
    // Determine bus type
    //

    if (HwIsEisaSystem()) {
        HwBusType = MACHINE_TYPE_EISA;
    } else {
        HwBusType = MACHINE_TYPE_ISA;
    }

    //
    // Allocate heap space for System component and initialize it.
    // Also make the System component the root of configuration tree.
    //

#if DBG
    clrscrn ();
    BlPrint("Detecting System Component ...\n");
#endif

    ConfigurationRoot = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                        sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    Component = &ConfigurationRoot->ComponentEntry;

    Component->Class = SystemClass;
    Component->Type = MaximumType;          // NOTE should be IsaCompatible
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0;
    Component->ConfigurationDataLength = 0;
    MachineId = "AT/AT COMPATIBLE";
    if (MachineId) {
        Length = strlen(MachineId) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, MachineId);
        Component->Identifier = IdentifierString;
        Component->IdentifierLength = Length;
    } else {
        Component->Identifier = 0;
        Component->IdentifierLength = 0;
    }
    NextRelationship = Child;
    PreviousEntry = ConfigurationRoot;

#if DBG
    BlPrint("Reading BIOS date ...\n");
#endif

    HwGetBiosDate (0xF0000, 0xFFFF, &BiosYear, &BiosMonth, &BiosDay);

#if DBG
    BlPrint("Done reading BIOS date (%d/%d/%d)\n",
                BiosMonth, BiosDay, BiosYear);

    BlPrint("Detecting PCI Bus Component ...\n");
#endif

    if (BiosYear > 1992 ||  (BiosYear == 1992  &&  BiosMonth >= 11) ) {

        // Bios date valid for pci presence check..
        HwGetPciSystemData((PVOID) &PciEntry, TRUE);

    } else {

        // Bios date not confirmed...
        HwGetPciSystemData((PVOID) &PciEntry, FALSE);
    }

    // If this is a PCI machine, we may need to get the IRQ routing table...
    //
    if (PciEntry.NoBuses)
    {
        // Add a PCI BIOS entry under the multi function key.
        // This will hold the irq routing table if it can be retrieved.
        //
        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA) HwAllocateHeap (
                sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
        Component = &AdapterEntry->ComponentEntry;
        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PCI BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        //
        // Add it to the tree
        //

        if (NextRelationship == Sibling) {
             PreviousEntry->Sibling = AdapterEntry;
             AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
             PreviousEntry->Child = AdapterEntry;
             AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;

        //
        // Now deal with the IRQ routing table if we need to.
        //

        if (NoIRQRouting) {
#if DBG
        BlPrint("\nSkipping calling PCI BIOS to get IRQ routing table...\n");
#endif
        } else {

            //
            // Add RealMode IRQ Routing Table to the tree
            //
#if DBG
        BlPrint("\nCalling PCI BIOS to get IRQ Routing table...\n");
#endif // DBG

            IrqRoutingTable = HwGetRealModeIrqRoutingTable();
            if (IrqRoutingTable)
            {
                CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                                      sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
                strcpy (Identifier, "PCI Real-mode IRQ Routing Table");
                i = strlen(Identifier) + 1;
                IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
                _fstrcpy(IdentifierString, Identifier);

                Component = &CurrentEntry->ComponentEntry;
                Component->Class = PeripheralClass;
                Component->Type = RealModeIrqRoutingTable;
                Component->Version = 0;
                Component->Key = 0;
                Component->AffinityMask = 0xffffffff;
                Component->IdentifierLength = i;
                Component->Identifier = IdentifierString;

                Length = IrqRoutingTable->TableSize + DATA_HEADER_SIZE;
                CurrentEntry->ConfigurationData =
                    (FPHWRESOURCE_DESCRIPTOR_LIST) HwAllocateHeap (Length, TRUE);

                Component->ConfigurationDataLength = Length;
                _fmemcpy((FPUCHAR) CurrentEntry->ConfigurationData + DATA_HEADER_SIZE,
                         IrqRoutingTable,
                         Length - DATA_HEADER_SIZE);

                HwSetUpFreeFormDataHeader(
                        (FPHWRESOURCE_DESCRIPTOR_LIST) CurrentEntry->ConfigurationData,
                        0,
                        0,
                        0,
                        Length - DATA_HEADER_SIZE
                        );

                //
                // Add it to tree
                //

                AdapterEntry->Child = CurrentEntry;
                CurrentEntry->Parent = AdapterEntry;
            }
#if DBG
        BlPrint("Getting IRQ Routing table from PCI BIOS complete...\n");
#endif // DBG
        }
    }

    //
    // Add a registry entry for each PCI bus
    //

    for (i=0; i < PciEntry.NoBuses; i++) {

        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &AdapterEntry->ComponentEntry;
        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PCI");
        Length = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = Length;
        Component->Identifier = IdentifierString;

        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

        if (i == 0) {
            //
            // For the first PCI bus include the PCI_REGISTRY_INFO
            //

            Length = sizeof(PCI_REGISTRY_INFO) + DATA_HEADER_SIZE;
            ConfigurationData = (FPUCHAR) HwAllocateHeap(Length, TRUE);

            Component->ConfigurationDataLength = Length;
            AdapterEntry->ConfigurationData = ConfigurationData;

            _fmemcpy ( ((FPUCHAR) ConfigurationData+DATA_HEADER_SIZE),
                       (FPVOID) &PciEntry, sizeof (PCI_REGISTRY_INFO));

            HwSetUpFreeFormDataHeader(
                    (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                    0,
                    0,
                    0,
                    Length - DATA_HEADER_SIZE
                    );
        }

        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;
    }

#if DBG
    BlPrint("Detecting PCI Bus Component completes ...\n");
#endif

    //
    // Enumerate the PCI Devices.
    //

    if (PCIEnum == 0 || PciEntry.NoBuses == 0) {
#if DBG
    BlPrint("\nSkipping enumeration of PCI devices...\n");
#endif
    } else {
        //
        // Enumerate PCI Devices
        //
#if DBG
        clrscrn ();
        BlPrint("\nEnumerating PCI Devices...\n");
#endif // DBG

        PciInit(&PciEntry);

        //
        // Count the devices
        //

        for (nDevIt = 0; (nDevIt = PciFindDevice(0, 0, nDevIt)) != 0;) {
            PCIDeviceCount++;
        }

#if DBG
        BlPrint("Found %d PCI devices\n", PCIDeviceCount );
#endif 

        CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
        strcpy (Identifier, "PCI Devices");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component = &CurrentEntry->ComponentEntry;
        Component->Class = PeripheralClass;
        Component->Type = RealModePCIEnumeration;
        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        Length = (( sizeof( USHORT ) + sizeof( PCI_COMMON_CONFIG )) * PCIDeviceCount) + DATA_HEADER_SIZE;
        CurrentEntry->ConfigurationData =
            (FPHWRESOURCE_DESCRIPTOR_LIST) HwAllocateHeap (Length, TRUE);

#if DBG
        if (CurrentEntry->ConfigurationData == NULL ) {
            BlPrint("Failed to allocate %d bytes for PCI Devices\n", Length );
        }
#endif

        Component->ConfigurationDataLength = Length;

        //        
        // Fill in Device Information
        //
        PCIDeviceCount = 0;
        
        for (nDevIt = 0; (nDevIt = PciFindDevice(0, 0, nDevIt)) != 0;) {
            FPUCHAR pCurrent;
            PCI_COMMON_CONFIG config;

            PciReadConfig(nDevIt, 0, (UCHAR*)&config, sizeof(config));

            pCurrent = (FPUCHAR) CurrentEntry->ConfigurationData + DATA_HEADER_SIZE + ( PCIDeviceCount * ( sizeof( USHORT) + sizeof ( PCI_COMMON_CONFIG ) ) );

            *(FPUSHORT)pCurrent = PCI_ITERATOR_TO_BUSDEVFUNC(nDevIt);
            
            _fmemcpy(pCurrent + sizeof( USHORT ),
                     &config,
                     sizeof ( USHORT ) + sizeof ( PCI_COMMON_CONFIG ) );
#if DBG
            {
                USHORT x = (config.BaseClass << 8) + config.SubClass;
                
                BlPrint("%d: %d.%d.%d: PCI\\VEN_%x&DEV_%x&SUBSYS_%x%x&REV_%x&CC_%x", 
                    PCIDeviceCount,
                    PCI_ITERATOR_TO_BUS(nDevIt), 
                    PCI_ITERATOR_TO_DEVICE(nDevIt), 
                    PCI_ITERATOR_TO_FUNCTION(nDevIt), 
                    config.VendorID, 
                    config.DeviceID, 
                    config.u.type0.SubSystemID, 
                    config.u.type0.SubVendorID, 
                    config.RevisionID,
                    x );

                if ( (config.HeaderType & (~PCI_MULTIFUNCTION) ) == PCI_BRIDGE_TYPE) {
                    BlPrint(" Brdg %d->%d\n", 
                        config.u.type1.PrimaryBus,
                        config.u.type1.SecondaryBus );
                } else {
                    BlPrint("\n");
                }
            }           
#endif
            PCIDeviceCount++;
        }

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) CurrentEntry->ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //

        AdapterEntry->Child = CurrentEntry;
        CurrentEntry->Parent = AdapterEntry;

#if DBG
        BlPrint("Enumerating PCI devices complete...\n");
        while ( ! HwGetKey ());
        clrscrn();
#endif // DBG

#if DBG
        //
        // Scan the PCI Bus via the bios
        //
        ScanPCIViaBIOS(&PciEntry);
#endif 

    }

    if (!NoLegacy) {
#if DBG
        BlPrint("Detecting APM Bus Component ...\n");
#endif

        if (HwGetApmSystemData((PVOID) &ApmEntry)) {
            AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

            Component = &AdapterEntry->ComponentEntry;
            Component->Class = AdapterClass;
            Component->Type = MultiFunctionAdapter;

            strcpy (Identifier, "APM");
            Length = strlen(Identifier) + 1;
            IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
            _fstrcpy(IdentifierString, Identifier);

            Component->Version = 0;
            Component->Key = 0;
            Component->AffinityMask = 0xffffffff;
            Component->IdentifierLength = Length;
            Component->Identifier = IdentifierString;

            AdapterEntry->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;

            //

            Length = sizeof(APM_REGISTRY_INFO) + DATA_HEADER_SIZE;
            ConfigurationData = (FPUCHAR) HwAllocateHeap(Length, TRUE);

            Component->ConfigurationDataLength = Length;
            AdapterEntry->ConfigurationData = ConfigurationData;

            _fmemcpy ( ((FPUCHAR) ConfigurationData+DATA_HEADER_SIZE),
                       (FPVOID) &ApmEntry, sizeof (APM_REGISTRY_INFO));

            HwSetUpFreeFormDataHeader(
                    (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                    0,
                    0,
                    0,
                    Length - DATA_HEADER_SIZE
                    );

            //
            // Add it to tree
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = AdapterEntry;
                AdapterEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = AdapterEntry;
                AdapterEntry->Parent = PreviousEntry;
            }

            NextRelationship = Sibling;
            PreviousEntry = AdapterEntry;
        }
#if DBG
    BlPrint("APM Data collection complete...\n");
#endif // DBG
    }


#if DBG
    BlPrint("Detecting PnP BIOS Bus Component ...\n");
#endif

    if (HwGetPnpBiosSystemData(&ConfigurationData,
                               &PnPBiosLength,
                               &SMBIOSLength,
                               &DockInfo)) {
        AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        AdapterEntry->ConfigurationData = ConfigurationData;
        Component = &AdapterEntry->ComponentEntry;
        Component->ConfigurationDataLength = PnPBiosLength +
                                             SMBIOSLength +
                                             DATA_HEADER_SIZE +
                                        sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR);

        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "PNP BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                0,
                1,
                0,
                PnPBiosLength
                );
        ((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData)->Count = 2;

        //
        // Setup SMBIOS PartialDescriptor
        Descriptor = (FPHWPARTIAL_RESOURCE_DESCRIPTOR)(ConfigurationData +
                                                        PnPBiosLength +
                                                        DATA_HEADER_SIZE);
        Descriptor->Type = RESOURCE_DEVICE_DATA;
        Descriptor->ShareDisposition = 0;
        Descriptor->Flags = 0;
        Descriptor->u.DeviceSpecificData.DataSize = SMBIOSLength;
        Descriptor->u.DeviceSpecificData.Reserved1 = 0;
        Descriptor->u.DeviceSpecificData.Reserved2 = 0;


        //
        // Add it to tree
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = AdapterEntry;
            AdapterEntry->Parent = PreviousEntry;
        }

        NextRelationship = Sibling;
        PreviousEntry = AdapterEntry;

        //
        // Add Docking Information to tree
        //

        CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                              sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        strcpy (Identifier, "Docking State Information");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component = &CurrentEntry->ComponentEntry;
        Component->Class = PeripheralClass;
        Component->Type = DockingInformation;
        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        Length = sizeof (DockInfo) + DATA_HEADER_SIZE;
        CurrentEntry->ConfigurationData =
            (FPHWRESOURCE_DESCRIPTOR_LIST) HwAllocateHeap (Length, TRUE);

        Component->ConfigurationDataLength = Length;
        _fmemcpy((FPCHAR) CurrentEntry->ConfigurationData + DATA_HEADER_SIZE,
                 &DockInfo,
                 Length - DATA_HEADER_SIZE);

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) CurrentEntry->ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        AdapterEntry->Child = CurrentEntry;
        CurrentEntry->Parent = AdapterEntry;

    }
#if DBG
    BlPrint("PnP BIOS Data collection complete...\n");
#endif // DBG

    //
    // Allocate heap space for Bus component and initialize it.
    //

#if DBG
    BlPrint("Detecting Bus/Adapter Component ...\n");
#endif

    AdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                   sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &AdapterEntry->ComponentEntry;

    Component->Class = AdapterClass;

    //
    // The assumption here is that the machine has only one
    // type of IO bus.  If a machine has more than one types of
    // IO buses, it will not use this detection code anyway.
    //

    if (HwBusType == MACHINE_TYPE_EISA) {

        //
        // Note We don't collect EISA config data here.  Because we may
        // exhaust the heap space.  We will collect the data after all
        // the other components are detected.
        //

        Component->Type = EisaAdapter;
        strcpy(Identifier, "EISA");
        AdapterEntry->ConfigurationData = NULL;
        Component->ConfigurationDataLength = 0;

    } else {

        //
        // If not EISA, it must be ISA
        //

        Component->Type = MultiFunctionAdapter;
        strcpy(Identifier, "ISA");
    }
    Length = strlen(Identifier) + 1;
    IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(IdentifierString, Identifier);
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;

    //
    // Make Adapter component System's child
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

    //
    // Collect BIOS information for ConfigurationRoot component.
    // This step is done here because we need data collected in
    // adapter component.  The ConfigurationData is:
    //      HWRESOURCE_DESCRIPTOR_LIST header
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Parameter Table
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Rom Blocks.
    // (Note DATA_HEADER_SIZE contains the size of the first partial
    //  descriptor already.)
    //

#if DBG
    BlPrint("Collecting Disk Geometry...\n");
#endif

    GetInt13DriveParameters((PVOID)&RomChain, &Length);
    InitialLength = (USHORT)(Length + RESERVED_ROM_BLOCK_LIST_SIZE + DATA_HEADER_SIZE +
                    sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    ConfigurationData = (FPUCHAR)HwAllocateHeap(InitialLength, FALSE);
    EndConfigurationData = ConfigurationData + DATA_HEADER_SIZE;
    if (Length != 0) {
        FpRomChain = EndConfigurationData;
        _fmemcpy(FpRomChain, (FPVOID)RomChain, Length);
    }
    EndConfigurationData += (sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                             Length);
    HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                              0,
                              0,
                              0,
                              Length
                              );

    //
    // Scan ROM to collect all the ROM blocks, if possible.
    //

#if DBG
    BlPrint("Detecting ROM Blocks...\n");
#endif

    FpRomBlock = EndConfigurationData;
    GetRomBlocks(FpRomBlock, &Length);
    RomBlockLength = Length;
    if (Length != 0) {
        EndConfigurationData += Length;
    } else {
        FpRomBlock = NULL;
    }

    //
    // We have both RomChain and RomBlock information/Headers.
    //

    DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData;
    DescriptorList->Count = 2;
    Descriptor = (FPHWPARTIAL_RESOURCE_DESCRIPTOR)(
                 EndConfigurationData - Length -
                 sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    Descriptor->Type = RESOURCE_DEVICE_DATA;
    Descriptor->ShareDisposition = 0;
    Descriptor->Flags = 0;
    Descriptor->u.DeviceSpecificData.DataSize = (ULONG)Length;
    Descriptor->u.DeviceSpecificData.Reserved1 = 0;
    Descriptor->u.DeviceSpecificData.Reserved2 = 0;

    Length = (USHORT)(MAKE_FLAT_ADDRESS(EndConfigurationData) -
             MAKE_FLAT_ADDRESS(ConfigurationData));
    ConfigurationRoot->ComponentEntry.ConfigurationDataLength = Length;
    ConfigurationRoot->ConfigurationData = ConfigurationData;
    FreeSize = InitialLength - Length;

    HwFreeHeap((ULONG)FreeSize);

    //
    // Set up device information structure for Keyboard.
    //

#if DBG
    BlPrint("Detecting Keyboard Component ...\n");
#endif
    if (NoLegacy) {
        //
        // Do not touch the hardware because there may not be a ports 60/64 on
        // the machine and we will hang if we try to touch them
        //
        KeyboardId = UNKNOWN_KEYBOARD;
    }
    else {
        //
        // Touch the hardware to try to determine an ID
        //
        KeyboardId = GetKeyboardId();
    }

    CurrentEntry = SetKeyboardConfigurationData(KeyboardId);

    //
    // Make display component the child of Adapter component.
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;

    if (!NoLegacy) {
        //
        // Set up device information for com port (Each COM component
        // is treated as a controller class.)
        //

#if DBG
    BlPrint("Detecting ComPort Component ...\n");
#endif

        if (CurrentEntry = GetComportInformation()) {

            FirstCom = CurrentEntry;

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
            } else {
                PreviousEntry->Child = CurrentEntry;
            }
            while (CurrentEntry) {
                CurrentEntry->Parent = AdapterEntry;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

        //
        // Set up device information for parallel port.  (Each parallel
        // is treated as a controller class.)
        //

#if DBG
    BlPrint("Detecting Parallel Component ...\n");
#endif

        if (CurrentEntry = GetLptInformation()) {

            FirstLpt = CurrentEntry;

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
            while (CurrentEntry) {
                CurrentEntry->Parent = PreviousEntry->Parent;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

        //
        // Set up device information structure for Mouse.
        //

#if DBG
    BlPrint("Detecting Mouse Component ...\n");
#endif

        if (CurrentEntry = GetMouseInformation()) {

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
            while (CurrentEntry) {
                CurrentEntry->Parent = PreviousEntry->Parent;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }
    }

        //
        // Set up device information for floppy drives. (The returned information
        // is a tree structure.)
        //

#if DBG
    BlPrint("Detecting Floppy Component ...\n");
#endif

        if (CurrentEntry = GetFloppyInformation()) {

            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
            } else {
                PreviousEntry->Child = CurrentEntry;
            }
            while (CurrentEntry) {
                CurrentEntry->Parent = AdapterEntry;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

#if DBG
    BlPrint("Detecting PcCard ISA IRQ mapping ...\n");
#endif
        if (CurrentEntry = GetPcCardInformation()) {
            //
            // Make current component the child of Adapter component.
            //

            if (NextRelationship == Sibling) {
                PreviousEntry->Sibling = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry->Parent;
            } else {
                PreviousEntry->Child = CurrentEntry;
                CurrentEntry->Parent = PreviousEntry;
            }
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
            while (CurrentEntry) {
                CurrentEntry->Parent = PreviousEntry->Parent;
                PreviousEntry = CurrentEntry;
                CurrentEntry = CurrentEntry->Sibling;
            }
            NextRelationship = Sibling;
        }

#if DBG
    BlPrint("Detecting ACPI Bus Component ...\n");
#endif

    if (HwGetAcpiBiosData(&ConfigurationData, &Length)) {
        AcpiAdapterEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                          sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        AcpiAdapterEntry->ConfigurationData = ConfigurationData;
        Component = &AcpiAdapterEntry->ComponentEntry;
        Component->ConfigurationDataLength = Length;

        Component->Class = AdapterClass;
        Component->Type = MultiFunctionAdapter;

        strcpy (Identifier, "ACPI BIOS");
        i = strlen(Identifier) + 1;
        IdentifierString = (FPCHAR)HwAllocateHeap(i, FALSE);
        _fstrcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = 0;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        HwSetUpFreeFormDataHeader(
                (FPHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
                0,
                0,
                0,
                Length - DATA_HEADER_SIZE
                );

        //
        // Add it to tree
        //
        // Big hack here.  This code inserts the ACPI node in
        // the tree one level higher than the ISA devices in
        // the code right above.  But this doesn't work in
        // the NoLegacy case because these devices haven't
        // been added to the tree.
        //
        // Ideally, this code would just be moved above the ISA
        // device detection code.  That would be simpler.  But
        // That causes current ACPI machines to fail to dual-boot
        // because their ARC paths would change.
        //

    //  if (NoLegacy) {
    //
    //      if (NextRelationship == Sibling) {
    //          PreviousEntry->Sibling = AcpiAdapterEntry;
    //          AcpiAdapterEntry->Parent = PreviousEntry->Parent;
    //      } else {
    //          PreviousEntry->Child = AdapterEntry;
    //          AdapterEntry->Parent = PreviousEntry;
    //      }
    //
    //      PreviousEntry = AdapterEntry;
    //
    //  } else {

            if (NextRelationship == Sibling) {
                PreviousEntry->Parent->Sibling = AcpiAdapterEntry;
                AcpiAdapterEntry->Parent = PreviousEntry->Parent->Parent;
            }
    //  }

        NextRelationship = Sibling;
    }

#if DBG
    BlPrint("ACPI BIOS Data collection complete...\n");
#endif // DBG

#if DBG
    BlPrint("Detection done. Press a key to display hardware info ...\n");
    while ( ! HwGetKey ());
    clrscrn ();
#endif

    //
    // Misc. supports.  Note, the information collected here will NOT be
    // written to hardware registry.
    //
    // 1. Collect video font information for vdm
    //

    GetVideoFontInformation();

    //
    // After all the components are detected, we collect EISA config data.
    //

    if (HwBusType == MACHINE_TYPE_EISA) {

        Component = &AdapterEntry->ComponentEntry;
        GetEisaConfigurationData(&AdapterEntry->ConfigurationData,
                                 &Component->ConfigurationDataLength);
        if (Component->ConfigurationDataLength) {
            HwEisaConfigurationData = (FPUCHAR)AdapterEntry->ConfigurationData +
                                           DATA_HEADER_SIZE;
            HwEisaConfigurationSize = Component->ConfigurationDataLength -
                                           DATA_HEADER_SIZE;

            //
            // Misc. detections based on Eisa config data
            //
            // Update Lpt and com controllers' irq information by examining
            //   the EISA configuration data.
            //

            GetIrqFromEisaData(FirstLpt, ParallelController);
            GetIrqFromEisaData(FirstCom, SerialController);
        }
    }


#if DBG
    CheckConfigurationTree(ConfigurationRoot);
#endif

    //
    // Update all the far pointers in the tree to flat 32 bit pointers
    //

    UpdateConfigurationTree(ConfigurationRoot);

    //
    // Set up returned values:
    //   Size of Heap space which should be preserved for configuration tree
    //   Pointer to the root of the configuration tree.
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap(0, FALSE);
    *BlHeapUsed = MAKE_FLAT_ADDRESS(CurrentEntry) -
                  MAKE_FLAT_ADDRESS(ConfigurationRoot);
    *BlConfigurationTree = (ULONG)MAKE_FLAT_ADDRESS(ConfigurationRoot);

}

VOID
GetIrqFromEisaData(
     FPFWCONFIGURATION_COMPONENT_DATA ControllerList,
     CONFIGURATION_TYPE ControllerType
     )
/*++

Routine Description:

    This routine updates all irq information for ControllerType components
    in the controllerList by examinine the eisa configuration data.

Arguments:

    ControllerList - Supplies a pointer to a component entry whoes irq will
        be updated.

    ControllerType - Supplies the controller type whoes irq will be searched
        for.

Returns:

    None.

--*/
{

     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry;
     FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
     FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
     USHORT i, Port;
     UCHAR Irq, Trigger;

     CurrentEntry = ControllerList;
     while (CurrentEntry &&
            CurrentEntry->ComponentEntry.Type == ControllerType) {
         if (CurrentEntry->ConfigurationData) {
             DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)
                              CurrentEntry->ConfigurationData;
             Port = 0;
             for (i = 0; i < (USHORT)DescriptorList->Count; i++) {
                 Descriptor = &DescriptorList->PartialDescriptors[i];
                 if (Descriptor->Type == CmResourceTypePort) {
                     Port = (USHORT)Descriptor->u.Port.Start.LowPart;
                     break;
                 }
             }
             if (Port != 0) {
                 for (i = 0; i < (USHORT)DescriptorList->Count; i++) {
                     Descriptor = &DescriptorList->PartialDescriptors[i];
                     if (Descriptor->Type == CmResourceTypeInterrupt) {
                         if (HwEisaGetIrqFromPort(Port, &Irq, &Trigger)) {
                             if (Trigger == 0) {  // EISA EDGE_TRIGGER
                                 Descriptor->Flags = EDGE_TRIGGERED;
                             } else {
                                 Descriptor->Flags = LEVEL_SENSITIVE;
                             }
                             Descriptor->u.Interrupt.Level = Irq;
                             Descriptor->u.Interrupt.Vector = Irq;
                             break;
                         }
                     }
                 }
             }
         }
         CurrentEntry = CurrentEntry->Sibling;
     }
}


VOID
UpdateComponentPointers(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
/*++

Routine Description:

    This routine updates all the "far" pointer to 32 bit flat addresses
    for a component entry.

Arguments:

    CurrentEntry - Supplies a pointer to a component entry which will
        be updated.

Returns:

    None.

--*/
{
    FPULONG UpdatePointer;
    FPVOID NextEntry;
    ULONG FlatAddress;

    //
    // Update the child, parent, sibling and ConfigurationData
    // far pointers to 32 bit flat addresses.
    // N.B. After we update the pointers to flat addresses, they
    // can no longer be accessed in real mode.
    //

    UpdatePointer = (FPULONG)&CurrentEntry->Child;
    NextEntry = (FPVOID)CurrentEntry->Child;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->Parent;
    NextEntry = (FPVOID)CurrentEntry->Parent;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->Sibling;
    NextEntry = (FPVOID)CurrentEntry->Sibling;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->ComponentEntry.Identifier;
    NextEntry = (FPVOID)CurrentEntry->ComponentEntry.Identifier;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

    UpdatePointer = (FPULONG)&CurrentEntry->ConfigurationData;
    NextEntry = (FPVOID)CurrentEntry->ConfigurationData;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    *UpdatePointer = FlatAddress;

}



VOID
UpdateConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
/*++

Routine Description:

    This routine traverses loader configuration tree and changes
    all the "far" pointer to 32 bit flat addresses.

Arguments:

    CurrentEntry - Supplies a pointer to a loader configuration
        tree or subtree.

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA TempEntry;
    
    while (CurrentEntry)
    {
        //
        // Spin down finding the deepest child
        //
        while (CurrentEntry->Child) {
            CurrentEntry = CurrentEntry->Child;
        }

        //
        // Now we need to either move to the next sibling.  If we
        // don't have a sibling we need to walk up through the parents
        // until we find an entry with a sibling.  We have to save
        // off the current entry since after we update the entry the
        // pointer are no longer useable.
        //
        while (CurrentEntry) {
            TempEntry = CurrentEntry;
            
            if (CurrentEntry->Sibling != NULL) {
                CurrentEntry = CurrentEntry->Sibling;
                UpdateComponentPointers(TempEntry);
                break;
            } else {
                CurrentEntry = CurrentEntry->Parent;
                UpdateComponentPointers(TempEntry);
            }
        }
    }
}

FPVOID
HwSetUpResourceDescriptor (
    FPFWCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    )

/*++

Routine Description:

    This routine allocates space from far heap , puts the caller's controller
    information to the space and sets up CONFIGURATION_COMPONENT
    structure for the caller.

Arguments:

    Component - Supplies the address the component whose configuration data
                should be set up.

    Identifier - Suppies a pointer to the identifier to identify the controller

    ControlData - Supplies a point to a structure which describes
                controller information.

    SpecificDataLength - size of the device specific data.  Device specific
                data is the information not defined in the standard format.

    SpecificData - Supplies a pointer to the device specific data.


Return Value:

    Returns a far pointer to the Configuration data.

--*/

{
    FPCHAR fpIdentifier;
    FPHWRESOURCE_DESCRIPTOR_LIST fpDescriptor = NULL;
    USHORT Length;
    SHORT Count, i;
    FPUCHAR fpSpecificData;

    //
    // Set up Identifier string for hardware component, if necessary.
    //

    if (Identifier) {
        Length = strlen(Identifier) + 1;
        Component->IdentifierLength = Length;
        fpIdentifier = (FPUCHAR)HwAllocateHeap(Length, FALSE);
        Component->Identifier = fpIdentifier;
        _fstrcpy(fpIdentifier, Identifier);
    } else {
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;
    }

    //
    // Set up configuration data for hardware component, if necessary
    //

    Count = ControlData->NumberPortEntries + ControlData->NumberIrqEntries +
            ControlData->NumberMemoryEntries + ControlData->NumberDmaEntries;

    if (SpecificDataLength) {

        //
        // if we have device specific data, we need to increment the count
        // by one.
        //

        Count++;
    }

    if (Count >0) {
        Length = (USHORT)(Count * sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                 FIELD_OFFSET(HWRESOURCE_DESCRIPTOR_LIST, PartialDescriptors) +
                 SpecificDataLength);
        fpDescriptor = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(Length, TRUE);
        fpDescriptor->Count = Count;

        //
        // Copy all the partial descriptors to the destination descriptors
        // except the last one. (The last partial descriptor may be a device
        // specific data.  It requires special handling.)
        //

        for (i = 0; i < (Count - 1); i++) {
            fpDescriptor->PartialDescriptors[i] =
                                        ControlData->DescriptorList[i];
        }

        //
        // Set up the last partial descriptor.  If it is a port, memory, irq or
        // dma entry, we simply copy it.  If the last one is for device specific
        // data, we set up the length and copy the device spcific data to the end
        // of the decriptor.
        //

        if (SpecificData) {
            fpDescriptor->PartialDescriptors[Count - 1].Type =
                            RESOURCE_DEVICE_DATA;
            fpDescriptor->PartialDescriptors[Count - 1].Flags = 0;
            fpDescriptor->PartialDescriptors[Count - 1].u.DeviceSpecificData.DataSize =
                            SpecificDataLength;
            fpSpecificData = (FPUCHAR)&(fpDescriptor->PartialDescriptors[Count]);
            _fmemcpy(fpSpecificData, SpecificData, SpecificDataLength);
        } else {
            fpDescriptor->PartialDescriptors[Count - 1] =
                            ControlData->DescriptorList[Count - 1];
        }
        Component->ConfigurationDataLength = Length;
    }
    return(fpDescriptor);
}
VOID
HwSetUpFreeFormDataHeader (
    FPHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    )

/*++

Routine Description:

    This routine initialize free formed data header.  Note this routine
    sets the the Header and initialize the FIRST PartialDescriptor only.
    If the header contains more than one descriptor, the caller must handle
    it itself.

Arguments:

    Header - Supplies a pointer to the header to be initialized.

    Version - Version number for the header.

    Revision - Revision number for the header.

    Flags - Free formed data flags.  (Currently, it is undefined and
                should be zero.)

    DataSize - Size of the free formed data.


Return Value:

    None.

--*/

{

    Header->Version = Version;
    Header->Revision = Revision;
    Header->Count = 1;
    Header->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    Header->PartialDescriptors[0].ShareDisposition = 0;
    Header->PartialDescriptors[0].Flags = Flags;
    Header->PartialDescriptors[0].u.DeviceSpecificData.DataSize = DataSize;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved1 = 0;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved2 = 0;
}
#if DBG

VOID
CheckComponentNode(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
{
    FPUCHAR NextEntry, DataPointer;
    ULONG FlatAddress;
    ULONG Length;
    UCHAR IdString[40];
    USHORT Count, i;
    UCHAR Type;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    FPHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;

    FlatAddress = MAKE_FLAT_ADDRESS(CurrentEntry);
    clrscrn ();
    BlPrint("\n");
    BlPrint("Current Node: %lx\n", FlatAddress);
    BlPrint("  Type = %s\n", TypeName[CurrentEntry->ComponentEntry.Type]);

    //
    // Update the child, parent, sibling and ConfigurationData
    // far pointers to 32 bit flat addresses.
    // N.B. After we update the pointers to flat addresses, they
    // can no longer be accessed in real mode.
    //

    NextEntry = (FPUCHAR)CurrentEntry->Child;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Child = %lx\n", FlatAddress);
    } else {
        BlPrint("\tChild = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->Parent;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Parent = %lx\n", FlatAddress);
    } else {
        BlPrint("\tParent = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->Sibling;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: Sibling = %lx\n", FlatAddress);
    } else {
        BlPrint("\tSibling = %lx\n", FlatAddress);
    }

    NextEntry = (FPUCHAR)CurrentEntry->ConfigurationData;
    FlatAddress = MAKE_FLAT_ADDRESS(NextEntry);
    if (FlatAddress > 0x60000 || (FlatAddress < 0x50000 && FlatAddress != 0)) {
        BlPrint("Invalid address: ConfigurationData = %lx\n", FlatAddress);
    } else {
        BlPrint("\tConfigurationData = %lx\n", FlatAddress);
    }

    Length = CurrentEntry->ComponentEntry.IdentifierLength;
    BlPrint("IdentifierLength = %lx\n", CurrentEntry->ComponentEntry.IdentifierLength);
    if (Length > 0) {
        _fstrcpy(IdString, CurrentEntry->ComponentEntry.Identifier);
        BlPrint("Identifier = %s\n", IdString);
    }

    Length = CurrentEntry->ComponentEntry.ConfigurationDataLength;
    BlPrint("ConfigdataLength = %lx\n", Length);

    if (Length > 0) {

        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)CurrentEntry->ConfigurationData;
        BlPrint("Version = %x, Revision = %x\n", DescriptorList->Version,
                 DescriptorList->Revision);
        Count = (USHORT)DescriptorList->Count;
        Descriptor = &DescriptorList->PartialDescriptors[0];
        BlPrint("Count = %x\n", Count);
        while (Count > 0) {
            Type = Descriptor->Type;
            if (Type == RESOURCE_PORT) {
                BlPrint("Type = Port");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("PortFlags = %x\n", Descriptor->Flags);
                BlPrint("PortStart = %x", Descriptor->u.Port.Start);
                BlPrint("\tPortLength = %x\n", Descriptor->u.Port.Length);
            } else if (Type == RESOURCE_DMA) {
                BlPrint("Type = Dma");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("DmaFlags = %x\n", Descriptor->Flags);
                BlPrint("DmaChannel = %x", Descriptor->u.Dma.Channel);
                BlPrint("\tDmaPort = %lx\n", Descriptor->u.Dma.Port);
            } else if (Type == RESOURCE_INTERRUPT) {
                BlPrint("Type = Interrupt");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("InterruptFlags = %x\n", Descriptor->Flags);
                BlPrint("Level = %x", Descriptor->u.Interrupt.Level);
                BlPrint("\tVector = %x\n", Descriptor->u.Interrupt.Vector);
            } else if (Type == RESOURCE_MEMORY) {
                BlPrint("Type = Memory");
                BlPrint("\tShareDisposition = %x\n", Descriptor->ShareDisposition);
                BlPrint("MemoryFlags = %x\n", Descriptor->Flags);
                BlPrint("Start1 = %lx", (ULONG)Descriptor->u.Memory.Start.LowPart);
                BlPrint("\tStart2 = %lx", (ULONG)Descriptor->u.Memory.Start.HighPart);
                BlPrint("\tLength = %lx\n", Descriptor->u.Memory.Length);
            } else {
                BlPrint("Type = Device Data\n");
                Length = Descriptor->u.DeviceSpecificData.DataSize;
                BlPrint("Size = %lx\n", Length);
                DataPointer = (FPUCHAR)(Descriptor+1);
                for (i = 0; (i < (USHORT)Length) && (i < 64); i++) {
                    BlPrint("%x ", *DataPointer);
                    DataPointer++;
                }
                break;
            }
            Count--;
            Descriptor++;
        }
    }
    while (HwGetKey() == 0) {
    }
}

VOID
CheckConfigurationTree(
     FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
     )
{
    FPFWCONFIGURATION_COMPONENT_DATA TempEntry;
    
    while (CurrentEntry)
    {
        //
        // Spin down finding the deepest child
        //
        while (CurrentEntry->Child) {
            CurrentEntry = CurrentEntry->Child;
        }

        //
        // Now we need to either move to the next sibling.  If we
        // don't have a sibling we need to walk up through the parents
        // until we find an entry with a sibling.  We have to save
        // off the current entry since after we update the entry the
        // pointer are no longer useable.
        //
        while (CurrentEntry) {
            TempEntry = CurrentEntry;
            
            if (CurrentEntry->Sibling != NULL) {
                CurrentEntry = CurrentEntry->Sibling;
                CheckComponentNode(TempEntry);
                break;
            } else {
                CurrentEntry = CurrentEntry->Parent;
                CheckComponentNode(TempEntry);
            }
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwdetect.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    detect.h

Abstract:

    This module is a global C include file for all the detection
    modules.

Author:

    Shie-Lin Tzong (shielint) 27-Dec-1991

Revision History:

--*/

#define i386
#define _X86_
#define __stdcall
#pragma warning (4:4103)
#include "types.h"
#include "ntmisc.h"
#include <ntconfig.h>
#include <arc.h>

#define X86_REAL_MODE           // must precede include of dockinfo.h
#include "..\..\inc\dockinfo.h"

//
// Machine type definitions.
//

#define MACHINE_TYPE_ISA 0
#define MACHINE_TYPE_EISA 1
#define MACHINE_TYPE_MCA 2

//
// Interrupt controller register addresses.
//

#define PIC1_PORT0 0x20         // master PIC
#define PIC1_PORT1 0x21
#define PIC2_PORT0 0x0A0        // slave PIC
#define PIC2_PORT1 0x0A1

//
// Commands for interrupt controller
//

#define OCW3_READ_ISR 0xb
#define OCW3_READ_IRR 0xa

//
// Definitions for the data stored in the first page 0x700 area
// The 0x700 is the place vdm loads MS-DOS.  It should be very safe
// to pass the data required by vdm.
//

#define DOS_BEGIN_SEGMENT 0x70   // DOS loaded segment address

#define VIDEO_FONT_OFFSET 0      // Video font ptrs stored at 0x700
#define VIDEO_FONT_DATA_SIZE 0x40

#define EBIOS_INFO_OFFSET 0x40   // Extended bios infor:
                                 //   EBIOS data area address 4 bytes
                                 //   EBIOS data area size 4 byte
#define EBIOS_INFO_SIZE   0x8

//
// Mouse information structure
// N.B. This *must* match the one defined in mouse.inc
//

typedef struct _MOUSE_INFORMATION {
        UCHAR MouseType;
        UCHAR MouseSubtype;
        USHORT MousePort;       // if serial mouse, 1 for com1, 2 for com2 ...
        USHORT MouseIrq;
        USHORT DeviceIdLength;
        UCHAR  DeviceId[10];
} MOUSE_INFORMATION, *PMOUSE_INFORMATION;

//
// Mouse Type definitions
//

#define UNKNOWN_MOUSE   0
#define NO_MOUSE        0x100             // YES! it is 0x100 *NOT* 0x10000

#define MS_MOUSE        0x200             // MS regular mouses
#define MS_BALLPOINT    0x300             // MS ballpoint mouse
#define LT_MOUSE        0x400             // Logitec Mouse

//
// note last 4 bits of the subtype are reserved subtype specific use
//

#define PS_MOUSE        0x1
#define SERIAL_MOUSE    0x2
#define INPORT_MOUSE    0x3
#define BUS_MOUSE       0x4
#define PS_MOUSE_WITH_WHEEL     0x5
#define SERIAL_MOUSE_WITH_WHEEL 0x6

//#define MOUSE_RESERVE_MASK  0xfffffff

//
// Definitions for the keyboard type returned from
// the detect keyboard function.
//

#define UNKNOWN_KEYBOARD  0
#define OLI_83KEY         1
#define OLI_102KEY        2
#define OLI_86KEY         3
#define OLI_A101_102KEY   4
#define XT_83KEY          5
#define ATT_302           6
#define PCAT_ENHANCED     7
#define PCAT_86KEY        8
#define PCXT_84KEY        9

//
// Redefine the configuration component structures to use FAR pointer type.
//
// Since ntdetect.com running at 16 bit real mode, it has to use FAR pointers
// to access loader heap.  Before returning to ntldr, ntdetect must convert
// these far pointers to 32 bit flat addresses such that kernel can acess the
// configuration tree.
//

typedef struct _FWCONFIGURATION_COMPONENT {
    CONFIGURATION_CLASS Class;
    USHORT Reserved0;
    CONFIGURATION_TYPE Type;
    USHORT Reserverd1;
    DEVICE_FLAGS Flags;
    ULONG Version;
    ULONG Key;
    ULONG AffinityMask;
    ULONG ConfigurationDataLength;
    ULONG IdentifierLength;
    FPCHAR Identifier;
} FWCONFIGURATION_COMPONENT, far *FPFWCONFIGURATION_COMPONENT;

typedef struct _FWCONFIGURATION_COMPONENT_DATA {
    struct _FWCONFIGURATION_COMPONENT_DATA far *Parent;
    struct _FWCONFIGURATION_COMPONENT_DATA far *Child;
    struct _FWCONFIGURATION_COMPONENT_DATA far *Sibling;
    FWCONFIGURATION_COMPONENT ComponentEntry;
    FPVOID ConfigurationData;
} FWCONFIGURATION_COMPONENT_DATA, far *FPFWCONFIGURATION_COMPONENT_DATA;

//
// defined the MicroChannel POS data structure
//

typedef CM_MCA_POS_DATA MCA_POS_DATA, far *FPMCA_POS_DATA;

//
// Rom Block Definition
//

typedef CM_ROM_BLOCK ROM_BLOCK, far *FPROM_BLOCK;
#define RESERVED_ROM_BLOCK_LIST_SIZE (((0xf0000 - 0xc0000)/512) * sizeof(ROM_BLOCK))

//
// Other type redefinitions
//

typedef CM_PARTIAL_RESOURCE_DESCRIPTOR HWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR *PHWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR far *FPHWPARTIAL_RESOURCE_DESCRIPTOR;

typedef CM_PARTIAL_RESOURCE_LIST HWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST *PHWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST far *FPHWRESOURCE_DESCRIPTOR_LIST;

typedef CM_EISA_SLOT_INFORMATION EISA_SLOT_INFORMATION, *PEISA_SLOT_INFORMATION;
typedef CM_EISA_SLOT_INFORMATION far *FPEISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION EISA_FUNCTION_INFORMATION, *PEISA_FUNCTION_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION far *FPEISA_FUNCTION_INFORMATION;

#define LEVEL_SENSITIVE CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE
#define EDGE_TRIGGERED CM_RESOURCE_INTERRUPT_LATCHED
#define RESOURCE_PORT 1
#define RESOURCE_INTERRUPT 2
#define RESOURCE_MEMORY 3
#define RESOURCE_DMA 4
#define RESOURCE_DEVICE_DATA 5
#define ALL_PROCESSORS 0xffffffff

//
// Note the DATA_HEADER_SIZE counts ONE partial descriptor only.
// if the resource list has more than one descriptors, you must add
// the size of extra descriptors to this value.
//

#define DATA_HEADER_SIZE sizeof(CM_PARTIAL_RESOURCE_LIST)

//
// Defines the structure to store controller information
// (used by ntdetect internally)
//

#define MAXIMUM_DESCRIPTORS 10

typedef struct _HWCONTROLLER_DATA {
    UCHAR NumberPortEntries;
    UCHAR NumberIrqEntries;
    UCHAR NumberMemoryEntries;
    UCHAR NumberDmaEntries;
    HWPARTIAL_RESOURCE_DESCRIPTOR DescriptorList[MAXIMUM_DESCRIPTORS];
} HWCONTROLLER_DATA, *PHWCONTROLLER_DATA;

//
// Macro definitions for conversion between far and fat pointers
//

#define MAKE_FP(p,a)    FP_SEG(p) = (USHORT)((a) >> 4) & 0xffff; FP_OFF(p) = (USHORT)((a) & 0x0f)
#define MAKE_FLAT_ADDRESS(fp) ( ((ULONG)FP_SEG(fp) * 16 ) +  (ULONG)FP_OFF(fp) )

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))

//
// I/O Port read and write routines.
//

extern
VOID
WRITE_PORT_UCHAR (
    PUCHAR  PortAddress,
    UCHAR   Value
    );

extern
UCHAR
READ_PORT_UCHAR(
    PUCHAR  Port
    );

extern
VOID
WRITE_PORT_USHORT (
    PUSHORT PortAddress,
    USHORT  Value
    );

extern
USHORT
READ_PORT_USHORT(
    PUSHORT Port
    );

extern
VOID
WRITE_PORT_ULONG (
    PUSHORT PortAddress,
    ULONG  Value
    );

extern
ULONG
READ_PORT_ULONG(
    PUSHORT Port
    );

//
// prototype definitions for Heap management routines
//

extern
BOOLEAN
HwInitializeHeap (
    ULONG HeapStart,
    ULONG HeapSize
    );

extern
FPVOID
HwAllocateHeap(
    ULONG RequestSize,
    BOOLEAN ZeroInitialized
    );

extern
VOID
HwFreeHeap(
    ULONG Size
    );

//
// Misc. prototype definitions
//

extern
FPVOID
HwSetUpResourceDescriptor (
    FPFWCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    );

extern
VOID
HwSetUpFreeFormDataHeader (
    FPHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    );

USHORT
HwGetKey(
    VOID
    );

extern
BOOLEAN
IsEnhancedKeyboard (
    VOID
    );

extern
SHORT
GetKeyboardIdBytes (
   PCHAR IdBuffer,
   SHORT Length
   );

extern
USHORT
GetKeyboardId(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    IN USHORT KeyboardId
    );

#if 0 // Remove video detection
extern
ULONG
GetVideoAdapterType (
   VOID
   );

extern
FPFWCONFIGURATION_COMPONENT_DATA
SetVideoConfigurationData (
    IN ULONG VideoType
    );
#endif // Remove video detection

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetLptInformation (
    VOID
    );

extern
PMOUSE_INFORMATION
GetMouseId (
   VOID
   );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetFloppyInformation(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetAtDiskInformation(
    VOID
    );

extern
FPFWCONFIGURATION_COMPONENT_DATA
GetPcCardInformation(
    VOID
    );

extern
BOOLEAN
HwIsMcaSystem(
    VOID
    );

extern
BOOLEAN
HwIsEisaSystem(
    VOID
    );

extern
BOOLEAN
IsNpxPresent(
    VOID
    );

extern
USHORT
HwGetProcessorType(
    VOID
    );

extern
USHORT
HwGetCpuStepping(
    USHORT
    );

extern
VOID
GetMcaPosData(
    FPVOID Entry,
    FPULONG DataLength
    );

extern
VOID
GetEisaConfigurationData(
    FPVOID Entry,
    FPULONG DataLength
    );

extern
VOID
UpdateConfigurationTree(
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry
    );

extern
PUCHAR
GetMachineId(
    VOID
    );

extern
VOID
HwGetEisaSlotInformation (
    PEISA_SLOT_INFORMATION SlotInformation,
    UCHAR Slot
    );

extern
UCHAR
HwGetEisaFunctionInformation (
    PEISA_FUNCTION_INFORMATION FunctionInformation,
    UCHAR Slot,
    UCHAR Function
    );

extern
VOID
GetBiosSystemEnvironment (
    PUCHAR Buffer
    );

extern
VOID
GetInt13DriveParameters (
    PUCHAR Buffer,
    PUSHORT Size
    );

extern
VOID
GetRomBlocks(
    FPUCHAR ReservedBuff,
    PUSHORT Size
    );

extern
VOID
GetVideoFontInformation(
    VOID
    );

extern
BOOLEAN
HwEisaGetIrqFromPort (
    USHORT Port,
    PUCHAR Irq,
    PUCHAR TriggerMethod
    );

VOID
HwGetPciSystemData(
    PVOID,
    BOOLEAN
    );

UCHAR
HwGetPciIrqRoutingOptions(
    VOID far *RouteBuffer,
    PUSHORT ExclusiveIRQs
    );

UCHAR
HwGetPciConfigurationDword(
    IN UCHAR Bus,
    IN UCHAR Device,
    IN UCHAR Function,
    IN UCHAR Offset,
    OUT PULONG DataRead
    );

VOID
HwGetBiosDate(
    ULONG source,
    USHORT  Length,
    PUSHORT BiosYear,
    PUSHORT BiosMonth,
    PUSHORT BiosDay
    );

BOOLEAN
HwGetPnpBiosSystemData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT PnPBiosLength,
    OUT PUSHORT SMBIOSLength,
    IN OUT FPDOCKING_STATION_INFO DockInfo
    );

BOOLEAN
HwGetAcpiBiosData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    );

#if DBG
extern
VOID
BlPrint(
    IN PCHAR,
    ...
    );

extern
VOID
clrscrn (
    VOID
    );

#endif // DBG

BOOLEAN HwGetApmSystemData(PVOID);

//
// External declarations for global variables
//

extern USHORT HwBusType;

extern FPFWCONFIGURATION_COMPONENT_DATA AdapterEntry;

extern FPMCA_POS_DATA HwMcaPosData;

extern FPUCHAR FpRomBlock;

extern USHORT RomBlockLength;

extern FPUCHAR HwEisaConfigurationData;

extern ULONG HwEisaConfigurationSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwheap.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This is a very simple Heap Manager for NT OS Hardware recognizer.
    This module provides functions to allocate memory in byte-unit
    from a permanent heap.

Author:

    Shie-Lin Tzong (shielint) 18-Oct-91


Environment:

    Kernel Mode


Revision History:


--*/

#include "hwdetect.h"
#include "string.h"

VOID
GrowHeapSpace(
    ULONG
    );

VOID
HeapCheck(
    PVOID
    );

//
// Heap management variables.
//

ULONG HwHeapBase = 0;           // Current virtual address of base of heap
ULONG HwHeapPointer = 0;        // Pointer to the end of available heap
ULONG  HwHeapSize = 0;          // Size of Heap
ULONG  HwAvailableHeap = 0;     // Currently available heap space

#if DBG
ULONG HwPreviousAllocSize = 0;
#endif

BOOLEAN
HwResizeHeap (
    ULONG NewHeapSize
    )

/*++

Routine Description:

    The routine grows current heap to the specified size.
    It reallocates the heap, copies the data in current heap to
    the new heap, updates heap variables, updates heap pointers
    in hardware data structures and finally frees the old heap.

Arguments:

    NewHeapSize - Specifies the size of the new heap.

Returns:

    TRUE - if operation is done sucessfully.  Else it returns FALSE.

--*/

{
    //
    // Not implemented yet.
    //

    return(FALSE);
}

BOOLEAN
HwInitializeHeap(
    ULONG HeapStart,
    ULONG HeapSize
    )

/*++

Routine Description:

    The routine allocates heap and initializes some vital heap
    variables.

Arguments:

    None

Returns:

    FALSE - if unable to allocate initial heap.  Else it returns TRUE.

--*/

{

    HwHeapBase = HeapStart;
    HwHeapPointer = HwHeapBase;
    HwHeapSize = HeapSize;
    HwAvailableHeap = HwHeapSize;
    return(TRUE);

}

FPVOID
HwAllocateHeap(
    ULONG RequestSize,
    BOOLEAN ZeroInitialized
    )

/**

Routine Description:

    Allocates memory from the hardware recognizer's heap.

    The heap begins with a default size. If a request exhausts heap space,
    the heap will be grown to accomodate the request. The heap can grow
    up to any size limited by NTLDR.  If we run out of heap space and are
    unable to allocate more memory, a value of NULL will be returned.

Arguments:

    RequestSize - Size of block to allocate.

    ZeroInitialized - Specifies if the heap should be zero initialized.

Returns:

    Returns a pointer to the allocated block of memory.  A NULL pointer
    will be returned if we run out of heap and are unable to resize
    current heap.

--*/

{
    FPVOID ReturnPointer;

    if (RequestSize > HwAvailableHeap) {

        //
        // We're out of heap.  Try to grow current heap to satisfy the
        // request.
        //

        if (!HwResizeHeap(HwHeapSize + RequestSize)) {
#if DBG
            BlPrint("Unable to grow heap\n");
#endif
            return(NULL);
        }
    }

    //
    // Set our return value to the new Heap pointer then
    // update the remaining space and heap pointer.
    //

    MAKE_FP(ReturnPointer, HwHeapPointer);
    HwHeapPointer += RequestSize;
#if DBG
    HwPreviousAllocSize = RequestSize;
#endif
    HwAvailableHeap -= RequestSize;
    if (ZeroInitialized) {
        _fmemset(ReturnPointer, 0, (USHORT)RequestSize);
    }
    return (ReturnPointer);
}

VOID
HwFreeHeap(
    ULONG Size
    )

/**

Routine Description:

    Unallocates memory from the hardware recognizer's heap.

    The unallocation is very basic.  It simply moves heap pointer
    back by the size specified and increases the heap size by the
    specified size.  The routine should be used only when previous
    allocateHeap allocated too much memory.

Arguments:

    RequestSize - Size of block to allocate.

Returns:

    Returns a pointer to the allocated block of memory.  A NULL pointer
    will be returned if we run out of heap and are unable to resize
    current heap.

--*/

{

#if DBG
    if (Size > HwPreviousAllocSize) {
        BlPrint("Invalid heap deallocation ...\n");
    } else {
        HwPreviousAllocSize -= Size;
    }
#endif

    HwHeapPointer -= Size;
    HwAvailableHeap += Size;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwpci.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;     hwpci.inc
;
; Abstract:
;
; Author:
;
; Revision History:
;
;--

;
;  PCI_INTERFACE_INT interrupt is the PCI BIOS entry point
;  PCI_BIOS_PRESENT AX function code for PCI BIOS entry point
;  PCI_READ_CONFIG_DWORD AX function code for PCI BIOS entry point
;

PCI_INTERFACE_INT           EQU  01AH
PCI_BIOS_PRESENT            EQU  0B101h
PCI_READ_CONFIG_DWORD       EQU  0B10Ah


; Down level bios checl

PCI10_BIOS_PRESENT            EQU  0B001h

;
;  Structure for PCI System Data - it is passed to the system
;  through the register to inform it what type of PCI support,
;  if any, is present.
;


PCI_SYSTEM_DATA     struc

    MajorRevision       db      0
    MinorRevision       db      0
    NoBuses             db      0
    HwMechanism         db      0

PCI_SYSTEM_DATA     ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hweisa.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;   eisa.inc
;
;   Abstract:
;
;   This module contains the assembly structures and definitions
;       for making 16-bit real mode EISA BIOS calls.
;
;   Author:
;
;   Shie-Lin (shielint) 7-June-1991
;
;   Revision History:
;
;--

;
; EISA BIOS call function number.
;

GET_EISA_SLOT_INFORMATION     equ 0D800h
GET_EISA_FUNCTION_INFORMATION equ 0D801h

;
; Length of EISA information block
;

EISA_INFORMATION_BLOCK_LENGTH equ 320

;
; Structure for EISA slot information block
;

EISA_SLOT_INFORMATION   struc

    SlotReturn                  db      0
    SlotFlags                   db      0
    SlotMajorRevision           db      0
    SlotMinorRevision           db      0
    SlotChecksum                dw      0
    SlotNumberFunctions         db      0
    SlotFunctionInformation     db      0
    SlotCompressedId            dd      0

EISA_SLOT_INFORMATION   ends

;
; Structure for EISA function information block
;

EISA_FUNCTION_INFORMATION       struc

    FunctionReturn      db      0
    FunctionInformation db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

EISA_FUNCTION_INFORMATION       ends

;
; Structure definitions and equates for INT 15 function E820
;

E820Frame struc
        ErrorFlag       dd      ?
        Key             dd      ?
        DescSize        dd      ?

        BaseAddrLow     dd      ?
        BaseAddrHigh    dd      ?
        SizeLow         dd      ?
        SizeHigh        dd      ?
        MemoryType      dd      ?
E820Frame ends

MemoryDescriptorFramePointer struc
        E820FramePointer    dd      ?
MemoryDescriptorFramePointer ends

;
; Structure definitions for INT 15 E980
;

E980Info struc
        Signature               dw      ?
        CommandPortAddress      dw      ?
        EventPortAddress        dw      ?
        PollInterval            dw      ?
        CommandDataValue        db      ?
        EventPortBitmask        db      ?
        MaxLevelAc              db      ?
        MaxLevelDc              db      ?
E980Info ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwmisca.asm ===
title  "Misc. Support Routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    misca.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Shie-Lin Tzong (shielint) Dec-23-1991
;
; Environment:
;
;    x86 real mode.
;
; Revision History:
;
;--

.386p

SIZE_OF_INT15_C0_BUFFER equ     10


_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING

;++
;
; I/O port space read and write functions.
;
;--


;++
;
;   UCHAR
;   READ_PORT_UCHAR(
;       PUCHAR  Port
;       )
;
;   Arguments:
;       (sp+2) = Port
;
;   Returns:
;       Value in Port.
;
;--
        public  _READ_PORT_UCHAR
_READ_PORT_UCHAR proc

        push    bp
        mov     bp, sp
        mov     dx, [bp+4]
        in      al,dx
        pop     bp
        ret

_READ_PORT_UCHAR endp



;++
;
;   USHORT
;   READ_PORT_USHORT(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (sp+2) = Port
;
;   Returns:
;       Value in Port.
;
;--
        public  _READ_PORT_USHORT
_READ_PORT_USHORT proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]              ; (dx) = Port
        in      ax,dx
        pop     bp
        ret

_READ_PORT_USHORT endp


;++
;
;   ULONG
;   READ_PORT_ULONG(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (sp+2) = Port
;
;   Returns:
;       Value in Port.
;
;--
        public  _READ_PORT_ULONG
_READ_PORT_ULONG proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]              ; (dx) = Port
        in      eax,dx				   ; eax = Value
        mov     edx, eax
        shr     edx, 16
        pop     bp
        ret

_READ_PORT_ULONG endp



;++
;
;   VOID
;   WRITE_PORT_UCHAR(
;       PUCHAR  Port,
;       UCHAR   Value
;       )
;
;   Arguments:
;       (sp+2) = Port
;       (sp+4) = Value
;
;--
        public  _WRITE_PORT_UCHAR
_WRITE_PORT_UCHAR proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]               ; (dx) = Port
        mov     al,[bp+6]               ; (al) = Value
        out     dx,al
        pop     bp
        ret

_WRITE_PORT_UCHAR endp

;++
;
;   VOID
;   WRITE_PORT_USHORT(
;       PUSHORT Port,
;       USHORT  Value
;       )
;
;   Arguments:
;       (sp+2) = Port
;       (sp+4) = Value
;
;--
        public  _WRITE_PORT_USHORT
_WRITE_PORT_USHORT proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]               ; (dx) = Port
        mov     ax,[bp+6]               ; (ax) = Value
        out     dx,ax
        pop     bp
        ret

_WRITE_PORT_USHORT endp


;++
;
;   VOID
;   WRITE_PORT_ULONG(
;       PUSHORT Port,
;       ULONG  Value
;       )
;
;   Arguments:
;       (sp+2) = Port
;       (sp+4) = Value (LSW)
;       (sp+6) = Value (MSW)
;
;--
        public  _WRITE_PORT_ULONG
_WRITE_PORT_ULONG proc

        push    bp
        mov     bp, sp
        mov     dx,[bp+4]               ; (dx) = Port
        xor		eax, eax
        mov     ax,[bp+8]               ; (ax) = Value MSW
        shl     eax, 16
        mov     ax,[bp+6]               ; (ax) = Value LSW
        out     dx,eax
        pop     bp
        ret

_WRITE_PORT_ULONG endp



;++
;
;   VOID
;   GetBiosSystemEnvironment(
;       PUCHAR Buffer
;       )
;
;   Description:
;
;       This function performs int 15h C0H function to get System
;       Environment supplied by BIOS ROM.
;
;   Arguments:
;
;       Buffer - Supplies a pointer to a buffer to receive the BIOS
;                System Environment. Caller must ensure that the buffer
;                is big enough.
;
;--

GbseBuffer      equ     [bp + 4]

        public _GetBiosSystemEnvironment
_GetBiosSystemEnvironment       proc    near

        push    bp
        mov     bp, sp

        push    bx
        push    es
        push    ds
        push    si
        push    di

        mov     ah, 0c0h
        int     15h
        mov     ax, es          ; exchange es and ds
        mov     cx, ds
        mov     ds, ax
        mov     es, cx
        mov     si, bx          ; [ds:si] -> ROM buffer (source)
        mov     di, GbseBuffer  ; [es:di] -> caller's buffer (destination)
        mov     cx, SIZE_OF_INT15_C0_BUFFER
        rep     movsb

        pop     di
        pop     si
        pop     ds
        pop     es
        pop     bx
        mov     sp, bp
        pop     bp
        ret

_GetBiosSystemEnvironment       endp

;++
;
;   BOOLEAN
;   HwRomCompare(
;       ULONG Source,
;       ULONG Destination
;       ULONG Size
;       )
;
;   Description:
;
;       This function performs ROM comparison between the Source ROM
;       block and Destination ROM block.
;
;   Arguments:
;
;       Source - Supplies the physical address of source ROM block.
;
;       Destination - Supplies the physical address of destination ROM block.
;
;       Size - The size of the comparison.  Must be <= 64k.
;
;   Return:
;
;       0 - if the contents of Source and destination are the same.
;
;       != 0 if the contents are different.
;--

HfSource        equ     [bp + 4]
HfDestination   equ     [bp + 8]
HfSize          equ     [bp + 12]

        public _HwRomCompare
_HwRomCompare   proc    near

        push    bp
        mov     bp, sp
        push    esi
        push    edi
        push    ds
        push    es
        cld

        mov     ecx, HfSize
        cmp     ecx, 10000h
        ja      HfNotTheSame

        mov     eax, HfSource
        add     eax, ecx
        cmp     eax, 100000h
        ja      short HfNotTheSame

        mov     edx, HfDestination
        add     edx, ecx
        cmp     edx, 100000h
        ja      short HfNotTheSame

        mov     eax, HfSource
        shr     eax, 4
        mov     es, ax
        mov     edi, HfSource
        and     edi, 0fh

        mov     eax, HfDestination
        shr     eax, 4
        mov     ds, ax
        mov     esi, HfDestination
        and     esi, 0fh

        shr     ecx, 2
        repe    cmpsd

        jnz     short HfNotTheSame
        mov     ax, 0
        jmp     short HfExit

HfNotTheSame:
        mov     ax, 1
HfExit:
        pop     es
        pop     ds
        pop     edi
        pop     esi
        pop     bp
        ret

_HwRomCompare   endp

;++
;
;   VOID
;   HwGetKey(
;       VOID
;       )
;
;   Description:
;
;       This function waits for a key to be pressed.
;
;   Arguments:
;       None.
;
;--

        public _HwGetKey
_HwGetkey proc

        mov     ax,0100h
        int     16h

        mov     ax,0
        jz      short Hgk99

;
; Now we call BIOS again, this time to get the key from the keyboard buffer
;

        int     16h

Hgk99:
        ret
_HwGetKey endp

;++
;
;   VOID
;   HwPushKey(
;       USHORT Key
;       )
;
;   Description:
;
;       This function pushes a character and scan code to keyboard
;       type-ahead buffer.
;
;   Arguments:
;
;       Key - Supplies the key to be push back.
;             bit 0 - 7 : Character
;             bit 8 - 15: Scan Code
;
;--

        public _HwPushKey
_HwPushkey      proc

        mov     cx, [esp + 2]           ; character and scan code
        mov     ah, 05h
        int     16h

;
; I don't care if the function call is successful.
;

        ret
_HwPushKey      endp
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hweisac.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    eisac.c

Abstract:

    This module implements routines to get EISA configuration information.

Author:

    Shie-Lin Tzong (shielint) 18-Jan-1992

Environment:

    16-bit real mode.


Revision History:


--*/

#include "hwdetect.h"
#include "string.h"

typedef EISA_PORT_CONFIGURATION far *FPEISA_PORT_CONFIGURATION;

extern CM_EISA_FUNCTION_INFORMATION FunctionInformation;


VOID
GetEisaConfigurationData (
    FPVOID Buffer,
    FPULONG Size
    )

/*++

Routine Description:

    This routine collects all the eisa slot information, function
    information and stores it in the caller supplied Buffer and
    returns the size of the data.

Arguments:


    Buffer - A pointer to a PVOID to recieve the address of configuration
        data.

    Size - a pointer to a ULONG to receive the size of the configuration
        data.

Return Value:

    None.

--*/

{
    UCHAR Slot=0;
    UCHAR Function=0, SlotFunctions = 0, ReturnCode;
    EISA_SLOT_INFORMATION  SlotInformation;
    FPUCHAR ConfigurationData, CurrentData;
    FPEISA_SLOT_INFORMATION FarSlotInformation;
    ULONG TotalSize = DATA_HEADER_SIZE;
    BOOLEAN Overflowed = FALSE;

    HwGetEisaSlotInformation(&SlotInformation, Slot);

    TotalSize += sizeof(EISA_SLOT_INFORMATION);
    ConfigurationData = (FPVOID)HwAllocateHeap(TotalSize, FALSE);
    CurrentData = ConfigurationData + DATA_HEADER_SIZE;

    _fmemcpy(CurrentData, (FPVOID)&SlotInformation, sizeof(EISA_SLOT_INFORMATION));
    FarSlotInformation = (FPEISA_SLOT_INFORMATION)CurrentData;

    while (SlotInformation.ReturnCode != EISA_INVALID_SLOT) {

        //
        // Ensure that the slot is not empty and collect all the function
        // information for the slot.
        //

        if (SlotInformation.ReturnCode != EISA_EMPTY_SLOT) {

            while (SlotInformation.NumberFunctions > Function) {
                ReturnCode = HwGetEisaFunctionInformation(
                                         &FunctionInformation, Slot, Function);
                Function++;

                //
                // if function call succeeds and the function contains usefull
                // information or this is the last function for the slot and
                // there is no function information collected for the slot, we
                // will save this function information to our heap.
                //

                if (!ReturnCode) {
                    if (((FunctionInformation.FunctionFlags & 0x7f) != 0) ||
                        (SlotInformation.NumberFunctions == Function &&
                         SlotFunctions == 0)) {
                        CurrentData = (FPVOID)HwAllocateHeap(
                                      sizeof(EISA_FUNCTION_INFORMATION), FALSE);
                        if (CurrentData == NULL) {
                            Overflowed = TRUE;
                            break;
                        }
                        SlotFunctions++;
                        TotalSize += sizeof(EISA_FUNCTION_INFORMATION);
                        _fmemcpy(CurrentData,
                                (FPVOID)&FunctionInformation,
                                sizeof(EISA_FUNCTION_INFORMATION));
                    }
                }
            }
            FarSlotInformation->NumberFunctions = SlotFunctions;
        }
        if (Overflowed) {
            break;
        }
        Slot++;
        Function = 0;
        HwGetEisaSlotInformation(&SlotInformation, Slot);
        CurrentData = (FPVOID)HwAllocateHeap(
                                  sizeof(EISA_SLOT_INFORMATION), FALSE);
        if (CurrentData == NULL) {
            Overflowed = TRUE;
            break;
        }
        TotalSize += sizeof(EISA_SLOT_INFORMATION);
        _fmemcpy(CurrentData,
                (FPVOID)&SlotInformation,
                sizeof(EISA_SLOT_INFORMATION));
        FarSlotInformation = (FPEISA_SLOT_INFORMATION)CurrentData;
        SlotFunctions = 0;
    }

    //
    // Free the last EISA_SLOT_INFORMATION space which contains the slot
    // information for IVALID SLOT
    //

    if (Overflowed != TRUE) {
        HwFreeHeap(sizeof(EISA_SLOT_INFORMATION));
        TotalSize -= sizeof(EISA_SLOT_INFORMATION);
    }

    //
    // Check if we got any EISA information.  If nothing, we release
    // the space for data header and return.
    //

    if (TotalSize == DATA_HEADER_SIZE) {
        HwFreeHeap(DATA_HEADER_SIZE);
        *(FPULONG)Buffer = (ULONG)0;
        *Size = (ULONG)0;
    } else {
        HwSetUpFreeFormDataHeader((FPHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                                  0,
                                  0,
                                  0,
                                  TotalSize - DATA_HEADER_SIZE
                                  );
        *(FPULONG)Buffer = (ULONG)ConfigurationData;
        *Size = TotalSize;
    }
}

BOOLEAN
HwEisaGetIrqFromPort (
    USHORT Port,
    PUCHAR Irq,
    PUCHAR TriggerMethod
    )

/*++

Routine Description:

    This routine scans EISA configuration data to match the I/O port address.
    The IRQ information is returned from the matched EISA function information.

Arguments:

    Port - The I/O port address to scan for.

    Irq - Supplies a pointer to a variable to receive the irq information.

    TriggerMethod - Supplies a pointer to a variable to receive the
                    EISA interrupt trigger method.

Return Value:

    TRUE - if the Irq information is found.  Otherwise a value of FALSE is
    returned.

--*/

{
    UCHAR Function, i, j;
    FPEISA_SLOT_INFORMATION SlotInformation;
    FPEISA_FUNCTION_INFORMATION Buffer;
    UCHAR FunctionFlags;
    ULONG SizeToScan = 0L;
    EISA_PORT_CONFIGURATION PortConfig;
    EISA_IRQ_DESCRIPTOR IrqConfig;
    SlotInformation = (FPEISA_SLOT_INFORMATION)HwEisaConfigurationData;

    //
    // Scan through all the EISA configuration data.
    //

    while (SizeToScan < HwEisaConfigurationSize) {
        if (SlotInformation->ReturnCode != EISA_EMPTY_SLOT) {

            //
            // Make sure this slot contains PORT_RANGE and IRQ information.
            //

            if ((SlotInformation->FunctionInformation & EISA_HAS_PORT_RANGE) &&
                (SlotInformation->FunctionInformation & EISA_HAS_IRQ_ENTRY)) {

                Buffer = (FPEISA_FUNCTION_INFORMATION)(SlotInformation + 1);

                //
                // For each function of the slot, if it contains both the IRQ
                // and PORT information, we then check for its PORT address.
                //

                for (Function = 0; Function < SlotInformation->NumberFunctions; Function++) {
                    FunctionFlags = Buffer->FunctionFlags;
                    if ((FunctionFlags & EISA_HAS_IRQ_ENTRY) &&
                        (FunctionFlags & EISA_HAS_PORT_RANGE)) {
                        for (i = 0; i < 20 ; i++ ) {
                            PortConfig = Buffer->EisaPort[i];
                            if ((Port >= PortConfig.PortAddress) &&
                                (Port <= (PortConfig.PortAddress +
                                 PortConfig.Configuration.NumberPorts))) {

                                //
                                // If there is only one IRQ entry, that's the
                                // one we want.  (This is the normal case and
                                // correct usage of EISA function data.)  Otherwise,
                                // we try to get the irq from the same index
                                // number as port entry.  (This is ALR's incorrect
                                // way of packing functions into one function
                                // data.)
                                //

                                IrqConfig = Buffer->EisaIrq[0].ConfigurationByte;
                                if (IrqConfig.MoreEntries == 0) {
                                    *Irq = IrqConfig.Interrupt;
                                    *TriggerMethod = IrqConfig.LevelTriggered;
                                    return(TRUE);
                                } else if (i >= 7) {
                                    return(FALSE);
                                }

                                for (j = 0; j <= i; j++) {
                                    if (j == i) {
                                        *Irq = IrqConfig.Interrupt;
                                        *TriggerMethod = IrqConfig.LevelTriggered;
                                        return(TRUE);
                                    }
                                    if (!IrqConfig.MoreEntries) {
                                        return(FALSE);
                                    }
                                    IrqConfig =
                                        Buffer->EisaIrq[j+1].ConfigurationByte;
                                }
                                return(FALSE);
                            }
                            if (!PortConfig.Configuration.MoreEntries) {
                                break;
                            }
                        }
                    }
                    Buffer++;
                }
            }

            //
            // Move on to next slot
            //

            SizeToScan += sizeof(EISA_SLOT_INFORMATION) +
                          sizeof(EISA_FUNCTION_INFORMATION) *
                          SlotInformation->NumberFunctions;
            SlotInformation = (FPEISA_SLOT_INFORMATION)(HwEisaConfigurationData +
                                                        SizeToScan);
        } else {

            //
            // This is a empty slot.  We simply skip it.
            //

            SizeToScan += sizeof(EISA_SLOT_INFORMATION);
            SlotInformation++;
        }
    }
    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwpbiosc.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    hwpbiosc.c

Abstract:

    This modules contains PnP BIOS C supporting routines

Author:

    Shie-Lin Tzong (shielint) 20-Apr-1995

Environment:

    Real mode.

Revision History:

    Doug Fritz     (dfritz)   02-Oct-1997
      - Add: get docking station info from PnP BIOS and pass to NTLDR
          
    Alan Warwick   (alanwar)  10-Feb-1998
      - Add: get SMBIOS tables from PnP BIOS and pass to NTLDR

--*/

#include "hwdetect.h"
#include <string.h>
#include "smbios.h"
#include "pnpbios.h"

//
// Some global variables referenced by other routines
//
BOOLEAN SystemHas8259 = FALSE;
BOOLEAN SystemHas8253 = FALSE;

USHORT HwSMBIOSStructureLength(
    FPSMBIOS_STRUCT_HEADER StructHeader,
    USHORT MaxStructLen
    )
{
    USHORT length;
    UCHAR type;
    FPUCHAR stringPtr;
    
    type = StructHeader->Type;
    length = StructHeader->Length;

    //
    // The length of an SMBIOS structure can be computed by adding the size
    // specified in the structure header plus the space used by the string
    // table that immediately follows the structure header. The size of the
    // string table is determined by scanning for a double NUL. A problem is
    // that those structures that do not contain strings do not have a 
    // double NUL to indicate an empty string table. However since we do 
    // initialize the entire buffer to 0 before calling the bios there 
    // will always be a double nul at the end regardless of how the bios
    // fills writes the structure. 
        
    stringPtr = (FPUCHAR)StructHeader + StructHeader->Length;
            
    //
    // Loop one byte at a time until double NUL is found
    while ((*((FPUSHORT)stringPtr) != 0) && (length < MaxStructLen))
    {
        stringPtr++;
        length++;
    }
 
#if DBG
    if (length == MaxStructLen)
    {
        BlPrint("HwSMBIOSStructureLength: structure overflow 0x%x\n", length);
    }
#endif
    
    return(length);
}


USHORT HwGetSMBIOSInfo(
    ENTRY_POINT BiosEntry,
    USHORT RealModeDataBaseAddress,
    USHORT StructBufferSize,
    FPUCHAR StructBuffer
    )
/*++

Routine Description:

    This routine determine if SMBIOS information is available in the system
    and if so then collect the size needed for all of the information and
    actually collect the information.
        
    The SMBIOS tables are packed into a buffer end to end. The length of each
    SMBIOS table is determined by the length in the structure header plus 
    any memory used by the stirng space immediately after the fixed portion
    of the structure. The string space is terminated by a double NUL. However
    some structure types do not contain strings and thus do not have a
    string space so the length of the structure is simply the length specified
    in the structure header. However this routine will append a double NUL
    to those structures anyway so that the total length of each structure
    within the buffer can be determined by finding the first double NUL after 
    the length declared in the structure header.
    

Arguments:

    BiosEntry is the real mode entrypoint to the PnP bios
        
    RealModeDataBaseAddress
        
    StructBufferSize is the maximum number of bytes available to write in 
        StructBuffer
            
    StructBuffer is the buffer in which to write the SMBIOS data. If this is
        NULL then only the size needed to write the data is determined.

Return Value:

    Size of SMBIOS structures

--*/
{
    USHORT retCode;
    USHORT numberStructures;
    USHORT maxStructSize;
    ULONG dmiStorageBase;
    USHORT dmiStorageSize;
    UCHAR dmiBiosRevision;
    ULONG romAddr, romEnd;
    FPSMBIOS_EPS_HEADER header;
    FPDMIBIOS_EPS_HEADER dmiHeader;
    FPUCHAR current;
    UCHAR sum;
    USHORT j;
    USHORT structCount;
    USHORT structNumber;
    USHORT dmiStorageSegment;
    USHORT totalStructSize = 0;
    USHORT checkLength;
    FPSMBIOS_STRUCT_HEADER structHeader;
    USHORT length, lengthNeeded;
    FPUCHAR tempStructBuffer;
    
#if DBG
    BlPrint("GetSMBIOSInfo: Determining SMBIOS - Try for table\n");
#endif

    MAKE_FP(current, PNP_BIOS_START);
    romAddr = PNP_BIOS_START;
    romEnd  = PNP_BIOS_END;

    checkLength = 0;
    while (romAddr < romEnd) {
        header = (FPSMBIOS_EPS_HEADER)current;
        dmiHeader = (FPDMIBIOS_EPS_HEADER)current;
    
        if ((dmiHeader->Signature2[0] == '_') &&
            (dmiHeader->Signature2[1] == 'D') &&
            (dmiHeader->Signature2[2] == 'M') &&
            (dmiHeader->Signature2[3] == 'I') &&
            (dmiHeader->Signature2[4] == '_')) {
#if DBG
            BlPrint("GetSMBIOSInfo: found _DMI_ anchor string installation %lx\n",
                    dmiHeader);
#endif
            checkLength = sizeof(DMIBIOS_EPS_HEADER);
        } else if (header->Signature[0] == '_' && 
                   header->Signature[1] == 'S' &&
                   header->Signature[2] == 'M' && 
                   header->Signature[3] == '_' &&
                   header->Length >= sizeof(SMBIOS_EPS_HEADER) &&
                   header->Signature2[0] == '_' && 
                   header->Signature2[1] == 'D' &&
                   header->Signature2[2] == 'M' && 
                   header->Signature2[3] == 'I' &&
                   header->Signature2[4] == '_' ) {
#if DBG
            BlPrint("GetSMBIOSInfo: found _SM_ anchor string installation %lx\n",
                    header);
#endif
            checkLength = header->Length;
            dmiHeader = (FPDMIBIOS_EPS_HEADER)&header->Signature2[0];
        }

        if (checkLength != 0)
        {
            sum = 0;
            for (j = 0; j < checkLength; j++) {
                sum += current[j];
            }
        
            if (sum == 0) {            
                break;
            }
#if DBG
            BlPrint("GetSMBIOSInfo: Checksum fails\n");
#endif
            checkLength = 0;
        }
        
        romAddr += PNP_BIOS_HEADER_INCREMENT;
        MAKE_FP(current, romAddr);        
    }
  
    if (romAddr >= romEnd) {
        //
        // We could not find the table so try the calling method
        dmiBiosRevision = 0;
        numberStructures = 0;
        retCode = BiosEntry(GET_DMI_INFORMATION,
                            (FPUCHAR)&dmiBiosRevision,
                            (FPUSHORT)&numberStructures,
                            (FPUSHORT)&maxStructSize,
                            (FPULONG)&dmiStorageBase,
                            (FPUSHORT)&dmiStorageSize,
                            RealModeDataBaseAddress);
            
        if ((retCode != DMI_SUCCESS) ||
            (dmiBiosRevision < 0x20))
        {
#if DBG
            BlPrint("GetSMBIOSInfo: GET_DMI_INFORMATION failed %x\n", retCode);
#endif
        return(0);
#if DBG
        } else {
            BlPrint("GetSMBIOSInfo: GET_DMI_INFORMATION\n");
            BlPrint("    BiosRevision %x      Number Structures %x     Structure Size %x\n", dmiBiosRevision, numberStructures, maxStructSize);
            BlPrint("    StorageBase %lx       StorageSize %x\n", dmiStorageBase, dmiStorageSize);
#endif        
        }    
    
        maxStructSize += 3;
        tempStructBuffer = HwAllocateHeap(maxStructSize, FALSE);
        if (tempStructBuffer == NULL)
        {
#if DBG
            BlPrint("GetSMBIOSInfo: HwAllocateHeap(structureSize = 0x%x\n",
                    maxStructSize);
#endif
            return(0);
        }
        
        //
        // Loop calling Get_DMI_STRUCTURE to get next structure until we
        // hit the end of structure or receive an error.
        structCount = 0;
        structNumber = 0;
        dmiStorageSegment = (USHORT)(dmiStorageBase >> 4);
        while ((structCount < numberStructures) && 
               (retCode == DMI_SUCCESS) && 
               (structNumber != 0xffff))
        {
            _fmemset(tempStructBuffer, 0, maxStructSize);
            retCode = BiosEntry(GET_DMI_STRUCTURE,
                                (FPUSHORT)&structNumber,
                                (FPUCHAR)tempStructBuffer,
                                dmiStorageSegment,
                                RealModeDataBaseAddress
                                );
#if DBG
            BlPrint("GetSMBIOSInfo: GET_DMI_STRUCTURE --> %x\n", retCode);
#endif
            if (retCode == DMI_SUCCESS)
            {                                   
                structCount++;
                structHeader = (FPSMBIOS_STRUCT_HEADER)tempStructBuffer;
        
                length = HwSMBIOSStructureLength(structHeader, maxStructSize);
                
                lengthNeeded = length + 2;
                if (StructBuffer != NULL)
                {
                    //
                    // if caller wants the data then lets copy into it buffer
                    if (StructBufferSize >= lengthNeeded)
                    {
                        _fmemcpy(StructBuffer, 
                                 tempStructBuffer,
                                 length);
             
                        *((FPUSHORT)&StructBuffer[length]) = 0;
            
                        StructBufferSize -= lengthNeeded;
                        StructBuffer += lengthNeeded;
                        totalStructSize += lengthNeeded;
#if DBG
                    } else {
                        BlPrint("GetSMBIOSInfo: Struct too large 0x%x bytes left\n",
                                 StructBufferSize);
#endif
                    }
                } else {
                    //
                    // Caller is only interested in length required
                    totalStructSize += lengthNeeded;
                }
                
#if DBG
                BlPrint("GetSMBIOSInfo: Number 0x%x Type 0x%x Length 0x%x/0x%x Handle 0x%x\n",
                        structNumber,
                        structHeader->Type,
                        structHeader->Length,
                        length,
                        structHeader->Handle);
                for (j = 0; j < structHeader->Length; j = j + 16)
                {
                    BlPrint("              %x %x %x %x %x %x %x %x\n              %x %x %x %x %x %x %x %x\n",
                            structHeader->Data[j],
                            structHeader->Data[j+1],
                            structHeader->Data[j+2],
                            structHeader->Data[j+3],
                            structHeader->Data[j+4],
                            structHeader->Data[j+5],
                            structHeader->Data[j+6],
                            structHeader->Data[j+7],
                            structHeader->Data[j+8],
                            structHeader->Data[j+9],
                            structHeader->Data[j+10],
                            structHeader->Data[j+11],
                            structHeader->Data[j+12],
                            structHeader->Data[j+13],
                            structHeader->Data[j+14],
                            structHeader->Data[j]+15);
                }
                
                for (j = structHeader->Length; j < length; j++)
                {
                    BlPrint("%c", structHeader->Data[j-sizeof(SMBIOS_STRUCT_HEADER)]);
                    if (structHeader->Data[j-sizeof(SMBIOS_STRUCT_HEADER)] == 0)
                    {
                        BlPrint("\n");
                    }
                }
                BlPrint("\n");
#endif                    
            }
#if DBG
            while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif
        }
        HwFreeHeap(maxStructSize);
#if DBG
        BlPrint("GetSMBIOSInfo: %x/%x structures read, total size 0x%x\n",
                 structCount, numberStructures, totalStructSize);
#endif
        
#if DBG
    } else {
        if ((FPVOID)dmiHeader != (FPVOID)header)
        {
            BlPrint("GetSMBIOSInfo: _SM_ Structure Table\n");
            BlPrint("    Length   %x    MajorVersion   %x    MinorVersion   %x\n",
                         header->Length, header->MajorVersion, header->MinorVersion);
            BlPrint("    MaximumStructureSize %x    EntryPointRevision %x    StructureTableLength %x\n",
                header->MaximumStructureSize, header->EntryPointRevision, header->StructureTableLength);
            BlPrint("    StructureTableAddress %x    NumberStructures %x    Revision %x\n",
                         header->StructureTableAddress, header->NumberStructures, header->Revision);
        } else {
            BlPrint("GetSMBIOSInfo: _DMI_ Structure Table\n");
            BlPrint("    StructureTableLength %x\n",
                         dmiHeader->StructureTableLength);
            BlPrint("    StructureTableAddress %x    NumberStructures %x    Revision %x\n",
                         dmiHeader->StructureTableAddress, dmiHeader->NumberStructures, dmiHeader->Revision);
        }
#endif
    }

#if DBG
    while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif
                            
    return(totalStructSize);                        
}
    

#if 0
VOID
HwDisablePnPBiosDevnode(
    ENTRY_POINT biosEntry,
    FPPNP_BIOS_INSTALLATION_CHECK header,
    UCHAR node,
    FPPNP_BIOS_DEVICE_NODE deviceNode
    )
{
    USHORT control = GET_CURRENT_CONFIGURATION;
    USHORT retCode;
    FPUCHAR buffer;
    USHORT i;
    UCHAR code;
#if 0
    BlPrint("DisablePnPBiosDevnode: found it\n");
    while ( !HwGetKey() ) ; // wait until key pressed to continue
    
    buffer = (FPUCHAR)deviceNode;
    
    for (i = 0; i < deviceNode->Size; i++) {
        BlPrint("%x ", *buffer++);
        if ( ((i+1)%16) == 0) {
            BlPrint("\n");
        }
    }
    BlPrint("\n");
#endif    

    //
    // Zero out allocated resources
    //        
    buffer = (FPUCHAR)(deviceNode+1);

    if (deviceNode->Size <= sizeof(PNP_BIOS_DEVICE_NODE)) {
        return;
    }
    
    for (i = 0; i < (deviceNode->Size - sizeof(PNP_BIOS_DEVICE_NODE)); i++) {
     
        code = *buffer;
#define PNP_BIOS_END_TAG 0x79
        if (code == PNP_BIOS_END_TAG) {
            //
            // found END TAG
            // write checksum
            //
            *(++buffer) = (UCHAR) (0 - PNP_BIOS_END_TAG);
            break;
        }
        *buffer++ = 0;
    }                
    
    
#if 0
    buffer = (FPUCHAR)deviceNode;
    
    for (i = 0; i < deviceNode->Size; i++) {
        BlPrint("%x ", *buffer++);
        if ( ((i+1)%16) == 0) {
            BlPrint("\n");
        }
    }
    BlPrint("\n");
    
    while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif    

    retCode = biosEntry(PNP_BIOS_SET_DEVICE_NODE,
                        node,
                        deviceNode,
                        control,
                        header->RealModeDataBaseAddress
                        );

#if DBG
    if (retCode != 0) {
        BlPrint("HwDisablePnPBiosDevnode: PnP Bios func 2 returns failure = %x.\n", retCode);
    }
#endif
}
#endif

//
// Global Variable within NTDETECT
//   - structure definition in dockinfo.h
//   - extern declaration in hwdetect.h
//   - used in hwpbios.c and hwdetect.c
//


BOOLEAN
HwGetPnpBiosSystemData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT PnPBiosLength,
    OUT PUSHORT SMBIOSLength,
    IN OUT FPDOCKING_STATION_INFO DockInfo
    )
/*++

Routine Description:

    This routine checks if PNP BIOS is present in the machine.  If yes, it
    also create a registry descriptor to collect the BIOS data.

Arguments:

    Configuration - Supplies a variable to receive the PNP BIOS data.

    PnPBiosLength - Supplies a variable to receive the size of the PnP Bios 
                    data (Does not include HEADER)
                
    SMBIOSBiosLength - Supplies a variable to receive the size of the SMBIOS
                       data (Does not include HEADER). Total size of buffer
                       returned is in *Configuration is (*PnPBiosLength + 
                       *SMBIOSLength + 2 * DATA_HEADER_SIZE)
                   
    DockInfo - 

Return Value:

    A value of TRUE is returned if success.  Otherwise, a value of
    FALSE is returned.

--*/
{
    ULONG romAddr, romEnd;
    FPUCHAR current;
    FPPNP_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    UCHAR currentNode;
    USHORT i, totalSize = 0, nodeSize, numberNodes, retCode;
    ENTRY_POINT biosEntry;
    FPPNP_BIOS_DEVICE_NODE deviceNode;
    USHORT control = GET_CURRENT_CONFIGURATION;
    USHORT sMBIOSBufferSize;
    FPUCHAR sMBIOSBuffer;

    //
    // Perform PNP BIOS installation Check
    //

    MAKE_FP(current, PNP_BIOS_START);
    romAddr = PNP_BIOS_START;
    romEnd  = PNP_BIOS_END;

    while (romAddr < romEnd) {
        header = (FPPNP_BIOS_INSTALLATION_CHECK)current;
        if (header->Signature[0] == '$' && header->Signature[1] == 'P' &&
            header->Signature[2] == 'n' && header->Signature[3] == 'P' &&
            header->Length >= sizeof(PNP_BIOS_INSTALLATION_CHECK)) {
#if DBG
            BlPrint("GetPnpBiosData: find Pnp installation\n");
#endif
            sum = 0;
            for (i = 0; i < header->Length; i++) {
                sum += current[i];
            }
            if (sum == 0) {
                break;
            }
#if DBG
            BlPrint("GetPnpBiosData: Checksum fails\n");
#endif
        }
        romAddr += PNP_BIOS_HEADER_INCREMENT;
        MAKE_FP(current, romAddr);
    }
    if (romAddr >= romEnd) {
        return FALSE;
    }

#if DBG
    BlPrint("PnP installation check at %lx\n", romAddr);
#endif


    //
    // Determine how much space we will need and allocate heap space
    //

    totalSize += sizeof(PNP_BIOS_INSTALLATION_CHECK);
    biosEntry = *(ENTRY_POINT far *)&header->RealModeEntryOffset;

    //
    // Determine size needed for SMBIOS data 
    sMBIOSBufferSize = HwGetSMBIOSInfo(biosEntry,
                                           header->RealModeDataBaseAddress,
                                           0,
                                           NULL);
                                      
    if (sMBIOSBufferSize > MAXSMBIOS20SIZE)
    {
#if DBG
        BlPrint("GetPnpBiosData: SMBIOS data structures are too large 0x%x bytes\n",
                 sMBIOSBufferSize);
        while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif
        sMBIOSBufferSize = 0;
    }
                   
    retCode = biosEntry(PNP_BIOS_GET_NUMBER_DEVICE_NODES,
                        (FPUSHORT)&numberNodes,
                        (FPUSHORT)&nodeSize,
                        header->RealModeDataBaseAddress
                        );
    if (retCode != 0) {
#if DBG
        BlPrint("GetPnpBiosData: PnP Bios GetNumberNodes func returns failure %x.\n", retCode);
#endif
        return FALSE;
    }

#if DBG
    BlPrint("GetPnpBiosData: Pnp Bios GetNumberNodes returns %x nodes\n", numberNodes);
#endif
    deviceNode = (FPPNP_BIOS_DEVICE_NODE) HwAllocateHeap(nodeSize, FALSE);
    if (!deviceNode) {
#if DBG
        BlPrint("GetPnpBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    while (node != 0xFF) {
        retCode = biosEntry(PNP_BIOS_GET_DEVICE_NODE,
                            (FPUCHAR)&node,
                            deviceNode,
                            control,
                            header->RealModeDataBaseAddress
                            );
        if (retCode != 0) {
#if DBG
            BlPrint("GetPnpBiosData: PnP Bios GetDeviceNode func returns failure = %x.\n", retCode);
#endif
            HwFreeHeap((ULONG)nodeSize);
            return FALSE;
        }
#if DBG
        BlPrint("GetPnpBiosData: PnpBios GetDeviceNode returns nodesize %x for node %x\n", deviceNode->Size, node);
#endif
        totalSize += deviceNode->Size;
    }

#if DBG
    BlPrint("GetPnpBiosData: PnpBios total size of nodes %x\n", totalSize);
#endif

    HwFreeHeap((ULONG)nodeSize);       // Free temporary buffer


    *PnPBiosLength = totalSize;
    *SMBIOSLength = sMBIOSBufferSize;
    
    
    //
    // Allocate enough room for 2 HWPARTIAL_RESOURCE_DESCRIPTORS (one for 
    // PnP bios and one for SMBios) plus room to keep the data.
    totalSize +=  sMBIOSBufferSize +  DATA_HEADER_SIZE + sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR);            
    current = (FPUCHAR) HwAllocateHeap(totalSize, FALSE);
    if (!current) {
#if DBG
        BlPrint("GetPnpBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    //
    // Collect PnP Bios installation check data and device node data.
    //

    _fmemcpy (current + DATA_HEADER_SIZE,
              (FPUCHAR)header,
              sizeof(PNP_BIOS_INSTALLATION_CHECK)
              );
    deviceNode = (FPPNP_BIOS_DEVICE_NODE)(current + DATA_HEADER_SIZE +
                                          sizeof(PNP_BIOS_INSTALLATION_CHECK));
    node = 0;
    while (node != 0xFF) {
        currentNode = node;
    
        retCode = biosEntry(PNP_BIOS_GET_DEVICE_NODE,
                            (FPUCHAR)&node,
                            deviceNode,
                            control,
                            header->RealModeDataBaseAddress
                            );
        if (retCode != 0) {
#if DBG
            BlPrint("GetPnpBiosData: PnP Bios func 1 returns failure = %x.\n", retCode);
#endif
            HwFreeHeap((ULONG)totalSize);
            return FALSE;
        }

        //
        // Record the existance of certain devices for the benefit of other
        // routines in ntdetect. For example, the pccard irq detection code
        // uses the PIC and an 8237... this insures that we actually have
        // those devices.
        //
        
        if (deviceNode->ProductId == 0xd041) {  // PNP0000
            SystemHas8259 = TRUE;
        } else if (deviceNode->ProductId == 0x1d041) {  // PNP0100
            SystemHas8253 = TRUE;
        }
        
        deviceNode = (FPPNP_BIOS_DEVICE_NODE)((FPUCHAR)deviceNode + deviceNode->Size);
    }

    //
    // Collect SMBIOS Data, skipping over PartialDescriptor which is filled in
    // by the caller of this routine
    if (sMBIOSBufferSize != 0)
    {
        
        sMBIOSBuffer = (FPUCHAR)deviceNode;
        sMBIOSBuffer += sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR);
        retCode = HwGetSMBIOSInfo(biosEntry,
                                  header->RealModeDataBaseAddress,
                                  sMBIOSBufferSize,
                                  sMBIOSBuffer);
#if DBG
        BlPrint("SMBIOS asked for 0x%x bytes and filled 0x%x bytes into %lx\n",
            sMBIOSBufferSize, retCode, sMBIOSBuffer);
#endif           
    }
    
    
    *Configuration = current;

    //
    // call PnP BIOS to get docking station information
    //

    DockInfo->ReturnCode = biosEntry(PNP_BIOS_GET_DOCK_INFORMATION,
                                    (FPUCHAR) DockInfo,
                                    header->RealModeDataBaseAddress
                                    );

#if DBG
    BlPrint("\npress any key to continue...\n");
    while ( !HwGetKey() ) ; // wait until key pressed to continue
    clrscrn();
    BlPrint("*** DockInfo - BEGIN ***\n\n");

    BlPrint("ReturnCode= 0x%x (Other fields undefined if ReturnCode != 0)\n",
            DockInfo->ReturnCode
            );
    BlPrint("  0x0000 = SUCCESS (docked)\n");
    BlPrint("  0x0082 = FUNCTION_NOT_SUPPORTED\n");
    BlPrint("  0x0087 = SYSTEM_NOT_DOCKED\n");
    BlPrint("  0x0089 = UNABLE_TO_DETERMINE_DOCK_CAPABILITIES\n\n");

    BlPrint("DockID = 0x%lx\n", DockInfo->DockID);
    BlPrint("  0xFFFFFFFF if product has no identifier (DockID)\n\n");

    BlPrint("SerialNumber = 0x%lx\n", DockInfo->SerialNumber);
    BlPrint("  0 if docking station has no SerialNumber\n\n");

    BlPrint("Capabilities = 0x%x\n" , DockInfo->Capabilities);
    BlPrint("  Bits 15:3 - reserved (0)\n");
    BlPrint("  Bits  2:1 - docking: 00=cold, 01=warm, 10=hot, 11=reserved\n");
    BlPrint("  Bit     0 - docking/undocking: 0=surprise style, 1=vcr style\n\n");

    BlPrint("*** DockInfo - END ***\n\n");

    BlPrint("press any key to continue...\n");
    while ( !HwGetKey() ) ; // wait until key pressed to continue
    clrscrn();
#endif // DBG


    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hweisaa.asm ===
title  "EISA bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    eisaa.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to get configuration
;    information on EISA machines.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 7-June-1991
;
; Environment:
;
;    Real Mode 16-bit code.
;
; Revision History:
;
;
;--


.386p
        .xlist
include hweisa.inc
        .list

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

        public  _FunctionInformation
_FunctionInformation     db      0
                         db      EISA_INFORMATION_BLOCK_LENGTH dup (0)

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; VOID
; HwGetEisaSlotInformation (
;    PBTEISA_SLOT_INFORMATION SlotInformation,
;    UCHAR Slot
;    )
;
; Routine Description:
;
;    This function retrieves the slot information for the specified slot.
;
; Arguments:
;
;    SlotInformation - Supplies a pointer to the structure which will
;                      receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
; Return Value:
;
;    None.
;
;--

HgesSlotInformation     equ     [bp + 4]
HgesSlot                equ     [bp + 6]

        public  _HwGetEisaSlotInformation
_HwGetEisaSlotInformation       proc

        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx

        mov     cl, HgesSlot
        mov     ax, GET_EISA_SLOT_INFORMATION
        int     15h

        push    bx                      ; Save revision level
        mov     bx, HgesSlotInformation

        ;
        ; fill values into eisa slot info structure.
        ;

        mov     [bx].SlotReturn, ah
        mov     [bx].SlotFlags, al
        pop     ax                      ; [ax] = revision level
        mov     [bx].SlotMajorRevision, ah
        mov     [bx].SlotMinorRevision, al
        mov     [bx].SlotChecksum, cx
        mov     [bx].SlotNumberFunctions, dh
        mov     [bx].SlotFunctionInformation, dl
        mov     word ptr [bx].SlotCompressedId, di
        mov     word ptr [bx+2].SlotCompressedId, si

        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_HwGetEisaSlotInformation       endp

;++
;
; UCHAR
; HwGetEisaFunctionInformation (
;    PBTEISA_FUNCTION_INFORMATION FunctionInformation,
;    UCHAR Slot,
;    UCHAR Function
;    )
;
; Routine Description:
;
;    This function retrieves function information for the specified slot
;    and function.
;
; Arguments:
;
;    FunctionInformation - Supplies a pointer to the structure which will
;           receive the slot information.
;
;    Slot - Specifies the slot to retrieve the information.
;
;    Function - Supplies the function number of the desired slot.
;
; Return Value:
;
;    Return code of the EISA function call.
;
;--

HgefFunctionInformation equ     [bp + 4]
HgefSlot                equ     [bp + 6]
HgefFunction            equ     [bp + 8]

        public  _HwGetEisaFunctionInformation
_HwGetEisaFunctionInformation     proc

        push    bp
        mov     bp, sp
        push    si

        mov     ax, GET_EISA_FUNCTION_INFORMATION
        mov     cl, HgefSlot            ; [cl] = slot, [ch]=function
        mov     ch, HgefFunction
        mov     si, HgefFunctionInformation
                                        ; (ds:si)->Function information
        int     15h

        mov     al, ah                  ; move the return code to AL

        pop     si
        pop     bp
        ret
_HwGetEisaFunctionInformation     endp

;++
;
; BOOLEAN
; HwIsEisaSystem (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines if the target machines is EISA based machines.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE - if this is EISA machine.  Otherwise, a value of FALSE is returned.
;--

        public _HwIsEisaSystem
_HwIsEisaSystem proc

        push    es
        push    bx

;
;       Check for an EISA system.  If "EISA" is at F000:FFD9h then it
;       is an EISA system.
;

        mov     ax,0f000h               ; segment
        mov     es,ax
        mov     bx,0ffd9h               ; offset in the ROM
        mov     eax, "ASIE"
        cmp     eax, es:[bx]
        jne     short hies00            ; if ne, Not EISA system, go bies00

        mov     ax, 1                   ; set return value to TRUE
        jmp     short hies10

hies00:
        mov     ax, 0
hies10:
        pop     bx
        pop     es
        ret
_HwIsEisaSystem endp

;++
;
; VOID
; Int15 (
;   PULONG  eax,
;   PULONG  ebx,
;   PULONG  ecx,
;   PULONG  edx,
;   PULONG  CyFlag
;   )
;
; Routine Description:
;
;   Calls Int15 with the requesed registers and returns the result
;
;--

        public _Int15
_Int15 proc
        push    bp
        mov     bp, sp
        push    esi
        push    edi
        push    ebx

        mov     si, [bp+4]          ; pointer to eax
        mov     eax, [si]

        mov     si, [bp+6]          ; pointer to ebx
        mov     ebx, [si]

        mov     si, [bp+8]          ; pointer to ecx
        mov     ecx, [si]

        mov     si, [bp+10]         ; pointer to edx
        mov     edx, [si]

        int     15h                 ; do it

        mov     si, [bp+4]          ; pointer to eax
        mov     [si], eax

        mov     si, [bp+6]          ; pointer to ebx
        mov     [si], ebx

        mov     si, [bp+8]          ; pointer to ecx
        mov     [si], ecx

        mov     si, [bp+10]         ; pointer to edx
        mov     [si], edx

        sbb     eax, eax
        mov     si, [bp+12]         ; pointer CyFlag
        mov     [si], eax

        pop     ebx
        pop     edi
        pop     esi
        pop     bp
        ret
_Int15 endp

;++
;
; BOOLEAN
; Int15E820 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets address range descriptor by calling int 15 function E820h.
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E820
_Int15E820 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     ebx, [bp].Key
        mov     ecx, [bp].DescSize
        lea     di,  [bp].BaseAddrLow
        mov     eax, 0E820h
        mov     edx, 'SMAP'             ; (edx) = signature

        INT     15h

        mov     [bp].Key, ebx           ; update callers ebx
        mov     [bp].DescSize, ecx      ; update callers size

        sbb     ecx, ecx                ; ecx = -1 if carry, else 0
        sub     eax, 'SMAP'             ; eax = 0 if signature matched
        or      ecx, eax
        mov     [bp].ErrorFlag, ecx     ; return 0 or non-zero

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E820 endp

;++
;
; BOOLEAN
; Int15E980 (
;     E820Frame     *Frame
;     );
;
;
; Description:
;
;       Gets Geyserville information by calling INT 15 E980h
;
; Arguments:
;
; Returns:
;
;       BOOLEAN - failed or succeed.
;
;--

cmdpFrame       equ     [bp + 6]
public _Int15E980
_Int15E980 proc near

        push    ebp
        mov     bp, sp
        mov     bp, cmdpFrame           ; (bp) = Frame
        push    es
        push    edi
        push    esi
        push    ebx

        push    ss
        pop     es

        mov     eax, 0E980h
        mov     edx, 47534943h          ; (edx) = signature 'GSIC'

        INT     15h

        sbb     eax, eax                ; eax = -1 if carry, else 0
        not     eax

        ;
        ; Pass back the information that the caller wanted
        ;
        
        mov     [bp].CommandPortAddress, bx
        shr     ebx, 16
        mov     [bp].CommandDataValue, bl
        mov     [bp].EventPortAddress, cx
        shr     ecx, 16
        mov     [bp].EventPortBitmask, cl
        mov     [bp].MaxLevelAc, dh
        mov     [bp].MaxLevelDc, dl
        shr     edx, 16
        mov     [bp].PollInterval, dx

        pop     ebx
        pop     esi
        pop     edi
        pop     es
        pop     ebp
        ret

_Int15E980 endp

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwpcia.asm ===
title  "PCI bus Support Assembley Code"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    hwpcia.asm
;
; Abstract:
;
;   Calls the PCI rom function to determine what type of PCI
;   support is prsent, if any.
;
;   Base code provided by Intel
;
; Author:
;
;--


.386p
        .xlist
include hwpci.inc
        .list

if DBG
        extrn   _BlPrint:PROC
endif

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

if DBG
cr  equ 11

PciBIOSSig          db  'PCI: Scanning for "PCI "', cr, 0
PciBIOSSigNotFound  db  'PCI: BIOS "PCI " not found', cr, 0


PciInt              db  'PCI: Calling PCI_BIOS_PRESENT', cr, 0
PciIntFailed        db  'PCI: PCI_BIOS_PRESENT returned carry', cr, 0
PciIntAhFailed      db  'PCI: PCI_BIOS_PRESENT returned bad AH value', cr, 0
PciIDFailed         db  'PCI: PCI_BIOS_PRESENT invalid PCI id', cr, 0
PciInt10IdFailed    db  'PCI: PCI10_BIOS_PRESENT invalid PCI id', cr, 0

PciFound            db  'PCI BUS FOUND', cr, 0

PciBadRead          db  'PCI BAD READ', cr, 0
endif

_DATA   ends


_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT

;++
;
; BOOLEAN
; HwGetPciSystemData (
;    PPCI_SYSTEM_DATA PciSystemData
;    )
;
; Routine Description:
;
;    This function retrieves the PCI System Data
;
; Arguments:
;
;    PciSystemData - Supplies a pointer to the structure which will
;                      receive the PCI System Data.
;
; Return Value:
;
;    True - PCI System Detected and System Data valid
;    False - PCI System Not Detected
;
;--

SystemInfoPointer     equ     [bp + 4]
BiosDateFound         equ     [bp + 6]

        public  _HwGetPciSystemData
_HwGetPciSystemData       proc
        push    bp                      ; The following INT 15H destroies
        mov     bp, sp                  ;   ALL the general registers.
        push    si
        push    di
        push    bx
;
; Set for no PCI buses present
;

        mov     bx, SystemInfoPointer
        mov     byte ptr [bx].NoBuses, 0

;
; Is the BIOS date >= 11/01/92?   If so, make the int-1a call
;
        push    ds
        cmp     byte ptr [BiosDateFound], 0
        jnz     gpci00

;
; A valid BIOS date was not found, check for "PCI " in bios code.
;

if DBG
        push    offset PciBIOSSig
        call    _BlPrint
        add     sp, 2
endif
        mov     bx, 0f000h
        mov     ds, bx
        mov     bx, 0fffch

spci05: cmp     dword ptr ds:[bx], ' ICP'   ; 'PCI ' found at this addr?
        je      short gpci00                ; found

        dec     bx                          ; next location
        jnz     short spci05                ; loop
        jmp     spci_notfound               ; wrapped, all done - not found

gpci00:
        pop     ds

if DBG
        push    offset PciInt
        call    _BlPrint
        add     sp, 2
endif
;
; Check for a PCI system.  Issue the PCI Present request.
;

        mov     ax, PCI_BIOS_PRESENT        ; Real Mode Presence Request
        int     PCI_INTERFACE_INT           ; Just Do It!

        jc      gpci10                      ; Carry Set => No PCI

        cmp     ah, 0                       ; If PCI Present AH == 0
        jne     gpci12                      ; AH != 0 => No PCI

        cmp     edx, " ICP"                 ; "PCI" Backwards (with a trailing space)
        jne     gpci14                      ; PCI Signature in EDX => PCI Exists

;
; Found PCI BIOS Version > 1.0
;
; The only thing left to do is squirrel the data away for the caller
;

        mov     dx, bx                              ; Save revision level
        mov     bx, SystemInfoPointer               ; Get caller's Pointer

        mov     byte ptr [bx].MajorRevision, dh
        mov     byte ptr [bx].MinorRevision, dl
        inc     cl                                  ; NoBuses = LastBus+1

if 0
;
; Some PIC BIOS returns very large number of NoBuses.  As a work-
; around we mask the value to 16, unless the BIOS also return CH as
; neg cl then we believe it.
;

        cmp     cl, 16
        jbe     short @f

        neg     ch
        inc     ch
        cmp     cl, ch
        je      short @f

        mov     cl, 16
@@:
endif


        mov     byte ptr [bx].NoBuses, cl
        mov     byte ptr [bx].HwMechanism, al
        jmp     Done                                ; We're done

if DBG
gpci10: mov     ax, offset PciIntFailed
        jmp     short gpci_oldbios

gpci12: mov     ax, offset PciIntAhFailed
        jmp     short gpci_oldbios

gpci14: mov     ax, offset PciIDFailed
gpci_oldbios:
        push    ax
        call    _BlPrint
        add     sp, 2

else

gpci10:
gpci12:
gpci14:

endif


    ;
    ; Look for BIOS Version 1.0,  This has a different function #
    ;

        mov     ax, PCI10_BIOS_PRESENT      ; Real Mode Presence Request
        int     PCI_INTERFACE_INT           ; Just Do It!

    ; Version 1.0 has "PCI " in dx and cx, the Version number in ax, and the
    ; carry flag cleared.  These are all the indications available.
    ;

        cmp     dx, "CP"                    ; "PC" Backwards
        jne     gpci50                      ; PCI Signature not in DX & CX => No PCI

        cmp     cx, " I"                    ; "I " Backwards
        jne     gpci50                      ; PCI Signature not in EDX => No PCI

;
; Found PCI BIOS Version 1.0
;
; The only thing left to do is squirrel the data away for the caller
;

        mov     bx, SystemInfoPointer       ; Get caller's Pointer

        mov     byte ptr [bx].MajorRevision, ah
        mov     byte ptr [bx].MinorRevision, al

    ;
    ;  The Version 1.0 BIOS is only on early HW that had couldn't support
    ;  Multi Function devices or multiple bus's.  So without reading any
    ;  device data, mark it as such.
    ;

        mov     byte ptr [bx].HwMechanism, 2
        mov     byte ptr [bx].NoBuses, 1
        jmp     Done


spci_notfound:
        pop     ds                      ; restore ds
if DBG
        push    offset PciBIOSSigNotFound
        call    _BlPrint
        add     sp, 2
endif
        jmp     gpci_exit


if DBG
gpci50: push    offset PciInt10IdFailed
        jmp     Done10

Done:   push    offset PciFound
Done10: call    _BlPrint
        add     sp, 2

else

; non-debug no prints
gpci50:
Done:

endif

gpci_exit:
        pop     bx
        pop     di
        pop     si
        pop     bp
        ret

_HwGetPciSystemData       endp

RouteBuffer     equ     [bp + 4]
ExclusiveIRQs   equ     [bp + 8]

        public  _HwGetPciIrqRoutingOptions
_HwGetPciIrqRoutingOptions       proc
                push            bp
                mov             bp, sp                                  ; Create 'C' stack frame.

                push            ebx
                push            edi
                push            esi                                             ; Save registers used.

                push            es                                              
                push            ds

                xor             edi, edi
                
                les             di, RouteBuffer
                mov             bx, 0f000h
                mov             ds, bx
                xor             ebx, ebx
                mov             ax, 0B10Eh                

                int             PCI_INTERFACE_INT

                pop             ds
                pop             es                                              

                mov             di, ExclusiveIRQs       
                mov             [di], bx                                                

                mov             al, ah

                pop             esi                                             ; Restore registers.
                pop             edi
                pop             ebx
                
                pop             bp
                ret

_HwGetPciIrqRoutingOptions endp

Bus             equ     [bp + 4]
Device          equ     [bp + 6]
Function        equ     [bp + 8]
RegOffset       equ     [bp + 10]
DataRead        equ     [bp + 12]

        public  _HwGetPciConfigurationDword
_HwGetPciConfigurationDword     proc
                push            bp
                mov             bp, sp                                  ; Create 'C' stack frame.

                push            ebx
                push            ecx
                push            edi
                push            esi                                             ; Save registers used.

                push            es                                              
                push            ds

                mov             bl, Device
                shl             bl, 3
                or              bl, Function
                mov             bh, Bus
                mov             di, RegOffset
                mov             ax, 0B10Ah                

                int             PCI_INTERFACE_INT

                jc              gbadread                      ; Carry Set => Read failed
                pop             ds
                pop             es                                              

                mov             di, DataRead       
                mov             [di], ecx                                                

                mov             al, ah
                jmp             greaddone

if DBG
gbadread:       push            offset PciBadRead
                call            _BlPrint
                add             sp, 2
                mov             al, 087h
else
gbadread:
endif
greaddone:      pop             esi             ; Restore registers.
                pop             edi
                pop             ecx
                pop             ebx
                
                pop             bp
                ret

_HwGetPciConfigurationDword endp


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\keybda.asm ===
title  "Keyboard Detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    keyboard.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 16-Dec-1991.  Most of the code is extracted
;    from Win31 Setup.
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

extrn           _READ_PORT_UCHAR:proc

;
; Now define the needed equates.
;

TRUE                equ         -1
FALSE               equ         0

;
; equates for ports -- these are used in the keyboard detection module.
;

ack_port        equ     20h     ; 8259 acknowledge port
eoi             equ     20h     ; 8259 end of interrupt

kb_data         equ     60h
kb_ctl          equ     61h
kb_command      equ     64h     ;
kb_status       equ     64h     ; status port -- bit 1: ok to write

ENABLE_KEYBOARD_COMMAND         EQU     0AEH
DISABLE_KEYBOARD_COMMAND        EQU     0ADH

.386

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING


;++
;
; BOOLEAN
; IsEnhancedKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    Function looks at bios data area 40:96 to see if an enhanced keyboard
;    is present.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    TRUE if Enhanced keyboard is present.  Else a value of FALSE is returned.
;
;--

        Public  _IsEnhancedKeyboard
_IsEnhancedKeyboard     proc    near

        push    es

        mov     ax,40h
        mov     es,ax
        xor     ax,ax
        mov     al,byte ptr es:[96h]
        and     al,00010000b

        pop     es
        ret

_IsEnhancedKeyboard     endp


;++
;
; SHORT
; GetKeyboardIdBytes (
;    PCHAR IdBuffer,
;    SHORT Length
;    )
;
; Routine Description:
;
;    This routine returns keyboard identification bytes.
;
;    Note that this function accepts one argument. The arg is a pointer to a
;    character buffer allocated to hold five (five) bytes. Upon return from
;    this function the buffer will contain between 1 and 5 bytes of keyboard
;    ID information. The number of valid ID bytes in the buffer is returned
;    in AX as a C proc return value.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Id bytes are stored in IdBuffer and the length of Id bytes is returned.
;
;--

KeybID  EQU     [bp + 4]              ; parameters
ReqByte EQU     [bp + 6]

nKeyID  EQU     [bp - 2]              ; Local variables
AckByte EQU     [bp - 3]

        public  _GetKeyboardIdBytes
_GetKeyboardIdBytes     proc    near

        push    bp
        mov     bp, sp
        sub     sp, 4                 ; space for local variables
        push    bx
        push    es

;
; First I initialize needed local vars.  Next I find out if machine is AT
; type or non AT type for the purpose of selecting proper acknowledgement
; byte so I can talk to the interrupt controler.
;

        mov     bx, KeybID            ; Initialize base pointer to buffer.
        mov     word ptr nKeyID, 0    ; Initialize count to zero.
        mov     byte ptr AckByte, 20h ; for all but AT-like. acknowledge for
                                      ; interrupt controller. 61h for AT's.
        mov     ax, 0fff0h            ; look into 0FFF0:0FE location.
        mov     es, ax                ; this is where the model byte is.
        mov     al, byte ptr es:[0feh]
        cmp     al, 0fch              ; is it AT-like?
        jne     UnlikeAT
        mov     byte ptr AckByte, 61h
        call    _Empty8042
if 0
        ;
        ; Disable keyboard is a right thing to do.  But, it turned out
        ; this causes some keyboards to fail GetId.
        ;

        call    DisableKeyboard
endif

UnlikeAT:

;
; Now, let's see if we can get some ID bytes from the keyboard controler.
;

        mov     ah, ReqByte           ; AT: send second command.
        mov     dx, 60h               ; write to data port
        call    Write8042             ; Output command byte to keyboard, bytes in AH
        call    ReadKeyboard          ; Get byte from keyboard, byte in AL if No CF
        jc      gotNoByte
        mov     [bx], al              ; save a byte. remember bx is pointer.
        inc     word ptr nKeyID
        call    ReadKeyboard          ; Get byte from keyboard, byte in AL if No CF
        jc      gotNoByte
        mov     [bx]+1, al            ; save a byte. remember bx is pointer.
        inc     word ptr nKeyID
        call    ReadKeyboard          ; check for extra bytes.
        jc      gotNoByte
        mov     [bx]+2, al            ; save a byte. remember bx is pointer.
        inc     word ptr nKeyID

gotNoByte:
        mov     al, AckByte
        out     ack_port, al
        call    EnableKeyboard
        call    _Empty8042
        mov     ax, nKeyID            ; Return number of valid ID bytes obtained.

        pop     es
        pop     bx
        mov     sp, bp
        pop     bp
        ret
_GetKeyboardIdBytes     endp

;++
;
; UCHAR
; ReadKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    This routine reads character from keyboard.
;
;    It is assumed that a command (05H or 0F2H) has been set to request
;    that the keyboard send an identification byte.
;    It is also assumed that interrupts are disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    If a character is returned, the carry bit is reset.
;    If no character is returned,  the carry bit is set.
;
;--

        public  ReadKeyboard
ReadKeyboard    proc     near

        push    cx
        push    bx
        mov     bx, 2             ; set outer timeout for double nested.
        cli

inner_timeout:
        xor     cx, cx            ; set inner timeout for double nested.

kbiwait:
        in      al, kb_status     ; wait for port ready
        test    al, 1             ; ready?
        jnz     kbiAvailable
        loop    kbiwait

        dec     bx                ; decrement outer timeout loop.
        jnz     inner_timeout     ; zero out inner loop again.
        stc
        jmp     short no_byte

kbiAvailable:                       ; we received a byte.
        mov     cx,100

        ;
        ; We need to let some time elapse before we try to read the data
        ; because of a problem running this code in the DOS box under
        ; OS/2.
        ;

wait_for_data:
        loop    wait_for_data

        in      al, kb_data       ; get data byte.
        clc

no_byte:
        sti
        pop     bx
        pop     cx
        ret

ReadKeyboard    endp


;++
;
; UCHAR
; Write8042 (
;    USHORT Port,
;    UCHAR Command
;    )
;
; Routine Description:
;
;    This routine writes command byte to keyboard.
;
;    It is assumed that a command (05H or 0F2H) has been set to request
;    that the keyboard send an identification byte.
;    It is also assumed that interrupts are disabled.
;
; Arguments:
;
;    Port (dx) - Port to write data to
;    Command (ah) - to be written to keyboard.
;
; Return Value:
;
;    None.
;
;--
                public  Write8042
Write8042       proc     near

        push    cx
        push    bx
        mov     bx, 4             ; set outer timeout for double nested.
        cli

reset_inner:
        xor     cx, cx            ; set inner timeout for double dested.

koutwait:
        in      al, kb_status     ; get 8042 status
        test    al, 10b           ; can we output a byte?
        jz      ok_to_send
        loop    koutwait

        dec     bx                ; decrement outer timeout loop.
        jnz     reset_inner       ; zero out inner loop again.
        jmp     short nosiree     ; timeout expired, don't try to send.

ok_to_send:
        call    _Empty8042
        mov     al, ah            ; ok, send the byte
        out     dx, al

nosiree:
        sti
        pop     bx
        pop     cx
        ret

Write8042       endp

;++
;
; UCHAR
; GetKeyboardFlags (
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the ROM BIOS flags byte that describes the state
;    of the various keyboard toggles and shift keys.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Keyboard ROM BIOS Flags byte.
;
;--

        public          _GetKeyboardFlags
_GetKeyboardFlags       proc     near

        mov     ah, 02
        int     16h
        ret

_GetKeyboardFlags       endp


;++
;
; VOID
; EnableKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    This routine enables 8042 keyboard interface.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        public  EnableKeyboard
EnableKeyboard  proc     near

        mov     ah, ENABLE_KEYBOARD_COMMAND
        mov     dx, kb_command
        call    Write8042
        ret

EnableKeyboard  endp

;++
;
; VOID
; DisableKeyboard (
;    VOID
;    )
;
; Routine Description:
;
;    This routine disables 8042 keyboard interface.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        public  DisableKeyboard
DisableKeyboard  proc     near

        mov     ah, DISABLE_KEYBOARD_COMMAND
        mov     dx, kb_command
        call    Write8042
        ret

DisableKeyboard  endp

;++
;
; VOID
; Empty8042 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine drains the i8042 controller's output buffer.  This gets
;    rid of stale data that may have resulted from the user hitting a key
;    or moving the mouse, prior to the execution of keyboard initialization.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        public  _Empty8042
_Empty8042      proc     near

        push    ax
        push    dx
        pushf
        cli
E8Check:
        in      al, kb_status     ; wait for port ready
        test    al, 1             ; ready?
        jz      E8Exit

        mov     dx, kb_data
        push    dx
        call    _READ_PORT_UCHAR  ; use this call to delay I/O
        add     sp, 2
        jmp     E8Check
E8Exit:
        popf
        pop     dx
        pop     ax
        ret

_Empty8042      endp

_TEXT   ends

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\main.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    main.inc
;
; Abstract:
;
;    This module defines the segment for the detection module.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 16-Feb-1992.
;
; Revision History:
;
;
;--

.386

;
; Segment declarations for "Small Model" 16 bit Su Module.
;

_TEXT   segment para use16 public 'CODE'
_TEXT   ends

_DATA   segment para use16 public 'DATA'
_DATA   ends

CONST   segment para use16 public 'CONST'
CONST   ends

_BSS    segment para use16 public 'BSS'
_BSS    ends

DGROUP  group   const, _BSS, _DATA

;
; Define the stack location for detection module.
;

DETECTION_STACK_SP      EQU     0fffch

;
; External references
;

extrn   _HardwareDetection: near
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwvbios.h ===
//
// Defines for machine models
//

#define          PS2_AT     0xF819      // PS/2 non-micro channel
#define          PS2_L40    0xF823      // PS/2 non-micro channel
#define          PS1_386    0xF830      // 386 non-microchannel     // 6.13

#define        PS2_PORT     0x0001      // PS/2 specific port
#define        ISA_PORT     0x0002      // AT specific port
#define     HYBRID_PORT     0x0004      // PS/2 non-micro channel specific port

//
//  Bios int 15h C0h buffer definition
//

struct BIOS_INT15_C0_BUFFER {
    USHORT Size;
    USHORT Model;
    UCHAR BiosRevision;
    UCHAR ConfigurationFlags;
    UCHAR Reserved[4];
} BiosSystemEnvironment;

typedef struct _TEMPORARY_ROM_BLOCK {
    ROM_BLOCK RomBlock;
    struct _TEMPORARY_ROM_BLOCK far *Next;
} TEMPORARY_ROM_BLOCK, far * FPTEMPORARY_ROM_BLOCK;

#define POS_MAX_SLOT 8

#define ROMBIOS_START   0xF0000
#define ROMBIOS_LEN     0x10000

#define PS2BIOS_START   0xE0000
#define PS2BIOS_LEN     0x20000

#define EXTROM_START    0xC0000         // where and how far to
#define EXTROM_LEN      0x40000         // search for external adapter ROMs

#define EBIOSDATA_START 0x9FC00
#define EBIOSDATA_LEN   0x00400

#define NUMBER_VECTORS  0x80
#define VGA_PARAMETER_POINTER   0x4A8
#define ALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))

//
// ROM format
//

#define ROM_HEADER_SIGNATURE    0xAA55
#define ROM_HEADER_INCREMENT    0x800
#define BLOCKSIZE       512

typedef struct _ROM_HEADER {
    USHORT Signature;                   // should be ROMHDR_SIGNATURE
    UCHAR NumberBlocks;                 // # of ROM blocks
    UCHAR Filler[ROM_HEADER_INCREMENT - 3];
} ROM_HEADER, far *FPROM_HEADER;

//
// External References
//

extern
BOOLEAN
HwRomCompare (
    ULONG Source,
    ULONG Destination,
    ULONG Size
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwvbiosc.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    hwheap.c

Abstract:

    This module goes through ROM area and tries to pick up all the ROM
    blocks.

Author:

    Shie-Lin Tzong (shielint) 21-Jan-92


Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include "hwvbios.h"

FPTEMPORARY_ROM_BLOCK BlockHead;
FPTEMPORARY_ROM_BLOCK BlockPointer;

BOOLEAN
AddRomBlock (
    ULONG RomAddress,
    ULONG RomSize
    )

/*++

Routine Description:

    This routine adds a ROM/RAM block to our ROM list.

Arguments:

    RomAddress - the starting address of the ROM/RAM block to be added.

    RomSize - the size of the ROM/RAM block (in byte).

Return Value:

    A value of TRUE is returned if success.  Otherwise, a value of
    FALSE is returned.

--*/

{
    LONG AddSize;
    ULONG AddAddress;
    FPTEMPORARY_ROM_BLOCK pCurrentBlock, pNextBlock;
    ULONG CurrentBlock, NextBlock, AddBlock;
    ULONG EndAddBlock, EndCurrentBlock, EndNextBlock;
    BOOLEAN  fOverlap=FALSE;

    pCurrentBlock = NULL;
    pNextBlock = NULL;
    AddSize = RomSize;
    AddAddress = RomAddress;
    AddBlock = RomAddress;

    //
    // If there are other blocks, make sure there is no overlap with them
    //

    if (BlockHead) {

        pCurrentBlock = BlockHead;
        pNextBlock = pCurrentBlock->Next;
        CurrentBlock = pCurrentBlock->RomBlock.Address;
        EndCurrentBlock = CurrentBlock + pCurrentBlock->RomBlock.Size;
        EndAddBlock = RomAddress + RomSize;

        while (pCurrentBlock!=NULL) {

            //
            // calculate location of next block (if it's there)
            //

            if(pNextBlock) {
                NextBlock = pNextBlock->RomBlock.Address;
                EndNextBlock = NextBlock + pNextBlock->RomBlock.Size;
            }

            //
            // if overlapping with current block, then stop and
            // resolve overlap
            //

            if((RomAddress < EndCurrentBlock)&& (RomAddress >= CurrentBlock)){
                fOverlap = TRUE;
                break;
            }

            //
            // if add block is lower than the current one,
            // or there is not a next block, then no need to search further
            //

            if((EndAddBlock <= CurrentBlock) || (pNextBlock == NULL)) {
                break;
            }

            //
            // if block is lower than next one, but greater than current
            // one, we have found the right area
            //

            if ((EndAddBlock <= NextBlock) && (AddBlock >= EndCurrentBlock)) {
                break;
            }

            //
            // if conflicting with next block, stop searching and
            // resolve conflict after this loop
            //

            if((EndAddBlock > NextBlock) && (EndAddBlock <= EndNextBlock)) {
                fOverlap = TRUE;
                break;
            }

            pCurrentBlock = pNextBlock;
            pNextBlock = pCurrentBlock->Next;
            CurrentBlock = NextBlock;
            EndCurrentBlock = EndNextBlock;
        }
    }

    //
    // if we have reached this point, there may be a conflict
    // with the current block.
    //

    if(fOverlap) {
        if(AddBlock < EndCurrentBlock) {
            AddAddress = EndCurrentBlock;
            AddSize = EndAddBlock - EndCurrentBlock;
            if(AddSize <= 0) {
                return TRUE;
            }
        }
        if((pNextBlock != NULL) && (EndAddBlock > NextBlock)) {
            AddSize = NextBlock - AddBlock;
            if(AddSize <= 0) {
                return TRUE;
            }
        }
    }

    BlockPointer->RomBlock.Address = AddAddress;
    BlockPointer->RomBlock.Size = AddSize;

    //
    // Put it on the list.
    // if it belongs on top, put it there
    //

    if ((pCurrentBlock == NULL)||
       ((pCurrentBlock == BlockHead) && (CurrentBlock > AddBlock))) {
        BlockPointer->Next = pCurrentBlock;
        BlockHead = BlockPointer;
    } else {

        //
        // else add to middle or bottom depending on NextBlock
        //

        BlockPointer->Next = pNextBlock;
        pCurrentBlock->Next = BlockPointer;
    }
    BlockPointer++;                         // Note that this works because
                                            // we know the offset part of
                                            // the addr is always < 64k.
    return TRUE;
}

BOOLEAN
ScanRomBlocks(
    VOID
    )

/*++

Routine Description:

    This routine scans the ROM IO area and checks for 55AA at every
    512 bytes for valid ROM blocks.


    NOTES:

                -------------
                |           |
                |           |
           ------------------100000
             ^  |           |
             |  |           |
             |  -------------f0000  (ROMBIOS_START)              ---
             |  |           |                                     ^
             |  |           |                                     |
     EXTROM_LEN -------------e0000  (PS2BIOS_START)  ---          |
             |  |           |                         ^    Search |
             |  |           |                  Search |    Range  |
             |  -------------d0000             Range  |    on AT  |
             |  |           |                  on PS/2|           |
             V  |           |                         V           V
           ------------------c0000 (EXTROM_START)    ---         ---

        ON AT:
          Scan through EXTROM_START-effff for ROM Blocks
        ON PS2
          Scan through EXTROM_START-dffff for ROM Blocks

Arguments:


    None.

Return Value:

    None.

--*/

{
    ULONG BlockSize;
    BOOLEAN Success = TRUE;
    FPUCHAR Current;
    ULONG RomAddr, RomEnd;

    //
    // As per the machine type restrict the search range
    //

    MAKE_FP(Current, EXTROM_START);
    RomAddr = EXTROM_START;

    if ((HwBusType == MACHINE_TYPE_MCA) ||
        (BiosSystemEnvironment.Model == PS2_L40) ||
        (BiosSystemEnvironment.Model == PS1_386) ||
        (BiosSystemEnvironment.Model == PS2_AT)) {

        RomEnd = PS2BIOS_START;
    } else {
        RomEnd = ROMBIOS_START;
    }

    while (RomAddr < RomEnd) {

        if (((FPROM_HEADER)Current)->Signature == ROM_HEADER_SIGNATURE) {

            BlockSize = (ULONG)((FPROM_HEADER)Current)->NumberBlocks * BLOCKSIZE;

            if ((RomAddr + BlockSize) > RomEnd) {
                BlockSize = RomEnd - RomAddr;
            }

            //
            // V7 VRAM card does not correctly report its BlockSize.  Since
            // this is a very popular video card, we provide a workaround
            // for it.
            //

            if ((RomAddr == 0xC0000) && (BlockSize < 0x8000)) {
                BlockSize = 0x8000;
            }
            if (BlockSize != 0) {
                if (!AddRomBlock(RomAddr, BlockSize)) {
                    Success = FALSE;
                    break;
                }
                RomAddr += BlockSize;
                RomAddr = ALIGN_UP(RomAddr, ROM_HEADER_INCREMENT);
                MAKE_FP(Current, RomAddr);
                continue;
            }
        }
        RomAddr += ROM_HEADER_INCREMENT;
        MAKE_FP(Current, RomAddr);
    }

    //
    // Last but not least, add the system ROM to the list
    //

    if (Success) {

        RomAddr = ROMBIOS_START;
        BlockSize = ROMBIOS_LEN;
        if ((HwBusType == MACHINE_TYPE_MCA) ||
            (BiosSystemEnvironment.Model == PS2_L40) ||
            (BiosSystemEnvironment.Model == PS1_386) ||
            (BiosSystemEnvironment.Model == PS2_AT)) {
            RomAddr = PS2BIOS_START;
            BlockSize = PS2BIOS_LEN;
        }

        if (!AddRomBlock(RomAddr, BlockSize)) {
            Success = FALSE;
        }
    }

    return Success;
}

FPTEMPORARY_ROM_BLOCK
MatchRomBlock (
    ULONG PhysicalAddr
    )

/*++

Routine Description:

    This routine finds the ROM block which the 'PhysicalAddr' is in.

Arguments:

    PhysicalAddr - the physical address ...

Return Value:

    A pointer to the detected ROM block.

--*/

{
    FPTEMPORARY_ROM_BLOCK CurrentBlock;
    ROM_BLOCK RomBlock;

    CurrentBlock = BlockHead;
    while (CurrentBlock) {
        RomBlock = CurrentBlock->RomBlock;
        if (RomBlock.Address <= PhysicalAddr &&
            RomBlock.Address +  RomBlock.Size > PhysicalAddr) {
            break;
        } else {
            CurrentBlock = CurrentBlock->Next;
        }
    }
    return(CurrentBlock);
}

BOOLEAN
IsSameRomBlock (
    FPTEMPORARY_ROM_BLOCK Source,
    FPTEMPORARY_ROM_BLOCK Destination
    )

/*++

Routine Description:

    This routine checks if the passed in ROM blocks contain the same
    information.  This ususally happens when the two ROM blocks are for
    video ROM and shadowed video ROM.

Arguments:

    Source - the source ROM block.

    Destination - the ROM block to compare with.

Return Value:

    BOOLEAN TRUE if the two ROM blocks are the same else FALSE is returned.

--*/

{

    if (Source == NULL || Destination == NULL) {
        return(FALSE);
    }

    //
    // First make sure their sizes are the same.
    //

    if (Source->RomBlock.Size == Destination->RomBlock.Size) {
        if (!HwRomCompare(Source->RomBlock.Address,
                          Destination->RomBlock.Address,
                          Source->RomBlock.Size)){
            return(TRUE);
        }
    }
    return(FALSE);

}

VOID
CheckVideoRom (
    VOID
    )

/*++

Routine Description:

    This routine checks if the int 10h video handler is in the video
    ROM block detected by us.  If not, the video ROM must have been
    remapped/shadowed to other area (usually 0xE0000.)

    NOTE: In this function, I commented out the code which removes the
          Video ROM block if it has been shadowed.  I found out
          machine POST code does not modify ALL the VIDEO ROM related
          pointers.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Vector, Handler, VectorAddr = 0x10 * sizeof(ULONG);
    FPULONG pVectorAddr;
    FPTEMPORARY_ROM_BLOCK RomBlock, VideoRomBlock;
    ULONG Size;

    MAKE_FP(pVectorAddr, VectorAddr);
    Vector = *pVectorAddr;
    Handler = ((Vector >> 16) << 4) + (Vector & 0xffff);
    RomBlock = MatchRomBlock(Handler);

    //
    // Check if the int 10h handler falls in one of our ROM blocks.
    //

    if (RomBlock) {
        if (RomBlock->RomBlock.Address >= 0xC0000 &&
            RomBlock->RomBlock.Address < 0xC8000) {

            //
            // if int 10h handler is in the standard video ROM area, we simply
            // return.  Either the video ROM is not shadowed or it
            // is a in-place shadow.
            //

            return;
        } else {

            //
            // The ROM block associated with the int 10h handler is not in
            // standard video bios ROM area.  It must have been mapped to
            // the current location.  We now need to make sure we have the
            // ROM block which contains the 40:a8 VGA parameter.
            //

            VectorAddr = VGA_PARAMETER_POINTER;
            MAKE_FP(pVectorAddr, VectorAddr);
            Vector = *pVectorAddr;
            Handler = ((Vector >> 16) << 4) + (Vector & 0xffff);
            VideoRomBlock = MatchRomBlock(Handler);
            if (VideoRomBlock == NULL) {

                //
                // We did not find the Video ROM associated with the
                // VGA parameters.  Try detect it.
                //

                //
                // In the following memory comparison, we skip the first 16 bytes.
                // Because most likely the reason we did not find the standard
                // Video ROM is because the signature word is missing.
                //

                Handler = (Handler & 0xF0000) +
                              (RomBlock->RomBlock.Address & 0xFFFF);
                if (!HwRomCompare(RomBlock->RomBlock.Address + 0x10,
                                  Handler + 0x10,
                                  RomBlock->RomBlock.Size - 0x10)) {
                    //
                    // Note:  The old code looked like this for many years:
                    //

                    /*
                    if ((Handler & 0xFFFF == 0) && (RomBlock->RomBlock.Size < 0x8000)){
                        Size = 0x8000;
                    } else {
                        Size = RomBlock->RomBlock.Size;
                    }
                    */

                    //
                    // But (Handler & 0xFFFF == 0) is always false.  So 
                    // Size always equals RomBlock->RomBlock.Size.  Rather than
                    // fix the comparison, which might cause machines to break,
                    // I'm going to assume that it's fine to just make the code
                    // do what it's always done.  -  JakeO  8/9/00
                    //

                    Size = RomBlock->RomBlock.Size;

                    AddRomBlock(Handler, Size);
                }
            }
        }
    } else {

        //
        // There is no ROM block associated with the int 10h handler.
        // We can find the shadowed video ROM block if:
        //   We detected the original video ROM in 0xC0000 - 0xC8000 range
        //

        VideoRomBlock = MatchRomBlock((Handler & 0xFFFF) + 0xC0000);
        if (VideoRomBlock != NULL) {

            //
            // In the following memory comparison, we skip the first 16 bytes.
            // Because most likely the reason we did not find the shadow rom
            // is the signature word is missing.
            //

            if (!HwRomCompare(VideoRomBlock->RomBlock.Address + 0x10,
                              (Handler & 0xF0000) +
                                (VideoRomBlock->RomBlock.Address & 0xFFFF) + 0x10,
                              VideoRomBlock->RomBlock.Size - 0x10)) {

                AddRomBlock((VideoRomBlock->RomBlock.Address & 0xFFFF) +
                                (Handler & 0xF0000),
                            VideoRomBlock->RomBlock.Size);
            }
        }
    }
}

VOID
GetRomBlocks(
    FPUCHAR ReservedBuffer,
    PUSHORT Size
    )

/*++

Routine Description:

    This routine scans the ROM IO area and collects all the ROM blocks.

Arguments:

    ReservedBuffer - Supplies a far pointer to the buffer.

    Size - Supplies a near pointer to a variable to receive the size
           of the ROM block.

Return Value:

    None.

--*/

{

    FPTEMPORARY_ROM_BLOCK Source;
    ULONG StartAddr, EndAddr;
    FPUSHORT TestAddr;
    FPROM_BLOCK Destination;
    USHORT BufferSize;
    ULONG EBiosAddress = 0, EBiosLength = 0;
    ULONG far *EBiosInformation = (ULONG far *)
                          ((DOS_BEGIN_SEGMENT << 4) + EBIOS_INFO_OFFSET);

    //
    // First we reserve the max space needed and build our temporary rom
    // block list in the heap space below the space reservedand.  After
    // the temporary list is built, we then copy it to the caller supplied
    // reserved space.
    //

    BlockPointer = (FPTEMPORARY_ROM_BLOCK)HwAllocateHeap(0, FALSE);
    BlockHead = NULL;
    *Size = 0;

    GetBiosSystemEnvironment((PUCHAR)&BiosSystemEnvironment);
    if (BiosSystemEnvironment.ConfigurationFlags & 0x4) {

        //
        // If extened BIOS data area is allocated, we will find out its
        // location and size and save in ROM blocks.
        //

        _asm {
              push   es
              mov    ah, 0xC1
              int    15h
              jc     short Exit

              cmp    ah, 0x86
              je     short Exit

              mov    bx, 0
              mov    dx, 0
              mov    ax, 0
              mov    al, es:[bx]
              shl    ax, 10
              mov    word ptr EBiosLength, ax
              mov    ax, es
              mov    dx, es
              shl    ax, 4
              shr    dx, 12
              mov    word ptr EBiosAddress, ax
              mov    word ptr EBiosAddress + 2, dx
        Exit:
              pop    es
        }
    }

    //
    // Save the Extended BIOS data area address and size at 700:40
    //

    if (EBiosLength) {
        *EBiosInformation++ = EBiosAddress;
        *EBiosInformation = EBiosLength;
    } else {
        *EBiosInformation++ = 0L;
        *EBiosInformation = 0L;
    }
    if (!ScanRomBlocks()) {
        return;
    }

    //
    // On some machines, when they shadow video ROM from 0xC0000 to
    // 0xE0000, they copy code only (no signature.)  So, we need
    // special code to work around the problem.
    //

    CheckVideoRom();

    //
    // Now do our special hack for IBM.  On SOME IBM PCs, they use
    // E0000-FFFFF for system BIOS (even on non PS/2 machines.) Since
    // system BIOS has no ROM header, it is very hard to know the starting
    // address of system ROM.  So we:
    //
    // 1. Make sure there is no ROM block in E0000-EFFFF area.
    // 2. and E0000-EFFFF contains valid data.
    //
    // If both 1 and 2 are true, we assume E0000-EFFFF is part of system
    // ROM.
    //

    Source = BlockHead;
    while (Source) {
        StartAddr = Source->RomBlock.Address;
        EndAddr = StartAddr + Source->RomBlock.Size - 1;
        if ((StartAddr < 0xE0000 && EndAddr < 0xE0000) ||
            (StartAddr >= 0xF0000)) {
            Source = Source->Next;
        } else {
            break;
        }
    }
    if (Source == NULL) {
        for (StartAddr = 0xE0000; StartAddr < 0xF0000; StartAddr += 0x800) {
            MAKE_FP(TestAddr, StartAddr);
            if (*TestAddr != 0xffff) {
                AddRomBlock(0xE0000, 0x10000);
                break;
            }
        }
    }

    //
    // Now copy the rom block list to our reserved space and release
    // the extra space we reserved.
    //

    Source = BlockHead;
    Destination = (FPROM_BLOCK)ReservedBuffer;
    BufferSize = 0;
    while (Source) {
        *Destination = *((FPROM_BLOCK)&Source->RomBlock);
        BufferSize += sizeof(ROM_BLOCK);
        Source = Source->Next;
        Destination++;
    }
    *Size = BufferSize;
}

VOID
HwGetBiosDate(
    ULONG   StartingAddress,
    USHORT  Length,
    PUSHORT Year,
    PUSHORT Month,
    PUSHORT Day
    )
/*++

Routine Description:

    Scans the specified area for the most recent date of the
    form xx/xx/xx.

Arguments:

    StartingAddress - First address to scan
    Length          - Length of area to scan

Return Value:

    Year            - If non-zero, the year of the date  (1991, 1992, ...)
    Month           - If non-zero, then month of the date found
    Day             - If non-zero, the day of the date found


--*/
{
    FPUCHAR fp, date;
    USHORT  y, m, d;
    UCHAR   c;
    ULONG   i, temp;

    //
    // Zero return values
    //

    *Year  = 0;
    *Month = 0;
    *Day   = 0;

    //
    // Search for date with the format MM/DD/YY or M1M1M2M2//D1D1D2D2//Y1Y1Y2Y2
    //

    MAKE_FP(fp, StartingAddress);   //  initialize fp pointer
    while (Length > 8) {

        c = fp[7];
        if ((c < '0' ||  c > '9')  &&  (c != '/'  &&  c != '-')) {
            // these 8 bytes are not a date, next location

            fp     += 8;
            Length -= 8;
            continue;
        }

        date = fp;                  // check for date at this pointer
        fp += 1;                    // skip to next byte
        Length -= 1;

        //
        // Check for date of the form MM/DD/YY
        //

        y = 0;
        if (date[0] >= '0'  &&  date[0] <= '9'  &&
            date[1] >= '0'  &&  date[1] <= '9'  &&
           (date[2] == '/'  ||  date[2] == '-') &&
            date[3] >= '0'  &&  date[3] <= '9'  &&
            date[4] >= '0'  &&  date[4] <= '9'  &&
           (date[5] == '/'  ||  date[5] == '-') &&
            date[6] >= '0'  &&  date[6] <= '9'  &&
            date[7] >= '0'  &&  date[7] <= '9' ) {


            //
            // A valid looking date field at date, crack it
            //

            y = (date[6] - '0') * 10 + date[7] - '0' + 1900;
            m = (date[0] - '0') * 10 + date[1] - '0';
            d = (date[3] - '0') * 10 + date[4] - '0';
        }

        //
        // Check for date of the form M1M1M2M2//D1D1D2D2//Y1Y1Y2Y2
        //

        if (Length >= 15 &&
            date[ 0] >= '0'  &&  date[ 0] <= '9'  &&  date[ 0] == date[ 1]  &&
            date[ 2] >= '0'  &&  date[ 2] <= '9'  &&  date[ 2] == date[ 3]  &&
           (date[ 4] == '/'  ||  date[ 4] == '-') &&  date[ 4] == date[ 5]  &&
            date[ 6] >= '0'  &&  date[ 6] <= '9'  &&  date[ 6] == date[ 7]  &&
            date[ 8] >= '0'  &&  date[ 8] <= '9'  &&  date[ 8] == date[ 9]  &&
           (date[10] == '/'  ||  date[10] == '-') &&  date[10] == date[11]  &&
            date[12] >= '0'  &&  date[12] <= '9'  &&  date[12] == date[13]  &&
            date[14] >= '0'  &&  date[14] <= '9'  &&  date[14] == date[15]) {

            //
            // A valid looking date field at date, crack it
            //

            y = (date[12] - '0') * 10 + date[14] - '0' + 1900;
            m = (date[ 0] - '0') * 10 + date[ 2] - '0';
            d = (date[ 6] - '0') * 10 + date[ 8] - '0';
        }

        if (y != 0) {
            if (m < 1  ||  m > 12  ||  d < 1  ||  d > 31) {
                y = 0;          // bad field in date, skip it
            } else {
                if (y < 1980) {

                    //
                    // Roll to next century.
                    //

                    y += 100;
                }
            }
        }

        //
        // Check for date of the form 19xx or 20xx
        //
        // First, check the 5th character is not a digit.
        //

#define IS_DIGIT(x) (((x) >= '0') && ((x) <= '9'))

        if (!IS_DIGIT(date[4])) {
            for (i = 0, temp = 0; i < 4; i++) {
                if (!IS_DIGIT(date[i])) {
                    temp = 0;
                    break;
                }
                temp = (temp * 10) + date[i] - '0';
            }
            if ((temp >= 1980) && (temp < 2599)) {

                //
                // Looks like a reasonable date, use it.
                //

                y = (USHORT)temp;
                m = 0;
                d = 0;
            }
        }
         
        if (!y) {
            // not a date - skip it
            continue;
        }

        if ((y >  *Year) ||
            (y == *Year  &&  m >  *Month)  ||
            (y == *Year  &&  m == *Month  &&  d > *Day) ) {

            //
            // This date is more recent
            //

            *Year  = y;
            *Month = m;
            *Day   = d;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\hwpmbios.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation

Module Name:

    hwpmbiosc.c

Abstract:

    This modules contains ACPI BIOS C supporting routines

Author:

    Jake Oshins (jakeo) 6-Feb-1997

Environment:

    Real mode.

Revision History:

--*/

#include "hwdetect.h"
#include <string.h>
#include "acpibios.h"

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820Frame;

BOOLEAN
Int15E820 (
    E820Frame       *Frame
    );

BOOLEAN
Int15E980 (
    PLEGACY_GEYSERVILLE_INT15 Info
    );


BOOLEAN
HwGetAcpiBiosData(
    IN FPUCHAR *Configuration,
    OUT PUSHORT Length
    )
/*++

Routine Description:

    This routine checks to see if an ACPI BIOS is present.  If it is,
    then it returns the ACPI Root System Description Pointer.

Arguments:
    
    Configuration - structure that holds ACPI pointer
    Length        - length of that structure

Return Value:

    TRUE if ACPI BIOS is present, FALSE otherwise

--*/
{
    ULONG romAddr, romEnd;
    FPUCHAR current;
    FPULONG EbdaAddr;
    FPACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum, node = 0;
    USHORT i, nodeSize;
    USHORT numE820Blocks, e820BlockIndex;
    BOOLEAN complete;
    FPACPI_E820_ENTRY e820Blocks;
    E820Frame Frame;
    LEGACY_GEYSERVILLE_INT15 geyservilleInfo;
    BOOLEAN geyservillePresent;

    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;

    //
    // Search on 16 byte boundaries for the signature of the 
    // Root System Description Table structure. 
    //
    
    for (pass = PASS1; pass < MAX_PASSES; pass++) {
        
        if (pass == PASS1) {
            // 
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.
            //

            //
            // Earlier, we stored the address of the EBDA in address
            // DOS_BEGIN_SEGMENT << 4 : EBIOS_INFO_OFFSET
            //
            MAKE_FP(EbdaAddr, ((DOS_BEGIN_SEGMENT << 4) + EBIOS_INFO_OFFSET));
            MAKE_FP(current, *EbdaAddr);

            if (*EbdaAddr == 0) {
                continue;
            }

            romAddr = *EbdaAddr;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000 
            // to 0xF0000.
            
            MAKE_FP(current, ACPI_BIOS_START);
            romAddr = ACPI_BIOS_START;
            romEnd  = ACPI_BIOS_END;
        }

        while (romAddr < romEnd) {
    
            header = (FPACPI_BIOS_INSTALLATION_CHECK)current;
            
            //
            // Signature to match is the string "RSD PTR".
            //
            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {
                
                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum += current[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
#if DBG
                BlPrint("GetAcpiBiosData: Checksum fails\n");
#endif
            }
            romAddr += ACPI_BIOS_HEADER_INCREMENT;
            MAKE_FP(current, romAddr);
        }
    }
    
    if (romAddr >= romEnd) {
#if DBG
            BlPrint("GetAcpiBiosData: RSDT pointer not found\n");
#endif
        return FALSE;
    }

    
    //
    // Now header points at the RSDP.  So we can move on to collecting the 
    // E820 blocks.
    //

    numE820Blocks = 20;
    
    while (TRUE) {
        
        e820Blocks = 
            (FPACPI_E820_ENTRY)HwAllocateHeap(
                sizeof(ACPI_E820_ENTRY) * numE820Blocks,
                FALSE);

        if (!e820Blocks) {
#if DBG
            BlPrint("GetAcpiBiosData: Out of heap space.\n");
#endif
            return FALSE;
        }

        e820BlockIndex = 0;
        Frame.Key = 0;
        complete = FALSE;

        while (!complete) {

#if DBG
            BlPrint("Searching for E820 block # %d.\n", e820BlockIndex);
#endif
            
            if (e820BlockIndex == numE820Blocks) {
                HwFreeHeap(sizeof(ACPI_E820_ENTRY) * numE820Blocks);
                numE820Blocks += 20;
                break;
            }
            
            //
            // Set up the context.
            //
            
            Frame.Size = sizeof (Frame.Descriptor);

            Int15E820 (&Frame);

            if (Frame.ErrorFlag  ||  Frame.Size < sizeof (Frame.Descriptor)) {

                //
                // The BIOS just didn't do it.
                //

#if DBG
                BlPrint("The BIOS failed the E820 call\n");
#endif
                complete = TRUE;
                break;
            }

            //
            // Copy the data from the Frame into the array.
            //

            e820Blocks[e820BlockIndex].Base.LowPart = Frame.Descriptor.BaseAddrLow;
            e820Blocks[e820BlockIndex].Base.HighPart = Frame.Descriptor.BaseAddrHigh;
            e820Blocks[e820BlockIndex].Length.LowPart = Frame.Descriptor.SizeLow;
            e820Blocks[e820BlockIndex].Length.HighPart = Frame.Descriptor.SizeHigh;
            e820Blocks[e820BlockIndex].Type = Frame.Descriptor.MemoryType;
            e820Blocks[e820BlockIndex].Reserved = 0;
            
#if DBG
            BlPrint("Base: %x%x  Len: %x%x  Type: %x\n",
                    (USHORT)(Frame.Descriptor.BaseAddrLow >> 16),
                    (USHORT)(Frame.Descriptor.BaseAddrLow & 0xffff),
                    (USHORT)(Frame.Descriptor.SizeLow >> 16),
                    (USHORT)(Frame.Descriptor.SizeLow & 0xffff),
                    (USHORT)(Frame.Descriptor.MemoryType));
#endif

            e820BlockIndex++;
            
            if (Frame.Key == 0) {
                
                //
                // This was the last descriptor
                //
                complete = TRUE;
                break;
            }
        }

        if (complete) {
            break;
        }
    }

#if DBG
    BlPrint("Finished with %d E820 descriptors\n", e820BlockIndex);
#endif
    
    //
    // Check for Geyserville
    //

    if (geyservillePresent = Int15E980(&geyservilleInfo)) {
        geyservilleInfo.Signature = 'GS';
    }

#if DBG
        BlPrint("GetAcpiBiosData: Geyserville is %s present.\n",
                geyservillePresent ? "" : "not");
        
        if (geyservillePresent) {
            BlPrint("GetAcpiBiosData: Geyserville command port: %x.\n",
                    geyservilleInfo.CommandPortAddress);
        }
#endif

    //
    // Now we know how big the lump of data is going to be.
    //
    
    nodeSize = sizeof(ACPI_BIOS_MULTI_NODE) + DATA_HEADER_SIZE +
               (sizeof(ACPI_E820_ENTRY) * (e820BlockIndex - 1)) +
               (geyservillePresent ? sizeof(LEGACY_GEYSERVILLE_INT15) : 0);

    current = (FPUCHAR) HwAllocateHeap(nodeSize, FALSE);
    if (!current) {
#if DBG
        BlPrint("GetAcpiBiosData: Out of heap space.\n");
#endif
        return FALSE;
    }

    //
    // Collect ACPI Bios installation check data and device node data.
    //

    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->RsdtAddress.HighPart = 0;
    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->RsdtAddress.LowPart = 
        header->RsdtAddress;

    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->Count = e820BlockIndex;
    ((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->Reserved = 0;

    _fmemcpy (&(((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->E820Entry[0]),
              (FPUCHAR)e820Blocks,
              sizeof(ACPI_E820_ENTRY) * e820BlockIndex
              );
    
    if (geyservillePresent) {
        
        //
        // Append Geyserville information to the end of the block.
        //

        _fmemcpy(&(((FPACPI_BIOS_MULTI_NODE)(current + DATA_HEADER_SIZE))->E820Entry[e820BlockIndex]),
                 &geyservilleInfo,
                 sizeof(geyservilleInfo));
    }

    *Configuration = current;
    *Length = nodeSize;

#if DBG
    BlPrint("ACPI BIOS found at 0x%x:%x.  RdstAddress is 0x%x:%x\n", 
            (USHORT)(romAddr >> 16), 
            (USHORT)(romAddr),
            (USHORT)(header->RsdtAddress >> 16),
            (USHORT)(header->RsdtAddress)
            );
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\keybdc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    abiosc.c

Abstract:

    This module implements keybaord detection C routines.

Author:

    Shie-Lin Tzong (shielint) 18-Dec-1991

Environment:

    Real Mode.


Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

extern
UCHAR
GetKeyboardFlags (
    VOID
    );

extern
USHORT
HwGetKey (
    VOID
    );

extern UCHAR NoLegacy;

//
// SavedKey is used to save the key left in the keyboard type-ahead buffer
//   before we start our keyboard/mouse tests.  The key will be push back
//   to the type-ahead buffer once the mouse detection is done.
//

USHORT   SavedKey = 0;

BOOLEAN NoBiosKbdCheck=FALSE;

//
// String table to map keyboard id to an ascii string.
//

PUCHAR KeyboardIdentifier[] = {
    "UNKNOWN_KEYBOARD",
    "OLI_83KEY",
    "OLI_102KEY",
    "OLI_86KEY",
    "OLI_A101_102KEY",
    "XT_83KEY",
    "ATT_302",
    "PCAT_ENHANCED",
    "PCAT_86KEY",
    "PCXT_84KEY"
    };

UCHAR KeyboardType[] = {
    255,
    1,
    2,
    3,
    4,
    1,
    1,
    4,
    3,
    1
    };

UCHAR KeyboardSubtype[] = {
    255,
    0,
    1,
    10,
    4,
    42,
    4,
    0,
    0,
    0
    };

USHORT
GetKeyboardId(
    VOID
    )

/*++

Routine Description:

    This routine determines the Id of the keyboard.  It calls GetKeyboardIdBytes
    to complete the task.

Arguments:

    None.

Return Value:

    Keyboard ID.

--*/

{
    char KeybID_Bytes[5];
    int  Num_ID_Bytes;
    int  keytype = UNKNOWN_KEYBOARD;

    SavedKey = HwGetKey();

    keytype = UNKNOWN_KEYBOARD;

    if (!NoBiosKbdCheck) {
        if (IsEnhancedKeyboard()) {
            keytype = PCAT_ENHANCED;
        }
    }

    if (keytype == UNKNOWN_KEYBOARD) {

        Num_ID_Bytes = GetKeyboardIdBytes(KeybID_Bytes, 0xf2);

        if (Num_ID_Bytes > 0) {

            if ((KeybID_Bytes[0] & 0x00ff) == 0xfa) {

                keytype = PCAT_86KEY;

            } else if ((KeybID_Bytes[0] & 0x00ff) == 0xfe) {

                keytype = PCAT_86KEY;

            } else if (Num_ID_Bytes >= 3 &&
                      ((KeybID_Bytes[1] & 0x00ff) == 0xAB) &&
                      ((KeybID_Bytes[2] & 0x00ff) == 0x41)) {

                keytype = PCAT_ENHANCED;

            } else {

                keytype = UNKNOWN_KEYBOARD;
            }
            
        } else {

            keytype = UNKNOWN_KEYBOARD;
        }
    }

    return keytype;
}

FPFWCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    USHORT KeyboardId
    )

/*++

Routine Description:

    This routine maps Keyboard Id information to an ASCII string and
    stores the string in configuration data heap.

Arguments:

    KeyboardId - Supplies a USHORT which describes the keyboard id information.

    Buffer - Supplies a pointer to a buffer where to put the ascii.

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA Controller, CurrentEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CM_KEYBOARD_DEVICE_DATA far *KeyboardData;
    USHORT z, Length;

    //
    // Set up Keyboard Controller component
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                 sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &Controller->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = KeyboardController;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Only fill this on a machine which is not legacy free
    //
    if (!NoLegacy) {
        //
        // Set up Port information
        //

        ControlData.NumberPortEntries = 2;
        ControlData.DescriptorList[z].Type = RESOURCE_PORT;
        ControlData.DescriptorList[z].ShareDisposition =
                                      CmResourceShareDeviceExclusive;
        ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    #if defined(NEC_98)
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x41;
    #else // PC98
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x60;
    #endif // PC98
        ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
        ControlData.DescriptorList[z].u.Port.Length = 1;
        z++;
        ControlData.DescriptorList[z].Type = RESOURCE_PORT;
        ControlData.DescriptorList[z].ShareDisposition =
                                      CmResourceShareDeviceExclusive;
        ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    #if defined(NEC_98)
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x43;
    #else // PC98
        ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x64;
    #endif // PC98
        ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
        ControlData.DescriptorList[z].u.Port.Length = 1;
        z++;

        //
        // Set up Irq information
        //

        ControlData.NumberIrqEntries = 1;
        ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
        ControlData.DescriptorList[z].ShareDisposition =
                                      CmResourceShareUndetermined;
        ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
        ControlData.DescriptorList[z].u.Interrupt.Level = 1;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 1;
        if (HwBusType == MACHINE_TYPE_MCA) {
            ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
        } else {

            //
            // For EISA the LevelTriggered is temporarily set to FALSE.
            //

            ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
        }

        Controller->ConfigurationData =
                            HwSetUpResourceDescriptor(Component,
                                                      NULL,
                                                      &ControlData,
                                                      0,
                                                      NULL
                                                      );
    }

    //
    // Set up Keyboard peripheral component
    //

    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &CurrentEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = KeyboardPeripheral;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    CurrentEntry->ConfigurationData = (FPVOID)NULL;
    Length = strlen(KeyboardIdentifier[KeyboardId]) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = HwAllocateHeap(Length, FALSE);
    _fstrcpy(Component->Identifier, KeyboardIdentifier[KeyboardId]);

    //
    // If we are running on a legacy free machine, we still want to report the
    // KeyboardFlags to NTOS
    //
    if (KeyboardId != UNKNOWN_KEYBOARD || NoLegacy) {

        Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                 sizeof(CM_KEYBOARD_DEVICE_DATA);
        DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                    Length,
                                    TRUE);
        CurrentEntry->ConfigurationData = DescriptorList;
        Component->ConfigurationDataLength = Length;
        DescriptorList->Count = 1;
        DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
        DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                    sizeof(CM_KEYBOARD_DEVICE_DATA);
        KeyboardData = (CM_KEYBOARD_DEVICE_DATA far *)(DescriptorList + 1);
        KeyboardData->KeyboardFlags = GetKeyboardFlags();
        KeyboardData->Type = KeyboardType[KeyboardId];
        KeyboardData->Subtype = KeyboardSubtype[KeyboardId];
    }

    Controller->Child = CurrentEntry;
    Controller->Sibling = NULL;
    CurrentEntry->Parent = Controller;
    CurrentEntry->Sibling = NULL;
    CurrentEntry->Child = NULL;
    return(Controller);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\main.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    main.asm
;
; Abstract:
;
;    This file implements the main entry code for x86 hardware detection
;    module. This assembly file is required in order to link C modules
;    into a "/TINY" (single segment) memory module.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 15-Feb-1992.
;        The code is extracted from NTLDR su.asm.
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
; Build Notes:
; ~~~~~~~~~~~~
; The microsoft C compiler will not produce "tiny" model programs. In the
; tiny model, the entire program consists of only one segment. The small
; model produced by our compilers consists of two segments: DGROUP and _TEXT.
; If you convert a small model program into a tiny model program, DS (which
; should point to DGROUP (bss,const,data) will always be wrong. For this reason
; we need an assembly module to do a simple run-time fixup on SS and DS. To
; guarantee that DS will point to DGROUP no matter where the detection module
; is loaded, the paragraph (shifted right four bits) offset of DGROUP from
; _TEXT must be added to the value in CS to compute DS and SS.
;
; We get the linker to fixup the offset of the beginning of the dgroup segment
; relative to the beginning of the code segment and it's this value added
; to the value in CS that allows us to build a "tiny" model program in C
; without a lot of munging around in order to get the data reference offsets
; in the code correct.
;
; If the _TEXT:DGROUP fixup appears in other files (which it does), the linker
; will not compute the correct value unless the accumulated data pointer is
; zero when it gets there. Therefore, no data should be placed in the data segment
; until after all instances of _TEXT:DGROUP have been encountered by the linker.
; The linker processes files from right to left on the command line.
;
;--

.386p

include main.inc

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

;
; Define double wrod to save caller's (ntldr's) stack pointer
;

NtldrStack      df      0               ; saved area for ss:esp

                dw      2048 dup (0)
DetectionStack  equ     $

_DATA   ends

_TEXT   segment para use16 public 'CODE'
        ASSUME  CS: _TEXT, DS: DGROUP, SS: DGROUP


;++
;
; VOID
; DetectionMain (
;    ULONG HeapStart,
;    ULONG HeapSize,
;    ULONG ConfigurationTree,
;    ULONG HeapUsed,
;    ULONG LoadOptions,
;    ULONG LoadOptionsLength
;    )
;
; Routine Description:
;
;    This is the entry point of the detection module.
;    Memory from HeapStart to (HeapStart + HeapSize) is allocated for detection
;    module to store the hardware configuration tree.
;    Note that detection module loaded address will be resued by loader after
;    the control is passed back to ntldr.
;
; Arguments:
;
;    HeapStart - supplies a 32 bit FLAT starting addr of the heap
;
;    HeapSize - Supplies the size of the useable heap
;
;    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
;               receive the configuration tree.
;
;    HeapUsed - Supplies a 32 bit FLAT address of the variable to receive
;               the size of heap we acually used.
;
;    LoadOptions - Supplies a 32 bit FLAT address of the load options string.
;
;    LoadOptionsLength - Supplies the length of the LoadOptions string. Note,
;        this is for sanity check to make sure the LoadOptions string is valid.
;        (in case use usews Nt 1.0 ntldr with the new ntdetect.com.)
;
; Return Value:
;
;    None.
;
;--
;

;
; Run-time fixups for stack and data segment
;

        public  DetectionMain
DetectionMain:

;
; Save all the registers we need to preserved on NTLDR's stack
;

        push    ebp
        mov     ebp, esp
        and     ebp, 0ffffh
        push    ds
        push    es
        push    ebx
        push    esi
        push    edi

;
; Compute the paragraph needed for DS
;

        mov     cx,offset _TEXT:DGROUP  ; first calculate offset to data
        shr     cx,4                    ; must be para aligned

        mov     ax,cs                   ; get base of code
        add     ax,cx                   ; add paragraph offset to data

;
; Make DS point to the paragraph address of DGROUP
;

        mov     ds,ax                   ; ds now points to beginning of DGROUP
        mov     es,ax

;
; Save old stack pointer and set up our own stack.
;

        mov     ecx, esp
        mov     dword ptr NtldrStack, ecx
        mov     cx, ss
        mov     word ptr NtldrStack + 4, cx

        mov     ebx, [bp + 8]           ; [ebx] = Heap Start
        mov     ecx, [bp + 12]          ; [ecx] = Heap Size
        mov     esi, [bp + 16]          ; [esi] -> addr of ConfigurationTree
        mov     edi, [bp + 20]          ; [edi] -> Addr of HeapUsed variable
        mov     edx, [bp + 24]          ; [edx]-> Addr of LoadOptions string
        mov     ebp, [bp + 28]          ; [ebp] = length of LoadOptions

        mov     ss,ax
        mov     esp,offset DGROUP:DetectionStack ; (ss:esp) = top of internal stack

;
; Set up parameters and invoke real detection code to collect hardware
; information.
;

        push    ebp
        push    edx
        push    edi
        push    esi
        push    ecx
        push    ebx
        
        xor     eax, eax        
        xor     ebx, ebx
        xor     ecx, ecx
        xor     edx, edx
        xor     esi, esi
        xor     edi, edi
        
        call    _HardwareDetection

;
; The hardware detection is done.  We need to switch to ntldr's stack,
; restore registers and return back to ntldr.
;

        lss     esp, NtldrStack

        pop     edi                      ; retore registers
        pop     esi
        pop     ebx
        pop     es
        pop     ds
        pop     ebp

        retf

_TEXT   ends

        end     DetectionMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\mouse.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       mouse.inc
;
;   Abstract:
;
;       This file defines the hardware specific equates to be used in
;       the mouse detection code.
;
;   Author:
;
;       Shie-Lin (shielint) 22-Feb-1992
;
;   Revision History:
;
;--

;
; External references
;

IFDEF NEC_98
ELSE ; NEC_98
extrn   _InportMouseIrqDetection:proc
ENDIF ; NEC_98
extrn    _READ_PORT_UCHAR: proc
extrn    _WRITE_PORT_UCHAR: proc

;
; Internal Macros
;

IOdelay macro
         jmp       $+2
         jmp       $+2
endm

address macro StartAddr, EndAddr
         add   dx,StartAddr-EndAddr
endm

DelayIn   macro
          push  dx
          call  _READ_PORT_UCHAR        ; destroy AL
          add   sp, 2
endm

DelayOut  macro
          push  ax
          push  dx
          call  _WRITE_PORT_UCHAR       ; destroy AL
          add   sp, 4
endm

IFDEF NEC_98
MultiDelayOut8  macro
          push  di

          mov   di, ax
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut
          mov   ax, di
          DelayOut

          pop di
endm
ELSE ; NEC_98
ENDIF ; NEC_98
;
; Mouse information structure
; N.B. This must match the one defined in hwdetect.h
;

MouseInformation        struc
        MouseType       db      0
        MouseSubtype    db      0
        MousePort       dw      0       ; if serial mouse, 1 for com1, 2 for com2 ...
        MouseIrq        dw      0
        DeviceIdLength  dw      0
        DeviceId        db      10 dup(?); Pnp device id if any
MouseInformation        ends


;
; Mouse ID's returned by GetMouseType().
;

UNKNOWN_MOUSE  equ    0         ; Don't know whether or not a mouse is
                                ; installed...
NO_MOUSE       equ    100H      ; No mouse installed.
MS_MOUSE       equ    200H      ; MS Regular mouse
MS_BALLPOINT   equ    300H      ; MS Ballpoint mouse
LT_MOUSE       equ    400H      ; LogTec mouse

IFDEF NEC_98
NEC_MOUSE      equ    500H      ; NEC PC-9800 Series Mouse
PC98BUS_MOUSE  equ    7h
ENDIF ; NEC_98
PS2_MOUSE      equ    1h        ; Connect to 8042 mouse port
SERIAL_MOUSE   equ    2h
INPORT_MOUSE   equ    3h
BUS_MOUSE      equ    4h
PS2_MOUSE_WITH_WHEEL    equ 5
SERIAL_MOUSE_WITH_WHEEL equ 6

TRUE           EQU    0ffh
FALSE          EQU    0

LW_ClockTickCount EQU    46Ch
HW_ClockTickCount EQU    46Eh

;************************************************************************
;               I N P O R T     D E F I N I T I O N S                   *
;************************************************************************

INP_ADDR        EQU     0               ; Inport addr register offset.
INP_DATA        EQU     1               ; Inport data register offset.
INP_ID          EQU     2               ; Inport ID register offset.
INP_TEST        EQU     3               ; Inport test register offset.

INPORT_ID       EQU     0DEh            ; InPort ID byte.

INP_STATUS_REG  EQU     0               ; Status register number.
INP_DATA1_REG   EQU     1               ; Internal data register 1.
INP_DATA2_REG   EQU     2               ; Internal data register 2.
INP_MODE_REG    EQU     7               ; Mode register number.

INP_RESET       EQU     10000000b       ; Value to reset InPort.

HZ0INTR0        EQU     00000000b       ; Value to select 0 Hz, INTR=0
HZ0INTR1        EQU     00000110b       ; Value to select 0 Hz, INTR=1
HZ30            EQU     00000001b       ; Value to select 30 Hz.
DATA_INT_ENAB   EQU     00001000b       ; Data int enable bit.
TIMER_INT_ENAB  EQU     00010000b       ; Timer int enable bit.
HOLD_BIT        EQU     00100000b       ; Hold bit.

BUTTON_1_BIT    EQU     00000100b       ; Bit indicating button 1.
BUTTON_3_BIT    EQU     00000001b       ; Bit indicating button 3.
MOVEMENT_BIT    EQU     01000000b       ; Bit indicating movement.

INPORT_FIRST_PORT EQU   23Ch            ; Address of primary InPort.
INPORT_LAST_PORT EQU    230h            ; Address of secondary InPort.

MACH20_IRQ      EQU     0Ch             ; IRQ used for Mach 20 InPort
                                        ; under Mach 20 OS/2.

;****************************************************************
;               B U S   D E F I N I T I O N S                   *
;****************************************************************
; Since the Adaptor for the bus mouse is based on an 8255A, we have to
;       program the 8255A properly in order to function. We need to select:
;
;       Mode 0 (for all ports).
;       Port A (input - this allows us to read information from the ALPS
;               chip and from the buttons)
;       Port B (output - this allows us to write a value there and then
;               read it back in. It is not connected to anything)
;       Port C, upper half (output - this allows us to send control
;               information to the ALPS chip)
;       Port C, lower half (input - this allows us to poll the current states
;               of IRQs 2, 3, 4, and 5)
;
; The value that does this is
;
;       10010001
;       ||||||||-----   Port C Lower is input
;       |||||||------   Port B is output
;       ||||||-------   Mode 0 for Group B (Port B and lower half of Port C)
;       |||||--------   Port C Upper is output
;       ||||---------   Port A is input
;       |------------   Mode 0 for Group A (Port A and upper half of Port C)
;       -------------   Mode set control word
;

BUS_MOUSE_BASE  EQU     023Ch           ; Base I/O addr of bus mouse.

BUS_DATA        EQU     BUS_MOUSE_BASE  ; Port where mouse data is read from.
BUS_SIG         EQU     BUS_MOUSE_BASE + 1 ; Port unused for mouse, used for de-
                                        ; termining existence of bus adaptor.
BUS_CONTROL     EQU     BUS_MOUSE_BASE + 2 ; Port used to control adaptor.
BUS_INIT        EQU     BUS_MOUSE_BASE + 3 ; Port used to init bus adaptor.

BUS_INIT_VALUE  EQU     10010001b       ; Value used to init bus adaptor.

LOW_X           EQU     090h            ; Cmd to read low 4 bits of delta X
HI_X            EQU     0B0h            ; Cmd to read high 2 bits of delta X
LOW_Y           EQU     0D0h            ; Cmd to read low 4 bits of delta Y
HI_Y            EQU     0F0h            ; Cmd to read high 2 bits of delta Y

;************************************************************************
;               S E R I A L     D E F I N I T I O N S                   *
;************************************************************************

SERIAL_PACKETSIZE       EQU     3       ; Bytes in a packet of data.

SYNC_BIT                EQU     40H     ; Bit 6 is the sync bit

;
; These are the offsets within the COM chip of the various registers.
;

TXB             EQU     0               ; Transmit buffer
RXB             EQU     0               ; Receive buffer
LATLSB          EQU     0               ; Divisor latch, LSB
LATMSB          EQU     1               ; Divisor latch, MSB
IER             EQU     1               ; Interrupt enable register
IIR             EQU     2               ; Interrupt identification register
LCR             EQU     3               ; Line control register
MCR             EQU     4               ; Modem control register
LSR             EQU     5               ; Line status register
MSR             EQU     6               ; Modem status register

IFDEF NEC_98
BASE_8251_NEC   EQU     30h             ; Base I/O address of 8251 serial controller
BASE_16550_NEC  EQU     238h            ; Base I/O address of 16550 serial controller

DATA_8251       EQU     BASE_8251_NEC       ; Port used to data read/write.
MODE_8251       EQU     BASE_8251_NEC + 2   ; Port used to set mode.
COMMAND_8251    EQU     BASE_8251_NEC + 2   ; Port used to write command.
STATUS_8251     EQU     BASE_8251_NEC + 2   ; Port used to read status.
SIGNAL_READ_8251 EQU    BASE_8251_NEC + 3   ; Port used to read signal.
MASK_8251       EQU     BASE_8251_NEC + 5   ; Port used to set mask.

BAUD_MODE_NEC   EQU     77h             ; Port used to set mode for baud rate.
BAUD_COUNT_NEC  EQU     75h             ; Port used to write baud rate.

SPEAKER_CONTROL_PORT EQU 37h
SPEAKER_OFF          EQU 07h
SPEAKER_ON           EQU 06h
WAIT1S               EQU 90000h
ENDIF ;NEC_98
;
; These give the number of milliseconds to wait while waiting for the serial
;       mouse to reset itself. We will first use the value given by SHORTDELAY
;       and if that fails, we will then use the value given by LONGDELAY.
;

SHORTDELAY      EQU     6        ; 350  msecs  = 350/55.5  = 6  clock ticks.
LONGDELAY       EQU     18       ; 1000 msecs  = 1000/55.5 = 18 clock ticks.

;
; These are the values that are written into the divisor latch for the
;       various baud rates. They are obtained by dividing the clock rate
;       (1.8432 MHz) by 16x the desired baud rate.
;

DIV_50          EQU     900h
DIV_75          EQU     600h
DIV_110         EQU     417h
DIV_150         EQU     300h
DIV_300         EQU     180h
DIV_600         EQU     0C0h
DIV_1200        EQU     060h
DIV_1800        EQU     040h
DIV_2000        EQU     03Ah
DIV_2400        EQU     030h
DIV_3600        EQU     020h
DIV_4800        EQU     018h
DIV_7200        EQU     010h
DIV_9600        EQU     00Ch

;
;** Interrupt enable masks
;

IE_RX           EQU     00000001b       ; read data available
IE_TX           EQU     00000010b       ; transmit buffer empty
IE_LX           EQU     00000100b       ; line status change
IE_MX           EQU     00001000b       ; modem status change

;
;** Line control masks
;

LC_BMASK        EQU     00000011b       ; data bits mask
LC_BITS5        EQU     00000000b       ; 5 data bits
LC_BITS6        EQU     00000001b       ; 6 data bits
LC_BITS7        EQU     00000010b       ; 7 data bits
LC_BITS8        EQU     00000011b       ; 8 data bits

LC_SMASK        EQU     00000100b       ; stop bits mask
LC_STOP1        EQU     00000000b       ; 1 stop bit
LC_STOP2        EQU     00000100b       ; 2 stop bits (1.5 if 5 data bits)

LC_PMASK        EQU     00111000b       ; parity mask
LC_PNONE        EQU     00000000b       ; none parity
LC_PODD         EQU     00001000b       ; odd parity
LC_PEVEN        EQU     00011000b       ; even parity
LC_PMARK        EQU     00101000b       ; mark parity
LC_PSPACE       EQU     00111000b       ; space parity

LC_BREAK        EQU     01000000b       ; transmit break
LC_DLAB         EQU     10000000b       ; divisor latch access bit
LC_MASK         EQU     01111111b       ; documented line control register bits

;
;** Modem control register masks
;

MC_DTR          EQU     00000001b       ; data terminal ready
MC_RTS          EQU     00000010b       ; request to send
MC_OUT1         EQU     00000100b       ; output 1
MC_OUT2         EQU     00001000b       ; output 2
MC_LOOP         EQU     00010000b       ; loopback mode

;
;** Line status register masks
;

LS_DR           EQU     00000001b       ; data ready
LS_OERR         EQU     00000010b       ; overrun error
LS_PERR         EQU     00000100b       ; parity error
LS_FERR         EQU     00001000b       ; framing error
LS_BI           EQU     00010000b       ; break interrupt
LS_THRE         EQU     00100000b       ; TX holding register empty
LS_TSRE         EQU     01000000b       ; TX shift register empty

;
;** Modem status register definitions:
;

MS_DCTS         EQU     00000001b       ; delta clear to send
MS_DDSR         EQU     00000010b       ; delta data set ready
MS_TERI         EQU     00000100b       ; trailing edge of ring indicator
MS_DDCD         EQU     00001000b       ; delta receiver line signal detect
MS_CTS          EQU     00010000b       ; clear to send
MS_DSR          EQU     00100000b       ; data set ready
MS_RI           EQU     01000000b       ; ring indicator
MS_DCD          EQU     10000000b       ; receiver line signal detect

;************************************************************************
;               8 2 5 9 A  D E F I N I T I O N S                        *
;************************************************************************

MASTER_MASK_ADDR EQU     021h            ; Master's mask register addr.
SLAVE_MASK_ADDR  EQU     0A1h            ; Slave's mask register addr.
IRQS_PER_8259    EQU     8               ; # IRQs on each 8259A.
SELECT_IRR       EQU     0Ah             ; Selects int request register.
SELECT_ISR       EQU     0Bh             ; Selects in service register.

;****************************************************************
;               P S / 2   D E F I N I T I O N S                 *
;****************************************************************

PS2_IRQ         EQU     0Ch             ; Always IRQ 12 for PS/2 mouse.
PS2_IRQ_MASK    EQU     00010000b       ; Bit mask for IRQ 12.
PS2_PACKETSIZE  EQU     3               ; Bytes in a packet of data.

DX_SIGN         EQU     00010000b       ; Bit 4 is dx sign bit in status byte
DY_SIGN         EQU     00100000b       ; Bit 5 is dy sign bit in status byte

PS2_25PPI       EQU     0               ; Value to set resolution to 25 ppi.
PS2_50PPI       EQU     1               ; Value to set resolution to 50 ppi.
PS2_100PPI      EQU     2               ; Value to set resolution to 100 ppi.
PS2_200PPI      EQU     3               ; Value to set resolution to 200 ppi.


MOUSE_RESET      EQU     0FFh            ; Reset mouse command
MOUSE_RESEND     EQU     0FEh            ; Resend data to mouse
MOUSE_DIAG_ERR   EQU     0FCh            ; Error on mouse diagnostics
MOUSE_ACK        EQU     0FAh            ; Acknowledge
MOUSE_DEFAULT    EQU     0F6h
MOUSE_DISABLE    EQU     0F5h            ; Disable Mouse command
MOUSE_ENABLE     EQU     0F4h            ; Enable Mouse command
MOUSE_RATE       EQU     0F3h            ; Set sampling rate
MOUSE_READ_TYPE  EQU     0F2h            ; Read device type
MOUSE_REMOTE     EQU     0F0h            ; Set remote mode
MOUSE_ECHO       EQU     0EEh            ; Set wrap mode
MOUSE_KILL_ECHO  EQU     0ECh            ; reset wrap mode
MOUSE_READDATA   EQU     0EBh            ; Read mouse data
MOUSE_STREAM     EQU     0EAh            ; Set stream mode
MOUSE_STATUS     EQU     0E9h            ; Status Request
MOUSE_RESOLUTION EQU     0E8h            ; Set Resolution
MOUSE_SCALE_2_1  EQU     0E7h            ; Set scaling 2 to 1
MOUSE_SCALE_1_1  EQU     0E6h            ; Set scaling 1 to 1
MOUSE_DIAG_OK    EQU     0AAh            ; Diagnostics ok
MOUSE_DIAG_ID    EQU     000h            ; Diagnostic ID number

;
; The following codes are specific to the Microsoft PS/2 mouse
;

MOUSE_MS_VERS    EQU     052h            ; Read current firmware version number
MOUSE_MS_INPORT  EQU     056h            ; Read raw InPort data
MOUSE_MS_DIAG    EQU     059h            ; enter MS diagnostices mode
MOUSE_MS_READRAM EQU     05Bh            ; read ram byte

;****************************************************************
;               8 0 4 2  D E F I N I T I O N S                  *
;****************************************************************

;
; 8042 port definitions.
;

DATA_8042       EQU     60h             ; Port where data is sent to/from 8042.
CONTROL_8042    EQU     64h             ; Port where commands are sent to 8042.
STATUS_8042     EQU     64h             ; Port where status is read from 8042.
CRT_DATA_SEG    EQU     40H             ; ROM BIOS CRT Data Segment Address

;
; Status register bit definitions.
;

OUTPUT_BUFFER_FULL      EQU     01h     ; 8042's output buffer is full.
INPUT_BUFFER_FULL       EQU     02h     ; 8042's input buffer is full.
AUX_OUTPUT_BUFFER_FULL  EQU     20h     ; 8042's aux output buffer is full.

;
; Command byte bit definitions.
;

AUX_DISABLED    EQU     20h             ; Auxiliary interface is disabled.
AUX_INT_ENABLE  EQU     02h             ; Auxiliary interrupts are enabled.
KBD_INT_ENABLE  EQU     01H             ; Keyboard interrupt enabled.
;
; 8042 commands.
;

CMD8042_READ_CMD EQU    020h            ; Read command byte.
CMD8042_WRITE_CMD EQU   060h            ; Write command byte.
CMD8042_DISABLE_AUX EQU 0A7h            ; Disable auxiliary interface.
CMD8042_ENABLE_AUX EQU  0A8h            ; Enable auxiliary interface.
CMD8042_TEST_AUX EQU    0A9h            ; Test auxiliary interface.
CMD8042_DISABLE_KBD EQU 0ADh            ; Disable keyboard.
CMD8042_ENABLE_KBD EQU  0AEh            ; Enable keyboard.
CMD8042_WRITE_AUX EQU   0D4h            ; Send data to auxiliary device.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\mousec.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    hwdata.c

Abstract:

    This module contains the C code to set up mouse configuration data.

Author:

    Shie-Lin Tzong (shielint) 18-Jan-1991

Revision History:

--*/

#include "hwdetect.h"
#include "string.h"

//
// External References
//

extern PMOUSE_INFORMATION
LookForPS2Mouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForInportMouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForSerialMouse (
    VOID
    );

extern PMOUSE_INFORMATION
LookForBusMouse (
    VOID
    );

extern VOID
Empty8042 (
    VOID
    );

extern USHORT
HwGetKey (
    VOID
    );

extern VOID
HwPushKey (
    USHORT Key
    );

extern USHORT SavedKey;
extern UCHAR  FastDetect;

//
// Define the master and slave i8259 IRQ bitmask.
//

#define MASTER_IRQ_MASK_BITS 0xB8
#define SLAVE_IRQ_MASK_BITS  0x02

//
// Define the lowest i8259 IRQ that the Inport mouse can reside on.  This
// has the highest NT priority.
//

#define INPORT_LOWEST_IRQ 0x03

//
// Define the Inport chip reset value.
//

#define INPORT_RESET 0x80

//
// Define the data registers (pointed to by the Inport address register).
//

#define INPORT_DATA_REGISTER_1 1
#define INPORT_DATA_REGISTER_2 2

//
// Define the Inport mouse mode register and mode bits.
//

#define INPORT_MODE_REGISTER           7
#define INPORT_MODE_0                  0x00 // 0 HZ - INTR = 0
#define INPORT_MODE_30HZ               0x01
#define INPORT_MODE_50HZ               0x02
#define INPORT_MODE_100HZ              0x03
#define INPORT_MODE_200HZ              0x04
#define INPORT_MODE_1                  0x06 // 0 HZ - INTR = 1
#define INPORT_DATA_INTERRUPT_ENABLE   0x08
#define INPORT_TIMER_INTERRUPT_ENABLE  0x10
#define INPORT_MODE_HOLD               0x20
#define INPORT_MODE_QUADRATURE         0x00

//
// Video adaptor type identifiers.
//

PUCHAR MouseIdentifier[] = {
    "UNKNOWN",
    "NO MOUSE",
    "MICROSOFT",
    "MICROSOFT BALLPOINT",
    "LOGITECH"
    };

PUCHAR MouseSubidentifier[] = {
    "",
    " PS2 MOUSE",
    " SERIAL MOUSE",
    " INPORT MOUSE",
    " BUS MOUSE",
    " PS2 MOUSE WITH WHEEL",
    " SERIAL MOUSE WITH WHEEL"
    };


//
// The following table translates keyboard make code to
// ascii code.  Note, only 0-9 and A-Z are translated.
// Everything else is translated to '?'
//

UCHAR MakeToAsciiTable[] = {
    0x3f, 0x3f, 0x31, 0x32, 0x33,      // ?, ?, 1, 2, 3,
    0x34, 0x35, 0x36, 0x37, 0x38,      // 4, 5, 6, 7, 8,
    0x39, 0x30, 0x3f, 0x3f, 0x3f,      // 9, 0, ?, ?, ?,
    0x3f, 0x51, 0x57, 0x45, 0x52,      // ?, Q, W, E, R,
    0x54, 0x59, 0x55, 0x49, 0x4f,      // T, Y, U, I, O,
    0x50, 0x3f, 0x3f, 0x3f, 0x3f,      // P, ?, ?, ?, ?,
    0x41, 0x53, 0x44, 0x46, 0x47,      // A, S, D, F, G,
    0x48, 0x4a, 0x4b, 0x4c, 0x3f,      // H, J, K, L, ?,
    0x3f, 0x3f, 0x3f, 0x3f, 0x5a,      // ?, ?, ?, ?, Z,
    0x58, 0x43, 0x56, 0x42, 0x4e,      // X, C, V, B, N,
    0x4d};                             // W
#define MAX_MAKE_CODE_TRANSLATED 0x32

static ULONG MouseControllerKey = 0;

FPFWCONFIGURATION_COMPONENT_DATA
SetMouseConfigurationData (
    PMOUSE_INFORMATION MouseInfo,
    FPFWCONFIGURATION_COMPONENT_DATA MouseList
    )

/*++

Routine Description:

    This routine fills in mouse configuration data.

Arguments:

    MouseInfo - Supplies a pointer to the MOUSE_INFOR structure

    MouseList - Supplies a pointer to the existing mouse component list.

Returns:

    Returns a pointer to our mice controller list.

--*/
{
    UCHAR i = 0;
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry, Controller, PeripheralEntry;
    FPFWCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    USHORT z, Length;
    FPUCHAR fpString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // If it is not SERIAL_MOUSE, set up controller component
        //

        Controller = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                     sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

        Component = &Controller->ComponentEntry;

        Component->Class = ControllerClass;
        Component->Type = PointerController;
        Component->Flags.Input = 1;
        Component->Version = 0;
        Component->Key = MouseControllerKey;
        MouseControllerKey++;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;

        //
        // If we have mouse irq or port information, allocate configuration
        // data space for mouse controller component to store these information
        //

        if (MouseInfo->MouseIrq != 0xffff || MouseInfo->MousePort != 0xffff) {

            //
            // Set up port and Irq information
            //

            if (MouseInfo->MousePort != 0xffff) {
                ControlData.NumberPortEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_PORT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareDeviceExclusive;
                ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
                ControlData.DescriptorList[z].u.Port.Start.LowPart =
                                        (ULONG)MouseInfo->MousePort;
                ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
                ControlData.DescriptorList[z].u.Port.Length = 4;
                z++;
            }
            if (MouseInfo->MouseIrq != 0xffff) {
                ControlData.NumberIrqEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareUndetermined;
                ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
                ControlData.DescriptorList[z].u.Interrupt.Level =
                                        (ULONG)MouseInfo->MouseIrq;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                        (ULONG)MouseInfo->MouseIrq;
                if (HwBusType == MACHINE_TYPE_MCA) {
                    ControlData.DescriptorList[z].Flags =
                                                        LEVEL_SENSITIVE;
                } else {

                    //
                    // For EISA the LevelTriggered is temporarily set to FALSE.
                    //

                    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                }
            }
            Controller->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          NULL,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

        } else {

            //
            // Otherwise, we don't have configuration data for the controller
            //

            Controller->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;
        }
    }

    //
    // Set up Mouse peripheral component
    //

    PeripheralEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                       sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);

    Component = &PeripheralEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = PointerPeripheral;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    PeripheralEntry->ConfigurationData = (FPVOID)NULL;

    //
    // If Mouse PnP device id is found, translate it to ascii code.
    // (The mouse device id is presented to us by keyboard make code.)
    //

    Length = 0;
    if (MouseInfo->DeviceIdLength != 0) {
        USHORT i;

        if (MouseInfo->MouseSubtype == PS_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                if (MouseInfo->DeviceId[i] > MAX_MAKE_CODE_TRANSLATED) {
                    MouseInfo->DeviceId[i] = '?';
                } else {
                    MouseInfo->DeviceId[i] = MakeToAsciiTable[MouseInfo->DeviceId[i]];
                }
            }
        } else if (MouseInfo->MouseSubtype == SERIAL_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                MouseInfo->DeviceId[i] += 0x20;
            }
        }
        Length = MouseInfo->DeviceIdLength + 3;
    }
    Length += strlen(MouseIdentifier[MouseInfo->MouseType]) +
              strlen(MouseSubidentifier[MouseInfo->MouseSubtype]) + 1;
    fpString = (FPUCHAR)HwAllocateHeap(Length, FALSE);
    if (MouseInfo->DeviceIdLength != 0) {
        _fstrcpy(fpString, MouseInfo->DeviceId);
        _fstrcat(fpString, " - ");
        _fstrcat(fpString, MouseIdentifier[MouseInfo->MouseType]);
    } else {
        _fstrcpy(fpString, MouseIdentifier[MouseInfo->MouseType]);
    }
    _fstrcat(fpString, MouseSubidentifier[MouseInfo->MouseSubtype]);
    Component->IdentifierLength = Length;
    Component->Identifier = fpString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {
        Controller->Child = PeripheralEntry;
        PeripheralEntry->Parent = Controller;
        if (MouseList) {

            //
            // Put the current mouse component to the beginning of the list
            //

            Controller->Sibling = MouseList;
        }
        return(Controller);
    } else {
        CurrentEntry = AdapterEntry->Child; // AdapterEntry MUST have child
        while (CurrentEntry) {
            if (CurrentEntry->ComponentEntry.Type == SerialController) {
                if (MouseInfo->MousePort == (USHORT)CurrentEntry->ComponentEntry.Key) {

                    //
                    // For serial mouse, the MousePort field contains
                    // COM port number.
                    //

                    PeripheralEntry->Parent = CurrentEntry;
                    CurrentEntry->Child = PeripheralEntry;
                    break;
                }
            }
            CurrentEntry = CurrentEntry->Sibling;
        }
        return(NULL);
    }
}

FPFWCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    )

/*++

Routine Description:

    This routine is the entry for mouse detection routine.  It will invoke
    lower level routines to detect ALL the mice in the system.

Arguments:

    None.

Returns:

    A pointer to a mouse component structure, if mouse/mice is detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PMOUSE_INFORMATION MouseInfo;
    FPFWCONFIGURATION_COMPONENT_DATA MouseList = NULL;

    //
    // Check if there is a key in keyboard look ahead buffer.  If yes and
    // we have not saved any, we will read it and remember it.
    //

    if (SavedKey == 0) {
        SavedKey = HwGetKey();
    }
    if (MouseInfo = LookForPS2Mouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }
    if (MouseInfo = LookForInportMouse()) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    while (MouseInfo = LookForSerialMouse()) {
        SetMouseConfigurationData(MouseInfo, MouseList);
    }

    if (!FastDetect && (MouseInfo = LookForBusMouse())) {
        MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    }

    //
    // Finally drain 8042 output buffer again before we leave
    //

    Empty8042();

    //
    // If we have a keystroke before the mouse/keyboard detection, we
    // needs to push the key back to the keyboard look ahead buffer such
    // that ntldr can read it.
    //

    if (SavedKey) {
       HwPushKey(SavedKey);
    }
    return(MouseList);
}

BOOLEAN
InportMouseIrqDetection(
    IN USHORT CurrentPort,
    OUT PUSHORT Vector
    )

/*++

Routine Description:

    This routine attempts to locate the interrupt vector for which
    the Inport mouse is configured.  The allowable vectors are
    3, 4, 5, 7, and 9.  If no interrupt vector is found, or more than
    one is found, the routine returns FALSE.  Otherwise, TRUE is returned.

    Note that we diddle the i8259 interrupt controllers here.

Arguments:

    CurrentPort - I/O port to use for the mouse.

    Vector - Pointer to the location to store the mouse interrupt vector.

Return Value:

    Returns TRUE if the Inport interrupt vector was located; otherwise,
    FALSE is returned.

--*/

{
    UCHAR OldMasterMask, OldSlaveMask;
    UCHAR MasterMask, SlaveMask;
    UCHAR InterruptBits;
    UCHAR PossibleInterruptBits;
    int i;
    int NumberOfIRQs;
    BOOLEAN VectorFound = FALSE;

    //
    // Get the i8259 interrupt masks.
    //

    OldMasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);
    OldSlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

    //
    // Raise IRQL to the highest priority IRQL the inport would use.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) 0xff ^ ((UCHAR)(1<<INPORT_LOWEST_IRQ) - 1)
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        (UCHAR) 0xff
        );

    //
    // Get the master i8259 interrupt mask.
    //

    MasterMask = READ_PORT_UCHAR((PUCHAR) PIC1_PORT1);

    //
    // Reset the Inport chip.
    //

    WRITE_PORT_UCHAR((PUCHAR)CurrentPort, INPORT_RESET);

    //
    // Select the Inport mode register for use as the current data register.
    //

    WRITE_PORT_UCHAR((PUCHAR)CurrentPort, INPORT_MODE_REGISTER);

    //
    // Disable potential Inport mouse interrupts.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        (UCHAR) (MasterMask | MASTER_IRQ_MASK_BITS)
        );

    //
    // Select the i8259 Interrupt Request Register.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_IRR);

    //
    // Attempt to locate the Inport interrupt line on the master i8259.
    // Why try this 10 times?  It's magic...
    //

    PossibleInterruptBits = MASTER_IRQ_MASK_BITS;
    for (i = 0; i < 10; i++) {

        //
        // Generate a 0 on the Inport IRQ on the master i8259.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
            INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_0
            );

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 7, 5, 4, 3, and 2 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        InterruptBits ^= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits)
            break;

        //
        // Generate a 1 on the Inport IRQ on the master i8259.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
            INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_1
            );

        //
        // Read the interrupt bits off the master i8259.  Only bits
        // 7, 5, 4, 3, and 2 are of interest.  Eliminate non-functional
        // IRQs.  Only continue looking at the master i8259 if there
        // is at least one functional IRQ.
        //

        InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC1_PORT0);
        InterruptBits &= MASTER_IRQ_MASK_BITS;
        PossibleInterruptBits &= InterruptBits;

        if (!PossibleInterruptBits)
            break;
    }

    if (PossibleInterruptBits) {

        //
        // We found at least one IRQ on the master i8259 that could belong
        // to the Inport mouse.  Count how many we found.  If there is
        // more than one, we haven't found the vector.  Otherwise, we've
        // successfully located the Inport interrupt vector on the master
        // i8259 (provided the interrupt vector is 3, 4, 5, or 7).
        //

        PossibleInterruptBits >>= 3;
        NumberOfIRQs = 0;
        for (i = 3; i <= 7; i++) {
            if (PossibleInterruptBits & 1) {
                NumberOfIRQs += 1;
                *Vector = (CCHAR) i;
            }
            PossibleInterruptBits >>= 1;
        }
        if (NumberOfIRQs == 1) {
            VectorFound = TRUE;
        } else {
            *Vector = 0xffff;
        }
    }

    //
    // If we didn't locate the interrupt vector on the master i8259, attempt
    // to locate it on the slave i8259.
    //

    if (!VectorFound) {

        //
        // Get the slave i8259 interrupt mask.
        //

        SlaveMask = READ_PORT_UCHAR((PUCHAR) PIC2_PORT1);

        //
        // Disable potential Inport mouse interrupts.
        //

        WRITE_PORT_UCHAR(
            (PUCHAR) PIC2_PORT1,
            (UCHAR) (SlaveMask | SLAVE_IRQ_MASK_BITS)
            );

        //
        // Select the i8259 Interrupt Request Register.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_IRR);

        //
        // Attempt to locate the Inport interrupt line on the slave i8259.
        // Why try this 10 times?  It's magic...
        //

        PossibleInterruptBits = SLAVE_IRQ_MASK_BITS;
        for (i = 0; i < 10; i++) {

            //
            // Generate a 0 on the Inport IRQ on the slave i8259.
            //

            WRITE_PORT_UCHAR(
                (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
                INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_0
                );

            //
            // Read the interrupt bits off the slave i8259.  Only bit 2
            // is of interest.  Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            InterruptBits ^= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits)
                break;

            //
            // Generate a 1 on the Inport IRQ on the slave i8259.
            //

            WRITE_PORT_UCHAR(
                (PUCHAR)(CurrentPort + INPORT_DATA_REGISTER_1),
                INPORT_TIMER_INTERRUPT_ENABLE + INPORT_MODE_1
                );

            //
            // Read the interrupt bits off the slave i8259.  Only bit 2
            // is of interest.  Eliminate non-functional IRQs.  Only continue
            // looking at the slave i8259 if there is at least one
            // functional IRQ.
            //

            InterruptBits = READ_PORT_UCHAR((PUCHAR) PIC2_PORT0);
            InterruptBits &= SLAVE_IRQ_MASK_BITS;
            PossibleInterruptBits &= InterruptBits;

            if (!PossibleInterruptBits)
                break;

        }

        //
        // We may have found the Inport IRQ.  If it's not 2 on slave (really
        // 9, overall) then we have NOT found the Inport interrupt vector.
        // Otherwise, we have successfully located the Inport vector on
        // the slave i8259.
        //

        if (PossibleInterruptBits == 2) {
            *Vector = 9;
            VectorFound = TRUE;
        } else {
           *Vector = 0xffff;
        }

        //
        // Restore the i8259 slave.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT0, OCW3_READ_ISR);

        //
        // Restore the i8259 slave interrupt mask.
        //

        WRITE_PORT_UCHAR((PUCHAR) PIC2_PORT1, SlaveMask);
    }

    //
    // Tri-state the Inport IRQ line.
    //

    WRITE_PORT_UCHAR((PUCHAR) (CurrentPort + INPORT_DATA_REGISTER_1), 0);

    //
    // Restore the i8259 master.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT0, OCW3_READ_ISR);

    //
    // Restore the i8259 master interrupt mask.
    //

    WRITE_PORT_UCHAR((PUCHAR) PIC1_PORT1, MasterMask);

    //
    // Restore the previous IRQL.
    //

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC1_PORT1,
        OldMasterMask
        );

    WRITE_PORT_UCHAR(
        (PUCHAR) PIC2_PORT1,
        OldSlaveMask
        );

    return(VectorFound);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pccard.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       pccard.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for the pccard IRQ detection mechanism.
;
;   Author:
;
;       Neil Sandlin (neilsa) 11-Dec-1998
;
;   Revision History:
;
;--

ifndef NEC_98
PIC1_OCW3    equ 20h
PIC1_IMR    equ 21h

PIC2_OCW3     equ 0A0h
PIC2_IMR     equ 0A1h        
else
PIC1_IMR    equ 2
PIC2_IMR    equ 0ah
PIC1_OCW3   equ 0
PIC2_OCW3   equ 8
endif

ifdef NEC_98
PIC_20          EQU     000h
PIC_21          EQU     002h
PIC_A0          EQU     008h
PIC_A1          EQU     00Ah
else ;NEC_98
PIC_20          EQU     020h
PIC_21          EQU     021h
PIC_A0          EQU     0A0h
PIC_A1          EQU     0A1h
endif ;NEC_98
PIC_RD_IR       EQU     00Ah
PIC_SPEC_EOI    EQU     060h
PIC_LEVEL_MSK   EQU     007h                 


PCIC_IDENT             equ 00
PCIC_STATUS            equ 01
PCIC_PWR_RST           equ 02
PCIC_INTERRUPT         equ 03
PCIC_CARD_CHANGE       equ 04
PCIC_CARD_INT_CONFIG   equ 05
IGC_PCCARD_RESETLO     equ 40h
CSCFG_CD_ENABLE        equ 8
PCIC_CARD_DETECT       equ 16h
CDGC_SW_DET_INT        equ 20h


PCI_TYPE1_ADDR_PORT    equ 0CF8h
PCI_TYPE1_DATA_PORT    equ 0CFCh
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\mousea.asm ===
title  "Mouse detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mouse.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    various mouse in the system.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 10-Dec-1991.
;    Most of the code is taken from win31 setup code(with modification.)
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include mouse.inc
        .list

.386
extrn                _Empty8042:proc
extrn                Write8042:proc
extrn                ReadKeyboard:proc
extrn                _ComPortAddress:word
extrn                _DisableSerialMice:word
extrn                _FastDetect:byte

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'

LATLSBSave           db  ?
LATMSBSave           db  ?
LCRSave              db  ?
MCRSave              db  ?
IERSave              db  ?
fSingle8259          db  0
DWFinalCount         dw  2 dup (0)
DWCurrCount          dw  2 dup (0)

NextComPort          dw      0               ; Offset into ComPortAddress[]
MouseInfo            MouseInformation        <0, 0, 0FFFFh, 0FFFFh, 0>

;
; MouseDetected is used to indicate if any mouse has been detected.
;

MouseDetected   dw      0               ; initialize to no
InPortIoBase    dw      0               ; The Base addr for inport mouse

_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:_DATA, SS:NOTHING


;++
;
; USHORT
; LookForPS2Mouse (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines mouse type in the system.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (eax): mouse Id.
;
;--

        public  _LookForPS2Mouse
_LookForPS2Mouse proc    near
        push    bx
        push    si
        push    di

        mov     si, offset MouseInfo
        lea     si, [si].DeviceId

        call    _Empty8042

        int     11h
        test    ax, 4                   ; is bit 2 set?
        jz      No_PS2_Mouse            ; No, no PS/2 mouse.

        xor     di, di

;
; Shortcut the rest of the detection and mouse reset if fast detect is set.
;

        cmp     _FastDetect, 0
        jne     short Is_PS2_Mouse

;
; Old Olivetti M400-60 and M400-40 will have trouble reading floppy
; and hard disk if the following call is made .
;

        mov     ax, 0c201h              ; reset PS/2 mouse
        int     15h
        jc      short No_PS2_Mouse
        jmp     short Is_PS2_Mouse

        mov     bh, 03                  ; Packet size = 3 bytes
        mov     ax, 0c205h              ; init point device interface
        int     15h
        jc      short No_PS2_Mouse

        mov     ax, 0c201h              ; reset PS/2 mouse
        int     15h
        jc      short No_PS2_Mouse

        call    _Empty8042

;
; The following sequence of Int 15h calls will determine if a Logitech
; PS/2 mouse is present.  This information was obtained from Logitech.
;

        mov     ax,0C203h               ; Set resolution to 1 cnt/mm
        mov     bh,0h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Set scaling to 1:1
        mov     bh,1h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Set scaling to 1:1
        mov     bh,1h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Set scaling to 1:1
        mov     bh,1h
        int     15h
        jc      Is_PS2_Mouse

        mov     ax,0C206h               ; Get status
        mov     bh,0h
        int     15h
        jc      Is_PS2_Mouse

        or      cl,cl                   ; Is resolution 1 cnt/mm?
        jz      Is_PS2_Mouse               ; Yes, then not a Logitech.

;
; If cl is not zero (i.e. 1 cnt/mm) then it is the number of buttons
; and we've found a Logitech 3-button PS/2 mouse
;

LT_PS2_Mouse:
        mov     ax,LT_MOUSE + PS2_MOUSE
        jmp     short PS2MouseFound

Is_PS2_Mouse:
        mov     ax,MS_MOUSE + PS2_MOUSE
        jmp     short PS2MouseFound

No_PS2_Mouse:
        mov     bx, 0
        jmp     ExitPs2Mouse

PS2MouseFound:

;
; Set mouse type and subtype to mouse info structure
;

        mov     bx, offset MouseInfo
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MouseIrq, 12
        mov     [bx].MousePort, 0ffffh
        mov     [bx].DeviceIdLength, di
        mov     MouseDetected, bx

ExitPs2Mouse:

;
; Drain 8042 input buffer and leave leave pointing device disabled.
; We don't want user moves the mouse and hangs the system.
;

        call    _Empty8042
        mov     ax, bx
        pop     di
        pop     si
        pop     bx
        ret

_LookForPS2Mouse endp

;++
;
; USHORT
; LookForInportMouse (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines mouse type in the system.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (eax): mouse Id.
;
;--

        public  _LookForInportMouse
_LookForInportMouse     proc    near

        push    bx
        mov     dx,INPORT_FIRST_PORT + 2 ; Get address of ID register.

inport_try_again:
        call    TestForInport           ; Does an InPort exist at this address?
        jnc     inport_found            ; No carry ! Inport found !

        sub     dx,4                    ; Nope, try the next possible port.
        cmp     dx,INPORT_LAST_PORT + 2
        jae     inport_try_again

        mov     ax, 0                   ; Fail to detect inport mouse
        jmp     short no_inport

inport_found:

;
; Set mouse type and subtype to mouse info structure
;

        mov     ax,MS_MOUSE + INPORT_MOUSE
        mov     cx, dx
        sub     cx, 2
        mov     bx, offset MouseInfo
        mov     [bx].DeviceIdLength, 0
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MousePort, cx
        mov     InportIoBase, cx
        mov     MouseDetected, bx
        lea     ax, [bx].MouseIrq
        push    ax
        push    cx                      ; Current Port
        call    _InportMouseIrqDetection
        add     sp, 4
        mov     ax, offset MouseInfo

no_inport:
        pop     bx
        ret

_LookForInportMouse endp

;++
;
; USHORT
; LookForBusMouse (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure will attempt to find a bus mouse adaptor in the system
;    and will return the results of this search.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--

        public  _LookForBusMouse
_LookForBusMouse proc    near

;
; If We already found Inport mouse and its IO base is 23ch, it is
; impossible to have a BUS mouse.
;

        cmp     InportIoBase, BUS_MOUSE_BASE
        jne     short @f
        mov     ax, 0
        ret

@@:
        push    bx

;
; We determine if the bus mouse adaptor is present by attempting to
;       program the 8255A, and then seeing if we can write a value out to
;       Port B on the 8255A and get that value back. If we can, we assume
;       that we have a bus mouse adaptor.
;

        mov     dx,BUS_INIT             ; Get address of 8255A control port.
        mov     al,BUS_INIT_VALUE       ; Get proper value.
        DelayOut                        ; Set up 8255A.
        mov     ax,0A5A5h               ; Get a signature byte.
        address BUS_SIG BUS_INIT        ; Get address of Port B.
        DelayOut                        ; Set Port B with signature.
        DelayIn                         ; Read back Port B.

        cmp     al,ah                   ; Does it match signature byte?
        jne     No_Bus_Mouse            ; Nope - no bus mouse adaptor

        mov     ax,MS_MOUSE + BUS_MOUSE
        jmp     short Bus_Mouse_Found

No_Bus_Mouse:
        mov     ax, 0                   ; No Bus Mouse detected
        jmp     short Bus_Exit

Bus_Mouse_Found:

;
; Set mouse type and subtype to mouse info structure
;

        mov     dx, BUS_MOUSE_BASE
        mov     bx, offset MouseInfo
        mov     [bx].DeviceIdLength, 0
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MousePort, dx
        mov     MouseDetected, bx
        call    BusMouseIrqDetection
        mov     [bx].MouseIrq, ax       ; if (ax) = 0xffff, no irq detected
        mov     ax, offset MouseInfo    ; return MouseInfor
Bus_Exit:
        pop     bx
        ret

_LookForBusMouse endp

;++
;
; USHORT
; BusMouseIrqDetection (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will attempt to find the irq level associated with the
;    Bus mouse in the machine.
;
; Arguments:
;
;    (dx) = Bus mouse base I/O port.
;
; Return Value:
;
;    (ax) = Irq level.  if (ax)= 0xffff, detection failed.
;
;--

BusMouseIrqDetection    proc    near

        push    bx

        add     dx, 2                   ; use adaptor control port
        in      al,dx                   ; Get irq 2-5 states
        IOdelay
        mov     ah,al                   ; Save states
        mov     cx,10000                ; Set loop count
        xor     bh,bh                   ; Clear changes buffer

@@:
        in      al,dx                   ; Get current states of irq 2-5
        IOdelay
        xor     ah,al                   ; Compare with last state
        or      bh,ah                   ; Mark any changes
        mov     ah,al                   ; Previous := current state
        loop    @B                      ; Keep looking

        mov     ax, 0ffffh
        or      bh,bh                   ; Any irq found?
        jz      short BusIntExit        ; Branch if no interrupt was found

BusIntFound:
        mov     ax,5                    ; Assume irq5
        test    bh,0001b                        ; Is it off?
        jnz     short BusIntExit        ; Yes..have irq5
        mov     ax,2                    ; Assume irq2
        test    bh,1000b
        jnz     short BusIntExit
        inc     ax                      ; Try irq3
        test    bh,0100b
        jnz     short BusIntExit
        inc     ax                      ; Must be irq4

BusIntExit:                             ; ax contains the IRQ number
        pop     bx
        ret

BusMouseIrqDetection    endp


;++
;
; USHORT
; LookForSerialMouse (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure will attempt to find a serial mouse adaptor in the system
;    and will return the results of this search.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--

        public  _LookForSerialMouse
_LookForSerialMouse     proc    near

        push    di
        push    bx

        mov     di, NextComPort         ; Get untested comport
        cmp     di, 8                   ; Have we over the comport limit?
        jae     short No_Serial_Mouse   ; if above or e, yes, exit

serial_try_again:
        mov     cx, di
        mov     al, 1
        shr     cx, 1
        inc     cx
        shl     ax, cl
        test    _DisableSerialMice, ax  ; Should we skip this com port?
        jnz     short serial_next_port  ; yes, try next one.

        mov     dx, _ComPortAddress[di] ; Get base address of COM port to test.
        or      dx,dx                   ; Does this port exist?
        jz      serial_next_port        ; No, try next one.

serial_test_port:

;
; The comport address is initialized by com detection routine.  if the port
; value is not zero, it means that the port exist.
;

        call    TestForSerial           ; Is a serial mouse attached to port?
        cmp     ax,NO_MOUSE
        jne     Serial_Mouse_Found      ; Yes! found a serial mouse

serial_next_port:                       ; No serial mouse on this COM port.
        add     di,2                    ; move to the next possible port
        cmp     di,8                    ; Are we over com limit?
        jb      serial_try_again        ; if b, no, go test it.

        mov     NextComport, di
No_Serial_Mouse:
        mov     ax, 0                   ; No serial mouse detected
        jmp     short SerialMouseExit

Serial_Mouse_Found:
        mov     NextComport, di
        add     NextComport, 2          ; Next comport to test

        shr     di, 1                   ; divide di by 2

;
; Set mouse type and subtype to mouse info structure
;

        mov     bx, offset MouseInfo
        mov     [bx].DeviceIdLength, 0
        cmp     ax, MS_MOUSE + SERIAL_MOUSE_WITH_WHEEL
        jnz     short @f

        mov     [bx].DeviceIdLength, 7
@@:
        mov     [bx].MouseSubtype, al
        mov     [bx].MouseType, ah
        mov     [bx].MousePort, di
        mov     [bx].MouseIrq, 0ffffh
        mov     MouseDetected, bx
        mov     ax, bx

SerialMouseExit:
        pop     bx
        pop     di
        ret

_LookForSerialMouse endp


;++
;
; BOOLEAN
; TestForInport (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will attempt to find an InPort mouse at the given base
;    I/O address. Note that if an InPort is found, it will be left
;    in a state where it will not be generating any interrupts.
;
; Arguments:
;
;    Port (DX) - I/O address of Inport identification register.
;
; Return Value:
;
;    NC - An Inport was found
;    CY - No Inport was found
;
;--

TestForInport   PROC    NEAR

        push    bx
        push    si

;
; Since the identification register alternates between returning back
;       the Inport chip signature and the version/revision, if we have an
;       InPort chip, the chip signature will be read in one of the following
;       two reads. If it isn't, we do not have an InPort chip.
;

        mov     bl,INPORT_ID
        in      al,dx                   ; Read ID register.
        cmp     al,bl                   ; Is value the InPort chip signature?
        je      possible_inport         ; Yes, go make sure we have an InPort.
        in      al,dx                   ; Read ID register again.
        cmp     al,bl                   ; Is value the InPort chip signature?
        jne     inport_not_found        ; No, return error

;
; At this point, we managed to read the InPort chip signature, so we have
;       a possible InPort chip. The next read from the ID register will
;       return the version/revision. We then make sure that the ID register
;       alternates between the chip signature and this version/revision. If
;       it does, we have an InPort chip.
;

possible_inport:
        in      al,dx                   ; Read version/revision.
        mov     ah,al                   ; Save it.
        mov     cx,5                    ; Test ID register 5 times.

inport_check:
        in      al,dx                   ; Read ID register.
        cmp     al,bl                   ; Make sure it is the chip signature.
        jne     inport_not_found        ; If not, we don't have an InPort chip.
        in      al,dx                   ; Read ID register.
        cmp     al,ah                   ; Make sure version/revision is same.
        jne     inport_not_found        ; If not, we don't have an InPort chip.
        loop    inport_check            ; Test desired number of times.

        clc
        pop     si
        pop     bx
        ret
;
; At this point, we know we have an InPort chip.
;

inport_not_found:                       ; We don't have an InPort chip.
        stc                             ; Show failure.
        pop     si
        pop     bx
        ret                             ; Return to caller.

TestForInport   ENDP


;++
;
; BOOLEAN
; TestForSerial (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will attempt to find a serial mouse adaptor in the system
;    and will return the results of this search.
;
; Arguments:
;
;    (dx) = Port Address.
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--

TestForSerial   PROC    NEAR

      call      SaveCOMSetting

      call      SetupCOMForMouse        ; Set up COM port to talk to mouse.

      mov       cx,SHORTDELAY           ; Use a short delay time.
      call      ResetSerialMouse        ; Reset mouse to see if it is there.
      cmp       ax,NO_MOUSE
      jne       TFS_Found

;
; If a mouse has been detected, most likely there won't be second mouse.
; so we don't test for LONGDELAY to save some time
;

      cmp       MouseDetected, 0
      jne       short @f

      mov       cx,LONGDELAY            ; Maybe the mouse is just slow.
      call      ResetSerialMouse        ; Reset mouse to see if it is there.
      cmp       ax,NO_MOUSE
      jne       TFS_Found

@@:
      call      TestForLogitechSerial   ; Maybe it's a Logitech Series C

TFS_Found:
      push      ax                      ; Save return value
      call      RestoreCOMSetting
      pop       ax
      ret

TestForSerial   ENDP


;++
;
; VOID
; SaveCOMSetting (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will save the current state of the COM port given.
;
; Arguments:
;
;    Port (DX) - Base address of COM port.
;
; Return Value:
;
;    None.
;
;--

SaveCOMSetting  PROC    NEAR

        push    dx                      ; Save base I/O address.
        address LCR RXB                 ; Get address of Line Control Register.
        DelayIn                         ; Get current contents.
        mov     [LCRSave],al            ; Save them.
        or      al,LC_DLAB              ; Set up to access divisor latches.
        DelayOut
        address LATMSB LCR              ; Get address of high word of divisor
        DelayIn                         ; latch and save its current contents.
        mov     [LATMSBSave],al
        address LATLSB LATMSB           ; Get address of low word of divisor
        DelayIn                         ; latch and save its current contents.
        mov     [LATLSBSave],al
        address LCR LATLSB              ; Get address of Line Control Register
        mov     al,[LCRSave]            ; and disable access to divisor.
        and     al,NOT LC_DLAB
        DelayOut
        address MCR LCR                 ; Get address of Modem Control Register
        DelayIn                         ; and save its current contents.
        mov     [MCRSave],al
        address IER MCR                 ; Get address of Interrupt Enable Reg-
        DelayIn                         ; ister and save its current contents.
        mov     [IERSave],al
        pop     dx                      ; Restore base I/O address.
        ret

SaveCOMSetting  ENDP


;++
;
; VOID
; RestoreCOMSetting (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will restore the current state of the COM port given.
;
; Arguments:
;
;    Port (DX) - Base address of COM port.
;
; Return Value:
;
;    None.
;
;--

RestoreCOMSetting       PROC    NEAR

      push      dx                      ; Save base I/O address.
      address   LCR RXB                 ; Get address of Line Control Register.
      mov       al,LC_DLAB              ; Set up to access divisor latches.
      DelayOut
      address   LATMSB LCR              ; Get address of high word of divisor
      mov       al,[LATMSBSave]         ; and restore it.
      DelayOut
      address   LATLSB LATMSB           ; Get address of low word of divisor
      mov       al,[LATLSBSave]         ; and restore it.
      DelayOut
      address   LCR LATLSB              ; Get address of Line Control Register
      mov       al,[LCRSave]            ; and restore it, disabling access to
      and       al,NOT LC_DLAB          ; the divisor latches.
      DelayOut
      address   MCR LCR                 ; Get addres of Modem Control Register
      mov       al,[MCRSave]            ; and restore it.
      DelayOut
      address   IER MCR                 ; Get address of Interrupt Enable Reg-
      mov       al,[IERSave]            ; ister and restore it.
      DelayOut
      pop       dx                      ; Restore base I/O address.
      ret

RestoreCOMSetting       ENDP


;++
;
; VOID
; SetupCOMForMouse (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will set up the given COM port so that it can talk to
;    a serial mouse.
;
; Arguments:
;
;    Port (DX) - Base address of COM port to set up.
;
; Return Value:
;
;    COM port set up, all interrupts disabled at COM port
;
;--

SetupCOMForMouse        PROC    NEAR

        push    dx                      ; Save base I/O address.
        mov     cx, 60h
        call    SetBaudRate

        address LCR RXB
        mov     al,LC_BITS7 + LC_STOP1 + LC_PNONE
        DelayOut                        ; Set 7,n,1; disable access to divisor.
        address IER LCR                 ; Get address of Int. Enable Register
        xor     al,al                   ; Disable all interrupts at the COM
        DelayOut                        ; port level.
        address LSR IER                 ; Get address of Line Status Reg.
        DelayIn                         ; Read it to clear any errors.
        pop     dx                      ; Restore base I/O address
        ret

SetupCOMForMouse        ENDP


;++
;
; USHORT
; ResetSerialMouse (
;    USHORT Port,
;    USHORT Delay
;    )
;
; Routine Description:
;
;    This procedure will reset a serial mouse on the given COM port and will
;    return an indication of whether a mouse responded or not.
;
;    The function now also checks for the presence of a 'B' as well as an
;    'M' to determine the presence of a pointing device.  Also, if the 'M' is
;    followed by a '3' the serial mouse is a Logitech.
;
;    Mouse     returns M
;    Ballpoint returns B
;
; Arguments:
;
;    Port (DX) - Base I/O address of COM port to use
;    Delay (CX) - Number of msecs to use for delays
;
; Return Value:
;
;    (ax) = Mouse Type.
;
;--

ResetSerialMouse PROC NEAR

      push      dx                  ; Save environment.
      push      si
      push      di
      push      es

      address   IER RXB             ; Get address of Interrupt Enable Reg.
      DelayIn                       ; Get current contents of IER and
      push      ax                  ; save them.
      push      dx                  ; Save address of IER.
      xor       al,al               ; Disable all interrupts at the
      DelayOut                      ; COM port level.

      address   MCR IER             ; Get address of Modem Control Reg.
      mov       al,MC_DTR           ; Set DTR active; RTS, OUT1, and OUT2
      DelayOut                      ; inactive. This powers down mouse.

      push      cx                  ; Save amount of time to delay.
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; upcoming delay loop.

      address   RXB MCR             ; Get address of Receive Buffer.

;
; Now, we wait the specified amount of time, throwing away any stray
; data that we receive. This gives the mouse time to properly reset
; itself.
;

rsm_waitloop:
      in        al, dx              ; Read and ignore any stray data.
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       rsm_waitloop        ; If not, keep waiting.

;
; Wait is over.
;

      address   LSR RXB             ; Get address of Line Status Reg.
      DelayIn                       ; Read it to clear any errors.
      address   MCR LSR             ; Get address of Modem COntrol Reg.
      mov       al,MC_DTR+MC_RTS    ; Set DTR, RTS, and OUT2 active
                                         ; OUT1 inactive.
      DelayOut                      ; This powers up the mouse.

      pop       cx                  ; Get amount of time to delay.
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; the upcoming delay loop.

;
; We give the mouse the specified amount of time to respond by sending
; us an M. If it doesn't, or we get more than 5 characters that aren't
; an M, we return a failure indication.
;

      address   LSR MCR             ; Get address of Line Status Reg.
      mov       si, 5               ; Read up to 5 chars from port.
      mov       bl,'3'              ; '3' will follow 'M' on Logitech.
      mov       bh,'B'              ; 'B' for BALLPOINT
      mov       ah,'M'              ; Get an M. (We avoid doing a cmp al,M
                                    ; because the M could be left floating
                                    ; due to capacitance.)
rsm_getchar:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       rsm_gotchar         ; Yes! Go and read it.
      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       rsm_getchar         ; Haven't timed out; keep looking.

      mov       bx,NO_MOUSE
      jmp       rsm_leave           ; Timed out. Leave with NO_MOUSE.

rsm_gotchar:

      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      cmp       al,ah               ; Is it an M?
      jne       check_for_b

;
; We received an 'M', now wait for next character to see if it is a '3'.
;

      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
      address   LSR RXB

rsm_waitfor3:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       rsm_gotchar3        ; Yes! Go and read it.
      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       rsm_waitfor3        ; Haven't timed out; keep looking.

;
; Not a Logitech - must be a standard Microsoft compatible serial mouse.
;

      jmp       rsm_notLT

rsm_gotchar3:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      cmp       al,bl               ; Is it a 3?
      jne       short rsm_check_for_z

      mov       bx,LT_MOUSE + SERIAL_MOUSE ; Yes, we've found a Logitech M+
      jmp       rsm_leave           ;   series, 3 button mouse

rsm_check_for_z:

;
; Determine if this is Microsoft mouse with wheel.
; 'M', 'Z', 0x40, 0x00, 0x00, 0x00, PnP String
;
      cmp       al, 'Z'
      jnz       rsm_notLT

;
; Check for 0x40, 0x00, 0x00, 0x00
;

      mov       ebx, 040h
      mov       cx, 4
      address   LSR RXB
rsm_get_byte:
      push      cx
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
@@:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       short @f            ; Yes! Go and read it.

      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       short @b            ; Haven't timed out; keep looking.
      jmp       rsm_notMZ

@@:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      cmp       al,bl               ; Is it a MS wheel?
      jnz       rsm_notMZ

      shr       ebx, 8
      address   LSR RXB
      pop       cx
      sub       cx, 1
      jnz       rsm_get_byte

;
; Next read PnP string for the MS wheel mouse
; First skip 3 bytes: 08 + 2-byte Rev number
;

      mov       cx, 3
rsm_get_byte1:
      push      cx
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
@@:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       short @f            ; Yes! Go and read it.

      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       short @b            ; Haven't timed out; keep looking.
      jmp       rsm_notMZ

@@:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      address   LSR RXB
      pop       cx
      sub       cx, 1
      jnz       rsm_get_byte1

;
; Next read 7 bytes PnpDevice id

      mov       si, offset MouseInfo
      lea       si, [si].DeviceId

      mov       cx, 7
rsm_get_byte2:
      push      cx
      mov       cx,1                ; Wait between 55.5 and 111ms for
      call      SetupForWait        ;   next character.
@@:
      DelayIn                       ; Get current status.
      test      al,LS_DR            ; Is there a character in Receive Buff?
      jnz       short @f            ; Yes! Go and read it.

      call      IsWaitOver          ; No, determine if we've timed out.
      jnc       short @b            ; Haven't timed out; keep looking.
      jmp       rsm_notMZ

@@:
      address   RXB LSR             ; Get address of Receive Buffer.
      DelayIn                       ; Get character that was sent to us.
      mov       [si], al
      inc       si
      address   LSR RXB
      pop       cx
      sub       cx, 1
      jnz       rsm_get_byte2

      mov       byte ptr [si], 0    ; add device id terminated null
      mov       bx, MS_MOUSE + SERIAL_MOUSE_WITH_WHEEL
      jmp       short rsm_leave     ; We still have a standard serial mouse.

rsm_notMZ:
      pop       cx
rsm_notLT:
      mov       bx,MS_MOUSE + SERIAL_MOUSE ; We didn't get the '3' after the 'M'
      jmp       short rsm_leave     ; We still have a standard serial mouse.

check_for_b:
      cmp       al,bh               ; Is it a B?
      jne       rsm_next_char

      mov       bx,MS_BALLPOINT + SERIAL_MOUSE ; We've found a BallPoint Mouse
      jmp       short rsm_leave

rsm_next_char:
      address   LSR RXB             ; Oh well. Get address of LSR again.
      dec       si                  ; Have we read 5 chars yet?
      jnz       rsm_getchar         ; Nope, we'll give him another try.

;
; We've read many characters - No a single 'M' or 'B' in the lot.
;

      mov       bx,NO_MOUSE

rsm_leave:
      pop       dx                  ; Get address of IER.
      pop       ax                  ; Get old value of IER.
      DelayOut                      ; Restore IER.

      pop       es                  ; Restore environment.
      assume    es:nothing
      pop       di
      pop       si
      pop       dx
      mov       ax,bx               ; Set return value.
      ret

ResetSerialMouse        ENDP


;++
;
; VOID
; SetupForWait (
;    USHORT WaitTime
;    )
;
; Routine Description:
;
;    This procedure accepts the number of milliseconds that we will want
;    to delay for and will set things up for the wait.
;
; Arguments:
;
;    (CX) = Number of clock ticks to wait for.
;
; Return Value:
;
;    None.
;
;--

SetupForWait    PROC    NEAR

      push      ax                  ; Do your saving !
      push      es

      xor       ax,ax
      mov       es,ax               ; Point to 40:6C = 0:46C

      cli
      mov       ax,es:[LW_ClockTickCount+2]
      mov       [DWFinalCount+2],ax       ; Save ending time (HiWord)
      mov       ax,es:[LW_ClockTickCount] ; Get tick count in AX.
      sti

      add       ax,cx               ; [Current + delay] = delay ends.
      mov       [DWFinalCount],ax   ; Save ending time (LoWord)
      jnc       SFW_End

      inc       [DWFinalCount+2]

SFW_End:
      pop       es                  ; Restore now !
      pop       ax

      ret

SetupForWait    ENDP


;++
;
; BOOLEAN
; IsWaitOver (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure accepts the current time and the ending time and
;    return and indication of whether the current time is past
;    the ending time.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    carry clear     Current time is not past ending time
;    carry set       Current time is past ending time
;
;--

IsWaitOver PROC NEAR

if 0
      push      ax                            ; Preserve AX
      push      es                            ; Preserve ES
      xor       ax,ax
      mov       es,ax                         ; Point to 40:6C = 0:46C

      cli
      mov       ax,es:[LW_ClockTickCount]
      mov       [DWCurrCount],ax              ; Save current time (LoWord)
      mov       ax,es:[LW_ClockTickCount+2]   ; Get tick count in AX.
      sti

      cmp       [DWFinalCount+2],ax           ; Compare HiWords
      ja        WaitNotOver                   ; Carry will be clear if wait
                                              ;   is not over.
      mov       ax,es:[LW_ClockTickCount]     ; Compare Lowords
      cmp       [DWFinalCount],ax             ; This will set CY accordingly

WaitNotOver:
      pop       es                            ; Restore ES
      pop       ax                            ; Restore AX
      ret

else

      push      ax                            ; Preserve AX
      push      es                            ; Preserve ES
      xor       ax,ax
      mov       es,ax                         ; Point to 40:6C = 0:46C

      cli
      mov       ax,es:[LW_ClockTickCount]
      mov       [DWCurrCount],ax              ; Save current time (LoWord)
      mov       ax,es:[LW_ClockTickCount+2]   ; Get tick count in AX.
      sti

      cmp       [DWFinalCount+2],ax           ; Compare HiWords
      jb        WaitExit                      ; Time is up

      jne       WaitRollCheck                 ; If not equal check for

WaitLowCheck:
      mov       ax,[DWCurrCount]              ; Compare Lowords
      cmp       [DWFinalCount],ax             ; This will set CY accordingly

WaitExit:
      pop       es                            ; Restore ES
      pop       ax                            ; Restore AX
      ret


WaitRollCheck:

; If the current time is less than the wait time we must check for
; roll over.  There are 18.2 * 60 * 60 * 24 or 0x1800b0 clock ticks in
; a day.  At midnight the counter rolls over to zero.

      cmp       ax,0
      jne       WaitExit                      ; If current HiWord is not 0,
                                              ;  no roll over.  Exit with
                                              ;  carry clear.

      cmp       [DWFinalCount+2],18h          ; Is Final HiWord 0x18
      je        short @f                      ; Yes, check LoWord for wrap.
      clc                                     ; No, no roll over.  Exit with
                                              ;  carry clear.
      jmp       WaitExit

@@:
      mov       ax,[DWFinalCount]             ; Get final LoWord
      sub       ax, 0b0h                      ; Check for wrap
      jb        WaitExit                      ; No, no roll over.  Exit with
                                              ;  cary set

; At this point we have determined that we have wrapped and that the
; ending time is into the next day.  Update the ending time

      mov       [DWFinalCount],ax             ; Set final LoWord
      xor       ax,ax
      mov       [DWFinalCount+2],ax           ; Zero final HiWord
      jmp       WaitLowCheck                  ; Check LoWord

endif

IsWaitOver ENDP


;++
;
; USHORT
; TestForLogitechSerial (
;    VOID
;    )
;
; Routine Description:
;
;    This procedure will detect the presence of a Logitech Series C
;    serial mouse is present
;
; Arguments:
;
;    (edx) = Port Address
;
; Return Value:
;
;    (ax) = Mouse ID.
;
;--


TestForLogitechSerial PROC NEAR

      push      di
      push      bx
      sub       sp, 10
      mov       bx, sp
      mov       word ptr [bx], 60h     ; baud = 1200
      mov       word ptr [bx + 2], 30h ; baud = 2400
      mov       word ptr [bx + 4], 18h ; baud = 4800
      mov       word ptr [bx + 6], 0ch ; baud = 9600
      mov       word ptr [bx + 8], 0

;
; Power up the C series mouse.
;
; Set both DTR and RTS to an active state
; If DTR and RTS are already on, the power is on for at least 500ms
; due to the MM serial mouse detection.
;

      address   MCR RXB             ; Get address of Modem Control Reg.
      DelayIn                       ; Get modem control byte

      and       al, MC_DTR + MC_RTS ; Check DTR and RTS
      cmp       al, MC_DTR + MC_RTS
      je        short @f            ; the lines are high already

      mov       al, MC_DTR + MC_RTS ; Set DTR and RTS to an active state
      DelayOut                      ; and ...

      mov       cx,9                ; wait for 1/2 second to pwrup mouse
      call      SetupForWait        ; Set up BX:CX and ES:DI properly for
      assume    es:nothing          ; upcoming delay loop.
                                    ; ask for current baud rate
lt_waitloop1:
      call      IsWaitOver          ; Determine if we've delayed enough.
      jnc       short lt_waitloop1

@@:
;
; Set the line control register to a format that the mouse can
; understand (see below: the line is set after the report rate).
;

      address   LCR  MCR            ; Get address of Line Control Reg.
      mov       al,LC_BITS8 + LC_STOP1 + LC_PODD
      DelayOut


;
; Cycle through the different baud rates to detect the mouse.
;

      mov       di, 0
      address   RXB LCR

Tfs_Next_Baud:
      mov       cx, [bx + di]
      cmp       cx, 0
      je        Tfs110              ; Reach the end of table

      call      SetBaudRate         ; Set baud rate

;
; Put the mouse in prompt mode.
;

      mov       cl, 'D'
      call      CSerWriteChar


;
; Set the MM protocol. This way we get the mouse to talk to us in a
; specific format. This avoids receiving errors from the line
; register.
;

      mov       cl, 'S'
      call      CSerWriteChar

      address   LCR  RXB            ; Get address of Line Control Reg.
      mov       al,LC_BITS8 + LC_STOP1 + LC_PODD
      DelayOut


;
; Try to get the status byte.
;

      address   RXB LCR
      mov       cl, 's'
      call      CSerWriteChar

;
; Read back the status character.
;

      mov       cx,2                 ; Wait at least 55.5 ms for response.
      call      SetupForWait
      assume    es:nothing
      address   LSR RXB

lt_waitloop2:                       ; (dx) = LSR reg
      DelayIn
      test      al, LS_DR           ; Is receiving buffer full?
      jnz       short @f            ; Yes, go read it.

lt_waitloop21:                      ; (dx) = LSR reg
      call      IsWaitOver
      jnc       short lt_waitloop2

      address   RXB LSR
      jmp       short Tfs50

@@:
      address   RXB LSR
      DelayIn
      cmp       al, 04fh            ; al = 4Fh means command understood
      je        short Tfs100

      address   LSR RXB
      jmp       short lt_waitloop21

Tfs50:
      add       di, 2
      jmp       Tfs_Next_Baud

Tfs100:

;
; Found the C series mouse.  Put the mouse back in a default mode.
; The protocol is already set.
;

;
; Set to default baud rate 1200
;

      mov       cl, '*'
      call      CSerWriteChar
      mov       cl, 'n'
      call      CSerWriteChar

;
; Wait for TX buffer empty
;

      mov       cx, 1
      call      SetupForWait
      address   LSR RXB
@@:
      DelayIn
      and       al, LS_THRE + LS_TSRE
      cmp       al, LS_THRE + LS_TSRE
      je        short @f            ; Wait for TX buffer empty
      call      IsWaitOver
      jnc       short @b

@@:
      address   RXB LSR
      mov       cx, 60h             ; Set baud rate to 1200
      call      SetBaudRate

;
; Set mouse to default report rate
;

      mov       cl, 'N'
      call      CSerWriteChar

      mov       ax,LT_MOUSE + SERIAL_MOUSE
      jmp       short lt_leave

Tfs110:
      mov       ax,NO_MOUSE

lt_leave:
      add       sp, 10              ; clear stack
      pop       bx
      pop       di
      ret

TestForLogitechSerial ENDP


;++
;
; VOID
; SetBaudRate (
;    USHORT Port,
;    USHORT BaudRate
;    )
;
; Routine Description:
;
;    This procedure will set up the given COM port so that it can talk to
;    a Logitech C series serial mouse.
;
; Arguments:
;
;    (DX) = COM Base address of COM port to set up.
;    (CX) = Baud Rate
;
; Return Value:
;
;    None.
;
;--

SetBaudRate PROC    NEAR
        push  dx
        address LCR RXB         ; Get address of Line Control Reg.
        DelayIn
        or      al,LC_DLAB      ; Set up to access divisor latches.
        DelayOut

        address LATMSB  LCR     ; Get address of high word of divisor
        mov     al, ch          ; latch and set it with value for
        DelayOut                ; specified baud.
        address LATLSB LATMSB   ; Get address of low word of divisor
        mov     al, cl          ; latch and set it with value for
        DelayOut                ; specified baud.

        address LCR LATLSB      ; Get address of Line Control Reg.
        DelayIn
        and     al, NOT LC_DLAB ; Disable access divisor latches.
        DelayOut

        mov   cx, 1
        call  SetupForWait
@@:
        call  IsWaitOver
        jnc   short @b

        pop   dx
        ret

SetBaudRate ENDP


;++
;
; VOID
; CSerWriteChar (
;    USHORT Port,
;    UCHAR Command
;    )
;
; Routine Description:
;
;    This procedure will write a char/command to logitech C series mouse.
;
; Arguments:
;
;    (DX) = COM Base address of COM port to set up.
;    (CL) = Command
;
; Return Value:
;
;    None.
;
;--

CserWriteChar   proc    near

      push      cx
      mov       cx, 1
      call      SetupForWait
      address   LSR RXB
@@:
      DelayIn
      and       al, LS_THRE + LS_TSRE
      cmp       al, LS_THRE + LS_TSRE
      je        short @f            ; Wait for TX buffer empty

      call      IsWaitOver
      jnc       short @b

@@:
      address   TXB LSR
      pop       ax                  ; Send command
      DelayOut
      ret
CserWriteChar   endp

if 0


;++
;
; VOID
; FlushReceiveBuffer (
;    USHORT Port
;    )
;
; Routine Description:
;
;    This procedure will flush receive buffer or until time out.
;
; Arguments:
;
;    (DX) = COM Base address of COM port to set up.
;
; Return Value:
;
;    None.
;
;--

FlushReceiveBuffer      proc    near

      mov       cx, 5
      call      SetupForWait
@@:
      address   LSR RXB
      DelayIn
      test      al, LS_DR
      jz        short @f

      address   RXB LSR
      DelayIn
      call      IsWaitOver
      jnc       short @b

      ret
@@:
      address   RXB LSR
      ret
FlushReceiveBuffer      endp

endif
_TEXT   ends

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pccard.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pccard.h

Abstract:

    This module contains the C code to set up PcCard (pcmcia, cardbus)
    configuration data.

Author:

    Neil Sandlin (neilsa) 16-Dec-1998

Revision History:

--*/

#define PCCARD_POSSIBLE_IRQS 0xCEB8                

//
// PIC hardware
//
#define PIC1_IMR    0x21
#define PIC2_IMR    0xa1
#define PIC1_OCW3   0x20
#define PIC2_OCW3   0xa0
#define PIC_RD_IR   0x0a
#define SYSCTRL_B   0x61

//
// Internal defs
//

#define DEVTYPE_GENERIC_PCIC 0
#define DEVTYPE_GENERIC_CARDBUS 1
#define DEVTYPE_CL_PD6832   2
#define DEVTYPE_CL_PD6834   3
#define DEVTYPE_CL_PD6833   4
#define DEVTYPE_TI_PCI1130  5
#define DEVTYPE_TI_PCI1131  6
#define DEVTYPE_TI_PCI1031  7


#define BCTRL_CL_CSCIRQROUTING_ENABLE   0x0800
#define CDGC_SW_DET_INT                 0x20

#define CFGSPACE_VENDOR_ID              0x00
#define CFGSPACE_DEVICE_ID              0x02
#define CFGSPACE_COMMAND                0x04
#define CFGSPACE_HEADER_TYPE            0x0e
#define CFGSPACE_SECONDARY_BUS          0x19
#define CFGSPACE_SUBORDINATE_BUS        0x1a
#define CFGSPACE_BRIDGE_CTRL            0x3e
#define CFGSPACE_LEGACY_MODE_BASE_ADDR  0x44
#define CFGSPACE_CL_CFGMISC1            0x98
#define CFGSPACE_TI_DEV_CTRL            0x92

#define CL_CFGMISC1_ISACSC              0x02
#define CSCFG_CD_ENABLE                 0x08

#define DEVCTRL_INTMODE_COMPAQ          0x04
#define DEVCTRL_INTMODE_MASK            0x06

#define EXCAREG_IDREV                   0x00
#define EXCAREG_INT_GENCTRL             0x03
#define EXCAREG_CARD_STATUS             0x04
#define EXCAREG_CSC_CFG                 0x05
#define EXCAREG_CARDDET_GENCTRL         0x16

#define IGC_PCCARD_RESETLO              0x40

#define PCIC_REVISION                   0x82
#define PCIC_REVISION2                  0x83
#define PCIC_REVISION3                  0x84


#define PCI_TYPE1_ADDR_PORT     ((PULONG) 0xCF8)
#define PCI_TYPE1_DATA_PORT     0xCFC
#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8

#define PCI_BRIDGE_TYPE                 0x01
#define PCI_CARDBUS_BRIDGE_TYPE         0x02

typedef struct _PCI_TYPE1_CFG_BITS {
    union {
        struct {
            ULONG   Reserved1:2;
            ULONG   RegisterNumber:6;
            ULONG   FunctionNumber:3;
            ULONG   DeviceNumber:5;
            ULONG   BusNumber:8;
            ULONG   Reserved2:7;
            ULONG   Enable:1;
        } bits;

        ULONG   AsULONG;
    } u;
} PCI_TYPE1_CFG_BITS, *PPCI_TYPE1_CFG_BITS;


typedef struct _PCCARD_INFORMATION {
    PCI_TYPE1_CFG_BITS PciCfg1;
    ULONG  DeviceId;
    UCHAR  Flags;
    UCHAR  ErrorCode;
    UCHAR  bDevType;
    UCHAR  Reserved;
    USHORT IoBase;
    USHORT wValidIRQs;
    UCHAR abIRQMap[16];
} PCCARD_INFORMATION, *PPCCARD_INFORMATION;

typedef struct _CARDBUS_BRIDGE_DEVTYPE {
    ULONG DeviceId;
    UCHAR bDevType;
} CARDBUS_BRIDGE_DEVTYPE, *PCARDBUS_BRIDGE_DEVTYPE;

//
// Prototypes
//


USHORT
DetectIRQMap(
    PPCCARD_INFORMATION pa
    );

USHORT
GetPICIRR(
    VOID
    );
    
USHORT
ToggleIRQLine(
    PPCCARD_INFORMATION pa,
    UCHAR bIRQ
    );

UCHAR
PcicReadSocket(
    PPCCARD_INFORMATION pa,
    USHORT Offset
    );
    
VOID
PcicWriteSocket(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    UCHAR value
    );

VOID
GetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID Buffer,
    USHORT Length
    );
    
VOID
SetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID Buffer,
    USHORT Length
    );

VOID
Clear_IR_Bits(
    USHORT BitMask
    );    

VOID
GetPCIType1Data(
    ULONG address,
    USHORT IoOffset,
    PVOID Buffer,
    USHORT Size    
    );

VOID
SetPCIType1Data(
    ULONG address,
    USHORT IoOffset,
    PVOID Buffer,
    USHORT Size    
    );

VOID
TimeOut(
    USHORT Ticks
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\ntmisc.h ===
/*++

Copyright (c) 1989-1993  Microsoft Corporation

Module Name:

    ntmisc.h

Abstract:

    This module contains the misc. definitions in \nt\public\sdk\inc
    directory.  Note, we created this file because ntdetect uses 16 bit
    compiler and various new C compiler switches/pragamas are not recognized
    by the 16 bit C compiler.

Author:

    Shie-Lin Tzong (shielint) 11-Nov-1992


Revision History:


--*/
//
// PHYSICAL_ADDRESS
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Note all the definitions defined below are used to make compiler shut up.
// Ntdetect.com does not rely on the correctness of the structures.
//

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY far *Flink;
   struct _LIST_ENTRY far *Blink;
} LIST_ENTRY, far *PLIST_ENTRY;

#define PTIME_FIELDS    PVOID
#define KPROCESSOR_STATE ULONG
#define WCHAR USHORT

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pccardc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    pccardc.c

Abstract:

    This module contains the C code to set up PcCard (pcmcia, cardbus)
    configuration data.

Author:

    Neil Sandlin (neilsa) 16-Dec-1998
       (DetectIRQMap, ToggleIRQLine were copied from win9x)

Revision History:

--*/

#include "hwdetect.h"
#include "pccard.h"
#include <string.h>

extern UCHAR DisablePccardIrqScan;
extern BOOLEAN SystemHas8259;
extern BOOLEAN SystemHas8253;

CARDBUS_BRIDGE_DEVTYPE CBTable[] = {
        {0x11101013, DEVTYPE_CL_PD6832},
        {0x11121013, DEVTYPE_CL_PD6834},
        {0x11111013, DEVTYPE_CL_PD6833},
        {0xAC12104C, DEVTYPE_TI_PCI1130},
        {0xAC15104C, DEVTYPE_TI_PCI1131},
        {0xAC13104C, DEVTYPE_TI_PCI1031},
        {0,0}};
        


FPFWCONFIGURATION_COMPONENT_DATA ControllerList = NULL;

#define LEGACY_BASE_LIST_SIZE 10
USHORT LegacyBaseList[LEGACY_BASE_LIST_SIZE] = {0};
USHORT LegacyBaseListCount = 0;



VOID
SetPcCardConfigurationData(
    PPCCARD_INFORMATION PcCardInfo
    )
/*++

Routine Description:

    This routine creates a structure containing the result of the
    irq detection, and links it onto our running list. This list
    eventually will show up in the registry under hardware
    descriptions.

Arguments:

    PcCardInfo - Structure containing the results of detection

Returns:

    None.

--*/
{
    FPFWCONFIGURATION_COMPONENT_DATA CurrentEntry;
    static FPFWCONFIGURATION_COMPONENT_DATA PreviousEntry = NULL;
    FPFWCONFIGURATION_COMPONENT Component;
    FPHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CHAR Identifier[32];
    FPCHAR IdentifierString;
    USHORT Length;       
    CM_PCCARD_DEVICE_DATA far *PcCardData;
    
    CurrentEntry = (FPFWCONFIGURATION_COMPONENT_DATA)HwAllocateHeap (
                            sizeof(FWCONFIGURATION_COMPONENT_DATA), TRUE);
    if (!ControllerList) {
        ControllerList = CurrentEntry;
    }
    Component = &CurrentEntry->ComponentEntry;
    
    Component->Class = ControllerClass;
    Component->Type = OtherController;

    strcpy (Identifier, "PcCardController");
    Length = strlen(Identifier) + 1;
    IdentifierString = (FPCHAR)HwAllocateHeap(Length, FALSE);
    _fstrcpy(IdentifierString, Identifier);        

    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;
    
    Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) + sizeof(CM_PCCARD_DEVICE_DATA);
    DescriptorList = (FPHWRESOURCE_DESCRIPTOR_LIST)HwAllocateHeap(
                                Length,
                                TRUE);
                                
    CurrentEntry->ConfigurationData = DescriptorList;
    Component->ConfigurationDataLength = Length;
    
    DescriptorList->Count = 1;
    DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                                            sizeof(CM_PCCARD_DEVICE_DATA);
                                            
    PcCardData = (CM_PCCARD_DEVICE_DATA far *)(DescriptorList + 1);
    PcCardData->Flags             = PcCardInfo->Flags;
    PcCardData->ErrorCode         = PcCardInfo->ErrorCode;
    PcCardData->DeviceId          = PcCardInfo->DeviceId;
    PcCardData->LegacyBaseAddress = (ULONG) PcCardInfo->IoBase;

    if (PcCardInfo->Flags & PCCARD_DEVICE_PCI) {
        PcCardData->BusData = PcCardInfo->PciCfg1.u.bits.BusNumber |
                              PcCardInfo->PciCfg1.u.bits.DeviceNumber << 8 |
                              PcCardInfo->PciCfg1.u.bits.FunctionNumber << 16;
    }
    
    _fmemcpy(PcCardData->IRQMap, PcCardInfo->abIRQMap, 16);
    
    if (PreviousEntry) {
        PreviousEntry->Sibling = CurrentEntry;
    }
    PreviousEntry = CurrentEntry;
}


BOOLEAN
IsOnLegacyBaseList(
    USHORT IoBase
    )
/*++

Routine Description:

    This routine runs our list of legacy base addresses to see if we
    have looked at the address before.

Arguments:

    IoBase = base address to map

Returns:

    TRUE if the base address is already on the list

--*/
{
    USHORT i;

    for (i = 0; i<LegacyBaseListCount; i++) {
        if (IoBase == LegacyBaseList[i]) {
            return TRUE;
        }
    }
    return FALSE;
}    


BOOLEAN
SetLegacyBaseList(
    USHORT IoBase
    )
/*++

Routine Description:

    This routine remembers the legacy base addresses that we have looked
    at so far so we don't keep mapping the same address.

    NOTE: We are using a DUMB mechanism that only builds the list in a
    fixed array. We could write some generic code which creates
    a linked list, but since the heap routines in ntdetect are also
    dumb, it makes it not possible to free the list. It's just not worth 
    it.
    
Arguments:

    IoBase = base address to map

Returns:

    TRUE if the base address is unique to this point
    FALSE if the base address already exists on the list

--*/
{
    
    if (IsOnLegacyBaseList(IoBase)) {
        return FALSE;
    }

    if (LegacyBaseListCount < LEGACY_BASE_LIST_SIZE) {
        LegacyBaseList[LegacyBaseListCount++] = IoBase;    
    }
    // note, we return true even if we overflow the list
    return TRUE;
}    


VOID
MapPcCardController(
    PPCCARD_INFORMATION PcCardInfo
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PcCard
    controllers.

Arguments:

    PcCardInfo - Structure defining the device to run detection on

Returns:

    None.

--*/
{
    USHORT wDetected;
    USHORT i;

    PcCardInfo->ErrorCode = 0;
    for (i=0; i<16; i++) {
        PcCardInfo->abIRQMap[i]=0;
    }                    
        
    if (!PcCardInfo->IoBase) {
    
        PcCardInfo->Flags |= PCCARD_MAP_ERROR;
        PcCardInfo->ErrorCode = PCCARD_NO_LEGACY_BASE;
        
    } else if (!SetLegacyBaseList(PcCardInfo->IoBase)) {
    
        PcCardInfo->Flags |= PCCARD_MAP_ERROR;
        PcCardInfo->ErrorCode = PCCARD_DUP_LEGACY_BASE;
        
    } 
        
    if (!(PcCardInfo->Flags & PCCARD_MAP_ERROR)) {
        PcCardInfo->wValidIRQs = PCCARD_POSSIBLE_IRQS;
        
#if DBG    
        BlPrint("Going to detect...\n");
#endif        
        //
        // Do the IRQ detection
        //
        wDetected = DetectIRQMap(PcCardInfo);
#if DBG    
        BlPrint("Detect IRQ Map returns %x on iobase %x\n", wDetected, PcCardInfo->IoBase);
#endif        
    
        if (!wDetected) {
            PcCardInfo->ErrorCode = PCCARD_MAP_ZERO;
        }
    }
    
#if DBG    
    if (PcCardInfo->Flags & PCCARD_MAP_ERROR) {
        BlPrint("Error mapping device, code=%x\n", PcCardInfo->ErrorCode);
    }
#endif
    
    //
    // Report the results
    //
    SetPcCardConfigurationData(PcCardInfo);
}    
    

VOID
LookForPciCardBusBridges(
    USHORT BusStart,
    USHORT BusEnd,
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PCI-based
    cardbus controllers.

Arguments:

    Bus = PCI Bus number to scan

Returns:

    None.

--*/
{
    PCCARD_INFORMATION PcCardInfo = {0};
    USHORT Device, Function;
    UCHAR HeaderType;
    UCHAR SecBus, SubBus;
    USHORT VendorId;
    USHORT DeviceId;
    ULONG LegacyBaseAddress;
    USHORT i;
    USHORT Bus;

#if DBG            
    BlPrint("LookForPciCardBusBridges %x-%x\n", BusStart, BusEnd);
#endif            

    for (Bus = BusStart; Bus <= BusEnd; Bus++) {

        PcCardInfo.PciCfg1.u.AsULONG = 0;
        PcCardInfo.PciCfg1.u.bits.BusNumber = Bus;
        PcCardInfo.PciCfg1.u.bits.Enable = TRUE;        
        
        for (Device = 0; Device < PCI_MAX_DEVICES; Device++) {
            PcCardInfo.PciCfg1.u.bits.DeviceNumber = Device;

            for (Function = 0; Function < PCI_MAX_FUNCTION; Function++) {
                PcCardInfo.PciCfg1.u.bits.FunctionNumber = Function;
                
                VendorId = 0xffff;
                GetPciConfigSpace(&PcCardInfo, CFGSPACE_VENDOR_ID, &VendorId, sizeof(VendorId));
    
                if ((VendorId == 0xffff) || (VendorId == 0)) {
                    if (Function == 0) {
                        break;
                    } else {                        
                        continue;
                    }                        
                }                    

                GetPciConfigSpace(&PcCardInfo, CFGSPACE_DEVICE_ID, &DeviceId, sizeof(DeviceId));
                GetPciConfigSpace(&PcCardInfo, CFGSPACE_HEADER_TYPE, &HeaderType, sizeof(HeaderType));
                
                switch(HeaderType & 0x7f) {
                case PCI_CARDBUS_BRIDGE_TYPE:
                
#if DBG            
                    BlPrint("%x.%x.%x : DeviceID = %lx (CardBus Bridge)\n", Bus, Device, Function, DeviceId);
#endif            
                    PcCardInfo.DeviceId = (ULONG) (VendorId << 16) | DeviceId;
                    PcCardInfo.Flags = PCCARD_DEVICE_PCI;
                    //
                    // See if this is a special cased controller
                    //
                    PcCardInfo.bDevType = DEVTYPE_GENERIC_CARDBUS;
                    i = 0;
                    while (CBTable[i].DeviceId != 0) {
                        if (DeviceId == CBTable[i].DeviceId) {
                            PcCardInfo.bDevType = CBTable[i].bDevType;
                            break;
                        }
                        i++;
                    }
            
                    GetPciConfigSpace(&PcCardInfo, CFGSPACE_LEGACY_MODE_BASE_ADDR, &LegacyBaseAddress, 4);
                    PcCardInfo.IoBase = (USHORT) (LegacyBaseAddress & ~1);
                    
                    MapPcCardController(&PcCardInfo);
                    break;

                case PCI_BRIDGE_TYPE:
#if DBG            
                    BlPrint("%x.%x.%x : DeviceID = %lx (Pci-Pci Bridge)\n", Bus, Device, Function, DeviceId);
#endif            
                    GetPciConfigSpace(&PcCardInfo, CFGSPACE_SECONDARY_BUS, &SecBus, sizeof(SecBus));
                    GetPciConfigSpace(&PcCardInfo, CFGSPACE_SUBORDINATE_BUS, &SubBus, sizeof(SubBus));
                    
                    if ((SecBus <= Bus) || (SubBus <= Bus) || (SubBus < SecBus)) {
                        break;
                    }

                    //
                    // Be conservative on stack space, only look one level deep
                    //
                    if (Bus > 0) {
                        break;
                    }
                    
                    LookForPciCardBusBridges(SecBus, SubBus);                    
                    break;
                }
            }
        }
    }        
}


VOID
LookForPcicControllers(
    VOID
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PCIC
    controllers.

Arguments:

    None.

Returns:

    None.

--*/
{
    PCCARD_INFORMATION PcCardInfo = {0};
    USHORT IoBase;
    UCHAR id;

    for (IoBase = 0x3e0; IoBase < 0x3e6; IoBase+=2) {
        if (IsOnLegacyBaseList(IoBase)) {
            continue;
        }
        PcCardInfo.Flags = 0;
        PcCardInfo.IoBase = IoBase;
        PcCardInfo.bDevType = DEVTYPE_GENERIC_PCIC;
        
        id = PcicReadSocket(&PcCardInfo, EXCAREG_IDREV);
        switch (id) {
        case PCIC_REVISION:
        case PCIC_REVISION2:
        case PCIC_REVISION3:        

#if DBG            
            BlPrint("Pcic Controller at base %x, rev(%x)\n", IoBase, id);
#endif            
            MapPcCardController(&PcCardInfo);
            break;
#if DBG            
        default:
            BlPrint("Not mapping base %x, return is (%x)\n", IoBase, id);
#endif            
        }
    }
}



FPFWCONFIGURATION_COMPONENT_DATA
GetPcCardInformation(
    VOID
    )
/*++

Routine Description:

    This routine is the entry for doing ISA IRQ detection for PcCard
    controllers.

Arguments:

    None.

Returns:

    A pointer to a pccard component structure, if IRQ's were properly detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PCCARD_INFORMATION PcCardInfo = {0};
    UCHAR ErrorCode = 0;

    //
    // Check for things which would prevent us from attempting
    // the irq detection
    //

    if (DisablePccardIrqScan == 1) {               
        ErrorCode = PCCARD_SCAN_DISABLED;
        
    } else if (!SystemHas8259) {
        ErrorCode = PCCARD_NO_PIC;
        
    } else if (!SystemHas8253) {
        ErrorCode = PCCARD_NO_TIMER;
        
    }

    //
    // If things look ok so far, do the detection
    //
    if (!ErrorCode) {
#if DBG
        BlPrint("press any key to continue...\n");
        while ( !HwGetKey() ) ; // wait until key pressed to continue
        clrscrn();
        BlPrint("Looking for PcCard Controllers...\n");
#endif
        //
        // Look first for cardbus
        //
        LookForPciCardBusBridges(0,0);
        //
        // Now check for regular pcic devices
        //
        LookForPcicControllers();
    
#if DBG
        BlPrint("press any key to continue...\n");
        while ( !HwGetKey() ) ; // wait until key pressed to continue
#endif

        if (!ControllerList) {
            ErrorCode = PCCARD_NO_CONTROLLERS;
        }
    }

    if (ErrorCode) {
        //
        // Something when wrong, so write a single entry to
        // allow someone to see what the error was
        //
        PcCardInfo.Flags |= PCCARD_MAP_ERROR;
        PcCardInfo.ErrorCode = ErrorCode;
        SetPcCardConfigurationData(&PcCardInfo);
    }    

    return ControllerList;
}


USHORT
DetectIRQMap(
    PPCCARD_INFORMATION pa
    )
/*++

Routine Description:

    This routine detects the IRQ mapping of the specified cardbus controller.
    Note that the controller is in PCIC mode.

Arguments:

    pa -> ADAPTER structure

Returns:

    returns detected IRQ bit mask

--*/
{
    USHORT wRealIRQMask = 0;
    USHORT wData;
    UCHAR bData;

    BOOLEAN fTINMIBug = FALSE;

    UCHAR i;
    USHORT wIRQMask, wRealIRQ, w;

    if (pa->bDevType == DEVTYPE_CL_PD6832)
    {
        //enable CSC IRQ routing just for IRQ detection
        GetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
        wData |= BCTRL_CL_CSCIRQROUTING_ENABLE;
        SetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
    }
    else if ((pa->bDevType == DEVTYPE_CL_PD6834) ||
             (pa->bDevType == DEVTYPE_CL_PD6833))
    {
        //enable CSC IRQ routing just for IRQ detection
        GetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
        bData |= CL_CFGMISC1_ISACSC;
        SetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
    }
    else if ((pa->bDevType == DEVTYPE_TI_PCI1130) ||
             (pa->bDevType == DEVTYPE_TI_PCI1131) ||
             (pa->bDevType == DEVTYPE_TI_PCI1031))
    {
        GetPciConfigSpace(pa, CFGSPACE_TI_DEV_CTRL, &wData, sizeof(wData));
        if ((wData & DEVCTRL_INTMODE_MASK) == DEVCTRL_INTMODE_COMPAQ)
        {
            //
            // There is an errata on TI 1130, 1131 and 1031 in which if
            // the chip is programmed to use serial IRQ mode (i.e. COMPAQ
            // mode) and the SERIRQ pin is not pull up with a 1K resistor,
            // the SERIRQ line will rise too slowly after IRQ 15 is
            // deasserted so that it looks like NMI should be asserted.
            // This caused spurious NMI.  This is a hardware problem.
            // Unfortunately, there are a large number of machines with
            // this problem on the street already, so CBSS has to work
            // around the problem by temporarily disabling NMI before
            // doing ISA IRQ detection.
            //
            fTINMIBug = TRUE;
            _asm    in   al,SYSCTRL_B
            _asm    and  al,0x0f
            _asm    push ax
            //
            // Mask NMI
            //
            _asm    or   al,0x08
            _asm    out  SYSCTRL_B,al
        }
    }
    _asm pushf
    _asm cli                    //disable interrupt
    _asm in   al,PIC2_IMR       //save old IMRs
    _asm mov  ah,al
    _asm in   al,PIC1_IMR
    _asm push ax

    _asm mov  al,0xff           //mask all interrupt
    _asm out  PIC2_IMR,al
    _asm out  PIC1_IMR,al

    for (i = 0; i < 16; ++i)
    {
        w = (USHORT)(1 << i);
        if ((pa->wValidIRQs & w) &&
            ((wIRQMask = ToggleIRQLine(pa, i)) != 0))
        {
            _asm mov dx, wIRQMask
            _asm _emit 0x66
            _asm _emit 0x0f
            _asm _emit 0xbc
            _asm _emit 0xc2
            _asm mov wRealIRQ,ax
            pa->abIRQMap[wRealIRQ] = i;
            wRealIRQMask |= (USHORT)(1 << wRealIRQ);
        }
    }
    Clear_IR_Bits(wRealIRQMask);

    _asm pop  ax
    _asm out  PIC1_IMR,al
    _asm mov  al,ah
    _asm out  PIC2_IMR,al
    _asm popf

    if (fTINMIBug)
    {
        //
        // Restore NMI mask
        //
        _asm    pop  ax
        _asm    out  SYSCTRL_B,al
    }

    if (pa->bDevType == DEVTYPE_CL_PD6832)
    {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
        wData &= ~BCTRL_CL_CSCIRQROUTING_ENABLE;
        SetPciConfigSpace(pa, CFGSPACE_BRIDGE_CTRL, &wData, sizeof(wData));
    }
    else if ((pa->bDevType == DEVTYPE_CL_PD6834) ||
             (pa->bDevType == DEVTYPE_CL_PD6833))
    {
        //disable CSC IRQ routing (use PCI interrupt for CSC)
        GetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
        bData &= ~CL_CFGMISC1_ISACSC;
        SetPciConfigSpace(pa, CFGSPACE_CL_CFGMISC1, &bData, sizeof(bData));
    }

    return wRealIRQMask;
}       //DetectIRQMap



USHORT
ToggleIRQLine(
    PPCCARD_INFORMATION pa,
    UCHAR bIRQ
    )
/*++

Routine Description:

    This routine toggles the specified IRQ line from the adapter.

Arguments:

    pa -> ADAPTER structure
    bIRQ - IRQ line to toggle

Returns:

    returns the IRR mask from PIC

--*/
{
    UCHAR bOldIntCtrl, bOldIntCfg, bData;
    USHORT rc = 0, irr1, irr2, irr3;

    bOldIntCfg = PcicReadSocket(pa, EXCAREG_CSC_CFG);
    bOldIntCtrl = PcicReadSocket(pa, EXCAREG_INT_GENCTRL);

    //Set to a known state
    PcicWriteSocket(pa, EXCAREG_INT_GENCTRL, IGC_PCCARD_RESETLO);

    //Set irq number in interrupt control register and enable irq
    PcicWriteSocket(pa, EXCAREG_CSC_CFG, (UCHAR)((bIRQ << 4) | CSCFG_CD_ENABLE));

    //clear all pending interrupts
    bData = PcicReadSocket(pa, EXCAREG_CARD_STATUS);
    irr1 = GetPICIRR();

    if (PcicReadSocket(pa, EXCAREG_IDREV) != 0x82)
    {
        //This is not an A stepping part, try the undocumented interrupt
        //register.  If this fails the other routine will be tried.
        PcicWriteSocket(pa, EXCAREG_CARDDET_GENCTRL, CDGC_SW_DET_INT);
        irr2 = GetPICIRR();

        //reset pending interrupt
        bData = PcicReadSocket(pa, EXCAREG_CARD_STATUS);
        irr3 = GetPICIRR();
        rc = (USHORT)((irr1 ^ irr2) & (irr2 ^ irr3));
    }

    if (rc == 0)
    {
        //Generate interrupt by de-asserting IRQ line so the PIC can pull it
        //high
        PcicWriteSocket(pa, EXCAREG_CSC_CFG, 0);
        //if (pa->dwfAdapter & AF_TI_SERIALIRQ)
        //    TIReleaseSerialIRQ(pa, bIRQ);
        irr2 = GetPICIRR();

        //re-assert IRQ line
        PcicWriteSocket(pa, EXCAREG_CSC_CFG, (UCHAR)((bIRQ << 4) | CSCFG_CD_ENABLE));

        //reset pending interrupt
        bData = PcicReadSocket(pa, EXCAREG_CARD_STATUS);
        irr3 = GetPICIRR();
        rc = (USHORT)((irr1 ^ irr2) & (irr2 ^ irr3));
    }

    PcicWriteSocket(pa, EXCAREG_CSC_CFG, bOldIntCfg);
    PcicWriteSocket(pa, EXCAREG_INT_GENCTRL, bOldIntCtrl);

    return rc;
}       //ToggleIRQLine


/***LP  GetPICIRR - Read PIC IRR
 *
 *  ENTRY
 *      None
 *
 *  EXIT
 *      returns the IRR mask from PIC
 */

USHORT GetPICIRR(VOID)
{
    USHORT wData;

    //
    // Delay 2 usec before reading PIC because serial IRQ may be a bit slow.
    //
    TimeOut(4);

    _asm mov al,PIC_RD_IR
    _asm out PIC2_OCW3,al
    _asm in  al,PIC2_OCW3
    _asm mov ah,al

    _asm mov al,PIC_RD_IR
    _asm out PIC1_OCW3,al
    _asm in  al,PIC1_OCW3

    _asm mov  wData,ax

    return wData;
}       //GetPICIRR



UCHAR
PcicReadSocket(
    PPCCARD_INFORMATION pa,
    USHORT Reg
    )
{
    USHORT IoBase = pa->IoBase;
    UCHAR value;
    _asm {
      mov   dx, IoBase
      mov   ax, Reg
      out   dx, al
      inc   dx
      in    al, dx
      mov   value, al
      }
    return value;
}    
    
VOID
PcicWriteSocket(
    PPCCARD_INFORMATION pa,
    USHORT Reg,
    UCHAR value
    )
{
    USHORT IoBase = pa->IoBase;
    _asm {
      mov   dx, IoBase
      mov   ax, Reg
      out   dx, al
      inc   dx
      mov   al, value
      out   dx, al
      }
}    


UCHAR PCIDeref[4][4] = { {4,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };
    
VOID
SetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID pvBuffer,
    USHORT Length
    )
    
{
    USHORT                  IoSize;
    PUCHAR                  Buffer = (PUCHAR) pvBuffer;
    //
    // Read it
    //
    while (Length) {
        pa->PciCfg1.u.bits.RegisterNumber = Offset / sizeof(ULONG);

        IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];

        SetPCIType1Data (pa->PciCfg1.u.AsULONG,
                        (Offset % sizeof(ULONG)),
                         Buffer,
                         IoSize);

        Offset += IoSize;
        Buffer += IoSize;
        Length -= IoSize;
    }
}    



VOID
GetPciConfigSpace(
    PPCCARD_INFORMATION pa,
    USHORT Offset,
    PVOID pvBuffer,
    USHORT Length
    )
{
    USHORT                  IoSize;
    USHORT                  i;
    PUCHAR                  Buffer = (PUCHAR) pvBuffer;
    
    //
    // Zap input buffer
    //

    for (i=0; i < Length; i++) {
        Buffer[i] = 0xff;
    }

    //
    // Read it
    //
    while (Length) {
        pa->PciCfg1.u.bits.RegisterNumber = Offset / sizeof(ULONG);

        IoSize = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];

        GetPCIType1Data (pa->PciCfg1.u.AsULONG,
                        (Offset % sizeof(ULONG)),
                         Buffer,
                         IoSize);

        Offset += IoSize;
        Buffer += IoSize;
        Length -= IoSize;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pccarda.asm ===
title  "PcCard IRQ detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    pccarda.asm
;
; Abstract:
;
;    This module implements the assembly code necessary to support the
;    scanning of ISA IRQ's for cardbus controllers.
;
; Author:
;
;    Neil Sandlin (neilsa) 10-Dec-1991.
;    The "Clear_IR" routines were taken from win9x code (vpicd)
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
;--

        .xlist
include pccard.inc
        .list
        .386

_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'
_DATA   ENDS

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:NOTHING, SS:NOTHING
        

;++
;
;   clr_ir_int_proc
;
; Routine Description:
;
;    Interrupt handler for clearing IR bit.  Just EOIs the PICs.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--        
Clr_IR_Int      dw      0               ; Current int # being processed

        public  clr_ir_int_proc
clr_ir_int_proc proc far
        push    ax

        mov     ax, Clr_IR_Int
        cmp     ax, 8                   ; Q: is int on the master PIC?
        jb      CIP_eoi                 ;    Y: only eoi master PIC

        sub     ax, 8                   ; AL = int on slave PIC
        or      al, PIC_SPEC_EOI
        out     PIC_A0, al              ; EOI the specific interrupt

        mov     al, 2                   ; EOI the master PIC
CIP_eoi:
        or      al, PIC_SPEC_EOI
        out     PIC_20, al              ; EOI the specific interrupt

        mov     al, 0FFh                ; Mask all interrupts
        out     PIC_A1, al
        out     PIC_21, al
        pop     ax
        iret
clr_ir_int_proc endp


;++
;
;   clr_ir_enable_int
;
; Routine Description:
;
;
; Arguments:
;
;       EAX = interrupt to hook and enable.
;       Interrupts must be disabled on entry.
;
; Return Value:
;
;    None.
;
;--        

clr_ir_enable_int proc near
        push    bx
        push    esi
        ; Hook interrupt so it can be handled.

        mov     Clr_IR_Int, ax          ; Set current interrupt being processed
        cmp     ax, 8                   ; Q: is int on the master PIC?
        jb      CIEI_master             ;   Y: based at 8
        add     ax, 68h                 ;   N: based at 70h
        jmp     CIEI_vector
CIEI_master:
        add     ax, 8
CIEI_vector:
        mov     bx, ax
        shl     bx, 2                   ; IVT vector offset
        
        push    ds
        mov     ax, 0
        mov     ds, ax
        ASSUME  DS:NOTHING
        
        mov     si, offset clr_ir_int_proc
        xchg    word ptr [bx], si       ; LSW
        ror     esi, 16
        push    cs
        pop     si
        xchg    word ptr [bx+2], si     ; MSW
        ror     esi, 16                 ; ESI = old handler offset
        pop     ds
        ASSUME  DS:_DATA

        sti

        nop                             ; allow interrupt to occur
        nop
        nop

        cli

        ; UnHook interrupt.

        push    ds
        mov     ax, 0
        mov     ds, ax
        ASSUME  DS:NOTHING
        mov     word ptr [bx], si       ; Restore LSW
        ror     esi, 16
        mov     word ptr [bx+2], si     ; Restore MSW
        pop     ds
        ASSUME  DS:_DATA
        
        pop     esi
        pop     bx
        ret
clr_ir_enable_int endp


;++
;
;   _Clear_IR_Bits
;
; Routine Description:
;
;    This routine and its support routines were copied (and munged) from
;    win9x's vxd\vpicd\vpicserv.asm.
;
;    Clears the desired Interrupt Request bits in the PIC.
;    Interrupt must be masked at the PIC on entry.
;
; Arguments:
;
;       [ESP+4] = bit mask of bits to clear
;       Interrupts must be disabled on entry.
;
; Return Value:
;
;    None.
;
;--        

        public _Clear_IR_Bits
_Clear_IR_Bits proc near
        push    bp
        mov     bp, sp
BitMask equ     [bp+4]        

        push    eax
        push    ebx
        push    ecx
        push    edx

        mov     bx, BitMask             ; BX = mask to clear
        or      bx, bx                  ; Are there any bits to clear?
        jz      CIB_exit                ;  no, return

        pushfd
        cli
        in      al, PIC_A1
        mov     ah, al
        in      al, PIC_21
        push    eax
        mov     al, 0FFh
        out     PIC_A1, al

        ; Walk each bit from the lowest bit to highest on each controller.

        mov     ecx, 01h                ; CL = test mask
CIB_loop20:
        test    bl, cl
        jz      CIB_next20

        mov     al, cl
        not     al
        out     PIC_21, al              ; Unmask the specific interrupt

        bsf     eax, ecx
        call    clr_ir_enable_int       ; Hook interrupt and enable it

        mov     al, 0FFh                ; Mask all interrupts
        out     PIC_21, al
CIB_next20:
        shl     cl, 1
        jnz     CIB_loop20              ; Clear next bit

        ; Setup for second PIC.  Handle the second controller by setting
        ; up both PICs, since they are chained.

        mov     bl, bh                  ; BL = second PICs mask to clear
        mov     cl, 01h                 ; CL = test mask
CIB_loopA0:
        test    bl, cl
        jz      CIB_nextA0

        mov     al, 0FBh                ; Mask for chained master PIC
        out     PIC_21, al              ; Unmask the specific interrupt

        mov     al, cl
        not     al
        out     PIC_A1, al              ; Unmask the specific interrupt

        xchg    cl, ch
        bsf     eax, ecx
        call    clr_ir_enable_int       ; Hook interrupt and enable it
        xchg    cl, ch

        mov     al, 0FFh                ; Mask all interrupts
        out     PIC_A1, al
        out     PIC_21, al
CIB_nextA0:
        shl     cl, 1
        jnz     CIB_loopA0              ; Clear next bit

        pop     eax
        out     PIC_21, al
        mov     al, ah
        out     PIC_A1, al
        popfd

CIB_exit:
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax

        mov     sp, bp
        pop     bp        
        ret

_Clear_IR_Bits endp


;++
;
;   GetPCIType1Data
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--        
        public  _GetPCIType1Data
_GetPCIType1Data proc near
        push    bp
        mov     bp, sp      
        push    bx
        push    di
gpd_addr   equ    [bp+4]
gpd_offset equ    [bp+8]
gpd_buffer equ  [bp+10]
gpd_width equ   [bp+12]        

        mov     dx, PCI_TYPE1_ADDR_PORT
        mov     eax, gpd_addr
        out     dx, eax

        mov     bx, gpd_buffer        
        mov     dx, gpd_offset
        add     dx, PCI_TYPE1_DATA_PORT
        mov     di, gpd_width
        
        cmp     di, 1
        jnz     @f
        in      al, dx
        mov     [bx], al
        jmp     gpd_exit
@@:        
        cmp     di, 2
        jnz     @f
        in      ax, dx
        mov     [bx], al
        mov     [bx+1], ah
        jmp     gpd_exit
@@:        
        
        cmp     di, 4
        jnz     gpd_exit
        in      eax, dx
        mov     [bx], al
        mov     [bx+1], ah
        shr     eax, 16
        mov     [bx+2], al
        mov     [bx+3], ah

gpd_exit:        
        pop     di
        pop     bx
        mov     sp, bp
        pop     bp        
        ret
_GetPCIType1Data endp

;++
;
;   SetPCIType1Data
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;    None.
;
;--        
        public  _SetPCIType1Data
_SetPCIType1Data proc near
        push    bp
        mov     bp, sp      
        push    bx
        push    di
spd_addr   equ    [bp+4]
spd_offset equ    [bp+8]
spd_buffer equ  [bp+10]
spd_width equ   [bp+12]        

        mov     dx, PCI_TYPE1_ADDR_PORT
        mov     eax, spd_addr
        out     dx, eax

        mov     bx, spd_buffer        
        mov     dx, spd_offset
        add     dx, PCI_TYPE1_DATA_PORT
        mov     di, spd_width
        
        cmp     di, 1
        jnz     @f
        mov     al, [bx]
        out     dx, al
        jmp     spd_exit
@@:        
        cmp     di, 2
        jnz     @f
        mov     al, [bx]
        mov     ah, [bx+1]
        out     dx, ax
        jmp     spd_exit
@@:        
        
        cmp     di, 4
        jnz     spd_exit
        mov     al, [bx+2]
        mov     ah, [bx+3]
        shl     eax, 16
        mov     al, [bx]
        mov     ah, [bx+1]
        out     dx, eax

spd_exit:        
        pop     di
        pop     bx
        mov     sp, bp
        pop     bp        
        ret
_SetPCIType1Data endp

;++
;
;   TimeOut
;
; Routine Description:
;
;   This routine implements a stall for waiting on hardware. It uses the
;   PC timer hardware (8237). The caller needs to insure that this hardware
;   exists on the machine before calling this function.
;
;   The function will take as input the count, and decrement the count
;   matching the timer hardware's count. It returns when the count reaches
;   zero. The caller must insure that the clock is programmed at the
;   desired rate.
;
; Arguments:
;
;   Count - number of clock ticks to wait (approx 840ns per tick)
;
; Return Value:
;
;    None.
;
;--        
        public  _TimeOut
_TimeOut proc near

TMCTRL_LATCHCNT0 equ 0d2h
TIMERPORT_CONTROL equ 43h
TIMERPORT_CNT0    equ 40h

        push    bp
        mov     bp, sp      
        push    cx
        push    si
        push    di
        
to_count  equ    [bp+4]

        mov     dx, TIMERPORT_CONTROL
        mov     al, TMCTRL_LATCHCNT0
        out     dx, al

        mov     dx, TIMERPORT_CNT0
        in      al, dx
        mov     ah, al
        in      al, dx
        xchg    ah, al
        mov     si, ax
        xor     cx, cx

;       si = prevtime
;       cx = ExpireTime

timeloop:
        mov     dx, TIMERPORT_CONTROL
        mov     al, TMCTRL_LATCHCNT0
        out     dx, al
        mov     dx, TIMERPORT_CNT0
        in      al, dx
        mov     ah, al
        in      al, dx
        xchg    ah, al
        mov     di, ax

        cmp     ax, si
        jbe     @f
        ; wrapped
        neg     ax
        add     ax, si
        add     cx, ax        
        jmp     timeincr
@@:
        sub     si, ax
        add     cx, si
timeincr:
        mov     si, di
        cmp     cx, to_count
        jb      timeloop

        pop     di
        pop     si
        pop     cx
        mov     sp, bp
        pop     bp        
        ret
_TimeOut endp


_TEXT   ends


        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pcienum.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pcienum.h

Abstract:

    This module contains support routines for the Pci bus enumeration.

Author:

    Bassam Tabbara (bassamt) 05-Aug-2001


Environment:

    Real mode

--*/


#define PCI_ITERATOR_TO_BUS(i)          ((UCHAR)(((i) >> 8) & 0xFF))
#define PCI_ITERATOR_TO_DEVICE(i)       ((UCHAR)(((i) >> 3) & 0x1F))
#define PCI_ITERATOR_TO_FUNCTION(i)     ((UCHAR)((i) & 0x07))

#define PCI_TO_ITERATOR(b,d,f)          ((ULONG)(0x80000000 | ((b) << 8) | ((d) << 3) | (f)))
#define PCI_ITERATOR_TO_BUSDEVFUNC(i)   ((USHORT)(i & 0xFFFF))

//
// methods
//

ULONG PciReadConfig
(
    ULONG   nDevIt,
    ULONG   cbOffset,
    UCHAR * pbBuffer,
    ULONG   cbLength
);

ULONG PciWriteConfig
(
    ULONG   nDevIt,
    ULONG   cbOffset,
    UCHAR * pbBuffer,
    ULONG   cbLength
);

ULONG PciFindDevice
(
    USHORT   nVendorId,                                 // 0 = Wildcard
    USHORT   nDeviceId,                                 // 0 = Wildcard
    ULONG    nBegDevIt                                  // 0 = begin enumeration
);

BOOLEAN PciInit(PCI_REGISTRY_INFO *pPCIReg);

UCHAR PciBiosReadConfig
(
    ULONG   nDevIt,
    UCHAR   cbOffset,
    UCHAR * pbBuffer,
    ULONG   cbLength
);

ULONG PciBiosFindDevice
(
    USHORT   nVendorId,                                 // 0 = Wildcard
    USHORT   nDeviceId,                                 // 0 = Wildcard
    ULONG    nBegDevIt                                  // 0 = begin enumeration
);

#ifdef DBG
extern
VOID
ScanPCIViaBIOS(
    PPCI_REGISTRY_INFO pPciEntry
     );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pnpbios.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosp.h

Abstract:

    PnP BIOS/ISA  sepc related definitions

Author:

    Shie-Lin Tzong (shielint) April 12, 1995

Revision History:

--*/

//
// Pnp BIOS device node structure
//

typedef struct _PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} PNP_BIOS_DEVICE_NODE, far *FPPNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} PNP_BIOS_INSTALLATION_CHECK, far *FPPNP_BIOS_INSTALLATION_CHECK;

//
// PnP BIOS ROM definitions
//

#define PNP_BIOS_START            0xF0000
#define PNP_BIOS_END              0xFFFFF
#define PNP_BIOS_HEADER_INCREMENT 16

//
// PnP BIOS API function codes
//

#define PNP_BIOS_GET_NUMBER_DEVICE_NODES 0
#define PNP_BIOS_GET_DEVICE_NODE 1
#define PNP_BIOS_SET_DEVICE_NODE 2
#define PNP_BIOS_GET_EVENT 3
#define PNP_BIOS_SEND_MESSAGE 4
#define PNP_BIOS_GET_DOCK_INFORMATION 5
// Function 6 is reserved.
#define PNP_BIOS_SELECT_BOOT_DEVICE 7
#define PNP_BIOS_GET_BOOT_DEVICE 8
#define PNP_BIOS_SET_OLD_ISA_RESOURCES 9
#define PNP_BIOS_GET_OLD_ISA_RESOURCES 0xA
#define PNP_BIOS_GET_ISA_CONFIGURATION 0x40


//
// SMBIOS function codes
#define GET_DMI_INFORMATION 0x50
#define GET_DMI_STRUCTURE 0x51
#define SET_DMI_STRUCTURE 0x52
#define GET_DMI_STRUCTURE_CHANGE_INFO 0x53
#define DMI_CONTROL 0x54
#define GET_GPNV_INFORMATION 0x55
#define READ_GPNV_DATA 0x56
#define WRITE_GPNV_DATA 0x57


typedef USHORT ( far * ENTRY_POINT) (int Function, ...);

//
// Control Flags for Get_Device_Node
//

#define GET_CURRENT_CONFIGURATION 1
#define GET_NEXT_BOOT_CONFIGURATION 2


//
// SMBIOS definitions

typedef SMBIOS_EPS_HEADER far *FPSMBIOS_EPS_HEADER;
typedef SMBIOS_STRUCT_HEADER far *FPSMBIOS_STRUCT_HEADER;
typedef DMIBIOS_EPS_HEADER far *FPDMIBIOS_EPS_HEADER;

//
// We cannot accomodate more than this amount of SMBIOS data to be passed 
// from NTDETECT to NTOSKRNL. 
#define MAXSMBIOS20SIZE 0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pcienum.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    pcienum.c

Abstract:

    This module contains support routines for the Pci bus enumeration.

Author:

    Bassam Tabbara (bassamt) 05-Aug-2001


Environment:

    Real mode

--*/

#include "hwdetect.h"
typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);
typedef PVOID PDEVICE_OBJECT;
#include "pci.h"
#include "pcienum.h"
#include <string.h>


#define PCI_FIXED_HDR_LENGTH                16          // Through BIST

#define UnusedParameter(x)  (void)x

#define X86_FLAG_IF     0x0200

#define TURN_INTERRUPTS_OFF(_s_) \
    __asm { \
        __asm pushf  \
        __asm pop ax  \
        __asm mov _s_,ax \
        __asm cli \
    }

#define RESTORE_INTERRUPTS(_s_) \
    do { \
        if ((_s_) & X86_FLAG_IF) { \
            __asm sti \
        } \
    } while (0)

//////////////////////////////////////////////////////////// PCI Mechanism #0.
//
static ULONG PciReadInt32_0(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg) 
{
    UnusedParameter(nBus);
    UnusedParameter(nDev);
    UnusedParameter(nFun);
    UnusedParameter(nReg);
    return ~0u;
}

static VOID PciWriteInt32_0(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg,
    ULONG Data)
{
    UnusedParameter(nBus);
    UnusedParameter(nDev);
    UnusedParameter(nFun);
    UnusedParameter(nReg);
    UnusedParameter(Data);
    return;
}

//////////////////////////////////////////////////////////// PCI Mechanism #1.
//
static ULONG PciReadInt32_1(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg) 
{
    USHORT fl;
    ULONG data = 0;
    PCI_TYPE1_CFG_BITS cfg;
    cfg.u.bits.Reserved1 = 0;
    cfg.u.bits.RegisterNumber = nReg >> 2;
    cfg.u.bits.FunctionNumber = nFun;
    cfg.u.bits.DeviceNumber = nDev;
    cfg.u.bits.BusNumber = nBus;
    cfg.u.bits.Reserved2 = 0;
    cfg.u.bits.Enable = 1;

    TURN_INTERRUPTS_OFF(fl);

    WRITE_PORT_ULONG((PUSHORT)PCI_TYPE1_ADDR_PORT, (ULONG)cfg.u.AsULONG); // Select
    data = READ_PORT_ULONG((PUSHORT)PCI_TYPE1_DATA_PORT);       // Fetch

    RESTORE_INTERRUPTS(fl);

    return data;
}

static VOID PciWriteInt32_1(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg,
    ULONG Data)
{
    USHORT fl;
    PCI_TYPE1_CFG_BITS cfg;
    cfg.u.bits.Reserved1 = 0;
    cfg.u.bits.RegisterNumber = nReg >> 2;
    cfg.u.bits.FunctionNumber = nFun;
    cfg.u.bits.DeviceNumber = nDev;
    cfg.u.bits.BusNumber = nBus;
    cfg.u.bits.Reserved2 = 0;
    cfg.u.bits.Enable = 1;
            
    TURN_INTERRUPTS_OFF(fl);
           
    WRITE_PORT_ULONG((PUSHORT)PCI_TYPE1_ADDR_PORT, cfg.u.AsULONG);  // Select
    WRITE_PORT_ULONG((PUSHORT)PCI_TYPE1_DATA_PORT, Data);           // Write

    RESTORE_INTERRUPTS(fl);
}

//////////////////////////////////////////////////////////// PCI Mechanism #2.
//
static ULONG PciReadInt32_2(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg)
{
    USHORT fl;
    ULONG data = 0;
    PCI_TYPE2_CSE_BITS cse;
    PCI_TYPE2_ADDRESS_BITS adr;
    
    cse.u.bits.Enable = 1;
    cse.u.bits.FunctionNumber = nFun;
    cse.u.bits.Key = 0xf;

    adr.u.bits.RegisterNumber = nReg;
    adr.u.bits.Agent = nDev;
    adr.u.bits.AddressBase = PCI_TYPE2_ADDRESS_BASE;

    TURN_INTERRUPTS_OFF(fl);
           
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_FORWARD_PORT, nBus);    // Select bus
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, cse.u.AsUCHAR);  // Select function & mapping
    data = READ_PORT_ULONG((PUSHORT)adr.u.AsUSHORT);              // Fetch
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, 0);            // Disable mapping.

    RESTORE_INTERRUPTS(fl);
    
    return data;
}

static VOID PciWriteInt32_2(
    UCHAR nBus, 
    UCHAR nDev, 
    UCHAR nFun, 
    UCHAR nReg,
    ULONG Data)
{
    USHORT fl;
    PCI_TYPE2_CSE_BITS cse;
    PCI_TYPE2_ADDRESS_BITS adr;
    
    cse.u.bits.Enable = 1;
    cse.u.bits.FunctionNumber = nFun;
    cse.u.bits.Key = 0xf;

    adr.u.bits.RegisterNumber = nReg;
    adr.u.bits.Agent = nDev;
    adr.u.bits.AddressBase = PCI_TYPE2_ADDRESS_BASE;

    TURN_INTERRUPTS_OFF(fl);
           
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_FORWARD_PORT, nBus);    // Select bus
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, cse.u.AsUCHAR);  // Select function & mapping
    WRITE_PORT_ULONG((PUSHORT)adr.u.AsUSHORT, Data);              // Write
    WRITE_PORT_UCHAR((PUCHAR)PCI_TYPE2_CSE_PORT, 0);            // Disable mapping.

    RESTORE_INTERRUPTS(fl);
}

/////////////////////////////////////////////////////////// PCI Configuration.
//
typedef ULONG (*PF_PCI_READ)(UCHAR nBus,
                              UCHAR nDev,
                              UCHAR nFun,
                              UCHAR nReg);
typedef VOID (*PF_PCI_WRITE)(UCHAR nBus,
                             UCHAR nDev,
                             UCHAR nFun,
                             UCHAR nReg,
                             ULONG Data);

static UCHAR            s_nPciMajorRevision = 0;
static UCHAR            s_nPciMinorRevision = 0;
static UCHAR            s_nPciNumberOfBuses = 0;
static PF_PCI_READ      s_pPciRead = PciReadInt32_0;
static PF_PCI_WRITE     s_pPciWrite = PciWriteInt32_0;

//////////////////////////////////////////////////////////////////////////////
//
ULONG PciReadConfig(ULONG nDevIt, ULONG cbOffset, UCHAR *pbData, ULONG cbData)
{
    ULONG cbDone;
    UCHAR nBus = PCI_ITERATOR_TO_BUS(nDevIt);
    UCHAR nDev = PCI_ITERATOR_TO_DEVICE(nDevIt);
    UCHAR nFun = PCI_ITERATOR_TO_FUNCTION(nDevIt);
    
    // CONFIG space is a space of aligned DWORDs, according to specs.
    // Therefore, if Offset is not aligned the caller is confused.
    //
    if ((cbOffset & 0x3) || (cbData & 0x3)) {
#if DBG
        BlPrint("CPci::ReadConfig() called with Offset=x%x, Length=x%x\n", cbOffset, cbData);
#endif
        return 0;
    }

    for (cbDone = 0; cbDone < cbData; cbDone += sizeof(ULONG)) {
        *((ULONG*)pbData)++ = s_pPciRead(nBus, nDev, nFun,
                                           (UCHAR)(cbOffset + cbDone));
    }
    return cbDone;
}

ULONG PciWriteConfig(ULONG nDevIt, ULONG cbOffset, UCHAR *pbData, ULONG cbData)
{
    ULONG cbDone;
    UCHAR nBus = PCI_ITERATOR_TO_BUS(nDevIt);
    UCHAR nDev = PCI_ITERATOR_TO_DEVICE(nDevIt);
    UCHAR nFun = PCI_ITERATOR_TO_FUNCTION(nDevIt);
    
    // CONFIG space is a space of aligned DWORDs, according to specs.
    // Therefore, if Offset is not aligned the caller is confused.
    //
    if ((cbOffset & 0x3) || (cbData & 0x3)) {
#if DBG
        BlPrint("CPci::ReadConfig() called with Offset=x%x, Length=x%x\n", cbOffset, cbData);
#endif
        return 0;
    }
    
    for (cbDone = 0; cbDone < cbData; cbDone += sizeof(ULONG)) {
        s_pPciWrite(nBus, nDev, nFun, (UCHAR)(cbOffset + cbDone),
                    *((ULONG*)pbData)++);
    }
    return cbDone;
}

ULONG PciFindDevice(USHORT VendorId, USHORT DeviceId, ULONG nBegDevIt)
{
    ULONG nDevIt;
    UCHAR nBus = 0;
    UCHAR nDev = 0;
    UCHAR nFun = 0;

    if (nBegDevIt != 0) {
        nBus = (UCHAR)PCI_ITERATOR_TO_BUS(nBegDevIt);
        nDev = (UCHAR)PCI_ITERATOR_TO_DEVICE(nBegDevIt);
        nFun = (UCHAR)(PCI_ITERATOR_TO_FUNCTION(nBegDevIt) + 1);
    }

    //
    // for each PCI bus     
    //
    for (; nBus < s_nPciNumberOfBuses; nBus++) {
        //
        // for each PCI Device on the bus
        //
        for (; nDev < PCI_MAX_DEVICES; nDev++) {

            BOOLEAN bIsMultiFunction;
            PCI_COMMON_CONFIG config;

            //
            // Check if we have a device on function 0
            //
            config.VendorID = PCI_INVALID_VENDORID;
            
            PciReadConfig( PCI_TO_ITERATOR(nBus, nDev, 0),
                           0, 
                           (UCHAR*)&config, 
                           PCI_FIXED_HDR_LENGTH );

            // No device on function 0, skip to next device
            if (config.VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            // check if the device is a multifunction device
            bIsMultiFunction = config.HeaderType & PCI_MULTIFUNCTION;
            
            for (; nFun < PCI_MAX_FUNCTION; nFun++) {

                // function numbers greater than zero
                // are only allowed on multifunction devices.
                if (nFun > 0 && !bIsMultiFunction) {
                    break;
                }

                // Read configuration header.
                //
                nDevIt = PCI_TO_ITERATOR(nBus, nDev, nFun);
                
                config.VendorID = PCI_INVALID_VENDORID;
                PciReadConfig(nDevIt, 0, (UCHAR*)&config, PCI_FIXED_HDR_LENGTH);

                // No function found, skip to next function
                if (config.VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }
                
                if (VendorId == 0 ||
                    (VendorId == config.VendorID &&
                     (DeviceId == 0 || DeviceId == config.DeviceID))) {
                    
                    return nDevIt;
                }
            }
            nFun = 0;
        }
        nDev = 0;
    }
    return 0;
}


BOOLEAN PciInit(PCI_REGISTRY_INFO *pPCIReg)
{
    s_nPciMajorRevision = pPCIReg->MajorRevision;
    s_nPciMinorRevision = pPCIReg->MinorRevision;
    s_nPciNumberOfBuses = pPCIReg->NoBuses;

    if ((pPCIReg->HardwareMechanism & 0x0F) == 1) {
        s_pPciRead = PciReadInt32_1;
        s_pPciWrite = PciWriteInt32_1;
    }
    else if ((pPCIReg->HardwareMechanism & 0x0F) == 2) {
        s_pPciRead = PciReadInt32_2;
        s_pPciWrite = PciWriteInt32_2;
    }
    else {
#if DBG
        BlPrint("Unknown PCI HW Mechanism!\n");
#endif
        return FALSE;
    }
    return TRUE;
}

#if DBG
#define PCI_SUCCESSFUL                     0x00
#define PCI_BAD_REGISTER_NUMBER            0x87

UCHAR PciBiosReadConfig(ULONG nDevIt, UCHAR cbOffset, UCHAR * pbData, ULONG cbData)
{
    UCHAR returnCode = 0;
    UCHAR nBus = (UCHAR)PCI_ITERATOR_TO_BUS(nDevIt);
    UCHAR nDev = (UCHAR)PCI_ITERATOR_TO_DEVICE(nDevIt);
    UCHAR nFun = (UCHAR)PCI_ITERATOR_TO_FUNCTION(nDevIt);
    
    // CONFIG space is a space of aligned DWORDs, according to specs.
    // Therefore, if Offset is not aligned the caller is confused.
    //
    if ((cbOffset & 0x3) || (cbData & 0x3)) {
#if DBG
        BlPrint("PciNewReadConfig() called with Offset=x%x, Length=x%x\n",
                    cbOffset, cbData);
#endif
        return 0;
    }

    for (cbData += cbOffset; cbOffset < cbData;
                    cbOffset += sizeof(ULONG), ((ULONG *)pbData)++) {
         returnCode = HwGetPciConfigurationDword(nBus, nDev, nFun,
                                           cbOffset, (ULONG *)pbData);
        if (returnCode == PCI_BAD_REGISTER_NUMBER) {
#if DBG
            BlPrint("PciNewReadConfig() failed with returncode=x%x, Bus=x%x\n\tDevice=x%x, Function=x%x, Offset=x%x\n",
                    returnCode, nBus, nDev, nFun, cbOffset);
#endif
            break;
        }
        
    }
    
    return returnCode;
}


ULONG PciBiosFindDevice(USHORT VendorId, USHORT DeviceId, ULONG nBegDevIt)
{
    ULONG nDevIt;
    UCHAR nBus = 0;
    UCHAR nDev = 0;
    UCHAR nFun = 0;
    UCHAR resultCode;

    if (nBegDevIt != 0) {
        nBus = (UCHAR)PCI_ITERATOR_TO_BUS(nBegDevIt);
        nDev = (UCHAR)PCI_ITERATOR_TO_DEVICE(nBegDevIt);
        nFun = (UCHAR)(PCI_ITERATOR_TO_FUNCTION(nBegDevIt) + 1);
    }

    //
    // for each PCI bus     
    //
    for (; nBus < s_nPciNumberOfBuses; nBus++) {
        //
        // for each PCI Device on the bus
        //
        for (; nDev < PCI_MAX_DEVICES; nDev++) {

            BOOLEAN bIsMultiFunction;
            PCI_COMMON_CONFIG config;

            //
            // Check if we have a device on function 0
            //
            config.VendorID = PCI_INVALID_VENDORID;
            
            resultCode = PciBiosReadConfig( PCI_TO_ITERATOR(nBus, nDev, 0),
                           0, 
                           (UCHAR*)&config, 
                           PCI_FIXED_HDR_LENGTH );
            if (resultCode != PCI_SUCCESSFUL) {
#if DBG
                BlPrint("PciBiosReadConfig() failed reading config, result: %x, Bus: %x, Device: %x, Function: %x\n",
                    resultCode, nBus, nDev, 0);
#endif
                return 0;
            }

            // No device on function 0, skip to next device
            if (config.VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            // check if the device is a multifunction device
            bIsMultiFunction = config.HeaderType & PCI_MULTIFUNCTION;
            
            for (; nFun < PCI_MAX_FUNCTION; nFun++) {

                // function numbers greater than zero
                // are only allowed on multifunction devices.
                if (nFun > 0 && !bIsMultiFunction) {
                    break;
                }

                // Read configuration header.
                //
                nDevIt = PCI_TO_ITERATOR(nBus, nDev, nFun);
                
                config.VendorID = PCI_INVALID_VENDORID;
                resultCode = PciBiosReadConfig( nDevIt,
                               0, 
                               (UCHAR*)&config, 
                               PCI_FIXED_HDR_LENGTH );
                if (resultCode != PCI_SUCCESSFUL) {
#if DBG
                    BlPrint("PciBiosReadConfig() failed reading config, result: %x, Bus: %x, Device: %x, Function: %x\n",
                        resultCode, nBus, nDev, nFun);
#endif
                    return 0;
                }

                // No function found, skip to next function
                if (config.VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }
                
                if (VendorId == 0 ||
                    (VendorId == config.VendorID &&
                     (DeviceId == 0 || DeviceId == config.DeviceID))) {
                    
                    return nDevIt;
                }
            }
            nFun = 0;
        }
        nDev = 0;
    }
    return 0;
}

VOID
ScanPCIViaBIOS(
    PPCI_REGISTRY_INFO pPciEntry
     )
{
    ULONG nDevIt;
    USHORT PCIDeviceCount = 0;
    UCHAR ResultCode;

#if DBG
    clrscrn ();
    BlPrint("\nEnumerating PCI Devices via the BIOS...\n");
#endif // DBG

    PciInit(pPciEntry);

    //
    // Count the devices
    //
    PCIDeviceCount = 0;
    for (nDevIt = 0; (nDevIt = PciBiosFindDevice(0, 0, nDevIt)) != 0;) {
        PCIDeviceCount++;
    }

    BlPrint("Found %d PCI devices\n", PCIDeviceCount );

    //        
    // Fill in Device Information
    //
    PCIDeviceCount = 0;
    
    for (nDevIt = 0; (nDevIt = PciBiosFindDevice(0, 0, nDevIt)) != 0;) {
        PCI_COMMON_CONFIG config;

        _fmemset(&config, 0, (USHORT)PCI_COMMON_HDR_LENGTH);
        ResultCode = PciBiosReadConfig(nDevIt, 0, (UCHAR*)&config, PCI_COMMON_HDR_LENGTH);
        if (ResultCode != 0) {
            BlPrint("PciBiosReadConfig() failed reading config, result: %x, BusDevFn: %x\n",
                ResultCode, nDevIt);
           break;
        }
        {
            USHORT x = (config.BaseClass << 8) + config.SubClass;
            
            BlPrint("%d: %d.%d.%d: PCI\\VEN_%x&DEV_%x&SUBSYS_%x%x&REV_%x&CC_%x", 
                PCIDeviceCount,
                PCI_ITERATOR_TO_BUS(nDevIt), 
                PCI_ITERATOR_TO_DEVICE(nDevIt), 
                PCI_ITERATOR_TO_FUNCTION(nDevIt), 
                config.VendorID, 
                config.DeviceID, 
                config.u.type0.SubVendorID, 
                config.u.type0.SubSystemID, 
                config.RevisionID,
                x );

            if ( (config.HeaderType & (~PCI_MULTIFUNCTION) ) == PCI_BRIDGE_TYPE) {
                BlPrint(" Brdg %d->%d\n", 
                    config.u.type1.PrimaryBus,
                    config.u.type1.SecondaryBus );
            } else {
                BlPrint("\n");
            }
        }
        PCIDeviceCount++;
    }

    BlPrint("Enumerating PCI devices via BIOS complete...\n");
    while ( ! HwGetKey ());
    clrscrn();

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pcibios.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pcibios.h

Abstract:

    This module contains support routines for the Pci Irq Routing.

Author:

    Santosh Jodh (santoshj) 15-Sept-1998


Environment:

    Kernel mode

--*/

#include "hwdetect.h"
#include "pcibios.h"

#define SUCCESSFUL                  0x00
#define BUFFER_TOO_SMALL            0x89

#define PIRT_SIGNATURE              0x52495024  // $PIR little endian

#if DBG
#define DebugPrint(x)       \
    {                       \
        BlPrint x;          \
        BlPrint("...\n");    \
    }
#else
#define DebugPrint(x)
#endif

typedef struct
{
    USHORT      BufferSize;
    UCHAR far   *Buffer;
}IRQ_ROUTING_OPTIONS, far *FPIRQ_ROUTING_OPTIONS;

typedef SLOT_INFO far *FPSLOT_INFO;

FPPCI_IRQ_ROUTING_TABLE
HwGetRealModeIrqRoutingTable(
    VOID
    )
{
    IRQ_ROUTING_OPTIONS     routeBuffer;
    FPPCI_IRQ_ROUTING_TABLE irqRoutingTable = NULL;
    USHORT                  pciIrqMask;
    UCHAR                   returnCode;
    USHORT                  size;
#if DBG
    FPSLOT_INFO				slotInfo;
    FPSLOT_INFO				lastSlot;
#endif

    routeBuffer.BufferSize = 0;
    routeBuffer.Buffer = NULL;

    returnCode = HwGetPciIrqRoutingOptions( &routeBuffer,
                                            &pciIrqMask);

    if (returnCode == BUFFER_TOO_SMALL)
    {
        if (routeBuffer.BufferSize)
        {
            DebugPrint(("PCI BIOS returned 0x%x as the size of IRQ routing options buffer", routeBuffer.BufferSize));
            size = routeBuffer.BufferSize + sizeof(PCI_IRQ_ROUTING_TABLE);
            irqRoutingTable = HwAllocateHeap(size, TRUE);
            if (irqRoutingTable)
            {
                routeBuffer.Buffer = (UCHAR far *)irqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE);
                returnCode = HwGetPciIrqRoutingOptions( &routeBuffer,
                                                        &pciIrqMask);
                if (returnCode == SUCCESSFUL)
                {
                    irqRoutingTable->Signature = PIRT_SIGNATURE;
                    irqRoutingTable->TableSize = size;
                    irqRoutingTable->Version = 0x0100;
                }
                else
                {
                    HwFreeHeap(size);
                    irqRoutingTable = NULL;
                    DebugPrint(("PCI BIOS returned error code 0x%x while getting the PCI IRQ routing table", returnCode));
                }
            }
            else
            {
                DebugPrint(("Could not allocate %d bytes of memory to read PCI IRQ routing table", size));
            }
        }
        else
        {
            DebugPrint(("PCI BIOS returned 0 size for PCI IRQ Routint table"));
        }
    }
    else
    {
        DebugPrint(("PCI BIOS returned error code 0x%x while getting the PCI IRQ routing table size", returnCode));
    }

#if DBG

    if (irqRoutingTable)
    {
	    BlPrint("*** Real-mode PCI BIOS IRQ Routing Table - BEGIN ***\n\n");

		BlPrint("Exclusive PCI IRQ mask = 0x%x\n", pciIrqMask);
        BlPrint("----------------------------------------------------------------\n");
        BlPrint("Bus Device  LnkA  Mask  LnkB  Mask  LnkC  Mask  LnkD  Mask  Slot\n");
        BlPrint("----------------------------------------------------------------\n");	
		for (	slotInfo = (FPSLOT_INFO)((UCHAR far *)irqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE)),
					lastSlot = (FPSLOT_INFO)((UCHAR far *)irqRoutingTable + irqRoutingTable->TableSize);
				slotInfo < lastSlot;
				slotInfo++)
		{
			BlPrint("0x%x    0x%x     0x%x   0x%x   0x%x   0x%x   0x%x   0x%x   0x%x   0x%x   0x%x\n",
                                    slotInfo->BusNumber,
                                    slotInfo->DeviceNumber >> 3,
                                    slotInfo->PinInfo[0].Link, slotInfo->PinInfo[0].InterruptMap,
                                    slotInfo->PinInfo[1].Link, slotInfo->PinInfo[1].InterruptMap,
                                    slotInfo->PinInfo[2].Link, slotInfo->PinInfo[2].InterruptMap,
                                    slotInfo->PinInfo[3].Link, slotInfo->PinInfo[3].InterruptMap,
                                    slotInfo->SlotNumber);
		}

	    BlPrint("\n*** Real-mode PCI BIOS IRQ Routing Table - END ***\n\n");

	    BlPrint("press any key to continue...\n");
	    while ( !HwGetKey() ) ; // wait until key pressed to continue
    }

#endif

    return (irqRoutingTable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\pcibios.h ===
/*++                    

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pcibios.h

Abstract:

    This module contains support routines for the Pci Irq Routing.

Author:

    Santosh Jodh (santoshj) 15-Sept-1998
    
    
Environment:

    Kernel mode

--*/

#ifndef _PCIBIOS_

#define _PCIBIOS_

//
// Maximum number of interrupt pins possible on a single
// Pci device (CS offset 3D).
//

#define NUM_IRQ_PINS                        4

//
// Structure definitions for Pci Irq Routing.
//

#pragma pack(1)

//
// Structure of information for one link.
//

typedef struct _PIN_INFO {
    UCHAR   Link;
    USHORT  InterruptMap;
} PIN_INFO, *PPIN_INFO;

//
// Structure of information for one slot entry.
//

typedef struct _SLOT_INFO {
    UCHAR       BusNumber;
    UCHAR       DeviceNumber;
    PIN_INFO    PinInfo[NUM_IRQ_PINS];
    UCHAR       SlotNumber;
    UCHAR       Reserved[1];    
} SLOT_INFO, *PSLOT_INFO, far *FPSLOT_INFO;

//
// Structure of the $PIR table according to MS specification.
//

typedef struct _PCI_IRQ_ROUTING_TABLE {
    ULONG   Signature;
    USHORT  Version;
    USHORT  TableSize;
    UCHAR   RouterBus;
    UCHAR   RouterDevFunc;
    USHORT  ExclusiveIRQs;
    ULONG   CompatibleRouter;
    ULONG   MiniportData;
    UCHAR   Reserved0[11];
    UCHAR   Checksum;
} PCI_IRQ_ROUTING_TABLE, *PPCI_IRQ_ROUTING_TABLE, far *FPPCI_IRQ_ROUTING_TABLE;

//#pragma pack(pop)

//
// Calls PCI BIOS to get the IRQ Routing table.
//

FPPCI_IRQ_ROUTING_TABLE
HwGetRealModeIrqRoutingTable(
    VOID
    );

#endif  // _PCIBIOS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\types.h ===
/*

File

      types.h


Description

      defines and structure definitions for nt386 hardware detection.


Author

      Shie-Lin Tzong (shielint) Feb-15-1992

*/

#define IN
#define OUT
#define OPTIONAL
#define NOTHING
#define CONST               const
#define POINTER_32
#define FIRMWARE_PTR POINTER_32

//
// Void
//

typedef void *PVOID;    // winnt

//
// Basics
//

#define VOID    void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;

//
// ANSI (Multi-byte Character) types
//

typedef CHAR *PCHAR;

typedef double DOUBLE;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef LONG LONG_PTR;
typedef LONG_PTR *PLONG_PTR;

//
// Unsigned Basics
//

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef ULONG ULONG_PTR;
typedef ULONG_PTR *PULONG_PTR;
typedef ULONG KAFFINITY;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// Far point to Basic
//

typedef UCHAR far  * FPCHAR;
typedef UCHAR far  * FPUCHAR;
typedef VOID far   * FPVOID;
typedef USHORT far * FPUSHORT;
typedef ULONG far  * FPULONG;

//
// Boolean
//

typedef CCHAR BOOLEAN;
typedef BOOLEAN *PBOOLEAN;

//
// Large (64-bit) integer types and operations
//

typedef struct _LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;

#define FP_SEG(fp) (*((unsigned *)&(fp) + 1))
#define FP_OFF(fp) (*((unsigned *)&(fp)))

#define FLAG_CF 0x01L
#define FLAG_ZF 0x40L
#define FLAG_TF 0x100L
#define FLAG_IE 0x200L
#define FLAG_DF 0x400L

#define TRUE 1
#define FALSE 0
#define NULL   ((void *)0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\string.h ===
/***
*string.h - declarations for string manipulation functions
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [ANSI/System V]
*
****/

#ifndef _INC_STRING

#ifdef __cplusplus
extern "C" {
#endif


#if (_MSC_VER <= 600)
#define __cdecl _cdecl
#endif

#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif


/* define NULL pointer value */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif


/* function prototypes */

void * _memccpy(void *, const void *, int, unsigned int);
void * memchr(const void *, int, size_t);
int memcmp(const void *, const void *, size_t);
int _memicmp(const void *, const void *, unsigned int);
void * memcpy(void *, const void *, size_t);
void * memmove(void *, const void *, size_t);
void * memset(void *, int, size_t);
void _far * _far _fmemset(void _far *, int, size_t);
void _far * _far _fmemcpy(void _far *, const void _far *, size_t);
char * strcat(char *, const char *);
char * strchr(const char *, int);
int strcmp(const char *, const char *);
int _strcmpi(const char *, const char *);
int strcoll(const char *, const char *);
int _stricmp(const char *, const char *);
char * strcpy(char *, const char *);
char _far * _far _fstrcpy(char _far *, const char _far *);
size_t strcspn(const char *, const char *);
char * _strdup(const char *);
char * _strerror(const char *);
char * strerror(int);
size_t strlen(const char *);
char * _strlwr(char *);
char * strncat(char *, const char *, size_t);
char _far * _far _fstrcat(char _far *, const char _far *);
int strncmp(const char *, const char *, size_t);
int _strnicmp(const char *, const char *, size_t);
char * strncpy(char *, const char *, size_t);
char * _strnset(char *, int, size_t);
char * strpbrk(const char *, const char *);
char * strrchr(const char *, int);
char * _strrev(char *);
char * _strset(char *, int);
size_t strspn(const char *, const char *);
char * strstr(const char *, const char *);
char _far * _far _fstrstr(const char _far *, const char _far *);
char * strtok(char *, const char *);
char * _strupr(char *);
size_t strxfrm (char *, const char *, size_t);
char * itoa(int, char *, int);
char * ultoa(unsigned long, char *, int);

#if !__STDC__
/* Non-ANSI names for compatibility */
#define memccpy  _memccpy
#define memicmp  _memicmp
#define strcmpi  _strcmpi
#define stricmp  _stricmp
#define strdup   _strdup
#define strlwr   _strlwr
#define strnicmp _strnicmp
#define strnset  _strnset
#define strrev   _strrev
#define strset   _strset
#define strupr   _strupr
#endif

#ifdef __cplusplus
}
#endif

#define _INC_STRING
#endif  /* _INC_STRING */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\videoa.asm ===
title  "Display Adapter type detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    video.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    various display chip sets.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 04-Dec-1991.
;    Most of the code is taken from Win31 vdd and setup code(with modification.)
;
; Environment:
;
;    x86 Real Mode.
;
; Revision History:
;
;
;--

FONT_POINTERS   EQU     700h            ; physical addr to store font pointers
                                        ; This is also the DOS loaded area
.386


_DATA   SEGMENT PARA USE16 PUBLIC 'DATA'


_DATA   ends

_TEXT   SEGMENT PARA USE16 PUBLIC 'CODE'
        ASSUME  CS: _TEXT, DS:_DATA, SS:NOTHING

;++
;
; VOID
; GetVideoFontInformation (
;    VOID
;    )
;
; Routine Description:
;
;     This function does int 10h, function 1130 to get font information and
;     saves the pointers in the physical 700h addr.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--
        ASSUME  DS:NOTHING
        public  _GetVideoFontInformation
_GetVideoFontInformation        proc    near

        push    ds
        push    es
        push    bp
        push    bx
        push    si

        mov     ax, FONT_POINTERS
        shr     ax, 4
        mov     ds, ax
        mov     si, FONT_POINTERS
        and     si, 0fh
        mov     bh, 2
@@:
        mov     ax, 1130h               ; Get font information
        int     10h

        mov     [si], bp
        add     si, 2
        mov     [si], es
        add     si, 2                   ; (si)= 8
        inc     bh
        cmp     bh, 8
        jb      short @b

        pop     si
        pop     bx
        pop     bp
        pop     es
        pop     ds
        ret

_GetVideoFontInformation        endp
_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\detect\i386\video.inc ===
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    video.inc
;
; Abstract:
;
;    This module implements the assembley definitions necessary to determine
;    display adapter type.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 15-July-1991.
;    Most of the stuff is extracted from win31 setup code.
;
; Environment:
;
;    80x86 Real Mode.
;
; Revision History:
;
;
;--

;
; Display type definitions.
;   BIT 16-31 Defines video adapter type
;   bit 0     0 - color; 1 - mono
;   bit 1-7   Reserved
;   bit 8-15  Adapter specific information.
;

VD_UNKNOWN              EQU     0
VD_COLOR                EQU     0
VD_MONO                 EQU     1
VD_VGA                  EQU     10000h
VD_COMPAQ_AVGA          EQU     20000H
VD_COMPAQ_QVIS          EQU     30000H
VD_8514                 EQU     40000H
VD_GENOA_VGA            EQU     50000H
VD_VIDEO7_VGA           EQU     60000H
VD_TRIDENT_VGA          EQU     70000H
VD_PARADISE_VGA         EQU     80000H
VD_ATI_VGA              EQU     90000H
VD_TSENGLAB_VGA         EQU     0A0000H
VD_CIRRUS_VGA           EQU     0B0000H
VD_DELL_DGX             EQU     0C0000H
VD_S3                   EQU     0D0000H
VD_NCR_77C22            EQU     0E0000H
VD_WD_90C               EQU     0F0000H
VD_XGA                  EQU     100000H
IFDEF NEC_98
VD_PC9801               EQU     010000h
ENDIF ; NEC_98

;
; Monitor type for 8514
; NOte, 0 is not used.
;

VF_MONITOR_VGA          EQU     100h            ; Stand VGA
VF_MONITOR_MONO_8503    EQU     200h            ; mono 8503
VF_MONITOR_GAD_8514     EQU     300h            ; 8514 type monitor

;
; Video 7 VGA specific flags
;

VF_V7_VRAM              EQU     100H
VF_V7_DRAM              EQU     200H

;
; NCR 77C2x specific flags
;

VF_NCR_77C22E           EQU     100H

;
; WD90Cxx specific flags
;

VF_WD_00                EQU     100H
VF_WD_30                EQU     200H
VF_WD_31                EQU     300H

;
; Trident VGA specific flags
;

VF_TVGA_9100            EQU     100h

;
; Paradise VGA specific flags
;

VF_PVGA_PROM            EQU     100h            ; with Paradise ROM
VF_PVGA_CHIP_1F         EQU     200h            ; with 1F chip

;
; ATI VGA  specific flags
;

VF_ATIVGA_WONDDER3      EQU     100h

;
; Tseng Lab VGA specific flags
;

VF_TLVGA_ET3000         EQU     0
VF_TLVGA_ET4000         EQU     100h

;
; Cirrus Logic VGA specific definitions
;

VF_CLVGA_REVC           EQU     100h            ; 610/620 rev C
;
; 070193 - adrianc
; Added the Cirrus chip detection for COMPAQ servers.
;
VF_CLVGA_5420r0         EQU     200h            ; COMPAQ Cirrus implementations
VF_CLVGA_5420r1         EQU     300h
VF_CLVGA_5428           EQU     400h
VF_CLVGA_542x           EQU     500h

;
; Equates for 8514 register ports.
;

ERR_TERM        equ     92e8h       ; 8514 error term register.
SUBSYS_STAT     equ     42e8h       ; 8514 Subsystem status register.

;
;  Video display register equates
;       ...Colr are for CGA and EGA color modes
;       ...Mono are for EGA/VGA monochrome modes
;
;NAMING CONVENTIONS
; pXXXXX is a I/O port definition
; fXXXXX is a bit mask
; bXXXXX is a bit number
; mXXXXX is a bit mask (multiple fXXXX)
; vXXXXX is a value to output/input to/from a port
; xXXXXX is a specific index

;
; CRT registers
;

pCRTCIndxColr   EQU     3D4h            ; CRTC index register
pCRTCIndxMono   EQU     3B4h

pCRTCDataColr   EQU     3D5h            ; CRTC data register
pCRTCDataMono   EQU     3B5h

; Status register
;

pStatColr       EQU     3DAh            ; Status register
pStatMono       EQU     3BAh
fStatEna        EQU     00000001b       ;   Video RAM access OK for processor
fStatLPTr       EQU     00000010b       ;   Light pen triggered
fStatLPSw       EQU     00000100b       ;   Light pen switch is "on"
fStatVRTC       EQU     00001000b       ;   Vertical retrace in progress
mStat_IVal      EQU     fStatEna+fStatVRTC  ; Initial value for pseudo status

;
; Feature control
;

pFeatColr       EQU     pStatColr       ; Feature control
pFeatMono       EQU     pStatMono
pFeatVGAIn      EQU     3CAh            ; VGA feature control read
fFeatFC0        EQU     00000001b       ;   FC0
fFeatFC1        EQU     00000010b       ;   FC1

;
; Light pen
;

pLPen1Colr      EQU     3DBh            ; Light pen latch clear
pLPen1Mono      EQU     3BBh
pLPen2Colr      EQU     3DCh            ; Light pen latch set
pLPen2Mono      EQU     3BCh

;
; Misc input/output
;

pMisc           EQU     3C2h            ; Miscellaneous output
pMiscIn         EQU     3CCh            ; VGA read Misc. output
fMiscPNum       EQU     00000001b       ;   3Dx port numbers(vs. 3Bx)
fMiscREna       EQU     00000010b       ;   Ram enable
fMiscDot        EQU     00001100b       ;   Dot clock select
fMiscOSrc       EQU     00010000b       ;   Output source
fMiscPage       EQU     00100000b       ;   Page bit for odd/even mode
fMiscHPol       EQU     01000000b       ;   Horizontal retrace polarity
fMiscVPol       EQU     10000000b       ;   Vertical retrace polarity
mMiscCRTC       EQU     fMiscREna+fMiscPage ; Mask for CRTC bits
mMiscMemC       EQU     0FFh - mMiscCRTC    ; Mask for MemC bits

;
; Misc. status
;

pStt0EGA        EQU     pMisc           ; Miscellaneous status
fStt0Swit       EQU     00010000b       ;   Switch sense(addr'd by dot clk sel)
fStt0FCI0       EQU     00100000b       ;   Feature card input 0
fStt0FCI1       EQU     01000000b       ;   Feature card input 1
fStt0VRTC       EQU     10000000b       ;   VRTC

;
; Attribute control
;

pAttr           EQU     3C0h            ; Attribute(palette) address/data
fVAI_Indx       EQU     10000000b       ; sign bit of Attribute index is
bVAI_Indx       EQU     7               ;   flag indicating port is index
fVAI_ScOn       EQU     00100000b       ; Indicates screen is on
bVAI_ScOn       EQU     5

;
; Sequencer
;

pSeqIndx        EQU     3C4h            ; Sequencer address
pSeqData        EQU     3C5h            ; Sequencer data
fSeq0ARst       EQU     00000001b       ;   0:Async reset
fSeq0SRst       EQU     00000010b       ;   0:Sync reset
fSeq1DPCh       EQU     00000001b       ;   1:Dots per character
fSeq1BWid       EQU     00000010b       ;   1:Band Width
fSeq1ShLd       EQU     00000100b       ;   1:Shift load(0=every char, 1=skip)
fSeq1DClk       EQU     00001000b       ;   1:Dot clock(=1 if halved)
mSeq2WMsk       EQU     00001111b       ;   2:Write mask
mSeq3ChrB       EQU     00000011b       ;   3:Char map B select(attr bit 3 = 0)
mSeq3ChrA       EQU     00001100b       ;   3:Char map A select(attr bit 3 = 1)
fSeq4Alph       EQU     00000001b       ;   4:Alpha mode(char gen enabled)
fSeq4ExtM       EQU     00000010b       ;   4:Extended memory installed
fSeq4SqAd       EQU     00000100b       ;   4:Seq'l mem addr'ing(vs. odd/even)
fSeq4Chain4     EQU     00001000b       ;   4:Chain 4 (double odd/even) for
                                        ;     256 color (mode 13)

fSeqF9extpgsel  EQU     00000001b       ;V7F9:Extended page select
fSeqFCext256m   EQU     00000010b       ;V7FC:Extended 256 color mode
fSeqFCext256e   EQU     00000100b       ;V7FC:Extended 256 color enable
fSeqFCseqChain4 EQU     00100000b       ;V7FC:Sequential Chain 4

;
; Graphic controller
;

pGrp1Pos        EQU     3CCh            ; Graphics posn 1(=0)
pGrp2Pos        EQU     3CAh            ; Graphics posn 2(=1)
pGrpIndx        EQU     3CEh            ; Graphics controller address
pGrpData        EQU     3CFh            ; Graphics controller data
fGrp0StV0       EQU     00000001b       ;   0:Value for plane 0 if enabled
fGrp0StV1       EQU     00000010b       ;   0:Value for plane 1 if enabled
fGrp0StV2       EQU     00000100b       ;   0:Value for plane 2 if enabled
fGrp0StV3       EQU     00001000b       ;   0:Value for plane 3 if enabled
fGrp1Ena0       EQU     00000001b       ;   1:Enable for plane 0
fGrp1Ena1       EQU     00000010b       ;   1:Enable for plane 1
fGrp1Ena2       EQU     00000100b       ;   1:Enable for plane 2
fGrp1Ena3       EQU     00001000b       ;   1:Enable for plane 3
mGrp2Colr       EQU     00001111b       ;   2:Color compare value
mGrp3RCnt       EQU     00000111b       ;   3:Rotate left count for mode 0
mGrp3Func       EQU     00011000b       ;   3:Function for modes 0 and 2
mGrp4RMsk       EQU     00000111b       ;   4:Read map select
mGrp5WMod       EQU     00000011b       ;   5:Write mode
fGrp5Test       EQU     00000100b       ;   5:Test condition
fGrp5RMod       EQU     00001000b       ;   5:Read mode(0=plane,1=compare)
fGrp5SqAd       EQU     00010000b       ;   5:Seq'l mem addr'ing(vs. odd/even)
fGrp5CGA        EQU     00100000b       ;   5:CGA 4 color mode addressing
fGrp6Char       EQU     00000001b       ;   6:Char or graphics
fGrp6Chain      EQU     00000010b       ;   6:Chain odd maps after even
mGrp6Addr       EQU     00001100b       ;   6:Processor view of VRAM start addr
                                        ;       00=A000 for 128kb
                                        ;       01=A000 for 64kb
                                        ;       10=B000 for 32kb
                                        ;       11=B800 for 32kb
bGrp6Addr       EQU          2          ;     First of 2 bits for start addr
mGrp7Colr       EQU     00001111b       ;   7:Color don't care for read compare
                                        ;   8:Mask: use latch value vs. data

;
; VGA subsystem enable
;

pVGAEna         EQU     3C3h            ; VGA enable register
fVGAEna         EQU     00000001b       ;   Enable access to VGA

;
; VGA DAC
;

pDACWindx       EQU     3C8h            ; DAC Write index(R/W)
pDACRindx       EQU     3C7h            ; DAC Read index(RO)
pDACState       EQU     pDACRindx       ; DAC state
pDACData        EQU     3C9h            ; DAC data(3 successive accesses)
pDACMask        EQU     3CAh            ; DAC mask

;
; VGA read access to write only registers
;

pMiscRead       EQU     3CCh            ; Port to read Misc output register
pFeatRead       EQU     3CAh            ; Port to read Feature output register

;
; 8514 DAC
;

p8514DACWindx   EQU     2ECh            ; DAC Write index(R/W)
p8514DACRindx   EQU     2EBh            ; DAC Read index(RO)
p8514DACState   EQU     pDACRindx       ; DAC state
p8514DACData    EQU     2EDh            ; DAC data(3 successive accesses)

;
; values returned from reads of port pDACState:
;

vDAC_Read_Mode  EQU     0
vDAC_Write_Mode EQU     3


xC_CTMiscRead   EQU     0Fh             ; CHIPS Misc output read index
xC_CTFeatRead   EQU     0Eh             ; CHIPS Feat output read index
xC_CT400        EQU     0F9h            ; CHIPS 400 line reg index
xC_CTTempFE     EQU     0FEh            ; CHIPS CRTC temp reg FEh
xG_CTCtl        EQU     0F7h            ; CHIPS control reg index

;

pCMode          EQU     3C6h            ; Control mode(Compaq specific)

ATiVGA_extended_reg     EQU     01ceh

TVGA_3C5_B_WrMode       equ     0
TVGA_3C5_B_RdMode       equ     1

;
; Definition for IBM XGA video adapter Id.
;

IBM_XGA_ID_LOW  EQU     8FD8h
IBM_XGA_ID_HIGH EQU     8FDBh
MCA_POS_DATA_SIZE EQU   6

;
; Misc. V7 VRAM definitions
;

VRAM2_ROM_ID_1          EQU     108h
VRAM2_ROM_ID_2          EQU     208h
VRAM2ERGO_ROM_ID        EQU     308h
V7_ID_OFFSET            EQU     86h     ; The offset to V7VGA ROM id

;
; WD extended registers
;

WD_EXT_IO_PORT          EQU     23C0h

;
; Misc. definitions
;

FONT_POINTERS   EQU     700h            ; physical addr to store font pointers
                                        ; This is also the DOS loaded area
VIDEO_SEG       EQU     0C000h          ; Video memory segment
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\arctree.c ===
/*++

Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    config.c

Abstract:

    Make a few ARC entries needed for NTLDR/ntoskrnl to boot.

Author:

    Allen Kay (akay) 26-Oct-98

Revision History:

--*/

#include "arccodes.h"
#include "bootia64.h"
#include "string.h"
#include "pci.h"
#include "ntacpi.h"
#include "acpitabl.h"

#include "efi.h"
#include "biosdrv.h"
#include "extern.h"

//
// External Data
//
extern PCONFIGURATION_COMPONENT_DATA FwConfigurationTree;

//
// Defines
//

#define LEVEL_SENSITIVE CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE
#define EDGE_TRIGGERED CM_RESOURCE_INTERRUPT_LATCHED
#define RESOURCE_PORT 1
#define RESOURCE_INTERRUPT 2
#define RESOURCE_MEMORY 3
#define RESOURCE_DMA 4
#define RESOURCE_DEVICE_DATA 5
#define ALL_PROCESSORS 0xffffffff

//
// Internal references and definitions.
//

typedef enum _RELATIONSHIP_FLAGS {
    Child,
    Sibling,
    Parent
} RELATIONSHIP_FLAGS;

//
// Hard Disk Drive
//
#define SIZE_OF_PARAMETER    12     // size of disk params
#define MAX_DRIVE_NUMBER     8      // max number of drives
#define RESOURCE_DEVICE_DATA 5
#define RESERVED_ROM_BLOCK_LIST_SIZE (((0xf0000 - 0xc0000)/512) * sizeof(CM_ROM_BLOCK))
#define DATA_HEADER_SIZE sizeof(CM_PARTIAL_RESOURCE_LIST)

typedef CM_PARTIAL_RESOURCE_DESCRIPTOR HWPARTIAL_RESOURCE_DESCRIPTOR;
typedef HWPARTIAL_RESOURCE_DESCRIPTOR *PHWPARTIAL_RESOURCE_DESCRIPTOR;

typedef CM_PARTIAL_RESOURCE_LIST HWRESOURCE_DESCRIPTOR_LIST;
typedef HWRESOURCE_DESCRIPTOR_LIST *PHWRESOURCE_DESCRIPTOR_LIST;

//
// Defines the structure to store controller information
// (used by ntdetect internally)
//

#define MAXIMUM_DESCRIPTORS 10

typedef struct _HWCONTROLLER_DATA {
    UCHAR NumberPortEntries;
    UCHAR NumberIrqEntries;
    UCHAR NumberMemoryEntries;
    UCHAR NumberDmaEntries;
    HWPARTIAL_RESOURCE_DESCRIPTOR DescriptorList[MAXIMUM_DESCRIPTORS];
} HWCONTROLLER_DATA, *PHWCONTROLLER_DATA;


//
// Hard Disk Defines
//
#pragma pack(1)
typedef struct _HARD_DISK_PARAMETERS {
    USHORT DriveSelect;
    ULONG MaxCylinders;
    USHORT SectorsPerTrack;
    USHORT MaxHeads;
    USHORT NumberDrives;
} HARD_DISK_PARAMETERS, *PHARD_DISK_PARAMETERS;
#pragma pack()

PUCHAR PRomBlock = NULL;
USHORT RomBlockLength = 0;
USHORT NumberBiosDisks;

#if defined(_INCLUDE_LOADER_KBINFO_)
//
// Keyboard defines
//

//
// String table to map keyboard id to an ascii string.
//

#define UNKNOWN_KEYBOARD  0
#define OLI_83KEY         1
#define OLI_102KEY        2
#define OLI_86KEY         3
#define OLI_A101_102KEY   4
#define XT_83KEY          5
#define ATT_302           6
#define PCAT_ENHANCED     7
#define PCAT_86KEY        8
#define PCXT_84KEY        9

PUCHAR KeyboardIdentifier[] = {
    "UNKNOWN_KEYBOARD",
    "OLI_83KEY",
    "OLI_102KEY",
    "OLI_86KEY",
    "OLI_A101_102KEY",
    "XT_83KEY",
    "ATT_302",
    "PCAT_ENHANCED",
    "PCAT_86KEY",
    "PCXT_84KEY"
    };

UCHAR KeyboardType[] = {
    -1,
    1,
    2,
    3,
    4,
    1,
    1,
    4,
    3,
    1
    };

UCHAR KeyboardSubtype[] = {
    -1,
    0,
    1,
    10,
    4,
    42,
    4,
    0,
    0,
    0
    };
#endif  // _INCLUDE_LOADER_KBINFO_

#if defined(_INCLUDE_LOADER_MOUSEINFO_)
//
// Mouse Defines
//

typedef struct _MOUSE_INFORMATION {
        UCHAR MouseType;
        UCHAR MouseSubtype;
        USHORT MousePort;       // if serial mouse, 1 for com1, 2 for com2 ...
        USHORT MouseIrq;
        USHORT DeviceIdLength;
        UCHAR  DeviceId[10];
} MOUSE_INFORMATION, *PMOUSE_INFORMATION;

//
// Mouse Type definitions
//

#define UNKNOWN_MOUSE   0
#define NO_MOUSE        0x100             // YES! it is 0x100 *NOT* 0x10000

#define MS_MOUSE        0x200             // MS regular mouses
#define MS_BALLPOINT    0x300             // MS ballpoint mouse
#define LT_MOUSE        0x400             // Logitec Mouse

//
// note last 4 bits of the subtype are reserved subtype specific use
//

#define PS2_MOUSE       0x1
#define SERIAL_MOUSE    0x2
#define INPORT_MOUSE    0x3
#define BUS_MOUSE       0x4
#define PS_MOUSE_WITH_WHEEL     0x5
#define SERIAL_MOUSE_WITH_WHEEL 0x6

PUCHAR MouseIdentifier[] = {
    "UNKNOWN",
    "NO MOUSE",
    "MICROSOFT",
    "MICROSOFT BALLPOINT",
    "LOGITECH"
    };

PUCHAR MouseSubidentifier[] = {
    "",
    " PS2 MOUSE",
    " SERIAL MOUSE",
    " INPORT MOUSE",
    " BUS MOUSE",
    " PS2 MOUSE WITH WHEEL",
    " SERIAL MOUSE WITH WHEEL"
    };

//
// The following table translates keyboard make code to
// ascii code.  Note, only 0-9 and A-Z are translated.
// Everything else is translated to '?'
//

UCHAR MakeToAsciiTable[] = {
    0x3f, 0x3f, 0x31, 0x32, 0x33,      // ?, ?, 1, 2, 3,
    0x34, 0x35, 0x36, 0x37, 0x38,      // 4, 5, 6, 7, 8,
    0x39, 0x30, 0x3f, 0x3f, 0x3f,      // 9, 0, ?, ?, ?,
    0x3f, 0x51, 0x57, 0x45, 0x52,      // ?, Q, W, E, R,
    0x54, 0x59, 0x55, 0x49, 0x4f,      // T, Y, U, I, O,
    0x50, 0x3f, 0x3f, 0x3f, 0x3f,      // P, ?, ?, ?, ?,
    0x41, 0x53, 0x44, 0x46, 0x47,      // A, S, D, F, G,
    0x48, 0x4a, 0x4b, 0x4c, 0x3f,      // H, J, K, L, ?,
    0x3f, 0x3f, 0x3f, 0x3f, 0x5a,      // ?, ?, ?, ?, Z,
    0x58, 0x43, 0x56, 0x42, 0x4e,      // X, C, V, B, N,
    0x4d};                             // W

#define MAX_MAKE_CODE_TRANSLATED 0x32
static ULONG MouseControllerKey = 0;

#endif  // _INCLUDE_LOADER_MOUSEINFO_

//
// ComPortAddress[] is a global array to remember which comports have
// been detected and their I/O port addresses.
//

#define MAX_COM_PORTS   4           // Max. number of comports detectable
#define MAX_LPT_PORTS   3           // Max. number of LPT ports detectable

#if 0 //unused
USHORT   ComPortAddress[MAX_COM_PORTS] = {0, 0, 0, 0};
#endif

//
// Global Definition
//

#if defined(_INCLUDE_LOADER_MOUSEINFO_) || defined(_INCLUDE_LOADER_KBINFO_)
USHORT HwBusType = 0;
#endif

PCONFIGURATION_COMPONENT_DATA AdapterEntry = NULL;

//
// Function Prototypes
//

#if defined(_INCLUDE_LOADER_KBINFO_)

PCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    IN USHORT KeyboardId
    );

#endif

#if defined(_INCLUDE_LOADER_MOUSEINFO_)

PCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    );

#endif

PCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    );

PVOID
HwSetUpResourceDescriptor (
    PCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    );

VOID
HwSetUpFreeFormDataHeader (
    PHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    );




BuildArcTree(
     )
/*++

Routine Description:

    Main entrypoint of the HW recognizer test.  The routine builds
    a configuration tree and leaves it in the hardware heap.

Arguments:

    ConfigurationTree - Supplies a 32 bit FLAT address of the variable to
        receive the hardware configuration tree.

Returns:

    None.

--*/
{
    PCONFIGURATION_COMPONENT_DATA ConfigurationRoot;
    PCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry;
    PCONFIGURATION_COMPONENT Component;
    RELATIONSHIP_FLAGS NextRelationship;
    CHAR Identifier[256];
    PCHAR MachineId;
#if defined(_INCLUDE_LOADER_KBINFO_)
    USHORT KeyboardId = 0;
#endif
    USHORT Length, InitialLength, i, j;
    PCHAR IdentifierString;
    PHARD_DISK_PARAMETERS RomChain;
    PUCHAR PRomChain = NULL, ConfigurationData, EndConfigurationData;
    SHORT FreeSize;
    PHWPARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    PHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    PACPI_BIOS_MULTI_NODE AcpiMultiNode;
    PUCHAR Current;
    PRSDP rsdp;

    //
    // Allocate heap space for System component and initialize it.
    // Also make the System component the root of configuration tree.
    //

    ConfigurationRoot = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                        sizeof(CONFIGURATION_COMPONENT_DATA));
    Component = &ConfigurationRoot->ComponentEntry;

    Component->Class = SystemClass;
    Component->Type = MaximumType;          // NOTE should be IsaCompatible
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0;
    Component->ConfigurationDataLength = 0;
    MachineId = "Intel Itanium processor family";
    if (MachineId) {
        Length = RESET_SIZE_AT_USHORT_MAX(strlen(MachineId) + 1);
        IdentifierString = (PCHAR)BlAllocateHeap(Length);
        strcpy(IdentifierString, MachineId);
        Component->Identifier = IdentifierString;
        Component->IdentifierLength = Length;
    } else {
        Component->Identifier = 0;
        Component->IdentifierLength = 0;
    }
    NextRelationship = Child;
    PreviousEntry = ConfigurationRoot;


    //
    // ISA
    //
    AdapterEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &AdapterEntry->ComponentEntry;

    Component->Class = AdapterClass;

    Component->Type = MultiFunctionAdapter;
    strcpy(Identifier, "ISA");

    Length = RESET_SIZE_AT_USHORT_MAX(strlen(Identifier) + 1);
    IdentifierString = (PCHAR)BlAllocateHeap(Length);
    strcpy(IdentifierString, Identifier);
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = Length;
    Component->Identifier = IdentifierString;

    //
    // Make Adapter component System's child
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = AdapterEntry;
        AdapterEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

    //
    // Collect BIOS information for ConfigurationRoot component.
    // This step is done here because we need data collected in
    // adapter component.  The ConfigurationData is:
    //      HWRESOURCE_DESCRIPTOR_LIST header
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Parameter Table
    //      HWPARTIAL_RESOURCE_DESCRIPTOR for Rom Blocks.
    // (Note DATA_HEADER_SIZE contains the size of the first partial
    //  descriptor already.)
    //

#if DBG
    BlPrint(TEXT("Collecting Disk Geometry...\r\n"));
#endif

    RomChain = (PHARD_DISK_PARAMETERS)
               BlAllocateHeap(SIZE_OF_PARAMETER * MAX_DRIVE_NUMBER);

#if 0
    RomChain[0].DriveSelect = 0x80;
    RomChain[0].MaxCylinders = 0;
    RomChain[0].SectorsPerTrack = 0;
    RomChain[0].MaxHeads = 0;
    RomChain[0].NumberDrives = 1;               // Gambit only access 1 drive

    NumberBiosDisks = 1;                        // was defined in diska.asm
#endif

    InitialLength = (USHORT)(Length + RESERVED_ROM_BLOCK_LIST_SIZE + DATA_HEADER_SIZE +
                    sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    ConfigurationData = (PUCHAR)BlAllocateHeap(InitialLength);
    EndConfigurationData = ConfigurationData + DATA_HEADER_SIZE;
    if (Length != 0) {
        PRomChain = EndConfigurationData;
        RtlCopyMemory( PRomChain, (PVOID)RomChain, Length);
    }
    EndConfigurationData += (sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                             Length);
    HwSetUpFreeFormDataHeader((PHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData,
                              0,
                              0,
                              0,
                              Length
                              );


    //
    // Scan ROM to collect all the ROM blocks, if possible.
    //

#if DBG
    BlPrint(TEXT("Constructing ROM Blocks...\r\n"));
#endif

    PRomBlock = EndConfigurationData;
    Length = 0;
    RomBlockLength = Length;
    if (Length != 0) {
        EndConfigurationData += Length;
    } else {
        PRomBlock = NULL;
    }

    //
    // We have both RomChain and RomBlock information/Headers.
    //

    DescriptorList = (PHWRESOURCE_DESCRIPTOR_LIST)ConfigurationData;
    DescriptorList->Count = 2;
    Descriptor = (PHWPARTIAL_RESOURCE_DESCRIPTOR)(
                 EndConfigurationData - Length -
                 sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR));
    Descriptor->Type = RESOURCE_DEVICE_DATA;
    Descriptor->ShareDisposition = 0;
    Descriptor->Flags = 0;
    Descriptor->u.DeviceSpecificData.DataSize = (ULONG)Length;
    Descriptor->u.DeviceSpecificData.Reserved1 = 0;
    Descriptor->u.DeviceSpecificData.Reserved2 = 0;

    Length = (USHORT)(EndConfigurationData - ConfigurationData);
    ConfigurationRoot->ComponentEntry.ConfigurationDataLength = Length;
    ConfigurationRoot->ConfigurationData = ConfigurationData;
    FreeSize = InitialLength - Length;

#if defined(_INCLUDE_LOADER_KBINFO_)

//#if defined(NO_ACPI)
    //
    // Set up device information structure for Keyboard.
    //

#if DBG
    BlPrint(TEXT("Constructing Keyboard Component ...\r\n"));
#endif

    KeyboardId = 7;           // PCAT_ENHANCED

    CurrentEntry = SetKeyboardConfigurationData(KeyboardId);

    //
    // Make display component the child of Adapter component.
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;
#endif  // _INCLUDE_LOADER_MOUSEINFO_

    //
    // Set up device information for com port
    //

#if defined(_INCLUDE_COMPORT_INFO_)
    //
    // This code was taken out because the GetComportInformation() routine
    // was manufacturing data about the com port and writing the com port
    // address to 40:0.  This information should be determined by PnP
    //

#if DBG
    BlPrint(TEXT("Constructing ComPort Component ...\r\n"));
#endif

    if (CurrentEntry = GetComportInformation()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
        } else {
            PreviousEntry->Child = CurrentEntry;
        }
        while (CurrentEntry) {
            CurrentEntry->Parent = AdapterEntry;
            PreviousEntry = CurrentEntry;
            CurrentEntry = CurrentEntry->Sibling;
        }
        NextRelationship = Sibling;
    }
#else
    
//    DbgPrint("Skipping ComPort Component ...\r\n");

    //
    // acpi node should be a sibling of adapter entry
    //
    // Note: this only works if !defined(_INCLUDE_LOADER_MOUSEINFO_)
    //
    NextRelationship = Sibling;
    PreviousEntry = AdapterEntry;
#endif

#if defined(_INCLUDE_LOADER_MOUSEINFO_)
    //
    // Set up device information structure for Mouse.
    //

#if DBG
    BlPrint(TEXT("Constructing Mouse Component ...\r\n"));
#endif

    if (CurrentEntry = GetMouseInformation
        ()) {

        //
        // Make current component the child of Adapter component.
        //

        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        NextRelationship = Sibling;
        PreviousEntry = CurrentEntry;
    }
//#endif    // NO_ACPI
#endif  // _INCLUDE_LOADER_MOUSEINFO_

    //DbgPrint("Constructing ACPI Bus Component ...\n");

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                          sizeof(CONFIGURATION_COMPONENT_DATA));

    Current = (PUCHAR) BlAllocateHeap( DATA_HEADER_SIZE +
                                      sizeof(ACPI_BIOS_MULTI_NODE) );
    AcpiMultiNode = (PACPI_BIOS_MULTI_NODE) (Current + DATA_HEADER_SIZE);

    //DbgPrint("AcpiTable: %p\n", AcpiTable);

    if (AcpiTable) {

        rsdp = (PRSDP) AcpiTable;
        AcpiMultiNode->RsdtAddress.QuadPart = rsdp->XsdtAddress.QuadPart;

    }

    CurrentEntry->ConfigurationData = Current;

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = Length;

    Component->Class = AdapterClass;
    Component->Type = MultiFunctionAdapter;

    strcpy (Identifier, "ACPI BIOS");
    i = RESET_SIZE_AT_USHORT_MAX(strlen(Identifier) + 1);
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    HwSetUpFreeFormDataHeader(
            (PHWRESOURCE_DESCRIPTOR_LIST) ConfigurationData,
            0,
            0,
            0,
            Length - DATA_HEADER_SIZE
            );

    //
    // Add it to tree
    //

#if defined(_INCLUDE_COMPORT_INFO_)

    //
    // Note: this assumes the previousentry is a child of the AdapterEntry,
    //       typically, this would be the comport info node
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Parent->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent->Parent;
    }
    NextRelationship = Sibling;

#else

    //
    // ACPI BIOS node is a sibling of AdapterEntry
    //
    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    }
    
    //
    // ARC disk info node must be child of adapter entry
    //
    NextRelationship = Child;
    PreviousEntry = AdapterEntry;

#endif

#if 0
    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;
#endif

    //
    // First entry created to make BlGetArcDiskInformation() happy
    //

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = 0;

    Component->Class = ControllerClass;
    Component->Type = DiskController;

    strcpy (Identifier, "Controller Class Entry For Hard Disk");
    i = RESET_SIZE_AT_USHORT_MAX(strlen(Identifier) + 1);
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    //
    // Add it to tree
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    NextRelationship = Child;
    PreviousEntry = CurrentEntry;

    //
    // Looks for disks on system and add them.
    //
    for( j=0; j<GetDriveCount(); j++ ) {
        CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                       sizeof(CONFIGURATION_COMPONENT_DATA));

        Component = &CurrentEntry->ComponentEntry;
        Component->ConfigurationDataLength = 0;

        Component->Class = PeripheralClass;
        Component->Type = DiskPeripheral;

        strcpy (Identifier, "Peripheral Class Entry For Hard Disk");
        i = RESET_SIZE_AT_USHORT_MAX(strlen(Identifier) + 1);
        IdentifierString = (PCHAR)BlAllocateHeap(i);
        strcpy(IdentifierString, Identifier);

        Component->Version = 0;
        Component->Key = j;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = i;
        Component->Identifier = IdentifierString;

        //
        // Add it to tree
        //
        if (NextRelationship == Sibling) {
            PreviousEntry->Sibling = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry->Parent;
        } else {
            PreviousEntry->Child = CurrentEntry;
            CurrentEntry->Parent = PreviousEntry;
        }
        NextRelationship = Sibling;
        PreviousEntry = CurrentEntry;
    }

    //
    // add an entry for the floppy disk peripheral
    //
    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = 0;

    Component->Class = PeripheralClass;
    Component->Type = FloppyDiskPeripheral;

    strcpy (Identifier, "Peripheral Class Entry For Floppy Disk");
    i = RESET_SIZE_AT_USHORT_MAX(strlen(Identifier) + 1);
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    //
    // Add it to tree
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    
    NextRelationship = Sibling;
    PreviousEntry = CurrentEntry;
    
    //
    // add another entry for the floppy disk peripheral 
    // for virtual floppy support
    //
    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;
    Component->ConfigurationDataLength = 0;

    Component->Class = PeripheralClass;
    Component->Type = FloppyDiskPeripheral;

    strcpy (Identifier, "Peripheral Class Entry For Floppy Disk");
    i = RESET_SIZE_AT_USHORT_MAX(strlen(Identifier) + 1);
    IdentifierString = (PCHAR)BlAllocateHeap(i);
    strcpy(IdentifierString, Identifier);

    Component->Version = 0;
    Component->Key = 1;
    Component->AffinityMask = 0xffffffff;
    Component->IdentifierLength = i;
    Component->Identifier = IdentifierString;

    //
    // Add it to tree
    //

    if (NextRelationship == Sibling) {
        PreviousEntry->Sibling = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry->Parent;
    } else {
        PreviousEntry->Child = CurrentEntry;
        CurrentEntry->Parent = PreviousEntry;
    }
    
    NextRelationship = Child;
    PreviousEntry = CurrentEntry;

    //
    // Done
    //
    FwConfigurationTree = (PCONFIGURATION_COMPONENT_DATA) ConfigurationRoot;
}

#if defined(_INCLUDE_LOADER_KBINFO_)

PCONFIGURATION_COMPONENT_DATA
SetKeyboardConfigurationData (
    USHORT KeyboardId
    )

/*++

Routine Description:

    This routine maps Keyboard Id information to an ASCII string and
    stores the string in configuration data heap.

Arguments:

    KeyboardId - Supplies a USHORT which describes the keyboard id information.

    Buffer - Supplies a pointer to a buffer where to put the ascii.

Returns:

    None.

--*/
{
    PCONFIGURATION_COMPONENT_DATA Controller, CurrentEntry;
    PCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    PHWRESOURCE_DESCRIPTOR_LIST DescriptorList;
    CM_KEYBOARD_DEVICE_DATA *KeyboardData;
    USHORT z, Length;

    //
    // Set up Keyboard COntroller component
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    Controller = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                 sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &Controller->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = KeyboardController;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 2;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x60;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 1;
    z++;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = 0x64;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 1;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
    ControlData.DescriptorList[z].u.Interrupt.Level = 1;
    ControlData.DescriptorList[z].u.Interrupt.Vector = 1;
    if (HwBusType == MACHINE_TYPE_MCA) {
        ControlData.DescriptorList[z].Flags = LEVEL_SENSITIVE;
    } else {

        //
        // For EISA the LevelTriggered is temporarily set to FALSE.
        //

        ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    }

    Controller->ConfigurationData =
                        HwSetUpResourceDescriptor(Component,
                                                  NULL,
                                                  &ControlData,
                                                  0,
                                                  NULL
                                                  );

    //
    // Set up Keyboard peripheral component
    //

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                       sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &CurrentEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = KeyboardPeripheral;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    CurrentEntry->ConfigurationData = (PVOID)NULL;
    Length = strlen(KeyboardIdentifier[KeyboardId]) + 1;
    Component->IdentifierLength = Length;
    Component->Identifier = BlAllocateHeap(Length);
    strcpy(Component->Identifier, KeyboardIdentifier[KeyboardId]);

    if (KeyboardId != UNKNOWN_KEYBOARD) {

        Length = sizeof(HWRESOURCE_DESCRIPTOR_LIST) +
                 sizeof(CM_KEYBOARD_DEVICE_DATA);
        DescriptorList = (PHWRESOURCE_DESCRIPTOR_LIST)BlAllocateHeap(Length);
        CurrentEntry->ConfigurationData = DescriptorList;
        Component->ConfigurationDataLength = Length;
        DescriptorList->Count = 1;
        DescriptorList->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
        DescriptorList->PartialDescriptors[0].u.DeviceSpecificData.DataSize =
                    sizeof(CM_KEYBOARD_DEVICE_DATA);
        KeyboardData = (CM_KEYBOARD_DEVICE_DATA *)(DescriptorList + 1);
        KeyboardData->KeyboardFlags = 0;
        KeyboardData->Type = KeyboardType[KeyboardId];
        KeyboardData->Subtype = KeyboardSubtype[KeyboardId];
    }

    Controller->Child = CurrentEntry;
    Controller->Sibling = NULL;
    CurrentEntry->Parent = Controller;
    CurrentEntry->Sibling = NULL;
    CurrentEntry->Child = NULL;
    return(Controller);
}

#endif

#if defined(_INCLUDE_LOADER_MOUSEINFO_)

PCONFIGURATION_COMPONENT_DATA
SetMouseConfigurationData (
    PMOUSE_INFORMATION MouseInfo,
    PCONFIGURATION_COMPONENT_DATA MouseList
    )

/*++

Routine Description:

    This routine fills in mouse configuration data.

Arguments:

    MouseInfo - Supplies a pointer to the MOUSE_INFOR structure

    MouseList - Supplies a pointer to the existing mouse component list.

Returns:

    Returns a pointer to our mice controller list.

--*/
{
    UCHAR i = 0;
    PCONFIGURATION_COMPONENT_DATA CurrentEntry, Controller, PeripheralEntry;
    PCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    USHORT z, Length;
    PUCHAR pString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {

        //
        // Initialize Controller data
        //

        ControlData.NumberPortEntries = 0;
        ControlData.NumberIrqEntries = 0;
        ControlData.NumberMemoryEntries = 0;
        ControlData.NumberDmaEntries = 0;
        z = 0;

        //
        // If it is not SERIAL_MOUSE, set up controller component
        //

        Controller = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                     sizeof(CONFIGURATION_COMPONENT_DATA));

        Component = &Controller->ComponentEntry;

        Component->Class = ControllerClass;
        Component->Type = PointerController;
        Component->Flags.Input = 1;
        Component->Version = 0;
        Component->Key = MouseControllerKey;
        MouseControllerKey++;
        Component->AffinityMask = 0xffffffff;
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;

        //
        // If we have mouse irq or port information, allocate configuration
        // data space for mouse controller component to store these information
        //

        if (MouseInfo->MouseIrq != 0xffff || MouseInfo->MousePort != 0xffff) {

            //
            // Set up port and Irq information
            //

            if (MouseInfo->MousePort != 0xffff) {
                ControlData.NumberPortEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_PORT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareDeviceExclusive;
                ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
                ControlData.DescriptorList[z].u.Port.Start.LowPart =
                                        (ULONG)MouseInfo->MousePort;
                ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
                ControlData.DescriptorList[z].u.Port.Length = 4;
                z++;
            }
            if (MouseInfo->MouseIrq != 0xffff) {
                ControlData.NumberIrqEntries = 1;
                ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
                ControlData.DescriptorList[z].ShareDisposition =
                                              CmResourceShareUndetermined;
                ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;
                ControlData.DescriptorList[z].u.Interrupt.Level =
                                        (ULONG)MouseInfo->MouseIrq;
                ControlData.DescriptorList[z].u.Interrupt.Vector =
                                        (ULONG)MouseInfo->MouseIrq;
                if (HwBusType == MACHINE_TYPE_MCA) {
                    ControlData.DescriptorList[z].Flags =
                                                        LEVEL_SENSITIVE;
                } else {

                    //
                    // For EISA the LevelTriggered is temporarily set to FALSE.
                    //

                    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
                }
            }

            Controller->ConfigurationData =
                                HwSetUpResourceDescriptor(Component,
                                                          NULL,
                                                          &ControlData,
                                                          0,
                                                          NULL
                                                          );

        } else {

            //
            // Otherwise, we don't have configuration data for the controller
            //

            Controller->ConfigurationData = NULL;
            Component->ConfigurationDataLength = 0;
        }
    }

    //
    // Set up Mouse peripheral component
    //

    PeripheralEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                       sizeof(CONFIGURATION_COMPONENT_DATA));

    Component = &PeripheralEntry->ComponentEntry;

    Component->Class = PeripheralClass;
    Component->Type = PointerPeripheral;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = 0;
    Component->AffinityMask = 0xffffffff;
    Component->ConfigurationDataLength = 0;
    PeripheralEntry->ConfigurationData = (PVOID)NULL;

    //
    // If Mouse PnP device id is found, translate it to ascii code.
    // (The mouse device id is presented to us by keyboard make code.)
    //

    Length = 0;
    if (MouseInfo->DeviceIdLength != 0) {
        USHORT i;

        if (MouseInfo->MouseSubtype == PS_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                if (MouseInfo->DeviceId[i] > MAX_MAKE_CODE_TRANSLATED) {
                    MouseInfo->DeviceId[i] = '?';
                } else {
                    MouseInfo->DeviceId[i] = MakeToAsciiTable[MouseInfo->DeviceId[i]];
                }
            }
        } else if (MouseInfo->MouseSubtype == SERIAL_MOUSE_WITH_WHEEL) {
            for (i = 0; i < MouseInfo->DeviceIdLength; i++) {
                MouseInfo->DeviceId[i] += 0x20;
            }
        }
        Length = MouseInfo->DeviceIdLength + 3;
    }
    Length += strlen(MouseIdentifier[MouseInfo->MouseType]) +
              strlen(MouseSubidentifier[MouseInfo->MouseSubtype]) + 1;
    pString = (PUCHAR)BlAllocateHeap(Length);
    if (MouseInfo->DeviceIdLength != 0) {
        strcpy(pString, MouseInfo->DeviceId);
        strcat(pString, " - ");
        strcat(pString, MouseIdentifier[MouseInfo->MouseType]);
    } else {
        strcpy(pString, MouseIdentifier[MouseInfo->MouseType]);
    }
    strcat(pString, MouseSubidentifier[MouseInfo->MouseSubtype]);
    Component->IdentifierLength = Length;
    Component->Identifier = pString;

    if ((MouseInfo->MouseSubtype != SERIAL_MOUSE) &&
        (MouseInfo->MouseSubtype != SERIAL_MOUSE_WITH_WHEEL)) {
        Controller->Child = PeripheralEntry;
        PeripheralEntry->Parent = Controller;
        if (MouseList) {

            //
            // Put the current mouse component to the beginning of the list
            //

            Controller->Sibling = MouseList;
        }
        return(Controller);
    } else {
        CurrentEntry = AdapterEntry->Child; // AdapterEntry MUST have child
        while (CurrentEntry) {
            if (CurrentEntry->ComponentEntry.Type == SerialController) {
                if (MouseInfo->MousePort == (USHORT)CurrentEntry->ComponentEntry.Key) {

                    //
                    // For serial mouse, the MousePort field contains
                    // COM port number.
                    //

                    PeripheralEntry->Parent = CurrentEntry;
                    CurrentEntry->Child = PeripheralEntry;
                    break;
                }
            }
            CurrentEntry = CurrentEntry->Sibling;
        }
        return(NULL);
    }
}

PCONFIGURATION_COMPONENT_DATA
GetMouseInformation (
    VOID
    )

/*++

Routine Description:

    This routine is the entry for mouse detection routine.  It will invoke
    lower level routines to detect ALL the mice in the system.

Arguments:

    None.

Returns:

    A pointer to a mouse component structure, if mouse/mice is detected.
    Otherwise a NULL pointer is returned.

--*/
{
    PMOUSE_INFORMATION MouseInfo;
    PCONFIGURATION_COMPONENT_DATA MouseList = NULL;

    MouseInfo = (PMOUSE_INFORMATION)BlAllocateHeap (
                 sizeof(MOUSE_INFORMATION));
    MouseInfo->MouseType = 0x2;            // Microsoft mouse
    MouseInfo->MouseSubtype = PS2_MOUSE;   // PS2 mouse
    MouseInfo->MousePort = 0xffff;         // PS2 mouse port
    MouseInfo->MouseIrq = 0xc;             // Interrupt request vector was 3
    MouseInfo->DeviceIdLength = 0;
    MouseList = SetMouseConfigurationData(MouseInfo, MouseList);
    return(MouseList);
}

#endif // _INCLUDE_LOADER_MOUSEINFO_

#if defined(_INCLUDE_COMPORT_INFO_)
    
//
// This code was taken out because the GetComportInformation() routine
// was manufacturing data about the com port and writing the com port
// address to 40:0.  This information should be determined by PnP
//


PCONFIGURATION_COMPONENT_DATA
GetComportInformation (
    VOID
    )

/*++

Routine Description:

    This routine will attempt to detect the comports information
    for the system.  The information includes port address, irq
    level.

    Note that this routine can only detect up to 4 comports and
    it assumes that if MCA, COM3 and COM4 use irq 4.  Otherwise,
    COM3 uses irq 4 and COM4 uses irq 3.  Also, the number of ports
    for COMPORT is set to 8 (for example, COM2 uses ports 2F8 - 2FF)

Arguments:

    None.

Return Value:

    A pointer to a stucture of type CONFIGURATION_COMPONENT_DATA
    which is the root of comport component list.
    If no comport exists, a value of NULL is returned.

--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry, PreviousEntry = NULL;
    PCONFIGURATION_COMPONENT_DATA FirstComport = NULL;
    PCONFIGURATION_COMPONENT Component;
    HWCONTROLLER_DATA ControlData;
    UCHAR i, j, z;
    SHORT Port;
    UCHAR ComportName[] = "COM?";
    CM_SERIAL_DEVICE_DATA SerialData;
    ULONG BaudClock = 1843200;
    USHORT Vector;
    USHORT IoPorts[MAX_COM_PORTS] = {0x3f8, 0x2f8, 0x3e8, 0x2e8};


    //
    // BIOS DATA area 40:0 is the port address of the first valid COM port
    //

    USHORT *pPortAddress = (USHORT *)0x00400000;

    //
    // Initialize serial device specific data
    //

    SerialData.Version = 0;
    SerialData.Revision = 0;
    SerialData.BaudClock = 1843200;

    //
    // Initialize Controller data
    //

    ControlData.NumberPortEntries = 0;
    ControlData.NumberIrqEntries = 0;
    ControlData.NumberMemoryEntries = 0;
    ControlData.NumberDmaEntries = 0;
    z = 0;
    i = 0;

    Port = IoPorts[i];
    *(pPortAddress+i) = (USHORT)Port;


    //
    // Remember the port address in our global variable
    // such that other detection code (e.g. Serial Mouse) can
    // get the information.
    //

#if 0 // unused
    ComPortAddress[i] = Port;
#endif

    CurrentEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap (
                   sizeof(CONFIGURATION_COMPONENT_DATA));
    if (!FirstComport) {
        FirstComport = CurrentEntry;
    }
    Component = &CurrentEntry->ComponentEntry;

    Component->Class = ControllerClass;
    Component->Type = SerialController;
    Component->Flags.ConsoleOut = 1;
    Component->Flags.ConsoleIn = 1;
    Component->Flags.Output = 1;
    Component->Flags.Input = 1;
    Component->Version = 0;
    Component->Key = i;
    Component->AffinityMask = 0xffffffff;

    //
    // Set up type string.
    //

    ComportName[3] = i + (UCHAR)'1';

    //
    // Set up Port information
    //

    ControlData.NumberPortEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_PORT;
    ControlData.DescriptorList[z].ShareDisposition =
                                          CmResourceShareDeviceExclusive;
    ControlData.DescriptorList[z].Flags = CM_RESOURCE_PORT_IO;
    ControlData.DescriptorList[z].u.Port.Start.LowPart = (ULONG)Port;
    ControlData.DescriptorList[z].u.Port.Start.HighPart = 0;
    ControlData.DescriptorList[z].u.Port.Length = 8;
    z++;

    //
    // Set up Irq information
    //

    ControlData.NumberIrqEntries = 1;
    ControlData.DescriptorList[z].Type = RESOURCE_INTERRUPT;
    ControlData.DescriptorList[z].ShareDisposition =
                                  CmResourceShareUndetermined;
    //
    // For EISA the LevelTriggered is temporarily set to FALSE.
    // COM1 and COM3 use irq 4; COM2 and COM4 use irq3
    //

    ControlData.DescriptorList[z].Flags = EDGE_TRIGGERED;
    if (Port == 0x3f8 || Port == 0x3e8) {
        ControlData.DescriptorList[z].u.Interrupt.Level = 4;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
    } else if (Port == 0x2f8 || Port == 0x2e8) {
        ControlData.DescriptorList[z].u.Interrupt.Level = 3;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
    } else if (i == 0 || i == 2) {
        ControlData.DescriptorList[z].u.Interrupt.Level = 4;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 4;
    } else {
        ControlData.DescriptorList[z].u.Interrupt.Level = 3;
        ControlData.DescriptorList[z].u.Interrupt.Vector = 3;
    }

    ControlData.DescriptorList[z].u.Interrupt.Affinity = ALL_PROCESSORS;

    //
    // Try to determine the interrupt vector.  If we success, the
    // new vector will be used to replace the default value.
    //

    CurrentEntry->ConfigurationData =
                    HwSetUpResourceDescriptor(Component,
                                              ComportName,
                                              &ControlData,
                                              sizeof(SerialData),
                                              (PUCHAR)&SerialData
                                              );
    if (PreviousEntry) {
        PreviousEntry->Sibling = CurrentEntry;
    }
    PreviousEntry = CurrentEntry;

    return(FirstComport);
}
#endif


PVOID
HwSetUpResourceDescriptor (
    PCONFIGURATION_COMPONENT Component,
    PUCHAR Identifier,
    PHWCONTROLLER_DATA ControlData,
    USHORT SpecificDataLength,
    PUCHAR SpecificData
    )

/*++

Routine Description:

    This routine allocates space from heap , puts the caller's controller
    information to the space and sets up CONFIGURATION_COMPONENT
    structure for the caller.

Arguments:

    Component - Supplies the address the component whose configuration data
                should be set up.

    Identifier - Suppies a pointer to the identifier to identify the controller

    ControlData - Supplies a point to a structure which describes
                controller information.

    SpecificDataLength - size of the device specific data.  Device specific
                data is the information not defined in the standard format.

    SpecificData - Supplies a pointer to the device specific data.


Return Value:

    Returns a pointer to the Configuration data.

--*/

{
    PCHAR pIdentifier;
    PHWRESOURCE_DESCRIPTOR_LIST pDescriptor = NULL;
    USHORT Length;
    SHORT Count, i;
    PUCHAR pSpecificData;

    //
    // Set up Identifier string for hardware component, if necessary.
    //

    if (Identifier) {
        Length = RESET_SIZE_AT_USHORT_MAX(strlen((PCHAR)Identifier) + 1);
        Component->IdentifierLength = Length;
        pIdentifier = (PCHAR)BlAllocateHeap(Length);
        Component->Identifier = pIdentifier;
        strcpy(pIdentifier, (PCHAR)Identifier);
    } else {
        Component->IdentifierLength = 0;
        Component->Identifier = NULL;
    }

    //
    // Set up configuration data for hardware component, if necessary
    //

    Count = ControlData->NumberPortEntries + ControlData->NumberIrqEntries +
            ControlData->NumberMemoryEntries + ControlData->NumberDmaEntries;

    if (SpecificDataLength) {

        //
        // if we have device specific data, we need to increment the count
        // by one.
        //

        Count++;
    }

    if (Count >0) {
        Length = (USHORT)(Count * sizeof(HWPARTIAL_RESOURCE_DESCRIPTOR) +
                 FIELD_OFFSET(HWRESOURCE_DESCRIPTOR_LIST, PartialDescriptors) +
                 SpecificDataLength);
        pDescriptor = (PHWRESOURCE_DESCRIPTOR_LIST)BlAllocateHeap(Length);
        pDescriptor->Count = Count;

        //
        // Copy all the partial descriptors to the destination descriptors
        // except the last one. (The last partial descriptor may be a device
        // specific data.  It requires special handling.)
        //

        for (i = 0; i < (Count - 1); i++) {
            pDescriptor->PartialDescriptors[i] =
                                        ControlData->DescriptorList[i];
        }

        //
        // Set up the last partial descriptor.  If it is a port, memory, irq or
        // dma entry, we simply copy it.  If the last one is for device specific
        // data, we set up the length and copy the device spcific data to the end
        // of the decriptor.
        //

        if (SpecificData) {
            pDescriptor->PartialDescriptors[Count - 1].Type =
                            RESOURCE_DEVICE_DATA;
            pDescriptor->PartialDescriptors[Count - 1].Flags = 0;
            pDescriptor->PartialDescriptors[Count - 1].u.DeviceSpecificData.DataSize =
                            SpecificDataLength;
            pSpecificData = (PUCHAR)&(pDescriptor->PartialDescriptors[Count]);
            RtlCopyMemory( pSpecificData, SpecificData, SpecificDataLength);
        } else {
            pDescriptor->PartialDescriptors[Count - 1] =
                            ControlData->DescriptorList[Count - 1];
        }
        Component->ConfigurationDataLength = Length;
    }
    return(pDescriptor);
}

VOID
HwSetUpFreeFormDataHeader (
    PHWRESOURCE_DESCRIPTOR_LIST Header,
    USHORT Version,
    USHORT Revision,
    USHORT Flags,
    ULONG DataSize
    )

/*++

Routine Description:

    This routine initialize free formed data header.  Note this routine
    sets the the Header and initialize the FIRST PartialDescriptor only.
    If the header contains more than one descriptor, the caller must handle
    it itself.

Arguments:

    Header - Supplies a pointer to the header to be initialized.

    Version - Version number for the header.

    Revision - Revision number for the header.

    Flags - Free formed data flags.  (Currently, it is undefined and
                should be zero.)

    DataSize - Size of the free formed data.


Return Value:

    None.

--*/

{

    Header->Version = Version;
    Header->Revision = Revision;
    Header->Count = 1;
    Header->PartialDescriptors[0].Type = RESOURCE_DEVICE_DATA;
    Header->PartialDescriptors[0].ShareDisposition = 0;
    Header->PartialDescriptors[0].Flags = Flags;
    Header->PartialDescriptors[0].u.DeviceSpecificData.DataSize = DataSize;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved1 = 0;
    Header->PartialDescriptors[0].u.DeviceSpecificData.Reserved2 = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\biosdrv.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosdrv.h

Abstract:

    This module defines globally used procedure and data structures used be
    the ARC emulation BIOS drivers.

Author:

    John Vert (jvert) 8-Aug-1991

Revision History:

    Allen Kay (akay) 26-Jan-1996          Ported for IA64

--*/


//
// Defines for the ARC name of console input and output
//

#define CONSOLE_INPUT_NAME "multi(0)key(0)keyboard(0)"
#define CONSOLE_OUTPUT_NAME "multi(0)video(0)monitor(0)"

//
// Define special character values.
//

#define ASCI_NUL 0x00
#define ASCI_BEL 0x07
#define ASCI_BS  0x08
#define ASCI_HT  0x09
#define ASCI_LF  0x0A
#define ASCI_VT  0x0B
#define ASCI_FF  0x0C
#define ASCI_CR  0x0D
#define ASCI_CSI 0x9B
#define ASCI_ESC 0x1B
#define ASCI_SYSRQ 0x80

//
// Define special key input values
//
#define DOWN_ARROW 0x5000
#define UP_ARROW 0x4800
#define HOME_KEY 0x4700
#define END_KEY 0x4F00



//
// Device I/O prototypes
//

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    );

ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );


ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleRead (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosConsoleWrite (
    IN ULONG FileId,
    OUT PWCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosDiskRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    );

ULONG
GetDriveCount(
    VOID
    );

EFI_HANDLE
GetCd(
    );

EFI_HANDLE
GetHardDrive(
    ULONG DriveId
    );

EFI_HANDLE
GetFloppyDrive(
    ULONG DriveId
    );


//
// constants for BlGetDriveId.DriveType
//
#define BL_DISKTYPE_ATAPI               0x00000001
#define BL_DISKTYPE_SCSI                0x00000002
#define BL_DISKTYPE_UNKNOWN             0x00000003


ULONG
BlGetDriveId(
    ULONG DriveType,
    PBOOT_DEVICE Device
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\acpidtct.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    acpidtct.c

Abstract:

    This module peruses the ACPI tables looking for specific
    entries.

Author:

    Matt Holle (matth)  (shamefully stolen from jakeo's x86 code)

Environment:


Revision History:
    

--*/
#include "stdlib.h"
#include "string.h"
#include "bldr.h"
#include "acpitabl.h"
#include "efi.h"
#include "extern.h"

PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    )
/*++

Routine Description:

    Given a table name, finds that table in the ACPI BIOS

Arguments:

    TableName - Supplies the table name

    TableLength - Supplies the length of the table to map

Return Value:

    Pointer to the table if found

    NULL if the table is not found
    
Note:

    This function is not capable of returning a pointer to
    a table with a signature of DSDT.  But that's never necessary
    in the loader.  If the loader ever incorporates an AML
    interpreter, this will have to be enhanced.    

--*/

{
    ULONG Signature;
    PDESCRIPTION_HEADER Header;
    ULONG TableCount;
    ULONG i;
    PXSDT xsdt = NULL;
    PRSDP rsdp = (PRSDP)AcpiTable;

    UNREFERENCED_PARAMETER( TableLength );

    //DbgPrint("Hunting for table %s\n", TableName);

    //
    // Sanity Check.
    //
    
    if (rsdp) {
        
        //DbgPrint("Looking through 2.0 RSDP: %p\n", rsdp20);
        xsdt = (PVOID)rsdp->XsdtAddress.QuadPart;
        if (xsdt->Header.Signature != XSDT_SIGNATURE) {
            
            //
            // Found ACPI 2.0 tables, but the signature
            // is garbage.
            //

            return NULL;
        }
    
    } else {
        
        //
        // Didn't find any tables at all.
        //

        return NULL;
    }

    
    Signature = *((ULONG UNALIGNED *)TableName);

    //
    // If they want the root table, we've already got that.
    //
    if (Signature == XSDT_SIGNATURE) {

        return(&xsdt->Header);

    } else {

        TableCount = NumTableEntriesFromXSDTPointer(xsdt);

        //DbgPrint("xSDT contains %d tables\n", TableCount);

        //
        // Sanity check.
        //
        if( TableCount > 0x100 ) {
            return(NULL);
        }

        //
        // Dig.
        //
        for (i=0;i<TableCount;i++) {

            Header = (PDESCRIPTION_HEADER)(xsdt->Tables[i].QuadPart);

            if (Header->Signature == Signature) {

                //DbgPrint("Table Address: %p\n", Header);
                return(Header);
            }
        }
    }

    //DbgPrint("Table not found\n");
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\arcemul.c ===
/*++


Copyright (c) 1991  Microsoft Corporation

Module Name:

    arcemul.c

Abstract:

    This module provides the x86 emulation for the Arc routines which are
    built into the firmware on ARC machines.

    N. B.   This is where all the initialization of the SYSTEM_PARAMETER_BLOCK
            takes place.  If there is any non-standard hardware, some of the
            vectors may have to be changed.  This is where to do it.


Author:

    Allen Kay (akay) 26-Jan-1996

    Base on i386 version by John Vert (jvert) 13-Jun-1991

Environment:

    EFI

Revision History:

--*/

#include "arccodes.h"
#include "bootia64.h"
#include "ntdddisk.h"
#include "string.h"
#include "stdio.h"
#include "stdlib.h"
#include "scsi.h"
#include "scsiboot.h"
#include "ramdisk.h"

#define CMOS_CONTROL_PORT ((PUCHAR)0x70)
#define CMOS_DATA_PORT    ((PUCHAR)0x71)
#define CMOS_STATUS_B     0x0B
#define CMOS_DAYLIGHT_BIT 1

extern PCHAR MnemonicTable[];

//
// Size definitions for HardDiskInitialize()
//

#define SUPPORTED_NUMBER_OF_DISKS 32
#define SIZE_FOR_SUPPORTED_DISK_STRUCTURE (SUPPORTED_NUMBER_OF_DISKS*sizeof(DRIVER_LOOKUP_ENTRY))


PDRIVER_UNLOAD AEDriverUnloadRoutine = NULL;


#define PORT_BUFFER_SIZE 10
UCHAR PortBuffer[PORT_BUFFER_SIZE];
ULONG PortBufferStart = 0;
ULONG PortBufferEnd = 0;

//
// Miniport DriverEntry typedef
//

typedef NTSTATUS
(*PDRIVER_ENTRY) (
    IN PVOID DriverObject,
    IN PVOID Parameter2
    );

//
// Private function prototypes
//

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

PCONFIGURATION_COMPONENT
AEComponentInfo(
    IN PCONFIGURATION_COMPONENT Current
    );

PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    );

PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    );

PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    );

PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    );

ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    );

PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    );

ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
AEClose(
    IN ULONG FileId
    );

ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEReadStatus (
    IN ULONG FileId
    );

VOID
AEReboot(
    VOID
    );

ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    );

PTIME_FIELDS
AEGetTime(
    VOID
    );

ULONG
AEGetRelativeTime(
    VOID
    );

ARC_STATUS
ScsiDiskClose (
    IN ULONG FileId
    );

ARC_STATUS
ScsiDiskMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
ScsiDiskOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
ScsiDiskRead (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
ScsiDiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
ScsiDiskWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

VOID
HardDiskInitialize(
    IN OUT PVOID LookupTable,
    IN ULONG Entries,
    IN PVOID DeviceFoundCallback
    );

//
// This is the x86 version of the system parameter block on the ARC machines.
// It lives here, and any module that uses an ArcXXXX routine must declare
// it external.  Machines that have other than very plain-vanilla hardware
// may have to replace some of the hard-wired vectors with different
// procedures.
//

PVOID GlobalFirmwareVectors[MaximumRoutine];

SYSTEM_PARAMETER_BLOCK GlobalSystemBlock =
    {
        0,                              // Signature??
        sizeof(SYSTEM_PARAMETER_BLOCK), // Length
        0,                              // Version
        0,                              // Revision
        NULL,                           // RestartBlock
        NULL,                           // DebugBlock
        NULL,                           // GenerateExceptionVector
        NULL,                           // TlbMissExceptionVector
        MaximumRoutine,                 // FirmwareVectorLength
        GlobalFirmwareVectors,          // Pointer to vector block
        0,                              // VendorVectorLength
        NULL                            // Pointer to vendor vector block
    };


extern BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

//
// temptemp John Vert (jvert) 6-Sep-1991
//      Just do this until we can make our device driver interface look
//      like the ARC firmware one.
//

extern BL_DEVICE_ENTRY_TABLE ScsiDiskEntryTable;

ULONG FwStallCounter;


VOID
AEInitializeStall(
    VOID
    )
{
    FwStallCounter = GET_STALL_COUNT();
    return;
}

#if !defined(NO_LEGACY_DRIVERS)


ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    )

/*++

Routine Description:

    Initializes SCSI boot driver, if any.  Loads ntbootdd.sys from the
    boot partition, binds it to the osloader, and initializes it.

Arguments:

    DriveId - file id of the opened boot partition

Return Value:

    ESUCCESS - Drivers successfully initialized

--*/

{
    extern ULONG ScsiPortCount;
    extern ULONG MachineType;
    ARC_STATUS Status;
    PVOID Buffer;
    PVOID ImageBase;
    PLDR_DATA_TABLE_ENTRY DriverDataTableEntry;
    PDRIVER_ENTRY Entry;    
    ULONG i;
    ULONG ImageBasePage;

    ScsiPortCount = 0;

    FwStallCounter = GET_STALL_COUNT();
    Status = BlLoadImage(DriveId,
                         MemoryFirmwarePermanent,
                         "\\NTBOOTDD.SYS",
                         TARGET_IMAGE,
                         &ImageBase);
    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = BlAllocateDataTableEntry("NTBOOTDD.SYS",
                                      "\\NTBOOTDD.SYS",
                                      ImageBase,
                                      &DriverDataTableEntry);
    if (Status != ESUCCESS) {
        return(Status);
    }
    //
    // Scan the import table and bind to osloader
    //
    Status = BlScanOsloaderBoundImportTable(DriverDataTableEntry);
    if (Status != ESUCCESS) {
        return(Status);
    }

    Entry = (PDRIVER_ENTRY)DriverDataTableEntry->EntryPoint;

    Status = (*Entry)(NULL,NULL);
    if (Status == ESUCCESS) {
        //
        // Find the firmware's copy of the memory descriptor that
        // contains the driver and change it from MemoryFree to
        // MemoryFirmwareTemporary.
        //
        ImageBasePage = ((PtrToUlong(ImageBase) & 0x7fffffff) >> PAGE_SHIFT);
        i=0;
        while ((MDArray[i].BasePage >= ImageBasePage) ||
               (MDArray[i].BasePage + MDArray[i].PageCount < ImageBasePage)) {
            i++;
        }

        MDArray[i].MemoryType = MemoryFirmwareTemporary;

        Buffer = BlAllocateHeap(SIZE_FOR_SUPPORTED_DISK_STRUCTURE);

        if(Buffer == NULL) {
            return ENOMEM;
        }

        HardDiskInitialize(Buffer, SUPPORTED_NUMBER_OF_DISKS, NULL);
    }
    return(Status);
}

#endif // NO_LEGACY_DRIVERS


VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    This routine fills in all the fields in the Global System Parameter Block
    that it can.  This includes all the firmware vectors, the vendor-specific
    information, and anything else that may come up.

Arguments:

    None.


Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( BootContextRecord );

    //
    // Fill in the pointers to the firmware functions which we emulate.
    // Those which we don't emulate are stubbed by BlArcNotYetImplemented,
    // which will print an error message if it is accidentally called.
    //

    //FIRMWARE_VECTOR_BLOCK->LoadRoutine               = (PARC_LOAD_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->InvokeRoutine             = (PARC_INVOKE_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->ExecuteRoutine            = (PARC_EXECUTE_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->HaltRoutine               = (PARC_HALT_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->PowerDownRoutine          = (PARC_POWERDOWN_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->InteractiveModeRoutine    = (PARC_INTERACTIVE_MODE_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->AddChildRoutine           = (PARC_ADD_CHILD_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->SaveConfigurationRoutine  = (PARC_SAVE_CONFIGURATION_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->GetSystemIdRoutine        = (PARC_GET_SYSTEM_ID_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->MountRoutine              = (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->SetFileInformationRoutine = (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->GetDirectoryEntryRoutine  = (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->SetEnvironmentRoutine     = (PARC_SET_ENVIRONMENT_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->FlushAllCachesRoutine     = (PARC_FLUSH_ALL_CACHES_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->TestUnicodeCharacterRoutine = (PARC_TEST_UNICODE_CHARACTER_ROUTINE)BlArcNotYetImplemented;
    FIRMWARE_VECTOR_BLOCK->GetDisplayStatusRoutine   = (PARC_GET_DISPLAY_STATUS_ROUTINE)BlArcNotYetImplemented;
    //FIRMWARE_VECTOR_BLOCK->DeleteComponentRoutine    = (PARC_DELETE_COMPONENT_ROUTINE)BlArcNotYetImplemented;
    
    FIRMWARE_VECTOR_BLOCK->CloseRoutine              = AEClose;
    FIRMWARE_VECTOR_BLOCK->OpenRoutine               = AEOpen;

    FIRMWARE_VECTOR_BLOCK->MemoryRoutine             = AEGetMemoryDescriptor;
    FIRMWARE_VECTOR_BLOCK->SeekRoutine               = AESeek;
    FIRMWARE_VECTOR_BLOCK->ReadRoutine               = AERead;
    FIRMWARE_VECTOR_BLOCK->ReadStatusRoutine         = AEReadStatus;
    FIRMWARE_VECTOR_BLOCK->WriteRoutine              = AEWrite;
    FIRMWARE_VECTOR_BLOCK->GetFileInformationRoutine = AEGetFileInformation;
    FIRMWARE_VECTOR_BLOCK->GetTimeRoutine            = AEGetTime;
    FIRMWARE_VECTOR_BLOCK->GetRelativeTimeRoutine    = AEGetRelativeTime;

    FIRMWARE_VECTOR_BLOCK->GetPeerRoutine            = FwGetPeer;
    FIRMWARE_VECTOR_BLOCK->GetChildRoutine           = FwGetChild;
    FIRMWARE_VECTOR_BLOCK->GetParentRoutine          = AEGetParent;
    FIRMWARE_VECTOR_BLOCK->GetComponentRoutine       = FwGetComponent;
    FIRMWARE_VECTOR_BLOCK->GetDataRoutine            = AEGetConfigurationData;
    FIRMWARE_VECTOR_BLOCK->GetEnvironmentRoutine     = AEGetEnvironment;

    FIRMWARE_VECTOR_BLOCK->RestartRoutine            = AEReboot;
    FIRMWARE_VECTOR_BLOCK->RebootRoutine             = AEReboot;
    
}


PMEMORY_DESCRIPTOR
AEGetMemoryDescriptor(
    IN PMEMORY_DESCRIPTOR MemoryDescriptor OPTIONAL
    )

/*++

Routine Description:

    Emulates the Arc GetMemoryDescriptor call.  This must translate
    between the memory description passed to us by the SU module and
    the MEMORYDESCRIPTOR type defined by ARC.

Arguments:

    MemoryDescriptor - Supplies current memory descriptor.
        If MemoryDescriptor==NULL, return the first memory descriptor.
        If MemoryDescriptor!=NULL, return the next memory descriptor.

Return Value:

    Next memory descriptor in the list.
    NULL if MemoryDescriptor is the last descriptor in the list.

--*/

{
    extern ULONG NumberDescriptors;
    PMEMORY_DESCRIPTOR Return;
    if (MemoryDescriptor==NULL) {
        Return=MDArray;
    } else {
        if((ULONG)(MemoryDescriptor-MDArray) >= (NumberDescriptors-1)) {
            return NULL;
        } else {
            Return = ++MemoryDescriptor;
        }
    }
    return(Return);

}


ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    )

/*++

Routine Description:

    This is a stub routine used to fill in the firmware vectors which haven't
    been defined yet.  It uses BlPrint to print a message on the screen.

Arguments:

    None.

Return Value:

    EINVAL

--*/

{
#if DBG
    BlPrint(TEXT("ERROR - Unimplemented Firmware Vector called (FID %lx)\r\n"),
            FileId );
#else 
    UNREFERENCED_PARAMETER( FileId );
#endif
    return(EINVAL);
}


PCONFIGURATION_COMPONENT
FwGetChild(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetChild.  Based on the current
    component, it returns the component's child component.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;

    //
    // if current component is NULL, return a pointer to first system
    // component; otherwise return current component's child component.
    //

    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Child) {
            return(&(CurrentEntry->Child->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        if (FwConfigurationTree) {
            return(&(FwConfigurationTree->ComponentEntry));
        } else {
            return(NULL);
        }
    }

}


PCONFIGURATION_COMPONENT
FwGetPeer(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetPeer.  Based on the current
    component, it returns the component's sibling.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Sibling) {
            return(&(CurrentEntry->Sibling->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


PCONFIGURATION_COMPONENT
AEGetParent(
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    A pointer to a CONFIGURATION_COMPONENT structure OR
    NULL - No more configuration information


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        if (CurrentEntry->Parent) {
            return(&(CurrentEntry->Parent->ComponentEntry));
        } else {
            return(NULL);
        }
    } else {
        return(NULL);
    }

}


ARC_STATUS
AEGetConfigurationData(
    IN PVOID ConfigurationData,
    IN PCONFIGURATION_COMPONENT Current
    )

/*++

Routine Description:

    This is the arc emulation routine for GetParent.  Based on the current
    component, it returns the component's parent.

Arguments:

    Current - Supplies pointer to the current configuration component

Return Value:

    ESUCCESS - Data successfully returned.


--*/

{
    PCONFIGURATION_COMPONENT_DATA CurrentEntry;


    if (Current) {
        CurrentEntry = CONTAINING_RECORD(Current,
                                         CONFIGURATION_COMPONENT_DATA,
                                         ComponentEntry);
        RtlMoveMemory(ConfigurationData,
                      CurrentEntry->ConfigurationData,
                      Current->ConfigurationDataLength);
        return(ESUCCESS);
    } else {
        return(EINVAL);
    }

}


PCHAR
AEGetEnvironment(
    IN PCHAR Variable
    )

/*++

Routine Description:

    This is the arc emulation routine for ArcGetEnvironment.  It returns
    the value of the specified NVRAM environment variable.

    NOTE John Vert (jvert) 23-Apr-1992
        This particular implementation uses the Daylight Savings Bit on
        the Real Time Clock to reflect the state of the LastKnownGood
        environment variable.  This is the only variable we support.

Arguments:

    Variable - Supplies the name of the environment variable to look up.

Return Value:

    A pointer to the specified environment variable's value, or
    NULL if the variable does not exist.

--*/

{
#if 1
    UNREFERENCED_PARAMETER( Variable );

    //
    // Until firmware implements LastKnownGood variable,
    // return NULL for now.
    //

    return(NULL);

#else
    UCHAR StatusByte;

    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return(NULL);
    }

    //
    // Read the Daylight Savings Bit out of the RTC to determine whether
    // the LastKnownGood environment variable is TRUE or FALSE.
    //

    WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
    StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);
    if (StatusByte & CMOS_DAYLIGHT_BIT) {
        return("TRUE");
    } else {
        return(NULL);
    }

#endif
}


ARC_STATUS
AEOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the file or device specified by OpenPath.

Arguments:

    OpenPath - Supplies a pointer to the fully-qualified path name.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
#if !defined(NO_LEGACY_DRIVERS)
    CHAR Buffer[128];
#endif

    Status = RamdiskOpen( OpenPath,
                          OpenMode,
                          FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    Status = BiosConsoleOpen( OpenPath,
                              OpenMode,
                              FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

    Status = BiosPartitionOpen( OpenPath,
                                OpenMode,
                                FileId );

    if (Status == ESUCCESS) {
        return(ESUCCESS);
    }

#if !defined(NO_LEGACY_DRIVERS)

    //
    // It's not the console or a BIOS partition, so let's try the SCSI
    // driver.
    //

    //
    // Find a free FileId
    //

    *FileId = 2;
    while (BlFileTable[*FileId].Flags.Open == 1) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    strcpy(Buffer,OpenPath);

    Status = ScsiDiskOpen( Buffer,
                           OpenMode,
                           FileId );

    if (Status == ESUCCESS) {

        //
        // SCSI successfully opened it.  For now, we stick the appropriate
        // SCSI DeviceEntryTable into the BlFileTable.  This is temporary.
        //

        BlFileTable[*FileId].Flags.Open = 1;
        BlFileTable[*FileId].DeviceEntryTable = &ScsiDiskEntryTable;
        return(ESUCCESS);
    }

#endif // NO_LEGACY_DRIVERS

    return(Status);
}


ARC_STATUS
AESeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    return(BlFileTable[FileId].DeviceEntryTable->Seek)( FileId,
                                                        Offset,
                                                        SeekMode );
}


ARC_STATUS
AEClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the file specified by FileId

Arguments:

    FileId - specifies the file to close

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{

    return(BlFileTable[FileId].DeviceEntryTable->Close)(FileId);

}


ARC_STATUS
AEReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    Determines if data is available on the specified device

Arguments:

    FileId - Specifies the device to check for data.

Return Value:

    ESUCCESS - At least one byte is available.

    EAGAIN - No data is available

--*/

{
    //
    // Special case for console input
    //

    if (FileId == 0) {
#if 0
        //
        // Give priority to dumb terminal
        //
        if (BlIsTerminalConnected() && (PortBufferStart != PortBufferEnd)) {
            return(ESUCCESS);
        }

        if (BlIsTerminalConnected() && (BlPortPollOnly(BlTerminalDeviceId) == CP_GET_SUCCESS)) {
            return(ESUCCESS);
        }
#endif
        return(BiosConsoleReadStatus(FileId));
    } else {
        return(BlArcNotYetImplemented(FileId));
    }

}


ARC_STATUS
AERead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file or device

Arguments:

    FileId - specifies the file to read from

    Buffer - Address of buffer to hold the data that is read

    Length - Maximum number of bytes to read

    Count -  Address of location in which to store the actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;

    //
    // Special case for console input
    //

    if (FileId == 0) {

RetryRead:
#if 0
        if (BlIsTerminalConnected()) {

            UCHAR Ch;
            ULONG StartTime;
            PCHAR TmpBuffer;
            ULONG LastTime;

            *Count = 0;
            TmpBuffer = (PCHAR)Buffer;

            while (*Count < Length) {

                //
                // First return any buffered input
                //
                if (PortBufferStart != PortBufferEnd) {
                    TmpBuffer[*Count] = PortBuffer[PortBufferStart];
                    PortBufferStart++;
                    PortBufferStart = PortBufferStart % PORT_BUFFER_SIZE;
                    *Count = *Count + 1;
                    continue;
                }

                //
                // Now check for new input
                //
                if (BlPortPollByte(BlTerminalDeviceId, TmpBuffer + *Count) != CP_GET_SUCCESS) {
                    break;
                }

                //
                // Convert ESC key to the local equivalent
                //
                if (TmpBuffer[*Count] == 0x1b) {
                    TmpBuffer[*Count] = (CHAR)ASCI_CSI_IN;

                    //
                    // Wait for the user to type a key.
                    //
                    StartTime = AEGetRelativeTime();

                    while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                        LastTime = AEGetRelativeTime();

                        //
                        // if the counter wraps back to zero, just restart the wait.
                        //
                        if (LastTime < StartTime) {
                            StartTime = LastTime;
                        }

                        //
                        // If one second has passed, the user must have just wanted a single
                        // escape key, so return with that.
                        //
                        if ((LastTime - StartTime) > 1) {
                            *Count = *Count + 1;
                            return (ESUCCESS);
                        }

                    }

                    //
                    // We have another key, get it and translate the escape sequence.
                    //
                    if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                        *Count = *Count + 1;
                        return (ESUCCESS);
                    }


                    switch (Ch) {
                    case '@': // F12 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'B';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '!': // F11 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'A';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '0': // F10 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'M';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '8': // F8 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'r';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '6': // F6 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'u';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '5': // F5 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 't';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '3': // F3 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'w';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '1': // F1 key
                        PortBuffer[PortBufferEnd] = 'O';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        PortBuffer[PortBufferEnd] = 'P';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '+': // Home key
                        PortBuffer[PortBufferEnd] = 'H';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '-': // End key
                        PortBuffer[PortBufferEnd] = 'K';
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;

                    case '[': // Cursor movement key

                        //
                        // The local computer can run a lot faster than the serial port can give bytes,
                        // so spin, polling, for a second.
                        //
                        StartTime = AEGetRelativeTime();
                        while (BlPortPollOnly(BlTerminalDeviceId) != CP_GET_SUCCESS) {
                            LastTime = AEGetRelativeTime();

                            //
                            // if the counter wraps back to zero, just restart the wait.
                            //
                            if (LastTime < StartTime) {
                                StartTime = LastTime;
                            }

                            //
                            // If one second has passed, we must be done.
                            //
                            if ((LastTime - StartTime) > 1) {
                                break;
                            }

                        }

                        if (BlPortPollByte(BlTerminalDeviceId, &Ch) != CP_GET_SUCCESS) {
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;                            
                            break;
                        }

                        if ((Ch == 'A') || (Ch == 'B') || (Ch == 'C') || (Ch == 'D')) { // Arrow key.

                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;

                        } else { 

                            //
                            // Leave it as is
                            //
                            PortBuffer[PortBufferEnd] = '[';
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                            PortBuffer[PortBufferEnd] = Ch;
                            PortBufferEnd++;
                            PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        }
                        break;

                    default:
                        PortBuffer[PortBufferEnd] = Ch;
                        PortBufferEnd++;
                        PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                        break;
                    }

                } else if (TmpBuffer[*Count] == 0x7F) { // DEL key
                    TmpBuffer[*Count] = (CHAR)ASCI_CSI_IN;
                    PortBuffer[PortBufferEnd] = 'P';
                    PortBufferEnd++;
                    PortBufferEnd = PortBufferEnd % PORT_BUFFER_SIZE;
                }

                *Count = *Count + 1;
            }

            if (*Count != 0) {
                return(ESUCCESS);
            }
            
        }
#endif

        if (BiosConsoleReadStatus(FileId) == ESUCCESS) {
            return(BiosConsoleRead(FileId,Buffer,Length,Count));
        }

        goto RetryRead;

    } else {

        *Count = 0;

        do {

            if ((PtrToUlong(Buffer) & 0xffff0000) !=
               ((PtrToUlong(Buffer) + Length) & 0xffff0000)) {

                Limit = 0x10000 - (PtrToUlong(Buffer) & 0x0000ffff);
            } else {

                Limit = Length;

            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Read)( FileId,
                                                                Buffer,
                                                                Limit,
                                                                &PartCount  );
            *Count += PartCount;
            Length -= Limit;
            Buffer = (PCHAR) Buffer + Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint(TEXT("Disk I/O error: Status = %lx\r\n"),Status);
#endif                
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}


ARC_STATUS
AEWrite (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file or device

Arguments:

    FileId - Supplies the file or device to write to

    Buffer - Supplies address of the data to be written

    Length - Supplies number of bytes to write

    Count -  Address of location in which to store the actual bytes written.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    ULONG Limit;
    ULONG PartCount;

    //
    // Special case for console output
    //

    if (FileId == 1) {

#if 0
        PCHAR TmpBuffer;
        
        if (BlIsTerminalConnected()) {
            for (PartCount = 0, TmpBuffer = (PCHAR)Buffer; PartCount < Length; PartCount++) {
                BlPortPutByte(BlTerminalDeviceId, TmpBuffer[PartCount]);
            }
        }
#endif

        return(BiosConsoleWrite(FileId,(PWCHAR)Buffer,Length,Count));
    } else {
        *Count = 0;

        do {

            if ((PtrToUlong(Buffer) & 0xffff0000) !=
               ((PtrToUlong(Buffer) + Length) & 0xffff0000)) {

                Limit = 0x10000 - (PtrToUlong(Buffer) & 0x0000ffff);
            } else {

                Limit = Length;

            }

            Status = (BlFileTable[FileId].DeviceEntryTable->Write)( FileId,
                                                                Buffer,
                                                                Limit,
                                                                &PartCount  );
            *Count += PartCount;
            Length -= Limit;
            Buffer = (PCHAR) Buffer + Limit;

            if (Status != ESUCCESS) {
#if DBG
                BlPrint(TEXT("AERead: Status = %lx\r\n"),Status);
#endif
                return(Status);
            }

        } while (Length > 0);

        return(Status);
    }
}

ARC_STATUS
AEGetFileInformation(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInformation
    )
{
    return(BlFileTable[FileId].DeviceEntryTable->GetFileInformation)( FileId,
                                                                      FileInformation);
}


TIME_FIELDS AETime;

PTIME_FIELDS
AEGetTime(
    VOID
    )
{
    ULONG Date,Time;

    GET_DATETIME(&Date,&Time);

    //
    // Date and time are filled as as follows:
    //
    // Date:
    //
    //    bits 0  - 4  : day
    //    bits 5  - 8  : month
    //    bits 9  - 31 : year
    //
    // Time:
    //
    //    bits 0  - 5  : second
    //    bits 6  - 11 : minute
    //    bits 12 - 16 : hour
    //

    AETime.Second = (CSHORT)((Time & 0x0000003f) >> 0);
    AETime.Minute = (CSHORT)((Time & 0x00000fc0) >> 6);
    AETime.Hour   = (CSHORT)((Time & 0x0001f000) >> 12);

    AETime.Day    = (CSHORT)((Date & 0x0000001f) >> 0);
    AETime.Month  = (CSHORT)((Date & 0x000001e0) >> 5);
    AETime.Year   = (CSHORT)((Date & 0xfffffe00) >> 9);

    AETime.Milliseconds = 0;        // info is not available
    AETime.Weekday = 7;             // info is not available - set out of range

    return(&AETime);
}


ULONG
AEGetRelativeTime(
    VOID
    )

/*++

Routine Description:

    Returns the time in seconds since some arbitrary starting point.

Arguments:

    None

Return Value:

    Time in seconds since some arbitrary starting point.

--*/

{
    ULONG TimerTicks;

    TimerTicks = GET_COUNTER();

    return((TimerTicks*10) / 182);
}


VOID
AEReboot(
    VOID
    )

/*++

Routine Description:

    Reboots the machine.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    REBOOT_PROCESSOR();
}



ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    )

/*++

Routine Description:

    This routine opens the specified partition and sets the partition info
    in the FileTable at the specified index.  It does not fill in the
    Device Entry table.

    It reads the partition information until the requested partition
    is found or no more partitions are defined.

Arguments:

    FileId - Supplies the file id for the file table entry.

    DiskId - Supplies the file id for the physical device.

    PartitionNumber - Supplies the zero-based partition number

Return Value:

    If a valid partition is found on the hard disk, then ESUCCESS is
    returned. Otherwise, EIO is returned.

--*/

{

    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionLength;
    ULONG StartingSector;
    ULONG VolumeOffset;
    ARC_STATUS Status;
    BOOLEAN PrimaryPartitionTable;
    ULONG PartitionOffset=0;
    ULONG PartitionIndex,PartitionCount=0;
    ULONG Count;
    LARGE_INTEGER SeekPosition;

    BlFileTable[FileId].u.PartitionContext.DiskId=(UCHAR)DiskId;
    BlFileTable[FileId].Position.QuadPart=0;

    VolumeOffset=0;
    PrimaryPartitionTable=TRUE;

    //
    // Change to a 1-based partition number
    //
    PartitionNumber++;

    do {
        SeekPosition.QuadPart = (ULONGLONG)PartitionOffset * (ULONGLONG)SECTOR_SIZE;
        Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                              &SeekPosition,
                                                              SeekAbsolute );
        if (Status != ESUCCESS) {
            return(Status);
        }
        
        Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                              DataBuffer,
                                                              SECTOR_SIZE,
                                                              &Count );

        if (Status != ESUCCESS) {
            return Status;
        }            

        //
        // If sector zero is not a master boot record, then return failure
        // status. Otherwise return success.
        //

        if (DataBuffer[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
#if DBG
            BlPrint(TEXT("Boot record signature %x not found (%x found)\r\n"),
                    BOOT_RECORD_SIGNATURE,
                    DataBuffer[BOOT_SIGNATURE_OFFSET] );
#endif
            Status = EIO;
            break;
        }

        //
        // Read the partition information until the four entries are
        // checked or until we found the requested one.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];

        for (PartitionIndex=0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {

            //
            // Count first the partitions in the MBR. The units
            // inside the extended partition are counted later.
            //
            if ((Partition->PartitionType != PARTITION_ENTRY_UNUSED) &&
                (Partition->PartitionType != STALE_GPT_PARTITION_ENTRY)                
            &&  !IsContainerPartition(Partition->PartitionType))
            {
                PartitionCount++;   // another partition found.
            }

            //
            // Check if the requested partition has already been found.
            // set the partition info in the file table and return.
            //
            if (PartitionCount == PartitionNumber) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionLength = (ULONG)(Partition->PartitionLengthLsb0) |
                                  (ULONG)(Partition->PartitionLengthLsb1 << 8) |
                                  (ULONG)(Partition->PartitionLengthMsb0 << 16) |
                                  (ULONG)(Partition->PartitionLengthMsb1 << 24);
                BlFileTable[FileId].u.PartitionContext.PartitionLength.QuadPart =
                        (PartitionLength << SECTOR_SHIFT);
                BlFileTable[FileId].u.PartitionContext.StartingSector=PartitionOffset + StartingSector;

                return ESUCCESS;
            }
        }

        //
        //  If requested partition was not yet found.
        //  Look for an extended partition.
        //
        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        PartitionOffset = 0;

        for (PartitionIndex=0;
            PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
            PartitionIndex++,Partition++) {

            if (IsContainerPartition(Partition->PartitionType)) {
                StartingSector = (ULONG)(Partition->StartingSectorLsb0) |
                                 (ULONG)(Partition->StartingSectorLsb1 << 8) |
                                 (ULONG)(Partition->StartingSectorMsb0 << 16) |
                                 (ULONG)(Partition->StartingSectorMsb1 << 24);
                PartitionOffset = VolumeOffset+StartingSector;

                if (PrimaryPartitionTable) {
                    VolumeOffset = StartingSector;
                }

                break;      // only one partition can be extended.
            }
        }

        PrimaryPartitionTable = FALSE;
    } while (PartitionOffset != 0);
    
    return EBADF;
}

#if 0

VOID
BlpTranslateDosToArc(
    IN PCHAR DosName,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This routine takes a DOS drive name ("A:" "B:" "C:" etc.) and translates
    it into an ARC name.  ("multi(0)disk(0)rdisk(0)partition(1)")

    N.B.    This will always return some sort of name suitable for passing
            to BiosPartitionOpen.  The name it constructs may not be an
            actual partition.  BiosPartitionOpen is responsible for
            determining whether the partition actually exists.

            Since no other driver should ever use ARC names beginning with
            "multi(0)disk(0)..." this will not be a problem.  (there is no
            way this routine will construct a name that BiosPartitionOpen
            will not open, but some other random driver will grab and
            successfully open)

Arguments:

    DosName - Supplies the DOS name of the drive.

    ArcName - Returns the ARC name of the drive.

Return Value:

--*/

{
    ARC_STATUS Status;
    ULONG DriveId;
    ULONG PartitionNumber;
    ULONG PartitionCount;
    ULONG Count;
    USHORT DataBuffer[SECTOR_SIZE / sizeof(USHORT)];
    PPARTITION_DESCRIPTOR Partition;
    ULONG PartitionIndex;
    BOOLEAN HasPrimary;
    LARGE_INTEGER SeekPosition;

    //
    // Eliminate the easy ones first.
    //    A: is always "multi(0)disk(0)fdisk(0)partition(0)"
    //    B: is always "multi(0)disk(0)fdisk(1)partition(0)"
    //    C: is always "multi(0)disk(0)rdisk(0)partition(1)"
    //

    if (_stricmp(DosName,"A:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(0)partition(0)");
        return;
    }
    if (_stricmp(DosName,"B:")==0) {
        strcpy(ArcName,"multi(0)disk(0)fdisk(1)partition(0)");
        return;
    }
    if (_stricmp(DosName,"C:")==0) {
        strcpy(ArcName,"multi(0)disk(0)rdisk(0)partition(1)");
        return;
    }

    //
    // Now things get more unpleasant.  If there are two drives, then
    // D: is the primary partition on the second drive.  Successive letters
    // are the secondary partitions on the first drive, then back to the
    // second drive when that runs out.
    //
    // The exception to this is when there is no primary partition on the
    // second drive.  Then, we letter the partitions on the first driver
    // consecutively, and when those partitions run out, we letter the
    // partitions on the second drive.
    //
    // I have no idea who came up with this wonderful scheme, but we have
    // to live with it.
    //

    //
    // Try to open the second drive.  If this doesn't work, we only have
    // one drive and life is easy.
    //
    Status = ArcOpen("multi(0)disk(0)rdisk(1)partition(0)",
                     ArcOpenReadOnly,
                     &DriveId );

    if (Status != ESUCCESS) {

        //
        // We only have one drive, so whatever drive letter he's requesting
        // has got to be on it.
        //

        sprintf(ArcName,
                "multi(0)disk(0)rdisk(0)partition(%d)",
                toupper(DosName[0]) - 'C' + 1 );

        return;
    } else {

        //
        // Now we read the partition table off the second drive, so we can
        // tell if there is a primary partition or not.
        //
        SeekPosition.QuadPart = 0;

        Status = ArcSeek(DriveId,
                         &SeekPosition,
                         SeekAbsolute);
        if (Status != ESUCCESS) {
            ArcName[0]='\0';
            return;
        }

        Status = ArcRead(DriveId, DataBuffer, SECTOR_SIZE, &Count);
        ArcClose(DriveId);

        if (Status != ESUCCESS) {
            ArcName[0] = '\0';
            return;
        }

        HasPrimary = FALSE;

        Partition = (PPARTITION_DESCRIPTOR)&DataBuffer[PARTITION_TABLE_OFFSET];
        for (PartitionIndex = 0;
             PartitionIndex < NUM_PARTITION_TABLE_ENTRIES;
             PartitionIndex++,Partition++) {
            if (IsRecognizedPartition(Partition->PartitionType)) {
                HasPrimary = TRUE;
            }
        }

        //
        // Now we have to go through and count
        // the partitions on the first drive.  We do this by just constructing
        // ARC names for each successive partition until one BiosPartitionOpen
        // call fails.
        //

        PartitionCount = 0;
        do {
            ++PartitionCount;
            sprintf(ArcName,
                    "multi(0)disk(0)rdisk(0)partition(%d)",
                    PartitionCount+1);

            Status = BiosPartitionOpen( ArcName,
                                        ArcOpenReadOnly,
                                        &DriveId );

            if (Status==ESUCCESS) {
                BiosPartitionClose(DriveId);
            }
        } while ( Status == ESUCCESS );

        PartitionNumber = toupper(DosName[0])-'C' + 1;

        if (HasPrimary) {

            //
            // There is Windows NT primary partition on the second drive.
            //
            // If the DosName is "D:" then we know
            // this is the first partition on the second drive.
            //

            if (_stricmp(DosName,"D:")==0) {
                strcpy(ArcName,"multi(0)disk(0)rdisk(1)partition(1)");
                return;
            }

            if (PartitionNumber-1 > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber-1);
            }

        } else {

            //
            // There is no primary partition on the second drive, so we
            // consecutively letter the partitions on the first drive,
            // then the second drive.
            //

            if (PartitionNumber > PartitionCount) {
                PartitionNumber -= PartitionCount;
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(1)partition(%d)",
                        PartitionNumber );
            } else {
                sprintf(ArcName,
                        "multi(0)disk(0)rdisk(0)partition(%d)",
                        PartitionNumber);
            }

        }


        return;
    }
}
#endif


VOID
FwStallExecution(
    IN ULONG Microseconds
    )

/*++

Routine Description:

    Does a busy wait for a specified number of microseconds (very approximate!)

Arguments:

    Microseconds - Supplies the number of microseconds to busy wait.

Return Value:

    None.

--*/

{
    extern EFI_SYSTEM_TABLE *EfiST;
    EfiST->BootServices->Stall( Microseconds );
}


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    )

/*++

Routine Description:

    This routine looks for the given Mnemonic in OpenPath.
    If Mnemonic is a component of the path, then it converts the key
    value to an integer wich is returned in Key.

Arguments:

    OpenPath - Pointer to a string that contains an ARC pathname.

    Mnemonic - Pointer to a string that contains a ARC Mnemonic

    Key      - Pointer to a ULONG where the Key value is stored.


Return Value:

    FALSE  if mnemonic is found in path and a valid key is converted.
    TRUE   otherwise.

--*/

{
    return(BlGetPathMnemonicKey(OpenPath,Mnemonic,Key));
}


PCONFIGURATION_COMPONENT
FwAddChild (
    IN PCONFIGURATION_COMPONENT Component,
    IN PCONFIGURATION_COMPONENT NewComponent,
    IN PVOID ConfigurationData OPTIONAL
    )
{
    ULONG Size;
    PCONFIGURATION_COMPONENT_DATA NewEntry;
    PCONFIGURATION_COMPONENT_DATA Parent;

    UNREFERENCED_PARAMETER( ConfigurationData );

    if (Component==NULL) {
        return(NULL);
    }

    Parent = CONTAINING_RECORD(Component,
                               CONFIGURATION_COMPONENT_DATA,
                               ComponentEntry);

    Size = sizeof(CONFIGURATION_COMPONENT_DATA) +
           NewComponent->IdentifierLength + 1;

    NewEntry = BlAllocateHeap(Size);
    if (NewEntry==NULL) {
        return(NULL);
    }

    RtlCopyMemory(&NewEntry->ComponentEntry,
                  NewComponent,
                  sizeof(CONFIGURATION_COMPONENT));
    NewEntry->ComponentEntry.Identifier = (PCHAR)(NewEntry+1);
    NewEntry->ComponentEntry.ConfigurationDataLength = 0;
    strncpy(NewEntry->ComponentEntry.Identifier,
            NewComponent->Identifier,
            NewComponent->IdentifierLength);

    //
    // Add the new component as the first child of its parent.
    //
    NewEntry->Child = NULL;
    NewEntry->Sibling = Parent->Child;
    Parent->Child = NewEntry;

    return(&NewEntry->ComponentEntry);

}

PCONFIGURATION_COMPONENT
FwGetComponent(
    IN PCHAR Pathname
    )
{
    PCONFIGURATION_COMPONENT Component;
    PCONFIGURATION_COMPONENT MatchComponent;
    PCHAR PathString;
    PCHAR MatchString;
    PCHAR Token;
    ULONG Key;

    PathString = Pathname;

    //
    // Get the the root component.
    //

    MatchComponent = FwGetChild(NULL);

    //
    // Repeat search for each new match component.
    //

    do {

        //
        // Get the first child of the current match component.
        //

        Component = FwGetChild( MatchComponent );

        //
        // Search each child of the current match component for the next match.
        //

        while ( Component != NULL ) {

            //
            // Reset Token to be the current position on the pathname.
            //

            Token = PathString;

            MatchString = MnemonicTable[Component->Type];

            //
            // Compare strings.
            //

            while (*MatchString == tolower(*Token)) {
                MatchString++;
                Token++;
            }

            //
            // Strings compare if the first mismatch is the terminator for
            // each.
            //

            if ((*MatchString == 0) && (*Token == '(')) {

                //
                // Form key.
                //

                Key = 0;
                Token++;
                while ((*Token != ')') && (*Token != 0)) {
                    Key = (Key * 10) + *Token++ - '0';
                }

                //
                // If the key matches the component matches, so update
                // pointers and break.
                //

                if (Component->Key == Key) {
                    PathString = Token + 1;
                    MatchComponent = Component;
                    break;
                }
            }

            Component = FwGetPeer( Component );
        }

    } while ((Component != NULL) && (*PathString != 0));

    return MatchComponent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Author:

    Thomas Parslow [TomP] Feb-13-1991
    Reworked substantially in Tokyo 7-July-95 (tedm)
    Port from ARC-BIOS to EFI 22-Nov-2000 (andrewr)

Abstract:

    This file contains an interface to the screen that is independent
    of the screen type actually being written to.  The module serves
    as a layer between OS loader applications and the EFI services
    that do the actual legwork of writing to the default console
    handlers.

--*/

#include "bldr.h"
#include "bootefi.h"


#include "efi.h"
#include "efip.h"
#include "flop.h"


//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;


// 
// Macro Definitions
// 
#define EfiPrint(_X)                                          \
  {                                                           \
      if (IsPsrDtOn()) {                                      \
          FlipToPhysical();                                   \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
          FlipToVirtual();                                    \
      }                                                       \
      else {                                                  \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
      }                                                       \
  }

#define ZLEN_SHORT(x) ((x < 0x10) + (x < 0x100) + (x < 0x1000))
#define ZLEN_LONG(x)  ((x < 0x10) + (x < 0x100) + (x < 0x1000) + \
    (x < 0x10000) + (x < 0x100000)+(x < 0x1000000)+(x < 0x10000000))

//
// Current screen position.
//
USHORT TextColumn = 0;
USHORT TextRow  = 0;

//
// Current text attribute
//
UCHAR TextCurrentAttribute = 0x07;      // start with white on black.

//
// Internal routines
//
VOID
puti(
    LONG
    );

VOID
putx(
    ULONG
    );

VOID
putu(
    ULONG
    );

VOID
putwS(
    PUNICODE_STRING String
    );

VOID
putS(
    PCWSTR String
    );

VOID
puts(
    PCSTR String
    );

VOID
BlPrint(
    PTCHAR cp,
    ...
    )

/*++

Routine Description:

    Standard printf function with a subset of formating features supported.

    Currently handles

     %d, %ld - signed short, signed long
     %u, %lu - unsigned short, unsigned long
     %c, %s  - character, string
     %x, %lx - unsigned print in hex, unsigned long print in hex
     %C, %S  - ansi character, string
     %wS     - counted UNICODE_STRING

    Does not do:

     - field width specification
     - floating point.

Arguments:

    cp - pointer to the format string, text string.

Returns:

    Nothing

--*/

{
    ULONG Count;
    TCHAR ch;
    ULONG DeviceId;
    TCHAR b,c;
    PTSTR FormatString;
    va_list args;

    FormatString = cp;

    DeviceId = BlConsoleOutDeviceId;

    va_start(args, cp);

    //
    // Process the arguments using the descriptor string
    //
    while(*FormatString != TEXT('\0')) {
          
        b = *FormatString;
        FormatString += 1;

        if(b == TEXT('%')) {

            c = *FormatString;
            FormatString += 1;

            switch (c) {

            case TEXT('d'):
                
                puti((LONG)va_arg(args, LONG));
                
                break;

            case TEXT('s'):
                putS((PCWSTR)va_arg(args, PWSTR));
                
                break;

            case TEXT('S'):
                puts((PCSTR)va_arg(args, PSTR));
                
                break;

            case TEXT('c'):
                ch = (WCHAR)va_arg( args, WCHAR );
                ArcWrite(DeviceId, &ch, 1*sizeof(WCHAR), &Count);                
                break;
            
            case TEXT('C'):
                ch = (CHAR)va_arg( args, CHAR );
                ArcWrite(DeviceId, &ch, 1*sizeof(CHAR), &Count);
                
                break;

            case TEXT('x'):
                //note that this doesn't currently support zero padding.
                putx((ULONG)va_arg( args, ULONG));
                break;

            case TEXT('u'):
                putu( (ULONG)va_arg( args, ULONG ));
                break;

            case TEXT('w'):
                c = *FormatString;
                FormatString += 1;
                switch (c) {
                case TEXT('S'):
                case TEXT('Z'):
                    putwS((PUNICODE_STRING)va_arg( args, PUNICODE_STRING));
                    break;
                }
                break;

            case TEXT('l'):
                c = *FormatString;
                FormatString += 1;                    

                switch(c) {

                case TEXT('0'):
                    break;

                case TEXT('u'):
                    putu(va_arg( args, ULONG));                    
                    break;

                case TEXT('x'):
                    //note that this doesn't currently support zero padding
                    putx(va_arg( args, ULONG));                    
                    break;

                case TEXT('d'):
                    puti(va_arg( args, ULONG));                    
                    break;
                }
                break;

            default :
                ch = (TCHAR)b;
                ArcWrite(DeviceId, &ch, 1*sizeof(TCHAR), &Count);
                ch = (TCHAR)c;
                ArcWrite(DeviceId, &ch, 1*sizeof(TCHAR), &Count);
            }
        } else {
            ArcWrite(DeviceId, FormatString - 1, 1*sizeof(TCHAR), &Count);            
        }
    }

    va_end(args);    

#if 0
    {
        ULONG l;
        //
        // This code pauses the system after each BlPrint.  You must enter 
        // a character to continue.  This is used for debugging
        //

        ArcRead(BlConsoleInDeviceId, &l, 1, &Count);
    }

#endif
    
}


VOID
putwS(
    PUNICODE_STRING String
    )

/*++

Routine Description:

    Writes counted unicode string to the display at the current
    cursor position.

Arguments:

    String - pointer to unicode string to display

Returns:

    Nothing

--*/

{
    ULONG i;
    ULONG Count;    
    
    for(i=0; i < String->Length; i++) {        
        ArcWrite(BlConsoleOutDeviceId, &String->Buffer[i], 1*sizeof(WCHAR), &Count);
    }
}

VOID
puts(
    PCSTR AnsiString
    )

/*++

Routine Description:

    Writes an ANSI string to the display at the current cursor position.

Arguments:

    String - pointer to ANSI string to display

Returns:

    Nothing

--*/

{
    ULONG Count;
    WCHAR Char;
    PCSTR p;

    p = AnsiString;
    while (*p != '\0') {
        Char = (WCHAR)*p;
        ArcWrite(BlConsoleOutDeviceId, &Char, sizeof(WCHAR), &Count);
        p += 1;
    }
                          
}

VOID
putS(
    PCWSTR UnicodeString
    )

/*++

Routine Description:

    Writes an ANSI string to the display at the current cursor position.

Arguments:

    String - pointer to ANSI string to display

Returns:

    Nothing

--*/

{
    ULONG Count;
    WCHAR Char;
    PCWSTR p;

    p = UnicodeString;
    while (*p != L'\0') {
        Char = *p;
        ArcWrite(BlConsoleOutDeviceId, &Char, sizeof(WCHAR), &Count);
        p += 1;
    }
                          
}



VOID
putx(
    ULONG x
    )

/*++

Routine Description:

    Writes hex long to the display at the current cursor position.

Arguments:

    x - ulong to write

Returns:

    Nothing

--*/

{
    ULONG j;
    ULONG Count;
    _TUCHAR ch;

    if(x/16) {
        putx(x/16);
    }

    if((j=x%16) > 9) {
        ch = (_TUCHAR)(j+TEXT('A')-10);
        ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
    } else {
        ch = (_TUCHAR)(j+TEXT('0'));
        ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
    }
}


VOID
puti(
    LONG i
    )

/*++

Routine Description:

    Writes a long integer on the display at the current cursor position.

Arguments:

    i - the integer to write to the display.

Returns:

    Nothing

--*/

{
    ULONG Count;
    _TUCHAR ch;

    if(i<0) {
        i = -i;
        ch = TEXT('-');
        ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
    }

    if(i/10) {
        puti(i/10);
    }

    ch = (_TUCHAR)((i%10)+TEXT('0'));
    ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
}


VOID
putu(
    ULONG u
    )

/*++

Routine Description:

    Write an unsigned long to display

Arguments:

    u - unsigned

Returns:

    Nothing

--*/

{
    ULONG Count;
    _TUCHAR ch;

    if(u/10) {
        putu(u/10);
    }
    
    ch = (_TUCHAR)((u%10)+TEXT('0'));
    ArcWrite(BlConsoleOutDeviceId, &ch, 1*sizeof(_TUCHAR), &Count);
}


#if 0
VOID
pTextCharOut(
    IN UCHAR c
    )
{
    if(DbcsLangId) {
        //
        // Single-byte only
        //
        TextGrCharOut(&c);
    } else {
        TextTmCharOut(&c);
    }
}

#endif

VOID
TextCharOut(
    IN PWCHAR pc
    )
{
    WCHAR  Text[2];
    Text[0] = *pc;
    Text[1] = L'\0';
    EfiPrint(Text);
#if 0
    if(DbcsLangId) {
        return(TextGrCharOut(pc));
    } else {
        return(TextTmCharOut(pc));
    }
#endif
}


VOID
TextStringOut(
    IN PWCHAR String
    )
{
    PWCHAR p = String;
    while (*p) {
        TextCharOut(p);
        p += 1;
    }

#if 0    
    if(DbcsLangId) {
        TextGrStringOut(String);
    } else {
        TextTmStringOut(String);
    }
#endif

}

VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    )

/*++

Routine Description:

    Sets the character attribute to be used for subsequent text display.

Arguments:

Returns:

    Nothing.

--*/

{
    TextCurrentAttribute = Attribute;
    
#ifdef EFI
    BlEfiSetAttribute( Attribute );
#else
    if(DbcsLangId) {
        TextGrSetCurrentAttribute(Attribute);
    } else {
        TextTmSetCurrentAttribute(Attribute);
    }
#endif
}


UCHAR
TextGetCurrentAttribute(
    VOID
    )
{
    return(TextCurrentAttribute);
}

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    )

/*++

Routine Description:

    Changes the screen attribute starting at the current cursor position.
    The cursor is not moved.

Arguments:

    Attribute - Supplies the new attribute

    Length - Supplies the length of the area to change (in bytes)

Return Value:

    None.

--*/

{
#ifdef EFI
    ULONG x,y, OrigX, OrigY;
    BOOLEAN FirstTime = TRUE;

    UNREFERENCED_PARAMETER( Length );

    BlEfiGetCursorPosition( &OrigX, &OrigY );

    x = OrigX;
    y = OrigY;

    for (y = OrigY; y < BlEfiGetLinesPerRow() ; y++) {
        x = FirstTime
            ? OrigX
            : 0 ;

        FirstTime = FALSE;

        for (; x <= BlEfiGetColumnsPerLine(); x++) {
            BlEfiPositionCursor( y, x );
            BlEfiSetAttribute( Attribute );
        }
    }

    BlEfiPositionCursor( OrigY, OrigX );

#else
    if(DbcsLangId) {
        TextGrFillAttribute(Attribute,Length);
    } else {
        TextTmFillAttribute(Attribute,Length);
    }
#endif
}


_TUCHAR
TextGetGraphicsCharacter(
    IN GraphicsChar WhichOne
    )
{
#ifdef EFI
    return(BlEfiGetGraphicsChar( WhichOne ));
#else
    return((WhichOne < GraphicsCharMax)
           ? (DbcsLangId 
               ? TextGrGetGraphicsChar(WhichOne) 
               : TextTmGetGraphicsChar(WhichOne))
           : TEXT(' '));
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\biosdrv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    biosdrv.c

Abstract:

    Provides the ARC emulation routines for I/O to a device supported by
    real-mode INT 13h BIOS calls.

Author:

    John Vert (jvert) 7-Aug-1991

Revision History:

    Allen Kay (akay)  19-May-1999

--*/

#include "arccodes.h"
#include "stdlib.h"
#include "string.h"

#if defined(_IA64_)
#include "bootia64.h"
#endif

#if defined(_X86_)
#include "bootx86.h"
#endif

#include "bootefi.h"
#include "biosdrv.h"

#include "efi.h"
#include "efip.h"
#include "flop.h"

//
// Externals
//

extern VOID FlipToVirtual();
extern VOID FlipToPhysical();
extern ULONGLONG CompareGuid();

extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;
extern EFI_GUID EfiDiskIoProtocol;
extern EFI_GUID EfiLoadedImageProtocol;
extern EFI_GUID EfiFilesystemProtocol;

extern
ULONG GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif


//
// defines for doing console I/O
//
#define CSI 0x95
#define SGR_INVERSE 7
#define SGR_NORMAL 0

//
// define for FloppyOpenMode
//
#define FloppyOpenMode 0xCDEFABCD

//
// static data for console I/O
//
BOOLEAN ControlSequence=FALSE;
BOOLEAN EscapeSequence=FALSE;
BOOLEAN FontSelection=FALSE;
BOOLEAN HighIntensity=FALSE;
BOOLEAN Blink=FALSE;
ULONG PCount=0;

#define CONTROL_SEQUENCE_MAX_PARAMETER 10
ULONG Parameter[CONTROL_SEQUENCE_MAX_PARAMETER];

#define KEY_INPUT_BUFFER_SIZE 16
UCHAR KeyBuffer[KEY_INPUT_BUFFER_SIZE];
ULONG KeyBufferEnd=0;
ULONG KeyBufferStart=0;

//
// array for translating between ANSI colors and the VGA standard
//
UCHAR TranslateColor[] = {0,4,2,6,1,5,3,7};

ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    );

VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    );

#define DEVICE_NOT_FOUND    0xFEEBEE

#ifdef FORCE_CD_BOOT

EFI_HANDLE
GetCdTest(
    VOID
    );

#endif

ULONG
FindAtapiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG PrimarySecondary,
    ULONG SlaveMaster,
    ULONG Lun
    );

ULONG
FindScsiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG Pun,
    ULONG Lun
    );

ULONG
FindFibreChannelDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONGLONG WWN,
    ULONGLONG Lun
    );

//
// Buffer for temporary storage of data read from the disk that needs
// to end up in a location above the 1MB boundary.
//
// NOTE: it is very important that this buffer not cross a 64k boundary.
//
PUCHAR LocalBuffer=NULL;

//
// There are two sorts of things we can open in this module, disk partitions,
// and raw disk devices.  The following device entry tables are
// used for these things.
//

BL_DEVICE_ENTRY_TABLE BiosPartitionEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosPartitionClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosPartitionOpen,
        (PARC_READ_ROUTINE)BiosPartitionRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosPartitionWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosPartitionGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)NULL
    };

BL_DEVICE_ENTRY_TABLE BiosDiskEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BiosDiskWrite,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)NULL
    };

BL_DEVICE_ENTRY_TABLE BiosEDDSEntryTable =
    {
        (PARC_CLOSE_ROUTINE)BiosDiskClose,
        (PARC_MOUNT_ROUTINE)BlArcNotYetImplemented,
        (PARC_OPEN_ROUTINE)BiosDiskOpen,
        (PARC_READ_ROUTINE)BiosElToritoDiskRead,
        (PARC_READ_STATUS_ROUTINE)BlArcNotYetImplemented,
        (PARC_SEEK_ROUTINE)BiosPartitionSeek,
        (PARC_WRITE_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_FILE_INFO_ROUTINE)BiosDiskGetFileInfo,
        (PARC_SET_FILE_INFO_ROUTINE)BlArcNotYetImplemented,
        (PRENAME_ROUTINE)BlArcNotYetImplemented,
        (PARC_GET_DIRECTORY_ENTRY_ROUTINE)BlArcNotYetImplemented,
        (PBOOTFS_INFO)NULL
    };


ARC_STATUS
BiosDiskClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
        BlPrint(TEXT("ERROR - Unopened fileid %lx closed\r\n"),FileId);
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(ESUCCESS);
}

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    )

/*++

Routine Description:

    Closes the specified device

Arguments:

    FileId - Supplies file id of the device to be closed

Return Value:

    ESUCCESS - Device closed successfully

    !ESUCCESS - Device was not closed.

--*/

{
    if (BlFileTable[FileId].Flags.Open == 0) {
        BlPrint(TEXT("ERROR - Unopened fileid %lx closed\r\n"),FileId);
    }
    BlFileTable[FileId].Flags.Open = 0;

    return(BiosDiskClose((ULONG)BlFileTable[FileId].u.PartitionContext.DiskId));
}


#define STR_PREFIX
#define DBG_PRINT(x)


ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens the disk partition specified by OpenPath.  This routine will open
    floppy drives 0 and 1, cdrom drives, as well as hard drives.

    Note that the ARC mapping layer doesn't really have a clean mapping under
    EFI.  We really just rely on order of device enumeration to locate devices.

Arguments:

    OpenPath - Supplies a pointer to the name of the partition.  If OpenPath
               is "A:" or "B:" the corresponding floppy drive will be opened.
               If it is "C:" or above, this routine will find the corresponding
               partition on hard drive 0 or 1 and open it.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only
                1 - Write Only
                2 - Read/Write

    FileId - Returns the file descriptor for use with the Close, Read, Write,
             and Seek routines

Return Value:

    ESUCCESS - File successfully opened.

--*/

{
    ARC_STATUS Status;
    ULONG DiskFileId;
    UCHAR PartitionNumber;
    ULONG Controller;
    ULONG Floppy;
    ULONG Key;

    UNREFERENCED_PARAMETER( OpenMode );

    //
    // BIOS devices are always "multi(0)" (except for EISA flakiness
    // where we treat "eisa(0)..." like "multi(0)..." in floppy cases.
    //
    if(FwGetPathMnemonicKey(OpenPath,"multi",&Key) != ESUCCESS) {
       if (FwGetPathMnemonicKey(OpenPath,"scsi",&Key) != ESUCCESS) {
           return(EBADF);
       }
    }

    if (Key!=0) {
        return(EBADF);
    }

    //
    // If we're opening a floppy drive, there are no partitions
    // so we can just return the physical device.
    //
    if (FwGetPathMnemonicKey(OpenPath,"fdisk",&Floppy) == ESUCCESS) {
        return(BiosDiskOpen( Floppy, FloppyOpenMode, FileId));
    }

    //
    // We can only deal with disk controller 0
    //

    if (FwGetPathMnemonicKey(OpenPath,"disk",&Controller) != ESUCCESS) {
        return(EBADF);
    }
    if ( Controller!=0 ) {
        return(EBADF);
    }

    if (FwGetPathMnemonicKey(OpenPath,"cdrom",&Key) == ESUCCESS) {
        //
        // Now we have a CD-ROM disk number, so we open that for raw access.
        // Use a special bit to indicate CD-ROM since we only access the cdrom
        // if we booted from it
        //
        return(BiosDiskOpen( Key | 0x80000000, 0, FileId ) );
    }

    if (FwGetPathMnemonicKey(OpenPath,"rdisk",&Key) != ESUCCESS) {
        return(EBADF);
    }

    //
    // Now we have a disk number, so we open that for raw access.
    // We need to add 0x80 to translate it to a BIOS number.
    //

    Status = BiosDiskOpen( Key,
                           0,
                           &DiskFileId );

    if (Status != ESUCCESS) {
        DBG_PRINT(STR_PREFIX"BiosDiskOpen Failed\r\n");

        return(Status);
    }

    //
    // Find the partition number to open
    //

    if (FwGetPathMnemonicKey(OpenPath,"partition",&Key)) {
        BiosPartitionClose(DiskFileId);
        return(EBADF);
    }

    //
    // If the partition number was 0, then we are opening the device
    // for raw access, so we are already done.
    //
    if (Key == 0) {
        *FileId = DiskFileId;
        return(ESUCCESS);
    }

    //
    // Before we open the partition, we need to find an available
    // file descriptor.
    //

    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if (*FileId == BL_FILE_TABLE_SIZE) {
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;

    BlFileTable[*FileId].DeviceEntryTable=&BiosPartitionEntryTable;


    //
    // Convert to zero-based partition number
    //
    PartitionNumber = (UCHAR)(Key - 1);

    DBG_PRINT(STR_PREFIX"Trying HardDiskPartitionOpen(...)\r\n");

    //
    // Try to open the MBR partition
    //
    Status = HardDiskPartitionOpen( *FileId,
                                   DiskFileId,
                                   PartitionNumber);


#ifdef EFI_PARTITION_SUPPORT

    if (Status != ESUCCESS) {
        //
        // Try to open the GPT partition
        //
        DBG_PRINT(STR_PREFIX"Trying BlOpenGPTDiskPartition(...)\r\n");

        Status = BlOpenGPTDiskPartition(*FileId,
                                    DiskFileId,
                                    PartitionNumber);
    }

#endif

    return Status;
}


ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Reads from the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count -  Returns actual bytes read.

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;

    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                (ULONGLONG)SECTOR_SIZE * BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          Buffer,
                                                          Length,
                                                          Count );

    BlFileTable[FileId].Position.QuadPart += *Count;

    return(Status);
}



ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    Changes the current offset of the file specified by FileId

Arguments:

    FileId - specifies the file on which the current offset is to
             be changed.

    Offset - New offset into file.

    SeekMode - Either SeekAbsolute or SeekRelative
               SeekEndRelative is not supported

Return Value:

    ESUCCESS - Operation completed succesfully

    EBADF - Operation did not complete successfully.

--*/

{
    switch (SeekMode) {
        case SeekAbsolute:
            BlFileTable[FileId].Position = *Offset;
            break;
        case SeekRelative:
            BlFileTable[FileId].Position.QuadPart += Offset->QuadPart;
            break;
        default:
            BlPrint(TEXT("SeekMode %lx not supported\r\n"),SeekMode);
            return(EACCES);

    }
    return(ESUCCESS);

}



ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes to the specified file

    NOTE John Vert (jvert) 18-Jun-1991
        This only supports block sector reads.  Thus, everything
        is assumed to start on a sector boundary, and every offset
        is considered an offset from the logical beginning of the disk
        partition.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count -  Returns actual bytes written.

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed.

--*/

{
    ARC_STATUS Status;
    LARGE_INTEGER PhysicalOffset;
    ULONG DiskId;

    PhysicalOffset.QuadPart = BlFileTable[FileId].Position.QuadPart +
                   (ULONGLONG)SECTOR_SIZE * BlFileTable[FileId].u.PartitionContext.StartingSector;

    DiskId = BlFileTable[FileId].u.PartitionContext.DiskId;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &PhysicalOffset,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return(Status);
    }

    Status = (BlFileTable[DiskId].DeviceEntryTable->Write)(DiskId,
                                                           Buffer,
                                                           Length,
                                                           Count );

    if(Status == ESUCCESS) {
        BlFileTable[FileId].Position.QuadPart += *Count;
    }

    return(Status);
}



ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Attempts to open either the console input or output

Arguments:

    OpenPath - Supplies a pointer to the name of the device to open.  If
               this is either CONSOLE_INPUT_NAME or CONSOLE_OUTPUT_NAME,
               a file descriptor is allocated and filled in.

    OpenMode - Supplies the mode to open the file.
                0 - Read Only (CONSOLE_INPUT_NAME)
                1 - Write Only (CONSOLE_OUTPUT_NAME)

    FileId - Returns the file descriptor for use with the Close, Read and
             Write routines

Return Value:

    ESUCCESS - Console successfully opened.

--*/

{
    if (_stricmp(OpenPath, CONSOLE_INPUT_NAME)==0) {

        //
        // Open the keyboard for input
        //

        if (OpenMode != ArcOpenReadOnly) {
            return(EACCES);
        }

        *FileId = ARC_CONSOLE_INPUT;

        return(ESUCCESS);
    }

    if (_stricmp(OpenPath, CONSOLE_OUTPUT_NAME)==0) {

        //
        // Open the display for output
        //

        if (OpenMode != ArcOpenWriteOnly) {
            return(EACCES);
        }
        *FileId = ARC_CONSOLE_OUTPUT;

        return(ESUCCESS);
    }

    return(ENOENT);

}

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine determines if there is a keypress pending

Arguments:

    FileId - Supplies the FileId to be read.  (should always be 0 for this
            function)

Return Value:

    ESUCCESS - There is a key pending

    EAGAIN - There is not a key pending

--*/

{
    ULONG Key;

    //
    // enforce file id to be 0 by no reading console otherwise
    //
    if (FileId != 0) {
        return EINVAL;
    }

    //
    // If we have buffered input...
    //
    if (KeyBufferEnd != KeyBufferStart) {
        return(ESUCCESS);
    }

    //
    // Check for a key
    //
    Key = GET_KEY();
    if (Key != 0) {
        //
        // We got a key, so we have to stick it back into our buffer
        // and return ESUCCESS.
        //
        BiosConsoleFillBuffer(Key);
        return(ESUCCESS);

    } else {
        //
        // no key pending
        //
        return(EAGAIN);
    }

}

ARC_STATUS
BiosConsoleRead(
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Gets input from the keyboard.

Arguments:

    FileId - Supplies the FileId to be read (should always be 0 for this
             function)

    Buffer - Returns the keyboard input.

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes read

Return Value:

    ESUCCESS - Keyboard read completed succesfully.

--*/

{
    ULONG Key;

    //
    // enforce file id to be 0 by no reading console otherwise
    //
    if (FileId != 0) {
        return EINVAL;
    }

    *Count = 0;

    while (*Count < Length) {
        if (KeyBufferEnd == KeyBufferStart) { // then buffer is presently empty
            do {

                //
                // Poll the keyboard until input is available
                //
                Key = GET_KEY();
            } while ( Key==0 );

            BiosConsoleFillBuffer(Key);
        }

        Buffer[*Count] = KeyBuffer[KeyBufferStart];
        KeyBufferStart = (KeyBufferStart+1) % KEY_INPUT_BUFFER_SIZE;

        *Count = *Count + 1;
    }
    return(ESUCCESS);
}



VOID
BiosConsoleFillBuffer(
    IN ULONG Key
    )

/*++

Routine Description:

    Places input from the keyboard into the keyboard buffer, expanding the
    special keys as appropriate.

    All keys translated here use the ARC translation table, as defined in the
    ARC specification, with one exception -- the BACKTAB_KEY, for which the
    ARC spec is lacking.  I have decided that BACKTAB_KEY is ESC+TAB.

Arguments:

    Key - Raw keypress value as returned by GET_KEY().

Return Value:

    none.

--*/

{
    switch(Key) {
        case UP_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'A';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DOWN_ARROW:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'B';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case RIGHT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'C';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case LEFT_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'D';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case INS_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = '@';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case DEL_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F1_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'P';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F2_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'Q';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F3_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'w';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F4_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'x';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F5_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 't';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F6_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'u';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F8_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'r';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case F10_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'O';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'M';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case HOME_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'H';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case END_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = 'K';
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case ESCAPE_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        case BACKTAB_KEY:
            KeyBuffer[KeyBufferEnd] = ASCI_CSI_IN;
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            KeyBuffer[KeyBufferEnd] = (UCHAR)(TAB_KEY & 0xFF);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
            break;

        default:
            //
            // The ASCII code is the low byte of Key
            //
            KeyBuffer[KeyBufferEnd] = (UCHAR)(Key & 0xff);
            KeyBufferEnd = (KeyBufferEnd+1) % KEY_INPUT_BUFFER_SIZE;
    }
}



ARC_STATUS
BiosConsoleWrite(
    IN ULONG FileId,
    OUT PWCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Outputs to the console.  (In this case, the VGA display)

Arguments:

    FileId - Supplies the FileId to be written (should always be 1 for this
             function)

    Buffer - Supplies characters to be output

    Length - Supplies the length of the buffer (in bytes)

    Count  - Returns the actual number of bytes written

Return Value:

    ESUCCESS - Console write completed succesfully.

--*/
{
    ARC_STATUS Status;
    PWCHAR String;
    ULONG Index;
    ULONG y;

    //
    // enforce file id to be 1 by no reading console otherwise
    //
    if (FileId != 1) {
        return EINVAL;
    }

    //
    // Process each character in turn.
    //

    Status = ESUCCESS;
    String = Buffer;

    for ( *Count = 0 ;
          *Count < Length ;
          String++,*Count = *Count+sizeof(WCHAR) ) {

        //
        // If we're in the middle of a control sequence, continue scanning,
        // otherwise process character.
        //

        if (ControlSequence) {

            //
            // If the character is a digit, update parameter value.
            //

            if ((*String >= L'0') && (*String <= L'9')) {
                Parameter[PCount] = Parameter[PCount] * 10 + *String - L'0';
                continue;
            }

            //
            // If we are in the middle of a font selection sequence, this
            // character must be a 'D', otherwise reset control sequence.
            //

            if (FontSelection) {

                //if (*String == 'D') {
                //
                //    //
                //    // Other fonts not implemented yet.
                //    //
                //
                //} else {
                //}

                ControlSequence = FALSE;
                FontSelection = FALSE;
                continue;
            }

            switch (*String) {

            //
            // If a semicolon, move to the next parameter.
            //

            case L';':

                PCount++;
                if (PCount > CONTROL_SEQUENCE_MAX_PARAMETER) {
                    PCount = CONTROL_SEQUENCE_MAX_PARAMETER;
                }
                Parameter[PCount] = 0;
                break;

            //
            // If a 'J', erase part or all of the screen.
            //

            case L'J':

                switch (Parameter[0]) {
                    case 0:
                        //
                        // Erase to end of the screen
                        //
                        BlEfiClearToEndOfDisplay();
                        //TextClearToEndOfDisplay();
                        break;

                    case 1:
                        //
                        // Erase from the beginning of the screen
                        //
                        break;

                    default:
                        //
                        // Erase entire screen
                        //
                        //TextClearDisplay();
                        BlEfiClearDisplay();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'K', erase part or all of the line.
            //

            case L'K':

                switch (Parameter[0]) {

                //
                // Erase to end of the line.
                //

                    case 0:
                        //TextClearToEndOfLine();
                        BlEfiClearToEndOfDisplay();
                        break;

                    //
                    // Erase from the beginning of the line.
                    //

                    case 1:
                        //TextClearFromStartOfLine();
                        BlEfiClearToEndOfLine();
                        break;

                    //
                    // Erase entire line.
                    //

                    default :
                        BlEfiGetCursorPosition( NULL, &y );
                        BlEfiPositionCursor( 0, y );
                        BlEfiClearToEndOfLine();
                        //TextClearFromStartOfLine();
                        //TextClearToEndOfLine();
                        break;
                }

                ControlSequence = FALSE;
                break;

            //
            // If a 'H', move cursor to position.
            //

            case 'H':
                //TextSetCursorPosition(Parameter[1]-1, Parameter[0]-1);
                BlEfiPositionCursor( Parameter[1]-1, Parameter[0]-1 );
                ControlSequence = FALSE;
                break;

            //
            // If a ' ', could be a FNT selection command.
            //

            case L' ':
                FontSelection = TRUE;
                break;

            case L'm':
                //
                // Select action based on each parameter.
                //
                // Blink and HighIntensity are by default disabled
                // each time a new SGR is specified, unless they are
                // explicitly specified again, in which case these
                // will be set to TRUE at that time.
                //

                HighIntensity = FALSE;
                Blink = FALSE;

                for ( Index = 0 ; Index <= PCount ; Index++ ) {
                    switch (Parameter[Index]) {

                    //
                    // Attributes off.
                    //

                    case 0:
                        // bugbug blink???
                        BlEfiSetAttribute( ATT_FG_WHITE );
                        //TextSetCurrentAttribute(7);
                        //
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // High Intensity.
                    //

                    case 1:
                        BlEfiSetAttribute( ATT_FG_INTENSE );
                        //TextSetCurrentAttribute(0xf);
                        HighIntensity = TRUE;
                        break;

                    //
                    // Underscored.
                    //

                    case 4:
                        break;

                    //
                    // Blink.
                    //

                    case 5:
                        //bugbug no blink in EFI
                        //TextSetCurrentAttribute(0x87);
                        Blink = TRUE;
                        break;

                    //
                    // Reverse Video.
                    //

                    case 7:
                        BlEfiSetInverseMode( TRUE );
                        //TextSetCurrentAttribute(0x70);
                        HighIntensity = FALSE;
                        Blink = FALSE;
                        break;

                    //
                    // Font selection, not implemented yet.
                    //

                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                    case 19:
                        break;

                    //
                    // Foreground Color
                    //

                    case 30:
                    case 31:
                    case 32:
                    case 33:
                    case 34:
                    case 35:
                    case 36:
                    case 37:
                    //bugbug EFI
#if 0
                        a = TextGetCurrentAttribute();
                        a &= 0x70;
                        a |= TranslateColor[Parameter[Index]-30];
                        if (HighIntensity) {
                            a |= 0x08;
                        }
                        if (Blink) {
                            a |= 0x80;
                        }
                        TextSetCurrentAttribute(a);
                        break;

                    //
                    // Background Color
                    //

                    case 40:
                    case 41:
                    case 42:
                    case 43:
                    case 44:
                    case 45:
                    case 46:
                    case 47:
                        a = TextGetCurrentAttribute();
                        a &= 0x8f;
                        a |= TranslateColor[Parameter[Index]-40] << 4;
                        TextSetCurrentAttribute(a);
                        break;
#endif
                    default:
                        break;
                    }
                }

            default:
                ControlSequence = FALSE;
                break;
            }

        //
        // This is not a control sequence, check for escape sequence.
        //

        } else {

            //
            // If escape sequence, check for control sequence, otherwise
            // process single character.
            //

            if (EscapeSequence) {

                //
                // Check for '[', means control sequence, any other following
                // character is ignored.
                //

                if (*String == '[') {

                    ControlSequence = TRUE;

                    //
                    // Initialize first parameter.
                    //

                    PCount = 0;
                    Parameter[0] = 0;
                }
                EscapeSequence = FALSE;

            //
            // This is not a control or escape sequence, process single character.
            //

            } else {

                switch (*String) {
                    //
                    // Check for escape sequence.
                    //

                    case ASCI_ESC:
                        EscapeSequence = TRUE;
                        break;

                    default:
                        TextCharOut(String);
                        break;
                }

            }
        }
    }
    return Status;
}


ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Opens a BIOS-accessible disk for raw sector access.

Arguments:

    DriveId - Supplies the BIOS DriveId of the drive to open
              0 - Floppy 0
              1 - Floppy 1
              0x80 - Hard Drive 0
              0x81 - Hard Drive 1
              0x82 - Hard Drive 2
              etc

              High bit set and ID > 0x81 means the device is expected to be
              a CD-ROM drive.

    OpenMode - Supplies the mode of the open

    FileId - Supplies a pointer to a variable that specifies the file
             table entry that is filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    EFI_HANDLE DeviceHandle;
    PDRIVE_CONTEXT Context;
    BOOLEAN IsCd;

    DBGOUT((TEXT("BiosDiskOpen: enter, id = 0x%x\r\n"),DriveId));

    //
    // Check special drive number encoding for CD-ROM case
    //
    if(DriveId >= 0x80000000) {
        IsCd = TRUE;
        DriveId &= 0x7fffffff;
    } else {
        IsCd = FALSE;
    }

    if( OpenMode == FloppyOpenMode ) {

        //
        // Must be floppy.
        //
        DeviceHandle = GetFloppyDrive( DriveId );

        if (DeviceHandle == (EFI_HANDLE) DEVICE_NOT_FOUND) {
            return EBADF;
        }

    } else {
    if( IsCd ) {

        //
        // For cd, we get the device we booted from.
        //
#ifndef FORCE_CD_BOOT
        DeviceHandle = GetCd();

        if (DeviceHandle == (EFI_HANDLE) DEVICE_NOT_FOUND) {
            return EBADF;
        }

#else
        DeviceHandle = GetCdTest();

        if (DeviceHandle == (EFI_HANDLE)0)
          return EBADF;
#endif // for FORCE_CD_BOOT

    } else {

        //
        // For harddrive, we get the harddrive associated
        // with the passed-in rdisk (DriveId) value.
        //
        DeviceHandle = GetHardDrive( DriveId );
        if (DeviceHandle == (EFI_HANDLE) DEVICE_NOT_FOUND) {
            DBGOUT((TEXT("GetHardDrive returns DEVICE_NOT_FOUND %x\r\n"),DriveId));
            return EBADF;
        }
    }
    }
    //
    // Find an available FileId descriptor to open the device with
    //
    *FileId=2;

    while (BlFileTable[*FileId].Flags.Open != 0) {
        *FileId += 1;
        if(*FileId == BL_FILE_TABLE_SIZE) {
            DBGOUT((TEXT("BiosDiskOpen: no file table entry available\r\n")));
            DBGPAUSE
            return(ENOENT);
        }
    }

    //
    // We found an entry we can use, so mark it as open.
    //
    BlFileTable[*FileId].Flags.Open = 1;
    BlFileTable[*FileId].DeviceEntryTable = IsCd
                                          ? &BiosEDDSEntryTable
                                          : &BiosDiskEntryTable;


    Context = &(BlFileTable[*FileId].u.DriveContext);
    Context->DeviceHandle = (ULONGLONG) DeviceHandle;
    Context->xInt13 = TRUE;


    DBGOUT((TEXT("BiosDiskOpen: exit success\r\n")));

    return(ESUCCESS);
}

ARC_STATUS
BiospWritePartialSector(
    IN UCHAR Int13Unit,
    IN ULONGLONG Sector,
    IN PUCHAR Buffer,
    IN BOOLEAN IsHead,
    IN ULONG Bytes,
    IN UCHAR SectorsPerTrack,
    IN USHORT Heads,
    IN USHORT Cylinders,
    IN BOOLEAN AllowXInt13,
    IN ULONGLONG DeviceHandle
    )
{
    ARC_STATUS Status;

    UNREFERENCED_PARAMETER( Int13Unit );
    UNREFERENCED_PARAMETER( AllowXInt13 );
    UNREFERENCED_PARAMETER( Cylinders );
    UNREFERENCED_PARAMETER( Heads );
    UNREFERENCED_PARAMETER( SectorsPerTrack );

    //
    // Read sector into the write buffer
    //
    Status = ReadExtendedPhysicalSectors(
                DeviceHandle,
                Sector,
                1,
                LocalBuffer
                );

    if(Status != ESUCCESS) {
        return(Status);
    }

    //
    // Transfer the appropriate bytes from the user buffer to the write buffer
    //
    RtlMoveMemory(
        IsHead ? (LocalBuffer + Bytes) : LocalBuffer,
        Buffer,
        IsHead ? (SECTOR_SIZE - Bytes) : Bytes
        );

    //
    // Write the sector out
    //
    Status = WriteExtendedPhysicalSectors(
                DeviceHandle,
                Sector,
                1,
                LocalBuffer
                );
    return(Status);
}


ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    Writes sectors directly to an open physical disk.

Arguments:

    FileId - Supplies the file to write to

    Buffer - Supplies buffer with data to write

    Length - Supplies number of bytes to write

    Count - Returns actual bytes written

Return Value:

    ESUCCESS - write completed successfully

    !ESUCCESS - write failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    ULONGLONG DeviceHandle;
    UCHAR Int13Unit;
    ULONG HeadOffset,TailByteCount;
    UCHAR SectorsPerTrack;
    USHORT Heads,Cylinders;
    BOOLEAN AllowXInt13;
    ARC_STATUS Status;
    ULONG BytesLeftToTransfer;
    UCHAR SectorsToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    PUCHAR UserBuffer;
    ULONG         PhysicalSectors;

    BytesLeftToTransfer = Length;
    PhysicalSectors = SECTOR_SIZE;

    if(!LocalBuffer) {
        LocalBuffer = BlAllocateHeapAligned(SCRATCH_BUFFER_SIZE);
        if(!LocalBuffer) {
            Status = ENOMEM;
            goto BiosDiskWriteDone;
        }
    }

    HeadSector = BlFileTable[FileId].Position.QuadPart / PhysicalSectors;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % PhysicalSectors);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length) / PhysicalSectors;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length) % PhysicalSectors);

    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;
    DeviceHandle = BlFileTable[FileId].u.DriveContext.DeviceHandle;

    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;

    UserBuffer = Buffer;

    //
    // Special case of transfer occuring entirely within one sector
    //
    CurrentSector = HeadSector;

    if(HeadOffset && TailByteCount && (HeadSector == TailSector)) {

        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    HeadSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        RtlMoveMemory(LocalBuffer+HeadOffset,Buffer,Length);

        Status = WriteExtendedPhysicalSectors(
                    DeviceHandle,
                    CurrentSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            goto BiosDiskWriteDone;
        }

        BytesLeftToTransfer = 0;
        goto BiosDiskWriteDone;
    }

    if(HeadOffset) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    HeadSector,
                    Buffer,
                    TRUE,
                    HeadOffset,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13,
                    DeviceHandle
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= PhysicalSectors - HeadOffset;
        UserBuffer += PhysicalSectors - HeadOffset;
        CurrentSector += 1;
    }

    if(TailByteCount) {

        Status = BiospWritePartialSector(
                    Int13Unit,
                    TailSector,
                    (PUCHAR)Buffer + Length - TailByteCount,
                    FALSE,
                    TailByteCount,
                    SectorsPerTrack,
                    Heads,
                    Cylinders,
                    AllowXInt13,
                    DeviceHandle
                    );

        if(Status != ESUCCESS) {
            return(Status);
        }

        BytesLeftToTransfer -= TailByteCount;
    }

    //
    // The following calculation is not inside the transfer loop because
    // it is unlikely that a caller's buffer will *cross* the 1 meg line
    // due to the PC memory map.
    //
    if((ULONG_PTR) UserBuffer + BytesLeftToTransfer <= 0x100000) {
        Under1MegLine = TRUE;
    } else {
        Under1MegLine = FALSE;
    }

    //
    // Now handle the middle part.  This is some number of whole sectors.
    //
    while(BytesLeftToTransfer) {

        //
        // The number of sectors to transfer is the minimum of:
        // - the number of sectors left in the current track
        // - BytesLeftToTransfer / SECTOR_SIZE
        //
        // Because sectors per track is 1-63 we know this will fit in a UCHAR
        //
        if (AllowXInt13) {
            //
            // Ignore cylinders & heads & track information for XINT13 cases
            //
            SectorsToTransfer = (UCHAR)(BytesLeftToTransfer / PhysicalSectors);
        } else {
            SectorsToTransfer = (UCHAR)min(
                                        SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                        BytesLeftToTransfer / PhysicalSectors
                                        );
        }

        //
        // Now we'll figure out where to transfer the data from.  If the
        // caller's buffer is under the 1 meg line, we can transfer the
        // data directly from the caller's buffer.  Otherwise we'll copy the
        // user's buffer to our local buffer and transfer from there.
        // In the latter case we can only transfer in chunks of
        // SCRATCH_BUFFER_SIZE because that's the size of the local buffer.
        //
        // Also make sure the transfer won't cross a 64k boundary.
        //
        // We also need to make sure the transfer buffer is properly aligned.
        // Otherwise, EFI can return an error.
        //
        if(Under1MegLine && 
           (!((ULONG_PTR)UserBuffer & (sizeof(ULONG_PTR)-1)))) {
            //
            // Check if the transfer would cross a 64k boundary.  If so,
            // use the local buffer.  Otherwise use the user's buffer.
            //
            if(((ULONG_PTR)UserBuffer & 0xffffffffffff0000) !=
              (((ULONG_PTR)UserBuffer + (SectorsToTransfer * PhysicalSectors) - 1) & 0xffffffffffff0000))
            {
                TransferBuffer = LocalBuffer;
                SectorsToTransfer = (UCHAR)min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);

            } else {

                TransferBuffer = UserBuffer;
            }
        } else {
            TransferBuffer = LocalBuffer;
            SectorsToTransfer = (UCHAR)min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / (USHORT)PhysicalSectors);
        }

        if(TransferBuffer == LocalBuffer) {
            RtlMoveMemory(LocalBuffer,UserBuffer,SectorsToTransfer*PhysicalSectors);
        }

        Status = WriteExtendedPhysicalSectors(
                    DeviceHandle,
                    CurrentSector,
                    SectorsToTransfer,
                    TransferBuffer
                    );

        if(Status != ESUCCESS) {
            //
            // Tail part isn't contiguous with middle part
            //
            BytesLeftToTransfer += TailByteCount;
            return(Status);
        }

        CurrentSector += SectorsToTransfer;
        BytesLeftToTransfer -= SectorsToTransfer * PhysicalSectors;
        UserBuffer += SectorsToTransfer * PhysicalSectors;
    }

    Status = ESUCCESS;

    BiosDiskWriteDone:

    *Count = Length - BytesLeftToTransfer;
    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
pBiosDiskReadWorker(
    IN  ULONG   FileId,
    OUT PVOID   Buffer,
    IN  ULONG   Length,
    OUT PULONG  Count,
    IN  USHORT  SectorSize,
    IN  BOOLEAN xInt13
    )

/*++

Routine Description:

    Reads sectors directly from an open physical disk.

Arguments:

    FileId - Supplies the file to read from

    Buffer - Supplies buffer to hold the data that is read

    Length - Supplies maximum number of bytes to read

    Count - Returns actual bytes read

Return Value:

    ESUCCESS - Read completed successfully

    !ESUCCESS - Read failed

--*/

{
    ULONGLONG HeadSector,TailSector,CurrentSector;
    ULONG HeadOffset,TailByteCount;
    ULONG BytesLeftToTransfer;
    USHORT Heads,Cylinders;
    UCHAR SectorsPerTrack;
    UCHAR Int13Unit;
    ULONGLONG DeviceHandle;
    ARC_STATUS Status;
    PUCHAR UserBuffer;
    UCHAR SectorsToTransfer;
    BOOLEAN Under1MegLine;
    PVOID TransferBuffer;
    BOOLEAN AllowXInt13;

    DBGOUT((TEXT("BiosDiskRead: enter; length=0x%lx, sector size=%u, xint13=%u\r\n"),Length,SectorSize,xInt13));

    BytesLeftToTransfer = Length;

    if(!LocalBuffer) {
        LocalBuffer = BlAllocateHeapAligned(SCRATCH_BUFFER_SIZE);
        if(!LocalBuffer) {
            Status = ENOMEM;
            DBGOUT((TEXT("BiosDiskRead: out of memory\r\n")));
            goto BiosDiskReadDone;
        }
    }

    SectorsPerTrack = BlFileTable[FileId].u.DriveContext.Sectors;
    Heads = BlFileTable[FileId].u.DriveContext.Heads;
    Cylinders = BlFileTable[FileId].u.DriveContext.Cylinders;
    AllowXInt13 = BlFileTable[FileId].u.DriveContext.xInt13;
    Int13Unit = BlFileTable[FileId].u.DriveContext.Drive;
    DeviceHandle = BlFileTable[FileId].u.DriveContext.DeviceHandle;

    HeadSector = BlFileTable[FileId].Position.QuadPart / SectorSize;
    HeadOffset = (ULONG)(BlFileTable[FileId].Position.QuadPart % SectorSize);

    TailSector = (BlFileTable[FileId].Position.QuadPart + Length) / SectorSize;
    TailByteCount = (ULONG)((BlFileTable[FileId].Position.QuadPart + Length) % SectorSize);

    UserBuffer = Buffer;

    DBGOUT((
        TEXT("BiosDiskRead: unit 0x%x CHS=%lu %lu %lu\r\n"),
        Int13Unit,
        Cylinders,
        Heads,
        SectorsPerTrack
        ));

    DBGOUT((
        TEXT("BiosDiskRead: head=0x%lx%lx tail=0x%lx%lx\r\n"),
        (ULONG)(HeadSector >> 32),
        (ULONG)HeadSector,
        (ULONG)(TailSector >> 32),
        (ULONG)TailSector
        ));

    CurrentSector = HeadSector;
    if(HeadOffset && TailByteCount && (HeadSector == TailSector)) {
        //
        // Read contained entirely within one sector, and does not start or
        // end on the sector boundary.
        //
        DBGOUT((TEXT("BiosDiskRead: read entirely within one sector\r\n")));
        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    HeadSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            goto BiosDiskReadDone;
        }

        RtlMoveMemory(Buffer,LocalBuffer + HeadOffset,Length);
        BytesLeftToTransfer = 0;
        goto BiosDiskReadDone;
    }

    if(HeadOffset) {
        //
        // The leading part of the read is not aligned on a sector boundary.
        // Fetch the partial sector and transfer it into the caller's buffer.
        //
        DBGOUT((TEXT("BiosDiskRead: reading partial head sector\r\n")));
        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    HeadSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            goto BiosDiskReadDone;
        }

        RtlMoveMemory(Buffer,LocalBuffer + HeadOffset,SectorSize - HeadOffset);

        BytesLeftToTransfer -= SectorSize - HeadOffset;
        UserBuffer += SectorSize - HeadOffset;
        CurrentSector = HeadSector + 1;
    }

    if(TailByteCount) {
        //
        // The trailing part of the read is not a full sector.
        // Fetch the partial sector and transfer it into the caller's buffer.
        //
        DBGOUT((TEXT("BiosDiskRead: reading partial tail sector\r\n")));
        Status = ReadExtendedPhysicalSectors(
                    DeviceHandle,
                    TailSector,
                    1,
                    LocalBuffer
                    );

        if(Status != ESUCCESS) {
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            goto BiosDiskReadDone;
        }

        RtlMoveMemory( ((PUCHAR)Buffer+Length-TailByteCount), LocalBuffer, TailByteCount );
        BytesLeftToTransfer -= TailByteCount;
    }

    //
    // The following calculation is not inside the transfer loop because
    // it is unlikely that a caller's buffer will *cross* the 1 meg line
    // due to the PC memory map.
    //
    if((ULONG_PTR) UserBuffer + BytesLeftToTransfer <= 0x100000) {
        Under1MegLine = TRUE;
    } else {
        Under1MegLine = FALSE;
    }

    //
    // Now BytesLeftToTransfer is an integral multiple of sector size.
    //
    while(BytesLeftToTransfer) {

        //
        // The number of sectors to transfer is the minimum of:
        // - the number of sectors left in the current track
        // - BytesLeftToTransfer / SectorSize
        //
        //
        if(xInt13) {
            //
            // Arbitrary maximum sector count of 128. For a CD-ROM this is
            // 256K, which considering that the xfer buffer all has to be
            // under 1MB anyway, is pretty unlikely.
            //
            if((BytesLeftToTransfer / SectorSize) > 128) {
                SectorsToTransfer = 128;
            } else {
                SectorsToTransfer = (UCHAR)(BytesLeftToTransfer / SectorSize);
            }
        } else {
            //
            // Because sectors per track is 1-63 we know this will fit in a UCHAR.
            //
            SectorsToTransfer = (UCHAR)min(
                                        SectorsPerTrack - (CurrentSector % SectorsPerTrack),
                                        BytesLeftToTransfer / SectorSize
                                        );
        }

        //
        // Make sure the user specified buffer is large enough.  If it is not, 
        // use the local buffer.  Also if we can use the user buffer, make sure
        // it is properly aligned (along a quad-word).  Otherwise, EFI can 
        // return an error.
        //
        if ( ((ULONG)(SectorSize * SectorsToTransfer) > Length) ||
             ((ULONG_PTR)UserBuffer & (sizeof(ULONG_PTR) - 1)) ) {
            TransferBuffer = LocalBuffer;
            SectorsToTransfer = (UCHAR)min(SectorsToTransfer, SCRATCH_BUFFER_SIZE / SectorSize);
        } else {
            TransferBuffer = UserBuffer;
        }


        DBGOUT((
            TEXT("BiosDiskRead: reading 0x%x sectors @ 0x%lx%lx; buf=0x%lx\r\n"),
            SectorsToTransfer,
            (ULONG)(CurrentSector >> 32),
            (ULONG)CurrentSector,
            TransferBuffer
            ));

            Status = ReadExtendedPhysicalSectors(
                        DeviceHandle,
                        CurrentSector,
                        SectorsToTransfer,
                        TransferBuffer
                        );

        if(Status != ESUCCESS) {
            //
            // Trail part isn't contiguous
            //
            DBGOUT((TEXT("BiosDiskRead: read failed with %u\r\n"),Status));
            BytesLeftToTransfer += TailByteCount;
            goto BiosDiskReadDone;
        }

        if(TransferBuffer == LocalBuffer) {
            RtlMoveMemory(UserBuffer,LocalBuffer,SectorsToTransfer * SectorSize);
        }
        UserBuffer += SectorsToTransfer * SectorSize;
        CurrentSector += SectorsToTransfer;
        BytesLeftToTransfer -= SectorsToTransfer*SectorSize;
    }

    Status = ESUCCESS;
    DBGOUT((TEXT("BiosDiskRead: exit success\r\n")));

    BiosDiskReadDone:

    DBGPAUSE
    *Count = Length - BytesLeftToTransfer;
    BlFileTable[FileId].Position.QuadPart += *Count;
    return(Status);
}


ARC_STATUS
BiosDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    USHORT    PhysicalSectors;

    PhysicalSectors = SECTOR_SIZE;
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,PhysicalSectors,TRUE));
}


ARC_STATUS
BiosElToritoDiskRead(
    IN  ULONG  FileId,
    OUT PVOID  Buffer,
    IN  ULONG  Length,
    OUT PULONG Count
    )
{
    return(pBiosDiskReadWorker(FileId,Buffer,Length,Count,2048,TRUE));
}


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    )
{
    //
    // THIS ROUTINE DOES NOT WORK FOR PARTITION 0.
    //

    PPARTITION_CONTEXT Context;

    RtlZeroMemory(Finfo, sizeof(FILE_INFORMATION));

    Context = &BlFileTable[FileId].u.PartitionContext;

    Finfo->StartingAddress.QuadPart = Context->StartingSector;
    Finfo->StartingAddress.QuadPart = Finfo->StartingAddress.QuadPart << (CCHAR)Context->SectorShift;

    Finfo->EndingAddress.QuadPart = Finfo->StartingAddress.QuadPart + Context->PartitionLength.QuadPart;

    Finfo->Type = DiskPeripheral;

    return ESUCCESS;
}

ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    )
/*++

Routine Description:

    Gets the information about the disk.

Arguments:

    FileId - The file id to the disk for which information is needed

    FileInfo - Place holder for returning information about the disk

Return Value:

    ESUCCESS if successful, otherwise appropriate ARC error code.

--*/
{
    ARC_STATUS Status = EINVAL;

    if (FileInfo) {
        EFI_STATUS  EfiStatus;
        EFI_BLOCK_IO *EfiBlockIo = NULL;
        PDRIVE_CONTEXT  Context;

        Context = &BlFileTable[FileId].u.DriveContext;
        Status = EIO;

        FlipToPhysical();

        //
        // Get hold for the block IO protocol handle
        //
        EfiStatus = EfiBS->HandleProtocol((EFI_HANDLE)Context->DeviceHandle,
                            &EfiBlockIoProtocol,
                            &EfiBlockIo);

        FlipToVirtual();

        if (!EFI_ERROR(EfiStatus) && EfiBlockIo && EfiBlockIo->Media) {
            LONGLONG DiskSize = (EfiBlockIo->Media->BlockSize *
                                 EfiBlockIo->Media->LastBlock);

            if (DiskSize) {
                RtlZeroMemory(FileInfo, sizeof(FILE_INFORMATION));

                FileInfo->StartingAddress.QuadPart = 0;
                FileInfo->EndingAddress.QuadPart = DiskSize;
                FileInfo->CurrentPosition = BlFileTable[FileId].Position;

                //
                // NOTE : Anything less than 3MB is floppy drive
                //
                if ((DiskSize < 0x300000) && (EfiBlockIo->Media->RemovableMedia)) {
                    FileInfo->Type = FloppyDiskPeripheral;
                } else {
                    FileInfo->Type = DiskPeripheral;
                }

                Status = ESUCCESS;
            }
        }
    }

    return Status;
}


EFI_HANDLE
GetCd(
    )
{
    ULONG i;
    ULONGLONG DevicePathSize, SmallestPathSize;
    ULONG HandleCount;
    UINT8 Channel = 0;

    EFI_HANDLE *BlockIoHandles;

    EFI_DEVICE_PATH *DevicePath, *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    PCI_DEVICE_PATH *PciDevicePath;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    EFI_STATUS Status;

    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        return(ReturnDeviceHandle);
    }

    FlipToPhysical();
    SmallestPathSize = 0;

    for (i = 0; i < HandleCount; i++) {
        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &DevicePath
                    );


        if (EFI_ERROR(Status)) {
            EfiPrint(L"GetCd: HandleProtocol failed\r\n");
            goto exit;
        }

        DevicePathSize = GetDevPathSize(DevicePath);

        EfiAlignDp(&TestPathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;


        //
        // In the cd case, just return the device we booted from.
        //
        while (TestPath->Type != END_DEVICE_PATH_TYPE) {

            //
            // save the channel.  We'll use this later to compare against
            // the channel of the CDROM that we booted from.  This helps
            // us further ensure it's the CDROM we're looking for.
            //
            // Considerthe case where we have 2 CDROMs on the system, each
            // hanging off a different controller, each having the same
            // ID/LUN.  This will allow us to further distinguish between
            // the two.
            //
            if (TestPath->Type == HW_PCI_DP) {
                PciDevicePath = (PCI_DEVICE_PATH *)TestPath;
                Channel = PciDevicePath->Function;
            }


            if (TestPath->Type == MESSAGING_DEVICE_PATH) {
               if (TestPath->SubType == MSG_ATAPI_DP &&
                   BootContext.BusType == BootBusAtapi) {
                   //
                   // For ATAPI, match PrimarySecondary and SlaveMaster
                   // fields with the device we booted from.
                   //
                   AtapiDevicePath = (ATAPI_DEVICE_PATH *) TestPath;
                   BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContext.BootDevice);
                   if ( (AtapiDevicePath->PrimarySecondary == BootDeviceAtapi->PrimarySecondary) &&
                        (AtapiDevicePath->SlaveMaster == BootDeviceAtapi->SlaveMaster) &&
                        (AtapiDevicePath->Lun == BootDeviceAtapi->Lun) &&
                        ((SmallestPathSize == 0) || (DevicePathSize < SmallestPathSize)) ) {

                       //
                       // Remember the BlockIo Handle
                       //

                       ReturnDeviceHandle = BlockIoHandles[i];

                       //
                       // Update the SmallestPathSize
                       //

                       SmallestPathSize = DevicePathSize;

                       break;
                   }
               } else if (TestPath->SubType == MSG_SCSI_DP &&
                          BootContext.BusType == BootBusScsi) {
                   //
                   // For SCSI, match PUN and LUN fields with the
                   // device we booted from.
                   //
                   ScsiDevicePath = (SCSI_DEVICE_PATH *) TestPath;
                   BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContext.BootDevice);
                   if ((ScsiDevicePath->Pun == BootDeviceScsi->Pun) &&
                       (ScsiDevicePath->Lun == BootDeviceScsi->Lun) &&
                       (Channel == BootDeviceScsi->Channel) &&
                       ((SmallestPathSize == 0) || (DevicePathSize < SmallestPathSize)) ) {

                       //
                       // Remember the BlockIo Handle
                       //

                       ReturnDeviceHandle = BlockIoHandles[i];

                       //
                       // Update the SmallestPathSize
                       //

                       SmallestPathSize = DevicePathSize;

                       break;
                   }
               }
           } else if (TestPath->Type == HARDWARE_DEVICE_PATH) {
               if (TestPath->SubType == HW_VENDOR_DP &&
                   BootContext.BusType == BootBusVendor) {
                   UnknownDevicePath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath;
                   BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContext.BootDevice);

                   if ( (CompareGuid( &(UnknownDevicePath->DevicePath.Guid),
                                      &(BootDeviceUnknown->Guid)) == 0) &&
                        (UnknownDevicePath->LegacyDriveLetter ==
                         BootDeviceUnknown->LegacyDriveLetter) &&
                        ((SmallestPathSize == 0) || (DevicePathSize < SmallestPathSize)) ) {

                       //
                       // Remember the BlockIo Handle
                       //

                       ReturnDeviceHandle = BlockIoHandles[i];

                       //
                       // Update the SmallestPathSize
                       //

                       SmallestPathSize = DevicePathSize;

                       break;
                   }
               }
           }

           DevicePath = NextDevicePathNode(DevicePath);
           EfiAlignDp(&TestPathAligned,
                      DevicePath,
                      DevicePathNodeLength(DevicePath));

           TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#ifdef FORCE_CD_BOOT
    if (ReturnDeviceHandle == (EFI_HANDLE)DEVICE_NOT_FOUND) {
        EfiPrint(L"GetCD: LocateHandle failed\r\n");
        ReturnDeviceHandle = 0;
    }
#endif // for FORCE_CD_BOOT

    //
    // Change back to virtual mode.
    //
exit:
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}

ULONG
BlGetDriveId(
    ULONG DriveType,
    PBOOT_DEVICE Device
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;
    EFI_BLOCK_IO *          BlkIo;
    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = DEVICE_NOT_FOUND;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    ULONG DriveId;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONGLONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }


    // Save the number of cached Device Paths
    nCachedDevicePaths = i;
    ASSERT(nCachedDevicePaths == HandleCount);

    //
    // Find all of the harddrives
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {

            //
            // Look for Media HardDrive node
            //
            if(((EFI_DEVICE_PATH *) NextDevicePathNode( CurrentDevicePath ))->Type == END_DEVICE_PATH_TYPE) {



                //
                // Since we found a harddrive, find the
                // raw device associated with it.
                //
                nFoundDevice = DEVICE_NOT_FOUND;
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                    ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the ATAPI raw device
                        //
                        nFoundDevice = FindAtapiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary,
                            ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster,
                            ((ATAPI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_SCSI_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {
                        //
                        // Find SCSI raw device
                        //
                        nFoundDevice = FindScsiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((SCSI_DEVICE_PATH *) TestPath)->Pun,
                            ((SCSI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                           ( TestPath->SubType == HW_VENDOR_DP ) ) {

                    //
                    // Find the Hardware Vendor raw device by ensuring it is not a
                    // removable media
                    //

                        Status = EfiBS->HandleProtocol( BlockIoHandles[i], &EfiBlockIoProtocol, &(( EFI_BLOCK_IO * ) BlkIo) );
                        if(BlkIo->Media->RemovableMedia)
                            nFoundDevice = DEVICE_NOT_FOUND;
                        else
                            nFoundDevice = 1;
                }


                if( nFoundDevice != DEVICE_NOT_FOUND ) {
                    // Found a raw device
                     BlockIoHandlesBitmap[ i ] = i;

                     switch (DriveType) {
                         case BL_DISKTYPE_ATAPI:
                             if(  ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                                  ( TestPath->SubType == MSG_ATAPI_DP ) &&
                                  ( ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary ==
                                      ((PBOOT_DEVICE_ATAPI)Device)->PrimarySecondary) &&
                                  ( ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster ==
                                      ((PBOOT_DEVICE_ATAPI)Device)->SlaveMaster) &&
                                  ( ((ATAPI_DEVICE_PATH *) TestPath)->Lun ==
                                      ((PBOOT_DEVICE_ATAPI)Device)->Lun) ) {
                                 DriveId = nFoundDevice;
                                 //DriveId = i;
                             }
                             break;
                        case BL_DISKTYPE_SCSI:
                             if(  ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                                  ( TestPath->SubType == MSG_SCSI_DP ) &&
                                  ( ((SCSI_DEVICE_PATH *) TestPath)->Pun ==
                                      ((PBOOT_DEVICE_SCSI)Device)->Pun) &&
                                  ( ((SCSI_DEVICE_PATH *) TestPath)->Lun ==
                                      ((PBOOT_DEVICE_SCSI)Device)->Lun) ) {
                                 DriveId = nFoundDevice;
                                 //DriveId = i;
                             }
                             break;
                        case BL_DISKTYPE_UNKNOWN:
                             if(  ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                                  ( TestPath->SubType == HW_VENDOR_DP ) ) {
                                 DriveId = nFoundDevice;
                                 //DriveId = i;
                             }
                             break;
                         default:
                             break;
                     }

                }

            }  // if END_DEVICE_PATH_TYPE

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return nDriveCount;
    //return nFoundDevice;
    //return DriveId;
}


EFI_HANDLE
GetHardDrive(
    ULONG DriveId
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;
    EFI_BLOCK_IO *          BlkIo;
    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = DEVICE_NOT_FOUND;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONGLONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }

    // Save the number of cached Device Paths
    nCachedDevicePaths = i;

    //
    // Find all of the harddrives
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {

            //
            // Look for Media HardDrive node
            //
            if(((EFI_DEVICE_PATH *) NextDevicePathNode( CurrentDevicePath ))->Type == END_DEVICE_PATH_TYPE) {

                //
                // Since we found a harddrive, find the
                // raw device associated with it.
                //
                nFoundDevice = DEVICE_NOT_FOUND;
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                    ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the ATAPI raw device
                        //
                        nFoundDevice = FindAtapiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary,
                            ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster,
                            ((ATAPI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_SCSI_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find SCSI raw device
                        //
                        nFoundDevice = FindScsiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((SCSI_DEVICE_PATH *) TestPath)->Pun,
                            ((SCSI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_FIBRECHANNEL_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the FIBRECHANNEL raw device
                        //
                        nFoundDevice = FindFibreChannelDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((FIBRECHANNEL_DEVICE_PATH *) TestPath)->WWN,
                            ((FIBRECHANNEL_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                           ( TestPath->SubType == HW_VENDOR_DP ) ) {

                    //
                    // Find the Hardware Vendor raw device by ensuring it is not a
                    // removable media
                    //
                    Status = EfiBS->HandleProtocol( BlockIoHandles[i], &EfiBlockIoProtocol, &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(BlkIo->Media->RemovableMedia) {
                        nFoundDevice = DEVICE_NOT_FOUND;
                    }
                    else {
                        nFoundDevice = 1;
                    }
                }


                if( nFoundDevice != DEVICE_NOT_FOUND ) {
                    // Found a raw device
                    BlockIoHandlesBitmap[ i ] = i;
                }

            }  // if END_DEVICE_PATH_TYPE

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

    //
    // Count the bitmap and when we find
    // the DriveId, return the BlockIoHandle
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        if( BlockIoHandlesBitmap[i] != DEVICE_NOT_FOUND ) {
            if( nDriveCount++ == DriveId ) {
                ReturnDeviceHandle = BlockIoHandles[BlockIoHandlesBitmap[i]];
            }
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}

ULONG
FindAtapiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG PrimarySecondary,
     ULONG SlaveMaster,
    ULONG Lun
    )
{
    ULONG i = 0, nFoundDevice = 0;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    EFI_DEVICE_PATH *CurrentDevicePath;

    //
    // Find the Atapi raw device whose PrimarySecondary,
    // SlaveMaster and Lun are a match.
    //
    for( i=0; i<nDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) pDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( (TestPath->Type != END_DEVICE_PATH_TYPE) ) {

            if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                if( ( ((ATAPI_DEVICE_PATH *)TestPath)->PrimarySecondary == PrimarySecondary ) &&
                    ( ((ATAPI_DEVICE_PATH *)TestPath)->SlaveMaster == SlaveMaster ) &&
                    ( ((ATAPI_DEVICE_PATH *)TestPath)->Lun == Lun )) {

                    nFoundDevice = i;

                    return nFoundDevice;
                }
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#if DBG
    BlPrint( TEXT("FindAtapiDevice returning DEVICE_NOT_FOUND\r\n"));
    if (BdDebuggerEnabled == TRUE) {
        DbgBreakPoint();
    }
#endif

    return DEVICE_NOT_FOUND;
}

ULONG
FindScsiDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONG Pun,
    ULONG Lun
    )
{
    ULONG i = 0, nFoundDevice = 0;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    EFI_DEVICE_PATH *CurrentDevicePath;

    //
    // Find the Atapi raw device whose PrimarySecondary,
    // SlaveMaster and Lun are a match.
    //
    for( i=0; i<nDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) pDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( (TestPath->Type != END_DEVICE_PATH_TYPE) ) {

            if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                ( TestPath->SubType == MSG_SCSI_DP ) ) {

                if( ( ((SCSI_DEVICE_PATH *)TestPath)->Pun == Pun ) &&
                    ( ((SCSI_DEVICE_PATH *)TestPath)->Lun == Lun )) {

                    nFoundDevice = i;

                    return nFoundDevice;
                }
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#if DBG
    BlPrint( TEXT("FindScsiDevice returning DEVICE_NOT_FOUND\r\n"));
    if (BdDebuggerEnabled == TRUE) {
        DbgBreakPoint();
    }
#endif

    return DEVICE_NOT_FOUND;
}

ULONG
FindFibreChannelDevice(
    ULONGLONG *pDevicePaths,
    ULONG nDevicePaths,
    ULONGLONG WWN,
    ULONGLONG Lun
    )
/*++

Routine Description:

    This routine searches the supplied device path array for
    a device path that matches the supplied WWN and Lun.

Arguments:

    pDevicePaths - Pointer to an array of device paths
    nDevicePaths - Number of elements in the array
    WWN - World Wide Name of the device being queried
    Lun - Logical Unit Number of the device being queried

Return Value:

    The index associated with the first match encountered, DEVICE_NOT_FOUND otherwise.

--*/
{
    ULONG i = 0, nFoundDevice = 0;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    EFI_DEVICE_PATH *CurrentDevicePath;

    //
    // Find the FibreChannel raw device whose WWN and Lun are a match.
    //
    for( i=0; i<nDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) pDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( (TestPath->Type != END_DEVICE_PATH_TYPE) ) {

            if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                ( TestPath->SubType == MSG_FIBRECHANNEL_DP ) ) {

                if( ( ((FIBRECHANNEL_DEVICE_PATH *)TestPath)->WWN == WWN ) &&
                    ( ((FIBRECHANNEL_DEVICE_PATH *)TestPath)->Lun == Lun )) {

                    nFoundDevice = i;

                    return nFoundDevice;
                }
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

#if DBG
    BlPrint( TEXT("FindFibreChannelDevice returning DEVICE_NOT_FOUND\r\n"));
    if (BdDebuggerEnabled == TRUE) {
        DbgBreakPoint();
    }
#endif

    return DEVICE_NOT_FOUND;
}

ULONG
GetDriveCount(
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;
    EFI_BLOCK_IO *          BlkIo;
    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    ULONG nFoundDevice = 0;
    ULONG nDriveCount = 0;
    EFI_DEVICE_PATH *CurrentDevicePath;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONGLONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }

    // Save the number of cached Device Paths
    nCachedDevicePaths = i;

    //
    // Find all of the harddrives
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];
        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {

            //
            // Look for Media HardDrive node
            //
            if(((EFI_DEVICE_PATH *) NextDevicePathNode( CurrentDevicePath ))->Type == END_DEVICE_PATH_TYPE) {

                //
                // Since we found a harddrive, find the
                // raw device associated with it.
                //
                nFoundDevice = DEVICE_NOT_FOUND;
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                    ( TestPath->SubType == MSG_ATAPI_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the ATAPI raw device
                        //
                        nFoundDevice = FindAtapiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((ATAPI_DEVICE_PATH *) TestPath)->PrimarySecondary,
                            ((ATAPI_DEVICE_PATH *) TestPath)->SlaveMaster,
                            ((ATAPI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_SCSI_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find SCSI raw device
                        //
                        nFoundDevice = FindScsiDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((SCSI_DEVICE_PATH *) TestPath)->Pun,
                            ((SCSI_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                           ( TestPath->SubType == MSG_FIBRECHANNEL_DP ) ) {

                    Status = EfiBS->HandleProtocol(
                                            BlockIoHandles[i],
                                            &EfiBlockIoProtocol,
                                            &(( EFI_BLOCK_IO * ) BlkIo) );
                    if(!BlkIo->Media->RemovableMedia) {

                        //
                        // Find the FIBRECHANNEL raw device
                        //
                        nFoundDevice = FindFibreChannelDevice(
                            CachedDevicePaths,
                            nCachedDevicePaths,
                            ((FIBRECHANNEL_DEVICE_PATH *) TestPath)->WWN,
                            ((FIBRECHANNEL_DEVICE_PATH *) TestPath)->Lun
                            );
                    }

                } else if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                           ( TestPath->SubType == HW_VENDOR_DP ) ) {

                    //
                    // Find the Hardware Vendor raw device by ensuring it is not a
                    // removable media
                    //

                        Status = EfiBS->HandleProtocol( BlockIoHandles[i], &EfiBlockIoProtocol, &(( EFI_BLOCK_IO * ) BlkIo) );
                        if(BlkIo->Media->RemovableMedia)
                            ;
                        else
                            nFoundDevice = 1;
                }


                if( nFoundDevice != DEVICE_NOT_FOUND ) {
                    // Found a raw device
                     BlockIoHandlesBitmap[ i ] = nFoundDevice;
                }

            }  // if END_DEVICE_PATH_TYPE

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }   // while
    }   // for

    //
    // Count the bitmap and when we find
    // the DriveId, return the BlockIoHandle
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {

        if( BlockIoHandlesBitmap[i] != DEVICE_NOT_FOUND ) {

            nDriveCount++;
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return nDriveCount;
}

BOOLEAN
IsVirtualFloppyDevice(
    EFI_HANDLE DeviceHandle
    )
/*++

Routine Description:

    Finds out if the given device is a virtual floppy (i.e. RAM Disk).

    NOTE : Currently we assume that if a device supports
    Block, Disk, File System & LoadedImage protocols then it should
    be virtual floppy. Also assumes that FlipToPhysical(...) has be
    already been called.

Arguments:

    DeviceHandle - Handle to the device which needs to be tested.

Return Value:

    TRUE if the device is virtual floppy otherwise FALSE

--*/
{
    BOOLEAN Result = FALSE;

    if (DeviceHandle != (EFI_HANDLE)DEVICE_NOT_FOUND) {
        EFI_STATUS  EfiStatus;
        EFI_BLOCK_IO *EfiBlock = NULL;
        EFI_DISK_IO  *EfiDisk = NULL;
        EFI_LOADED_IMAGE *EfiImage = NULL;
        EFI_FILE_IO_INTERFACE *EfiFs = NULL;

        //
        // Get hold of the loaded image protocol handle
        //
        EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                &EfiLoadedImageProtocol,
                                &EfiImage);

        if (!EFI_ERROR(EfiStatus) && EfiImage) {
            //
            // Get hold of the FS protocol handle
            //
            EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                    &EfiFilesystemProtocol,
                                    &EfiFs);

            if (!EFI_ERROR(EfiStatus) && EfiFs) {
                //
                // Get hold of the disk protocol
                //
                EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                        &EfiDiskIoProtocol,
                                        &EfiDisk);

                if (!EFI_ERROR(EfiStatus) && EfiDisk) {
                    //
                    // Get hold of the block protocol
                    //
                    EfiStatus = EfiBS->HandleProtocol(DeviceHandle,
                                            &EfiBlockIoProtocol,
                                            &EfiBlock);

                    if (!EFI_ERROR(EfiStatus) && EfiBlock) {
                        Result = TRUE;
                    }
                }
            }
        }
    }

    return Result;
}


EFI_HANDLE
GetFloppyDrive(
    ULONG DriveId
    )
{
    ULONG i;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;
    ULONG nCachedDevicePaths = 0;
    ULONGLONG *CachedDevicePaths;

    ULONG HandleCount;
    EFI_HANDLE *BlockIoHandles;
    EFI_DEVICE_PATH *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ULONG *BlockIoHandlesBitmap;
    EFI_DEVICE_PATH *CurrentDevicePath;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) DEVICE_NOT_FOUND;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlGetEfiProtocolHandles failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now that we know how many handles there are, we can allocate space for
    // the CachedDevicePaths and BlockIoHandlesBitmap
    //
    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONGLONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CachedDevicePaths = (ULONGLONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    ArcStatus =  BlAllocateAlignedDescriptor(
                            LoaderFirmwareTemporary,
                            0,
                            BYTES_TO_PAGES(HandleCount*sizeof(ULONG)),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"BlGetDriveId: BlAllocateAlignedDescriptor failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    BlockIoHandlesBitmap = (ULONG *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();
    RtlZeroMemory(CachedDevicePaths, HandleCount*sizeof(ULONGLONG));
    for (i=0;i<HandleCount; i++) {
        BlockIoHandlesBitmap[i] = DEVICE_NOT_FOUND;
    }

    //
    // Cache all of the EFI Device Paths
    //
    for (i = 0; i < HandleCount; i++) {

        Status = EfiBS->HandleProtocol (
                    BlockIoHandles[i],
                    &EfiDevicePathProtocol,
                    &( (EFI_DEVICE_PATH *) CachedDevicePaths[i] )
                    );
    }

    // Save the number of cached Device Paths
    nCachedDevicePaths = i;

    //
    // Find the floppy.
    //
    for( i=0; i<nCachedDevicePaths; i++ ) {
        //
        // Get next device path.
        //
        CurrentDevicePath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];

        EfiAlignDp(
            &TestPathAligned,
            CurrentDevicePath,
            DevicePathNodeLength( CurrentDevicePath )
            );

        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

        while( ( TestPath->Type != END_DEVICE_PATH_TYPE ) ) {
            if (!DriveId) {
                if( ( TestPath->Type == HARDWARE_DEVICE_PATH ) &&
                               ( TestPath->SubType == HW_VENDOR_DP ) ) {
                    //
                    // Find the Hardware Vendor raw device
                    //
                    if(!(((UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath)->LegacyDriveLetter & 0x80) &&
                        !(((UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath)->LegacyDriveLetter == 0xFF)
                        ) {
                        ReturnDeviceHandle = BlockIoHandles[i];

                        // Bail-out.
                        i = nCachedDevicePaths;
                        break;
                    }
                } else if (TestPath->Type == MESSAGING_DEVICE_PATH &&
                          TestPath->SubType == MSG_ATAPI_DP) {
                    //
                    // For ATAPI "floppy drive", we're really looking for a
                    // removable block IO device with a 512 byte block size, as
                    // this signature matches the ls120 style floppy drives and
                    // keeps us from accidentally finding cdrom drives.
                    //
                    // our search algorithm short-circuits when we find the
                    // first suitable device
                    //
                    EFI_DEVICE_PATH *TmpTestPath, *AtapiTestPath;
                    EFI_DEVICE_PATH_ALIGNED AtapiTestPathAligned;
                    EFI_BLOCK_IO * BlkIo;
                    BOOLEAN DefinitelyACDROM = FALSE;

                    Status = EfiBS->HandleProtocol(
                                         BlockIoHandles[i],
                                         &EfiBlockIoProtocol,
                                         &(( EFI_BLOCK_IO * ) BlkIo) );

#if 0
                    if (EFI_ERROR(Status)) {
                        DBGOUT((L"getting BlkIo interface failed, ec=%x\r\n",Status));
                    } else {
                        DBGOUT((L"Block size = %x, removable media = %s\r\n",
                                BlkIo->Media->BlockSize,
                                BlkIo->Media->RemovableMedia ? L"TRUE" : L"FALSE" ));
                    }
#endif


                    TmpTestPath = (EFI_DEVICE_PATH *) CachedDevicePaths[i];

                    EfiAlignDp(
                        &AtapiTestPathAligned,
                        TmpTestPath,
                        DevicePathNodeLength( TmpTestPath )
                        );

                    AtapiTestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

                    //
                    // test the device
                    // removable media?  512 byte block size?
                    //
                    if (!EFI_ERROR(Status) && (BlkIo->Media->RemovableMedia)
                        && BlkIo->Media->BlockSize == 512) {

                        //
                        // let's be doubly sure and make sure there
                        // isn't a cdrom device path attached to this
                        // device path
                        //
                        while (AtapiTestPath->Type != END_DEVICE_PATH_TYPE ) {

                            if (AtapiTestPath->Type == MEDIA_DEVICE_PATH &&
                                AtapiTestPath->SubType == MEDIA_CDROM_DP) {
                                DefinitelyACDROM = TRUE;
                            }
                            //
                            // Get next device path node.
                            //
                            TmpTestPath = NextDevicePathNode( TmpTestPath );

                            EfiAlignDp(
                                &AtapiTestPathAligned,
                                TmpTestPath,
                                DevicePathNodeLength( TmpTestPath )
                                );

                            AtapiTestPath = (EFI_DEVICE_PATH *) &AtapiTestPathAligned;

                        }

                        if (DefinitelyACDROM == FALSE) {
                            //
                            // found the first floppy drive.
                            // Remember the BlockIo Handle
                            //
                            ReturnDeviceHandle = BlockIoHandles[i];
                            break;
                        }
                    }
                }
            } else {
                //
                // Find the logical vendor device
                //
                if( ( TestPath->Type == MESSAGING_DEVICE_PATH ) &&
                               ( TestPath->SubType == MSG_VENDOR_DP ) ) {

                    if (IsVirtualFloppyDevice(BlockIoHandles[i])) {
                        DriveId--;

                        //
                        // Is this the device we were looking for?
                        //
                        if (!DriveId) {
                            ReturnDeviceHandle = BlockIoHandles[i];

                            i = nCachedDevicePaths; // for outer loop
                            break;      // found the virtual floppy device we were looking for
                        }
                    }
                }
            }

            //
            // Get next device path node.
            //
            CurrentDevicePath = NextDevicePathNode( CurrentDevicePath );
            EfiAlignDp(
                &TestPathAligned,
                CurrentDevicePath,
                DevicePathNodeLength( CurrentDevicePath )
                );

            TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandlesBitmap >> PAGE_SHIFT) );
    BlFreeDescriptor( (ULONG)((ULONGLONG)CachedDevicePaths >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}


#ifdef FORCE_CD_BOOT

EFI_DEVICE_PATH *
DevicePathFromHandle (
    IN EFI_HANDLE       Handle
    )
{
    EFI_STATUS          Status;
    EFI_DEVICE_PATH     *DevicePath;
    EFI_GUID DevicePathProtocol;

    Status = EfiBS->HandleProtocol (Handle, &DevicePathProtocol, (VOID*)&DevicePath);

    if (EFI_ERROR(Status)) {
        DevicePath = NULL;
    }

    return DevicePath;
}


ARC_STATUS
IsUDFSFileSystem(
    IN EFI_HANDLE Handle
    )
/*++

Routine Description:

  Mounts the UDFS Volume on the device and updates the
  file system state (global data structures)

Arguments:

  Volume - UDF Volume pointer
  DeviceId - Device on which the Volume may be residing

Return Value:

  ESUCCESS if successful otherwise EBADF (if no UDF volume was found)

--*/
{
    ARC_STATUS  Status = EBADF;
    UCHAR           UBlock[UDF_BLOCK_SIZE+256] = {0};
    PUCHAR      Block = ALIGN_BUFFER(UBlock);
    ULONG       BlockIdx = 256;
    ULONG       LastBlock = 0;
    EFI_STATUS  EfiStatus;
    EFI_BLOCK_IO *BlkDev;

    EfiStatus = EfiBS->HandleProtocol(
                                     Handle,
                                     &EfiBlockIoProtocol,
                                     &BlkDev);

    if ((EfiStatus == EFI_SUCCESS) && (BlkDev) && (BlkDev->Media) &&
        (BlkDev->Media->RemovableMedia == TRUE)) {
        // get hold of Anchor Volume Descriptor
        EfiStatus = BlkDev->ReadBlocks(
                                      BlkDev,
                                      BlkDev->Media->MediaId,
                                      BlockIdx,
                                      UDF_BLOCK_SIZE,
                                      Block);

        if (EfiStatus == EFI_SUCCESS) {
            if (*(PUSHORT)Block == 0x2) {
                // get partition descriptor
                PNSR_PART Part;
                PWCHAR    TagID;
                ULONG     BlockIdx = *(PULONG)(Block + 20);

                do {
                    EfiStatus = BlkDev->ReadBlocks(
                                                  BlkDev,
                                                  BlkDev->Media->MediaId,
                                                  BlockIdx++,
                                                  UDF_BLOCK_SIZE,
                                                  Block);

                    TagID = (PWCHAR)Block;
                }
                while ((EfiStatus == ESUCCESS) && (*TagID) &&
                       (*TagID != 0x8) && (*TagID != 0x5));

                if ((EfiStatus == ESUCCESS) && (*TagID == 0x5)) {
                    Status = ESUCCESS;
                }
            }
        }
    }

    return Status;
}


ARC_STATUS
IsCDFSFileSystem(
    IN EFI_HANDLE Handle
    )
/*++

Routine Description:

  Mounts the CDFS Volume on the device and updates the
  file system state (global data structures)

Arguments:


Return Value:

  ESUCCESS if successful otherwise EBADF (if no CDFS volume was found)

--*/
{
    EFI_DEVICE_PATH *Dp;
    ARC_STATUS Status = EBADF;


    Dp=DevicePathFromHandle(Handle);


    if (Dp) {
        while (!IsDevicePathEnd (Dp) && (Status == EBADF)) {
            if ((Dp->Type == MEDIA_DEVICE_PATH) &&
                (Dp->SubType == MEDIA_CDROM_DP) ) {
                Status = ESUCCESS;
            }
            Dp=NextDevicePathNode(Dp);
        }
    }

    return Status;
}


EFI_HANDLE
GetCdTest(
    VOID
    )
{
    ULONG i;
    ULONGLONG DevicePathSize, SmallestPathSize;
    ULONG HandleCount;

    EFI_HANDLE *BlockIoHandles;

    EFI_HANDLE DeviceHandle = NULL;
    EFI_DEVICE_PATH *DevicePath, *TestPath,*Dp;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    EFI_STATUS Status;
    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
//    PBOOT_DEVICE_TCPIPv4 BootDeviceTcpipV4;
//    PBOOT_DEVICE_TCPIPv6 BootDeviceTcpipV6;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;
    EFI_HANDLE ReturnDeviceHandle = (EFI_HANDLE) 0;
    ARC_STATUS ArcStatus;

    //
    // get all handles that support the block I/O protocol.
    //
    ArcStatus = BlGetEfiProtocolHandles(
                        &EfiBlockIoProtocol,
                        &BlockIoHandles,
                        &HandleCount);
    if (ArcStatus != ESUCCESS) {
        EfiPrint(L"GetCdTest: BlGetEfiProtocolHandles failed\r\n");
        return(ReturnDeviceHandle);
    }

    //
    // change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();

    SmallestPathSize = 0;

    for (i = 0,; i < HandleCount; i++) {

      if (IsUDFSFileSystem(BlockIoHandles[i]) == ESUCCESS) {
        ReturnDeviceHandle = BlockIoHandles[i];
        break;
      }
    }

    if (ReturnDeviceHandle == (EFI_HANDLE) 0) {

        for (i = 0; i < HandleCount; i++) {
            if (IsCDFSFileSystem (BlockIoHandles[i]) == ESUCCESS) {
                ReturnDeviceHandle = BlockIoHandles[i];
                break;
            }

        }
    }

    //
    // Change back to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)BlockIoHandles >> PAGE_SHIFT) );

    return ReturnDeviceHandle;
}

#endif // for FORCE_CD_BOOT


//
// Turn off the timer so we don't reboot waiting for the user to press a key
//
void
DisableEFIWatchDog (
    VOID
    )
{
    BOOLEAN WasVirtual;

    //
    // Remember if we started off in virtual mode
    //
    WasVirtual = IsPsrDtOn();

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    if (WasVirtual) {
        FlipToPhysical();
    }

    EfiBS->SetWatchdogTimer (0,0,0,NULL);

    //
    // Flip back to Virtual mode if called that way
    //
    if (WasVirtual) {
        FlipToVirtual();
    }
}

//
// Set the watch dog timer
//
VOID
SetEFIWatchDog (
    ULONG Timeout
    )
{
    BOOLEAN WasVirtual;

    //
    // Remember if we started off in virtual mode
    //
    WasVirtual = IsPsrDtOn();

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    if (WasVirtual) {
        FlipToPhysical();
    }

    EfiBS->SetWatchdogTimer(Timeout, 0, 0, NULL);

    //
    // Flip back to Virtual mode if called that way
    //
    if (WasVirtual) {
        FlipToVirtual();
    }
}



BOOLEAN
BlDiskGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
/*++

Routine Description:

    This routine is a callback for reading data for a routine that
    validates the GPT partition table.

    NOTE: This routine changes the seek position on disk, and you must seek
          back to your original seek position if you plan on reading from the
          disk after making this call.

Arguments:

    StartingLBA - starting logical block address to read from.

    BytesToRead - Indicates how many bytes are to be read.

    pContext - context pointer for hte function (in this case, a pointer to the disk id.)

    OutputBuffer - a buffer that receives the data.  It's assumed that it is at least
                   BytesToRead big enough.

Return Value:

    TRUE - success, data has been read

    FALSE - failed, data has not been read.

--*/
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    PUSHORT DataPointer;
    ULONG DiskId;
    ULONG ReadCount = 0;


    DiskId = *((PULONG)pContext);
    //
    // read from the appropriate LBA on the disk
    //
    SeekPosition.QuadPart = StartingLBA * SECTOR_SIZE;

    Status = BlSeek(DiskId,
                      &SeekPosition,
                      SeekAbsolute );

    if (Status != ESUCCESS) {
        return FALSE;
    }

    DataPointer = OutputBuffer;

    Status = BlRead(
                DiskId,
                DataPointer,
                BytesToRead,
                &ReadCount);

    if ((Status == ESUCCESS) && (ReadCount == BytesToRead)) {
        return(TRUE);
    }

    return(FALSE);

}



ARC_STATUS
BlGetGPTDiskPartitionEntry(
    IN ULONG DiskNumber,
    IN UCHAR PartitionNumber,
    OUT EFI_PARTITION_ENTRY UNALIGNED **PartitionEntry
    )
{
    ARC_STATUS Status;
    ULONG DiskId;
    LARGE_INTEGER SeekPosition;
    UCHAR DataBuffer[SECTOR_SIZE * 2];
    ULONG ReadCount;
    UCHAR NullGuid[16] = {0};
    UNALIGNED EFI_PARTITION_TABLE  *EfiHdr;
    UNALIGNED EFI_PARTITION_ENTRY *PartEntry = NULL;

    if (PartitionNumber >= 128) {
        return EINVAL;
    }

    //
    // Open the disk for raw access.
    //

    Status = BiosDiskOpen( DiskNumber,
                           0,
                           &DiskId );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BiosDiskOpen (%x) fails, %x\r\n"), DiskNumber, Status));
        return EINVAL;
    }


    BlFileTable[DiskId].Flags.Read = 1;

    //
    // Read the second LBA on the disk.
    //

    SeekPosition.QuadPart = 1 * SECTOR_SIZE;

    Status = BlSeek( DiskId, &SeekPosition, SeekAbsolute );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BlSeek fails, %x\r\n"), Status));
        goto done;
    }

    Status = BlRead( DiskId, DataBuffer, SECTOR_SIZE, &ReadCount );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BlRead fails, %x\r\n"), Status));
        goto done;
    }

    if (ReadCount != SECTOR_SIZE) {
        Status = EIO;
        DBGOUT((TEXT("BlRead (wrong amt)\r\n")));
        goto done;
    }

    EfiHdr = (UNALIGNED EFI_PARTITION_TABLE *)DataBuffer;

    //
    // Verify EFI partition table.
    //
    if (!BlIsValidGUIDPartitionTable(
                            (UNALIGNED EFI_PARTITION_TABLE *)EfiHdr,
                            1,
                            &DiskId,
                            BlDiskGPTDiskReadCallback)) {
        DBGOUT((TEXT("BlIsValidGUIDPartitionTable fails, %x\r\n"), Status));
        Status = EBADF;
        goto done;
    }

    //
    // Locate and read the partition entry that was requested.
    //
    SeekPosition.QuadPart = EfiHdr->PartitionEntryLBA * SECTOR_SIZE;

    DBG_PRINT(STR_PREFIX"Seeking GPT Partition Entries\r\n");

    Status = BlSeek( DiskId, &SeekPosition, SeekAbsolute );

    if (Status != ESUCCESS) {
        goto done;
    }

    Status = BlRead( DiskId, EfiPartitionBuffer, sizeof(EfiPartitionBuffer), &ReadCount );

    if (Status != ESUCCESS) {
        goto done;
    }

    if (ReadCount != sizeof(EfiPartitionBuffer)) {
        Status = EIO;
        goto done;
    }

    PartEntry = BlLocateGPTPartition( PartitionNumber - 1, 128, NULL );

    if ( PartEntry != NULL ) {

        if ( (memcmp(PartEntry->Type, NullGuid, 16) != 0) &&
             (memcmp(PartEntry->Id, NullGuid, 16) != 0) &&
             (PartEntry->StartingLBA != 0) &&
             (PartEntry->EndingLBA != 0) ) {
            Status = ESUCCESS;
            goto done;
        }
    }

    Status = EBADF;

done:

    *PartitionEntry = PartEntry;

    BiosDiskClose(DiskId);

    if (Status != ESUCCESS) {
        Status = ENOENT;
    }

    return Status;
}

#define MBR_SIGNATURE_OFFSET        (SECTOR_SIZE - 2)
#define MBR_UNIQUE_SIGNATURE_OFFSET 0x1B8
#define MBR_REQUIRED_SIGNATURE      0xAA55

ARC_STATUS
BlGetMbrDiskSignature(
    IN  ULONG  DiskNumber,
    OUT PULONG DiskSignature
    )
/*++

Routine Description:

    Reads the MBR of a give disk (DiskNumber)
    in attempt to get the unique 32 bit signature
    located in the MBR.

    The unique signature is located at offset 0x1B8 (440 decimal)

Arguments:

    DiskNumber: the disk whose signature is to be retrieved

    DiskSignature: the location to copy the signature value to.

Return Value:

    ARC status code indicating outcome.  an error will be returned
    if the disk can not be opened, read or if the required mbr
    signature is incorrect.  otherwise ESUCCESS is returned.

--*/
{
    ARC_STATUS Status;
    UCHAR DataBuffer[SECTOR_SIZE];
    ULONG ReadCount;
    ULONG DiskId;
    LARGE_INTEGER SeekPosition;

    //
    // Open the disk for raw access.
    //

    Status = BiosDiskOpen( DiskNumber,
                           0,
                           &DiskId );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BiosDiskOpen (%x) fails, %x\r\n"), DiskNumber, Status));
        return EINVAL;
    }


    BlFileTable[DiskId].Flags.Read = 1;

    //
    // Read the MBR on the disk.
    //

    SeekPosition.QuadPart = 0;

    Status = BlSeek( DiskId, &SeekPosition, SeekAbsolute );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BlSeek fails, %x\r\n"), Status));
        goto done;
    }

    Status = BlRead( DiskId, DataBuffer, SECTOR_SIZE, &ReadCount );

    if (Status != ESUCCESS) {
        DBGOUT((TEXT("BlRead fails, %x\r\n"), Status));
        goto done;
    }

    if (ReadCount != SECTOR_SIZE) {
        Status = EIO;
        DBGOUT((TEXT("BlRead (wrong amt)\r\n")));
        goto done;
    }

    //
    // validate the MBR (last two bytes must be 0xaa55
    //
    if (((PUSHORT)DataBuffer)[MBR_SIGNATURE_OFFSET/sizeof(USHORT)] != MBR_REQUIRED_SIGNATURE) {
        Status = EBADF;
        goto done;
    }

    //
    // 32 bit unique signature is at offset 0x1b8
    //
    *DiskSignature = ((PULONG)DataBuffer)[MBR_UNIQUE_SIGNATURE_OFFSET/sizeof(ULONG)];

done:
    BiosDiskClose(DiskId);

    if (Status != ESUCCESS) {
        Status = ENOENT;
    }

    return Status;
}


ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  ULONGLONG DeviceHandle,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
        PUCHAR    Buffer,
    IN  BOOLEAN   Write
    )

/*++

Routine Description:

    Read or write disk sectors via extended int13.

    It is assumed that the caller has ensured that the transfer buffer is
    under the 1MB line, that the sector run does not cross a 64K boundary,
    etc.

    This routine does not check whether extended int13 is actually available
    for the drive.

Arguments:

    Int13UnitNumber - supplies the int13 drive number for the drive
        to be read from/written to.

    StartSector - supplies the absolute physical sector number. This is 0-based
        relative to all sectors on the drive.

    SectorCount - supplies the number of sectors to read/write.

    Buffer - receives data read from the disk or supplies data to be written.

    Write - supplies a flag indicating whether this is a write operation.
        If FALSE, then it's a read. Otherwise it's a write.

Return Value:

    ARC status code indicating outcome.

--*/

{
    ARC_STATUS s;
    ULONG l,h;
    UCHAR Operation;

    if(!SectorCount) {
        return(ESUCCESS);
    }

    l = (ULONG)StartSector;
    h = (ULONG)(StartSector >> 32);

    Operation = (UCHAR)(Write ? 0x43 : 0x42);

    //
    // We don't reset since this routine is only used on hard drives and
    // CD-ROMs, and we don't totally understand the effect of a disk reset
    // on ElTorito.
    //
    s = GET_EDDS_SECTOR((EFI_HANDLE)DeviceHandle,l,h,SectorCount,Buffer,Operation);

    return(s);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\efidisp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    efidisp.c

Author:

    Create It. 21-Nov-2000 (andrewr)

Abstract:

    This file contains utility routines for manipulating the EFI 
    SIMPLE_CONSOLE_OUTPUT interface

--*/

#include "bldr.h"
#include "bootefi.h"


#include "efi.h"
#include "efip.h"
#include "flop.h"

//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;


extern GoneVirtual;

//
// macro definition
//
#define EfiPrint(_X)                                          \
  {                                                           \
      if (IsPsrDtOn()) {                                      \
          FlipToPhysical();                                   \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
          FlipToVirtual();                                    \
      }                                                       \
      else {                                                  \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
      }                                                       \
  }

BOOLEAN gInverse = FALSE;


ULONG
BlEfiGetLinesPerRow(
    VOID
    )
/*++

Routine Description:

    Gets the number of lines per EFI console row.

Arguments:

    None.
    
Return Value:

    ULONG - number of lines.

--*/
{
    //
    // TODO: read the modes to determine lines/row.
    //
    // for now we just support 80x25
    //
    
    return 25;
}

ULONG
BlEfiGetColumnsPerLine(
    VOID
    )
/*++

Routine Description:

    Gets the number of columns per EFI console line.

Arguments:

    None.
    
Return Value:

    ULONG - number of columns.

--*/
{
    //
    // TODO: read the modes to determine columns/line.
    //
    // for now we just support 80x25
    //
    return 80;
}


BOOLEAN
BlEfiClearDisplay(
    VOID
    )
/*++

Routine Description:

    Clears the display.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    EFI_STATUS Status;

    //
    // you must be in physical mode to call EFI
    //
    FlipToPhysical();
    Status = EfiST->ConOut->ClearScreen(EfiST->ConOut);
    FlipToVirtual();

    return (BOOLEAN)(Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiClearToEndOfDisplay(
    VOID
    )
/*++

Routine Description:

    Clears from the current cursor position to the end of the display.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    ULONG i,j, LinesPerRow,ColumnsPerLine;
    BOOLEAN FirstTime = TRUE;

    //
    // you must be in physical mode to call EFI
    //
    FlipToPhysical();

    LinesPerRow = BlEfiGetLinesPerRow();
    ColumnsPerLine = BlEfiGetColumnsPerLine();


    for (i = EfiST->ConOut->Mode->CursorRow; i<= LinesPerRow; i++) {

        j = FirstTime 
             ? EfiST->ConOut->Mode->CursorColumn
             : 0 ;

        FirstTime = FALSE;
        
        for (; j <= ColumnsPerLine; j++) {

            EfiST->ConOut->SetCursorPosition(
                                EfiST->ConOut,
                                i,
                                j);
    
            //
            // outputting a space should clear the current character
            //
            
            EfiPrint(L" " );
        }

    }

    //
    // flip back into virtual mode and return
    //
    FlipToVirtual();

    return(TRUE);
}


BOOLEAN
BlEfiClearToEndOfLine(
    VOID
    )
/*++

Routine Description:

    Clears from the current cursor position to the end of the line.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    ULONG i, ColumnsPerLine;
    ULONG x, y;

    ColumnsPerLine = BlEfiGetColumnsPerLine();

    //
    // save current cursor position
    //
    BlEfiGetCursorPosition( &x, &y );
    
    FlipToPhysical();
    for (i = EfiST->ConOut->Mode->CursorColumn; i <= ColumnsPerLine; i++) {
        
        EfiST->ConOut->SetCursorPosition(
                            EfiST->ConOut,
                            i,
                            EfiST->ConOut->Mode->CursorRow);
        
        //
        // outputting a space should clear the current character
        //
        EfiPrint( L" " );
    }

    //
    // restore the current cursor position
    //
    EfiST->ConOut->SetCursorPosition(
                            EfiST->ConOut,
                            x,
                            y );

    FlipToVirtual();

    return(TRUE);
}


BOOLEAN
BlEfiGetCursorPosition(
    OUT PULONG x, OPTIONAL
    OUT PULONG y OPTIONAL
    )
/*++

Routine Description:

    retrieves the current cursor position

Arguments:

    x - if specified, receives the current cursor column.
    y - if specified, receives the current cursor row.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    FlipToPhysical();

    if (x) {
        *x = EfiST->ConOut->Mode->CursorColumn;
    }

    if (y) {
        *y = EfiST->ConOut->Mode->CursorRow;
    }
        
    FlipToVirtual();

    return(TRUE);

}


BOOLEAN
BlEfiPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )
/*++

Routine Description:

    Sets the current cursor position.

Arguments:

    Column - column to set (x coordinate)
    Row - row to set (y coordinate)
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;

    FlipToPhysical();
    Status = EfiST->ConOut->SetCursorPosition(EfiST->ConOut,Column,Row);
    FlipToVirtual();

    return (BOOLEAN)(Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiEnableCursor(
    BOOLEAN bVisible
    )
/*++

Routine Description:

    Turns on or off the input cursor.

Arguments:

    bVisible - TRUE indicates that the cursor should be made visible.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{
    EFI_STATUS Status;

    FlipToPhysical();
    Status = EfiST->ConOut->EnableCursor( EfiST->ConOut, bVisible );
    FlipToVirtual();

    return (BOOLEAN)(Status == EFI_SUCCESS);
}

BOOLEAN
BlEfiSetAttribute(
    ULONG Attribute
    )
/*++

Routine Description:

    Sets the current attribute for the console.
    
    This routines switches between the ATT_* constants into the EFI_* display
    constants.  Not all of the ATT_ flags can be supported under EFI, so we 
    make a best guess.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;
    UINTN foreground,background;
    UINTN EfiAttribute;

    switch (Attribute & 0xf) {
        case ATT_FG_BLACK:
            foreground = EFI_BLACK;
            break;
        case ATT_FG_RED:
            foreground = EFI_RED;
            break;
        case ATT_FG_GREEN:
            foreground = EFI_GREEN;
            break;
        case ATT_FG_YELLOW:
            foreground = EFI_YELLOW;
            break;
        case ATT_FG_BLUE:
            foreground = EFI_BLUE;
            break;
        case ATT_FG_MAGENTA:
            foreground = EFI_MAGENTA;
            break;
        case ATT_FG_CYAN:
            foreground = EFI_CYAN;
            break;
        case ATT_FG_WHITE:
            foreground = EFI_LIGHTGRAY; // this is a best guess
            break;
        case ATT_FG_INTENSE:
            foreground = EFI_WHITE; // this is a best guess
            break;
        default:
            // you may fall into this for blinking attribute, etc.
            foreground = EFI_WHITE;  
    }

    switch ( Attribute & ( 0xf << 4)) {
        case ATT_BG_BLACK:
            background = EFI_BACKGROUND_BLACK;
            break;
        case ATT_BG_RED:
            background = EFI_BACKGROUND_RED;
            break;
        case ATT_BG_GREEN:
            background = EFI_BACKGROUND_GREEN;
            break;
        case ATT_BG_YELLOW:
            // there is no yellow background in EFI
            background = EFI_BACKGROUND_CYAN;
            break;
        case ATT_BG_BLUE:
            background = EFI_BACKGROUND_BLUE;
            break;
        case ATT_BG_MAGENTA:
            background = EFI_BACKGROUND_MAGENTA;
            break;
        case ATT_BG_CYAN:
            background = EFI_BACKGROUND_CYAN;
            break;
        case ATT_BG_WHITE:
            // there is no white background in EFI
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
        case ATT_BG_INTENSE:
            // there is no intense (or white) background in EFI
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
        default:
            background = EFI_BACKGROUND_LIGHTGRAY;
            break;
    }
        
    EfiAttribute = foreground | background ;
    

    FlipToPhysical();
    Status = EfiST->ConOut->SetAttribute(EfiST->ConOut,EfiAttribute);
    FlipToVirtual();

    return (BOOLEAN)(Status == EFI_SUCCESS);
}


BOOLEAN
BlEfiSetInverseMode(
    BOOLEAN fInverseOn
    )
/*++

Routine Description:

    Sets the console text to an inverse attribute.
    
    Since EFI doesn't support the concept of inverse, we have
    to make a best guess at this.  Note that if you clear the
    display, etc., then the entire display will be set to this
    attribute.

Arguments:

    None.
    
Return Value:

    BOOLEAN - TRUE if the call succeeded.

--*/
{   
    EFI_STATUS Status;
    UINTN EfiAttribute,foreground,background;

    //
    // if it's already on, then just return.
    //
    if (fInverseOn && gInverse) {
        return(TRUE);
    }

    //
    // if it's already off, then just return.
    //
    if (!fInverseOn && !gInverse) {
        return(TRUE);
    }


    FlipToPhysical();

    //
    // get the current attribute and switch it.
    //
    EfiAttribute = EfiST->ConOut->Mode->Attribute;
    foreground = EfiAttribute & 0xf;
    background = (EfiAttribute & 0xf0) >> 4 ;

    EfiAttribute =  background | foreground;

    Status = EfiST->ConOut->SetAttribute(EfiST->ConOut,EfiAttribute);
    FlipToVirtual();

    gInverse = !gInverse;

    return (BOOLEAN)(Status == EFI_SUCCESS);
}




//
// Array of EFI drawing characters.
//
// This array MUST MATCH the GraphicsChar enumerated type in bldr.h.
//
USHORT EfiDrawingArray[GraphicsCharMax] = { 
    BOXDRAW_DOUBLE_DOWN_RIGHT,
    BOXDRAW_DOUBLE_DOWN_LEFT,
    BOXDRAW_DOUBLE_UP_RIGHT,
    BOXDRAW_DOUBLE_UP_LEFT,
    BOXDRAW_DOUBLE_VERTICAL,
    BOXDRAW_DOUBLE_HORIZONTAL,
    BLOCKELEMENT_FULL_BLOCK,
    BLOCKELEMENT_LIGHT_SHADE    
};



USHORT
BlEfiGetGraphicsChar(
    IN GraphicsChar WhichOne
    )
/*++

Routine Description:

    Gets the appropriate mapping character.
    
    
    
Arguments:

    GraphicsChar - enumerated type indicating character to be retrieved.
    
Return Value:

    USHORT - EFI drawing character.

--*/
{
    //
    // just return a space if the input it out of range
    //
    if (WhichOne >= GraphicsCharMax) {
        return(L' ');
    }
    
    return(EfiDrawingArray[WhichOne]);
}


#if DBG

VOID
DBG_EFI_PAUSE(
    VOID
    )
{
    EFI_EVENT EventArray[2];
    EFI_INPUT_KEY Key;
    UINTN num;

    if (GoneVirtual) {
        FlipToPhysical();
    }
    EventArray[0] = EfiST->ConIn->WaitForKey;
    EventArray[1] = NULL;
    EfiBS->WaitForEvent(1,EventArray,&num);
    //
    // reset the event
    //
    EfiST->ConIn->ReadKeyStroke( EfiST->ConIn, &Key );
    if (GoneVirtual) {
        FlipToVirtual();
    }
    
}

#else

VOID
DBG_EFI_PAUSE(
    VOID
    )
{
    NOTHING;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\envvar.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    envvar.c

Abstract:

    Provides routines to access EFI environment variables.

Author:

    Chuck Lenzmeier (chuckl) 10-Dec-2000

Revision History:

--*/

#include "arccodes.h"
#include "stdlib.h"
#include "stdio.h"
#include "string.h"
#if defined(_IA64_)
#include "bootia64.h"
#endif
#include "efi.h"
#include "efip.h"

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

GUID RamdiskVendorGuid = {0};

#include <efiboot.h>

ARC_STATUS
BlpGetPartitionFromDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevicePath,
    IN PUCHAR MaximumValidAddress,
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT HARDDRIVE_DEVICE_PATH UNALIGNED **HarddriveDevicePath,
    OUT FILEPATH_DEVICE_PATH UNALIGNED **FilepathDevicePath
    );

//
// Externals
//

extern VOID FlipToVirtual();
extern VOID FlipToPhysical();
extern ULONGLONG CompareGuid();

extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;

EFI_STATUS
EfiGetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    OUT UINT32 *Attributes OPTIONAL,
    IN OUT UINTN *DataSize,
    OUT VOID *Data
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->GetVariable(
                                        VariableName,
                                        VendorGuid,
                                        Attributes,
                                        DataSize,
                                        Data
                                        );

    FlipToVirtual();
    
    return status;

} // EfiGetVariable
    
EFI_STATUS
EfiSetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    IN UINT32 Attributes,
    IN UINTN DataSize,
    IN VOID *Data
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->SetVariable(
                                        VariableName,
                                        VendorGuid,
                                        Attributes,
                                        DataSize,
                                        Data
                                        );

    FlipToVirtual();
    
    return status;

} // EfiSetVariable
    
EFI_STATUS
EfiGetNextVariableName (
    IN OUT UINTN *VariableNameSize,
    IN OUT CHAR16 *VariableName,
    IN OUT EFI_GUID *VendorGuid
    )
{
    EFI_STATUS status;

    FlipToPhysical();

    status = EfiST->RuntimeServices->GetNextVariableName(
                                        VariableNameSize,
                                        VariableName,
                                        VendorGuid
                                        );

    FlipToVirtual();
    
    return status;

} // EfiGetNextVariableName
    
LONG
SafeStrlen (
    PUCHAR String,
    PUCHAR Max
    )
{
    PUCHAR p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return (LONG)(p - String);
    }

    return -1;

} // SafeStrlen

LONG
SafeWcslen (
    PWCHAR String,
    PWCHAR Max
    )
{
    PWCHAR p = String;
    while ( (p < Max) && (*p != 0) ) {
        p++;
    }

    if ( p < Max ) {
        return (LONG)(p - String);
    }

    return -1;

} // SafeWclen

ARC_STATUS
BlGetEfiBootOptions (
    OUT PUCHAR Argv0String OPTIONAL,
    OUT PUCHAR SystemPartition OPTIONAL,
    OUT PUCHAR OsLoaderFilename OPTIONAL,
    OUT PUCHAR OsLoadPartition OPTIONAL,
    OUT PUCHAR OsLoadFilename OPTIONAL,
    OUT PUCHAR FullKernelPath OPTIONAL,
    OUT PUCHAR OsLoadOptions OPTIONAL
    )
{
    EFI_STATUS status;
    ARC_STATUS arcStatus;
    EFI_GUID EfiGlobalVariable = EFI_GLOBAL_VARIABLE;
    UCHAR variable[512];
    CHAR syspart[100];
    UCHAR loader[100];
    CHAR loadpart[100];
    UCHAR loadname[100];
    PEFI_LOAD_OPTION efiLoadOption;
    EFI_DEVICE_PATH UNALIGNED *devicePath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp;
    WINDOWS_OS_OPTIONS UNALIGNED *osOptions;
    UINT16 bootCurrent;
    UINTN length;
    PUCHAR max;
    PUCHAR osloadoptions;
    LONG l;
    WCHAR UNALIGNED *fp;
    ULONG bootDisk;
    ULONG bootPartition;
    ULONG loadDisk;
    ULONG loadPartition;
    LONG i;
    FILE_PATH UNALIGNED *loadFilePath;
    PWCHAR wideosloadoptions;
    WCHAR currentBootEntryName[9];

    //
    // Get the ordinal of the entry that was used to boot the system.
    //
    length = sizeof(bootCurrent);
    status = EfiGetVariable( L"BootCurrent", &EfiGlobalVariable, NULL, &length, &bootCurrent );
    if ( status != EFI_SUCCESS ) {
        return ENOENT;
    }

    //
    // Read the boot entry.
    //

    swprintf( currentBootEntryName, L"Boot%04x", bootCurrent );
    length = 512;
    status = EfiGetVariable( currentBootEntryName, &EfiGlobalVariable, NULL, &length, variable );
    if ( status != EFI_SUCCESS ) {
        return ENOENT;
    }

    //
    // Verify the boot entry.
    //

    max = variable + length;

    //
    // Is it long enough even to contain the base part of the EFI load option?
    //

    if ( length < sizeof(EFI_LOAD_OPTION) ) {
        return ENOENT;
    }

    //
    // Is the description properly terminated?
    //

    efiLoadOption = (PEFI_LOAD_OPTION)variable;
    l = SafeWcslen( efiLoadOption->Description, (PWCHAR)max );
    if ( l < 0 ) {
        return ENOENT;
    }

    devicePath = (EFI_DEVICE_PATH *)((PUCHAR)efiLoadOption +
                    FIELD_OFFSET(EFI_LOAD_OPTION,Description) +
                    ((l + 1) * sizeof(CHAR16)));
    osOptions = (WINDOWS_OS_OPTIONS UNALIGNED *)((PUCHAR)devicePath + efiLoadOption->FilePathLength);

    length -= (UINTN)((PUCHAR)osOptions - variable);

    //
    // Does the OsOptions structure look like a WINDOWS_OS_OPTIONS structure?
    //

    if ( (length < FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) ||
         (length != osOptions->Length) ||
         (WINDOWS_OS_OPTIONS_VERSION != osOptions->Version) ||
         (strcmp((PCHAR)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) != 0) ) {
        return ENOENT;
    }

    //
    // Is the OsLoadOptions string properly terminated?
    //

    wideosloadoptions = (PWCHAR)osOptions->OsLoadOptions;
    l = SafeWcslen( wideosloadoptions, (PWCHAR)max );
    if ( l < 0 ) {
        return ENOENT;
    }

    //
    // Convert the OsLoadOptions string to ANSI.
    //

    osloadoptions = (PUCHAR)wideosloadoptions;
    for ( i = 1; i <= l; i++ ) {
        osloadoptions[i] = (UCHAR)wideosloadoptions[i];
    }
    
    //
    // Parse the device path to determine the OS load partition and directory.
    // Convert the directory name to ANSI.
    //

    loadFilePath = ADD_OFFSET( osOptions, OsLoadPathOffset );

    if ( loadFilePath->Type == FILE_PATH_TYPE_EFI ) {

        EFI_DEVICE_PATH UNALIGNED *loadDp = (EFI_DEVICE_PATH UNALIGNED *)loadFilePath->FilePath;
        VENDOR_DEVICE_PATH UNALIGNED *vendorDp = (VENDOR_DEVICE_PATH UNALIGNED *)loadDp;
        PCHAR ramdiskArcPath = (PCHAR)(vendorDp + 1);

#if 0
        //
        // turn this on to see the device path to the loader executable and device
        // path to the operating system
        //
        BlPrint(TEXT("Device Path = %s\r\n"), DevicePathToStr( devicePath ));
        BlPrint(TEXT("Embedded Device Path to OS = %s\r\n"), DevicePathToStr( loadDp ));
        DBG_EFI_PAUSE();
#endif

        if ( (DevicePathType(loadDp) != HARDWARE_DEVICE_PATH) ||
             (DevicePathSubType(loadDp) != HW_VENDOR_DP) ||
             (DevicePathNodeLength(loadDp) < sizeof(VENDOR_DEVICE_PATH)) ||
             (memcmp(&vendorDp->Guid, &RamdiskVendorGuid, 16) != 0) ) {
        
            arcStatus = BlpGetPartitionFromDevicePath(
                            loadDp,
                            max,
                            &loadDisk,
                            &loadPartition,
                            &harddriveDp,
                            &filepathDp
                            );
            if (arcStatus != ESUCCESS) {
                return arcStatus;
            }
            sprintf( loadpart,
                     "multi(0)disk(0)rdisk(%d)partition(%d)",
                     loadDisk,
                     loadPartition );
            fp = filepathDp->PathName;
            l = 0;
            while ( (l < (99 - 9 - strlen(loadpart))) &&
                    ((PUCHAR)fp < max) &&
                    (*fp != 0) ) {
                loadname[l++] = (UCHAR)*fp++;
            }
            loadname[l] = 0;

        } else {

            //
            // Looks like a RAM disk path. Verify.
            //

            if ( DevicePathNodeLength(loadDp) < (sizeof(VENDOR_DEVICE_PATH) + sizeof("ramdisk(0)\\x")) ) {
                return ENOENT;
            }

            if ( _strnicmp(ramdiskArcPath, "ramdisk(", 8) != 0 ) {
                return ENOENT;
            }

            l = 0;
            while ( (l <= 99) && (*ramdiskArcPath != 0) && (*ramdiskArcPath != '\\') ) {
                loadpart[l++] = *ramdiskArcPath++;
            }
            if ( (l == 100) || (*ramdiskArcPath == 0) ) {
                return ENOENT;
            }
            loadpart[l] = 0;
            l = 0;
            while ( (l <= 99) && (*ramdiskArcPath != 0) ) {
                loadname[l++] = *ramdiskArcPath++;
            }
            if ( (l == 100) || (l < 2) ) {
                return ENOENT;
            }
            loadname[l] = 0;
        }

    } else {

        return ENOENT;
    }

    //
    // Translate loader device path to partition/path.
    //

    arcStatus = BlpGetPartitionFromDevicePath(
                    devicePath,
                    max,
                    &bootDisk,
                    &bootPartition,
                    &harddriveDp,
                    &filepathDp
                    );
    if (arcStatus != ESUCCESS) {
        return arcStatus;
    }

    //
    // Form the ARC name for the partition.
    //

    sprintf( syspart,
             "multi(0)disk(0)rdisk(%d)partition(%d)",
             bootDisk,
             bootPartition );

    //
    // Extract the path to the loader.
    //

    fp = filepathDp->PathName;
    l = 0;

    while ( (l < (99 - 9 - strlen(syspart))) &&
            ((PUCHAR)fp < max) &&
            (*fp != 0) ) {
        loader[l++] = (UCHAR)*fp++;
    }
    loader[l] = 0;

    //
    // Create the strings that the loader needs.
    //

    if ( Argv0String != NULL ) {
        sprintf( (PCHAR)Argv0String, "%s%s", syspart, loader );
    }
    if ( OsLoaderFilename != NULL ) {
        sprintf( (PCHAR)OsLoaderFilename, "OSLOADER=%s%s", syspart, loader );
    }
    if ( SystemPartition != NULL ) {
        sprintf( (PCHAR)SystemPartition, "SYSTEMPARTITION=%s", syspart );
    }
    if ( OsLoadOptions != NULL ) {
        sprintf( (PCHAR)OsLoadOptions, "OSLOADOPTIONS=%s", osloadoptions );
    }
    if ( OsLoadFilename != NULL ) {
        sprintf( (PCHAR)OsLoadFilename, "OSLOADFILENAME=%s", loadname );
    }
    if ( FullKernelPath != NULL ) {
        sprintf( (PCHAR)FullKernelPath, "%s%s", loadpart, loadname );
    }
    if ( OsLoadPartition != NULL ) {
        sprintf( (PCHAR)OsLoadPartition, "OSLOADPARTITION=%s", loadpart );
    }

    return ESUCCESS;

} // BlGetEfiBootOptions

ARC_STATUS
BlpGetPartitionFromDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevicePath,
    IN PUCHAR MaximumValidAddress,
    OUT PULONG DiskNumber,
    OUT PULONG PartitionNumber,
    OUT HARDDRIVE_DEVICE_PATH UNALIGNED **HarddriveDevicePath,
    OUT FILEPATH_DEVICE_PATH UNALIGNED **FilepathDevicePath
    )
{
    ARC_STATUS status = ESUCCESS;
    EFI_DEVICE_PATH UNALIGNED *devicePath;
    HARDDRIVE_DEVICE_PATH UNALIGNED *harddriveDp;
    FILEPATH_DEVICE_PATH UNALIGNED *filepathDp;
    LOGICAL end;
    ULONG disk;
    ULONG partition;
    BOOLEAN DiskFound;

    //
    // Find the MEDIA/HARDDRIVE and MEDIA/FILEPATH elements in the device path.
    //

    devicePath = DevicePath;
    harddriveDp = NULL;
    filepathDp = NULL;
    end = FALSE;

    while ( ((PUCHAR)devicePath < MaximumValidAddress) &&
            !end &&
            ((harddriveDp == NULL) || (filepathDp == NULL)) ) {

        switch( devicePath->Type ) {
        
        case END_DEVICE_PATH_TYPE:
            end = TRUE;
            break;

        case MEDIA_DEVICE_PATH:
            switch ( devicePath->SubType ) {
            
            case MEDIA_HARDDRIVE_DP:
                harddriveDp = (HARDDRIVE_DEVICE_PATH UNALIGNED *)devicePath;
                break;

            case MEDIA_FILEPATH_DP:
                filepathDp = (FILEPATH_DEVICE_PATH UNALIGNED *)devicePath;
                break;

            default:
                break;
            }

        default:
            break;
        }

        devicePath = (EFI_DEVICE_PATH UNALIGNED *)NextDevicePathNode( devicePath );
    }

    //
    // If the two necessary elements weren't found, we can't continue.
    //

    if ( (harddriveDp == NULL) || (filepathDp == NULL) ) {
        return ENOENT;
    }

    //
    // Determine the disk number of the disk by opening the given partition
    // number on each disk and checking the partition signature.
    //

    partition = harddriveDp->PartitionNumber;

    //
    // find the disk this devicepath refers to
    //
    disk = 0;
    DiskFound = FALSE;
    while ( !DiskFound ) {

        switch (harddriveDp->SignatureType) {
            case SIGNATURE_TYPE_GUID: {
                EFI_PARTITION_ENTRY UNALIGNED *partEntry;
                status = BlGetGPTDiskPartitionEntry( disk, (UCHAR)partition, &partEntry );

                if ( status == ESUCCESS ) {
                    //
                    // we successfully got a GPT partition entry.
                    // check to see if the partitions signature matches
                    // the device path signature
                    //
                    if ( memcmp(partEntry->Id, harddriveDp->Signature, 16) == 0 ) {
                        DiskFound = TRUE;
                    }
                }
                break;
            }

            case SIGNATURE_TYPE_MBR: {
                ULONG MbrSignature;
                status = BlGetMbrDiskSignature(disk, &MbrSignature);

                if (status == ESUCCESS) {
                    //
                    // check to see if the MBR disk signature is 
                    // the signature we are looking for.
                    //
                    if ( MbrSignature == *(ULONG UNALIGNED *)&harddriveDp->Signature ) {
                        DiskFound = TRUE;
                    }
                }
                break;
            }

            default:
                // 
                // invalid type, just continue
                //
                break;
        }

        if ( status == EINVAL ) {
            //
            // we will receive EINVAL when there
            // are no more disks to cycle through.
            // if we get this before we have found 
            // our disk, we have a problem.  return 
            // the error.
            //
            return ENOENT;
        }
        
        disk++;
    }

    //
    // Return information about this disk, and about the device path.
    //

    *DiskNumber = disk - 1;
    *PartitionNumber = partition;
    *HarddriveDevicePath = harddriveDp;
    *FilepathDevicePath = filepathDp;

    return ESUCCESS;

} // BlpGetPartitionFromDevicePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\efiutil.c ===
#include "bldr.h"
#include "bootefi.h"
#include "efi.h"
#include "smbios.h"
#include "stdlib.h"

#if defined(_IA64_)
#include "bootia64.h"
#endif

extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;

//
// macro definition
//
#define EfiPrint(_X)                                          \
  {                                                           \
      if (IsPsrDtOn()) {                                      \
          FlipToPhysical();                                   \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
          FlipToVirtual();                                    \
      }                                                       \
      else {                                                  \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
      }                                                       \
  }


INTN
RUNTIMEFUNCTION
CompareGuid(
    IN EFI_GUID     *Guid1,
    IN EFI_GUID     *Guid2
    )
/*++

Routine Description:

    Compares two GUIDs

Arguments:

    Guid1       - guid to compare
    Guid2       - guid to compare

Returns:
    = 0     if Guid1 == Guid2

--*/
{
    INT32       *g1, *g2, r;

    //
    // Compare 32 bits at a time
    //

    g1 = (INT32 *) Guid1;
    g2 = (INT32 *) Guid2;

    r  = g1[0] - g2[0];
    r |= g1[1] - g2[1];
    r |= g1[2] - g2[2];
    r |= g1[3] - g2[3];

    return r;
}


EFI_STATUS
GetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    )

{
    UINTN Index;

    //
    // ST is system table
    //
    for(Index=0;Index<EfiST->NumberOfTableEntries;Index++) {
        if (CompareGuid(TableGuid,&(EfiST->ConfigurationTable[Index].VendorGuid))==0) {
            *Table = EfiST->ConfigurationTable[Index].VendorTable;
            return EFI_SUCCESS;
        }
    }
    return EFI_NOT_FOUND;
}


ARC_STATUS
BlGetEfiProtocolHandles(
    IN EFI_GUID *ProtocolType,
    OUT EFI_HANDLE **pHandleArray,
    OUT ULONG *NumberOfDevices
    )
/*++

Routine Description:

    Finds all of the handles that support a given protocol type.
    
    This routine requires that BlInitializeMemory() has already been
    called.

Arguments:

    ProtocolType - GUID that describes handle type to search for.
    pHandleArray - receives an array of handles that support the specified
                   protocol.
                   The page that these handles reside in can be freed via 
                   BlFreeDescriptor.
    NumberOfDevices - receives the number of device handles that support the
                   given protocol

Returns:
    ARC_STATUS indicating outcome.

--*/
{
    EFI_HANDLE *HandleArray = NULL;
    ULONGLONG HandleArraySize = 0;
    ULONG MemoryPage;
    ARC_STATUS ArcStatus;
    EFI_STATUS EfiStatus;
    
    *pHandleArray = NULL;
    *NumberOfDevices = 0;

    //
    // Change to physical mode so that we can make EFI calls
    //
    FlipToPhysical();

//    EfiPrint(L"In BlGetEfiProtocolHandles\r\n");

    //
    // Try to find out how much space we need.
    //
    EfiStatus = EfiBS->LocateHandle (
                ByProtocol,
                ProtocolType,
                0,
                (UINTN *) &HandleArraySize,
                HandleArray
                );

    FlipToVirtual();

    if (EfiStatus != EFI_BUFFER_TOO_SMALL) {
        //
        // yikes.  something is really messed up.  return failure.
        //        
//        EfiPrint(L"LocateHandle returned failure\r\n");
        return(EINVAL);
    }
    
//    EfiPrint(L"About to BlAllocateAlignedDescriptor\r\n");
    //
    // allocate space for the handles.
    //
    ArcStatus =  BlAllocateAlignedDescriptor( 
                            LoaderFirmwareTemporary,
                            0,
                            (ULONG) BYTES_TO_PAGES(HandleArraySize),
                            0,
                            &MemoryPage);

    if (ArcStatus != ESUCCESS) {
//        EfiPrint(L"BlAllocateAlignedDescriptor failed\r\n");
        return(ArcStatus);
    }

    

    HandleArray = (EFI_HANDLE *)(ULONGLONG)((ULONGLONG)MemoryPage << PAGE_SHIFT);
    
    FlipToPhysical();
    RtlZeroMemory(HandleArray, HandleArraySize);

//    EfiPrint(L"calling LocateHandle again\r\n");

    //
    // now get the handles now that we have enough space.
    //
    EfiStatus = EfiBS->LocateHandle (
                ByProtocol,
                ProtocolType,
                0,
                (UINTN *) &HandleArraySize,
                (EFI_HANDLE *)HandleArray
                );

//    EfiPrint(L"back from LocateHandle\r\n");
    FlipToVirtual();

    if (EFI_ERROR(EfiStatus)) {
        //
        // cleanup and return
        //        
//        EfiPrint(L"LocateHandle failed\r\n");
        BlFreeDescriptor( MemoryPage );
        return(EINVAL);
    }

//    EfiPrint(L"LocateHandle succeeded, return success\r\n");
    *NumberOfDevices = (ULONG)(HandleArraySize / sizeof (EFI_HANDLE));
    *pHandleArray = HandleArray;

//    BlPrint(TEXT("BlGetEfiProtocolHandles: found %x devices\r\n"), *NumberOfDevices );

    return(ESUCCESS);

}




CHAR16 *sprintf_buf;
UINT16 count;


VOID
__cdecl
putbuf(CHAR16 c)
{
    *sprintf_buf++ = c;
    count++;
}
VOID
bzero(CHAR16 *cp, int len)
{
    while (len--) {
        *(cp + len) = 0;
    }
}

VOID
__cdecl
doprnt(VOID (*func)(CHAR16 c), const CHAR16 *fmt, va_list args);


//
// BUGBUG this is a semi-sprintf hacked together just to get it to work
//
UINT16
__cdecl
wsprintf(CHAR16 *buf, const CHAR16 *fmt, ...)
{

    va_list args;

    sprintf_buf = buf;
    va_start(args, fmt);
    doprnt(putbuf, fmt, args);
    va_end(args);
    putbuf('\0');
    return count--;
}

void
__cdecl
printbase(VOID (*func)(CHAR16), ULONG x, int base, int width)
{
    static CHAR16 itoa[] = L"0123456789abcdef";
    ULONG j;
    LONG k;
    CHAR16 buf[32], *s = buf;

    bzero(buf, 16);
    if (x == 0 ) {
        *s++ = itoa[0];
    }
    while (x) {
        j = x % base;
        *s++ = itoa[j];
        x -= j;
        x /= base;
    }

    if( s-buf < width ) {
        for( k = 0; k < width - (s-buf); k++ ) {
            func('0');
        }
    }
    for (--s; s >= buf; --s) {
        func(*s);
    }
}

void
__cdecl
printguid(
    VOID (*func)( CHAR16), 
    GUID *pGuid
    )
{
    func(L'{');
    printbase(func, pGuid->Data1, 16, 8);
    func(L'-');
    printbase(func, pGuid->Data2, 16, 4);
    func(L'-');
    printbase(func, pGuid->Data3, 16, 4);
    func(L'-');
    printbase(func, pGuid->Data4[0], 16, 2);
    printbase(func, pGuid->Data4[1], 16, 2);
    func(L'-');
    printbase(func, pGuid->Data4[2], 16, 2);
    printbase(func, pGuid->Data4[3], 16, 2);
    printbase(func, pGuid->Data4[4], 16, 2);
    printbase(func, pGuid->Data4[5], 16, 2);
    printbase(func, pGuid->Data4[6], 16, 2);
    printbase(func, pGuid->Data4[7], 16, 2);
    func(L'}');    
}


void
__cdecl
doprnt(VOID (*func)( CHAR16 c), const CHAR16 *fmt, va_list args)
{
    ULONG x;
    LONG l;
    LONG width;
    CHAR16 c, *s;
    GUID * g;

    count = 0;

    while ((c = *fmt++) != 0) {
        if (c != '%') {
            func(c);
            continue;
        }

        width=0;
        c=*fmt++;

        if(c == '0') {
            while( (c = *fmt++) != 0) {

                if (!isdigit(c)) {
                    break;
                }

                width = width*10;
                width = width+(c-48);

            }
        }
        fmt--; // back it up one char

        switch (c = *fmt++) {
        case 'x':
            x = va_arg(args, ULONG);
            printbase(func, x, 16, width);
            break;
        case 'o':
            x = va_arg(args, ULONG);
            printbase(func, x, 8, width);
            break;
        case 'd':
            l = va_arg(args, LONG);
            if (l < 0) {
                func('-');
                l = -l;
            }
            printbase(func, (ULONG) l, 10, width);
            break;
        case 'u':
            l = va_arg(args, ULONG);
            printbase(func, (ULONG) l, 10, width);
            break;
        case 'g':
            g = va_arg(args, GUID *);
            printguid(func, g);
            break;
        case 'c':
            c = va_arg(args, CHAR16);
            func(c);
            break;
        case 's':
            s = va_arg(args, CHAR16 *);
            while (*s) {
                func(*s++);
            }
            break;
        default:
            func(c);
            break;
        }
    }
}

VOID
CatPrint(
    IN UNICODE_STRING *String,
    IN CHAR16* Format,
    ...
    )
{
    CHAR16* pString = String->Buffer;
    va_list args;

    if (*pString != '\0') {
        pString = String->Buffer + wcslen(String->Buffer);
    }

    sprintf_buf = pString;

    va_start(args, Format);
    doprnt(putbuf, Format, args);
    va_end(args);
    putbuf('\0');

}

VOID
_DevPathPci (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    PCI_DEVICE_PATH UNALIGNED         *Pci;

    Pci = DevPath;
    CatPrint(Str, L"Pci(%x|%x)", Pci->Device, Pci->Function);
}

VOID
_DevPathPccard (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    PCCARD_DEVICE_PATH UNALIGNED      *Pccard;

    Pccard = DevPath;   
    CatPrint(Str, L"Pccard(Socket%x)", Pccard->SocketNumber);
}

VOID
_DevPathMemMap (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    MEMMAP_DEVICE_PATH UNALIGNED      *MemMap;

    MemMap = DevPath;   
    CatPrint(Str, L"MemMap(%d:%x-%x)",
        MemMap->MemoryType,
        MemMap->StartingAddress,
        MemMap->EndingAddress
        );
}

VOID
_DevPathController (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    CONTROLLER_DEVICE_PATH UNALIGNED  *Controller;

    Controller = DevPath;
    CatPrint(Str, L"Ctrl(%d)",
        Controller->Controller
        );
}

VOID
_DevPathVendor (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    VENDOR_DEVICE_PATH UNALIGNED        *Vendor;
    CHAR16                              *Type;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH UNALIGNED   *UnknownDevPath;
    EFI_GUID UnknownDevice      = UNKNOWN_DEVICE_GUID;
    EFI_GUID VendorGuid;
    

    Vendor = DevPath;
    switch (DevicePathType(&Vendor->Header)) {
    case HARDWARE_DEVICE_PATH:  Type = L"Hw";        break;
    case MESSAGING_DEVICE_PATH: Type = L"Msg";       break;
    case MEDIA_DEVICE_PATH:     Type = L"Media";     break;
    default:                    Type = L"?";         break;
    }                            

    RtlCopyMemory( &VendorGuid, &Vendor->Guid, sizeof(EFI_GUID));

    CatPrint(Str, L"Ven%s(%g", Type, &VendorGuid);
    if (CompareGuid (&VendorGuid, &UnknownDevice) == 0) {
        /* 
         *  GUID used by EFI to enumerate an EDD 1.1 device
         */
        UnknownDevPath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH UNALIGNED *)Vendor;
        CatPrint(Str, L":%02x)", UnknownDevPath->LegacyDriveLetter);
    } else {
        CatPrint(Str, L")");
    }
}


VOID
_DevPathAcpi (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    ACPI_HID_DEVICE_PATH UNALIGNED        *Acpi;

    Acpi = DevPath;
    if ((Acpi->HID & PNP_EISA_ID_MASK) == PNP_EISA_ID_CONST) {
        CatPrint(Str, L"Acpi(PNP%04x,%x)", EISA_ID_TO_NUM (Acpi->HID), Acpi->UID);
    } else {
        CatPrint(Str, L"Acpi(%08x,%x)", Acpi->HID, Acpi->UID);
    }
}


VOID
_DevPathAtapi (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    ATAPI_DEVICE_PATH UNALIGNED       *Atapi;

    Atapi = DevPath;
    CatPrint(Str, L"Ata(%s,%s)", 
        Atapi->PrimarySecondary ? L"Secondary" : L"Primary",
        Atapi->SlaveMaster ? L"Slave" : L"Master"
        );
}

VOID
_DevPathScsi (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    SCSI_DEVICE_PATH UNALIGNED        *Scsi;

    Scsi = DevPath;
    CatPrint(Str, L"Scsi(Pun%x,Lun%x)", Scsi->Pun, Scsi->Lun);
}


VOID
_DevPathFibre (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    FIBRECHANNEL_DEVICE_PATH UNALIGNED    *Fibre;

    Fibre = DevPath;
    CatPrint(Str, L"Fibre(%lx)", Fibre->WWN);
}

VOID
_DevPath1394 (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    F1394_DEVICE_PATH UNALIGNED       *F1394;

    F1394 = DevPath;
    CatPrint(Str, L"1394(%g)", &F1394->Guid);
}



VOID
_DevPathUsb (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    USB_DEVICE_PATH UNALIGNED         *Usb;

    Usb = DevPath;
    CatPrint(Str, L"Usb(%x)", Usb->Port);
}


VOID
_DevPathI2O (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    I2O_DEVICE_PATH UNALIGNED         *I2O;

    I2O = DevPath;
    CatPrint(Str, L"I2O(%x)", I2O->Tid);
}

VOID
_DevPathMacAddr (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    MAC_ADDR_DEVICE_PATH UNALIGNED    *MAC;
    UINTN                   HwAddressSize;
    UINTN                   Index;

    MAC = DevPath;

    HwAddressSize = sizeof(EFI_MAC_ADDRESS);
    if (MAC->IfType == 0x01 || MAC->IfType == 0x00) {
        HwAddressSize = 6;
    }
    
    CatPrint(Str, L"Mac(");

    for(Index = 0; Index < HwAddressSize; Index++) {
        CatPrint(Str, L"%02x",MAC->MacAddress.Addr[Index]);
    }
    CatPrint(Str, L")");
}

VOID
_DevPathIPv4 (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    IPv4_DEVICE_PATH UNALIGNED     *IP;

    IP = DevPath;
    CatPrint(Str, L"IPv4(not-done)");
}

VOID
_DevPathIPv6 (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    IPv6_DEVICE_PATH UNALIGNED     *IP;

    IP = DevPath;
    CatPrint(Str, L"IP-v6(not-done)");
}

VOID
_DevPathInfiniBand (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    INFINIBAND_DEVICE_PATH UNALIGNED  *InfiniBand;

    InfiniBand = DevPath;
    CatPrint(Str, L"InfiniBand(not-done)");
}

VOID
_DevPathUart (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    UART_DEVICE_PATH UNALIGNED  *Uart;
    CHAR8             Parity;

    Uart = DevPath;
    switch (Uart->Parity) {
        case 0  : Parity = 'D'; break;
        case 1  : Parity = 'N'; break;
        case 2  : Parity = 'E'; break;
        case 3  : Parity = 'O'; break;
        case 4  : Parity = 'M'; break;
        case 5  : Parity = 'S'; break;
        default : Parity = 'x'; break;
    }

    if (Uart->BaudRate == 0) {
        CatPrint(Str, L"Uart(DEFAULT %c",Uart->BaudRate,Parity);
    } else {
        CatPrint(Str, L"Uart(%d %c",Uart->BaudRate,Parity);
    }

    if (Uart->DataBits == 0) {
        CatPrint(Str, L"D");
    } else {
        CatPrint(Str, L"%d",Uart->DataBits);
    }

    switch (Uart->StopBits) {
        case 0  : CatPrint(Str, L"D)");   break;
        case 1  : CatPrint(Str, L"1)");   break;
        case 2  : CatPrint(Str, L"1.5)"); break;
        case 3  : CatPrint(Str, L"2)");   break;
        default : CatPrint(Str, L"x)");   break;
    }
}


VOID
_DevPathHardDrive (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    HARDDRIVE_DEVICE_PATH UNALIGNED   *Hd;

    Hd = DevPath;
    switch (Hd->SignatureType) {
        case SIGNATURE_TYPE_MBR:
            CatPrint(Str, L"HD(Part%d,Sig%08X)", 
                Hd->PartitionNumber,
                *((UINT32 *)(&(Hd->Signature[0])))
                );
            break;
        case SIGNATURE_TYPE_GUID:
            CatPrint(Str, L"HD(Part%d,Sig%g)", 
                Hd->PartitionNumber,
                (EFI_GUID *) &(Hd->Signature[0])     
                );
            break;
        default:
            CatPrint(Str, L"HD(Part%d,MBRType=%02x,SigType=%02x)", 
                Hd->PartitionNumber,
                Hd->MBRType,
                Hd->SignatureType
                );
            break;
    }
}

VOID
_DevPathCDROM (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    CDROM_DEVICE_PATH UNALIGNED       *Cd;

    Cd = DevPath;
    CatPrint(Str, L"CDROM(Entry%x)", Cd->BootEntry);
}

VOID
_DevPathFilePath (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    FILEPATH_DEVICE_PATH UNALIGNED    *Fp;   

    Fp = DevPath;
    CatPrint(Str, L"%s", Fp->PathName);
}

VOID
_DevPathMediaProtocol (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    MEDIA_PROTOCOL_DEVICE_PATH UNALIGNED  *MediaProt;

    MediaProt = DevPath;
    CatPrint(Str, L"%g", &MediaProt->Protocol);
}

VOID
_DevPathBssBss (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    BBS_BBS_DEVICE_PATH UNALIGNED     *Bss;
    CHAR16                  *Type;

    Bss = DevPath;
    switch (Bss->DeviceType) {
    case BBS_TYPE_FLOPPY:               Type = L"Floppy";       break;
    case BBS_TYPE_HARDDRIVE:            Type = L"Harddrive";    break;
    case BBS_TYPE_CDROM:                Type = L"CDROM";        break;
    case BBS_TYPE_PCMCIA:               Type = L"PCMCIA";       break;
    case BBS_TYPE_USB:                  Type = L"Usb";          break;
    case BBS_TYPE_EMBEDDED_NETWORK:     Type = L"Net";          break;
    default:                            Type = L"?";            break;
    }

    CatPrint(Str, L"Bss-%s(%a)", Type, Bss->String);
}


VOID
_DevPathEndInstance (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    UNREFERENCED_PARAMETER( DevPath );
    CatPrint(Str, L",");
}

VOID
_DevPathNodeUnknown (
    IN OUT UNICODE_STRING       *Str,
    IN VOID                 *DevPath
    )
{
    UNREFERENCED_PARAMETER( DevPath );

    CatPrint(Str, L"?");
}


struct {
    UINT8   Type;
    UINT8   SubType;
    VOID    (*Function)(UNICODE_STRING *, VOID *);    
} DevPathTable[] = {
    HARDWARE_DEVICE_PATH,   HW_PCI_DP,                        _DevPathPci,
    HARDWARE_DEVICE_PATH,   HW_PCCARD_DP,                     _DevPathPccard,
    HARDWARE_DEVICE_PATH,   HW_MEMMAP_DP,                     _DevPathMemMap,
    HARDWARE_DEVICE_PATH,   HW_VENDOR_DP,                     _DevPathVendor,
    HARDWARE_DEVICE_PATH,   HW_CONTROLLER_DP,                 _DevPathController,
    ACPI_DEVICE_PATH,       ACPI_DP,                          _DevPathAcpi,
    MESSAGING_DEVICE_PATH,  MSG_ATAPI_DP,                     _DevPathAtapi,
    MESSAGING_DEVICE_PATH,  MSG_SCSI_DP,                      _DevPathScsi,
    MESSAGING_DEVICE_PATH,  MSG_FIBRECHANNEL_DP,              _DevPathFibre,
    MESSAGING_DEVICE_PATH,  MSG_1394_DP,                      _DevPath1394,
    MESSAGING_DEVICE_PATH,  MSG_USB_DP,                       _DevPathUsb,
    MESSAGING_DEVICE_PATH,  MSG_I2O_DP,                       _DevPathI2O,
    MESSAGING_DEVICE_PATH,  MSG_MAC_ADDR_DP,                  _DevPathMacAddr,
    MESSAGING_DEVICE_PATH,  MSG_IPv4_DP,                      _DevPathIPv4,
    MESSAGING_DEVICE_PATH,  MSG_IPv6_DP,                      _DevPathIPv6,
    MESSAGING_DEVICE_PATH,  MSG_INFINIBAND_DP,                _DevPathInfiniBand,
    MESSAGING_DEVICE_PATH,  MSG_UART_DP,                      _DevPathUart,
    MESSAGING_DEVICE_PATH,  MSG_VENDOR_DP,                    _DevPathVendor,
    MEDIA_DEVICE_PATH,      MEDIA_HARDDRIVE_DP,               _DevPathHardDrive,
    MEDIA_DEVICE_PATH,      MEDIA_CDROM_DP,                   _DevPathCDROM,
    MEDIA_DEVICE_PATH,      MEDIA_VENDOR_DP,                  _DevPathVendor,
    MEDIA_DEVICE_PATH,      MEDIA_FILEPATH_DP,                _DevPathFilePath,
    MEDIA_DEVICE_PATH,      MEDIA_PROTOCOL_DP,                _DevPathMediaProtocol,
    BBS_DEVICE_PATH,        BBS_BBS_DP,                       _DevPathBssBss,
    END_DEVICE_PATH_TYPE,   END_INSTANCE_DEVICE_PATH_SUBTYPE, _DevPathEndInstance,
    0,                      0,                          NULL
};


#define ALIGN_SIZE(a)   ((a % MIN_ALIGNMENT_SIZE) ? MIN_ALIGNMENT_SIZE - (a % MIN_ALIGNMENT_SIZE) : 0)

EFI_DEVICE_PATH UNALIGNED *
UnpackDevicePath (
    IN EFI_DEVICE_PATH UNALIGNED *DevPath
    )
{
    EFI_DEVICE_PATH UNALIGNED     *Src, *Dest, *NewPath;
    UINTN               Size;
    
    /* 
     *  Walk device path and round sizes to valid boundries
     *      */

    Src = DevPath;
    Size = 0;
    for (; ;) {
        Size += DevicePathNodeLength(Src);
        Size += ALIGN_SIZE(Size);

        if (IsDevicePathEnd(Src)) {
            break;
        }

        Src = NextDevicePathNode(Src);
    }


    /* 
     *  Allocate space for the unpacked path
     */
    EfiAllocateAndZeroMemory( EfiLoaderData,
                              Size,
                              (VOID **) &NewPath );
    
    if (NewPath) {
        /* 
         *  Copy each node
         */

        Src = DevPath;
        Dest = NewPath;
        for (; ;) {
            Size = DevicePathNodeLength(Src);
            RtlCopyMemory (Dest, Src, Size);
            Size += ALIGN_SIZE(Size);
            SetDevicePathNodeLength (Dest, Size);
            Dest->Type |= EFI_DP_TYPE_UNPACKED;
            Dest = (EFI_DEVICE_PATH UNALIGNED *) (((UINT8 *) Dest) + Size);

            if (IsDevicePathEnd(Src)) {
                break;
            }

            Src = NextDevicePathNode(Src);
        }
    }

    return NewPath;
}



WCHAR DbgDevicePathStringBuffer[1000];

CHAR16 *
DevicePathToStr (
    EFI_DEVICE_PATH UNALIGNED *DevPath
    )
/*++

    Turns the Device Path into a printable string.  Allcoates
    the string from pool.  The caller must FreePool the returned
    string.

--*/
{
    UNICODE_STRING      Str;
    EFI_DEVICE_PATH UNALIGNED  *DevPathNode;
    VOID                (*DumpNode)(UNICODE_STRING *, VOID *);    
    UINTN               Index;

    RtlZeroMemory(DbgDevicePathStringBuffer, sizeof(DbgDevicePathStringBuffer));
    Str.Buffer= DbgDevicePathStringBuffer;
    Str.Length = sizeof(DbgDevicePathStringBuffer);
    Str.MaximumLength = sizeof(DbgDevicePathStringBuffer);

    /* 
     *  Unpacked the device path
     */

    DevPath = UnpackDevicePath(DevPath);
    ASSERT (DevPath);


    /* 
     *  Process each device path node
     *      */

    DevPathNode = DevPath;
    while (!IsDevicePathEnd(DevPathNode)) {

        /* 
         *  Find the handler to dump this device path node
         */

        DumpNode = NULL;
        for (Index = 0; DevPathTable[Index].Function; Index += 1) {

            if (DevicePathType(DevPathNode) == DevPathTable[Index].Type &&
                DevicePathSubType(DevPathNode) == DevPathTable[Index].SubType) {
                DumpNode = DevPathTable[Index].Function;
                break;
            }
        }

        /* 
         *  If not found, use a generic function
         */

        if (!DumpNode) {
            DumpNode = _DevPathNodeUnknown;
        }

        /* 
         *   Put a path seperator in if needed
         */

        if (Str.Length  &&  DumpNode != _DevPathEndInstance) {
            CatPrint (&Str, L"/");
        }

        /* 
         *  Print this node of the device path
         */

        DumpNode (&Str, DevPathNode);

        /* 
         *  Next device path node
         */

        DevPathNode = NextDevicePathNode(DevPathNode);
    }

    /* 
     *  Shrink pool used for string allocation
     */

    EfiBS->FreePool (DevPath);

    return Str.Buffer;
}






PVOID
FindSMBIOSTable(
    UCHAR   RequestedTableType
    )
/*++

Routine Description:

    This routine searches through the SMBIOS tables for the specified table
    type.

Arguments:

    RequestedTableType - Which SMBIOS table are we looking for?

Return Value:

    NULL - THe specified table was not found.
    
    PVOID - A pointer to the specified table.

--*/
{
extern PVOID SMBiosTable;

    PUCHAR                          StartPtr = NULL;
    PUCHAR                          EndPtr = NULL;
    PSMBIOS_EPS_HEADER              SMBiosEPSHeader = NULL;
    PDMIBIOS_EPS_HEADER             DMIBiosEPSHeader = NULL;
    PSMBIOS_STRUCT_HEADER           SMBiosHeader = NULL;



    if( SMBiosTable == NULL ) {
        return NULL;
    }


    //
    // Set up our search pointers.
    //    
    SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosTable;
    DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

    StartPtr = (PUCHAR)ULongToPtr(DMIBiosEPSHeader->StructureTableAddress);
    EndPtr = StartPtr + DMIBiosEPSHeader->StructureTableLength;

    if( BdDebuggerEnabled ) { 
        DbgPrint( "FindSMBIOSTable: About to start searching for table type %d at address (%x)...\r\n",
              RequestedTableType,
              PtrToUlong(StartPtr) );
    }


    while( StartPtr < EndPtr ) {

        SMBiosHeader = (PSMBIOS_STRUCT_HEADER)StartPtr;

        if( SMBiosHeader->Type == RequestedTableType ) {

            // This is the table we're looking for.
            if( BdDebuggerEnabled ) {
                DbgPrint( "FindSMBIOSTable: Found requested table type %d at address %x\r\n",
                      RequestedTableType,
                      PtrToUlong(StartPtr) );
            }
            return (PVOID)StartPtr;
        } else {

            //
            // It's not him.  Go to the next table.
            //
            if( BdDebuggerEnabled ) {
                DbgPrint( "FindSMBIOSTable: Inspected table type %d at address %x\r\n",
                      SMBiosHeader->Type,
                      PtrToUlong(StartPtr) );
            }
        
            StartPtr += SMBiosHeader->Length;

            //
            // jump over any trailing string-list that may be appeneded onto the
            // end of this table.
            //
            while ( (*((USHORT UNALIGNED *)StartPtr) != 0)  &&
                    (StartPtr < EndPtr) ) {
                
                StartPtr++;
            }
            StartPtr += 2;

        }

    }

    return NULL;

}


VOID
EfiCheckFirmwareRevision(
    VOID
    )
/*++

Routine Description:

    This routine will retrieve the BIOS revision value then parse it to determine
    if the revision is new enough.
    
    If the revision is not new enough, we won't be returning from this function.

Arguments:

    None.

Return Value:

    None.

--*/
{
#define         FIRMWARE_MINIMUM_SOFTSUR (103)
#define         FIRMWARE_MINIMUM_LION (71)
    PUCHAR      FirmwareString = NULL;
    PUCHAR      VendorString = NULL;
    PUCHAR      TmpPtr = NULL;
    ULONG       FirmwareVersion = 0;
    ULONG       FirmwareMinimum = 0;
    BOOLEAN     IsSoftSur = FALSE;
    BOOLEAN     IsVendorIntel = FALSE;
    WCHAR       OutputBuffer[256];
    PSMBIOS_BIOS_INFORMATION_STRUCT BiosInfoHeader = NULL;
    ULONG       i = 0;
    


    BiosInfoHeader = (PSMBIOS_BIOS_INFORMATION_STRUCT)FindSMBIOSTable( SMBIOS_BIOS_INFORMATION_TYPE );

    if( BiosInfoHeader ) {
         
        
        //
        // Get the firmware version string.
        //
        if( (ULONG)BiosInfoHeader->Version > 0 ) {
 
         
            // Jump to the end of the formatted portion of the SMBIOS table.
            FirmwareString = (PUCHAR)BiosInfoHeader + BiosInfoHeader->Length;
                            
            
            //
            // Now jump over some number of strings to get to our string.
            //
            // This is a bit scary because we're trusting what SMBIOS
            // has handed us.  If he gave us something bogus, then
            // we're about run off the end of the world looking for NULL
            // string terminators.
            //
            for( i = 0; i < ((ULONG)BiosInfoHeader->Version-1); i++ ) {
                while( *FirmwareString != 0 ) {
                    FirmwareString++;
                }
                FirmwareString++;
            }


            //
            // Determine platform and firmware version.
            //
            // FirmwareString should look something like:
            // W460GXBS2.86E.0103B.P05.200103281759
            // --------      ----
            //    |            |
            //    |             ------- Firmware version
            //    |
            //     -------------------- Platform identifier.  "W460GXBS" means softsur.
            //                          Anything else means Lion.
            //
        
        

            //
            if( FirmwareString ) {

                IsSoftSur = (BOOLEAN)(!strncmp( (PCHAR)FirmwareString, "W460GXBS", 8 ));

                // Get the minimum firmware that's okay, based on the platform.
                FirmwareMinimum = (IsSoftSur) ? FIRMWARE_MINIMUM_SOFTSUR : FIRMWARE_MINIMUM_LION;

                
                // Get the version.
                TmpPtr = (PUCHAR)strchr( (PCHAR)FirmwareString, '.' );
                if( TmpPtr ) {
                    TmpPtr++;
                    TmpPtr = (PUCHAR)strchr( (PCHAR)TmpPtr, '.' );
                    if( TmpPtr ) {
                        TmpPtr++;
                        FirmwareVersion = strtoul( (PCHAR)TmpPtr, NULL, 10 );

#if DBG


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: Successfully retrieved the Firmware String: %S\r\n",
                                  FirmwareString );
                        EfiPrint(OutputBuffer );


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: Detected platform: %S\r\n",
                                  IsSoftSur ? "Softsur" : "Lion" );
                        EfiPrint(OutputBuffer );


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: FirmwareVersion: %d\r\n",
                                  FirmwareVersion );
                        EfiPrint(OutputBuffer );


                        swprintf( OutputBuffer,
                                  L"EfiCheckFirmwareRevision: Minimum FirmwareVersion requirement: %d\r\n",
                                  FirmwareMinimum );
                        EfiPrint(OutputBuffer );


#endif

                    }
                }

            }
        }



        //
        // Get the BIOS vendor and see if it's Intel.
        //
        if( (ULONG)BiosInfoHeader->Vendor > 0 ) {
 
         
            // Jump to the end of the formatted portion of the SMBIOS table.
            VendorString = (PUCHAR)BiosInfoHeader + BiosInfoHeader->Length;
                            
            
            //
            // Now jump over some number of strings to get to our string.
            //
            for( i = 0; i < ((ULONG)BiosInfoHeader->Vendor-1); i++ ) {
                while( *VendorString != 0 ) {
                    VendorString++;
                }
                VendorString++;
            }


            //
            // Remember firmware vendor.
            //
            if( VendorString ) {
                IsVendorIntel = (BOOLEAN)(!_strnicmp( (PCHAR)VendorString, "INTEL", 5 ));
#if DBG
                swprintf( OutputBuffer,
                          L"EfiCheckFirmwareRevision: Firmware Vendor String: %S\r\n",
                          VendorString );
                EfiPrint(OutputBuffer );
#endif

            }
        }

    }




    if( (FirmwareVersion) &&
        (IsVendorIntel) ) {

        if( FirmwareVersion < FirmwareMinimum ) {

            swprintf(OutputBuffer, L"Your system's firmware version is less than %d.\n\r", FirmwareMinimum);
            EfiPrint(OutputBuffer);
            swprintf(OutputBuffer, L"You must upgrade your system firmware in order to proceed.\n\r" );
            EfiPrint(OutputBuffer);

            while( 1 );
        }
    }

}

ARC_STATUS
BlLoadEFIImage(
    IN PCCHAR PartitionArcName,
    IN PCCHAR ImagePath,
    IN PCCHAR ImageName OPTIONAL,
    IN BOOLEAN StartImage,
    OUT EFI_HANDLE* EfiHandle OPTIONAL
    )
/*++

Routine Description:

    Loads an EFI image by calling LoadImage boot service and optionally starts the image.

Arguments:

    PartitionArcName - The arc name of the partition the files is located on
    ImagePath - The path to the file to load (from the root directory) on the partition specified by PartitionArcName.
                This can be the full file path or a partial path (e.g. only the directory).
    ImageName - Optional. The file name of the image to load. If not NULL, it is simply appended to ImagePath to form the complete
                path to the file. If NULL or empty string, ImagePath must contain the complete path.
                Note that the complete path must not exceed 128 characters, including the zero terminator.
    StartImage - If TRUE, the image is also started by calling StartImage boot service.
    EfiHandle - Optional. Pointer to a location to receive the loaded image EFI handle.

Return value:

    ESUCCESS on success or the error code on failure.

--*/
{
    ARC_STATUS Status = ESUCCESS;
    CHAR Buffer[128];
    ULONG PartitionId = BL_INVALID_FILE_ID;
    ULONG FileId = BL_INVALID_FILE_ID;
    ULONG PageBase = 0;
    EFI_HANDLE _EfiHandle = 0;
    EFI_STATUS EfiStatus;
    PVOID ImageBase;
    ULONG PathSize;
    ULONG NameSize;
    ULONG PageCount;
    ULONG BytesRead;
    PCHAR CompletePath;
    FILE_INFORMATION FileInfo;
    EFI_DEVICE_PATH DevPath;
    EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
    EFI_LOADED_IMAGE *LoadedEfiImageInfo = NULL;

    if(NULL == PartitionArcName || NULL == ImagePath) {
        Status = EINVAL;
        goto exit;
    }

    if(NULL == ImageName || 0 == ImageName[0]) {
        CompletePath = ImagePath;
    } else {
        PathSize = (ULONG)strlen(ImagePath);
        NameSize = (ULONG)strlen(ImageName);

        if(PathSize + NameSize >= sizeof(Buffer) / sizeof(Buffer[0])) {
            Status = ENAMETOOLONG;
            goto exit;
        }

        RtlCopyMemory(Buffer, ImagePath, PathSize * sizeof(ImagePath[0]));
        RtlCopyMemory(Buffer + PathSize, ImageName, (NameSize + 1) * sizeof(ImagePath[0]));
        CompletePath = Buffer;
    }

    Status = ArcOpen(PartitionArcName, ArcOpenReadOnly, &PartitionId);

    if(Status != ESUCCESS) {
        goto exit;
    }

    Status = BlOpen(PartitionId, CompletePath, ArcOpenReadOnly, &FileId);

    if(Status != ESUCCESS) {
        goto exit;
    }

    Status = BlGetFileInformation(FileId, &FileInfo);

    if(Status != ESUCCESS) {
        goto exit;
    }

    if(FileInfo.EndingAddress.HighPart != 0 || 0 == FileInfo.EndingAddress.LowPart) {
        Status = EINVAL;
        goto exit;
    }

    PageCount = (FileInfo.EndingAddress.LowPart + PAGE_SIZE - 1) / PAGE_SIZE;
    Status = BlAllocateDescriptor(LoaderFirmwareTemporary, 0, PageCount, &PageBase);

    if(Status != ESUCCESS) {
        goto exit;
    }

    ImageBase = (PVOID) ((ULONG_PTR) PageBase * PAGE_SIZE);
    Status = BlRead(FileId, ImageBase, FileInfo.EndingAddress.LowPart, &BytesRead);

    if(Status != ESUCCESS) {
        goto exit;
    }

    if(BytesRead != FileInfo.EndingAddress.LowPart) {
        Status = EIO;
        goto exit;
    }
    //
    // LoadImage does not like a NULL device path so create an empty one
    //
    DevPath.Type = END_DEVICE_PATH_TYPE;
    DevPath.SubType = END_ENTIRE_DEVICE_PATH_SUBTYPE;
    DevPath.Length[0] = sizeof(DevPath);
    DevPath.Length[1] = 0;

    FlipToPhysical();
    EfiStatus = EfiST->BootServices->LoadImage(FALSE, EfiImageHandle, &DevPath, ImageBase, FileInfo.EndingAddress.LowPart, &_EfiHandle);

    if(!EFI_ERROR(EfiStatus)) {
        if(StartImage) {
            EfiStatus = EfiST->BootServices->StartImage(_EfiHandle, NULL, NULL);

            if(EFI_ALREADY_STARTED == EfiStatus) {
                //
                // The image is already started so don't unload
                //
                EfiStatus = EFI_SUCCESS;
            }

            if(EFI_ERROR(EfiStatus)) {
                EfiST->BootServices->UnloadImage(_EfiHandle);
            }
        }
    }

//    EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, image is loaded.\r\n");

    //
    // if the image is loaded then we need to make sure the OS knows about it.
    //
    if (!EFI_ERROR(EfiStatus)) {
        //EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, Getting Loaded image protocol.\r\n");
        EfiStatus = EfiST->BootServices->HandleProtocol( 
                                                _EfiHandle,
                                                &EfiLoadedImageProtocol,
                                                &LoadedEfiImageInfo );
        //EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, got Loaded image protocol.\r\n");
    }

    FlipToVirtual();

#if 0
    if (LoadedEfiImageInfo) {
        
        MEMORY_ALLOCATION_DESCRIPTOR *Descriptor;
        ULONG NewBasePage, NewPageCount;

        NewBasePage = (ULONG)((ULONG_PTR)LoadedEfiImageInfo->ImageBase) >> PAGE_SHIFT;
        NewPageCount = (ULONG) BYTES_TO_PAGES(LoadedEfiImageInfo->ImageSize);
        
        //
        // locate the descriptor containing the data.
        //
        Descriptor = BlFindMemoryDescriptor( NewBasePage );


        if (!Descriptor) {
//            EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, no descriptor.\r\n");
            //
            // no descriptor describes this range.  So create a new one and
            // insert it.
            //
            Descriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                            sizeof(MEMORY_ALLOCATION_DESCRIPTOR));
            if (Descriptor == NULL) {
                EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, allocate MEMORY_ALLOCATION_DESCRIPTOR failed.\r\n");
                Status = ENOMEM;
                goto exit;
            }
        
            Descriptor->MemoryType = MemoryFirmwarePermanent;
            Descriptor->BasePage =  NewBasePage;
            Descriptor->PageCount = NewPageCount;

            BlInsertDescriptor(Descriptor);

            //EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, finished inserting descriptor.\r\n");

        } else {

            //EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, calling BlGenerateDescriptor .\r\n");

            Status = BlGenerateDescriptor(
                            Descriptor,
                            MemoryFirmwarePermanent,
                            NewBasePage,
                            NewPageCount);

            //EfiST->ConOut->OutputString(EfiST->ConOut, L"In BlLoadEFIImage, back from BlGenerateDescriptor .\r\n");
        }

    }
#endif

    if(EFI_ERROR(EfiStatus)) {
        Status = EFAULT;
        _EfiHandle = NULL;
    }

exit:
    if(EfiHandle != NULL) {
        *EfiHandle = _EfiHandle;
    }

    if(PageBase != 0) {
        BlFreeDescriptor(PageBase);
    }

    if(FileId != -1) {
        BlClose(FileId);
    }

    if(PartitionId != -1) {
        ArcClose(PartitionId);
    }

    return Status;
}


EFI_STATUS
EfiAllocateAndZeroMemory(
    EFI_MEMORY_TYPE     MemoryType,
    UINTN               Size,
    PVOID               *ReturnPtr
    )
/*++

Routine Description:

    Returns a memory pointer which points to a newly allocated block
    of memory.  If the memory allocation succeeds, the block is
    zero'd out.

Arguments:

    MemoryType      Specified EFI memory type to be tagged
    
    Size            Size (in bytes) of the requested memory block.
    
    ReturnPtr       Recieves the pointer allocated memory.

Returns:

    EFI_STATUS determining if the allocation was successful.

--*/
{
    EFI_STATUS      Status = EFI_SUCCESS;
    BOOLEAN         FlipBackToVirtual = FALSE;

    //
    // Check parameters and initialize.
    //
    if( !ReturnPtr ) {
        return EFI_INVALID_PARAMETER;
    }
    *ReturnPtr = NULL;
    if( (Size == 0) || (MemoryType >= EfiMaxMemoryType) ) {
        return EFI_INVALID_PARAMETER;
    }


    // If we aren't already in physical mode, get there now.
    if (IsPsrDtOn()) {
        FlipToPhysical();
        FlipBackToVirtual = TRUE;
    }
    
    // try to allocate the requested block.
    Status = EfiST->BootServices->AllocatePool( MemoryType,
                                                Size,
                                                ReturnPtr );
    if( FlipBackToVirtual ) {
        FlipToVirtual();
    }


    //
    // If everything went okay, zero the block before returning.
    //
    if( (Status == EFI_SUCCESS) &&
        (*ReturnPtr != NULL) ) {
        RtlZeroMemory( *ReturnPtr, Size );
        ASSERT (((UINTN)(*ReturnPtr)) % MIN_ALIGNMENT_SIZE == 0);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\entry.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    entry.c

Abstract:

    EFI specific startup for os loaders

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

--*/
#if defined(_IA64_)
#include "bootia64.h"
#endif

#include "biosdrv.h"

#include "efi.h"
#include "stdio.h"
#include "flop.h"

#if 0
#define DBGOUT(x)   BlPrint x
#define DBGPAUSE    while(!GET_KEY());
#else
#define DBGOUT(x)
#define DBGPAUSE
#endif

extern VOID AEInitializeStall();

//
// Externals
//
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;

BOOLEAN GoneVirtual = FALSE;
//
// Prototypes for Internal Routines
//

VOID
DoGlobalInitialization(
    PBOOT_CONTEXT
    );

#if defined(ELTORITO)
BOOLEAN ElToritoCDBoot = FALSE;
#endif

extern CHAR NetBootPath[];

//
// Global context pointers. These are passed to us by the SU module or
// the bootstrap code.
//

PCONFIGURATION_COMPONENT_DATA FwConfigurationTree = NULL;
PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
CHAR BootPartitionName[129];
ULONG FwHeapUsed = 0;
#if defined(NEC_98)
ULONG Key;
int ArrayDiskStartOrdinal = -1;
BOOLEAN BootedFromArrayDisk = FALSE;
BOOLEAN HyperScsiAvalable = FALSE;
#endif //NEC_98
ULONG MachineType = 0;
LONG_PTR OsLoaderBase;
LONG_PTR OsLoaderExports;
extern PUCHAR BlpResourceDirectory;
extern PUCHAR BlpResourceFileOffset;
ULONGLONG BootFlags = 0;

#if DBG

extern EFI_SYSTEM_TABLE        *EfiST;
#define DBG_TRACE(_X) EfiPrint(_X)

#else

#define DBG_TRACE(_X) 

#endif // for FORCE_CD_BOOT

VOID
NtProcessStartup(
    IN PBOOT_CONTEXT BootContextRecord
    )
/*++

Routine Description:

    Main entry point for setup loader. Control is transferred here by the
    start-up (SU) module.

Arguments:

    BootContextRecord - Supplies the boot context, particularly the
        ExternalServicesTable.

Returns:

    Does not return. Control eventually passed to the kernel.


--*/
{
    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;
    ARC_STATUS Status;

    DBG_TRACE(L"NtProcessStart: Entry\r\n");
    
    //
    // Initialize the boot loader's video
    //

    DoGlobalInitialization(BootContextRecord);

    BlFillInSystemParameters(BootContextRecord);

    //
    // Set the global bootflags
    //
    BootFlags = BootContextRecord->BootFlags;

    //
    // Initialize the memory descriptor list, the OS loader heap, and the
    // OS loader parameter block.
    //

    DBG_TRACE( L"NtProcessStartup:about to BlMemoryInitialize\r\n");

    Status = BlMemoryInitialize();
    if (Status != ESUCCESS) {
        DBG_TRACE(TEXT("Couldn't initialize memory\r\n"));
        FlipToPhysical();
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


#ifdef FORCE_CD_BOOT
    DBG_TRACE(L"Forcing BootMediaCdrom\r\n");    
    BootContextRecord->MediaType = BootMediaCdrom;
#endif // for FORCE_CD_BOOT    
    
    if (BootContextRecord->MediaType == BootMediaFloppyDisk) {

        //
        // Boot was from A:
        //

        BootDeviceFloppy = (PBOOT_DEVICE_FLOPPY) &(BootContextRecord->BootDevice);
        sprintf(BootPartitionName,
                "multi(0)disk(0)fdisk(%u)",
                BootDeviceFloppy->DriveNumber);

    } else if (BootContextRecord->MediaType == BootMediaTcpip) {

        //
        // Boot was from the net
        //
        strcpy(BootPartitionName,"net(0)");
        BlBootingFromNet = TRUE;

#if defined(ELTORITO)
    } else if (BootContextRecord->MediaType == BootMediaCdrom) {

#ifdef FORCE_CD_BOOT
        sprintf(BootPartitionName,
                "multi(0)disk(0)cdrom(%u)",
                0
                );
                
        ElToritoCDBoot = TRUE;
#else
        //
        // Boot was from El Torito CD
        //
        if( BootContextRecord->BusType == BootBusAtapi ) {
            BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)cdrom(%u)",
                    BootDeviceAtapi->Lun);
        } else if( BootContextRecord->BusType == BootBusScsi ) {
            BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)cdrom(%u)",
                    BootDeviceScsi->Lun);
        } else if( BootContextRecord->BusType == BootBusVendor ) {
            BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)cdrom(%u)",
                    0 
                    );
        }
        ElToritoCDBoot = TRUE;
#endif // for FORCE_CD_BOOT
#endif // for ELTORITO

    } else {
        //
        // Find the partition we have been booted from.  Note that this
        // is *NOT* necessarily the active partition.  If the system has
        // Boot Mangler installed, it will be the active partition, and
        // we have to go figure out what partition we are actually on.
        //
        if (BootContextRecord->BusType == BootBusAtapi) {
            BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)rdisk(%u)partition(%u)",
                    BlGetDriveId(BL_DISKTYPE_ATAPI, (PBOOT_DEVICE)BootDeviceAtapi), // BootDeviceAtapi->Lun,
                    BootContextRecord->PartitionNumber);
        } else if (BootContextRecord->BusType == BootBusScsi) {
            BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "scsi(0)disk(0)rdisk(%u)partition(%u)",
                    BlGetDriveId(BL_DISKTYPE_SCSI, (PBOOT_DEVICE)BootDeviceScsi), //BootDeviceScsi->Pun, 
                    BootContextRecord->PartitionNumber);
        } else if (BootContextRecord->BusType == BootBusVendor) {
            BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContextRecord->BootDevice);
            sprintf(BootPartitionName,
                    "multi(0)disk(0)rdisk(%u)partition(%u)",
                    BlGetDriveId(BL_DISKTYPE_UNKNOWN, (PBOOT_DEVICE)BootDeviceUnknown), //BootDeviceUnknown->LegacyDriveLetter & 0x7F, 
                    BootContextRecord->PartitionNumber);
        }
    }
    
    //
    // Initialize the OS loader I/O system.
    //
    AEInitializeStall();

    FlipToPhysical();
    DBG_TRACE( L"NtProcessStartup:about to Init I/O\r\n");
    FlipToVirtual();
    Status = BlIoInitialize();
    if (Status != ESUCCESS) {
#if DBG
        BlPrint(TEXT("Couldn't initialize I/O\r\n"));
#endif
        FlipToPhysical();
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
    
    //
    // Call off to regular startup code
    //
    FlipToPhysical();
    DBG_TRACE( L"NtProcessStartup:about to call BlStartup\r\n");
    FlipToVirtual();

    BlStartup(BootPartitionName);    

    //
    // we should never get here!
    //
    if (BootFlags & BOOTFLAG_REBOOT_ON_FAILURE) {
        ULONG StartTime = ArcGetRelativeTime();
        BlPrint(TEXT("\nRebooting in 5 seconds...\n"));
        while ( ArcGetRelativeTime() - StartTime < 5) {}
        ArcRestart();      
    }
    
    do {
        GET_KEY();
    } while ( 1 );

}


VOID
DoGlobalInitialization(
    IN PBOOT_CONTEXT BootContextRecord
    )

/*++

Routine Description

    This routine calls all of the subsytem initialization routines.


Arguments:

    None

Returns:

    Nothing

--*/

{
    ARC_STATUS Status;

    //
    // Set base address of OS Loader image for the debugger.
    //

    OsLoaderBase = BootContextRecord->OsLoaderBase;
    OsLoaderExports = BootContextRecord->OsLoaderExports;

    //
    // Initialize memory.
    //

    Status = InitializeMemorySubsystem(BootContextRecord);
    if (Status != ESUCCESS) {
#if DBG
        BlPrint(TEXT("InitializeMemory failed %lx\r\n"),Status);
#endif
        FlipToPhysical();
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
    ExternalServicesTable=BootContextRecord->ExternalServicesTable;
    MachineType = (ULONG) BootContextRecord->MachineType;

    //
    // Turn the cursor off
    //
    // bugbug EFI
    //HW_CURSOR(0,127);

    FlipToPhysical();
    DBG_TRACE( L"DoGlobalInitialization: cursor off\r\n");
    EfiST->ConOut->EnableCursor(EfiST->ConOut, FALSE);
    FlipToVirtual();

    BlpResourceDirectory = (PUCHAR)(BootContextRecord->ResourceDirectory);
    BlpResourceFileOffset = (PUCHAR)(BootContextRecord->ResourceOffset);

    OsLoaderBase = BootContextRecord->OsLoaderBase;
    OsLoaderExports = BootContextRecord->OsLoaderExports;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\input.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    input.c

Author:

    Ken Reneris Oct-2-1997

Abstract:

--*/

#if defined (_IA64_)
#include "bootia64.h"
#endif

#if defined (_X86_)
#include "bldrx86.h"
#endif

#include "displayp.h"
#include "stdio.h"

#include "efi.h"
#include "efip.h"
#include "flop.h"

#include "bootefi.h"

//
// Externals
//
extern BOOT_CONTEXT BootContext;
extern EFI_HANDLE EfiImageHandle;
extern EFI_SYSTEM_TABLE *EfiST;
extern EFI_BOOT_SERVICES *EfiBS;
extern EFI_RUNTIME_SERVICES *EfiRS;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiBlockIoProtocol;

//
// Globals
//
ULONGLONG InputTimeout = 0;


//
// Takes any pending input and converts it into a KEY value.  Non-blocking, returning 0 if no input available.
//
ULONG
BlGetKey()
{
    ULONG Key = 0;
    UCHAR Ch;
    ULONG Count;

    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

        ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

        if (Ch == ASCI_CSI_IN) {

            if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {

                ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);

                //
                // All the function keys start with ESC-O
                //
                switch (Ch) {
                case 'O':

                    ArcRead(BlConsoleInDeviceId, &Ch, sizeof(Ch), &Count);  // will not or block, as the buffer is already filled

                    switch (Ch) {
                    case 'P': 
                        Key = F1_KEY;
                        break;

                    case 'Q': 
                        Key = F2_KEY;
                        break;

                    case 'w': 
                        Key = F3_KEY;
                        break;

                    case 'x':
                        Key = F4_KEY;
                        break;

                    case 't': 
                        Key = F5_KEY;
                        break;

                    case 'u': 
                        Key = F6_KEY;
                        break;

                    case 'r': 
                        Key = F8_KEY;
                        break;

                    case 'M':
                        Key = F10_KEY;
                        break;
                    }
                    break;

                case 'A':
                    Key = UP_ARROW;
                    break;

                case 'B':
                    Key = DOWN_ARROW;
                    break;

                case 'C':
                    Key = RIGHT_KEY;
                    break;

                case 'D':
                    Key = LEFT_KEY;
                    break;

                case 'H':
                    Key = HOME_KEY;
                    break;

                case 'K':
                    Key = END_KEY;
                    break;

                case '@':
                    Key = INS_KEY;
                    break;

                case 'P':
                    Key = DEL_KEY;
                    break;

                case TAB_KEY:
                    Key = BACKTAB_KEY;
                    break;

                }

            } else { // Single escape key, as no input is waiting.

                Key = ESCAPE_KEY;

            }

        } else if (Ch == 0x8) {

            Key = BKSP_KEY;

        } else {

            Key = (ULONG)Ch;

        }

    }

    return Key;
}


VOID
BlInputString(
    IN ULONG    Prompt,
    IN ULONG    CursorX,
    IN ULONG    PosY,
    IN PUCHAR   String,
    IN ULONG    MaxLength
    )
{
    PTCHAR      PromptString;
    ULONG       TextX, TextY;
    ULONG       Length, Index;
    _TUCHAR     CursorChar[2];
    ULONG       Key;
    _PTUCHAR    p;
    ULONG       i;
    ULONG       Count;
    _PTUCHAR    pString;
#ifdef UNICODE
    WCHAR       StringW[200];
    UNICODE_STRING uString;
    ANSI_STRING aString;
    pString = StringW;
    uString.Buffer = StringW;
    uString.MaximumLength = sizeof(StringW);
    RtlInitAnsiString(&aString, (PCHAR)String );
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
#else
    pString = String;
#endif    


    PromptString = BlFindMessage(Prompt);
    Length = (ULONG)strlen((PCHAR)String);
    CursorChar[1] = TEXT('\0');

    //
    // Print prompt
    //

    BlEfiPositionCursor( PosY, CursorX );
    BlEfiEnableCursor( TRUE );
    ArcWrite(BlConsoleOutDeviceId, PromptString, (ULONG)_tcslen(PromptString)*sizeof(TCHAR), &Count);

    //
    // Indent cursor to right of prompt
    //

    CursorX += (ULONG)_tcslen(PromptString);
    TextX = CursorX;
    Key = 0;

    for (; ;) {

        TextY = TextX + Length;
        if (CursorX > TextY) {
            CursorX = TextY;
        }
        if (CursorX < TextX) {
            CursorX = TextX;
        }

        Index = CursorX - TextX;
        pString[Length] = 0;

        //
        // Display current string
        //

        BlEfiPositionCursor( TextY, TextX );
        ArcWrite(
            BlConsoleOutDeviceId, 
            pString, 
            (ULONG)_tcslen(pString)*sizeof(TCHAR), 
            &Count);
        ArcWrite(BlConsoleOutDeviceId, TEXT("  "), sizeof(TEXT("  ")), &Count);
        if (Key == 0x0d) {      // enter key?
            break ;
        }

        //
        // Display cursor
        //
        BlEfiPositionCursor( PosY, CursorX );
        BlEfiSetInverseMode( TRUE );
        CursorChar[0] = pString[Index] ? pString[Index] : TEXT(' ');
        ArcWrite(BlConsoleOutDeviceId, CursorChar, sizeof(_TUCHAR), &Count);
        BlEfiSetInverseMode( FALSE );
        BlEfiPositionCursor( PosY, CursorX );
        BlEfiEnableCursor(TRUE);
        
        //
        // Get key and process it
        //

        while ((Key = BlGetKey()) == 0) ;

        switch (Key) {
            case HOME_KEY:
                CursorX = TextX;
                break;

            case END_KEY:
                CursorX = TextY;
                break;

            case LEFT_KEY:
                CursorX -= 1;
                break;

            case RIGHT_KEY:
                CursorX += 1;
                break;

            case BKSP_KEY:
                if (!Index) {
                    break;
                }

                CursorX -= 1;
                pString[Index-1] = CursorChar[0];
                // fallthough to DEL_KEY
            case DEL_KEY:
                if (Length) {
                    p = pString+Index;
                    i = Length-Index+1;
                    while (i) {
                        p[0] = p[1];
                        p += 1;
                        i -= 1;
                    }
                    Length -= 1;
                }
                break;

            case INS_KEY:
                if (Length < MaxLength) {
                    p = pString+Length;
                    i = Length-Index+1;
                    while (i) {
                        p[1] = p[0];
                        p -= 1;
                        i -= 1;
                    }
                    pString[Index] = TEXT(' ');
                    Length += 1;
                }
                break;

            default:
                Key = Key & 0xff;

                if (Key >= ' '  &&  Key <= 'z') {
                    if (CursorX == TextY  &&  Length < MaxLength) {
                        Length += 1;
                    }

                    pString[Index] = (_TUCHAR)Key;
                    pString[MaxLength] = 0;
                    CursorX += 1;
                }
                break;
        }
    }
}


ULONGLONG
BlSetInputTimeout(
    ULONGLONG Timeout
    )
/*++

 Routine Description:

    Sets the InputTimeout value.  This is used
    when getting local input.  When attempting 
    to get local input, we will wait for up 
    to InputTimeout for a local key to be
    pressed.

 Arguments:

    Timeout - Value to set the global InputTimeout to
              (in 100 nanoseconds)

 Return Value:

    The value stored in InputTimeout

--*/
{
    InputTimeout = Timeout;

    return InputTimeout;
}


ULONGLONG
BlGetInputTimeout(
    VOID
    ) 
/*++

 Routine Description:

    Gets the InputTimeout value.  This is used
    when getting local input.  When attempting 
    to get local input, we will wait for up 
    to InputTimeout for a local key to be
    pressed.

 Arguments:

    none.

 Return Value:

    The value stored in InputTimeout

--*/
{
    return InputTimeout;
}

EFI_STATUS
BlWaitForInput(
    EFI_INPUT_KEY *Key,
    ULONGLONG Timeout
    )
/*++

 Routine Description:

    creates an event consisting of a time interval
    and an efi event (local input).  Once event
    is signaled, will check for input
    
    Assumes it is being called in PHYSICAL mode

 Arguments:

    Key - input key structure to return
          input in
    Timeout - Timer interval to wait.

 Return Value:

    EFI_TIMEOUT if timer interval met
    EFI_SUCCESS if passed in event is met.
    other error if EFI call failed.
    
--*/
{
    EFI_STATUS Status = EFI_SUCCESS;
   
    //
    // start by seeing if there is any pending input
    // 
    Status = EfiST->ConIn->ReadKeyStroke(EfiST->ConIn, 
                                         Key
                                         );
    if (Status == EFI_SUCCESS) {
        return Status;
    }

    //
    // create events to wait on
    //
    if (Timeout) {
        EFI_EVENT Event;
        EFI_EVENT TimerEvent;
        EFI_EVENT WaitList[2];
        UINTN Index;
                
        Event = EfiST->ConIn->WaitForKey;

        // 
        //  Create a timer event
        //

        Status = EfiBS->CreateEvent(EVT_TIMER, 0, NULL, NULL, &TimerEvent);
        if (Status == EFI_SUCCESS) {
            //
            // set the timer event
            //
            EfiBS->SetTimer(TimerEvent, 
                            TimerRelative, 
                            Timeout
                            );

            // 
            // Wait for the original event or timer
            //
            WaitList[0] = Event;
            WaitList[1] = TimerEvent;
            Status = EfiBS->WaitForEvent(2, 
                                         WaitList, 
                                         &Index
                                         );
            EfiBS->CloseEvent(TimerEvent);

            //
            // if the timer expired, change the return to timed out
            //
            if(Status == EFI_SUCCESS && Index == 1) {
                Status = EFI_TIMEOUT;
            }

            //
            // attempt to read local input
            //
            if (Status == EFI_SUCCESS) {
                Status = EfiST->ConIn->ReadKeyStroke(EfiST->ConIn, 
                                                     Key
                                                     );
            }
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\exp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1998  Intel Corporation


Module Name:

    exp.c

Abstract:

    This file contains low level I/O functions that are implemented
        with BIOS calls.

Author:

    Allen Kay   (akay)  04-Aug-97

--*/

#include "bldr.h"
#include "sudata.h"
#if defined(_IA64_)
#include "bootia64.h"
#include "bldria64.h"
#endif
#include "efi.h"
#include "extern.h"


ARC_STATUS
RebootProcessor(
    VOID
    )
{
#if DBG
    BlPrint(TEXT("About to call EfiRS->ResetSystem()"));
#endif

    FlipToPhysical();

    return( (ARC_STATUS) EfiRS->ResetSystem(EfiResetCold, 0, 0, NULL) );
}

ARC_STATUS
GetSector(
    ULONG Operation,
    ULONG Drive,
    ULONG Head,
    ULONG Cylinder,
    ULONG Sector,
    ULONG SectorCount,
    ULONG Buffer
    )
{
    UNREFERENCED_PARAMETER( Operation );
    UNREFERENCED_PARAMETER( Drive );
    UNREFERENCED_PARAMETER( Head );
    UNREFERENCED_PARAMETER( Cylinder );
    UNREFERENCED_PARAMETER( Sector );
    UNREFERENCED_PARAMETER( SectorCount );
    UNREFERENCED_PARAMETER( Buffer );
    
    //
    // NOTE!: Need to remove this function
    //
    return (0);
}

ARC_STATUS
GetEddsSector(
    EFI_HANDLE Handle,
    ULONG SectorNumberLow,
    ULONG SectorNumberHigh,
    ULONG SectorCount,
    PUCHAR Buffer,
    UCHAR  Write
    )
{
    EFI_BLOCK_IO *BlkDev;
    EFI_STATUS Status;
    ULONGLONG Lba;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    //
    // convert virtual address to physical if it is virtual.
    //

    if (((ULONGLONG)Buffer & KSEG0_BASE) == KSEG0_BASE) {
        Buffer = (PUCHAR) ((ULONGLONG)Buffer & ~KSEG0_BASE);
    }

    Lba = (SectorNumberHigh << 32) | SectorNumberLow;

    Status = EfiBS->HandleProtocol( Handle,
                                    &EfiBlockIoProtocol,
                                    &BlkDev);
    if (EFI_ERROR(Status)) {
#if DBG
        EfiPrint( L"GetEddSector: HandleProtocol failed\n\r");
#endif
        FlipToVirtual();
        return (EIO);
    }


    if (Write == 0x43) {
        Status = BlkDev->WriteBlocks( BlkDev,
                                      BlkDev->Media->MediaId,
                                      Lba,
                                      SectorCount * BlkDev->Media->BlockSize,
                                      Buffer);
    } else {
        Status = BlkDev->ReadBlocks( BlkDev,
                                     BlkDev->Media->MediaId,
                                     Lba,
                                     SectorCount * BlkDev->Media->BlockSize,
                                     Buffer);
    }


    if (EFI_ERROR(Status) && BlkDev->Media->RemovableMedia) {

        //
        // Failed operation to removable media.
        //
#if DBG
        EfiPrint( L"GetEddSector: R/W operation to removable media failed\n\r");
#endif
        FlipToVirtual();
        return (ENODEV);
    }
    
    if (EFI_ERROR(Status)) {
        //
        // Failed operation to fixed media.
        //
#if DBG
        EfiPrint( L"\nGetEddsSector: R/W operation to fixed Media failed.\r\n");
#endif
        FlipToVirtual();
        return (EIO);
    }

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();
    return(ESUCCESS);
}

ULONG
GetKey(
    VOID
    )
{
    EFI_INPUT_KEY               Key;
    EFI_STATUS                  Status;
    ULONG                       Code;
    BOOLEAN                     WasVirtual;

    //
    // default return value is 0
    //
    Code = 0;

    //
    // Remember if we started off in virtual mode
    //
    WasVirtual = IsPsrDtOn();

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    if (WasVirtual) {
        FlipToPhysical();
    }

    //
    // If set, wait for keystroke 
    // 
    Status = BlWaitForInput(&Key,
                            BlGetInputTimeout()
                            );
    if (EFI_ERROR(Status)) {
        goto GET_KEY_DONE;
    }

    if (Key.UnicodeChar) {
        // truncate unicode char to ascii
        if (Key.UnicodeChar > 0xFF) {
            Code = 0;
            goto GET_KEY_DONE;
        }

        // Convert back spaces
        if (Key.UnicodeChar == 0x08) {
            Key.UnicodeChar = 0x0E08;
        }

        Code = Key.UnicodeChar;
        goto GET_KEY_DONE;
    }

    //
    // Convert EFI keys to dos key codes
    //

    switch (Key.ScanCode) {
#if 0
        case SCAN_UP:        Code = 0x4800;  break;
        case SCAN_DOWN:      Code = 0x5000;  break;
        case SCAN_RIGHT:     Code = 0x4d00;  break;
        case SCAN_LEFT:      Code = 0x4b00;  break;
        case SCAN_HOME:      Code = 0x4700;  break;
        case SCAN_INSERT:    Code = 0x5200;  break;
        case SCAN_DELETE:    Code = 0x5300;  break;
        case SCAN_PAGE_UP:   Code = 0x4900;  break;
        case SCAN_PAGE_DOWN: Code = 0x5100;  break;
        case SCAN_F1:        Code = 0x3b00;  break;
        case SCAN_F2:        Code = 0x3c00;  break;
        case SCAN_F3:        Code = 0x3d00;  break;
        case SCAN_F4:        Code = 0x3e00;  break;
        case SCAN_F5:        Code = 0x3f00;  break;
        case SCAN_F6:        Code = 0x4000;  break;
        case SCAN_F7:        Code = 0x4100;  break;
        case SCAN_F8:        Code = 0x4200;  break;
        case SCAN_F9:        Code = 0x4300;  break;
        case SCAN_F10:       Code = 0x4400;  break;
        case SCAN_ESC:       Code = 0x001d;  break;
#else
        case SCAN_UP:        Code = UP_ARROW;    break;
        case SCAN_DOWN:      Code = DOWN_ARROW;  break;
        case SCAN_RIGHT:     Code = RIGHT_KEY;   break;
        case SCAN_LEFT:      Code = LEFT_KEY;    break;
        case SCAN_HOME:      Code = HOME_KEY;    break;
        case SCAN_INSERT:    Code = INS_KEY;     break;
        case SCAN_DELETE:    Code = DEL_KEY;     break;
        // bugbug
        case SCAN_PAGE_UP:   Code = 0x4900;  break;
        // bugbug    
        case SCAN_PAGE_DOWN: Code = 0x5100;  break;
        case SCAN_F1:        Code = F1_KEY;      break;
        case SCAN_F2:        Code = F2_KEY;      break;
        case SCAN_F3:        Code = F3_KEY;      break;
        // bugbug
        case SCAN_F4:        Code = 0x3e00;      break;
        case SCAN_F5:        Code = F5_KEY;      break;
        case SCAN_F6:        Code = F6_KEY;      break;
        case SCAN_F7:        Code = F7_KEY;      break;
        case SCAN_F8:        Code = F8_KEY;      break;
        // bugbug
        case SCAN_F9:        Code = 0x4300;  break;
        case SCAN_F10:       Code = F10_KEY;     break;
        //bugbug different than 0x001d
        case SCAN_ESC:       Code = ESCAPE_KEY;  break;
#endif
    }

GET_KEY_DONE:
    //
    // Restore virtual mode before returning.
    //
    if (WasVirtual) {
        FlipToVirtual();
    }

    return Code;
}

ULONG Counter = 0;

ULONG
GetCounter(
    VOID
    )
{
    EFI_TIME        Time;
    UINTN           ms;
    static UINTN    BaseTick, LastMs;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    // NB. the NT loader only uses this to count seconds
    // this function only works if called at least every hour

    //
    // Get the current calendar time
    //

    EfiRS->GetTime (&Time, NULL);

    // Compute a millisecond value for the time
    ms = Time.Minute * 60 * 1000 + Time.Second * 1000 + Time.Nanosecond / 1000000;
    if (ms < LastMs) {
        BaseTick += 65520;          // 60 * 60 * 18.2
    }

    LastMs = ms;

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();

    return (ULONG) (( (ms * 182) / 10000) + BaseTick);
}

//
// Transfer control to a loaded boot sector
//
VOID
Reboot(
    ULONG BootType
    )
{
    UNREFERENCED_PARAMETER( BootType );

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    EfiBS->Exit(EfiImageHandle, 0, 0, 0);
}

VOID
HardwareCursor(
    ULONG YCoord,
    ULONG XCoord
    )
{
    UNREFERENCED_PARAMETER( YCoord );
    UNREFERENCED_PARAMETER( XCoord );
    //
    // NOTE!: Need to be implemented
    //
}

VOID
GetDateTime(
    PULONG Date,
    PULONG Time
    )
{
    UNREFERENCED_PARAMETER( Date );
    UNREFERENCED_PARAMETER( Time );
    //
    // NOTE!: Need to implement
    //
}

VOID
DetectHardware(
    ULONG HeapStart,
    ULONG HeapSize,
    ULONG ConfigurationTree,
    ULONG HeapUsed,
    ULONG OptionString,
    ULONG OptionStringLength
    )
{
    UNREFERENCED_PARAMETER( HeapStart );
    UNREFERENCED_PARAMETER( HeapSize );
    UNREFERENCED_PARAMETER( ConfigurationTree );
    UNREFERENCED_PARAMETER( HeapUsed );
    UNREFERENCED_PARAMETER( OptionString );
    UNREFERENCED_PARAMETER( OptionStringLength );

    //
    // NOTE!: needed to remove
    //
}

VOID
ComPort(
    LONG Port,
    ULONG Function,
    UCHAR Arg
    )
{
    //
    // NOTE!: needed to remove
    //

    UNREFERENCED_PARAMETER( Port );
    UNREFERENCED_PARAMETER( Function );
    UNREFERENCED_PARAMETER( Arg );
}

ULONG
GetStallCount(
    VOID
    )
{
#if defined(VPC_PHASE2)
    ULONGLONG Frequency;

    //
    // First go into physical mode since EFI calls can only be made in
    // physical mode.
    //
    FlipToPhysical();

    IA32RegisterState.esp = SAL_PROC_SP;
    IA32RegisterState.ss = SAL_PROC_SS;
    IA32RegisterState.eflags = SAL_PROC_EFLAGS;

    SAL_PROC(SAL_FREQ_BASE,0,0,0,0,0,0,0,RetVals);
    Frequency = RetVals->RetVal1;

    //
    // Restore virtual mode before returning.
    //
    FlipToVirtual();

    return ((ULONG) Frequency / 1000);     // Convert ticks/sec to ticks/usec
#else
    return ((ULONG) 1000000);     // Convert ticks/sec to ticks/usec
#endif
}

VOID
InitializeDisplayForNt(
    VOID
    )
{
    //
    // NOTE!: Need to implement
    //
}

VOID
GetMemoryDescriptor(
    )
{
    //
    // NOTE!: need to remove
    //
}

BOOLEAN
GetElToritoStatus(
    PUCHAR Buffer,
    UCHAR DriveNum
    )
{
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( DriveNum );

    //
    // NOTE!: need to remove
    //
    return(0);
}

BOOLEAN
GetExtendedInt13Params(
    PUCHAR Buffer,
    UCHAR Drive
    )
{
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Drive );

    return(1);
}

USHORT
NetPcRomServices(
    ULONG FunctionNumber,
    PVOID CommandPacket
    )
{
    UNREFERENCED_PARAMETER( FunctionNumber );
    UNREFERENCED_PARAMETER( CommandPacket );

    //
    // should never call this from EFI app.
    //
    ASSERT(FALSE);

    return (USHORT)0;
}


ULONG
GetRedirectionData(
   ULONG Command
   )
/* ++

 Routine Name:

       BiosRedirectService

 Description:

       Get parameters of bios redirection.

 Arguments:

       Command - 1: Get Com Port Number
                 2: Get Baud Rate
                 3: Get Parity
                 4: Get Stop Bits

 Returns:

       Value, or -1 if an error.

--
*/
{
    UNREFERENCED_PARAMETER( Command );

    //
    // should never call this from EFI app.
    //
    ASSERT(FALSE);
    return((ULONG)-1);
}

VOID
APMAttemptReconect(
    VOID
    )
{
    //
    // should never call this from EFI app.
    //
    ASSERT(FALSE);
    return;
}


VOID
SuFillExportTable(
    )
{
    PEXTERNAL_SERVICES_TABLE Est = (PEXTERNAL_SERVICES_TABLE)ExportEntryTable;

    Est->RebootProcessor        = &RebootProcessor;
    Est->DiskIOSystem           = &GetSector;
    Est->GetKey                 = &GetKey;
    Est->GetCounter             = &GetCounter;
    Est->Reboot                 = &Reboot;
    Est->DetectHardware         = &DetectHardware;
    Est->HardwareCursor         = &HardwareCursor;
    Est->GetDateTime            = &GetDateTime;
    Est->ComPort                = &ComPort;
    Est->GetStallCount          = &GetStallCount;
    Est->InitializeDisplayForNt = &InitializeDisplayForNt;
    Est->GetMemoryDescriptor    = &GetMemoryDescriptor;
    Est->GetEddsSector          = &GetEddsSector;
    Est->GetElToritoStatus      = &GetElToritoStatus;
    Est->GetExtendedInt13Params = &GetExtendedInt13Params;
    Est->NetPcRomServices       = &NetPcRomServices;
    Est->ApmAttemptReconnect    = &APMAttemptReconect;
    Est->BiosRedirectService    = &GetRedirectionData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\sources.inc ===
!IF 0

Copyright (c) Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=boot

!IF "$(BUILD_DEBUG_LOADER)" != ""
!include $(PROJECT_ROOT)\boot\loader_dbg.inc
!ELSE
!include $(PROJECT_ROOT)\boot\loader.inc
!ENDIF

TARGETNAME=efi
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES= \
    $(SDK_INC_PATH);\
    $(DS_INC_PATH)\crypto;\
    $(PROJECT_ROOT)\hals;\
    $(PROJECT_ROOT)\hals\inc;\
    ..\inc;\
    ..\..\inc;\
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\fs\fastfat;\
    $(PROJECT_ROOT)\fs\cdfs;\
    $(PROJECT_ROOT)\fs\udfs;\
    $(PROJECT_ROOT)\fs\cntfs;\
    $(PROJECT_ROOT)\ntos\config;\
    ..\$(TARGET_DIRECTORY);\
    $(DDK_INC_PATH);\
    $(HALKIT_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX

!if defined(LINK_TIME_CODE_GENERATION)
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /wd4702
!ENDIF

!IF $(IA64)
INCLUDES = $(INCLUDES);..\..\lib\$(TARGET_DIRECTORY);..\inc\$(TARGET_DIRECTORY)
!ENDIF

!IF 0
NOTE : To force CD/DVD boot while starting setupldr from harddisk use
       FORCE_CD_BOOT
C_DEFINES=$(C_DEFINES) -DFORCE_CD_BOOT -DEFI

!ENDIF

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE -DEFI

SOURCES=..\arcemul.c  \
        ..\acpidtct.c \
        ..\arctree.c  \
        ..\biosdrv.c  \
        ..\display.c  \
        ..\efidisp.c  \
        ..\efiutil.c  \
        ..\entry.c    \
        ..\envvar.c   \
        ..\exp.c      \
        ..\input.c    \
        ..\port.c     \
        ..\sumain.c   \
        ..\netboot2.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\netboot2.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    net.c

Abstract:

    This module implements the net boot file system used by the operating
    system loader.

    It only contains those functions which are firmware/BIOS dependent.

Author:

Revision History:

--*/

#include "..\bootlib.h"
#include "stdio.h"

#ifdef UINT16
#undef UINT16
#endif

#ifdef INT16
#undef INT16
#endif

#include <dhcp.h>
#include <netfs.h>
#include <pxe_cmn.h>

#include <pxe_api.h>

#include <udp_api.h>
#include <tftp_api.h>
#include "bldr.h"
#include "bootia64.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "extern.h"
#include "smbios.h"

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

#define MAX_PATH          260

//
// Define global data.
//

CHAR NetBootPath[129];

EFI_PXE_BASE_CODE              *PXEClient;
ULONG                           NetLocalIpAddress;
ULONG                           NetLocalSubnetMask;

ULONG                           NetServerIpAddress;
ULONG                           NetGatewayIpAddress;
UCHAR                           NetLocalHardwareAddress[16];

UCHAR MyGuid[16];
ULONG MyGuidLength = sizeof(MyGuid);
BOOLEAN MyGuidValid = FALSE;


TFTP_RESTART_BLOCK              gTFTPRestartBlock;


VOID
EfiDumpBuffer(
    PVOID Buffer,
    ULONG BufferSize
    )
/*++

Routine Description:

    Dumps the buffer content on to the debugger output.

Arguments:

    Buffer: buffer pointer.

    BufferSize: size of the buffer.

Return Value:

    none

--*/
{
#define NUM_CHARS 16

    ULONG i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    PUCHAR BufferPtr = Buffer;


    BlPrint(TEXT("------------------------------------\r\n"));

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            BlPrint(TEXT("%x "), (UCHAR)BufferPtr[i]);

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            BlPrint(TEXT("  "));
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            BlPrint(TEXT("  %s\r\n"), TextBuffer);            
        }

    }

    BlPrint(TEXT("------------------------------------\r\n"));


#if 0
    //
    // enable this to make it pause after dumping the buffer.
    //
    DBG_EFI_PAUSE();
#endif
}


EFI_STATUS
EfiGetPxeClient(
    VOID
    )
/*++

Routine Description:

    Obtains the global pointer to the PXE device
    booted from in a RIS scenario.
    
Arguments:

    none

Return Value:

    ESUCCESS when successful, otherwise failure

--*/
{
    EFI_STATUS        Status = EFI_UNSUPPORTED;
    EFI_GUID          PXEGuid = EFI_PXE_BASE_CODE_PROTOCOL;
    EFI_LOADED_IMAGE *EfiImageInfo;
    EFI_DEVICE_PATH  *PXEDevicePath;
    EFI_HANDLE        PXEHandle;

    if (PXEClient) {
        //
        // already have a pointer to the device
        // no more work needed
        //
        return ESUCCESS;
    }

    // 
    // get the correct PXE Handle by looking at the loaded
    // image for oschooser
    //

    //
    // get the image info for oschooser
    //
    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol (EfiImageHandle,
                                                  &EfiLoadedImageProtocol,
                                                  &EfiImageInfo);
    FlipToVirtual();

    if (Status != EFI_SUCCESS) {
        if( BdDebuggerEnabled ) {
            DbgPrint( "EfiGetPxeClient: HandleProtocol failed -LoadedImageProtocol (%d)\n", Status);
        }
        return Status;
    }

    //
    // get the device path to the image
    //
    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol (EfiImageInfo->DeviceHandle,
                                                  &EfiDevicePathProtocol,
                                                  &PXEDevicePath);
    FlipToVirtual();

    if (Status != EFI_SUCCESS) {
        if( BdDebuggerEnabled ) {
            DbgPrint( "EfiGetPxeClient: HandleProtocol failed -DevicePathProtocol (%d)\n", Status);
        }
        return Status;
    }

    //
    // get the PXE_BASE_CODE_PROTOCOL interface from returned handle
    //
    FlipToPhysical();
    Status = EfiST->BootServices->LocateDevicePath(&PXEGuid, 
                                                   &PXEDevicePath, 
                                                   &PXEHandle);
    FlipToVirtual();

    if (Status != EFI_SUCCESS)
    {
        if( BdDebuggerEnabled ) {
            DbgPrint( "EfiGetPxeClient: LocateDevicePath failed (%d)\n", Status);
        }
        return Status;
    }
    
    // get the pxebc interface from PXEHandle
    FlipToPhysical();
    Status = EfiST->BootServices->HandleProtocol(PXEHandle, 
                                                 &PXEGuid, 
                                                 &PXEClient);
    FlipToVirtual();

    if (Status != EFI_SUCCESS)
    {
        if( BdDebuggerEnabled ) {
            DbgPrint( "EfiGetPxeClient: HandleProtocol failed -PXEBCP interface (%d)\n", Status);
        }
        return Status;
    }

    return EFI_SUCCESS;
}


ARC_STATUS
FindDhcpOption(
    IN EFI_PXE_BASE_CODE_PACKET Packet,
    IN UCHAR Option,
    IN ULONG MaximumLength,
    OUT PUCHAR OptionData,
    OUT PULONG Length OPTIONAL,
    IN ULONG Instance OPTIONAL
    )
/*++

Routine Description:

    Searches a dhcp packet for a given option.

Arguments:

    Packet - pointer to the dhcp packet.  Caller is responsible for assuring
    that the packet is a valid dhcp packet.
    Option - the dhcp option we're searching for.
    MaximumLength - size in bytes of OptionData buffer.
    OptionData - buffer to receive the option.
    Length - if specified, receives the actual length of option copied.
    Instance - specifies which instance of the option you are searching for. 
    If not specified (zero), then we just grab the first instance of the tag.

Return Value:

    ARC_STATUS indicating outcome.

--*/
{
    PUCHAR curOption;
    ULONG copyLength;
    ULONG i = 0;

    if (MaximumLength == 0) {
        return EINVAL;
    }

    RtlZeroMemory(OptionData, MaximumLength);

    //
    // Parse the DHCP options looking for a specific one.
    //

    curOption = (PUCHAR)&Packet.Dhcpv4.DhcpOptions;
    while ((curOption - (PUCHAR)&Packet.Dhcpv4) < sizeof(EFI_PXE_BASE_CODE_DHCPV4_PACKET) &&
           *curOption != 0xff) {

        if (*curOption == DHCP_PAD) {
            //
            // just walk past any pad options
            // these will not have any length
            //
            curOption++;
        }
        else {        
            if (*curOption == Option) {

                //
                // Found it, copy and leave.
                //

                if ( i == Instance ) {

                    if (sizeof(EFI_PXE_BASE_CODE_DHCPV4_PACKET) <= curOption + 2 - (PUCHAR)&Packet.Dhcpv4 ||
                        sizeof(EFI_PXE_BASE_CODE_DHCPV4_PACKET) <= curOption + 2 + curOption[1] - (PUCHAR)&Packet.Dhcpv4 ) {
                        // 
                        // invalid option.  it walked past the end of the packet
                        //
                        break;
                    }

                    if (curOption[1] > MaximumLength) {
                        copyLength = MaximumLength;
                    } else {
                        copyLength = curOption[1];
                    }

                    RtlCopyMemory(OptionData,
                                  curOption+2,
                                  copyLength);

                    if (ARGUMENT_PRESENT(Length)) {
                        *Length = copyLength;
                    }

                    return ESUCCESS;
                }

                i++;
            }
            
            curOption = curOption + 2 + curOption[1];

        }
    }

    return EINVAL;

}

BOOLEAN
IsIpv4AddressNonZero(
    EFI_IPv4_ADDRESS *pAddress
    )
{
    if (pAddress->Addr[0] != 0 ||
        pAddress->Addr[1] != 0 ||
        pAddress->Addr[2] != 0 ||
        pAddress->Addr[3] != 0) {
        return(TRUE);
    }

    return(FALSE);
}



ARC_STATUS
GetParametersFromRom (
    VOID
    )
{
    UINTN             Count = 0;
    EFI_STATUS        Status = EFI_UNSUPPORTED;
    PUCHAR            p;
    UCHAR             temp[4];
 

    //
    // obtain a pointer to the PXE device we booted from
    //
    Status = EfiGetPxeClient();

    if (Status != EFI_SUCCESS) {
        return (ARC_STATUS) Status;
    }

    //
    // Our IP address is down in:
    // PXEClient->Mode->StationIp.v4
    //
    // The server's IP address is down in:
    // PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr
    //
    // Our NIC's GUID should be down in:
    // PXEClient->Mode->ProxyOffer.Dhcpv4.BootpHwAddr
    //
    // Our Subnetmask is down in:
    // PXEClient->Mode->SubnetMask.v4
    //
    NetServerIpAddress = 0;
    NetLocalIpAddress = 0;
    NetLocalSubnetMask = 0;
    NetGatewayIpAddress = 0;
    for( Count = 0; Count < 4; Count++ ) {
        NetServerIpAddress = (NetServerIpAddress << 8) + PXEClient->Mode->ProxyOffer.Dhcpv4.BootpSiAddr[Count];
        NetLocalIpAddress = (NetLocalIpAddress << 8) + PXEClient->Mode->StationIp.v4.Addr[Count];
        NetLocalSubnetMask = (NetLocalSubnetMask << 8) + PXEClient->Mode->SubnetMask.v4.Addr[Count];        
    }

    
    //
    // Our gateway address is either in the dhcp ack or the proxy offer packet.
    // proxy offer overrides the dhcp ack.
    // first look for the dhcp router option, then look in the packet itself.
    //
    //
    if (FindDhcpOption(PXEClient->Mode->DhcpAck, DHCP_ROUTER, sizeof(temp), (PUCHAR)temp, NULL, 0) == ESUCCESS) {
        NetGatewayIpAddress =  (temp[0] << 24) + 
                               (temp[1] << 16) + 
                               (temp[2] << 8) + 
                                temp[3];        
    } else if (IsIpv4AddressNonZero((EFI_IPv4_ADDRESS *)&PXEClient->Mode->DhcpAck.Dhcpv4.BootpGiAddr[0])) {
            NetGatewayIpAddress =  (PXEClient->Mode->DhcpAck.Dhcpv4.BootpGiAddr[0] << 24) + 
                                   (PXEClient->Mode->DhcpAck.Dhcpv4.BootpGiAddr[1] << 16) + 
                                   (PXEClient->Mode->DhcpAck.Dhcpv4.BootpGiAddr[2] << 8) + 
                                    PXEClient->Mode->DhcpAck.Dhcpv4.BootpGiAddr[3];
    }

    if (FindDhcpOption(PXEClient->Mode->ProxyOffer, DHCP_ROUTER, sizeof(temp), (PUCHAR)temp, NULL, 0) == ESUCCESS) {
        NetGatewayIpAddress =  (temp[0] << 24) + 
                               (temp[1] << 16) + 
                               (temp[2] << 8) + 
                                temp[3];
    } else if (IsIpv4AddressNonZero((EFI_IPv4_ADDRESS *)&PXEClient->Mode->ProxyOffer.Dhcpv4.BootpGiAddr[0])) {
        NetGatewayIpAddress =  (PXEClient->Mode->ProxyOffer.Dhcpv4.BootpGiAddr[0] << 24) + 
                               (PXEClient->Mode->ProxyOffer.Dhcpv4.BootpGiAddr[1] << 16) + 
                               (PXEClient->Mode->ProxyOffer.Dhcpv4.BootpGiAddr[2] << 8) + 
                                PXEClient->Mode->ProxyOffer.Dhcpv4.BootpGiAddr[3];
    }

    memcpy( NetLocalHardwareAddress, PXEClient->Mode->ProxyOffer.Dhcpv4.BootpHwAddr, sizeof(NetLocalHardwareAddress) );

    //
    // Get the path where we were launched from.  We what to remove the
    // actual file name (oschoice.efi in this case), but leave that trailing
    // '\'.
    //
    strncpy( NetBootPath, (PCHAR)PXEClient->Mode->ProxyOffer.Dhcpv4.BootpBootFile, sizeof(NetBootPath) );
    NetBootPath[sizeof(NetBootPath)-1] = '\0';
    p = (PUCHAR)strrchr( NetBootPath, '\\' );
    if( p ) {
        p++;
        *p = '\0';
    } else {
        NetBootPath[0] = '\0'; // no path
    }
    
    return ESUCCESS;

}

VOID
EfiNetTerminate(
    VOID
    )
{
    FlipToPhysical();

    PXEClient->Stop( PXEClient );

    FlipToVirtual();
}


ARC_STATUS
GetGuid(
    OUT PUCHAR *Guid,
    OUT PULONG GuidLength
    )

/*++

Routine Description:

    This routine returns the Guid of this machine.

Arguments:

    Guid - Place to store pointer to the guid.

    GuidLength - Place to store the length in bytes of the guid.

Return Value:

    ARC code indicating outcome.

--*/

{
PSMBIOS_SYSTEM_INFORMATION_STRUCT SystemInfoHeader = NULL;

    *Guid = NULL;
    *GuidLength = 0;

    SystemInfoHeader = (PSMBIOS_SYSTEM_INFORMATION_STRUCT)FindSMBIOSTable( SMBIOS_SYSTEM_INFORMATION );

    if( SystemInfoHeader ) {

        *Guid = (PUCHAR)BlAllocateHeap( SYSID_UUID_DATA_SIZE );
        if( *Guid ) {
            *GuidLength = SYSID_UUID_DATA_SIZE;
            
            RtlCopyMemory( *Guid,
                           SystemInfoHeader->Uuid,
                           SYSID_UUID_DATA_SIZE );

            return ESUCCESS;
        } else {
            if(BdDebuggerEnabled) { DbgPrint( "GetGuid: Failed Alloc.\r\n" ); }
            *GuidLength = 0;

            return ENOMEM;
        }

    } else {
        if(BdDebuggerEnabled) { DbgPrint( "GetGuid: Failed to find a SMBIOS_SYSTEM_INFORMATION table.\n" ); }
    }

    return ENODEV;
}


ULONG
CalculateChecksum(
    IN PLONG Block,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine calculates a simple two's-complement checksum of a block of
    memory. If the returned value is stored in the block (in a word that was
    zero during the calculation), then new checksum of the block will be zero.

Arguments:

    Block - Address of a block of data. Must be 4-byte aligned.

    Length - Length of the block. Must be a multiple of 4.

Return Value:

    ULONG - Two's complement additive checksum of the input block.

--*/

{
    LONG checksum = 0;

    ASSERT( ((ULONG_PTR)Block & 3) == 0 );
    ASSERT( (Length & 3) == 0 );

    for ( ; Length != 0; Length -= 4 ) {
        checksum += *Block;
        Block++;
    }

    return -checksum;
}


















UINTN
DevicePathSize (
    IN EFI_DEVICE_PATH  *DevPath
    )
{
    EFI_DEVICE_PATH     *Start;

    /* 
     *  Search for the end of the device path structure
     *      */

    Start = DevPath;
    while (!IsDevicePathEnd(DevPath)) {
        DevPath = NextDevicePathNode(DevPath);
    }

    /* 
     *  Compute the size
     */

    return ((UINTN) DevPath - (UINTN) Start) + sizeof(EFI_DEVICE_PATH);
}

EFI_DEVICE_PATH *
DevicePathInstance (
    IN OUT EFI_DEVICE_PATH  **DevicePath,
    OUT UINTN               *Size
    )
{
    EFI_DEVICE_PATH         *Start, *Next, *DevPath;
    UINTN                   Count;

    DevPath = *DevicePath;
    Start = DevPath;

    if (!DevPath) {
        return NULL;
    }

    /* 
     *  Check for end of device path type
     *      */

    for (Count = 0; ; Count++) {
        Next = NextDevicePathNode(DevPath);

        if (IsDevicePathEndType(DevPath)) {
            break;
        }

        if (Count > 01000) {
            break;
        }

        DevPath = Next;
    }

    ASSERT (DevicePathSubType(DevPath) == END_ENTIRE_DEVICE_PATH_SUBTYPE ||
            DevicePathSubType(DevPath) == END_INSTANCE_DEVICE_PATH_SUBTYPE);

    /* 
     *  Set next position
     */

    if (DevicePathSubType(DevPath) == END_ENTIRE_DEVICE_PATH_SUBTYPE) {
        Next = NULL;
    }

    *DevicePath = Next;

    /* 
     *  Return size and start of device path instance
     */

    *Size = ((UINT8 *) DevPath) - ((UINT8 *) Start);
    return Start;
}

UINTN
DevicePathInstanceCount (
    IN EFI_DEVICE_PATH      *DevicePath
    )
{
    UINTN       Count, Size;

    Count = 0;
    while (DevicePathInstance(&DevicePath, &Size)) {
        Count += 1;
    }

    return Count;
}

EFI_DEVICE_PATH *
AppendDevicePath (
    IN EFI_DEVICE_PATH  *Src1,
    IN EFI_DEVICE_PATH  *Src2
    )
/*  Src1 may have multiple "instances" and each instance is appended
 *  Src2 is appended to each instance is Src1.  (E.g., it's possible
 *  to append a new instance to the complete device path by passing 
 *  it in Src2) */
{
    UINTN               Src1Size, Src1Inst, Src2Size, Size;
    EFI_DEVICE_PATH     *Dst, *Inst;
    UINT8               *DstPos;
    EFI_DEVICE_PATH     EndInstanceDevicePath[] = { END_DEVICE_PATH_TYPE,
                                                    END_INSTANCE_DEVICE_PATH_SUBTYPE,
                                                    END_DEVICE_PATH_LENGTH,
                                                    0 };

    EFI_DEVICE_PATH     EndDevicePath[] = { END_DEVICE_PATH_TYPE,
                                            END_ENTIRE_DEVICE_PATH_SUBTYPE,
                                            END_DEVICE_PATH_LENGTH,
                                            0 };

    Src1Size = DevicePathSize(Src1);
    Src1Inst = DevicePathInstanceCount(Src1);
    Src2Size = DevicePathSize(Src2);
    Size = Src1Size * Src1Inst + Src2Size;
    

    EfiAllocateAndZeroMemory( EfiLoaderData,
                              Size,
                              (VOID **) &Dst );

    if (Dst) {
        DstPos = (UINT8 *) Dst;

        /* 
         *  Copy all device path instances
         */

        while ((Inst = DevicePathInstance (&Src1, &Size)) != 0) {

            RtlCopyMemory(DstPos, Inst, Size);
            DstPos += Size;

            RtlCopyMemory(DstPos, Src2, Src2Size);
            DstPos += Src2Size;

            RtlCopyMemory(DstPos, EndInstanceDevicePath, sizeof(EFI_DEVICE_PATH));
            DstPos += sizeof(EFI_DEVICE_PATH);
        }

        /*  Change last end marker */
        DstPos -= sizeof(EFI_DEVICE_PATH);
        RtlCopyMemory(DstPos, EndDevicePath, sizeof(EFI_DEVICE_PATH));
    }

    return Dst;
}

NTSTATUS
NetSoftReboot(
    IN PUCHAR NextBootFile,
    IN ULONGLONG Param,
    IN PUCHAR RebootFile OPTIONAL,
    IN PUCHAR SifFile OPTIONAL,
    IN PUCHAR User OPTIONAL,
    IN PUCHAR Domain OPTIONAL,
    IN PUCHAR Password OPTIONAL,
    IN PUCHAR AdministratorPassword OPTIONAL
    )

/*++

Routine Description:

    This routine will load the specified file, build a parameter
    list and transfer control to the loaded file.

Arguments:

    NextBootFile - Fully qualified path name of the file to download.

    Param - Reboot parameter to set.

    RebootFile - String identifying the file to reboot to when after the current reboot is done.

    SifFile - Optional SIF file to pass to the next loader.

    User/Domain/Password/AdministratorPassword - Optional credentials to pass to the next loader.

Return Value:

    Should not return if successful.

--*/

{

    NTSTATUS                Status = STATUS_SUCCESS;
    EFI_DEVICE_PATH         *ldrDevicePath = NULL, *Eop = NULL;
    EFI_HANDLE              ImageHandle = NULL;
    UINTN                   i = 0;
    EFI_STATUS              EfiStatus = EFI_SUCCESS;
    WCHAR                   WideNextBootFile[MAX_PATH];
    FILEPATH_DEVICE_PATH    *FilePath = NULL;
    UNICODE_STRING          uString;
    ANSI_STRING             aString;
    EFI_LOADED_IMAGE        *OriginalEfiImageInfo = NULL;
    EFI_LOADED_IMAGE        *LoadedEfiImageInfo = NULL;
    EFI_DEVICE_PATH         *OriginalEfiDevicePath = NULL;
    PTFTP_RESTART_BLOCK     restartBlock = NULL;
    PTFTP_RESTART_BLOCK_V1  restartBlockV1 = NULL;

    ULONG                   BootFileId = 0;
    PUCHAR                  LoadedImageAddress = NULL;
    ULONG                   LoadedImageSize = 0;


    //
    // Load the file we want to boot into memory.
    //
    Status = BlOpen( NET_DEVICE_ID,
                     (PCHAR)NextBootFile,
                     ArcOpenReadOnly,
                     &BootFileId );
    if (Status != ESUCCESS) {
        return Status;
    }

    //
    // What memory address did he get loaded into?
    //
    // make sure we have the physical address 
    //
    LoadedImageAddress = (PUCHAR)((ULONGLONG)(BlFileTable[BootFileId].u.NetFileContext.InMemoryCopy) & ~KSEG0_BASE);
    LoadedImageSize = BlFileTable[BootFileId].u.NetFileContext.FileSize;


    //
    // BUild a device path to the target file.  We'll do this by gathering
    // some information about ourselves, knowing that we're about to load/launch
    // an image from the server, just like where we came from.
    //

    //
    // Get image information on ourselves.
    //
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->HandleProtocol( EfiImageHandle,
                                                     &EfiLoadedImageProtocol,
                                                     &OriginalEfiImageInfo );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: HandleProtocol_1 failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Get our DevicePath too.
    //
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->HandleProtocol( OriginalEfiImageInfo->DeviceHandle,
                                                     &EfiDevicePathProtocol,
                                                     &OriginalEfiDevicePath );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: HandleProtocol_2 failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Now build a device path based on the DeviceHandle of ourselves, along
    // with the path to the image we want to load.
    //
    RtlInitString( &aString, (PCHAR)NextBootFile );
    uString.MaximumLength = MAX_PATH;
    uString.Buffer = WideNextBootFile;
    RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );

    i = wcslen(uString.Buffer);


    EfiStatus = EfiAllocateAndZeroMemory( EfiLoaderData,
                                          i + sizeof(FILEPATH_DEVICE_PATH) + sizeof(EFI_DEVICE_PATH),
                                          (VOID **) &FilePath );

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: AllocatePool_1 failed (%d)\n", EfiStatus );
        }
        return STATUS_NO_MEMORY;
    }


    FilePath->Header.Type = MEDIA_DEVICE_PATH;
    FilePath->Header.SubType = MEDIA_FILEPATH_DP;
    SetDevicePathNodeLength (&FilePath->Header, i + sizeof(FILEPATH_DEVICE_PATH));
    RtlCopyMemory (FilePath->PathName, uString.Buffer, i);

    FlipToPhysical();
    Eop = NextDevicePathNode(&FilePath->Header);
    SetDevicePathEndNode(Eop);

    // 
    //  Append file path to device's device path
    //
    ldrDevicePath = (EFI_DEVICE_PATH *)FilePath;
    ldrDevicePath = AppendDevicePath ( OriginalEfiDevicePath,
                                       ldrDevicePath );
    FlipToVirtual();


    //
    // Load the image, then set its loadoptions in preparation
    // for launching it.
    //
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: About to LoadImage.\n" );
    }
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->LoadImage( FALSE,
                                                EfiImageHandle,
                                                ldrDevicePath,
                                                LoadedImageAddress,
                                                LoadedImageSize,
                                                &ImageHandle );
    FlipToVirtual();


    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: LoadImage failed (%d)\n", EfiStatus );
        }
        return STATUS_NO_MEMORY;

    } else {
        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: LoadImage worked (%d)\n", EfiStatus );
        }
    }



    //
    // allocate a chunk of memory, then load it up w/ all the boot options.
    //
    EfiStatus = EfiAllocateAndZeroMemory( EfiLoaderData,
                                          sizeof(TFTP_RESTART_BLOCK),
                                          (VOID **) &restartBlock );

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: Failed to allocate memory for restartBlock (%d)\n", EfiStatus );
        }
        return STATUS_NO_MEMORY;
    }

    restartBlockV1 = (PTFTP_RESTART_BLOCK_V1)(&restartBlock->RestartBlockV1);

    //
    // There's no need to pass the headless settings through the restart block.
    // The only way to get headless settings on EFI is to get them from firmware
    // and we'll be checking for formware settings when we reboot back into
    // setupldr anyway.  -matth (2/2002)
    //
    // BlSetHeadlessRestartBlock(restartBlock);

    if (AdministratorPassword) {
        RtlMoveMemory(restartBlock->AdministratorPassword,AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);        
    }

    restartBlockV1->RebootParameter = Param;

    if (RebootFile != NULL) {
        strncpy(restartBlockV1->RebootFile, (PCHAR)RebootFile, sizeof(restartBlockV1->RebootFile));
        restartBlockV1->RebootFile[sizeof(restartBlockV1->RebootFile)-1] = '\0';
    }

    if (SifFile != NULL) {
        strncpy(restartBlockV1->SifFile, (PCHAR)SifFile, sizeof(restartBlockV1->SifFile));
        restartBlockV1->SifFile[sizeof(restartBlockV1->SifFile)-1] = '\0';
    }

    if (User != NULL) {
        strncpy(restartBlockV1->User, (PCHAR)User, sizeof(restartBlockV1->User));
        restartBlockV1->User[sizeof(restartBlockV1->User)-1] = '\0';
    }
    if (Domain != NULL) {
        strncpy(restartBlockV1->Domain, (PCHAR)Domain, sizeof(restartBlockV1->Domain));
        restartBlockV1->Domain[sizeof(restartBlockV1->Domain)-1] = '\0';
    }
    if (Password != NULL) {
        strncpy(restartBlockV1->Password, (PCHAR)Password, sizeof(restartBlockV1->Password));
        restartBlockV1->Password[sizeof(restartBlockV1->Password)-1] = '\0';
    }

    //
    // Set the tag in the restart block and calculate and store the checksum.
    //
    restartBlockV1->Tag = 'rtsR';
    restartBlockV1->Checksum = CalculateChecksum((PLONG)(restartBlockV1), 128);

    //
    // For all versions of RIS after NT5.0 we have a new datastructure which is
    // more adaptable for the future.  For this section we have a different checksum,
    // do that now.
    //
    restartBlock->TftpRestartBlockVersion = TFTP_RESTART_BLOCK_VERSION;
    restartBlock->NewCheckSumLength = sizeof(TFTP_RESTART_BLOCK);
    restartBlock->NewCheckSum = CalculateChecksum((PLONG)restartBlock,
                                                  restartBlock->NewCheckSumLength);

    

    //
    // We've got the command-line options all setup.  Now we need to
    // actually put them into ImageInfo->LoadOptions so they get
    // passed to the loaded image.
    //
    
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: About to EfiLoadedImageProtocol on the loadedImage.\n" );
    }
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->HandleProtocol( ImageHandle,
                                                     &EfiLoadedImageProtocol,
                                                     &LoadedEfiImageInfo );
    FlipToVirtual();

    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: HandleProtocol_3 failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    LoadedEfiImageInfo->LoadOptions = (PVOID)restartBlock;
    LoadedEfiImageInfo->LoadOptionsSize = sizeof(TFTP_RESTART_BLOCK);
#if DBG
    EfiDumpBuffer(LoadedEfiImageInfo->LoadOptions, sizeof(TFTP_RESTART_BLOCK));
#endif


    //
    // Since we loaded the image from a memory buffer, he's not
    // going to have a DeviceHandle set.  We'll fail quickly when
    // setupldr.efi starts.  We can just set it right here, and
    // we know exactly what it is because it's the same as the
    // network device handle for Oschoice.efi, wich we have
    // readily available.
    //
    LoadedEfiImageInfo->DeviceHandle = OriginalEfiImageInfo->DeviceHandle;
    LoadedEfiImageInfo->FilePath = ldrDevicePath;
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: LoadedEfiImageInfo->DeviceHandle: 0x%08lx\n", PtrToUlong(LoadedEfiImageInfo->DeviceHandle) );
        DbgPrint( "NetSoftReboot: LoadedEfiImageInfo->FilePath: 0x%08lx\n", PtrToUlong(LoadedEfiImageInfo->FilePath) );
    }

    //
    // We shouldn't return from this call!
    //
    if( BdDebuggerEnabled ) {
        DbgPrint( "NetSoftReboot: StartImage.\n" );
    }
    FlipToPhysical();
    EfiStatus = EfiST->BootServices->StartImage( ImageHandle,
                                                 0,
                                                 NULL );
    FlipToVirtual();



    if( EFI_ERROR(EfiStatus) ) {

        if( BdDebuggerEnabled ) {
            DbgPrint( "NetSoftReboot: StartImage failed (%d)\n", EfiStatus );
        }
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;

}

VOID
NetGetRebootParameters(
    OUT PULONGLONG Param OPTIONAL,
    OUT PUCHAR RebootFile OPTIONAL,
    OUT PUCHAR SifFile OPTIONAL,
    OUT PUCHAR User OPTIONAL,
    OUT PUCHAR Domain OPTIONAL,
    OUT PUCHAR Password OPTIONAL,
    OUT PUCHAR AdministratorPassword OPTIONAL,
    BOOLEAN ClearRestartBlock
    )

/*++

Routine Description:

    This routine reads the reboot parameters from the global TFTP_RESTART_BLOCK
    and returns them.

Arguments:

    Param - Space for returning the value.

    RebootFile - Optional space for storing the file to reboot to when done here. (size >= char[128])

    SifFile - Optional space for storing a SIF file passed from whoever
        initiated the soft reboot.

    User/Domain/Password/AdministratorPassword - Optional space to store credentials passed across
        the soft reboot.

    ClearRestartBlock - If set to TRUE, it wipes out the memory here - should be done exactly once, at the
        last call to this function.

Return Value:

    None.

--*/

{
BOOLEAN     restartBlockValid = FALSE;

#if DBG
    EfiDumpBuffer(&gTFTPRestartBlock, sizeof(TFTP_RESTART_BLOCK));
#endif

    //
    // See if the block is valid. If it's not, we create a temporary empty
    // one so the copy logic below doesn't have to keep checking.
    //
    if ((gTFTPRestartBlock.RestartBlockV1.Tag == 'rtsR') &&
        (CalculateChecksum((PLONG)(&gTFTPRestartBlock.RestartBlockV1), 128) == 0)) {
        restartBlockValid = TRUE;
    }


    //
    // Copy out the parameters that were in the original TFTP_RESTART_BLOCK structure.
    // These shipped in Win2K.
    //
    //
    // Unfortunetly we do not know the size of the parameters passed to us.
    // Assume they are no smaller than the fields in the restart block
    //
    if (Param != NULL) {
        *Param = gTFTPRestartBlock.RestartBlockV1.RebootParameter;
    }

    if (RebootFile != NULL) {
        memcpy(RebootFile, gTFTPRestartBlock.RestartBlockV1.RebootFile, sizeof(gTFTPRestartBlock.RestartBlockV1.RebootFile));
    }

    if (SifFile != NULL) {
        memcpy(SifFile, gTFTPRestartBlock.RestartBlockV1.SifFile, sizeof(gTFTPRestartBlock.RestartBlockV1.SifFile));
    }

    if (User != NULL) {
        strncpy((PCHAR)User, gTFTPRestartBlock.RestartBlockV1.User, sizeof(gTFTPRestartBlock.RestartBlockV1.User));
        User[sizeof(gTFTPRestartBlock.RestartBlockV1.User)-1] = '\0';
    }
    if (Domain != NULL) {
        strncpy((PCHAR)Domain, gTFTPRestartBlock.RestartBlockV1.Domain,sizeof(gTFTPRestartBlock.RestartBlockV1.Domain));
        Domain[sizeof(gTFTPRestartBlock.RestartBlockV1.Domain)-1] = '\0';
    }
    if (Password != NULL) {
        strncpy((PCHAR)Password, gTFTPRestartBlock.RestartBlockV1.Password, sizeof(gTFTPRestartBlock.RestartBlockV1.Password));
        Password[sizeof(gTFTPRestartBlock.RestartBlockV1.Password)-1] = '\0';
    }

    //
    // Now do a new check for all versions past Win2K
    //
    if (restartBlockValid) {

        if ((gTFTPRestartBlock.NewCheckSumLength == 0) ||
            (CalculateChecksum((PLONG)(&gTFTPRestartBlock), gTFTPRestartBlock.NewCheckSumLength) != 0)) {

            //
            // A pre-Win2K OsChooser has given us this block.  Clear out all fields
            // that are post-Win2K and continue.
            //
            RtlZeroMemory( &gTFTPRestartBlock, sizeof(TFTP_RESTART_BLOCK) );

        }

    }

    //
    // Now extract the parameters from the block.
    //
    if (gTFTPRestartBlock.TftpRestartBlockVersion == TFTP_RESTART_BLOCK_VERSION) {
        // 
        // Don't load these here.  Rather get the headless settings from firmware.
        // -matth (2/2002)
        //
        // BlGetHeadlessRestartBlock(&gTFTPRestartBlock, restartBlockValid);

        if (AdministratorPassword) {
            RtlMoveMemory(AdministratorPassword,gTFTPRestartBlock.AdministratorPassword, OSC_ADMIN_PASSWORD_LEN);
        }
    }    

    if (restartBlockValid && ClearRestartBlock) {
        RtlZeroMemory(&gTFTPRestartBlock, sizeof(TFTP_RESTART_BLOCK));
    }

#if DBG
    BlPrint(TEXT("Done getting TFTP_RESTART_BLOCK.\r\n"));
#endif

    return;
}


ARC_STATUS
NetFillNetworkLoaderBlock (
    PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    )
{
    EFI_STATUS Status;
    ARC_STATUS ArcStatus;
    
    //
    // get a pointer to the PXE client code.
    //
    Status = EfiGetPxeClient();        

    if (Status != EFI_SUCCESS) {
        ArcStatus = EIO;
        goto cleanup;
    }

    //
    // save off the DHCPServerACK packet
    //
    NetworkLoaderBlock->DHCPServerACK = BlAllocateHeap(sizeof(EFI_PXE_BASE_CODE_PACKET));
    if (NetworkLoaderBlock->DHCPServerACK == NULL) {
        ArcStatus = ENOMEM;
        goto cleanup;
    }

    memcpy( 
        NetworkLoaderBlock->DHCPServerACK, 
        &PXEClient->Mode->DhcpAck, 
        sizeof(EFI_PXE_BASE_CODE_PACKET) );

    NetworkLoaderBlock->DHCPServerACKLength = sizeof(EFI_PXE_BASE_CODE_PACKET);

    //
    // save off the BINL reply packet
    //
    NetworkLoaderBlock->BootServerReplyPacket = BlAllocateHeap(sizeof(EFI_PXE_BASE_CODE_PACKET));
    if (NetworkLoaderBlock->BootServerReplyPacket == NULL) {
        ArcStatus = ENOMEM;
        goto cleanup;
    }

    memcpy( 
        NetworkLoaderBlock->BootServerReplyPacket, 
        &PXEClient->Mode->ProxyOffer,
        sizeof(EFI_PXE_BASE_CODE_PACKET) );
    NetworkLoaderBlock->BootServerReplyPacketLength = sizeof(EFI_PXE_BASE_CODE_PACKET);
    
    //
    // we succeeded, mark success
    //
    ArcStatus = ESUCCESS;

cleanup:
    return(ArcStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This modules implements com port code to support reading/writing from com ports.

Author:

    Allen M. Kay (allen.m.kay@intel.com) 27-Jan-2000

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ntverp.h"
#include "efi.h"
#include "efip.h"
#include "bldria64.h"
#include "acpitabl.h"
#include "netboot.h"
#include "extern.h"


#if DBG

extern EFI_SYSTEM_TABLE        *EfiST;
#define DBG_TRACE(_X)                                         \
  {                                                           \
      if (IsPsrDtOn()) {                                      \
          FlipToPhysical();                                   \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
          FlipToVirtual();                                    \
      }                                                       \
      else {                                                  \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
      }                                                       \
  }

#else

#define DBG_TRACE(_X) 

#endif // for FORCE_CD_BOOT




//
// Headless boot defines
//
ULONG BlTerminalDeviceId = 0;
BOOLEAN BlTerminalConnected = FALSE;
ULONG   BlTerminalDelay = 0;

HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;

//
// Define COM Port registers.
//
#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

//
// Define Serial IO Protocol
//
EFI_GUID EfiSerialIoProtocol = SERIAL_IO_PROTOCOL;
SERIAL_IO_INTERFACE *SerialIoInterface;


#if defined(ENABLE_LOADER_DEBUG)
    //
    // jamschw: added support to allow user to specify
    // the debuggers device path by setting a nvram
    // variable.  There is no clear way to map a 
    // port number or port address to a device path 
    // and vice versa.  The current code attempts to
    // use the ACPI device node UID field, but this
    // only works on a few machines.  The UID does 
    // not need to map to the port number/address.
    //
    // This change provides to the user the ability
    // to use the boot debugger even
    // if he/she has a machine whose UID does not 
    // map to the port number/address.  The user
    // needs to set the nvram variable for 
    // DebuggerDevicePath to the device path string
    // for the uart he/she wishes to debug on. ie.)
    // set DebuggerDevicePath "/ACPI(PNP0501,10000)/UART(9600 N81)"
    // from the EFI Shell
    // 
    // since it is late in the developement cycle, all
    // this code will only compile for the debug
    // loader.  but since this is the only
    // time BlPortInitialize is called, the 
    // #if defined(ENABLE_LOADER_DEBUG)'s in this file
    // can eventually be removed
    //

#define SHELL_ENVIRONMENT_VARIABLE     \
    { 0x47C7B224, 0xC42A, 0x11D2, 0x8E, 0x57, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x3B }
EFI_GUID EfiShellVariable = SHELL_ENVIRONMENT_VARIABLE;

#endif



//
// Define debugger port initial state.
//
typedef struct _CPPORT {
    PUCHAR Address;
    ULONG Baud;
    USHORT Flags;
} CPPORT, *PCPPORT;

#define PORT_DEFAULTRATE    0x0001      // baud rate not specified, using default
#define PORT_MODEMCONTROL   0x0002      // using modem controls

CPPORT Port[4] = {
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE},
                  {NULL, 0, PORT_DEFAULTRATE}
                 };



//
// This is how we find table information from
// the ACPI table index.
//
extern PDESCRIPTION_HEADER
BlFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    );



LOGICAL
BlRetrieveBIOSRedirectionInformation(
    VOID
    )

/*++

Routine Description:

    This functions retrieves the COM port information from the ACPI
    table.

Arguments:

    We'll be filling in the LoaderRedirectionInformation structure.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PSERIAL_PORT_REDIRECTION_TABLE pPortTable = NULL;
    LOGICAL             ReturnValue = FALSE;
    LOGICAL             FoundIt = FALSE;
    EFI_DEVICE_PATH     *DevicePath = NULL;
    EFI_DEVICE_PATH     *RootDevicePath = NULL;
    EFI_DEVICE_PATH     *StartOfDevicePath = NULL;
    EFI_STATUS          Status = EFI_UNSUPPORTED;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    UART_DEVICE_PATH    *UartDevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    UINTN               reqd;
    EFI_GUID EfiGlobalVariable  = EFI_GLOBAL_VARIABLE;
    PUCHAR              CurrentAddress = NULL;
    UCHAR               Checksum;
    ULONG               i;
    ULONG               CheckLength;



    pPortTable = (PSERIAL_PORT_REDIRECTION_TABLE)BlFindACPITable( "SPCR",
                                                                  sizeof(SERIAL_PORT_REDIRECTION_TABLE) );

    if( pPortTable ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: Found an SPCR table\r\n");

        //
        // generate a checksum for later validation.
        //
        CurrentAddress = (PUCHAR)pPortTable;
        CheckLength = pPortTable->Header.Length;
        Checksum = 0;
        for( i = 0; i < CheckLength; i++ ) {
            Checksum = Checksum + CurrentAddress[i];
        }


        if(
                                                // checksum is okay?
            (Checksum == 0) &&

                                                // device address defined?
            ((UCHAR UNALIGNED *)pPortTable->BaseAddress.Address.QuadPart != (UCHAR *)NULL) &&

                                                // he better be in system or memory I/O
                                                // note: 0 - systemI/O
                                                //       1 - memory mapped I/O
            ((pPortTable->BaseAddress.AddressSpaceID == 0) ||
             (pPortTable->BaseAddress.AddressSpaceID == 1))

         ) {

            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: SPCR checksum'd and everything looks good.\r\n");

            if( pPortTable->BaseAddress.AddressSpaceID == 0 ) {
                LoaderRedirectionInformation.IsMMIODevice = TRUE;
            } else {
                LoaderRedirectionInformation.IsMMIODevice = FALSE;
            }


            //
            // We got the table.  Now dig out the information we want.
            // See definitiion of SERIAL_PORT_REDIRECTION_TABLE (acpitabl.h)
            //
            LoaderRedirectionInformation.UsedBiosSettings = TRUE;
            LoaderRedirectionInformation.PortNumber = 3;
            LoaderRedirectionInformation.PortAddress = (UCHAR UNALIGNED *)(pPortTable->BaseAddress.Address.QuadPart);

            if( pPortTable->BaudRate == 7 ) {
                LoaderRedirectionInformation.BaudRate = BD_115200;
            } else if( pPortTable->BaudRate == 6 ) {
                LoaderRedirectionInformation.BaudRate = BD_57600;
            } else if( pPortTable->BaudRate == 4 ) {
                LoaderRedirectionInformation.BaudRate = BD_19200;
            } else {
                LoaderRedirectionInformation.BaudRate = BD_9600;
            }

            LoaderRedirectionInformation.Parity = pPortTable->Parity;
            LoaderRedirectionInformation.StopBits = pPortTable->StopBits;
            LoaderRedirectionInformation.TerminalType = pPortTable->TerminalType;

            
            //
            // If this is a new SERIAL_PORT_REDIRECTION_TABLE, then it's got the PCI device
            // information.
            //
            if( pPortTable->Header.Length >= sizeof(SERIAL_PORT_REDIRECTION_TABLE) ) {

                LoaderRedirectionInformation.PciDeviceId = *((USHORT UNALIGNED *)(&pPortTable->PciDeviceId));
                LoaderRedirectionInformation.PciVendorId = *((USHORT UNALIGNED *)(&pPortTable->PciVendorId));
                LoaderRedirectionInformation.PciBusNumber = (UCHAR)pPortTable->PciBusNumber;
                LoaderRedirectionInformation.PciSlotNumber = (UCHAR)pPortTable->PciSlotNumber;
                LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)pPortTable->PciFunctionNumber;
                LoaderRedirectionInformation.PciFlags = *((ULONG UNALIGNED *)(&pPortTable->PciFlags));
            } else {

                //
                // There's no PCI device information in this table.
                //
                LoaderRedirectionInformation.PciDeviceId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciVendorId = (USHORT)0xFFFF;
                LoaderRedirectionInformation.PciBusNumber = 0;
                LoaderRedirectionInformation.PciSlotNumber = 0;
                LoaderRedirectionInformation.PciFunctionNumber = 0;
                LoaderRedirectionInformation.PciFlags = 0;
            }

            return TRUE;

        }

    }


    //
    // We didn't get anything from the ACPI table.  Look
    // for the ConsoleOutHandle and see if someone configured
    // the EFI firmware to redirect.  If so, we can pickup
    // those settings and carry them forward.
    //


    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: didn't find SPCR table\r\n");


    FoundIt = FALSE;
    //
    // Get the CONSOLE Device Paths.
    //
    
    reqd = 0;
    Status = EfiST->RuntimeServices->GetVariable(
                                        L"ConOut",
                                        &EfiGlobalVariable,
                                        NULL,
                                        &reqd,
                                        NULL );

    if( Status == EFI_BUFFER_TOO_SMALL ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: GetVariable(ConOut) success\r\n");


#ifndef  DONT_USE_EFI_MEMORY
        Status = EfiAllocateAndZeroMemory( EfiLoaderData,
                                           reqd,
                                           (VOID **) &StartOfDevicePath);
        
        if( Status != EFI_SUCCESS ) {
            DBG_TRACE( L"BlRetreiveBIOSRedirectionInformation: Failed to allocate pool.\r\n" );
            StartOfDevicePath = NULL;
        }

#else
        //
        // go back to virtual mode to allocate some memory
        //
        FlipToVirtual();
        StartOfDevicePath = BlAllocateHeapAligned( (ULONG)reqd );

        if( StartOfDevicePath ) {
            //
            // convert the address into a physical address
            //
            StartOfDevicePath = (EFI_DEVICE_PATH *) ((ULONGLONG)StartOfDevicePath & ~KSEG0_BASE);
        }

        //
        // go back into physical mode
        // 
        FlipToPhysical();
#endif

        if (StartOfDevicePath) {
            
            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: allocated pool for variable\r\n");

            Status = EfiST->RuntimeServices->GetVariable(
                                                        L"ConOut",
                                                        &EfiGlobalVariable,
                                                        NULL,
                                                        &reqd,
                                                        (VOID *)StartOfDevicePath);

            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: GetVariable returned\r\n");

        } else {
            DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: Failed to allocate memory for CONOUT variable.\r\n");
            Status = EFI_OUT_OF_RESOURCES;
        }
    } else {
        DBG_TRACE( L"BlRetreiveBIOSRedirectionInformation: GetVariable failed to tell us how much memory is needed.\r\n" );
        Status = EFI_BAD_BUFFER_SIZE;
    }



    if( !EFI_ERROR(Status) ) {

        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: retrieved ConOut successfully\r\n");

        //
        // Preserve StartOfDevicePath so we can free the memory later.
        //
        DevicePath = StartOfDevicePath;

        EfiAlignDp(&DevicePathAligned,
                   DevicePath,
                   DevicePathNodeLength(DevicePath));



        //
        // Keep looking until we get to the end of the entire Device Path.
        //
        while( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                 (DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE)) &&
                (!FoundIt) ) {


            //
            // Remember the address he's holding.  This is the root
            // of this device path and we may need to look at this
            // guy again if down the path we find a UART.
            //
            RootDevicePath = DevicePath;



            //
            // Keep looking until we get to the end of this subpath.
            //
            while( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                     ((DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE) ||
                      (DevicePathAligned.DevPath.SubType == END_INSTANCE_DEVICE_PATH_SUBTYPE))) ) {


                if( (DevicePathAligned.DevPath.Type    == MESSAGING_DEVICE_PATH) &&
                    (DevicePathAligned.DevPath.SubType == MSG_UART_DP) &&
                    (FoundIt == FALSE) ) {

                    DBG_TRACE(L"BlRetrieveBIOSRedirectionInformation: found a UART\r\n");

                    //
                    // We got a UART.  Pickup the settings.
                    //
                    UartDevicePath = (UART_DEVICE_PATH *)&DevicePathAligned;
                    
                    LoaderRedirectionInformation.BaudRate = (ULONG)UartDevicePath->BaudRate;
                    LoaderRedirectionInformation.Parity = (BOOLEAN)UartDevicePath->Parity;
                    LoaderRedirectionInformation.StopBits = (UCHAR)UartDevicePath->StopBits;


                    //
                    // Fixup BaudRate if necessary.  If it's 0, then we're
                    // supposed to use the default for this h/w.  We're going
                    // to override to 9600 though.
                    //
                    if( LoaderRedirectionInformation.BaudRate == 0 ) {
                        LoaderRedirectionInformation.BaudRate = BD_9600;
                    }

                    if( LoaderRedirectionInformation.BaudRate > BD_115200 ) {
                        LoaderRedirectionInformation.BaudRate = BD_115200;
                    }

                    //
                    // Remember that we found a UART and quit searching.
                    //
                    FoundIt = TRUE;

                }

                if( (FoundIt == TRUE) && // we already found a UART, so we're on the right track.
                    (DevicePathAligned.DevPath.Type    == MESSAGING_DEVICE_PATH) &&
                    (DevicePathAligned.DevPath.SubType == MSG_VENDOR_DP) ) {

                    VENDOR_DEVICE_PATH  *VendorDevicePath = (VENDOR_DEVICE_PATH *)&DevicePathAligned;
                    EFI_GUID            PcAnsiGuid = DEVICE_PATH_MESSAGING_PC_ANSI;

                    //
                    // See if the UART is a VT100 or ANSI or whatever.
                    //
                    if( memcmp( &VendorDevicePath->Guid, &PcAnsiGuid, sizeof(EFI_GUID)) == 0 ) {
                        LoaderRedirectionInformation.TerminalType = 3;
                    } else {

                        // Default to VT100
                        LoaderRedirectionInformation.TerminalType = 0;
                    }
                }


                //
                // Get the next structure in our packed array.
                //
                DevicePath = NextDevicePathNode( DevicePath );

                EfiAlignDp(&DevicePathAligned,
                           DevicePath,
                           DevicePathNodeLength(DevicePath));
            
            }


            //
            // Do we need to keep going?  Check to make sure we're not at the
            // end of the entire packed array of device paths.
            //
            if( !((DevicePathAligned.DevPath.Type == END_DEVICE_PATH_TYPE) &&
                  (DevicePathAligned.DevPath.SubType == END_ENTIRE_DEVICE_PATH_SUBTYPE)) ) {

                //
                // Yes.  Get the next entry.
                //
                DevicePath = NextDevicePathNode( DevicePath );

                EfiAlignDp(&DevicePathAligned,
                           DevicePath,
                           DevicePathNodeLength(DevicePath));
            }

        }

    } else {
        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: failed to get CONOUT variable\r\n");
    }


    if( FoundIt ) {


        //
        // We found a UART, but we were already too far down the list
        // in the device map to get the address, which is really what
        // we're after.  Start looking at the device map again from the
        // root of the path where we found the UART.
        //
        DevicePath = RootDevicePath;


        //
        // Reset this guy so we'll know if we found a reasonable
        // ACPI_DEVICE_PATH entry.
        //
        FoundIt = FALSE;
        EfiAlignDp(&DevicePathAligned,
                   RootDevicePath,
                   DevicePathNodeLength(DevicePath));


        //
        // Keep looking until we get to the end, or until we run
        // into our UART again.
        //
        while( (DevicePathAligned.DevPath.Type != END_DEVICE_PATH_TYPE) &&
               (!FoundIt) ) {

            if( DevicePathAligned.DevPath.Type == ACPI_DEVICE_PATH ) {

                //
                // Remember the address he's holding.
                //
                AcpiDevicePath = (ACPI_HID_DEVICE_PATH *)&DevicePathAligned;

                if( AcpiDevicePath->UID ) {

                    LoaderRedirectionInformation.PortAddress = (PUCHAR)ULongToPtr(AcpiDevicePath->UID);
                    LoaderRedirectionInformation.PortNumber = 3;

                    FoundIt = TRUE;
                }
            }


            //
            // Get the next structure in our packed array.
            //
            DevicePath = NextDevicePathNode( DevicePath );

            EfiAlignDp(&DevicePathAligned,
                       DevicePath,
                       DevicePathNodeLength(DevicePath));
        }

    }


    if( FoundIt ) {
        DBG_TRACE( L"BlRetrieveBIOSRedirectionInformation: returning TRUE\r\n");

        ReturnValue = TRUE;
    }



#ifndef  DONT_USE_EFI_MEMORY
    //
    // Free the memory we allocated for StartOfDevicePath.
    //
    if( StartOfDevicePath != NULL ) {
        EfiBS->FreePool( (VOID *)StartOfDevicePath );
    }
#endif


    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();


    return( ReturnValue );

}


//
// These are the serial port EISA PNP IDs used by EFI 1.02 and EFI 1.1
// respectively.
//

#define EFI_1_02_SERIAL_PORT_EISA_HID EISA_PNP_ID(0x500)
#define EFI_1_1_SERIAL_PORT_EISA_HID  EISA_PNP_ID(0x501)

LOGICAL
BlIsSerialPortDevicePath(
    IN EFI_DEVICE_PATH *DevicePath,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress
    )

/*++

Routine Description:

    This function determines whether or not a device path matches a specific
    serial port number or serial port address.

Arguments:

    DevicePath - Supplies the EFI device path to be examined.

    PortNumber - Supplies the relevant serial port number.

    PortAddress - Supplies the relevant serial port address.

Returned Value:

    TRUE - If DevicePath specifies a serial port which matches PortAddress
           and PortNumber.

--*/

{
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    EFI_DEVICE_PATH_ALIGNED DevicePathAligned;
    UINT32 Length;


    //
    // We walk node by node through the device path until we hit
    // an end type node with an 'end entire path' subtype.
    //

    while ((DevicePath->Type & EFI_DP_TYPE_MASK) != EFI_DP_TYPE_MASK
           || DevicePath->SubType != END_ENTIRE_DEVICE_PATH_SUBTYPE) {
        Length = (((UINT32) DevicePath->Length[1]) << 8)
                 | ((UINT32) DevicePath->Length[0]);

        //
        // We're only looking for ACPI device path nodes.
        //
        if (DevicePath->Type != ACPI_DEVICE_PATH
            || DevicePath->SubType != ACPI_DP)
            goto NextIteration;

        //
        // Make sure to align the current node before accessing the four
        // byte fields in ACPI_HID_DEVICE_PATH.
        //

        EfiAlignDp(&DevicePathAligned, DevicePath,
                   DevicePathNodeLength(DevicePath));

        AcpiDevicePath = (ACPI_HID_DEVICE_PATH *) &DevicePathAligned;

        if (AcpiDevicePath->HID == EFI_1_02_SERIAL_PORT_EISA_HID) {
            //
            // In EFI 1.02 the serial port base address was stored in
            // the UID field.  Match the PortAddress against this.
            //
            DBGTRACE(L"Efi 1.02\r\n");

            if (AcpiDevicePath->UID == PtrToUlong(PortAddress))
                return TRUE;

            return FALSE;
        } else if (AcpiDevicePath->HID == EFI_1_1_SERIAL_PORT_EISA_HID) {
            //
            // In EFI 1.1 the serial port number is stored in the UID
            // field.  Match the PortNumber against this.
            //
            DBGTRACE(L"Efi 1.10\r\n");

            if (AcpiDevicePath->UID == PortNumber - 1)
                return TRUE;

            return FALSE;
        }

NextIteration:
        //
        // Increment our DevicePath pointer to the next node in the
        // path.
        //
        DevicePath = (EFI_DEVICE_PATH *) (((UINT8 *) DevicePath) + Length);
    }

    return FALSE;
}

LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    )

/*++

Routine Description:

    This functions initializes the com port.

Arguments:

    BaudRate - Supplies an optional baud rate.

    PortNumber - supplies an optinal port number.
    
    ReInitialize - Set to TRUE if we already have this port open, but for some
        reason need to completely reset the port.  Otw it should be FALSE.
    
    BlFileId - A place to store a fake file Id, if successful.

Returned Value:

    TRUE - If a debug port is found, and BlFileId will point to a location within Port[].

--*/

{
    LOGICAL Found = FALSE;

    ULONG HandleCount;
    EFI_HANDLE *SerialIoHandles;
    EFI_DEVICE_PATH *DevicePath;
    ULONG i;
    ULONG Control;
    EFI_STATUS Status;
    ARC_STATUS ArcStatus;

#if defined(ENABLE_LOADER_DEBUG)
    PWCHAR DevicePathStr;
    WCHAR DebuggerDevicePath[80];
    ULONG Size;
    BOOLEAN QueryDevicePath = FALSE;
    
    //
    // Query NVRAM to see if the user specified the EFI device
    // path for a UART to use for the debugger.
    //
    // The contents for the DebuggerDevicePath variable
    // should be quite small.  It is simply a string representing
    // the device path.  It should be much shorter than 
    // 80 characters, so use a static buffer to read this value.
    //
    Size = sizeof(DebuggerDevicePath);
    Status = EfiGetVariable(L"DebuggerDevicePath",
                            &EfiShellVariable,
                            NULL,
                            (UINTN *)&Size,
                            (VOID *)DebuggerDevicePath
                            );


    if (Status == EFI_SUCCESS) {
        //
        // convert this string to all uppercase to make the compare
        // easier
        //
        _wcsupr(DebuggerDevicePath);

        //
        // set local flag to know we succeeded
        //
        QueryDevicePath = TRUE;
    }
#endif



    ArcStatus = BlGetEfiProtocolHandles(
                                    &EfiSerialIoProtocol,
                                    &SerialIoHandles,
                                    &HandleCount
                                    );


    if (ArcStatus != ESUCCESS) {
        return FALSE;
    }

    //
    // If the baud rate is not specified, then default the baud rate to 19.2.
    //

    if (BaudRate == 0) {
        BaudRate = BD_19200;
    }


    
    //
    // If the user didn't send us a port address, then
    // guess based on the COM port number.
    //
    if( PortAddress == 0 ) {

        switch (PortNumber) {
            case 1:
                PortAddress = (PUCHAR)COM1_PORT;
                break;

            case 2:
                PortAddress = (PUCHAR)COM2_PORT;
                break;

            case 3:
                PortAddress = (PUCHAR)COM3_PORT;
                break;

            default:
                PortNumber = 4;
                PortAddress = (PUCHAR)COM4_PORT;
        }

    }
        
    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();


    //
    // Get the device path
    //
    for (i = 0; i < HandleCount; i++) {
        DBG_TRACE( L"About to HandleProtocol\r\n");
        Status = EfiBS->HandleProtocol (
                    SerialIoHandles[i],
                    &EfiDevicePathProtocol,
                    &DevicePath
                    );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"HandleProtocol failed\r\n");
            Found = FALSE;
            goto e0;
        }

#if defined(ENABLE_LOADER_DEBUG)
        // 
        // if the user specified to get the debugger device
        // path from NVRAM, use this to find a match.
        // by default, use the port number
        //
        if (QueryDevicePath) {
            DevicePathStr = _wcsupr(DevicePathToStr(DevicePath));
            
            if (_wcsicmp(DebuggerDevicePath, DevicePathStr) == 0) {
                Found = TRUE;
                break;
            }
        }
        else {
#endif
            if (PortNumber == 0) {
                Found = TRUE;
                break;
            } else if (BlIsSerialPortDevicePath(DevicePath, PortNumber,
                                                PortAddress)) {
                Found = TRUE;
                break;
            }
#if defined (ENABLE_LOADER_DEBUG)
        }
#endif
    }

    if (Found == TRUE) {
        DBG_TRACE( L"found the port device\r\n");
        //
        // Check if the port is already in use, and this is a first init.
        //
        if (!ReInitialize && (Port[PortNumber].Address != NULL)) {
            DBG_TRACE( L"found the port device but it's already in use\r\n");
            Found = FALSE;
            goto e0;
        }

        //
        // Check if someone tries to reinit a port that is not open.
        //
        if (ReInitialize && (Port[PortNumber].Address == NULL)) {
            DBG_TRACE( L"found the port device but we're reinitializing a port that hasn't been opened\r\n");
            Found = FALSE;
            goto e0;
        }

        DBG_TRACE( L"about to HandleProtocol for SerialIO\r\n");

        //
        // Get the interface for the serial IO protocol.
        //
        Status = EfiBS->HandleProtocol(SerialIoHandles[i],
                                       &EfiSerialIoProtocol,
                                       &SerialIoInterface
                                      );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"HandleProtocol for SerialIO failed\r\n");
            Found = FALSE;
            goto e0;
        }

        Status = SerialIoInterface->SetAttributes(SerialIoInterface,
                                                  BaudRate,
                                                  0,
                                                  0,
                                                  DefaultParity,
                                                  0,
                                                  DefaultStopBits
                                                 );

        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"SerialIO: SetAttributes failed\r\n");
            Found = FALSE;
            goto e0;
        }

        Control = EFI_SERIAL_DATA_TERMINAL_READY;
        Status = SerialIoInterface->SetControl(SerialIoInterface,
                                               Control
                                              );
        if (EFI_ERROR(Status)) {
            DBG_TRACE( L"SerialIO: SetControl failed\r\n");
            Found = FALSE;
            goto e0;
        }

    } else {
        DBG_TRACE( L"didn't find a port device\r\n");    
        Found = FALSE;
        goto e0;
    }


    //
    // Initialize Port[] structure.
    //
    Port[PortNumber].Address = PortAddress;
    Port[PortNumber].Baud    = BaudRate;

    *BlFileId = PortNumber;


    DBG_TRACE( L"success, we're done.\r\n");    
e0:
    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    BlFreeDescriptor( (ULONG)((ULONGLONG)SerialIoHandles >> PAGE_SHIFT) );
    
    return Found;
}

VOID
BlInitializeHeadlessPort(
    VOID
    )

/*++

Routine Description:

    Does x86-specific initialization of a dumb terminal connected to a serial port.  Currently, 
    it assumes baud rate and com port are pre-initialized, but this can be changed in the future 
    by reading the values from boot.ini or someplace.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UINTN               reqd;
    PUCHAR              TmpGuid = NULL;
    ULONG               TmpGuidSize = 0;


    if( (LoaderRedirectionInformation.PortNumber == 0) &&
        !(LoaderRedirectionInformation.PortAddress) ) {

        //
        // This means that no one has filled in the LoaderRedirectionInformation
        // structure, which means that we aren't redirecting right now.
        // See if the BIOS was redirecting.  If so, pick up those settings
        // and use them.
        //
        BlRetrieveBIOSRedirectionInformation();

        if( LoaderRedirectionInformation.PortNumber ) {


            //
            // We don't need to even bother telling anyone else in the
            // loader that we're going to need to redirect because if
            // EFI is redirecting, then the loader will be redirecting (as
            // it's just an EFI app).
            //
            BlTerminalConnected = FALSE;


            //
            // We really need to make sure there's an address associated with
            // this port and not just a port number.
            //
            if( LoaderRedirectionInformation.PortAddress == NULL ) {

                switch( LoaderRedirectionInformation.PortNumber ) {

                    case 4:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM4_PORT;
                        break;

                    case 3:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM3_PORT;
                        break;

                    case 2:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM2_PORT;
                        break;

                    case 1:
                    default:
                        LoaderRedirectionInformation.PortAddress = (PUCHAR)COM1_PORT;
                        break;
                }

            }

            //
            // Load in the machine's GUID
            //
            TmpGuid = NULL;
            reqd = 0;

            GetGuid( &TmpGuid, &TmpGuidSize );
            if( (TmpGuid != NULL) && (TmpGuidSize == sizeof(GUID)) ) {
                RtlCopyMemory( (VOID *)&LoaderRedirectionInformation.SystemGUID,
                               TmpGuid,
                               sizeof(GUID) );
            }

        } else {
            BlTerminalConnected = FALSE;
        }

    }

}

LOGICAL
BlTerminalAttached(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    This routine will attempt to discover if a terminal is attached.

Arguments:

    DeviceId - Value returned by BlPortInitialize()

Return Value:

    TRUE - Port seems to have something attached.

    FALSE - Port doesn't seem to have anything attached.

--*/

{
    UINT32 Control;
    ULONG Flags;
    EFI_STATUS Status;
    BOOLEAN ReturnValue;
 
    UNREFERENCED_PARAMETER(DeviceId);

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return FALSE;
    }

    Flags = EFI_SERIAL_DATA_SET_READY |
            EFI_SERIAL_CLEAR_TO_SEND  |
            EFI_SERIAL_CARRIER_DETECT;

    ReturnValue = (BOOLEAN)((Control & Flags) == Flags);

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    return ReturnValue;
}

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    )

/*++

Routine Description:

    This routine will fill in the areas of the restart block that are appropriate 
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.

Return Value:

    None.

--*/

{

    if( LoaderRedirectionInformation.PortNumber ) {


        RestartBlock->HeadlessUsedBiosSettings = (ULONG)LoaderRedirectionInformation.UsedBiosSettings;
        RestartBlock->HeadlessPortNumber = (ULONG)LoaderRedirectionInformation.PortNumber;
        RestartBlock->HeadlessPortAddress = (PUCHAR)LoaderRedirectionInformation.PortAddress;
        RestartBlock->HeadlessBaudRate = (ULONG)LoaderRedirectionInformation.BaudRate;
        RestartBlock->HeadlessParity = (ULONG)LoaderRedirectionInformation.Parity;
        RestartBlock->HeadlessStopBits = (ULONG)LoaderRedirectionInformation.StopBits;
        RestartBlock->HeadlessTerminalType = (ULONG)LoaderRedirectionInformation.TerminalType;

        RestartBlock->HeadlessPciDeviceId = LoaderRedirectionInformation.PciDeviceId;
        RestartBlock->HeadlessPciVendorId = LoaderRedirectionInformation.PciVendorId;
        RestartBlock->HeadlessPciBusNumber = LoaderRedirectionInformation.PciBusNumber;
        RestartBlock->HeadlessPciSlotNumber = LoaderRedirectionInformation.PciSlotNumber;
        RestartBlock->HeadlessPciFunctionNumber = LoaderRedirectionInformation.PciFunctionNumber;
        RestartBlock->HeadlessPciFlags = LoaderRedirectionInformation.PciFlags;
    }
}

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    )

/*++

Routine Description:

    This routine will get all the information from a restart block    
    for the headless server effort.

Arguments:

    RestartBlock - The magic structure for holding restart information from oschoice
        to setupldr.
        
    RestartBlockValid - Is this block valid (full of good info)?

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER( RestartBlockValid );

    LoaderRedirectionInformation.UsedBiosSettings = (BOOLEAN)RestartBlock->HeadlessUsedBiosSettings;
    LoaderRedirectionInformation.DataBits = 0;
    LoaderRedirectionInformation.StopBits = (UCHAR)RestartBlock->HeadlessStopBits;
    LoaderRedirectionInformation.Parity = (BOOLEAN)RestartBlock->HeadlessParity;
    LoaderRedirectionInformation.BaudRate = (ULONG)RestartBlock->HeadlessBaudRate;;
    LoaderRedirectionInformation.PortNumber = (ULONG)RestartBlock->HeadlessPortNumber;
    LoaderRedirectionInformation.PortAddress = (PUCHAR)RestartBlock->HeadlessPortAddress;
    LoaderRedirectionInformation.TerminalType = (UCHAR)RestartBlock->HeadlessTerminalType;

    LoaderRedirectionInformation.PciDeviceId = (USHORT)RestartBlock->HeadlessPciDeviceId;
    LoaderRedirectionInformation.PciVendorId = (USHORT)RestartBlock->HeadlessPciVendorId;
    LoaderRedirectionInformation.PciBusNumber = (UCHAR)RestartBlock->HeadlessPciBusNumber;
    LoaderRedirectionInformation.PciSlotNumber = (UCHAR)RestartBlock->HeadlessPciSlotNumber;
    LoaderRedirectionInformation.PciFunctionNumber = (UCHAR)RestartBlock->HeadlessPciFunctionNumber;
    LoaderRedirectionInformation.PciFlags = (ULONG)RestartBlock->HeadlessPciFlags;

}

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it.

Arguments:

    BlFileId - The port to read from.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.

    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    ULONGLONG BufferSize = 1;
    EFI_STATUS Status;

    UNREFERENCED_PARAMETER( BlFileId );

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->Read(SerialIoInterface,
                                     &BufferSize,
                                     Input
                                    );

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    switch (Status) {
    case EFI_SUCCESS:
        return CP_GET_SUCCESS;
    case EFI_TIMEOUT:
        return CP_GET_NODATA;
    default:
        return CP_GET_ERROR;
    }
}

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the port.

Arguments:

    BlFileId - The port to write to.

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
    ULONGLONG BufferSize = 1;
    EFI_STATUS Status;

    UNREFERENCED_PARAMETER( BlFileId );

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->Write(SerialIoInterface,
                                      &BufferSize,
                                      &Output
                                     );
    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

}

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the port and return it if one is available.

Arguments:

    BlFileId - The port to poll.

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    ULONGLONG BufferSize = 1;
    UINT32 Control;
    EFI_STATUS Status;
 
    UNREFERENCED_PARAMETER( BlFileId );

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );
    if (EFI_ERROR(Status)) {
        FlipToVirtual();
        return CP_GET_ERROR;
    }


    if (Control & EFI_SERIAL_INPUT_BUFFER_EMPTY) {
        FlipToVirtual();
        return CP_GET_NODATA;
    } else {
        Status = SerialIoInterface->Read(SerialIoInterface,
                                         &BufferSize,
                                         Input
                                        );
        FlipToVirtual();

        switch (Status) {
        case EFI_SUCCESS:
            return CP_GET_SUCCESS;
        case EFI_TIMEOUT:
            return CP_GET_NODATA;
        default:
            return CP_GET_ERROR;
        }
    }
}

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    )

/*++

Routine Description:

    Check if a byte is available

Arguments:

    BlFileId - The port to poll.

Return Value:

    CP_GET_SUCCESS is returned if a byte is ready.
    CP_GET_ERROR is returned if error encountered.
    CP_GET_NODATA is returned if timeout.

--*/

{
    EFI_STATUS Status;
    UINT32 Control;

    UNREFERENCED_PARAMETER( BlFileId );

    //
    // EFI requires all calls in physical mode.
    //
    FlipToPhysical();

    Status = SerialIoInterface->GetControl(SerialIoInterface,
                                           &Control
                                          );

    //
    // Restore the processor to virtual mode.
    //
    FlipToVirtual();

    switch (Status) {
    case EFI_SUCCESS:
        if (Control & EFI_SERIAL_INPUT_BUFFER_EMPTY)
            return CP_GET_NODATA;
        else
            return CP_GET_SUCCESS;
    case EFI_TIMEOUT:
        return CP_GET_NODATA;
    default:
        return CP_GET_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\bootfont.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    bootfint.h

Abstract:

    Header file describing the bootfont.bin file used to provide
    dbcs support during system or setup bootstrap.

Author:

    tedm 11-July-1995

Revision History:

--*/


//
// Define maximum number of dbcs lead byte ranges we support.
//
#define MAX_DBCS_RANGE  5

//
// Define signature value.
//
#define BOOTFONTBIN_SIGNATURE 0x5465644d

//
// Define structure used as a header for the bootfont.bin file.
//
typedef struct _BOOTFONTBIN_HEADER {

    //
    // Signature. Must be BOOTFONTBIN_SIGNATURE.
    //
    ULONG Signature;

    //
    // Language id of the language supported by this font.
    // This should match the language id of resources in msgs.xxx.
    //
    ULONG LanguageId;

    //
    // Number of sbcs characters and dbcs characters contained in the file.
    //
    unsigned NumSbcsChars;
    unsigned NumDbcsChars;

    //
    // Offsets within the file to the images.
    //
    unsigned SbcsOffset;
    unsigned DbcsOffset;

    //
    // Total sizes of the images.
    //
    unsigned SbcsEntriesTotalSize;
    unsigned DbcsEntriesTotalSize;

    //
    // Dbcs lead byte table. Must contain a pair of 0's to indicate the end.
    //
    UCHAR DbcsLeadTable[(MAX_DBCS_RANGE+1)*2];

    //
    // Height values for the font.
    // CharacterImageHeight is the height in scan lines/pixels of the
    // font image. Each character is drawn with additional 'padding'
    // lines on the top and bottom, whose sizes are also contained here.
    //
    UCHAR CharacterImageHeight;
    UCHAR CharacterTopPad;
    UCHAR CharacterBottomPad;

    //
    // Width values for the font. These values contain the width in pixels
    // of a single byte character and double byte character.
    //
    // NOTE: CURRENTLY THE SINGLE BYTE WIDTH *MUST* BE 8 AND THE DOUBLE BYTE
    // WIDTH *MUST* BE 16!!!
    //
    UCHAR CharacterImageSbcsWidth;
    UCHAR CharacterImageDbcsWidth;

} BOOTFONTBIN_HEADER, *PBOOTFONTBIN_HEADER;

//
// Images themselves follow.
//
// First there are SbcsCharacters entries for single-byte chars.
// The first byte in each entry is the ascii char code. The next n bytes are
// the image. n is dependent on the width and height of an sbcs char.
//
// Following these are the dbcs images. The first 2 bytes are the dbcs
// character code (highbyte lowbyte) and the next n bytes are the image.
// n is dependent on the width and height of a dbcs char.
//
// Important note: the characters must be sorted in ascending order!
//

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\bootia64.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootia64.h

Abstract:

    Header file for the Ia64 portions of the common boot library

Author:

    John Vert (jvert) 14-Oct-1993

Revision History:

    Allen Kay (akay) 26-Jan-1996          Ported to IA-64

--*/

#include "bldria64.h"
#include "..\bootlib.h"
#include "efi.h"

//
// Macro definition
//
extern EfiSt;
#define EfiPrint(_X)                                          \
  {                                                           \
      if (IsPsrDtOn()) {                                      \
          FlipToPhysical();                                   \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
          FlipToVirtual();                                    \
      }                                                       \
      else {                                                  \
          EfiST->ConOut->OutputString(EfiST->ConOut, (_X));   \
      }                                                       \
  }
  
//
// Macro for translation memory size in bytes to page size in TR format
//
#define MEM_SIZE_TO_PS(MemSize, TrPageSize)             \
                if (MemSize <= MEM_4K) {                \
                    TrPageSize = PS_4K;                 \
                } else if (MemSize <= MEM_8K)       {   \
                    TrPageSize = PS_8K;                 \
                } else if (MemSize <= MEM_16K)      {   \
                    TrPageSize = PS_16K;                \
                } else if (MemSize <= MEM_64K)      {   \
                    TrPageSize = PS_64K;                \
                } else if (MemSize <= MEM_256K)     {   \
                    TrPageSize = PS_256K;               \
                } else if (MemSize <= MEM_1M)       {   \
                    TrPageSize = PS_1M;                 \
                } else if (MemSize <= MEM_4M)       {   \
                    TrPageSize = PS_4M;                 \
                } else if (MemSize <= MEM_16M)      {   \
                    TrPageSize = PS_16M;                \
                } else if (MemSize <= MEM_64M)      {   \
                    TrPageSize = PS_64M;                \
                } else if (MemSize <= MEM_256M)     {   \
                    TrPageSize = PS_256M;               \
                }

extern PMEMORY_DESCRIPTOR MDArray;
extern ULONG             MaxDescriptors;
extern ULONG             NumberDescriptors;


VOID
InitializeMemoryDescriptors (
    VOID
    );

VOID
InsertDescriptor (
    ULONG BasePage,
    ULONG NumberOfPages,
    MEMORY_TYPE MemoryType
    );



//          B O O T   C O N T E X T   R E C O R D
//
//  Passed to the OS loader by the SU module or bootstrap
//  code, whatever the case. Constains all the basic machine
//  and environment information the OS loaders needs to get
//  itself going.
//

typedef enum {
    BootBusAtapi,
    BootBusScsi,
    BootBusVendor,
    BootBusMax
} BUS_TYPE;

typedef enum {
    BootMediaHardDisk,
    BootMediaCdrom,
    BootMediaFloppyDisk,
    BootMediaTcpip,
    BootMediaMax
} MEDIA_TYPE;

typedef struct _BOOT_DEVICE_ATAPI {
    UCHAR PrimarySecondary;
    UCHAR SlaveMaster;
    USHORT Lun;
} BOOT_DEVICE_ATAPI, *PBOOT_DEVICE_ATAPI;

typedef struct _BOOT_DEVICE_SCSI {
    UINT8 Channel;
    USHORT Pun;
    USHORT Lun;
} BOOT_DEVICE_SCSI, *PBOOT_DEVICE_SCSI;

typedef struct _BOOT_DEVICE_FLOPPY {
    ULONG DriveNumber;
} BOOT_DEVICE_FLOPPY, *PBOOT_DEVICE_FLOPPY;

typedef struct _BOOT_DEVICE_IPv4 {
    USHORT RemotePort;
    USHORT LocalPort;
    EFI_IPv4_ADDRESS Ip;
} BOOT_DEVICE_IPv4, *PBOOT_DEVICE_IPv4;

typedef struct {
    UINT64 Ip[2];
} IPv6_ADDRESS;

typedef struct _BOOT_DEVICE_IPv6 {
    USHORT RemotePort;
    USHORT LocalPort;
    IPv6_ADDRESS Ip;
} BOOT_DEVICE_IPv6, *PBOOT_DEVICE_IPv6;

typedef struct {
    ULONG Data1;
    USHORT Data2;
    USHORT Data3;
    UCHAR Data4[8];
} BOOT_EFI_GUID;

typedef struct _BOOT_DEVICE_UNKNOWN {
    BOOT_EFI_GUID Guid;
    UCHAR LegacyDriveLetter;
} BOOT_DEVICE_UNKNOWN, *PBOOT_DEVICE_UNKNOWN;

typedef union _BOOT_DEVICE {
    BOOT_DEVICE_ATAPI BootDeviceAtapi;
    BOOT_DEVICE_SCSI BootDeviceScsi;
    BOOT_DEVICE_FLOPPY BootDeviceFloppy;
    BOOT_DEVICE_IPv4 BootDeviceIpv4;
    BOOT_DEVICE_IPv6 BootDeviceIpv6;
    BOOT_DEVICE_UNKNOWN BootDeviceUnknown;
} BOOT_DEVICE, *PBOOT_DEVICE;

typedef struct _BOOT_CONTEXT {
    ULONG BusType;
    ULONG MediaType;
    ULONG PartitionNumber;
    BOOT_DEVICE BootDevice;
    PEXTERNAL_SERVICES_TABLE ExternalServicesTable;
    ULONGLONG MachineType;
    ULONGLONG OsLoaderStart;
    ULONGLONG OsLoaderEnd;
    ULONGLONG ResourceDirectory;
    ULONGLONG ResourceOffset;
    ULONGLONG OsLoaderBase;
    ULONGLONG OsLoaderExports;
    ULONGLONG BootFlags;
} BOOT_CONTEXT, *PBOOT_CONTEXT;


//
// Common function prototypes
//
VOID
InitializeDisplaySubsystem(
    VOID
    );

ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT
    );

ARC_STATUS
XferPhysicalDiskSectors(
    IN  UCHAR     Int13UnitNumber,
    IN  ULONGLONG StartSector,
    IN  UCHAR     SectorCount,
    OUT PUCHAR    Buffer,
    IN  UCHAR     SectorsPerTrack,
    IN  USHORT    Heads,
    IN  USHORT    Cylinders,
    IN  BOOLEAN   AllowExtendedInt13,
    IN  BOOLEAN   Write
    );

#define ReadPhysicalSectors(d,a,n,p,s,h,c,f)                                \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),FALSE)

#define WritePhysicalSectors(d,a,n,p,s,h,c,f)                               \
                                                                            \
            XferPhysicalDiskSectors((d),(a),(n),(p),(s),(h),(c),(f),TRUE)


ARC_STATUS
XferExtendedPhysicalDiskSectors(
    IN  ULONGLONG DeviceHandle,
    IN  ULONGLONG StartSector,
    IN  USHORT    SectorCount,
    OUT PUCHAR    Buffer,
    IN  BOOLEAN   Write
    );

#define ReadExtendedPhysicalSectors(d,a,c,p)                                \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),FALSE)

#define WriteExtendedPhysicalSectors(d,a,c,p)                               \
                                                                            \
            XferExtendedPhysicalDiskSectors((d),(a),(c),(p),TRUE)

VOID
ResetDiskSystem(
    UCHAR Int13UnitNumber
    );

VOID
MdShutoffFloppy(
    VOID
    );


BOOLEAN
FwGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    );

PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    );

PVOID
FwAllocatePool(
    IN ULONG Size
    );

PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    );

VOID
FwStallExecution(
    IN ULONG Microseconds
    );

VOID
BlGetActivePartition(
    OUT PUCHAR PartitionName
    );

VOID
BlFillInSystemParameters(
    IN PBOOT_CONTEXT BootContextRecord
    );


//
// PS/2 ABIOS module  (in abiosc.c)
//
VOID
RemapAbiosSelectors(
    VOID
    );

//
// global data definitions
//

extern ULONG MachineType;
extern PCONFIGURATION_COMPONENT_DATA FwConfigurationTree;
extern ULONG HeapUsed;
ULONG PalFreeBase;

//
// page Table definition
//

#define HYPER_SPACE_BEGIN       0xC0000000
#define HYPER_PAGE_DIR          0xC0300000

#define GetPteOffset(va) \
  ( (((ULONG)(va)) << (32-PDI_SHIFT)) >> ((32-PDI_SHIFT) + PTI_SHIFT) )

//
// X86 Detection definitions
// The size is *ALWAYS* assumed to be 64K.
// N.B.  The definition *MUST* be the same as the ones defined in
//       startup\su.inc
//

#define DETECTION_LOADED_ADDRESS 0x10000

//
//  We need to allocate permanent and temporary memory for the page directory,
//  assorted page tables, and the memory descriptors before the blmemory
//  routines ever get control.  So we have two private heaps, one for permanent
//  data and one for temporary data.  There are two descriptors for this.  The
//  permanent heap descriptor starts out as zero-length at P.A. 0x30000.  The
//  temporary heap descriptor immediately follows the permanent heap in memory
//  and starts out as 128k long.  As we allocate permanent pages, we increase
//  the size of the permanent heap descriptor and increase the base (thereby
//  decreasing the size) of the temporary heap descriptor)
//
//  So the permanent heap starts at P.A. 0x30000 and grows upwards.  The
//  temporary heap starts at P.A. 0x5C000 and grows downwards.  This gives us
//  a total of 128k of combined permanent and temporary data.
//

//
// Heap starting locations (in pages)
//

#define PERMANENT_HEAP_START (0x1010000 >> PAGE_SHIFT)
#define TEMPORARY_HEAP_START (0x1040000 >> PAGE_SHIFT)

//
// Useful Macro Definitions
//
#define ROUND_UP(Num,Size)  (((Num) + Size - 1) & ~(Size -1))

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) { \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) { \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) { \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }


//
// Global definitions for the BIOS ARC Emulation
//

//
// Defines for the ARC name of console input and output
//

#define CONSOLE_INPUT_NAME "multi(0)key(0)keyboard(0)"
#define CONSOLE_OUTPUT_NAME "multi(0)video(0)monitor(0)"

//
// Define special character values.
//

#define ASCI_NUL 0x00
#define ASCI_BEL 0x07
#define ASCI_BS  0x08
#define ASCI_HT  0x09
#define ASCI_LF  0x0A
#define ASCI_VT  0x0B
#define ASCI_FF  0x0C
#define ASCI_CR  0x0D
#define ASCI_CSI 0x9B
#define ASCI_ESC 0x1B
#define ASCI_SYSRQ 0x80




//
// Device I/O prototypes
//

ARC_STATUS
BiosPartitionClose(
    IN ULONG FileId
    );

ARC_STATUS
BiosPartitionOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosPartitionRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosPartitionSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
BiosDiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );


ARC_STATUS
BiosPartitionGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION FileInfo
    );

ARC_STATUS
BlArcNotYetImplemented(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosConsoleReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
BiosConsoleRead (
    IN ULONG FileId,
    OUT PUCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosConsoleWrite (
    IN ULONG FileId,
    OUT PWCHAR Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosDiskOpen(
    IN ULONG DriveId,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BiosDiskRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BiosElToritoDiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

BOOLEAN
BlIsElToritoCDBoot(
    UCHAR DriveNum
    );

ARC_STATUS
BiosDiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
HardDiskPartitionOpen(
    IN ULONG   FileId,
    IN ULONG   DiskId,
    IN UCHAR   PartitionNumber
    );


//
// routines that deal with creating arc memory descriptors from 
// an efi memory map
//
VOID
ConstructArcMemoryDescriptorsWithAllocation(
    ULONGLONG              LowBoundary,
    ULONGLONG              HighBoundary
    );

VOID
ConstructArcMemoryDescriptors(
    EFI_MEMORY_DESCRIPTOR *EfiMd,
    MEMORY_DESCRIPTOR     *ArcMd,
    ULONGLONG              MemoryMapSize,
    ULONGLONG              DescriptorSize,
    ULONGLONG              LowBoundary,
    ULONGLONG              HighBoundary
    );

MEMORY_TYPE
EfiToArcType (
    UINT32 Type
    );

#ifdef DBG
VOID
PrintArcMemoryDescriptorList(
    MEMORY_DESCRIPTOR *ArcMd,
    ULONG              MaxDesc
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\sumain.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1998  Intel Corporation


Module Name:

    sumain.c

Abstract:
    SuMain() sets up NT specific data structures for OsLoader.c.  This
    is necessary since we don't have the ARC firmware to do the work
    for us.  SuMain() is call by SuSetup() which is an assembly level
    routine that does IA64 specific setup.

Author:

    Allen Kay   (akay)  19-May-95

--*/

#include "bldr.h"
#include "sudata.h"
#include "sal.h"
#include "efi.h"
#include "efip.h"
#include "bootia64.h"
#include "smbios.h"

extern EFI_SYSTEM_TABLE *EfiST;

//
// External functions
//
extern VOID NtProcessStartup();
extern VOID SuFillExportTable();
extern VOID CpuSpecificWork();

extern EFI_STATUS
GetSystemConfigurationTable(
    IN EFI_GUID *TableGuid,
    IN OUT VOID **Table
    );

//
// Define export entry table.
//
PVOID ExportEntryTable[ExMaximumRoutine];

//          M E M O R Y   D E S C R I P T O R
//
// Memory Descriptor - each contiguous block of physical memory is
// described by a Memory Descriptor. The descriptors are a table, with
// the last entry having a BlockBase and BlockSize of zero.  A pointer
// to the beginning of this table is passed as part of the BootContext
// Record to the OS Loader.
//

BOOT_CONTEXT BootContext;

//
// Global EFI data
//

#define EFI_ARRAY_SIZE    100
#define EFI_PAGE_SIZE     4096
#define EFI_PAGE_SHIFT    12

#define MEM_4K         0x1000
#define MEM_8K         0x2000
#define MEM_16K        0x4000
#define MEM_64K        0x10000
#define MEM_256K       0x40000
#define MEM_1M         0x100000
#define MEM_4M         0x400000
#define MEM_16M        0x1000000
#define MEM_64M        0x4000000
#define MEM_256M       0x10000000

EFI_HANDLE               EfiImageHandle;
EFI_SYSTEM_TABLE        *EfiST;
EFI_BOOT_SERVICES       *EfiBS;
EFI_RUNTIME_SERVICES    *EfiRS;
PSST_HEADER              SalSystemTable;
PVOID                    AcpiTable;
PVOID                    SMBiosTable;

//
// EFI GUID defines
//
EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
EFI_GUID EfiDevicePathProtocol  = DEVICE_PATH_PROTOCOL;
EFI_GUID EfiDeviceIoProtocol    = DEVICE_IO_PROTOCOL;
EFI_GUID EfiBlockIoProtocol     = BLOCK_IO_PROTOCOL;
EFI_GUID EfiDiskIoProtocol  = DISK_IO_PROTOCOL;
EFI_GUID EfiFilesystemProtocol  = SIMPLE_FILE_SYSTEM_PROTOCOL;


EFI_GUID AcpiTable_Guid         = ACPI_TABLE_GUID;
EFI_GUID SmbiosTableGuid        = SMBIOS_TABLE_GUID;
EFI_GUID SalSystemTableGuid     = SAL_SYSTEM_TABLE_GUID;

//
// PAL, SAL, and IO port space data
//

TR_INFO     Pal,Sal,SalGP;

ULONGLONG   PalProcPhysical;
ULONGLONG   PalPhysicalBase = 0;
ULONGLONG   PalTrPs;

ULONGLONG   IoPortPhysicalBase;
ULONGLONG   IoPortTrPs;
ULONG       WakeupVector;

//
// Function Prototypes
//

VOID
GetPalProcEntryPoint(
    IN PSST_HEADER SalSystemTable
    );

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

#if DBG
#define DBG_TRACE(_X) EfiPrint(_X)
#else
#define DBG_TRACE(_X)
#endif

#ifdef FORCE_CD_BOOT

EFI_HANDLE
GetCd(
    );

EFI_HANDLE
GetCdTest(
    VOID
    );

#endif // for FORCE_CD_BOOT


VOID
SuMain(
    IN EFI_HANDLE          ImageHandle,
    IN EFI_SYSTEM_TABLE    *SystemTable
    )
/*++

Routine Description:

    Main entrypoint of the SU module. Control is passed from the boot
    sector to startup.asm which does some run-time fixups on the stack
    and data segments and then passes control here.

Arguments:

    None

Returns:

    Does not return. Passes control to the OS loader


--*/
{
    PIMAGE_DOS_HEADER DosHeader;
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG NumberOfSections;
    BOOLEAN ResourceFound = FALSE;

    ULONGLONG Destination;
    ULONGLONG VirtualSize;
    ULONGLONG SizeOfRawData;
    USHORT Section;

    EFI_GUID EfiLoadedImageProtocol = LOADED_IMAGE_PROTOCOL;
    EFI_LOADED_IMAGE *EfiImageInfo;
    EFI_STATUS Status;

    EFI_DEVICE_PATH *DevicePath, *TestPath;
    EFI_DEVICE_PATH_ALIGNED TestPathAligned;
    PCI_DEVICE_PATH *PciDevicePath;
    HARDDRIVE_DEVICE_PATH *HdDevicePath;
    ACPI_HID_DEVICE_PATH *AcpiDevicePath;
    ATAPI_DEVICE_PATH *AtapiDevicePath;
    SCSI_DEVICE_PATH *ScsiDevicePath;
    IPv4_DEVICE_PATH *IpV4DevicePath;
    IPv6_DEVICE_PATH *IpV6DevicePath;
    UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *UnknownDevicePath;

    ULONG i;
    
    PBOOT_DEVICE_ATAPI BootDeviceAtapi;
    PBOOT_DEVICE_SCSI BootDeviceScsi;
    PBOOT_DEVICE_FLOPPY BootDeviceFloppy;
    PBOOT_DEVICE_IPv4 BootDeviceIpV4;
    PBOOT_DEVICE_IPv6 BootDeviceIpV6;
    PBOOT_DEVICE_UNKNOWN BootDeviceUnknown;

    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PUCHAR SMBiosEPSPtr;
    UCHAR CheckSum;
    UINT8 Channel = 0;  // for SCSI boot devices - default to 0


    //
    // EFI global variables
    //
    EfiImageHandle = ImageHandle;
    EfiST = SystemTable;
    EfiBS = SystemTable->BootServices;
    EfiRS = SystemTable->RuntimeServices;

    DBG_TRACE(L"SuMain: entry\r\n");

    //
    // Get the SAL System Table
    //
    Status = GetSystemConfigurationTable(&SalSystemTableGuid, &SalSystemTable);
    if (EFI_ERROR(Status)) {
        EfiPrint(L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

#if 0
    //
    // Get the MPS Table
    //
    Status = GetSystemConfigurationTable(&MpsTableGuid, &MpsTable);
    if (EFI_ERROR(Status)) {
        EfiPrint(L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }
#endif
    //
    // Get the ACPI Tables
    //

    //
    // Get the ACPI 2.0 Table, if present
    //
    //DbgPrint("Looking for ACPi 2.0\n");
    Status = GetSystemConfigurationTable(&AcpiTable_Guid, &AcpiTable);
    if (EFI_ERROR(Status)) {
        //DbgPrint("returned error\n");
        AcpiTable = NULL;
    }

  //DbgPrint("AcpiTable: %p\n", AcpiTable);

    if (!AcpiTable) {
        EfiPrint(L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }


    //
    // Get the SMBIOS Table
    //
    Status = GetSystemConfigurationTable(&SmbiosTableGuid, &SMBiosTable);
    if (EFI_ERROR(Status)) {
        //DbgPrint("returned error\n");
        SMBiosTable = NULL;
    } else {
        //
        // Validate SMBIOS EPS Header
        //
        SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)SMBiosTable;
        SMBiosEPSPtr = (PUCHAR)SMBiosTable;
        
        if ((*((PULONG)SMBiosEPSHeader->Signature) == SMBIOS_EPS_SIGNATURE) &&
            (SMBiosEPSHeader->Length >= sizeof(SMBIOS_EPS_HEADER)) &&
            (*((PULONG)SMBiosEPSHeader->Signature2) == DMI_EPS_SIGNATURE) && 
            (SMBiosEPSHeader->Signature2[4] == '_' ))
        {
            CheckSum = 0;
            for (i = 0; i < SMBiosEPSHeader->Length ; i++)
            {
                CheckSum = CheckSum + SMBiosEPSPtr[i];
            }

            if (CheckSum != 0)
            {
                DBG_TRACE(L"SMBios Table has bad checksum.....\r\n");
                SMBiosTable = NULL;
            } else {
                DBG_TRACE(L"SMBios Table has been validated.....\r\n");
            }
            
        } else {
            DBG_TRACE(L"SMBios Table is incorrectly formed.....\r\n");
            SMBiosTable = NULL;
        }       
    }                                                                     
    
    //
    // Get the image info for NTLDR
    //
    Status = EfiBS->HandleProtocol (
                ImageHandle,
                &EfiLoadedImageProtocol,
                &EfiImageInfo
                );

    if (EFI_ERROR(Status)) {
        EfiPrint(L"SuMain: HandleProtocol failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Get device path of the DeviceHandle associated with this image handle.
    //
    Status = EfiBS->HandleProtocol (
                EfiImageInfo->DeviceHandle,
                &EfiDevicePathProtocol,
                &DevicePath
                );

    if (EFI_ERROR(Status)) {
        EfiPrint(L"SuMain: HandleProtocol failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // Get the MediaType and Partition information and save them in the
    // BootContext.
    //
    EfiAlignDp( &TestPathAligned,
                 DevicePath,
                 DevicePathNodeLength(DevicePath) );


    TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;

    while (TestPath->Type != END_DEVICE_PATH_TYPE) {

        //
        // save the channel in case its needed later.  We may
        // need this information to help further distinguish
        // between devices that share the same SCSI ID/LUN, but
        // may be sitting on different controllers.
        //
    	if (TestPath->Type == HW_PCI_DP) {
    	    PciDevicePath = (PCI_DEVICE_PATH *)TestPath;
    	    Channel = PciDevicePath->Function;
    	}

        if (TestPath->Type == MESSAGING_DEVICE_PATH) {
            if (TestPath->SubType == MSG_ATAPI_DP) {
                AtapiDevicePath = (ATAPI_DEVICE_PATH *) TestPath;
                BootContext.BusType = BootBusAtapi;
                BootDeviceAtapi = (PBOOT_DEVICE_ATAPI) &(BootContext.BootDevice);

                BootDeviceAtapi->PrimarySecondary = AtapiDevicePath->PrimarySecondary;
                BootDeviceAtapi->SlaveMaster = AtapiDevicePath->SlaveMaster;
                BootDeviceAtapi->Lun = AtapiDevicePath->Lun;
            } else if (TestPath->SubType == MSG_SCSI_DP) {
                ScsiDevicePath = (SCSI_DEVICE_PATH *) TestPath;
                BootContext.BusType = BootBusScsi;
                BootDeviceScsi = (PBOOT_DEVICE_SCSI) &(BootContext.BootDevice);

                // Remember his specifics
                BootDeviceScsi->Channel = Channel;
                BootDeviceScsi->Pun = ScsiDevicePath->Pun;
                BootDeviceScsi->Lun = ScsiDevicePath->Lun;
            } else if (TestPath->SubType == MSG_MAC_ADDR_DP) {
                BootContext.MediaType = BootMediaTcpip;
            } else if (TestPath->SubType == MSG_IPv4_DP) {
                IpV4DevicePath = (IPv4_DEVICE_PATH *) TestPath;
                BootContext.MediaType = BootMediaTcpip;
                BootDeviceIpV4 = (PBOOT_DEVICE_IPv4) &(BootContext.BootDevice);

                BootDeviceIpV4->RemotePort = IpV4DevicePath->RemotePort;
                BootDeviceIpV4->LocalPort = IpV4DevicePath->LocalPort;
                RtlCopyMemory(&BootDeviceIpV4->Ip, &IpV4DevicePath->LocalIpAddress, sizeof(EFI_IPv4_ADDRESS));
            } else if (TestPath->SubType == MSG_IPv6_DP) {
                IpV6DevicePath = (IPv6_DEVICE_PATH *) TestPath;
                BootContext.MediaType = BootMediaTcpip;
                BootDeviceIpV6 = (PBOOT_DEVICE_IPv6) &(BootContext.BootDevice);

                BootDeviceIpV6->RemotePort = IpV6DevicePath->RemotePort;
                BootDeviceIpV6->LocalPort = IpV6DevicePath->LocalPort;
#if 0
                BootDeviceIpV6->Ip = IpV6DevicePath->Ip;
#endif
            }
        } else if (TestPath->Type == ACPI_DEVICE_PATH) {
            AcpiDevicePath = (ACPI_HID_DEVICE_PATH *) TestPath;
            if (AcpiDevicePath->HID == EISA_ID(PNP_EISA_ID_CONST, 0x0303)) {
                BootDeviceFloppy = (PBOOT_DEVICE_FLOPPY) &(BootContext.BootDevice);
                BootDeviceFloppy->DriveNumber = AcpiDevicePath->UID;
            }
        } else if (TestPath->Type == HARDWARE_DEVICE_PATH) {
            if (TestPath->SubType == HW_VENDOR_DP) {
                UnknownDevicePath = (UNKNOWN_DEVICE_VENDOR_DEVICE_PATH *) TestPath;
                BootDeviceUnknown = (PBOOT_DEVICE_UNKNOWN) &(BootContext.BootDevice);
                RtlCopyMemory( &(BootDeviceUnknown->Guid),
                               &(UnknownDevicePath->DevicePath.Guid),
                               sizeof(EFI_GUID));

                BootContext.BusType = BootBusVendor;
                BootDeviceUnknown->LegacyDriveLetter = UnknownDevicePath->LegacyDriveLetter;
            }
        } else if (TestPath->Type == MEDIA_DEVICE_PATH) {
            BootContext.MediaType = TestPath->SubType;
            if (TestPath->SubType == MEDIA_HARDDRIVE_DP) {
                HdDevicePath = (HARDDRIVE_DEVICE_PATH *) TestPath;

                BootContext.MediaType = BootMediaHardDisk;
                BootContext.PartitionNumber = (UCHAR) HdDevicePath->PartitionNumber;
            } else if (TestPath->SubType == MEDIA_CDROM_DP) {
                BootContext.MediaType = BootMediaCdrom;
            }
        }

        DevicePath = NextDevicePathNode(DevicePath);
        EfiAlignDp( &TestPathAligned,
                      DevicePath,
                      DevicePathNodeLength(DevicePath) );
        TestPath = (EFI_DEVICE_PATH *) &TestPathAligned;
    }

#ifdef  FORCE_CD_BOOT
    BootContext.MediaType = BootMediaCdrom;
#endif
    //
    // Fill out the rest of BootContext fields
    //

    DosHeader = EfiImageInfo->ImageBase;
    NtHeader = (PIMAGE_NT_HEADERS) ((PUCHAR) DosHeader + DosHeader->e_lfanew);
    FileHeader =  &(NtHeader->FileHeader);
    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)
                     ((PUCHAR)FileHeader + sizeof(IMAGE_FILE_HEADER));
    SectionHeader = (PIMAGE_SECTION_HEADER) ((PUCHAR)OptionalHeader +
                                             FileHeader->SizeOfOptionalHeader);

    BootContext.ExternalServicesTable = (PEXTERNAL_SERVICES_TABLE)
                                        &ExportEntryTable;

    BootContext.MachineType          = MACHINE_TYPE_ISA;

    BootContext.OsLoaderBase         = (ULONG_PTR)EfiImageInfo->ImageBase;
    BootContext.OsLoaderExports = (ULONG_PTR)EfiImageInfo->ImageBase +
                                  OptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

    BootContext.BootFlags            = 0;

    //
    // Calculate the start address and the end address of OS loader.
    //

    BootContext.OsLoaderStart        = (ULONG_PTR)EfiImageInfo->ImageBase +
                                       SectionHeader->VirtualAddress;
    BootContext.OsLoaderEnd          = (ULONG_PTR)EfiImageInfo->ImageBase +
                                       SectionHeader->SizeOfRawData;

    for (Section=FileHeader->NumberOfSections ; Section-- ; SectionHeader++) {
        Destination = (ULONG_PTR)EfiImageInfo->ImageBase + SectionHeader->VirtualAddress;
        VirtualSize = SectionHeader->Misc.VirtualSize;
        SizeOfRawData = SectionHeader->SizeOfRawData;

        if (VirtualSize == 0) {
            VirtualSize = SizeOfRawData;
        }
        if (Destination < BootContext.OsLoaderStart) {
            BootContext.OsLoaderStart = Destination;
        }
        if (Destination+VirtualSize > BootContext.OsLoaderEnd) {
            BootContext.OsLoaderEnd = Destination+VirtualSize;
        }
    }

    //
    // Find .rsrc section
    //
    SectionHeader = (PIMAGE_SECTION_HEADER) ((PUCHAR)OptionalHeader +
                                             FileHeader->SizeOfOptionalHeader);
    NumberOfSections = FileHeader->NumberOfSections;
    while (NumberOfSections) {
        if (_stricmp((PCHAR)SectionHeader->Name, ".rsrc")==0) {
            BootContext.ResourceDirectory =
                    (ULONGLONG) ((ULONG_PTR)EfiImageInfo->ImageBase + SectionHeader->VirtualAddress);

            BootContext.ResourceOffset = (ULONGLONG)((LONG)SectionHeader->VirtualAddress);
            ResourceFound = TRUE;
        }

        ++SectionHeader;
        --NumberOfSections;
    }

    if (ResourceFound == FALSE) {
        EfiPrint(L"SuMain: Resource section not found\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    DBG_TRACE( L"SuMain: About to call NtProcessStartup\r\n");


    //
    // See if someone called us w/ a TFTP restart block.
    //
    if( EfiImageInfo->LoadOptionsSize == (sizeof(TFTP_RESTART_BLOCK)) ) {
        
        //
        // Likely.  Make sure it's really a TFTP restart block and if so, go retrieve all
        // its contents.
        //
        if( EfiImageInfo->LoadOptions != NULL ) {

            extern TFTP_RESTART_BLOCK       gTFTPRestartBlock;
            PTFTP_RESTART_BLOCK             restartBlock = NULL;

            restartBlock = (PTFTP_RESTART_BLOCK)(EfiImageInfo->LoadOptions);

            RtlCopyMemory( &gTFTPRestartBlock,
                           restartBlock,
                           sizeof(TFTP_RESTART_BLOCK) );

            DBG_TRACE( L"SuMain: copied TFTP_RESTART_BLOCK into gTFTPRestartBlock\r\n");
        }
    }

    GetPalProcEntryPoint( SalSystemTable );

    //
    // construct arc memory descriptors for the first 128 mb of memory.
    // the loader will not use anything over 128 mb and efi may still
    // change the memory descriptors in it's memory map.  let the loader's
    // memory map be for as small a memory region as possible, so that
    // the chance for the loader's/efi's memory map to get out of sync
    // is minimal
    //
    ConstructArcMemoryDescriptorsWithAllocation(0, BL_DRIVER_RANGE_HIGH << PAGE_SHIFT);

    //
    // Applies CPU specific workarounds
    //
    CpuSpecificWork();

    SuFillExportTable( );

    NtProcessStartup( &BootContext );

}


VOID
GetPalProcEntryPoint(
    IN PSST_HEADER SalSystemTable
    )
{
    PVOID NextEntry;
    PPAL_SAL_ENTRY_POINT PalSalEntryPoint;
    PAP_WAKEUP_DESCRIPTOR ApWakeupDescriptor;
    ULONG i;
    

    DBG_TRACE(L"GetPalProcEntryPoint: entry\n");
    
    //
    // Get PalProc entry point from SAL System Table
    //


    NextEntry = (PUCHAR) SalSystemTable + sizeof(SST_HEADER);
    for (i = 0; i < SalSystemTable->EntryCount; i++) {
        switch ( *(PUCHAR)NextEntry ) {
            case PAL_SAL_EP_TYPE:
                PalSalEntryPoint = (PPAL_SAL_ENTRY_POINT) NextEntry;
                
                PalProcPhysical = Pal.PhysicalAddress = PalSalEntryPoint->PalEntryPoint;
                Sal.PhysicalAddress = PalSalEntryPoint->SalEntryPoint;
                SalGP.PhysicalAddress = PalSalEntryPoint->GlobalPointer;
                
                NextEntry = (PPAL_SAL_ENTRY_POINT)NextEntry + 1;
                break;
            case SAL_MEMORY_TYPE:

                NextEntry = (PSAL_MEMORY_DESCRIPTOR)NextEntry + 1;
                break;
            case PLATFORM_FEATURES_TYPE:
                
                NextEntry = (PPLATFORM_FEATURES)NextEntry + 1;
                break;
            case TRANSLATION_REGISTER_TYPE:

                NextEntry = (PTRANSLATION_REGISTER)NextEntry + 1;
                break;
            case PTC_COHERENCE_TYPE:
                                
                NextEntry = (PPTC_COHERENCE_DOMAIN)NextEntry + 1;
                break;
            case AP_WAKEUP_TYPE:
                ApWakeupDescriptor = (PAP_WAKEUP_DESCRIPTOR)NextEntry;
                WakeupVector = (ULONG) ApWakeupDescriptor->WakeupVector;
                NextEntry = (PAP_WAKEUP_DESCRIPTOR)NextEntry + 1;
                break;
            default:
                
                EfiPrint(L"SST: Invalid SST entry\n");
                EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        }
    }

    DBG_TRACE(L"GetPalProcEntryPoint: exit\n");    
}

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    )
{
    EFI_DEVICE_PATH *Start;

    //
    // Search for the end of the device path structure
    //
    Start = DevPath;
    while (DevPath->Type != END_DEVICE_PATH_TYPE) {
        DevPath = NextDevicePathNode(DevPath);
    }

    //
    // Compute the size
    //
    return (ULONG)((ULONGLONG)DevPath - (ULONGLONG)Start);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\chksum.s ===
#include "ksia64.h"

        LEAF_ENTRY (ChkSum)

        .prologue
        alloc    t21 = ar.pfs, 3, 0, 0, 0
        .save    ar.lc, t22
        mov      t22 = ar.lc
        zxt4     t3 = a2
        ;;

        cmp4.eq  pt0, pt1 = zero, a2
        add      t7 = 64, a1
        add      t3 = -1, t3
        ;;

(pt1)   ld2.nta  t0 = [a1], 2
        mov      ar.lc = t3
        cmp4.ne  pt2 = 1, a2

        mov      t10 = 0xffff
        zxt4     a0 = a0
(pt0)   br.cond.spnt cs20
        ;;

cs10:
(pt2)   ld2.nta  t4 = [a1], 2
        add      a2 = -1, a2
        add      a0 = t0, a0
        ;;

(pt1)   lfetch.nta [t7], 64
        extr.u   t1 = a0, 16, 16
        and      t2 = a0, t10
        ;;

        cmp4.ne  pt2 = 1, a2
        nop.f    0
        tbit.nz  pt1 = a1, 6
        
        mov      t0 = t4
        add      a0 = t1, t2
        br.cloop.dptk cs10
        ;;
        
cs20:
  
        nop.m    0
        extr.u   t1 = a0, 16, 16
        ;;
        add      a0 = t1, a0
        ;;

        mov      ar.lc = t22
        and      v0 = a0, t10
        br.ret.sptk brp

        LEAF_EXIT (ChkSum)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\sudata.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    sudata.h

Abstract:

	This file contains definition for ExportEntryTable and AbiosServices
        Table.

Author:

    Allen Kay	(akay)	14-Aug-97

--*/


typedef
VOID
(*PFUNCTION) (
    );

//
// define ntdetect.exe base address
//
#define DETECTION_ADDRESS 0x10000   // NTDETECT base address

//
// Define IO export functions.
//
typedef enum _EXPORT_ENTRY {
    ExRebootProcessor,
    ExGetSector,
    ExGetKey,
    ExGetCounter,
    ExReboot,
    ExAbiosServices,
    ExDetectHardware,
    ExHardwareCursor,
    ExGetDateTime,
    ExComPort,
    ExIsMcaMachine,
    ExGetStallCount,
    ExInitializeDisplayForNt,
    ExGetMemoryDescriptor,
    ExGetEddsSector,
    ExGetElToritoStatus,
    ExGetExtendedInt13Params,
	ExNetPcRomServices,
    ExAPMAttemptReconnect,
    ExBiosRedirectService,
    ExMaximumRoutine
} EXPORT_ENTRY;

//
// Define ABIOS services table.
//
typedef enum _ABIOS_SERVICES {
    FAbiosIsAbiosPresent,
    FAbiosGetMachineConfig,
    FAbiosInitializeSpt,
    FAbiosBuildInitTable,
    FAbiosInitializeDbsFtt,
    FAbiosMaximumRoutine
} ABIOS_SERVICES;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\flop.h ===
#if defined(NEC_98)
#define BYTE_PER_SECTOR  1024
#define SECTOR_PER_TRACK 8
#define TOTAL_CYLINDER   77
#define HEADS            2
#define MAX_FLOPPY_LEN (BYTE_PER_SECTOR*SECTOR_PER_TRACK*TOTAL_CYLINDER*HEADS)
// #define SCRATCH_BUFFER_SIZE (BYTE_PER_SECTOR * SECTOR_PER_TRACK)
#endif //NEC_98
//
// Optimize this constant so we are guaranteed to be able to transfer
// a whole track at a time from a 1.44 meg disk (sectors/track = 18 = 9K)
//
#define SCRATCH_BUFFER_SIZE 9216

//
// Buffer for temporary storage of data read from the disk that needs
// to end up in a location above the 1MB boundary.
//
// NOTE: it is very important that this buffer not cross a 64k boundary.
//
extern PUCHAR LocalBuffer;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\displayp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    displayp.h

Abstract:

    Private header file for display routines.

Author:

    Ted Miller (tedm) 7-July-1995

Revision History:

--*/

//
// NOTICE
//
// Under no circumstances is anyone besides display.c to call these routines
// directly. This would break DBCS display for Far Eastern locales.
//

//
// Globals
//
extern USHORT TextColumn;
extern USHORT TextRow;
extern UCHAR TextCurrentAttribute;

//
// Vga text mode stuff
//
VOID
TextTmScrollDisplay(
    VOID
    );

VOID
TextTmClearDisplay(
    VOID
    );

VOID
TextTmClearToEndOfDisplay(
    VOID
    );

VOID
TextTmClearFromStartOfLine(
    VOID
    );

VOID
TextTmClearToEndOfLine(
    VOID
    );

VOID
TextTmFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextTmCharOut(
    PUCHAR pc
    );

VOID
TextTmStringOut(
    IN PUCHAR String
    );

VOID
TextTmPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextTmSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextTmGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

//
// Vga graphics mode stuff
//

VOID
TextGrScrollDisplay(
    VOID
    );

VOID
TextGrClearDisplay(
    VOID
    );

VOID
TextGrClearToEndOfDisplay(
    VOID
    );

VOID
TextGrClearFromStartOfLine(
    VOID
    );

VOID
TextGrClearToEndOfLine(
    VOID
    );

VOID
TextGrFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

PUCHAR
TextGrCharOut(
    PUCHAR pc
    );

VOID
TextGrStringOut(
    IN PUCHAR String
    );

VOID
TextGrPositionCursor(
    USHORT Row,
    USHORT Column
    );

VOID
TextGrSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGrGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\halnls.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    halnls.h

Abstract:

    Strings which are used in the HAL

    English

--*/

#define MSG_HARDWARE_ERROR1     "\n*** Hardware Malfunction\n\n"
#define MSG_HARDWARE_ERROR2     "Call your hardware vendor for support\n\n"
#define MSG_HALT                "\n*** The system has halted ***\n"
#define MSG_NMI_PARITY          "NMI: Parity Check / Memory Parity Error\n"
#define MSG_NMI_CHANNEL_CHECK   "NMI: Channel Check / IOCHK\n"
#define MSG_NMI_FAIL_SAFE       "NMI: Fail-safe timer\n"
#define MSG_NMI_BUS_TIMEOUT     "NMI: Bus Timeout\n"
#define MSG_NMI_SOFTWARE_NMI    "NMI: Software NMI generated\n"
#define MSG_NMI_EISA_IOCHKERR   "NMI: Eisa IOCHKERR board %\n"

#define MSG_DEBUG_ENABLE        "Kernel Debugger Using: COM%x (Port 0x%x, Baud Rate %d)\n"
#define MSG_DEBUG_9600          "Switching debugger to 9600 baud\n"
#define MSG_MCE_PENDING         "Machine Check Exception pending, MCE exceptions not enabled\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\extern.h ===
/*++

Copyright (c) 1991  Microsoft Corporation


Module Name:

    sudata.h

Abstract:

    This file contains definition for ExportEntryTable and AbiosServices
        Table.

Author:

    Allen Kay   (allen.m.kay@intel.com) 12-Jan-2000

--*/

//
// EFI gloal variables
//

extern EFI_SYSTEM_TABLE        *EfiST;
extern EFI_BOOT_SERVICES       *EfiBS;
extern EFI_RUNTIME_SERVICES    *EfiRS;
extern EFI_HANDLE               EfiImageHandle;

//
// EFI GUID defines
//

extern EFI_GUID EfiLoadedImageProtocol;
extern EFI_GUID EfiDevicePathProtocol;
extern EFI_GUID EfiDeviceIoProtocol;
extern EFI_GUID EfiBlockIoProtocol;
extern EFI_GUID EfiFilesystemProtocol;

extern EFI_GUID MpsTableGuid;
extern EFI_GUID AcpiTableGuid;
extern EFI_GUID SmbiosTableGuid;
extern EFI_GUID SalSystemTableGuid;

//
// Other gloal variables
//
extern PVOID              ExportEntryTable[];
extern PVOID              AcpiTable;

extern TR_INFO            Pal;
extern TR_INFO            Sal;
extern TR_INFO            SalGP;

extern ULONGLONG          IoPortPhysicalBase;
extern ULONGLONG          IoPortTrPs;

extern ULONG              WakeupVector;


//
// PAL, SAL, and IO port space data
//

typedef
EFI_STATUS
(EFIAPI *PAL_PROC) (
    IN ULONGLONG Index,
    IN ULONGLONG CacheType,
    IN ULONGLONG Invalidate,
    IN ULONGLONG PlatAck
    );

//
// Function Prototypes
//

ULONG
GetDevPathSize(
    IN EFI_DEVICE_PATH *DevPath
    );

BOOLEAN
ConstructMemoryDescriptors(
    );

BOOLEAN
ConstructCacheDescriptors (
    );

VOID
FlipToPhysical (
    );

VOID
FlipToVirtual (
    );

BOOLEAN
IsPsrDtOn (
    VOID
    );

VOID
BlInstTransOn (
    );

VOID
PioICacheFlush (
    );

VOID
ReadProcessorConfigInfo (
    PPROCESSOR_CONFIG_INFO ProcessorConfigInfo
    );

VOID
CheckForPreA2Processors(
    );

VOID
EnforcePostB2Processor(
    );

VOID
EnforcePostVersion16PAL(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\haldtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    detecthw.c

Abstract:

    Routines for determining which drivers/HAL need to be loaded.

Author:

    John Vert (jvert) 20-Oct-1993

Revision History:

--*/
#include "haldtect.h"
#include <stdlib.h>


//
// detection function prototypes
//
#if 0
ULONG   DetectPicACPI_NEC98(PBOOLEAN);
ULONG   DetectMPS_NEC98(PBOOLEAN);
ULONG   DetectUPMPS_NEC98(PBOOLEAN);
ULONG   DetectTmr_NEC98(PBOOLEAN);
ULONG   DetectNonTmr_NEC98(PBOOLEAN);
ULONG   DetectSystemPro(PBOOLEAN);
ULONG   DetectWyse7(PBOOLEAN);
ULONG   NCRDeterminePlatform(PBOOLEAN);
ULONG   Detect486CStep(PBOOLEAN);
ULONG   DetectOlivettiMp(PBOOLEAN);
ULONG   DetectAST(PBOOLEAN);
ULONG   DetectCbusII(PBOOLEAN);
ULONG   DetectMPACPI(PBOOLEAN);
ULONG   DetectApicACPI(PBOOLEAN);
ULONG   DetectPicACPI(PBOOLEAN);
ULONG   DetectUPMPS(PBOOLEAN);
ULONG   DetectMPS(PBOOLEAN);
#endif
ULONG   DetectTrue(PBOOLEAN);

typedef struct _HAL_DETECT_ENTRY {
    INTERFACE_TYPE  BusType;
    ULONG           (*DetectFunction)(PBOOLEAN);
    PCHAR           Shortname;
} HAL_DETECT_ENTRY, *PHAL_DETECT_ENTRY;

HAL_DETECT_ENTRY DetectHal[] = {

#if 0
// First check for a HAL to match some specific hardware.
    Isa,            DetectPicACPI_NEC98,   "nec98acpipic_up",
    Isa,            DetectMPS_NEC98,       "nec98mps_mp",
    Isa,            DetectUPMPS_NEC98,     "nec98mps_up",
    Isa,            DetectTmr_NEC98,       "nec98tmr_up",
    Isa,            DetectNonTmr_NEC98,    "nec98Notmr_up",
    MicroChannel,   NCRDeterminePlatform,  "ncr3x_mp",
    Eisa,           DetectCbusII,          "cbus2_mp",
    Isa,            DetectCbusII,          "cbus2_mp",
    MicroChannel,   DetectCbusII,          "cbusmc_mp",
    Eisa,           DetectMPACPI,          "acpiapic_mp",
    Isa,            DetectMPACPI,          "acpiapic_mp",
    Eisa,           DetectApicACPI,        "acpiapic_up",
    Isa,            DetectApicACPI,        "acpiapic_up",
    Isa,            DetectPicACPI,         "acpipic_up",
    Eisa,           DetectMPS,             "mps_mp",
    Isa,            DetectMPS,             "mps_mp",
    MicroChannel,   DetectMPS,             "mps_mca_mp",
    Eisa,           DetectUPMPS,           "mps_up",
    Isa,            DetectUPMPS,           "mps_up",
    Eisa,           DetectSystemPro,       "syspro_mp", // check SystemPro last

// Before using default HAL make sure we don't need a special one
    Isa,            Detect486CStep,        "486c_up",
    Eisa,           Detect486CStep,        "486c_up",

// Use default hal for given bus type...
    Isa,            DetectTrue,            "e_isa_up",
    Eisa,           DetectTrue,            "e_isa_up",
    MicroChannel,   DetectTrue,            "mca_up",
#endif
    Isa,            DetectTrue,            "acpipic_up",
    Eisa,           DetectTrue,            "acpipic_up",
    MicroChannel,   DetectTrue,            "acpipic_up",
    0,       NULL,                   NULL
};


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines which HAL to load and returns the filename.

Arguments:

    None.

Return Value:

    PCHAR - pointer to the filename of the HAL to be loaded.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Adapter;
    INTERFACE_TYPE BusType;
    BOOLEAN IsMpMachine;
    ULONG i;
    PCHAR MachineShortname;

    //
    // Determine the bus type by searching the ARC configuration tree
    //

    BusType = Isa;

    //
    // Check for Eisa
    //

    Adapter = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                       AdapterClass,
                                       EisaAdapter,
                                       NULL);
    if (Adapter != NULL) {
        BusType = Eisa;
    }

    //
    // Check for MCA
    //

    Adapter = NULL;
    for (; ;) {
        Adapter = KeFindConfigurationNextEntry (
                        BlLoaderBlock->ConfigurationRoot,
                        AdapterClass,
                        MultiFunctionAdapter,
                        NULL,
                        &Adapter
                        );
        if (!Adapter) {
            break;
        }

        if (_stricmp(Adapter->ComponentEntry.Identifier,"MCA")==0) {
            BusType = MicroChannel;
            break;
        }
    }

    //
    // Now go figure out machine and hal type.
    //

    for (i=0;;i++) {
        if (DetectHal[i].DetectFunction == NULL) {
            //
            // We reached the end of the list without
            // figuring it out!
            //
            SlFatalError(i);
            return(NULL);
        }

        if ((DetectHal[i].BusType == BusType) ||
            (DetectHal[i].BusType == Internal)) {

            IsMpMachine = FALSE;
            if ((DetectHal[i].DetectFunction)(&IsMpMachine) != 0) {

                //
                // Found the correct HAL.
                //

                MachineShortname = DetectHal[i].Shortname;
                break;
            }
        }
    }

    return(MachineShortname);
}


ULONG
DetectTrue(
    OUT PBOOLEAN IsMP
)
/*++

Routine Description:

    To Return TRUE

Return Value:

    TRUE

--*/
{
    UNREFERENCED_PARAMETER( IsMP );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\i64bios.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1994  Microsoft Corporation

Module Name:

  i64bios.c  copied from hali64\x86bios.c

Abstract:


    This module implements the platform specific interface between a device
    driver and the execution of x86 ROM bios code for the device.

Author:

    William K. Cheung (wcheung) 20-Mar-1996

    based on the version by David N. Cutler (davec) 17-Jun-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#pragma warning(disable:4200)   // unsized array in halp

#include "halp.h"

//
// Define global data.
//

ULONG HalpX86BiosInitialized = FALSE;
ULONG HalpEnableInt10Calls = FALSE;



ULONG
HalpSetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Offset );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( SlotNumber );
    UNREFERENCED_PARAMETER( RootHandler );
    UNREFERENCED_PARAMETER( BusHandler );

    return 0;
}


ULONG
HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    UNREFERENCED_PARAMETER( BusNumber );
    UNREFERENCED_PARAMETER( SlotNumber );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );

    return 0;
}


VOID
HalpAcquireCmosSpinLock (
    VOID
        )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{ 
    return;
}


VOID
HalpReleaseCmosSpinLock (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}


HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/




{
    return 8;
}


VOID
HalpInitializeCmos (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return ;
}


VOID
HalpReadCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    UNREFERENCED_PARAMETER( TimeFields );

    return ;
}

VOID
HalpWriteCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    UNREFERENCED_PARAMETER( TimeFields );

    return;
}



BOOLEAN
HalpBiosDisplayReset (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/

{
    return FALSE;
}


VOID
HalpInitializeX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function initializes a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if 0
    //
    // If I/O Ports or I/O memory could not be mapped, then don't
    // attempt to initialize the display adapter.
    //

    if (HalpIoControlBase == NULL || HalpIoMemoryBase == NULL) {
        return;
    }

    //
    // Initialize the x86 bios emulator.
    //

    x86BiosInitializeBios(HalpIoControlBase, HalpIoMemoryBase);
    HalpX86BiosInitialized = TRUE;

    //
    // Attempt to initialize the display adapter by executing its ROM bios
    // code. The standard ROM bios code address for PC video adapters is
    // 0xC000:0000 on the ISA bus.
    //

    if (x86BiosInitializeAdapter(0xc0000,
                                 NULL,
                                 (PVOID)HalpIoControlBase,
                                 (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {



    HalpEnableInt10Calls = FALSE;
    return;
    }
#endif

    HalpEnableInt10Calls = TRUE;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\halp.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

Author:

    John Vert (jvert) 11-Feb-92


Revision History:

--*/
#ifndef _HALP_H_
#define _HALP_H_

//
// ignore some warning for public headers.
//
#pragma warning(disable:4214)   // bit field types other than int
#pragma warning(disable:4201)   // nameless struct/union
#pragma warning(disable:4115)   // named type definition in parentheses

#include "nthal.h"
#include "hal.h"

#define IPI_VECTOR 0xE1

#include "halnls.h"

#if 0
#ifndef _HALI_
#include "..\inc\hali.h"
#endif
#endif

#define HAL_MAXIMUM_PROCESSOR 0x20

/*
 * Default clock and profile timer intervals (in 100ns-unit)
 */
#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms

//
// Define Realtime Clock register numbers.
//

#define RTC_SECOND 0                    // second of minute [0..59]
#define RTC_SECOND_ALARM 1              // seconds to alarm
#define RTC_MINUTE 2                    // minute of hour [0..59]
#define RTC_MINUTE_ALARM 3              // minutes to alarm
#define RTC_HOUR 4                      // hour of day [0..23]
#define RTC_HOUR_ALARM 5                // hours to alarm
#define RTC_DAY_OF_WEEK 6               // day of week [1..7]
#define RTC_DAY_OF_MONTH 7              // day of month [1..31]
#define RTC_MONTH 8                     // month of year [1..12]
#define RTC_YEAR 9                      // year [00..99]
#define RTC_CONTROL_REGISTERA 10        // control register A
#define RTC_CONTROL_REGISTERB 11        // control register B
#define RTC_CONTROL_REGISTERC 12        // control register C
#define RTC_CONTROL_REGISTERD 13        // control register D
#define RTC_REGNUMBER_RTC_CR1 0x6A      // control register 1



#define RTC_ISA_ADDRESS_PORT   0x070
 
#define RTC_ISA_DATA_PORT      0x071

extern PVOID HalpRtcAddressPort;

extern PVOID HalpRtcDataPort;

extern PLOADER_PARAMETER_BLOCK KeLoaderBlock; 

//
// Define Control Register A structure.
//

typedef struct _RTC_CONTROL_REGISTER_A {
    UCHAR RateSelect : 4;
    UCHAR TimebaseDivisor : 3;
    UCHAR UpdateInProgress : 1;
} RTC_CONTROL_REGISTER_A, *PRTC_CONTROL_REGISTER_A;

//
// Define Control Register B structure.
//

typedef struct _RTC_CONTROL_REGISTER_B {
    UCHAR DayLightSavingsEnable : 1;
    UCHAR HoursFormat : 1;
    UCHAR DataMode : 1;
    UCHAR SquareWaveEnable : 1;
    UCHAR UpdateInterruptEnable : 1;
    UCHAR AlarmInterruptEnable : 1;
    UCHAR TimerInterruptEnable : 1;
    UCHAR SetTime : 1;
} RTC_CONTROL_REGISTER_B, *PRTC_CONTROL_REGISTER_B;

//
// Define Control Register C structure.
//

typedef struct _RTC_CONTROL_REGISTER_C {
    UCHAR Fill : 4;
    UCHAR UpdateInterruptFlag : 1;
    UCHAR AlarmInterruptFlag : 1;
    UCHAR TimeInterruptFlag : 1;
    UCHAR InterruptRequest : 1;
} RTC_CONTROL_REGISTER_C, *PRTC_CONTROL_REGISTER_C;

//
// Define Control Register D structure.
//

typedef struct _RTC_CONTROL_REGISTER_D {
    UCHAR Fill : 7;
    UCHAR ValidTime : 1;
} RTC_CONTROL_REGISTER_D, *PRTC_CONTROL_REGISTER_D;




#define EISA_DMA_CHANNELS 8

extern UCHAR HalpDmaChannelMasks[];

//
// HalpOwnedDisplayBeforeSleep is defined in mpdat.c
//

extern BOOLEAN HalpOwnedDisplayBeforeSleep;

#define PIC_VECTORS 16

#define PRIMARY_VECTOR_BASE  0x30


#ifndef NEC_98

#define PIC_SLAVE_IRQ      2
#define PIC_SLAVE_REDIRECT 9
#else
#define PIC_SLAVE_IRQ      7
#define PIC_SLAVE_REDIRECT 8
#endif  //NEC_98

extern PVOID HalpSleepPageLock;
 
KIRQL
KfAcquireSpinLock (
   PKSPIN_LOCK SpinLock
    );

VOID
KfReleaseSpinLock (
   IN PKSPIN_LOCK SpinLock,
   IN KIRQL       NewIrql
   );

VOID
KeSetAffinityThread (
   PKTHREAD       Thread,
   KAFFINITY      HalpActiveProcessors
   );

KIRQL
KfRaiseIrql (
    KIRQL  NewIrql
    );

VOID
KfLowerIrql (
    KIRQL  NewIrql
    );

extern BOOLEAN
KdPollBreakIn (
    VOID
    );


VOID
HalpSavePicState (
    VOID
    );

VOID
HalpSaveDmaControllerState (
    VOID
    );


NTSTATUS
HalAllocateAdapterChannel (
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

ULONG
HalReadDmaCounter (
   IN PADAPTER_OBJECT AdapterObject
   );


VOID
HalpSaveTimerState (
    VOID
    );

VOID
HalpRestorePicState (
    VOID
    );

VOID
HalpRestoreDmaControllerState (
    VOID
    );

VOID
HalpRestoreTimerState (
    VOID
    );

BOOLEAN
HalpIoSapicInitialize (
    VOID
    );

BOOLEAN
IsPsrDtOn (
    VOID
    );

BOOLEAN
HalpIoSapicConnectInterrupt (
    KIRQL Irql,
    IN ULONG Vector 
    );

NTSTATUS
HalacpiGetInterruptTranslator(
        IN INTERFACE_TYPE ParentInterfaceType,
        IN ULONG ParentBusNumber,
        IN INTERFACE_TYPE BridgeInterfaceType,
        IN USHORT Size,
        IN USHORT Version,
        OUT PTRANSLATOR_INTERFACE Translator,
        OUT PULONG BridgeBusNumber
        );

#ifdef notyet

typedef struct {
    UCHAR   MasterMask;
    UCHAR   SlaveMask;
    UCHAR   MasterEdgeLevelControl;
    UCHAR   SlaveEdgeLevelControl;
} PIC_CONTEXT, *PPIC_CONTEXT;

#define EISA_DMA_CHANNELS 8

typedef struct {
    UCHAR           Dma1ExtendedModePort;
    UCHAR           Dma2ExtendedModePort;
    DMA1_CONTROL    Dma1Control;
    DMA2_CONTROL    Dma2Control;
} DMA_CONTEXT, *PDMA_CONTEXT;

typedef struct {
    UCHAR   nothing;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

typedef struct {
    PIC_CONTEXT     PicState;
    DMA_CONTEXT     DmaState;
} MOTHERBOARD_CONTEXT, *PMOTHERBOARD_CONTEXT;

extern MOTHERBOARD_CONTEXT  HalpMotherboardState;
extern UCHAR                HalpDmaChannelModes[];
extern PVOID                HalpSleepPageLock;
extern UCHAR                HalpDmaChannelMasks[];
extern BOOLEAN              HalpOwnedDisplayBeforeSleep;

#endif //notyet

VOID
HalpGetProcessorIDs (
   VOID
          );

VOID
HalpInitializeInterrupts (
    VOID
    );


VOID
HalInitializeProcessor (
     ULONG Number,
     PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
     );


VOID
HalpClearClock (
      VOID
     );


VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpClockInterruptPn(
   IN PKINTERRUPT_ROUTINE Interrupt,
   IN PKTRAP_FRAME TrapFrame  
  );



UCHAR
HalpReadClockRegister (
    UCHAR Register
    );

VOID
HalpWriteClockRegister (
    UCHAR Register,
    UCHAR Value
    );

// extern VOID
// HalpProfileInterrupt (
//    IN PKTRAP_FRAME TrapFrame
//    );

ULONGLONG
HalpReadIntervalTimeCounter (
    VOID
    );


VOID
HalpProgramIntervalTimerVector(
    ULONGLONG  IntervalTimerVector
          );

VOID
HalpClearITC (
    VOID );

VOID
HalpInitializeClock  (
    VOID
    );

VOID
HalpInitializeClockPn (
    VOID
    );

VOID
HalpInitializeClockInterrupts(
    VOID
    );

VOID
HalpSetInitialClockRate (
    VOID
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );


VOID
HalpUpdateITM (
    IN ULONGLONG NewITMValue
    );

VOID
HalpSendIPI (
    IN USHORT ProcessorID,
    IN ULONGLONG Data
    );

VOID
HalpOSRendez (
    IN USHORT ProcessorID
    );

//
// Prototype for system bus handlers
//

NTSTATUS
HalpQuerySimBusSlots (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

ULONG
HalpGetSimBusInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

BOOLEAN
HalpTranslateSimBusAddress (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
HalpRegisterSimBusHandler (
    VOID
    );

ULONG
HalpGetSimBusData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetSimBusData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignSimBusSlotResources (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

NTSTATUS
HalpAdjustSimBusResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

PDEVICE_HANDLER_OBJECT
HalpReferenceSimDeviceHandler (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN ULONG                SlotNumber
    );

NTSTATUS
HalpSimDeviceControl (
    IN PHAL_DEVICE_CONTROL_CONTEXT Context
    );

ULONG
HalGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

ULONG
HalSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

NTSTATUS
HalpHibernateHal (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler
    );

NTSTATUS
HalpResumeHal (
    IN PBUS_HANDLER  BusHandler,
    IN PBUS_HANDLER  RootHandler
    );


ULONG
HalpGetFeatureBits (
    VOID
    );

VOID
HalpInitMP(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

#ifdef RtlMoveMemory
#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory

#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))
VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

VOID
RtlFillMemory (
   PVOID Destination,
   ULONG Length,
   UCHAR Fill
   );

VOID
RtlZeroMemory (
   PVOID Destination,
   ULONG Length
   );

#endif


#if 0
#include "ixisa.h"
#endif

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
//


typedef struct _PcMpIoApicEntry  {
    UCHAR EntryType;
    UCHAR IoApicId;
    UCHAR IoApicVersion;
    UCHAR IoApicFlag;
    PVOID IoApicAddress;
} PCMPIOAPIC, *PPCMPIOAPIC;

//
// MP_INFO is defined in pcmp_nt.inc
//

// typedef struct _MP_INFO {
//    ULONG ApicVersion;      // 82489Dx or Not
//    ULONG ProcessorCount;   // Number of Enabled Processors
//    ULONG NtProcessors;     // Number of Running Processors
//    ULONG BusCount;         // Number of buses in system
//    ULONG IOApicCount;      // Number of Io Apics in system
//    ULONG IntiCount;        // Number of Io Apic interrupt input entries
//    ULONG LintiCount;       // Number of Local Apic interrupt input entries
//    ULONG IMCRPresent;      // Indicates if the IMCR is present
//    ULONG LocalApicBase;    // Base of local APIC
//    PULONG IoApicBase;     // The virtual addresses of the IoApic
//    PPCMPIOAPIC IoApicEntryPtr; // Ptr to 1st PC+MP IoApic entry 
//    ULONG  IoApicPhys[];        // The physical addresses of the IoApi

//}MP_INFO, *PMP_INFO;


extern USHORT LOCAL_ID[];

#define VECTOR_SIZE     8
#define IPI_ID_SHIFT    4
#define IpiTOKEN_SHIFT  20
#define IpiTOKEN    0xFFE

#define EID_MASK        0xFF00

#define OS_RENDEZ_VECTOR  0x11

#define RENDEZ_TIME_OUT  0X0FFFFFFFF

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE *IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

extern BOOLEAN HalpEisaDma;

//
// Map buffer prameters.  These are initialized in HalInitSystem
//

extern PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
extern ULONG HalpMapBufferSize;

extern ULONG HalpBusType;
extern ULONG HalpCpuType;
extern UCHAR HalpSerialLen;
extern UCHAR HalpSerialNumber[];

//
// The following macros are taken from mm\ia64\miia64.h.  We need them here
// so the HAL can map its own memory before memory-management has been
// initialized, or during a BugCheck.
//
// MiGetPdeAddress returns the address of the PDE which maps the
// given virtual address.
//

#if defined(_WIN64)

#define ADDRESS_BITS 64

#define NT_ADDRESS_BITS 32

#define NT_ADDRESS_MASK (((UINT_PTR)1 << NT_ADDRESS_BITS) -1)

#define MiGetPdeAddress(va) \
   ((PHARDWARE_PTE)(((((UINT_PTR)(va) & NT_ADDRESS_MASK) >> PDI_SHIFT) << PTE_SHIFT) + PDE_BASE))

#define MiGetPteAddress(va) \
   ((PHARDWARE_PTE)(((((UINT_PTR)(va) & NT_ADDRESS_MASK) >> PAGE_SHIFT) << PTE_SHIFT) + PTE_BASE))

#else

#define MiGetPdeAddress(va)  ((PHARDWARE_PTE)(((((ULONG)(va)) >> 22) << 2) + PDE_BASE))

//
// MiGetPteAddress returns the address of the PTE which maps the
// given virtual address.
//

#define MiGetPteAddress(va) ((PHARDWARE_PTE)(((((ULONG)(va)) >> 12) << 2) + PTE_BASE))

#endif // defined(_WIN64)

//
// Resource usage information
//

#pragma pack(1)
typedef struct {
    UCHAR   Flags;
    KIRQL   Irql;
    UCHAR   BusReleativeVector;
} IDTUsage;

typedef struct _HalAddressUsage{
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;       // Port or Memory
    UCHAR                   Flags;      // same as IDTUsage.Flags
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[];
} ADDRESS_USAGE;
#pragma pack()

//
// Added the following line
//

#define MAXIMUM_IDTVECTOR   0x0FF

//
// The following 3 lines are lifted from halp.h of halia64 directory 
// to clear the build error from i64timer.c
//

#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms

// IO Port emulation defines 

#define IO_PORT_MASK 0x0FFFF;
#define BYTE_ADDRESS_MASK 0x00FFF;
#define BYTE_ADDRESS_CLEAR 0x0FFFC;

// #define ExtVirtualIOBase   0xFFFFFFFFFFC00000

   // #define VirtualIOBase      0xFFFFFFFFFFC00000i64
#define VirtualIOBase      (UINT_PTR)(KADDRESS_BASE+0xFFC00000)

// extern VOID *VirtualIOBase;


// #define PhysicalIOBase   0x80000000FFC00000i64
#define PhysicalIOBase     0x00000FFFFC000000i64

#define IDTOwned            0x01        // IDT is not available for others
#define InterruptLatched    0x02        // Level or Latched
#define InternalUsage       0x11        // Report usage on internal bus
#define DeviceUsage         0x21        // Report usage on device bus

extern IDTUsage         HalpIDTUsage[];
extern ADDRESS_USAGE   *HalpAddressUsageList;

#define HalpRegisterAddressUsage(a) \
    (a)->Next = HalpAddressUsageList, HalpAddressUsageList = (a);


VOID
HalpInsertTranslationRegister (
    IN UINT_PTR  IFA,
    IN ULONG     SlotNumber,
    IN ULONGLONG Attribute,
    IN ULONGLONG ITIR
    );

VOID
HalpFillTbForIOPortSpace (
    ULONGLONG PhysicalAddress,
    UINT_PTR  VirtualAddress,
    ULONG     SlotNumber
    );


//
// Temp definitions to thunk into supporting new bus extension format
//

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusDataType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    );

#define HalpHandlerForBus   HaliHandlerForBus
#define HalpSetBusHandlerParent(c,p)    (c)->ParentHandler = p;

//
// Define function prototypes.
//

VOID
HalInitSystemPhase2(
    VOID
    );

KIRQL
HaliRaiseIrqlToDpcLevel (
   VOID
   );

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

VOID
HalpDisableAllInterrupts (
    VOID
    );

VOID
HalpProfileInterrupt(
    IN PKTRAP_FRAME TrapFrame 
    );

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeDisplay(
    VOID
    );

VOID
HalpInitializeStallExecution(
    IN CCHAR ProcessorNumber
    );

VOID
HalpRemoveFences (
    VOID
    );

VOID
HalpInitializePICs(
    VOID
    );

VOID
HalpIrq13Handler (
    VOID
   );

VOID
HalpFlushTLB (
    VOID
    );

VOID
HalpSerialize (
    VOID
    );


PVOID
HalMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );


PVOID
HalpMapPhysicalMemory(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    );

PVOID
HalpMapPhysicalMemoryWriteThrough(
    IN PVOID  PhysicalAddress,
    IN ULONG  NumberPages
    );

ULONG
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    );

BOOLEAN
HalpBiosDisplayReset(
    IN VOID
    );

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    );

VOID
HalpDisplayDebugStatus(
    IN PUCHAR   Status,
    IN ULONG    Length
    );

VOID
HalpInitializeCmos (
   VOID
   );

VOID
HalpReadCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpWriteCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpAcquireCmosSpinLock (
    VOID
    );

VOID
HalpReleaseCmosSpinLock (
    VOID
    );

VOID
HalpResetAllProcessors (
    VOID
    );

VOID
HalpCpuID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );

VOID
HalpEnableInterruptHandler (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql,
    IN VOID   (*HalInterruptServiceRoutine)(VOID),
    IN KINTERRUPT_MODE InterruptMode
    );

VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    );

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    );

VOID
HalpYearIs(
    IN ULONG Year
    );

VOID
HalpRecordEisaInterruptVectors(
    VOID
    );

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

//
// Defines for HalpFeatureBits
//

#define HAL_PERF_EVENTS     0x00000001
#define HAL_NO_SPECULATION  0x00000002
#define HAL_MCA_PRESENT     0x00000004  // Intel MCA Available
#define HAL_MCE_PRESENT     0x00000008  // ONLY Pentium style MCE available

extern ULONG HalpFeatureBits;

//
// Added HalpPciIrqMask
//
   extern USHORT HalpPciIrqMask;
  
//
// Defines for Processor Features returned from CPUID instruction
//

#define CPUID_MCA_MASK  0x4000
#define CPUID_MCE_MASK  0x0080


// Added ITIR bit field masks
//
 
#define ITIR_PPN_MASK       0x7FFF000000000000
#define IoSpaceSize         0x14
#define Attribute_PPN_Mask 0x0000FFFFFFFFF000 

#define IoSpaceAttribute 0x0010000000000473

NTSTATUS
HalpGetMcaLog(
    OUT PMCA_EXCEPTION  Exception,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO pMcaDriverInfo  // Info about registering driver
    );

VOID
HalpMcaInit(
    VOID
    );

//
// Disable the Local APIC on UP (PIC 8259) PentiumPro systems to work around
// spurious interrupt errata.
//
#define APIC_BASE_MSR       0x1B
#define APIC_ENABLED        0x0000000000000800


//
// PnP stuff
//

VOID
HalIrqTranslatorReference(
    PVOID Context
    );

VOID
HalIrqTranslatorDereference(
    PVOID Context
    );

NTSTATUS
HalIrqTranslateResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

ULONG
HalpGetIsaIrqState(
    ULONG   Vector
    );



// Definion for IA64 HalpVectorToINTI 

#define VECTOR  0xFF;
#define LEVEL   32;
extern UCHAR HalpVectorToINTI[];
extern UCHAR HalpVectorToIRQL[];

// Definition for IA64 complete


//
// ACPI specific stuff
//

// from detect\i386\acpibios.h
typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT 
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_INSTALLATION_CHECK   RsdtPtr
    );
    
NTSTATUS
HalpAcpiFindRsdtPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );
    
NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

PVOID
HalpGetAcpiTable(
    ULONG   Signature
    );

VOID
HalpSleepS5(
    VOID
    );
    
VOID
HalProcessorThrottle (
    UCHAR
    );



VOID
HalpStoreBufferUCHAR (
    PUCHAR VirtualAddress,
    PUCHAR Buffer,
    ULONG Count
    );

VOID
HalpStoreBufferUSHORT (
    PUSHORT VirtualAddress,
    PUSHORT Buffer,
    ULONG Count
    );

VOID
HalpStoreBufferULONG (
    PULONG VirtualAddress,
    PULONG Buffer,
    ULONG  Count
    );

VOID
HalpStoreBufferULONGLONG (
    PULONGLONG VirtualAddress,
    PULONGLONG Buffer,
    ULONG Count
    );


VOID
HalpLoadBufferUCHAR (
    PUCHAR VirtualAddress,
    PUCHAR Buffer,
    ULONG Count
    );

VOID
HalpLoadBufferUSHORT (
    PUSHORT VirtualAddress,
    PUSHORT Buffer,
    ULONG Count
    );

VOID
HalpLoadBufferULONG (
    PULONG VirtualAddress,
    PULONG Buffer,
    ULONG Count
    );

VOID
HalpLoadBufferULONGLONG (
    PULONGLONG VirtualAddress,
    PULONGLONG Buffer,
    ULONG Count
    );




//
// I/O Port space
//
// IoSpaceSize = 0x14 for 2 power 0x14 is 1Meg space size.
//

#define IO_SPACE_SIZE 0x14

// Present bit       =    1B to wire the space.
// Memory Attributes = 1001B for UC Memory type
// Accessed Bit      =    1B to "enable" access without faulting.
// Dirty Bit         =    1B to "enable" write without faulting.
// Privilege Level   =   00B for kernel accesses
// Access Right      =  010B for read/write accesses
// Exception Deferral=    1B for Exception Deferral.
//                               Exceptions are deferred
//                           for speculative loads to pages with
//                               non-spec. mem. attributes anyway.

// Protection Key    =    0  for kernel mode

#define IO_SPACE_ATTRIBUTE 0x0010000000000473

#endif // _HALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\i64ioasm.s ===
//	TITLE ("Memory Fences, Load Acquires and Store Acquires")

/*++

    Copyright (c) 1995  Intel Corporation

    Module Name:

     i64ioasm.s assembly routines for read and write I/O  

    Abstract:

     This module implements the I/O port access routines.

    Author:

      Bernard Lint, M. Jayakumar 17 Sep '97

    Environment:

      Kernel mode

    Revision History:

--*/

#include "ksia64.h"

#define HAL_RR_PS_VE 0x69
 
	.file "i64ioasm.s"



/*++

 VOID 
 HalpInsertTranslationRegister (
    IN UINT_PTR  IFA,
    IN ULONG     SlotNumber,
    IN ULONGLONG Attribute,
    IN ULONGLONG ITIR
    ) 


Routine Description:

   This function fills a fixed entry in TR 
 

    N.B.  It is assumed that the entry is not in the TB and therefore the TB 
        is not probed.

Arguements:

    (a0) - Supplies the virtual page number to be loaded into IFA.

    (a1) - Supplies the slot number to be used for Translation Register.

    (a2) - Supplies the attribute and portion of the physical address.

    (a3) - Supplies the value to be loaded into ITIR.


Return Value:

    None.

--*/


         LEAF_ENTRY(HalpInsertTranslationRegister)

         // Register aliases
         //

         rT1 = t3
         rT2 = t4 
 
         rPKR = t13
         rRR = t15 

 
         //	
         // rsm to reset PSR.i bit
         //


         rsm     1 << PSR_I    // reset PSR.i bit
         ;;
         rsm     1 << PSR_IC    // reset PSR.ic bit
         ;;
         srlz.d                 // serialize
    
         //
         // set RR[0],Region ID (HAL_ RID) = 0x7FFFFF,Page Size (PS) = 8K, 
         //  VHPT enabled (VE) = 1
         //  

  
         // dep.z       rRR= RR_IO_PORT, RR_INDEX, RR_INDEX_LEN

         dep.z          rRR = 5, RR_INDEX, RR_INDEX_LEN

         movl           rT2 = (0x7FFFFF << RR_RID) | HAL_RR_PS_VE
         ;;

         mov            rr[rRR] = rT2   // Initialize rr[RR_IOPort]
 

         // Protection Key Registers

         mov            rPKR = PKRNUM    // Total number of key registers
         ;;

         sub            rPKR = rPKR, zero,1 // Choose the last one

         movl           rT2 = (0x7FFFFF << RR_RID) | PKR_VALID
         ;;
  
         mov            pkr[rPKR] = rT2      
         ;;

         srlz.i
         mov cr.ifa   = a0
         mov cr.itir  = a3
         ;;
  
         itr.d dtr[a1]  = a2
         ssm     1 << PSR_IC             // set PSR.ic bit again
         ;;        
         srlz.d                          // serialize
         ssm     1 << PSR_I              // set PSR.i bit again
         LEAF_RETURN

         LEAF_EXIT(HalpInsertTranslationRegister)

/*++

VOID
HalpLoadBufferUCHAR (
   PUCHAR VirtualAddress,
   PUCHAR Buffer,
   UCHAR Count
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferUCHAR)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf

LoadChar:
    
         ld1.acq t1 = [a0]
         ;;
         st1 [a1] = t1, 1
    
         br.cloop.dptk.few LoadChar 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferUCHAR)
 

/*++

VOID
HalpLoadBufferUSHORT (
   PUSHORT VirtualAddress,
   PUSHORT Buffer,
   ULONG Count
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferUSHORT)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf
 
LoadShort:
    
         ld2.acq t1 = [a0]
         ;;  
         st2 [a1] = t1, 2 

         br.cloop.dptk.few LoadShort 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferUSHORT)
 
/*++

VOID
HalpLoadBufferULONG (
   PULONG VirtualAddress,
   PULONG Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferULONG)
    
         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf
 
LoadLong:
    
         ld4.acq t1 = [a0]
         ;; 
         st4 [a1] = t1, 4

         br.cloop.dptk.few LoadLong 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferULONG)
 
/*++

VOID
HalpLoadBufferULONGLONG (
   PULONGLONG VirtualAddress,
   PULONGLONG Buffer,
   ULONG      Count
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpLoadBufferULONGLONG)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
         mf

LoadLongLong:
    
         ld8.acq t1 = [a0]
         ;; 
         st8 [a1] = t1, 8
    
         br.cloop.dptk.few LoadLongLong 
         ;;

         mf.a
         mov ar.lc = t22
         LEAF_RETURN

         LEAF_EXIT (HalpLoadBufferULONGLONG)
 

/*++

VOID
HalpStoreBufferUCHAR (
   PUCHAR VirtualAddress,
   PUCHAR Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferUCHAR)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
 
StoreChar:
   
         ld1 t1 = [a1], 1 
         ;;
         st1.rel [a0] = t1 
    
         br.cloop.dptk.few StoreChar 
         ;;

         mf 

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferUCHAR)
 
/*++

VOID
HalpStoreBufferUSHORT (
   PUSHORT VirtualAddress,
   PUSHORT Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferUSHORT)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc
    
         sub a2 = a2,zero,1
         ;;
 
         PROLOGUE_END

         mov ar.lc = a2
 
StoreShort:
    
         ld2 t1 = [a1], 2
         ;;
         st2.rel [a0] = t1 
    
         br.cloop.dptk.few StoreShort 
         ;;

         mf

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferUSHORT)
 
/*++

VOID
HalpStoreBufferULONG (
   PULONG VirtualAddress,
   PULONG Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferULONG)
    
         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc
    
         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END

         mov ar.lc = a2
 
StoreLong:
    
         ld4.s t1 = [a1],t0
         ;;
         st4.rel [a0] = t1,4 
    
         br.cloop.dptk.few StoreLong 
         ;;

         mf

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferULONG)
 
/*++

VOID
HalpStoreBufferULONGLONG (
   PULONGLONG VirtualAddress,
   PULONGLONG Buffer,
   ULONG Count 
   );

Routine Description:

Arguements:

Return Value:

--*/

         LEAF_ENTRY(HalpStoreBufferULONGLONG)

         .prologue
         .save ar.lc, t22
         mov t22 = ar.lc

         sub a2 = a2,zero,1
         ;;

         PROLOGUE_END
 
         mov ar.lc = a2
 
StoreLongLong:
    
         ld8.s t1 = [a1],t0
         ;;
         st8.rel [a0] = t1, 8
    
         br.cloop.dptk.few StoreLongLong 
         ;;

         mf

         mf.a

         mov ar.lc = t22

         LEAF_RETURN

         LEAF_EXIT (HalpStoreBufferULONGLONG)
 

//++
//
// VOID
// ReadCpuLid(VOID);
//
// Routine Description:
//
// This function returns that value of cr.lid for this cpu
//
// Arguements:
//
// Return Value:
//
//    LID register contents
//
//--

         LEAF_ENTRY(ReadCpuLid)

         mov    v0 = cr.lid
         LEAF_RETURN

         LEAF_EXIT(ReadCpuLid)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\i64ioacc.c ===
/*++

 Copyright (c) 1995  Intel Corporation

 Module Name:

   i64ioacc.c

 Abstract:

   This module implements the I/O Register access routines.

 Author:

    Bernard Lint, M. Jayakumar  Sep 16 '97

 Environment:

    Kernel mode

 Revision History:

--*/



#pragma warning(disable:4200)   // unsized array in halp

#include "halp.h"
#include "kxia64.h"
 
extern ULONGLONG IoPortPhysicalBase;

ULONGLONG HalpGetPortVirtualAddress(
	UINT_PTR Port
	)
{

/*++

Routine Description:
 
   This routine gives 32 bit virtual address for the I/O Port specified.

Arguements:

   PORT - Supplies PORT address of the I/O PORT.

Returned Value:

   PUCHAR - 32bit virtual address value.

--*/

    // 
    // PUCHAR VirtualIOBase;
    //
   
    UINT_PTR ShiftedPort,PortIndex; 
  
    //
    //  Shifting operation applicable to integrals only. ULONG for 32 bits 
    //

    ShiftedPort = (UINT_PTR)Port;

    //
    //  Limit arguement PORT to 16 bit quantity 
    //

    ShiftedPort =  ShiftedPort & IO_PORT_MASK;

    //
    //  Capture bits [11:0] 
    //
    
    PortIndex   =  ShiftedPort & BYTE_ADDRESS_MASK;

    //
    //  Position it to point to 32 bit boundary
    //

    ShiftedPort =  ShiftedPort & BYTE_ADDRESS_CLEAR;

    //
    //  Shifted to page boundary. ShiftedPORT[[1:0] are zero.
    //  PORT[15:2] shifted to ShiftedPort[25:12]
    //

    ShiftedPort =  ShiftedPort << 10;

    // 
    //  Bits 1:0 has now 4 byte PORT address
    //
 
    ShiftedPort = ShiftedPort | PortIndex;
    
    // return (VIRTUAL_IO_BASE | ShiftedPort);

    //
    // Assume 1-to-to mapping of IO ports.
    //
    if (IsPsrDtOn()) {
        return (VIRTUAL_IO_BASE | ShiftedPort);
    } else {
        return (IoPortPhysicalBase | ShiftedPort | 0x8000000000000000);
    }
}


VOID 
HalpFillTbForIOPortSpace(
   ULONGLONG PhysicalAddress, 
   UINT_PTR  VirtualAddress,
   ULONG     SlotNumber 
   )

 {

/*++

Routine Description:

   This routine fills the translation buffer for the translation requested

Arguements:


   PhysicalAddress - Supplies Physical Address to be mapped for the virtual 
                     address.

   VirtualAddress  - Supplies Virtual Address.


   SlotNumber      - Slot number of the Translation Buffer to be used.

--*/

     ULONGLONG IITR,Attribute;
     UINT_PTR  IFA;
     
     IFA  = VirtualAddress;
   
     IITR = PhysicalAddress & IITR_PPN_MASK;

     IITR  = IITR | (IO_SPACE_SIZE << IDTR_PS);

     Attribute   = PhysicalAddress & IITR_ATTRIBUTE_PPN_MASK;
   
     Attribute   = Attribute   | IO_SPACE_ATTRIBUTE;

     HalpInsertTranslationRegister(IFA,SlotNumber,Attribute,IITR);

     return;
  }
 
UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    )
{

/*++

Routine Description:

   Reads a byte location from the PORT

Arguements:

   PORT - Supplies the PORT address to read from

Return Value:

   UCHAR - Returns the byte read from the PORT specified.


--*/

    ULONGLONG VirtualPort;
    UCHAR LoadData;
 
    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile UCHAR *)VirtualPort;
    __mfa();

    return (LoadData);
}



USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )
{
 
/*++

Routine Description:

   Reads a word location (16 bit unsigned value) from the PORT

Arguements:

   PORT - Supplies the PORT address to read from. 

Returned Value:

   USHORT - Returns the 16 bit unsigned value from the PORT specified.

--*/

    ULONGLONG VirtualPort;
    USHORT LoadData;
    
    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile USHORT *)VirtualPort;
    __mfa();

    return (LoadData);
}



ULONG
READ_PORT_ULONG (
    PULONG Port
    )
{

/*++

   Routine Description:

      Reads a longword location (32bit unsigned value) from the PORT.

   Arguements:

     PORT - Supplies PORT address to read from. 

   Returned Value:

     ULONG - Returns the 32 bit unsigned value (ULONG) from the PORT specified.

--*/ 

    ULONGLONG VirtualPort;
    ULONG LoadData;

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile ULONG *)VirtualPort;
    __mfa();

    return (LoadData);
}



VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )
{

/*++

   Routine Description:

     Reads multiple bytes from the specified PORT address into the 
     destination buffer.

   Arguements:

     PORT - The address of the PORT to read from.

     Buffer - A pointer to the buffer to fill with the data read from the PORT.

     Count - Supplies the number of bytes to read.

   Return Value:

     None.

--*/


    ULONGLONG VirtualPort;
    
    //
    // PUCHAR ReadBuffer = Buffer;
    //
    //
    // ULONG ReadCount;
    //
 
    VirtualPort =   HalpGetPortVirtualAddress((UINT_PTR)Port); 

    HalpLoadBufferUCHAR((PUCHAR)VirtualPort, Buffer, Count);

}



VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )
{

/*++

    Routine Description:

      Reads multiple words (16bits) from the speicified PORT address into
      the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data 
               read from the PORT.
 
      Count  - Supplies the number of words to read.     

--*/

   ULONGLONG VirtualPort;
   
   //
   // PUSHORT ReadBuffer = Buffer;
   // ULONG ReadCount;
   //

   VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port); 

   //
   // We don't need memory fence in between INs?. 
   // So, it is out of the loop to improve performance.
   //

   HalpLoadBufferUSHORT((PUSHORT)VirtualPort, Buffer, Count);

}


VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )
{

 /*++

    Routine Description:

      Reads multiple longwords (32bits) from the speicified PORT 
      address into the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data 
               read from the PORT.
 
      Count  - Supplies the number of long words to read.     

--*/

   ULONGLONG VirtualPort;
 
   VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port); 

   //  
   // We don't need memory fence in between INs. 
   // So, it is out of the loop to improve performance.
   //

   HalpLoadBufferULONG((PULONG)VirtualPort, Buffer,Count);

}

VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR  Value
    )
{
 
/*++

   Routine Description:

      Writes a byte to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.
 
      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/ 
  
    ULONGLONG VirtualPort;

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port); 
    *(volatile UCHAR *)VirtualPort = Value;
    __mf();
    __mfa();
}

VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT  Value
    )
{
 
/*++

   Routine Description:

      Writes a 16 bit SHORT Integer to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.
 
      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/ 
  
    ULONGLONG VirtualPort;

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port); 
    *(volatile USHORT *)VirtualPort = Value;
    __mf();
    __mfa();
}


VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG  Value
    )
{
 
/*++

   Routine Description:

      Writes a 32 bit Long Word to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.
 
      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/ 
  
    ULONGLONG VirtualPort;

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port); 
    *(volatile ULONG *)VirtualPort = Value;
    __mf();
    __mfa();
}



VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple bytes from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of bytes to write.

   Return Value:

     None.

--*/


   ULONGLONG VirtualPort; 

   VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

   HalpStoreBufferUCHAR((PUCHAR)VirtualPort,Buffer,Count);

}


VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 16bit short integers from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (16 bit) words to write.

   Return Value:

     None.

--*/


   ULONGLONG VirtualPort; 

   VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);
   
   
   HalpStoreBufferUSHORT((PUSHORT)VirtualPort,Buffer, Count);

}

VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 32bit long words from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (32 bit) long words to write.

   Return Value:

     None.

--*/


   ULONGLONG VirtualPort; 

   VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

   HalpStoreBufferULONG((PULONG)VirtualPort,Buffer, Count); 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\ixfwhal.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixfwhal.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    Intel x86 specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91


Revision History:

--*/

#ifndef _IXHALP_
#define _IXHALP_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_MAP_BUFFER_SIZE  0x1000000

//
// Define the initial buffer allocation size for a map buffers.
//

#define INITIAL_MAP_BUFFER_SIZE 0x20000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    CSHORT Type;
    CSHORT Size;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    UCHAR AdapterMode;
    UCHAR ExtendedModeFlags;
    USHORT DmaPortAddress;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN IsaDevice;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN AdapterInUse;
    PUCHAR PagePort;
} ADAPTER_OBJECT;

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// Define External data structures.
//

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

//
// Define function prototypes.
//

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

VOID
HalpInitializeDisplay(
    IN PUSHORT VideoBufferAddress
    );

#endif // _IXHALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the IopXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#if defined(NEC_98)
#include "nec98.h"
#else  //NEC_98
#include "eisa.h"
#endif //NEC_98


PADAPTER_OBJECT
IopAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    phyically contiguous memory pages.

Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
        channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    CSHORT Size;

    UNREFERENCED_PARAMETER( ChannelNumber );
    UNREFERENCED_PARAMETER( MapRegistersPerChannel );

    //
    // Determine the size of the adapter.
    //

    Size = sizeof( ADAPTER_OBJECT );

    //
    // Now create the adapter object.
    //

    AdapterObject = FwAllocateHeap(Size);

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table.
    //

    if (AdapterObject) {

        RtlZeroMemory(AdapterObject, Size);

        //
        // Initialize the adapter object itself.
        //

        AdapterObject->Type = IO_TYPE_ADAPTER;
        AdapterObject->Size = Size;
        AdapterObject->MapRegistersPerChannel = 0;
        AdapterObject->AdapterBaseVa = AdapterBaseVa;
        AdapterObject->PagePort = NULL;
        AdapterObject->AdapterInUse = FALSE;

    } else {

        //
        // An error was incurred for some reason.  Set the return value
        // to NULL.
        //

        return(NULL);
    }

    return AdapterObject;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\ixbusdat.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixbusdat.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#if defined(NEC_98)
#include "nec98.h"
#else  //NEC_98
#include "eisa.h"
#endif //NEC_98
#include "mca.h"
#include "ntconfig.h"

#if defined(NEC_98)
#else
ULONG
HalpGetCmosData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG
HalpGetPosData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetEisaData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );
#endif //!NEC_98

ULONG
HalpGetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData(
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

/*
 *
 * Router functions.  Routes each call to specific handler
 *
 */


ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    switch (BusDataType) {
#if defined(NEC_98)
#else
        case Cmos:
            if (Offset != 0) {
                return 0;
            }

            return HalpGetCmosData(BusNumber, Slot, Buffer, Length);

        case Pos:
            return HalpGetPosData(BusNumber, Slot, Buffer, Offset, Length);

        case EisaConfiguration:
            return HalpGetEisaData(BusNumber, Slot, Buffer, Offset, Length);
#endif //NEC_98

        case PCIConfiguration:
            return HalpGetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    switch (BusDataType) {
        case PCIConfiguration:
            return HalpSetPCIData(BusNumber, Slot, Buffer, Offset, Length);
    }
    return 0;
}


NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    UNREFERENCED_PARAMETER( RegistryPath );
    UNREFERENCED_PARAMETER( DriverClassName );
    UNREFERENCED_PARAMETER( DriverObject );
    UNREFERENCED_PARAMETER( DeviceObject );
  
    switch (BusType) {
        case PCIBus:
            return HalpAssignPCISlotResources (
                        BusNumber,
                        SlotNumber,
                        AllocatedResources
                        );
        default:
            break;
    }
    return STATUS_NOT_FOUND;
}





/**
 **
 ** Standard PC bus functions
 **
 **/



BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusNumber          - Supplies the bus number.  This is ignored on
                         standard x86 systems

    BusAddress         - Supplies the bus-relative address

    AddressSpace       - Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => I/O space
                         AddressSpace == 1 => memory space

    TranslatedAddress - Pointer to a physical_address.

Return Value:

    System physical address corresponding to the supplied bus relative
    address and bus address number.

--*/

{
    UNREFERENCED_PARAMETER( InterfaceType );
    UNREFERENCED_PARAMETER( BusNumber );
    UNREFERENCED_PARAMETER( AddressSpace );
    
    TranslatedAddress->HighPart = 0;
    TranslatedAddress->LowPart = BusAddress.LowPart;
    return(TRUE);
}

#if defined(NEC_98)
#else
ULONG
HalpGetPosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG DOffset,
    IN ULONG Length
    )
/*--

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PVOID McaRegisterBase = 0;
    ULONG Index = 0;
    PUCHAR DataBuffer = Buffer;
    ULONG DataLength = 0;
    PUCHAR PosBase;
    ULONG Offset;

    UNREFERENCED_PARAMETER( BusNumber );

    if (DOffset != 0  ||  MachineType != MACHINE_TYPE_MCA) {
        return 0;
    }

    PosBase = (PUCHAR) &((PMCA_CONTROL) McaRegisterBase)->Pos;

    //
    //  Place the specified adapter into setup mode.
    //

    WRITE_PORT_UCHAR((PVOID) &((PMCA_CONTROL) McaRegisterBase)->AdapterSetup,
                     (UCHAR) ( MCA_ADAPTER_SETUP_ON | SlotNumber ));

    while (DataLength < Length && DataLength < 6) {
        DataBuffer[DataLength] = READ_PORT_UCHAR( PosBase + DataLength );
        DataLength++;
    }

    while (DataLength < Length) {

        WRITE_PORT_UCHAR((PVOID) &((PPROGRAMMABLE_OPTION_SELECT)
            PosBase)->SubaddressExtensionLsb, (UCHAR) Index);

        WRITE_PORT_UCHAR((PVOID) &((PPROGRAMMABLE_OPTION_SELECT)
            PosBase)->SubaddressExtensionMsb, (UCHAR) (Index >> 8));

        DataBuffer[Index + 6] = READ_PORT_UCHAR(
            (PVOID) &((PPROGRAMMABLE_OPTION_SELECT)PosBase)->OptionSelectData2);

        DataLength++;

        if (DataLength < Length) {
            Offset = DataLength + ((Length - DataLength) / 2);
            DataBuffer[Offset] = READ_PORT_UCHAR(
                (PVOID) &((PPROGRAMMABLE_OPTION_SELECT)PosBase)->OptionSelectData3);
            DataLength++;
            Index++;
        }
    }

    //
    //  Disable adapter setup.
    //

    WRITE_PORT_UCHAR((PVOID) &((PMCA_CONTROL) McaRegisterBase)->AdapterSetup,
                     (UCHAR) ( MCA_ADAPTER_SETUP_OFF ));
    return 1;
}

ULONG
HalpGetEisaData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*--

Arguments:

    BusDataType - Supplies the type of bus.

    BusNumber - Indicates which bus.

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{

    ULONG DataLength = 0;
    ULONG i;
    ULONG TotalDataSize;
    ULONG SlotDataSize = 0;
    ULONG PartialCount;
    PCONFIGURATION_COMPONENT_DATA ConfigData;
    PCM_EISA_SLOT_INFORMATION SlotInformation = NULL;
    PCM_PARTIAL_RESOURCE_LIST Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    BOOLEAN Found = FALSE;

    UNREFERENCED_PARAMETER( BusNumber );

    if (MachineType != MACHINE_TYPE_EISA) {
        return 0;
    }

    ConfigData = KeFindConfigurationEntry(
        FwConfigurationTree,
        AdapterClass,
        EisaAdapter,
        NULL
        );

    if (ConfigData == NULL) {
#if defined(ENABLE_LOADER_EBUG) 
        DbgPrint("HalGetBusData: KeFindConfigurationEntry failed\n");
#endif
        return(0);
    }

    Descriptor = ConfigData->ConfigurationData;
    PartialResource = Descriptor->PartialDescriptors;
    PartialCount = Descriptor->Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

#if defined(ENABLE_LOADER_EBUG) 
                        DbgPrint("HalGetBusData: SlotDataSize > TotalDataSize\n");
#endif

                        return(0);

                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:

#if defined(ENABLE_LOADER_EBUG) 
                DbgPrint("Bad Data in registry!\n");
#endif

                return(0);

        }

    }

    if (Found) {

        //
        // As a hack if the length is zero then the buffer points to a
        // PVOID where the pointer to the data should be stored.  This is
        // done in the loader because we quickly run out of heap scaning
        // all of the EISA configuration data.
        //

        if (Length == 0) {

            //
            // Return the pointer to the mini-port driver.
            //

            *((PVOID *)Buffer) = SlotInformation;
            return(SlotDataSize);
        }

        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory(Buffer, ((PUCHAR) SlotInformation + Offset), DataLength);
    }

    return(DataLength);
}
#endif //NEC_98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\ixpcibus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcidat.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

Environment:

    Kernel mode

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#include "ntconfig.h"

#include "pci.h"

//extern WCHAR rgzMultiFunctionAdapter[];
//extern WCHAR rgzConfigurationData[];
//extern WCHAR rgzIdentifier[];
//extern WCHAR rgzPCIIdentifier[];

//
// Hal specific PCI bus structures
//

typedef struct tagPCIPBUSDATA {
    union {
        struct {
            PULONG      Address;
            ULONG       Data;
        } Type1;
        struct {
            PUCHAR      CSE;
            PUCHAR      Forward;
            ULONG       Base;
        } Type2;
    } Config;

} PCIPBUSDATA, *PPCIPBUSDATA;

#define PciBitIndex(Dev,Fnc)    (Fnc*32 + Dev);
#define PCI_CONFIG_TYPE(PciData)    ((PciData)->HeaderType & ~PCI_MULTIFUNCTION)

#define BUSHANDLER  _BUSHANDLER
#define PBUSHANDLER _PBUSHANDLER

// thunk for NtLdr
typedef struct {
    ULONG           NoBuses;
    ULONG           BusNumber;
    PVOID           BusData;
    PCIPBUSDATA     theBusData;
} BUSHANDLER, *PBUSHANDLER;

#define HalpPCIPin2Line(bus,rbus,slot,pcidata)
#define HalpPCILine2Pin(bus,rbus,slot,pcidata,pcidata2)
#define ExAllocatePool(a,l) FwAllocatePool(l)
// thunk for NtLdr


typedef ULONG (*FncConfigIO) (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

typedef VOID (*FncSync) (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

typedef VOID (*FncReleaseSync) (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

typedef struct {
    FncSync         Synchronize;
    FncReleaseSync  ReleaseSynchronzation;
    FncConfigIO     ConfigRead[3];
    FncConfigIO     ConfigWrite[3];
} CONFIG_HANDLER, *PCONFIG_HANDLER;


//
// Prototypes
//

ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern ULONG
HalpGetPCIInterruptVector (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUSHANDLER BusHandler,
    IN PBUSHANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

VOID
HalpInitializePciBuses (
    VOID
    );

//VOID
//HalpPCIPin2Line (
//    IN PBUSHANDLER         BusHandler,
//    IN PBUSHANDLER         RootHandler,
//    IN PCI_SLOT_NUMBER     Slot,
//    IN PPCI_COMMON_CONFIG  PciData
//    );
//
//VOID
//HalpPCILine2Pin (
//    IN PBUSHANDLER          BusHandler,
//    IN PBUSHANDLER          RootHandler,
//    IN PCI_SLOT_NUMBER      SlotNumber,
//    IN PPCI_COMMON_CONFIG   PciNewData,
//    IN PPCI_COMMON_CONFIG   PciOldData
//    );

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER     BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    );

//-------------------------------------------------

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );


//#define DISABLE_INTERRUPTS() //_asm { cli }
//#define ENABLE_INTERRUPTS()  //_asm { sti }


//
// Globals
//

ULONG               PCIMaxDevice;
BUSHANDLER          PCIBusHandler;

CONFIG_HANDLER      PCIConfigHandlers = {
    HalpPCISynchronizeType1,
    HalpPCIReleaseSynchronzationType1,
    {
        HalpPCIReadUlongType1,          // 0
        HalpPCIReadUcharType1,          // 1
        HalpPCIReadUshortType1          // 2
    },
    {
        HalpPCIWriteUlongType1,         // 0
        HalpPCIWriteUcharType1,         // 1
        HalpPCIWriteUshortType1         // 2
    }
};

CONFIG_HANDLER      PCIConfigHandlersType2 = {
    HalpPCISynchronizeType2,
    HalpPCIReleaseSynchronzationType2,
    {
        HalpPCIReadUlongType2,          // 0
        HalpPCIReadUcharType2,          // 1
        HalpPCIReadUshortType2          // 2
    },
    {
        HalpPCIWriteUlongType2,         // 0
        HalpPCIWriteUcharType2,         // 1
        HalpPCIWriteUshortType2         // 2
    }
};

UCHAR PCIDeref[4][4] = { {0,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    );


VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCI_REGISTRY_INFO  PCIRegInfo;
    PPCIPBUSDATA        BusData;
    PBUSHANDLER         Bus;
    PCONFIGURATION_COMPONENT_DATA   ConfigData;
    PCM_PARTIAL_RESOURCE_LIST       Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    ULONG               i;
    ULONG               HwType;

    Bus = &PCIBusHandler;
    PCIBusHandler.BusData = &PCIBusHandler.theBusData;

    PCIRegInfo = NULL;      // not found
    ConfigData = NULL;      // start at begining
    do {
        ConfigData = KeFindConfigurationNextEntry (
            FwConfigurationTree,
            AdapterClass,
            MultiFunctionAdapter,
            NULL,
            &ConfigData
            );

        if (ConfigData == NULL) {
            // PCI info not found
            return ;
        }

        if (ConfigData->ComponentEntry.Identifier == NULL  ||
            _stricmp (ConfigData->ComponentEntry.Identifier, "PCI") != 0) {
            continue;
        }

        PCIRegInfo = NULL;
        Desc  = ConfigData->ConfigurationData;
        PDesc = Desc->PartialDescriptors;
        for (i = 0; i < Desc->Count; i++) {
            if (PDesc->Type == CmResourceTypeDeviceSpecific) {
                PCIRegInfo = (PPCI_REGISTRY_INFO) (PDesc+1);
                break;
            }
            PDesc++;
        }
    } while (!PCIRegInfo) ;

    //
    // PCIRegInfo describes the system's PCI support as indicated
    // by the BIOS.
    //

    HwType = PCIRegInfo->HardwareMechanism & 0xf;

    switch (HwType) {
        case 1:
            // this is the default case
            PCIMaxDevice = PCI_MAX_DEVICES;
            break;

        //
        // Type2 does not work MP, nor does the default type2
        // support more the 0xf device slots
        //

        case 2:
            RtlMoveMemory (&PCIConfigHandlers,
                           &PCIConfigHandlersType2,
                           sizeof (PCIConfigHandlersType2));
            PCIMaxDevice = 0x10;
            break;

        default:
            // unsupport type
            PCIRegInfo->NoBuses = 0;
    }

    PCIBusHandler.NoBuses = PCIRegInfo->NoBuses;
    if (PCIRegInfo->NoBuses) {

        BusData = (PPCIPBUSDATA) Bus->BusData;
        switch (HwType) {
            case 1:
                BusData->Config.Type1.Address = (PULONG)PCI_TYPE1_ADDR_PORT;
                BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
                break;

            case 2:
                BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
                BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
                BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;
                break;
        }
    }
}


PBUSHANDLER
HalpGetPciBusHandler (
    IN ULONG BusNumber
    )
{
    if (PCIBusHandler.BusData == NULL) {
        HalpInitializePciBus ();
    }

    if (BusNumber > PCIBusHandler.NoBuses) {
        return NULL;
    }

    PCIBusHandler.BusNumber = BusNumber;
    return &PCIBusHandler;
}


ULONG
HalpGetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:

    BusNumber - Indicates which bus.

    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.


--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue
        // in the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested at least some data within the
        // common header.  Read the whole header, effect the
        // fields we need to and then copy the user's requested
        // bytes from the header
        //

        //
        // Read this PCI devices slot data
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            Len = 2;       // only return invalid id
        }

        //
        // Has this PCI device been configured?
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        HalpPCIPin2Line (BusHandler, RootHandler, Slot, PciData);

        //
        // Copy whatever data overlaps into the callers buffer
        //

        if (Len < Offset) {
            // no data at caller's buffer
            return 0;
        }

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpReadPCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

ULONG
HalpSetPCIData (
    IN ULONG BusNumber,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:


    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PBUSHANDLER         BusHandler;
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG) iBuffer2;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);
        if (PciData->VendorID == PCI_INVALID_VENDORID  ||
            PCI_CONFIG_TYPE (PciData) != 0) {

            // no device, or header type unkown
            return 0;
        }

        //
        // Set this device as configured
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //

        RtlMoveMemory (iBuffer2, iBuffer, Len);

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory (iBuffer2+Offset, Buffer, Len);

        // in case interrupt line or pin was editted
        HalpPCILine2Pin (BusHandler, RootHandler, Slot, PciData2, PciData);

        //
        // Set new PCI configuration
        //

        HalpWritePCIConfig (BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long & WORD aligned.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpWritePCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

VOID
HalpReadPCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID return no data
        //

        RtlFillMemory (Buffer, Length, (UCHAR) -1);
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigRead);
}

VOID
HalpWritePCIConfig (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID do nothing
        //
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                   PCIConfigHandlers.ConfigWrite);
}

BOOLEAN
HalpValidPCISlot (
    IN PBUSHANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
{
    PCI_SLOT_NUMBER                 Slot2;
    UCHAR                           HeaderType;
    ULONG                           i;

    if (Slot.u.bits.Reserved != 0) {
        return FALSE;
    }

    if (Slot.u.bits.DeviceNumber >= PCIMaxDevice) {
        return FALSE;
    }

    if (Slot.u.bits.FunctionNumber == 0) {
        return TRUE;
    }

    //
    // Non zero function numbers are only supported if the
    // device has the PCI_MULTIFUNCTION bit set in it's header
    //

    i = Slot.u.bits.DeviceNumber;

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //

    Slot2 = Slot;
    Slot2.u.bits.FunctionNumber = 0;

    HalpReadPCIConfig (
        BusHandler,
        Slot2,
        &HeaderType,
        FIELD_OFFSET (PCI_COMMON_CONFIG, HeaderType),
        sizeof (UCHAR)
        );

    if (!(HeaderType & PCI_MULTIFUNCTION) || HeaderType == 0xFF) {
        // this device doesn't exists or doesn't support MULTIFUNCTION types
        return FALSE;
    }

    return TRUE;
}


VOID
HalpPCIConfig (
    IN PBUSHANDLER      BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    )
{
    KIRQL               OldIrql;
    ULONG               i;
    UCHAR               State[20];
    PPCIPBUSDATA        BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PCIConfigHandlers.Synchronize (BusHandler, Slot, &OldIrql, State);

    while (Length) {
        i = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = ConfigIO[i] (BusData, State, Buffer, Offset);

        Offset += i;
        Buffer += i;
        Length -= i;
    }

    PCIConfigHandlers.ReleaseSynchronzation (BusHandler, OldIrql);
}

VOID HalpPCISynchronizeType1 (
    IN PBUSHANDLER          BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    UNREFERENCED_PARAMETER( Irql );

    //
    // Initialize PciCfg1
    //

    PciCfg1->u.AsULONG = 0;
    PciCfg1->u.bits.BusNumber = BusHandler->BusNumber;
    PciCfg1->u.bits.DeviceNumber = Slot.u.bits.DeviceNumber;
    PciCfg1->u.bits.FunctionNumber = Slot.u.bits.FunctionNumber;
    PciCfg1->u.bits.Enable = TRUE;

    //
    // Synchronize with PCI type1 config space
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
}

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUSHANDLER      BusHandler,
    IN KIRQL            Irql
    )
{
    PCI_TYPE1_CFG_BITS  PciCfg1;
    PPCIPBUSDATA        BusData;

    UNREFERENCED_PARAMETER( Irql );

    //
    // Disable PCI configuration space
    //

    PciCfg1.u.AsULONG = 0;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1.u.AsULONG);

    //
    // Release spinlock
    //

    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *Buffer = READ_PORT_UCHAR ((PUCHAR)UlongToPtr((BusData->Config.Type1.Data + i)));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT)ULongToPtr(BusData->Config.Type1.Data + i));
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG)ULongToPtr(BusData->Config.Type1.Data));
    return sizeof (ULONG);
}


ULONG
HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_UCHAR ((PUCHAR)ULongToPtr(BusData->Config.Type1.Data + i), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_USHORT ((PUSHORT)ULongToPtr(BusData->Config.Type1.Data + i), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_ULONG ((PULONG)ULongToPtr(BusData->Config.Type1.Data), *((PULONG) Buffer));
    return sizeof (ULONG);
}


VOID HalpPCISynchronizeType2 (
    IN PBUSHANDLER              BusHandler,
    IN PCI_SLOT_NUMBER          Slot,
    IN PKIRQL                   Irql,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    UNREFERENCED_PARAMETER( Irql );

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Initialize Cfg2Addr
    //

    PciCfg2Addr->u.AsUSHORT = 0;
    PciCfg2Addr->u.bits.Agent = (USHORT) Slot.u.bits.DeviceNumber;
    PciCfg2Addr->u.bits.AddressBase = (USHORT) BusData->Config.Type2.Base;

    //
    // Synchronize with type2 config space - type2 config space
    // remaps 4K of IO space, so we can not allow other I/Os to occur
    // while using type2 config space, hence the disable_interrupts.
    //

    //KeAcquireSpinLock (&HalpPCIConfigLock, Irql);
    //DISABLE_INTERRUPTS ();                      // is not MP safe

    PciCfg2Cse.u.AsUCHAR = 0;
    PciCfg2Cse.u.bits.Enable = TRUE;
    PciCfg2Cse.u.bits.FunctionNumber = (UCHAR) Slot.u.bits.FunctionNumber;
    PciCfg2Cse.u.bits.Key = 0xff;

    //
    // Select bus & enable type 2 configuration space
    //

    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) BusHandler->BusNumber);
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
}


VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUSHANDLER          BusHandler,
    IN KIRQL                Irql
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    UNREFERENCED_PARAMETER( Irql );

    //
    // disable PCI configuration space
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    PciCfg2Cse.u.AsUCHAR = 0;
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);

    //
    // Restore interrupts, release spinlock
    //

    //ENABLE_INTERRUPTS ();
    //KeReleaseSpinLock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *Buffer = READ_PORT_UCHAR ((PUCHAR) ((ULONGLONG)PciCfg2Addr->u.AsUSHORT));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    USHORT RetVal;
    
    UNREFERENCED_PARAMETER( BusData );
    
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    RetVal = READ_PORT_USHORT ((PUSHORT) ((ULONGLONG)PciCfg2Addr->u.AsUSHORT));
    *Buffer = TRUNCATE_SIZE_AT_UCHAR_MAX(RetVal);
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    ULONG RetVal;

    UNREFERENCED_PARAMETER( BusData );
    
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    RetVal = READ_PORT_ULONG ((PULONG) ((ULONGLONG)PciCfg2Addr->u.AsUSHORT));
    *Buffer = TRUNCATE_SIZE_AT_UCHAR_MAX(RetVal);
    return sizeof(ULONG);
}


ULONG
HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );

    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_UCHAR ((PUCHAR) ((ULONGLONG)PciCfg2Addr->u.AsUSHORT), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );
    
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_USHORT ((PUSHORT) ((ULONGLONG)PciCfg2Addr->u.AsUSHORT), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    UNREFERENCED_PARAMETER( BusData );
    
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_ULONG ((PULONG) ((ULONGLONG)PciCfg2Addr->u.AsUSHORT), *((PULONG) Buffer));
    return sizeof(ULONG);
}

NTSTATUS
HalpAssignPCISlotResources (
    IN ULONG                    BusNumber,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    PBUSHANDLER                     BusHandler;
    UCHAR                           buffer[PCI_COMMON_HDR_LENGTH];
    UCHAR                           buffer2[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG              PciData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    ULONG                           i, j, length, type;
    PHYSICAL_ADDRESS                Address;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    static PCM_RESOURCE_LIST        CmResList;

    BusHandler = HalpGetPciBusHandler (BusNumber);
    if (!BusHandler) {
        return 0;
    }

    *pAllocatedResources = NULL;

    PciData  = (PPCI_COMMON_CONFIG) buffer;
    PciData2 = (PPCI_COMMON_CONFIG) buffer2;
    PciSlot  = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;

    //
    // Read the PCI device's configuration
    //

    HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // Make a copy of the device's current settings
    //

    RtlMoveMemory (buffer2, buffer, PCI_COMMON_HDR_LENGTH);

    //
    // Set resources to all bits on to see what type of resources
    // are required.
    //

    for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
        PciData->u.type0.BaseAddresses[j] = 0xFFFFFFFF;
    }
    PciData->u.type0.ROMBaseAddress = 0xFFFFFFFF;

    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    PciData->u.type0.ROMBaseAddress &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpPCIPin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Restore the device's settings in case we don't complete
    //

    HalpWritePCIConfig (BusHandler, PciSlot, buffer2, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Build a CmResource descriptor list for the device
    //

    if (!CmResList) {
        // NtLdr pool is only allocated and never freed.  Allocate the
        // buffer once, and from then on just use the buffer over

        CmResList = ExAllocatePool (PagedPool,
            sizeof (CM_RESOURCE_LIST) +
            sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
            );
    }

    if (!CmResList) {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (CmResList,
        sizeof (CM_RESOURCE_LIST) +
        sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2)
        );

    *pAllocatedResources = CmResList;
    CmResList->List[0].InterfaceType = PCIBus;
    CmResList->List[0].BusNumber = BusNumber;

    CmDescriptor = CmResList->List[0].PartialResourceList.PartialDescriptors;
    if (PciData->u.type0.InterruptPin) {

        CmDescriptor->Type = CmResourceTypeInterrupt;
        CmDescriptor->ShareDisposition = CmResourceShareShared;
        CmDescriptor->Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        // in the loader interrupts aren't actually enabled, so just
        // pass back the untranslated values
        CmDescriptor->u.Interrupt.Level = PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Vector =  PciData->u.type0.InterruptLine;
        CmDescriptor->u.Interrupt.Affinity = 1;

        CmResList->List[0].PartialResourceList.Count++;
        CmDescriptor++;
    }

    // clear last address index + 1
    PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] = 0;
    if (PciData2->u.type0.ROMBaseAddress & PCI_ROMADDRESS_ENABLED) {

        // put rom address in last index+1
        PciData->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;

        PciData2->u.type0.BaseAddresses[PCI_TYPE0_ADDRESSES] =
            PciData2->u.type0.ROMBaseAddress & ~PCI_ADDRESS_IO_SPACE;
    }

    for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {
        if (PciData->u.type0.BaseAddresses[j]) {
            i = PciData->u.type0.BaseAddresses[j];

            // scan for first set bit, that's the length & alignment
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            Address.HighPart = 0;
            Address.LowPart = PciData2->u.type0.BaseAddresses[j] & ~(length-1);
            while (!(i & length)  &&  length) {
                length <<= 1;
            }

            // translate bus specific address
            type = (i & PCI_ADDRESS_IO_SPACE) ? 0 : 1;
            if (!HalTranslateBusAddress (
                    PCIBus,
                    BusNumber,
                    Address,
                    &type,
                    &Address )) {
                // translation failed, skip it
                continue;
            }

            // fill in CmDescriptor to return
            if (type == 0) {
                CmDescriptor->Type = CmResourceTypePort;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_PORT_IO;
                CmDescriptor->u.Port.Length = length;
                CmDescriptor->u.Port.Start = Address;
            } else {
                CmDescriptor->Type = CmResourceTypeMemory;
                CmDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                CmDescriptor->u.Memory.Length = length;
                CmDescriptor->u.Memory.Start = Address;

                if (j == PCI_TYPE0_ADDRESSES) {
                    // this is a ROM address
                    CmDescriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }
            }

            CmResList->List[0].PartialResourceList.Count++;
            CmDescriptor++;

            if (i & PCI_TYPE_64BIT) {
                // skip upper half of 64 bit address.
                j++;
            }
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\ixhwsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "bootia64.h"
#include "arc.h"
#include "ixfwhal.h"
#include "eisa.h"
#include "ntconfig.h"

#if !defined(NO_LEGACY_DRIVERS)
//
// This isn't used under EFI -- the HalPT is only setup immediately
// before calling ExitBootServices(), and is only necessary if you are
// using ntbootdd.sys
//
extern PHARDWARE_PTE HalPT;
#endif

PVOID HalpEisaControlBase;

//
// Define save area for ESIA adapter objects.
//

PADAPTER_OBJECT HalpEisaAdapter[8];

VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );



VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine copies the speicific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    neccessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    BOOLEAN mapped;

    //
    // Check to see if the buffer needs to be mapped.
    //


    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

        //
        // Map the buffer into system space.
        //

        bufferAddress = MmGetMdlVirtualAddress(Mdl);
        mapped = TRUE;

    } else {

        bufferAddress = Mdl->MappedSystemVa;
        mapped = FALSE;

    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Copy the data between the user buffer and map buffer
    //

    if (WriteToDevice) {

        RtlMoveMemory( TranslationEntry->VirtualAddress, bufferAddress, Length);

    } else {

        RtlMoveMemory(bufferAddress, TranslationEntry->VirtualAddress, Length);

    }

}

PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.  This code works for Isa and Eisa
    systems.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adpater object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    ULONG channelNumber;
    ULONG controllerNumber;
    DMA_EXTENDED_MODE extendedMode;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    BOOLEAN useChannel;
    ULONG maximumLength;


    //
    // Determine if the the channel number is important.  Master cards on
    // Eisa and Mca do not use a channel number.
    //

    if (DeviceDescriptor->InterfaceType != Isa &&
        DeviceDescriptor->Master) {

        useChannel = FALSE;
    } else {

        useChannel = TRUE;
    }

    //
    // Support for ISA local bus machines:
    // If the driver is a Master but really does not want a channel since it
    // is using the local bus DMA, just don't use an ISA channel.
    //

    if (DeviceDescriptor->InterfaceType == Isa &&
        DeviceDescriptor->DmaChannel > 7) {

        useChannel = FALSE;
    }

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    //
    // Channel 4 cannot be used since it is used for chaining. Return null if
    // it is requested.
    //

    if (DeviceDescriptor->DmaChannel == 4 && useChannel &&
        DeviceDescriptor->InterfaceType != MicroChannel) {
        return(NULL);
    }

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather && DeviceDescriptor->InterfaceType == Eisa) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength)
            + 1;
        numberOfMapRegisters = numberOfMapRegisters > MAXIMUM_ISA_MAP_REGISTER ?
            MAXIMUM_ISA_MAP_REGISTER : numberOfMapRegisters;

    }

    //
    // Set the channel number number.
    //

    channelNumber = DeviceDescriptor->DmaChannel & 0x03;

    //
    // Set the adapter base address to the Base address register and controller
    // number.
    //

    if (!(DeviceDescriptor->DmaChannel & 0x04)) {

        controllerNumber = 1;
        adapterBaseVa = (PVOID) &((PEISA_CONTROL) HalpEisaControlBase)->Dma1BasePort;

    } else {

        controllerNumber = 2;
#if defined(NEC_98)
        adapterBaseVa = &((PEISA_CONTROL) HalpEisaControlBase)->InDirectAddress;
#else  //NEC_98
        adapterBaseVa = &((PEISA_CONTROL) HalpEisaControlBase)->Dma2BasePort;
#endif //NEC_98

    }

    //
    // Determine if a new adapter object is necessary.  If so then allocate it.
    //

    if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

        adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

    } else {

        //
        // Allocate an adapter object.
        //

        adapterObject = (PADAPTER_OBJECT) IopAllocateAdapter(
            numberOfMapRegisters,
            adapterBaseVa,
            NULL
            );

        if (adapterObject == NULL) {

            return(NULL);

        }

        if (useChannel) {

            HalpEisaAdapter[DeviceDescriptor->DmaChannel] = adapterObject;

        }

        //
        // We never need map registers.
        //

        adapterObject->NeedsMapRegisters = FALSE;

        //
        // Set the maximum number of map registers for this channel bus on
        // the number requested and the type of device.
        //

        if (numberOfMapRegisters) {

            //
            // The speicified number of registers are actually allowed to be
            // allocated.
            //

            adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

        } else {

            //
            // No real map registers were allocated.  If this is a master
            // device, then the device can have as may registers as it wants.
            //


            if (DeviceDescriptor->Master) {

                adapterObject->MapRegistersPerChannel = BYTES_TO_PAGES(
                    maximumLength
                    )
                    + 1;

            } else {

                //
                // The device only gets one register.  It must call
                // IoMapTransfer repeatedly to do a large transfer.
                //

                adapterObject->MapRegistersPerChannel = 1;
            }
        }
    }

    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;

    //
    // If the channel number is not used then we are finished.  The rest of
    // the work deals with channels.
    //

    if (!useChannel) {
        return(adapterObject);
    }

    //
    // Setup the pointers to all the random registers.
    //

    adapterObject->ChannelNumber = (UCHAR) channelNumber;

    if (controllerNumber == 1) {

        switch ((UCHAR)channelNumber) {

        case 0:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel0;
            break;

        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel1;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel2;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel3;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 1;

#if defined(NEC_98)
#else
        //
        // Save the extended mode register address.
        //

        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma1ExtendedModePort;
#endif // !NEC_98

    } else {

#if defined(NEC_98)
#else  //NEC_98
        switch (channelNumber) {
        case 1:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel5;
            break;

        case 2:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel6;
            break;

        case 3:
            adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel7;
            break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 2;

        //
        // Save the extended mode register address.
        //
        adapterBaseVa =
            &((PEISA_CONTROL) HalpEisaControlBase)->Dma2ExtendedModePort;
#endif //NEC_98

    }

    adapterObject->Width16Bits = FALSE;

    if (MachineType == MACHINE_TYPE_EISA) {

        //
        // Initialzie the extended mode port.
        //

        *((PUCHAR) &extendedMode) = 0;
        extendedMode.ChannelNumber = (UCHAR)channelNumber;

        switch (DeviceDescriptor->DmaSpeed) {
        case Compatible:
            extendedMode.TimingMode = COMPATIBLITY_TIMING;
            break;

        case TypeA:
            extendedMode.TimingMode = TYPE_A_TIMING;
            break;

        case TypeB:
            extendedMode.TimingMode = TYPE_B_TIMING;
            break;

        case TypeC:
            extendedMode.TimingMode = BURST_TIMING;
            break;

        default:
            return(NULL);

        }

        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:
            extendedMode.TransferSize = BY_BYTE_8_BITS;
            break;

        case Width16Bits:
            extendedMode.TransferSize = BY_BYTE_16_BITS;

            //
            // Note Width16bits should not be set here because there is no need
            // to shift the address and the transfer count.
            //

            break;

        case Width32Bits:
            extendedMode.TransferSize = BY_BYTE_32_BITS;
            break;

        default:
            return(NULL);

        }

        WRITE_PORT_UCHAR( adapterBaseVa, *((PUCHAR) &extendedMode));

    } else if (!DeviceDescriptor->Master) {


#if defined(NEC_98)
#else
        switch (DeviceDescriptor->DmaWidth) {
        case Width8Bits:

            //
            // The channel must use controller 1.
            //

            if (controllerNumber != 1) {
                return(NULL);
            }

            break;

        case Width16Bits:

            //
            // The channel must use controller 2.
            //

            if (controllerNumber != 2) {
                return(NULL);
            }

            adapterObject->Width16Bits = TRUE;
            break;

        default:
            return(NULL);

        }
#endif //!NEC_98
    }


    //
    // Determine if this is an Isa adapter.
    //

    if (DeviceDescriptor->InterfaceType == Isa) {

        adapterObject->IsaDevice = TRUE;

    }

    //
    // Initialize the adapter mode register value to the correct parameters,
    // and save them in the adapter object.
    //

    adapterMode = 0;
    ((PDMA_EISA_MODE) &adapterMode)->Channel = adapterObject->ChannelNumber;

    adapterObject->MasterDevice = FALSE;

    if (DeviceDescriptor->Master) {

        adapterObject->MasterDevice = TRUE;

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = CASCADE_REQUEST_MODE;

        //
        // Set the mode, and enable the request.
        //

        if (adapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );

        } else {

#if defined(NEC_98)
#else  //NEC_98
            //
            // This request is for DMA controller 1
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                &dmaControl->SingleMask,
                 (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                 );
#endif //NEC_98

        }

    } else if (DeviceDescriptor->DemandMode) {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = DEMAND_REQUEST_MODE;

    } else {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = SINGLE_REQUEST_MODE;

    }

    if (DeviceDescriptor->AutoInitialize) {

        ((PDMA_EISA_MODE) &adapterMode)->AutoInitialize = 1;

    }

    adapterObject->AdapterMode = adapterMode;

    return(adapterObject);
}

NTSTATUS
IoAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  If this is the case, then the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    IO_ALLOCATION_ACTION action;

    //
    // Make sure the adapter if free.
    //

#if defined(ENABLE_LOADER_EBUG)
    if (AdapterObject->AdapterInUse) {
        DbgPrint("IoAllocateAdapterChannel: Called while adapter in use.\n");
    }
#endif

    //
    // Make sure there are enough map registers.
    //

    if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {

#if defined(ENABLE_LOADER_EBUG)
        DbgPrint("IoAllocateAdapterChannel:  Out of map registers.\n");
#endif
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    action = ExecutionRoutine( DeviceObject,
                               DeviceObject->CurrentIrp,
                               AdapterObject->MapRegisterBase,
                               Context );

    //
    // If the driver wishes to keep the map registers then
    // increment the current base and decrease the number of existing map
    // registers.
    //

    if (action == DeallocateObjectKeepRegisters &&
        AdapterObject->MapRegisterBase != NULL) {

        AdapterObject->MapRegistersPerChannel -= NumberOfMapRegisters;
        AdapterObject->MapRegisterBase = (PVOID)((PTRANSLATION_ENTRY)AdapterObject->MapRegisterBase + 
                                                 NumberOfMapRegisters);

    } else if (action == KeepObject) {

        AdapterObject->AdapterInUse = TRUE;

    }

    return(STATUS_SUCCESS);
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{

    AdapterObject->AdapterInUse = FALSE;
}

PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    ULONG logicalAddress;
    PULONG pageFrame;
    PUCHAR bytePointer;
    UCHAR adapterMode;
    UCHAR dataByte;
    PTRANSLATION_ENTRY translationEntry;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS ReturnAddress;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;
    transferLength = *Length;

    //
    // Determine if the data transfer needs to use the map buffer.
    //

    if (translationEntry && !masterDevice &&
        ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, transferLength) > 1) {

        logicalAddress = translationEntry->PhysicalAddress;
        useBuffer = TRUE;

    } else {

        //
        // The transfer can only be done for one page.
        //



        transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
        pageFrame = (PULONG)(Mdl+1);
        pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) Mdl->StartVa) / PAGE_SIZE;
        logicalAddress = (*pageFrame << PAGE_SHIFT) + BYTE_OFFSET(CurrentVa);

        //
        // If the buffer is contigous and does not cross a 64 K bountry then
        // just extend the buffer.
        //

        while( transferLength < *Length ){

            if ( (*pageFrame + 1) != *(pageFrame + 1) ||
                 (*pageFrame & ~0x0ffff) != (*(pageFrame + 1) & ~0x0ffff)) {
                    break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;

        }


        transferLength = transferLength > *Length ? *Length : transferLength;

        useBuffer = FALSE;
    }

    //
    // Check to see if this device has any map registers allocated. If it
    // does, then it must require memory to be at less than 16 MB.  If the
    // logical address is greater than 16MB then map registers must be used
    //

    if (translationEntry && logicalAddress >= MAXIMUM_PHYSICAL_ADDRESS) {

        logicalAddress = (translationEntry + translationEntry->Index)->
            PhysicalAddress;
        useBuffer = TRUE;

    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Copy the data if necessary.
    //

    if (useBuffer && WriteToDevice) {

        HalpCopyBufferMap(
            Mdl,
            translationEntry + translationEntry->Index,
            CurrentVa,
            *Length,
            WriteToDevice
            );

    }

    //
    // If there are map registers, then update the index to indicate
    // how many have been used.
    //

    if (translationEntry) {

        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
            CurrentVa,
            transferLength
            );

    }

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    if (masterDevice) {

        //
        // We only support 32 bits, but the return is 64.  Just
        // zero extend
        //

        ReturnAddress.QuadPart = logicalAddress;
        return(ReturnAddress);
    }

    //
    // Determine the mode based on the transfer direction.
    //

    adapterMode = AdapterObject->AdapterMode;
    ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) (WriteToDevice ?
        WRITE_TRANSFER :  READ_TRANSFER);

    ReturnAddress.QuadPart = logicalAddress;
    bytePointer = (PUCHAR) &logicalAddress;

#if defined(NEC_98)
#else
    if (AdapterObject->Width16Bits) {

        //
        // If this is a 16 bit transfer then adjust the length and the address
        // for the 16 bit DMA mode.
        //

        transferLength >>= 1;

        //
        // In 16 bit DMA mode the low 16 bits are shifted right one and the
        // page register value is unchanged. So save the page register value
        // and shift the logical address then restore the page value.
        //

        dataByte = bytePointer[2];
        logicalAddress >>= 1;
        bytePointer[2] = dataByte;

    }
#endif //NEC_98

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (ULONGLONG)AdapterObject->PagePort,
            bytePointer[2]
            );

#if 0
        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );
#endif

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );

    } else {

#if defined(NEC_98)
#else  //NEC_98
        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[0]
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseAddress,
            bytePointer[1]
            );

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
            (ULONGLONG)AdapterObject->PagePort,
            bytePointer[2]
            );
#if 0

        //
        // Write the high page register with zero value. This enable a special mode
        // which allows ties the page register and base count into a single 24 bit
        // address register.
        //

        WRITE_PORT_UCHAR(
            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
            (ULONG)AdapterObject->PagePort,
            0
            );

#endif
        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) & 0xff)
            );

        WRITE_PORT_UCHAR(
            &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
            .DmaBaseCount,
            (UCHAR) ((transferLength - 1) >> 8)
            );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
             (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
             );
#endif //NEC_98

    }

    return(ReturnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine flushes the DMA adpater object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PULONG pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    BOOLEAN masterDevice;
    BOOLEAN mapped = FALSE;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
        TRUE : FALSE;

    translationEntry = MapRegisterBase;

    //
    // Clear the index of used buffers.
    //

    if (translationEntry) {

        translationEntry->Index = 0;
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice && translationEntry) {

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if (ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length) > 1 &&
            !masterDevice) {

            HalpCopyBufferMap(
                Mdl,
                translationEntry,
                CurrentVa,
                Length,
                WriteToDevice
                );

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = (PULONG)(Mdl+1);
            pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) Mdl->StartVa) / PAGE_SIZE;

            while( transferLength <= Length ){

                if (*pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                    //
                    // Check to see that the MDL is mapped in system space.
                    // If is not mapped, then map it.  This ensures that the
                    // buffer will only have to be mapped at most once per I/O.
                    //

                    if ((Mdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) == 0) {

                        Mdl->MappedSystemVa = MmGetMdlVirtualAddress(Mdl);
                        Mdl->MdlFlags |= MDL_MAPPED_TO_SYSTEM_VA;
                        mapped = TRUE;

                    }

                    HalpCopyBufferMap(
                        Mdl,
                        translationEntry,
                        CurrentVa,
                        partialLength,
                        WriteToDevice
                        );

                }

                CurrentVa = (PCCHAR) CurrentVa + partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame >= BYTES_TO_PAGES(MAXIMUM_PHYSICAL_ADDRESS)) {

                HalpCopyBufferMap(
                    Mdl,
                    translationEntry,
                    CurrentVa,
                    partialLength,
                    WriteToDevice
                    );

            }
        }

    }


    //
    // If this is a master device, then there is nothing more to do so return
    // TRUE.
    //

    if (masterDevice) {

        return(TRUE);

    }

    //
    // Mask the DMA request line so that DMA requests cannot occur.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );

    } else {

        //
        // This request is for DMA controller 2
        //

#if defined(NEC_98)
#else  //NEC_98
        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR(
            &dmaControl->SingleMask,
            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
            );
#endif //NEC_98

    }

    return TRUE;
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

   This routine deallocates the map registers for the adapter.  If there are
   any queued adapter waiting for an attempt is made to allocate the next
   entry.

Arguments:

   AdapterObject - The adapter object to where the map register should be
        returned.

   MapRegisterBase - The map register base of the registers to be deallocated.

   NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

   None

--+*/
{
    PTRANSLATION_ENTRY translationEntry;

    //
    // Determine if this was the last allocation from the adapter. If is was
    // then free the map registers by restoring the map register base and the
    // channel count; otherwise the registers are lost.  This handles the
    // normal case.
    //

    translationEntry = AdapterObject->MapRegisterBase;
    translationEntry -= NumberOfMapRegisters;

    if (translationEntry == MapRegisterBase) {

        //
        // The last allocated registers are being freed.
        //

        AdapterObject->MapRegisterBase = (PVOID) translationEntry;
        AdapterObject->MapRegistersPerChannel += NumberOfMapRegisters;
    }
}

PHYSICAL_ADDRESS
MmGetPhysicalAddress (
     IN PVOID BaseAddress
     )

/*++

Routine Description:

    This function returns the corresponding physical address for a
    valid virtual address.

Arguments:

    BaseAddress - Supplies the virtual address for which to return the
                  physical address.

Return Value:

    Returns the corresponding physical address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    PHYSICAL_ADDRESS PhysicalAddress;
#if !defined(NO_LEGACY_DRIVERS)
    ULONG Index;
#endif

    PhysicalAddress.QuadPart = (ULONG_PTR)BaseAddress & ~KSEG0_BASE;

#if !defined(NO_LEGACY_DRIVERS)
//
// This is not used under EFI -- the HalPT is only setup immediately
// before calling ExitBootServices(), and this routine is really only
// necessary if you are using ntbootdd.sys.
//
    //
    // If the address is in the hal map range, get the physical
    // addressed mapped by the pte
    //

    if (((ULONG_PTR) BaseAddress) >= 0xe0000000ffc00000) {
        Index = (ULONG) ((PhysicalAddress.QuadPart >> PAGE_SHIFT) & 0x3ff);
        PhysicalAddress.QuadPart = HalPT[Index].PageFrameNumber << PAGE_SHIFT;
        PhysicalAddress.QuadPart |= (ULONG_PTR)BaseAddress & (PAGE_SIZE-1);
    }
#endif

    return(PhysicalAddress);
}

PVOID
MmAllocateNonCachedMemory (
    IN SIZE_T NumberOfBytes
    )

/*++

Routine Description:

    This function allocates a range of noncached memory in
    the non-paged portion of the system address space.

    This routine is designed to be used by a driver's initialization
    routine to allocate a noncached block of virtual memory for
    various device specific buffers.

Arguments:

    NumberOfBytes - Supplies the number of bytes to allocate.

Return Value:

    NULL - the specified request could not be satisfied.

    NON-NULL - Returns a pointer (virtual address in the nonpaged portion
               of the system) to the allocated phyiscally contiguous
               memory.

Environment:

    Kernel mode, IRQL of APC_LEVEL or below.

--*/

{
    PVOID BaseAddress;
    ULONG bytesToAllocate;

    bytesToAllocate = (ULONG)NumberOfBytes;

    //
    // Allocated the memory.
    //

    BaseAddress = BlAllocateHeap(bytesToAllocate);
    return BaseAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\memory.c ===
/*++


Copyright (c) 1990, 1991  Microsoft Corporation


Module Name:

    memory.c

Abstract:

    This module sets up the memory subsystem so that virtual addresses map 1:1
    with physical addresses.  It also tweaks the EFI-supplied memory map for 
    use by the loader.  This mapping occurs as follows:

Memory Map used by NTLDR:

    0 - 1MB         Legacy BIOS area, marked as unusable
    
    32 MB - 48 MB   used for diamond decompression engine

    48 MB - 64 MB   used for loading kernel and hal (the kernel must be loaded on a 16 MB boundary)
    
    64 MB - 128 MB  used for loading drivers

    There are not enough TRs to map all memory, so any other memory has a 
    straight 1-1 translation.  Since we use KSEG for our addresses, this 
    means that these ranges are effectively unaddressable.
        
Author:

    John Vert (jvert) 18-Jun-1991        

Environment:

    Kernel Mode


Revision History:

    Andrew Ritz (andrewr) 15-Dec-2000  - added comments and major cleanup for
                                         running under EFI

--*/

#include "arccodes.h"
#include "bootia64.h"
#include "efi.h"

extern EFI_SYSTEM_TABLE *EfiST;

WCHAR DebugBuffer[512];

//
// Current heap start pointers (physical addresses)
// Note that 0x50000 to 0x5ffff is reserved for detection configuration memory
//

#if FW_HEAP
ULONG_PTR FwPermanentHeap = PERMANENT_HEAP_START * PAGE_SIZE;
ULONG_PTR FwTemporaryHeap = (TEMPORARY_HEAP_START * PAGE_SIZE) - 0x10000;

//
// Current pool pointers.  This is different than the temporary/permanent
// heaps, because it is not required to be under 1MB.  It is used by the
// SCSI miniports for allocating their extensions and for the dbcs font image.
//

#define FW_POOL_SIZE (0x40000/PAGE_SIZE)
ULONG_PTR FwPoolStart;
ULONG_PTR FwPoolEnd;

//
// This gets set to FALSE right before we call into the osloader, so we
// know that the fw memory descriptors can no longer be changed at will.
//
BOOLEAN FwDescriptorsValid = TRUE;
#endif
//
// External function prototypes
//
extern
ARC_STATUS
MempGoVirtual (
    VOID
    );

//
// Private function prototypes
//

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

//
// Global - memory management variables.
//

PHARDWARE_PTE PDE;
PHARDWARE_PTE HalPT;

//
// Global memory array that is used by the loader to construct the 
// MemoryDescriptorList which is passed into the OS.
//
PMEMORY_DESCRIPTOR MDArray;
//
// These help us keep track of the memory descriptor array and are used
// in the allocation and insertion routines
//
ULONG NumberDescriptors=0;
ULONG MaxDescriptors=0;

extern GoneVirtual;



ARC_STATUS
InitializeMemorySubsystem(
    PBOOT_CONTEXT BootContext
    )
/*++

Routine Description:

    The initial heap is mapped and allocated. Pointers to the
    Page directory and page tables are initialized.

Arguments:

    BootContext - Supplies basic information provided by SU module.

Returns:

    ESUCCESS - Memory succesfully initialized.

--*/

{
    ARC_STATUS Status = ESUCCESS;
    PMEMORY_DESCRIPTOR SuMemory;
    ULONG PageStart;
    ULONG PageEnd;
    extern BOOLEAN isOSCHOICE;

    //
    // We already have memory descriptors that describe the physical memory
    // layout on the system.  We must walk this list and do some tweaking
    // to describe our memory layout.
    //

    SuMemory = MDArray;
    while (SuMemory->PageCount != 0) {
        PageStart = SuMemory->BasePage;
        PageEnd   = SuMemory->BasePage+SuMemory->PageCount;
#if DBG_MEMORY
        wsprintf( DebugBuffer, L"PageStart (%x), PageEnd (%x), Type (%x)\r\n", PageStart, PageEnd, SuMemory->MemoryType);
        EfiPrint(DebugBuffer);
        DBG_EFI_PAUSE();
#endif

        //
        // we have no TRs for memory under 32MB so we can't use it in
        // the loader -- mark it as off limits
        //
        // Note: PageStart could be 0, so don't check for (PageStart >= _1MB) at this point.
        //
        if ((PageStart < _32MB)  && 
            (SuMemory->MemoryType == MemoryFree)) {
            ULONG TmpPageEnd = (PageEnd > _32MB) ? _32MB : PageEnd;

            Status = MempAllocDescriptor( PageStart, TmpPageEnd,
                                   MemoryFirmwareTemporary );

            if (Status != ESUCCESS) {
               break;
            }

            PageStart = TmpPageEnd;

            if (PageStart != PageEnd ) {
                SuMemory->PageCount -= (PageStart - SuMemory->BasePage);
                SuMemory->BasePage = PageStart;
            }

        }

        //
        // Move to the next memory descriptor
        //

        ++SuMemory;

    }

    if (Status != ESUCCESS) {
#if DBG
        wsprintf( DebugBuffer, TEXT("MempSetDescriptorRegion failed %lx\n"),Status);
        EfiPrint(DebugBuffer);    
#endif
        return(Status);
    }

    //
    // Describe the BIOS area.  We are essentially burning the 1st Meg so the OS
    // can do legacy INT emulation.
    //
    // Note: EFI marks the 1st Meg as "boot services data" so that it won't 
    // touch it.  Once we get into the OS, we need to preserve this same
    // hack (for video card frame buffer, etc).  We only really need to preserve
    // 640K - 1MB, but there is a dependency in the x86 emulation code in the
    // Hal upon this region being zero-based.  So we burn 640K, and that's life.
    //

#if DBG_MEMORY
    wsprintf( DebugBuffer,  L"Mark 'BIOS' region %x - %x as firmware permanent\r\n", 0, ROM_END_PAGE );
    EfiPrint(DebugBuffer);
#endif
    MempSetDescriptorRegion(0, ROM_END_PAGE, MemoryFirmwarePermanent);

    if ((BootContext->MediaType == BootMediaTcpip) &&
        (isOSCHOICE == FALSE)) {
    
        //
        // We RIS-booted setupldr, so make sure 32-128MB is clear.
        // when running oschooser, this memory was used for
        // the loader's heap, etc.  therefore, it is probably
        // marked with the memory type firmware temporary.
        // reclaim it, marking it as free.
        //
        Status = MempSetDescriptorRegion(_32MB,
                                         _128MB,
                                         MemoryFree);
        if( Status != ESUCCESS ) {
            EfiPrint(TEXT("Failed to reclaim 32MB to 128MB!!!"));
        }
    } 
    
        
    //
    //  Make 48mb - 64mb reserved for kernel and 64mb - 128mb reserved for 
    //  driver loading
    //
    //  THIS IS A HACK - the code in blmemory.c:BlMemoryInitialize that 
    //  allocates a region for the heap requires the descriptor the heap will
    //  be carved from to be completely contained in the region the heap must
    //  be allocated in.  We require the heap to reside in the driver region.
    //  The high boundary for this region was preserved from the call in sumain
    //  to memdesc.c:ConstructArcMemoryDescriptorsWithAllocation.  To ensure the
    //  the lower boundary, allocate 1 page of FirmwareTemporary memory.
    //
#if DBG_MEMORY
    wsprintf( DebugBuffer,  L"Mark region %x - %x for systemblock\r\n", _48MB, _80MB );
    EfiPrint(DebugBuffer);
#endif

    Status = MempAllocDescriptor(BL_DRIVER_RANGE_LOW - 1,
                                 BL_DRIVER_RANGE_LOW,
                                 MemoryFirmwareTemporary);

    if (Status != ESUCCESS) {
#if DBG
        wsprintf( DebugBuffer,  L"Mark systemblock region failed %x\r\n", Status );
        EfiPrint(DebugBuffer);
#endif
        return(Status);
    }

#if 0
#if DBG_MEMORY
     
    SuMemory = MDArray;
    while (SuMemory->PageCount != 0) {
        PageStart = SuMemory->BasePage;
        PageEnd   = SuMemory->BasePage+SuMemory->PageCount;

        wsprintf( DebugBuffer, L"dumpmem: PageStart (%x), PageEnd (%x), Type (%x)\r\n", PageStart, PageEnd, SuMemory->MemoryType);
        EfiPrint(DebugBuffer);
        DBG_EFI_PAUSE();

        ++SuMemory;
    }

#endif
#endif

#if DBG
    EfiPrint(TEXT("About to Go Virtual\r\n") );
#endif

    //
    // Setup TR's used by the NT loader and go into virtual addressing mode.
    //
    if ((BootContext->MediaType != BootMediaTcpip) ||
        (isOSCHOICE == TRUE)) {        
#if DBG
        EfiPrint(TEXT("Really going virtual\r\n") );
#endif        
        Status = MempGoVirtual();
    }
    else {
        //
        // always leave this function in virtual mode
        // for consistency
        //
        FlipToVirtual();
    }

    GoneVirtual = TRUE;

    if (Status != ESUCCESS) {
        return(Status);
    }

    return(Status);
}

ARC_STATUS
MempSetDescriptorRegion (
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )
/*++

Routine Description:

    This function sets a range to the corresponding memory type.
    Descriptors will be removed, modified, inserted as needed to
    set the specified range.

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG           i;
    ULONG           sp, ep;
    TYPE_OF_MEMORY  mt;
    BOOLEAN         RegionAdded;

    if (EndPage <= StartPage) {
        //
        // This is a completely bogus memory descriptor. Ignore it.
        //

#ifdef LOADER_DEBUG
        wsprintf( DebugBuffer, TEXT("Attempt to create invalid memory descriptor %lx - %lx\n"),
                StartPage,EndPage);
        EfiPrint(DebugBuffer);
#endif
        return(ESUCCESS);
    }

    RegionAdded = FALSE;

    //
    // Clip, remove, any descriptors in target area
    //

    for (i=0; i < NumberDescriptors; i++) {
        sp = MDArray[i].BasePage;
        ep = MDArray[i].BasePage + MDArray[i].PageCount;
        mt = MDArray[i].MemoryType;

        if (sp < StartPage) {
            if (ep > StartPage  &&  ep <= EndPage) {
                // truncate this descriptor
                ep = StartPage;
            }

            if (ep > EndPage) {
                //
                // Target area is contained totally within this
                // descriptor.  Split the descriptor into two ranges
                //

                if (NumberDescriptors == MaxDescriptors) {
#if DBG
                    wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
                    EfiPrint(DebugBuffer);
#endif
                    return(ENOMEM);
                }

                //
                // Add descriptor for EndPage - ep
                //

                MDArray[NumberDescriptors].MemoryType = mt;
                MDArray[NumberDescriptors].BasePage   = EndPage;
                MDArray[NumberDescriptors].PageCount  = ep - EndPage;
                NumberDescriptors += 1;

                //
                // Adjust current descriptor for sp - StartPage
                //

                ep = StartPage;
            }

        } else {
            // sp >= StartPage

            if (sp < EndPage) {
                if (ep < EndPage) {
                    //
                    // This descriptor is totally within the target area -
                    // remove it
                    //

                    ep = sp;

                }  else {
                    // bump begining page of this descriptor
                    sp = EndPage;
                }
            }
        }

        //
        // Check if the new range can be appended or prepended to
        // this descriptor
        //
        if (mt == MemoryType && !RegionAdded) {
            if (sp == EndPage) {
                // prepend region being set
                sp = StartPage;
                RegionAdded = TRUE;

            } else if (ep == StartPage) {
                // append region being set
                ep = EndPage;
                RegionAdded = TRUE;

            }
        }

        if (MDArray[i].BasePage == sp  &&  MDArray[i].PageCount == ep-sp) {

            //
            // Descriptor was not editted
            //

            continue;
        }

        //
        // Reset this descriptor
        //

        MDArray[i].BasePage  = sp;
        MDArray[i].PageCount = ep - sp;

        if (ep == sp) {

            //
            // Descriptor vanished - remove it
            //

            NumberDescriptors -= 1;
            if (i < NumberDescriptors) {
                //
                // move the last descriptor to this position
                //
                MDArray[i] = MDArray[NumberDescriptors];
            }
            //
            // and reset the last spot, since it is no longer valid
            //
            RtlZeroMemory(&MDArray[NumberDescriptors], sizeof(MEMORY_DESCRIPTOR));

            i--;        // backup & recheck current position
        }
    }

    //
    // If region wasn't already added to a neighboring region, then
    // create a new descriptor now
    //

    if (!RegionAdded  &&  MemoryType < LoaderMaximum) {
        if (NumberDescriptors == MaxDescriptors) {
#if DBG
            wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
            EfiPrint(DebugBuffer);
#endif
            return(ENOMEM);
        }

#ifdef LOADER_DEBUG
        wsprintf( DebugBuffer, TEXT("Adding '%lx - %lx, type %x' to descriptor list\n"),
                StartPage << PAGE_SHIFT,
                EndPage << PAGE_SHIFT,
                (USHORT) MemoryType
                );
        EfiPrint(DebugBuffer);
#endif

        MDArray[NumberDescriptors].MemoryType = MemoryType;
        MDArray[NumberDescriptors].BasePage   = StartPage;
        MDArray[NumberDescriptors].PageCount  = EndPage - StartPage;
        NumberDescriptors += 1;
    }
    return (ESUCCESS);
}

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    )

/*++

Routine Description:

    This routine carves out a specific memory descriptor from the
    memory descriptors that have already been created.  The MD array
    is updated to reflect the new state of memory.

    The new memory descriptor must be completely contained within an
    already existing memory descriptor.  (i.e.  memory that does not
    exist should never be marked as a certain type)

Arguments:

    StartPage  - Supplies the beginning page of the new memory descriptor

    EndPage    - Supplies the ending page of the new memory descriptor

    MemoryType - Supplies the type of memory of the new memory descriptor

Return Value:

    ESUCCESS - Memory descriptor succesfully added to MDL array

    ENOMEM   - MDArray is full.

--*/
{
    ULONG i;

    //
    // Walk through the memory descriptors until we find one that
    // contains the start of the descriptor.
    //
    for (i=0; i<NumberDescriptors; i++) {
        if ((MDArray[i].MemoryType == MemoryFree) &&
            (MDArray[i].BasePage <= StartPage )     &&
            (MDArray[i].BasePage+MDArray[i].PageCount >  StartPage) &&
            (MDArray[i].BasePage+MDArray[i].PageCount >= EndPage)) {

            break;
        }
    }

    if (i==MaxDescriptors) {
#if DBG
        wsprintf( DebugBuffer,  TEXT("NumDescriptors filled (%x) ENOMEM returned %S %d\r\n"), MaxDescriptors, __FILE__, __LINE__ );
        EfiPrint(DebugBuffer);
#endif
        return(ENOMEM);
    }

    if (MDArray[i].BasePage == StartPage) {

        if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

            //
            // The new descriptor is identical to the existing descriptor.
            // Simply change the memory type of the existing descriptor in
            // place.
            //
#if DBG_MEMORY
            wsprintf( DebugBuffer,  TEXT("descriptor (%x) matched -- change type from %x to %x\r\n"), MDArray[i].BasePage, MDArray[i].MemoryType, MemoryType  );
            EfiPrint(DebugBuffer);
#endif
            MDArray[i].MemoryType = MemoryType;
        } else {

            //
            // The new descriptor starts on the same page, but is smaller
            // than the existing descriptor.  Shrink the existing descriptor
            // by moving its start page up, and create a new descriptor.
            //
            if (NumberDescriptors == MaxDescriptors) {
#if DBG_MEMORY
                wsprintf( DebugBuffer,  TEXT("out of descriptors trying to grow (%x) (%x total)\r\n"), MDArray[i].BasePage,NumberDescriptors  );
                EfiPrint(DebugBuffer);
#endif
#if DBG
                wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
                EfiPrint(DebugBuffer);
#endif
                return(ENOMEM);
            }

#if DBG_MEMORY
            wsprintf( 
                DebugBuffer,  
                TEXT("split descriptor starting at %x into two (%x pagecount into %x (size %x) and %x size %x)\r\n"), 
                StartPage,
                MDArray[i].PageCount,
                EndPage,
                MDArray[i].PageCount - (EndPage-StartPage),
                StartPage,
                EndPage-StartPage  );
            EfiPrint(DebugBuffer);
#endif

            MDArray[i].BasePage = EndPage;
            MDArray[i].PageCount -= (EndPage-StartPage);

            MDArray[NumberDescriptors].BasePage = StartPage;
            MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
            MDArray[NumberDescriptors].MemoryType = MemoryType;
            ++NumberDescriptors;

        }
    } else if (MDArray[i].BasePage+MDArray[i].PageCount == EndPage) {

        //
        // The new descriptor ends on the same page.  Shrink the existing
        // by decreasing its page count, and create a new descriptor.
        //
        if (NumberDescriptors == MaxDescriptors) {
#if DBG_MEMORY
            wsprintf( DebugBuffer,  TEXT("out of descriptors trying to shrink (%x) (%x total)\r\n"), MDArray[i].BasePage,NumberDescriptors  );
            EfiPrint(DebugBuffer);
#endif
#if DBG
            wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
            EfiPrint(DebugBuffer);
#endif
            return(ENOMEM);
        }

#if DBG_MEMORY
        wsprintf( 
                DebugBuffer,  
                TEXT("shrink descriptor starting at %x into two (%x pagecount into %x (size %x) and %x size %x, type %x)\r\n"), 
                MDArray[i].BasePage,
                MDArray[i].PageCount,
                MDArray[i].BasePage,
                StartPage - MDArray[i].BasePage,
                StartPage,
                EndPage-StartPage,
                MemoryType  );
        EfiPrint(DebugBuffer);
#endif

        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    } else {

        //
        // The new descriptor is in the middle of the existing descriptor.
        // Shrink the existing descriptor by decreasing its page count, and
        // create two new descriptors.
        //

        if (NumberDescriptors+1 >= MaxDescriptors) {
#if DBG_MEMORY
            wsprintf( DebugBuffer,  TEXT("out of descriptors trying to shrink (%x) (%x total)\r\n"), MDArray[i].BasePage,NumberDescriptors  );
            EfiPrint(DebugBuffer);
#endif
#if DBG
            wsprintf( DebugBuffer,  TEXT("ENOMEM returned %S %d\n"), __FILE__, __LINE__ );
            EfiPrint(DebugBuffer);
#endif
            return(ENOMEM);
        }

#if DBG_MEMORY
        wsprintf( 
            DebugBuffer,  
            TEXT("split descriptor starting at %x into 3 (%x pagecount into %x (size %x), %x size %x (memory free), %x size %x, type %x)\r\n"), 
            MDArray[i].BasePage,
            MDArray[i].PageCount,
            MDArray[i].BasePage,
            StartPage-MDArray[i].BasePage,
            EndPage,
            MDArray[i].PageCount - (EndPage-MDArray[i].BasePage),
            StartPage,
            EndPage-StartPage,
            MemoryType  );
        EfiPrint(DebugBuffer);
#endif

        MDArray[NumberDescriptors].BasePage = EndPage;
        MDArray[NumberDescriptors].PageCount = MDArray[i].PageCount -
                (EndPage-MDArray[i].BasePage);
        MDArray[NumberDescriptors].MemoryType = MemoryFree;
        ++NumberDescriptors;

        MDArray[i].PageCount = StartPage - MDArray[i].BasePage;

        MDArray[NumberDescriptors].BasePage = StartPage;
        MDArray[NumberDescriptors].PageCount = EndPage-StartPage;
        MDArray[NumberDescriptors].MemoryType = MemoryType;
        ++NumberDescriptors;
    }

    return(ESUCCESS);
}

#if FW_HEAP
PVOID
FwAllocateHeapPermanent(
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This allocates pages from the private heap.  The memory descriptor for
    the LoaderMemoryData area is grown to include the returned pages, while
    the memory descriptor for the temporary heap is shrunk by the same amount.

    N.B.    DO NOT call this routine after we have passed control to
            BlOsLoader!  Once BlOsLoader calls BlMemoryInitialize, the
            firmware memory descriptors are pulled into the OS Loader heap
            and those are the descriptors passed to the kernel.  So any
            changes in the firmware private heap will be irrelevant.

            If you need to allocate permanent memory after the OS Loader
            has initialized, use BlAllocateDescriptor.

Arguments:

    NumberPages - size of memory to allocate (in pages)

Return Value:

    Pointer to block of memory, if successful.
    NULL, if unsuccessful.

--*/

{

    PVOID MemoryPointer;
    PMEMORY_DESCRIPTOR Descriptor;

    if (FwPermanentHeap + (NumberPages << PAGE_SHIFT) > FwTemporaryHeap) {

        //
        // Our heaps collide, so we are out of memory
        //

        wsprintf( DebugBuffer, TEXT("Out of permanent heap!\n"));
        EfiPrint(DebugBuffer);
        while (1) {
        }

        return(NULL);
    }

    //
    // Find the memory descriptor which describes the LoaderMemoryData area,
    // so we can grow it to include the just-allocated pages.
    //
    Descriptor = MDArray;
    while (Descriptor->MemoryType != LoaderMemoryData) {
        ++Descriptor;
        if (Descriptor > MDArray+MaxDescriptors) {
            wsprintf( DebugBuffer, TEXT("ERROR - FwAllocateHeapPermanent couldn't find the LoaderMemoryData descriptor!\r\n"));
            EfiPrint(DebugBuffer);            
            return(NULL);
        }
    }
    Descriptor->PageCount += NumberPages;

    //
    // We know that the memory descriptor after this one is the firmware
    // temporary heap descriptor.  Since it is physically contiguous with our
    // LoaderMemoryData block, we remove the pages from its descriptor.
    //

    ++Descriptor;
    Descriptor->PageCount -= NumberPages;
    Descriptor->BasePage  += NumberPages;

    MemoryPointer = (PVOID)FwPermanentHeap;
    FwPermanentHeap += NumberPages << PAGE_SHIFT;

    return(MemoryPointer);
}


PVOID
FwAllocateHeap(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{
    ULONG i;
    ULONG SizeInPages;
    ULONG StartPage;
    ARC_STATUS Status;

    if (((FwTemporaryHeap - FwPermanentHeap) < Size) && (FwDescriptorsValid)) {
        //
        // Large allocations get their own descriptor so miniports that
        // have huge device extensions don't pull up all of the heap.
        //
        // Note that we can only do this while running in "firmware" mode.
        // Once we call into the osloader, it pulls all the memory descriptors
        // out of the "firmware" and changes to this list will not show
        // up there.
        //
        // We are looking for a descriptor that is MemoryFree and <16Mb.
        //
        SizeInPages = (Size+PAGE_SIZE-1) >> PAGE_SHIFT;

        for (i=0; i<NumberDescriptors; i++) {
            if ((MDArray[i].MemoryType == MemoryFree) &&
                (MDArray[i].PageCount >= SizeInPages)) {
                break;
            }
        }

        if (i < NumberDescriptors) {
            StartPage = MDArray[i].BasePage+MDArray[i].PageCount-SizeInPages;
            Status = MempAllocDescriptor(StartPage,
                                         StartPage+SizeInPages,
                                         MemoryFirmwareTemporary);
            if (Status==ESUCCESS) {
                return((PVOID)(ULONG_PTR)(StartPage << PAGE_SHIFT));
            }
        }
    }

    FwTemporaryHeap -= Size;

    //
    // Round down to 16-byte boundary
    //

    FwTemporaryHeap &= ~((ULONG)0xf);

    if (FwTemporaryHeap < FwPermanentHeap) {
#if DBG
        wsprintf( DebugBuffer, TEXT("Out of temporary heap!\n"));
        EfiPrint(DebugBuffer);
#endif
        return(NULL);
    }

    return((PVOID)FwTemporaryHeap);

}
#endif // FW_HEAP

#if FW_HEAP


PVOID
FwAllocatePool(
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the firmware pool.  Note that
    this memory is NOT under the 1MB line, so it cannot be used for
    anything that must be accessed from real mode.  It is currently used
    only by the SCSI miniport drivers and dbcs font loader.
        
Arguments:

    Size - Supplies size of block to allocate.

Return Value:

    PVOID - pointer to the beginning of the block
    NULL - out of memory

--*/

{
    PVOID Buffer;
    ULONG NewSize;

    //
    // round size up to 16 byte boundary
    //
    NewSize = (Size + 15) & ~0xf;
    if ((FwPoolStart + NewSize) <= FwPoolEnd) {

        Buffer = (PVOID)FwPoolStart;
        FwPoolStart += NewSize;
        return(Buffer);

    } else {
        //
        // we've used up all our pool, try to allocate from the heap.
        //
        return(BlAllocateHeap(Size));
    }


}



PVOID
FwAllocateHeapAligned(
    IN ULONG Size
    )

/*++

Routine Description:

    Allocates memory from the "firmware" temporary heap.  This memory is
    always allocated on a page boundary, so it can readily be used for
    temporary page tables

Arguments:

    Size - Supplies size of block to allocate

Return Value:

    PVOID - Pointer to the beginning of the block
    NULL  - Out of memory

--*/

{

    FwTemporaryHeap -= Size;

    //
    // Round down to a page boundary
    //

    FwTemporaryHeap &= ~(PAGE_SIZE-1);

    if (FwTemporaryHeap < FwPermanentHeap) {
        wsprintf( DebugBuffer, TEXT("Out of temporary heap!\n")s);
        EfiPrint(DebugBuffer);
        return(NULL);
    }
    RtlZeroMemory((PVOID)FwTemporaryHeap,Size);

    return((PVOID)FwTemporaryHeap);

}
#endif

#if !defined(NO_LEGACY_DRIVERS)
//
// This isn't used under EFI -- the HalPT is only setup immediately
// before calling ExitBootServices(), and this routine is really
// only present if ntbootdd.sys must be used.
//


PVOID
MmMapIoSpace (
     IN PHYSICAL_ADDRESS PhysicalAddress,
     IN SIZE_T NumberOfBytes,
     IN MEMORY_CACHING_TYPE CacheType
     )

/*++

Routine Description:

    This function returns the corresponding virtual address for a
    known physical address.

Arguments:

    PhysicalAddress - Supplies the phiscal address.

    NumberOfBytes - Unused.

    CacheType - Unused.

Return Value:

    Returns the corresponding virtual address.

Environment:

    Kernel mode.  Any IRQL level.

--*/

{
    ULONG i;
    ULONG j;
    ULONG NumberPages;

    NumberPages = (ULONG)((NumberOfBytes+PAGE_SIZE-1) >> PAGE_SHIFT);

    //
    // We use the HAL's PDE for mapping memory buffers.
    // Find enough free PTEs.
    //

    for (i=0; i<=1024-NumberPages; i++) {
        for (j=0; j < NumberPages; j++) {
            if ((((PULONG)HalPT))[i+j]) {
                break;
            }
        }

        if (j == NumberPages) {
            for (j=0; j<NumberPages; j++) {
                HalPT[i+j].PageFrameNumber =
                                (PhysicalAddress.LowPart >> PAGE_SHIFT)+j;
                HalPT[i+j].Valid = 1;
                HalPT[i+j].Write = 1;
            }

            return((PVOID)((ULONG_PTR)(0xffc00000 | (i<<12) | (PhysicalAddress.LowPart & 0xfff))));
        }
        //
        // page 'i + j' is used.  walk past it
        //
        i += j;

    }
    return(NULL);
}


VOID
MmUnmapIoSpace (
     IN PVOID BaseAddress,
     IN SIZE_T NumberOfBytes
     )

/*++

Routine Description:

    This function unmaps a range of physical address which were previously
    mapped via an MmMapIoSpace function call.

Arguments:

    BaseAddress - Supplies the base virtual address where the physical
                  address was previously mapped.

    NumberOfBytes - Supplies the number of bytes which were mapped.

Return Value:

    None.

Environment:

    Kernel mode, IRQL of DISPATCH_LEVEL or below.

--*/

{
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\memdesc.c ===
#include "bldr.h"
#include "sal.h"
#include "efi.h"
#include "efip.h"
#include "bootia64.h"
#include "smbios.h"
#include "extern.h"

extern EFI_SYSTEM_TABLE *EfiST;

extern EFI_BOOT_SERVICES       *EfiBS;
extern EFI_HANDLE               EfiImageHandle;

extern TR_INFO     Sal;
extern TR_INFO     SalGP;
extern TR_INFO     Pal;
extern ULONGLONG   PalProcPhysical;
extern ULONGLONG   PalPhysicalBase;
extern ULONGLONG   PalTrPs;

extern ULONGLONG   IoPortPhysicalBase;
extern ULONGLONG   IoPortTrPs;


#if DBG
#define DBG_TRACE(_X) EfiPrint(_X)
#else
#define DBG_TRACE(_X)
#endif

//          M E M O R Y   D E S C R I P T O R
//
// Memory Descriptor - each contiguous block of physical memory is
// described by a Memory Descriptor. The descriptors are a table, with
// the last entry having a BlockBase and BlockSize of zero.  A pointer
// to the beginning of this table is passed as part of the BootContext
// Record to the OS Loader.
//

//
// define the number of Efi Pages in an OS page
//

#define EFI_PAGES_PER_OS_PAGE ((EFI_PAGE_SHIFT < PAGE_SHIFT) ? (1 << (PAGE_SHIFT - EFI_PAGE_SHIFT)) : 1)

//
// global values associated with global Efi memory descriptor array
//
ULONGLONG MemoryMapKey;
ULONG     BlPlatformPropertiesEfiFlags = 0;


//
// values to make sure we only get sal,pal,salgp,ioport info once
//
BOOLEAN SalFound = FALSE;
BOOLEAN PalFound = FALSE;
BOOLEAN SalGpFound = FALSE;
BOOLEAN IoPortFound = FALSE;

//
// prototypes for local routines
//

BOOLEAN
pDescriptorContainsAddress(
    EFI_MEMORY_DESCRIPTOR *EfiMd,
    ULONGLONG PhysicalAddress
    );

BOOLEAN
pCoalesceDescriptor(
    MEMORY_DESCRIPTOR *PrevEntry,
    MEMORY_DESCRIPTOR *CurrentEntry
    );

//
// function definitions for routines exported outside
// this file
//

MEMORY_TYPE
EfiToArcType (
    UINT32 Type
    )
/*++

Routine Description:

    Maps an EFI memory type to an Arc memory type.  We only care about a few
    kinds of memory, so this list is incomplete.

Arguments:

    Type - an EFI memory type

Returns:

    A MEMORY_TYPE enumerated type.

--*/
{
    MEMORY_TYPE typeRet=MemoryFirmwarePermanent;


    switch (Type) {
        case EfiLoaderCode:
                 {
                typeRet=MemoryLoadedProgram;       // This gets claimed later
                break;
             }
        case EfiLoaderData:
        case EfiBootServicesCode:
        case EfiBootServicesData:
             {
                 typeRet=MemoryFirmwareTemporary;
                 break;
             }
        case EfiConventionalMemory:
             {
                typeRet=MemoryFree;
                break;
             }
        case EfiUnusableMemory:
             {
                typeRet=MemoryBad;
                break;
             }
        default:
            //
            // all others are memoryfirmwarepermanent
            //
            break;
    }


    return typeRet;


}


VOID
ConstructArcMemoryDescriptorsWithAllocation(
    ULONGLONG LowBoundary,
    ULONGLONG HighBoundary
    )
/*++

Routine Description:

    Builds up memory descriptors for the OS loader.  This routine queries EFI
    for it's memory map (a variable sized array of EFI_MEMORY_DESCRIPTOR's).
    It then allocates sufficient space for the MDArray global (a variable sized
    array of  ARC-based MEMORY_DESCRIPTOR's.)  The routine then maps the EFI
    memory map to the ARC memory map, carving out all of the conventional
    memory space for the EFI loader to help keep the memory map intact.  We
    must leave behind some amount of memory for the EFI boot services to use,
    which we allocate as conventional memory in our map.

    This routine will allocate the memory (using EFI) for the
    EfiMemoryDescriptors

Arguments:

    LowBoundary - The entire Efi Memory descriptor list does not need be
    HigBoundary - translated to Arc descriptors.  Low/High Boundary map
                  the desired region to be mapped.  Their values are
                  addresses (not pages)

Returns:

    NOTHING: If this routine encounters an error, it is treated as fatal
    and the program exits.

--*/
{
    EFI_STATUS Status;
    ULONG i;

    EFI_MEMORY_DESCRIPTOR   *MDEfi = NULL;
    ULONGLONG                MemoryMapSize = 0;
    ULONGLONG                DescriptorSize;
    UINT32                   DescriptorVersion;


    //
    // Get memory map info from EFI firmware
    //
    // To do this, we first find out how much space we need by calling
    // with an empty buffer.
    //

    Status = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                NULL,
                &MemoryMapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (Status != EFI_BUFFER_TOO_SMALL) {
        EfiPrint(L"ConstructArcMemoryDescriptors: GetMemoryMap failed\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // We are going to make a few extra allocations before we call GetMemoryMap
    // again, so add some extra space.
    //
    // 1. EfiMD (a descriptor for us, if we can't fit)
    // 2. MDarray (a descriptor for the MDArray, if not already allocated)
    // 3. Split out memory above and below the desired boundaries
    // and add a few more so we hopefully don't have to reallocate memory
    // for the descriptor
    //
    MemoryMapSize += 3*DescriptorSize;

#if DBG_MEMORY
    wsprintf(DebugBuffer,
             L"ConstructArcMemoryDescriptor: Allocated 0x%x bytes for MDEfi\r\n",
             (ULONG)MemoryMapSize
             );
    EfiPrint(DebugBuffer);
#endif

    //
    // now allocate space for the EFI-based memory map and assign it to the loader
    //
    Status = EfiAllocateAndZeroMemory(EfiLoaderData,
                                      (ULONG) MemoryMapSize,
                                      &MDEfi);
    if (EFI_ERROR(Status)) {
        DBG_TRACE( L"ConstructArcMemoryDescriptors: AllocatePool failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // now Allocate and zero the MDArray, which is the native loader memory
    // map which we need to map the EFI memory map to.
    //
    // The MDArray has one entry for each EFI_MEMORY_DESCRIPTOR, and each entry
    // is MEMORY_DESCRIPTOR large.
    //
    if (MDArray == NULL) {
        i=((ULONG)(MemoryMapSize / DescriptorSize)+1)*sizeof (MEMORY_DESCRIPTOR);

#if DBG_MEMORY
        wsprintf(DebugBuffer,
                 L"ConstructArcMemoryDescriptor: Allocated 0x%x bytes for MDArray\r\n",
                 i
                 );
        EfiPrint(DebugBuffer);
#endif

        Status = EfiAllocateAndZeroMemory(EfiLoaderData,i,&MDArray);
        if (EFI_ERROR(Status)) {
            DBG_TRACE (L"ConstructArcMemoryDescriptors: AllocatePool failed\r\n");
            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
        }
    }

    //
    // we have all of the memory allocated at this point, so retreive the
    // memory map again, which should succeed the second time.
    //
    Status = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                MDEfi,
                &MemoryMapKey,
                &DescriptorSize,
                &DescriptorVersion
                );

    if (EFI_ERROR(Status)) {
        DBG_TRACE(L"ConstructArcMemoryDescriptors: GetMemoryMap failed\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // initialize global variables
    //
    MaxDescriptors = (ULONG)((MemoryMapSize / DescriptorSize)+1); // zero-based

    //
    // construct the arc memory descriptors for the
    // efi descriptors
    //
    ConstructArcMemoryDescriptors(MDEfi,
                                  MDArray,
                                  MemoryMapSize,
                                  DescriptorSize,
                                  LowBoundary,
                                  HighBoundary);

#if DBG_MEMORY
    PrintArcMemoryDescriptorList(MDArray,
                                 NumberDescriptors
                                 );
#endif

}

#define MASK_16MB (ULONGLONG) 0xffffffffff000000I64
#define MASK_16KB (ULONGLONG) 0xffffffffffffc000I64
#define SIZE_IN_BYTES_16KB                    16384

VOID
ConstructArcMemoryDescriptors(
    EFI_MEMORY_DESCRIPTOR *EfiMd,
    MEMORY_DESCRIPTOR     *ArcMd,
    ULONGLONG              MemoryMapSize,
    ULONGLONG              EfiDescriptorSize,
    ULONGLONG              LowBoundary,
    ULONGLONG              HighBoundary
    )
/*++

Routine Description:

    Builds up memory descriptors for the OS loader.  The routine maps the EFI
    memory map to the ARC memory map, carving out all of the conventional
    memory space for the EFI loader to help keep the memory map intact.  We
    must leave behind some amount of memory for the EFI boot services to use,
    which we allocate as conventional memory in our map.

    If consecutive calls are made into ConstructArcMemoryDescriptors,
    the efi routine GetMemoryMap must be called before each instance,
    since we may allocate new pages inside of this routine.  therefore
    a new efi memory map may be required to illustrate these changes.

Arguments:

    EfiMd - a pointer to the efi memory descriptor list that we will be
            constructing arc memory descriptors for.
    ArcMd - (must be allocated).  This will be populated with ARC-based memory
            descriptors corresponding to the EFI Memory Descriptors
    MemoryMapSize - Size of the Efi Memory Map
    EfiDescriptorSize - size of Efi Memory Descriptor
    LowBoundary - The entire Efi Memory descriptor list does not need be
    HigBoundary - translated to Arc descriptors.  Low/High Boundary map
                  the desired region to be mapped.  Their values are
                  addresses (not pages)

Returns:

    Nothing.  Fills in the MDArray global variable.  If this routine encounters
    an error, it is treated as fatal and the program exits.

--*/
{

    EFI_STATUS Status;
    ULONG i;
    ULONGLONG IoPortSize;
    ULONGLONG MdPhysicalStart;
    ULONGLONG MdPhysicalEnd;
    ULONGLONG MdPhysicalSize;
    MEMORY_DESCRIPTOR *OldMDArray = NULL;  // initialize for w4 compiler
    ULONG     OldNumberDescriptors = 0;    // initialize for w4 compiler
    ULONG     OldMaxDescriptors = 0;       // initialize for w4 compiler
    BOOLEAN   ReplaceMDArray = FALSE;
    ULONG     efiMemMapIOWriteCombining = 0;
    ULONG     efiMemMapIO = 0;
    ULONG     efiMainMemoryWC = 0;
    ULONG     efiMainMemoryUC = 0;

    //
    // check to make sure ArcMd is allocated
    //
    if (ArcMd == NULL) {
        EfiPrint(L"ConstructArcMemoryDescriptors: Invalid parameter\r\n");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        return;
    }

    //
    // this is a bit hacky, but instead of changing the functionality of
    // all the other functions (insertdescriptor, adjustarcmemorydescriptor, etc)
    // just have MDArray point to the new ArcMd (if we want to write a new descriptor
    // list.  when we are done, switch it back
    //
    if (MDArray != ArcMd) {
        ReplaceMDArray = TRUE;
        OldMDArray = MDArray;
        OldNumberDescriptors = NumberDescriptors;
        OldMaxDescriptors = MaxDescriptors;
        MDArray = ArcMd;

#if DBG_MEMORY
        EfiPrint(L"ConstructArcMemoryDescriptors: Using alternate Memory Descriptor List\r\n");
#endif

        //
        // perhaps change this functionality.
        // right now a descriptor list besides the global
        // one will always expect to create a whole new list
        // each time
        //
        NumberDescriptors = 0;
        MaxDescriptors = (ULONG)((MemoryMapSize / EfiDescriptorSize)+1); // zero-based

        RtlZeroMemory(MDArray, MemoryMapSize);
    }

#if DBG_MEMORY
    wsprintf( DebugBuffer,
              L"unaligned (LowBoundary, HighBoundary) = (0x%x, 0x%x)\r\n",
              LowBoundary, HighBoundary
              );
    EfiPrint( DebugBuffer );
#endif
    //
    // align boundaries (with OS page size)
    // having this be os page size makes alignment issues easier later
    //
    LowBoundary = (LowBoundary >> PAGE_SHIFT) << PAGE_SHIFT; // this should alway round down
    if (HighBoundary % PAGE_SIZE) {
        // this should round up
        HighBoundary = ((HighBoundary + PAGE_SIZE) >> PAGE_SHIFT << PAGE_SHIFT);
    }
    // make sure that we did not wrap around ...
    if (HighBoundary == 0) {
        HighBoundary = (ULONGLONG)-1;
    }

#if DBG_MEMORY
    wsprintf( DebugBuffer,
              L"aligned (LowBoundary, HighBoundary) = (0x%x, 0x%x)\r\n",
              LowBoundary, HighBoundary
              );
    EfiPrint( DebugBuffer );
#endif

    //
    // now walk the EFI_MEMORY_DESCRIPTOR array, mapping each
    // entry to an arc-based MEMORY_DESCRIPTOR.
    //
    // MemoryMapSize contains actual size of the memory descriptor array.
    //
    for (i = 0; MemoryMapSize > 0; i++) {
#if DBG_MEMORY
        wsprintf( DebugBuffer,
                  L"PageStart (%x), Size (%x), Type (%x)\r\n",
                  (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT),
                  EfiMd->NumberOfPages,
                  EfiMd->Type);
        EfiPrint(DebugBuffer);
        //DBG_EFI_PAUSE();
#endif

        if (EfiMd->NumberOfPages > 0) {
            MdPhysicalStart = EfiMd->PhysicalStart;
            MdPhysicalEnd = EfiMd->PhysicalStart + (EfiMd->NumberOfPages << EFI_PAGE_SHIFT);
            MdPhysicalSize = MdPhysicalEnd - MdPhysicalStart;

#if DBG_MEMORY
            wsprintf( DebugBuffer,
                      L"PageStart %x (%x), PageEnd %x (%x), Type (%x)\r\n",
                      MdPhysicalStart, (EfiMd->PhysicalStart >> EFI_PAGE_SHIFT),
                      MdPhysicalEnd, (EfiMd->PhysicalStart >>EFI_PAGE_SHIFT) + EfiMd->NumberOfPages,
                      EfiMd->Type);
            EfiPrint(DebugBuffer);
            //DBG_EFI_PAUSE();
#endif

            //
            // only create arc memory descriptors for the desired region.
            // but always look for efi memory mapped io space.  this is not
            // included in the arc descripter list, but is needed for the
            // tr's to enable virtual mode.
            // also save off any pal information for later.
            //
            if (EfiMd->Type == EfiMemoryMappedIOPortSpace) {
                if (!IoPortFound) {
                    //
                    // save off the Io stuff for later
                    //
                    IoPortPhysicalBase = EfiMd->PhysicalStart;
                    IoPortSize = EfiMd->NumberOfPages << EFI_PAGE_SHIFT;
                    MEM_SIZE_TO_PS(IoPortSize, IoPortTrPs);

                    IoPortFound = TRUE;
                }
#if DBG_MEMORY
                else {
                    EfiPrint(L"Ignoring IoPort.\r\n");
                }
#endif
            }
            else if (EfiMd->Type == EfiPalCode)    {
                if (!PalFound) {

                    BOOLEAN LargerThan16Mb;
                    ULONGLONG PalTrMask;
                    ULONGLONG PalTrSize;
                    ULONGLONG PalSize;

                    //
                    // save off the Pal stuff for later
                    //
                    PalPhysicalBase = Pal.PhysicalAddressMemoryDescriptor = EfiMd->PhysicalStart;
                    PalSize = EfiMd->NumberOfPages << EFI_PAGE_SHIFT;
                    Pal.PageSizeMemoryDescriptor = (ULONG)EfiMd->NumberOfPages;
                    MEM_SIZE_TO_PS(PalSize, PalTrPs);
                    Pal.PageSize = (ULONG)PalTrPs;


                    //
                    // Copied from Halia64\ia64\i64efi.c
                    //
                    PalTrSize = SIZE_IN_BYTES_16KB;
                    PalTrMask = MASK_16KB;
                    LargerThan16Mb = TRUE;
                    
                    while (PalTrMask >= MASK_16MB) {

                        if ( (Pal.PhysicalAddressMemoryDescriptor + PalSize) <= 
                             ((Pal.PhysicalAddressMemoryDescriptor & PalTrMask) + PalTrSize)) {

                            LargerThan16Mb = FALSE;
                            break;

                        }
                        PalTrMask <<= 2;
                        PalTrSize <<= 2;

                    }

                    //
                    // This is the virtual base adddress of the PAL
                    //
                    Pal.VirtualAddress = VIRTUAL_PAL_BASE + (Pal.PhysicalAddressMemoryDescriptor & ~PalTrMask);

                    //
                    // We've done this already. Remember that
                    //
                    PalFound = TRUE;

                }
#if DBG_MEMORY
                else {
                    EfiPrint(L"Ignoring Pal.\r\n");
                }
#endif
            }
            else if (EfiMd->Type == EfiMemoryMappedIO)    {
                //
                // In terms of arc descriptor entry, just ignore this type since
                // it's not real memory -- the system can use ACPI tables to get
                // at this later on.
                //

                efiMemMapIO++;

                //
                // Simply check the attribute for the PlatformProperties global.
                //

                if ( EfiMd->Attribute & EFI_MEMORY_WC )   {
                    efiMemMapIOWriteCombining++;
                }
            }
            //
            // don't insert all memory into the arc descriptor table
            // just the descriptors between the Low/High Boundaries
            // so before we even continue, make sure that some part
            // of the descriptor is in the desired boundary.
            // there are three cases for crossing a boundary
            //     1. the start page (not the end page) is in the boundary
            //     2. the end page (not the start page) is in the boundary
            //     3. the range covers the entire boundary (neither start/end page) in boundary
            //
            // these can be written more simply as:
            // A descriptor is NOT within a region if the entire
            // descriptor is LESS than the region ( MdStart <= MdEnd <= LowBoundary )
            // OR is      GREATER than the region ( HighBoundary <= MdStart <= MdEnd )
            // Therefore we simplify this futher to say
            // Start < HighBoundary && LowBoundary < MdEnd
            else if ( (MdPhysicalStart < HighBoundary) && (LowBoundary < MdPhysicalEnd) ) {
                //
                // Insert conventional memory descriptors with WB flag set
                // into NT loader memory descriptor list.
                //
                if ( (EfiMd->Type == EfiConventionalMemory) &&
                     ((EfiMd->Attribute & EFI_MEMORY_WB) == EFI_MEMORY_WB) ) {

                    ULONGLONG AmountOfMemory;
                    ULONGLONG NumberOfEfiPages;
                    BOOLEAN BrokeRange = FALSE;
                    EFI_PHYSICAL_ADDRESS AllocationAddress = 0;

                    //
                    // adjust the descriptor if not completely in
                    // desired boundary (we know that if we are here at least
                    // part of descriptor is in boundary
                    //
                    if (MdPhysicalStart < LowBoundary) {
#if DBG_MEMORY
                        wsprintf(DebugBuffer,
                                 L"Broke Low (start=0x%x) LowBoundary=0x%x\r\n",
                                 MdPhysicalStart,
                                 LowBoundary);
                        EfiPrint(DebugBuffer);
#endif
                        MdPhysicalStart = LowBoundary;
                        BrokeRange = TRUE;
                    }
                    if (HighBoundary < MdPhysicalEnd) {
#if DBG_MEMORY
                        wsprintf(DebugBuffer,
                                 L"Broke High (end=0x%x) HighBoundary=0x%x\r\n",
                                 MdPhysicalEnd,
                                 HighBoundary);
                        EfiPrint(DebugBuffer);
#endif
                        MdPhysicalEnd = HighBoundary;
                        BrokeRange = TRUE;
                    }

                    //
                    // determine the memory range for this descriptor
                    //
                    AmountOfMemory = MdPhysicalEnd - MdPhysicalStart;
                    NumberOfEfiPages = AmountOfMemory >> EFI_PAGE_SHIFT;

                    if (BrokeRange) {

                        //
                        // allocate pages for the new region
                        //
                        // note: we have 1 descriptor describing up to 3 new regions.
                        // we can change the descriptor but still may have to allocate 2
                        // new regions.  but if we allocate with the same type, they will just
                        // coellesce.
                        // one way to get around this is to allocate the middle page (in this
                        // boundary region) of a different efi memory type (this will cause
                        // efi to break the descriptor into three.  then we can keep
                        // a better record of it in our arc descriptor list
                        //
                        // the possible regions are
                        //    start address - low boundary
                        //    low boundar - high boundary
                        //    high boundary - end address
                        //
                        // have the current descriptor modified for this boundary
                        // region, allocating pages for that below and above us
                        //
                        AllocationAddress = MdPhysicalStart;
                        Status = EfiBS->AllocatePages ( AllocateAddress,
                                                        EfiLoaderData,
                                                        NumberOfEfiPages,
                                                        &AllocationAddress );

#if DBG_MEMORY
                        wsprintf( DebugBuffer,
                                  L"allocate pages @ %x size = %x\r\n",
                                  (MdPhysicalStart >> EFI_PAGE_SHIFT),
                                  NumberOfEfiPages );
                        EfiPrint(DebugBuffer);
                        //DBG_EFI_PAUSE();
#endif

                        if (EFI_ERROR(Status)) {
                            EfiPrint(L"SuMain: AllocPages failed\n");
                            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
                        }
                    }

                    //
                    // now we can finally insert this (possibly modified) descriptor
                    //
                    InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                      (ULONG)((ULONGLONG)AmountOfMemory >> EFI_PAGE_SHIFT),
                                      EfiToArcType(EfiMd->Type)
                                      );

                }
                else {
                    //
                    // some other type -- just insert it without any changes
                    //
                    InsertDescriptor( (ULONG)(MdPhysicalStart >> EFI_PAGE_SHIFT),
                                      (ULONG)(MdPhysicalSize >> EFI_PAGE_SHIFT),
                                      EfiToArcType(EfiMd->Type));
                }
            }
            //
            // try to get the size of the sal.
            //
            if (pDescriptorContainsAddress(EfiMd,Sal.PhysicalAddress)) {
                if (!SalFound) {
                    Sal.PhysicalAddressMemoryDescriptor = EfiMd->PhysicalStart;
                    Sal.PageSizeMemoryDescriptor = (ULONG)EfiMd->NumberOfPages;

                    SalFound = TRUE;
                }
#if DBG_MEMORY
                else {
                    EfiPrint(L"Ignoring Sal.\r\n");
                }
#endif
            }

            //
            // try to get the size of the sal gp.
            //
            if (pDescriptorContainsAddress(EfiMd,SalGP.PhysicalAddress)) {
                if (!SalGpFound) {
                    SalGP.PhysicalAddressMemoryDescriptor = EfiMd->PhysicalStart;
                    SalGP.PageSizeMemoryDescriptor = (ULONG)EfiMd->NumberOfPages;

                    SalGpFound = TRUE;
                }
#if DBG_MEMORY
                else {
                    EfiPrint(L"Ignoring SalGP.\r\n");
                }
#endif
            }

        
            //
            // try to get the cacheability attribute of ACPI Tables.  Remember
            // that the ACPI tables must be cached in the exceptional case where
            // the firmware doesn't map the acpi tables non-cached.
            //
            if ( AcpiTable && pDescriptorContainsAddress(EfiMd,(ULONG_PTR)AcpiTable)) {
                if ( (EfiMd->Attribute & EFI_MEMORY_WB) && !(EfiMd->Attribute & EFI_MEMORY_UC) ) {
                    BlPlatformPropertiesEfiFlags |= HAL_PLATFORM_ACPI_TABLES_CACHED;
                }
            }      

            //
            // if none of EFI MD Main Memory does present Uncacheable or WriteCombining,
            // it's assumed this platform doesn't support Uncacheable or Write Combining
            // in Main Memory.
            //

            if ( EfiMd->Type == EfiConventionalMemory )   {
                if ( EfiMd->Attribute & EFI_MEMORY_WC )  {
                    efiMainMemoryWC++;
                }
                if (EfiMd->Attribute & EFI_MEMORY_UC )  {
                    efiMainMemoryUC++;
                }
            }


        }
        EfiMd = (EFI_MEMORY_DESCRIPTOR *) ( (PUCHAR) EfiMd + EfiDescriptorSize );
        MemoryMapSize -= EfiDescriptorSize;
    }

    //
    // If this platform supports at least 1 MMIO Write Combining EFI MD or if there are
    // no memory mapped I/O entries, then indicate the platform can support write
    // combined accesses to the I/O space.
    //

    if ( efiMemMapIOWriteCombining || (efiMemMapIO == 0))  {
        BlPlatformPropertiesEfiFlags |= HAL_PLATFORM_ENABLE_WRITE_COMBINING_MMIO;
    }

    //
    // If this platform doesn't support Main Memory Uncacheable or Write Combining
    // from a point of view of EFI MDs, let's flag the PlatformProperties global.
    //

    if ( !efiMainMemoryUC )   {
        BlPlatformPropertiesEfiFlags |= HAL_PLATFORM_DISABLE_UC_MAIN_MEMORY;
    }
    if ( !efiMainMemoryWC )  {
        BlPlatformPropertiesEfiFlags |= HAL_PLATFORM_DISABLE_WRITE_COMBINING;
    }

    //
    // reset globals
    //
    if (ReplaceMDArray) {
        MDArray = OldMDArray;
        NumberDescriptors = OldNumberDescriptors;
        MaxDescriptors = OldMaxDescriptors;
    }
}

VOID
InsertDescriptor (
    ULONG  BasePage,
    ULONG  NumberOfPages,
    MEMORY_TYPE MemoryType
    )

/*++

Routine Description:

    This routine inserts a descriptor into the correct place in the
    memory descriptor list.

    The descriptors come in in EFI_PAGE_SIZE pages and must be
    converted to PAGE_SIZE pages.  This significantly complicates things,
    as we must page align the start of descriptors and hte lengths of the
    descriptors.

    pCoalesceDescriptor does the necessary work for coalescing descriptors
    plus converting from EF_PAGE_SIZE to PAGE_SIZE.

Arguments:

    BasePage      - Base page that the memory starts at.

    NumberOfPages - The number of pages starting at memory block to be inserted.

    MemoryType    - An arc memory type describing the memory.

Return Value:

    None.  Updates MDArray global memory array.

--*/

{
    MEMORY_DESCRIPTOR *CurrentEntry, *PriorEntry;

    //
    // grab the pointers for CurrentEntry and PriorEntry.
    // fill in the efi values for CurrentEntry
    //
    PriorEntry = (NumberDescriptors == 0) ? NULL : (MEMORY_DESCRIPTOR *)&MDArray[NumberDescriptors-1];
    CurrentEntry = (MEMORY_DESCRIPTOR *)&MDArray[NumberDescriptors];

    //
    // The last entry had better be empty or the descriptor list is
    // somehow corrupted.
    //
    if (CurrentEntry->PageCount != 0) {
        wsprintf(DebugBuffer,
                 L"InsertDescriptor: Inconsistent Descriptor count(0x%x) (PageCount=0x%x)\r\n",
                 NumberDescriptors,
                 CurrentEntry->PageCount
                 );
        EfiPrint(DebugBuffer);
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
    }

    //
    // fill in values for this entry
    //
    CurrentEntry->BasePage = BasePage;
    CurrentEntry->PageCount = NumberOfPages;
    CurrentEntry->MemoryType = MemoryType;

    //
    // call pCoalesceDescriptor.  this will do all the basepage/pagecount manipulation
    // for EFI_PAGES -> OS_PAGES.
    // the return value is TRUE if the current entry merged with the previous entry,
    // otherwise the descriptor should be added.
    //
    if (pCoalesceDescriptor(PriorEntry, CurrentEntry) == FALSE) {
        NumberDescriptors++;
    }
    else {
        CurrentEntry->BasePage = CurrentEntry->PageCount = CurrentEntry->MemoryType = 0;
    }

#if DBG_MEMORY
    wsprintf( DebugBuffer,
              L"insert new descriptor #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n",
              NumberDescriptors,
              MaxDescriptors,
              CurrentEntry->BasePage,
              CurrentEntry->PageCount,
              CurrentEntry->MemoryType);
    EfiPrint(DebugBuffer);
    //DBG_EFI_PAUSE();
#endif

    return;
}

#ifdef DBG
VOID
PrintArcMemoryDescriptorList(
    MEMORY_DESCRIPTOR *ArcMd,
    ULONG              MaxDesc
    )
{
    ULONG i;

    for (i = 0; i < MaxDesc; i++) {
        //
        // print to console BasePage, EndPage, PageCount, MemoryType
        //
        wsprintf( DebugBuffer,
                  L"#%x BasePage:0x%x  EndPage:0x%x  PageCount:0x%x  MemoryType:0x%x\r\n",
                  i,
                  ArcMd[i].BasePage,
                  ArcMd[i].BasePage + ArcMd[i].PageCount,
                  ArcMd[i].PageCount,
                  ArcMd[i].MemoryType
                  );
        EfiPrint(DebugBuffer);
    }
}
#endif


//
// private function definitions
//

BOOLEAN
pDescriptorContainsAddress(
    EFI_MEMORY_DESCRIPTOR *EfiMd,
    ULONGLONG PhysicalAddress
    )
{
    ULONGLONG MdPhysicalStart, MdPhysicalEnd;

    MdPhysicalStart = (ULONGLONG)EfiMd->PhysicalStart;
    MdPhysicalEnd = MdPhysicalStart + ((ULONGLONG)EfiMd->NumberOfPages << EFI_PAGE_SHIFT);

    if ((PhysicalAddress >= MdPhysicalStart) &&
        (PhysicalAddress < MdPhysicalEnd)) {
#if DBG_MEMORY
        EfiPrint(L"DescriptorContainsAddress: returning TRUE\r\n");
#endif
        return(TRUE);
    }

    return(FALSE);

}

BOOLEAN
pCoalesceDescriptor(
    MEMORY_DESCRIPTOR *PrevEntry,
    MEMORY_DESCRIPTOR *CurrentEntry
    )
/*++

Routine Description:

    This routine attempts to coalesce a memory descriptor with the
    previous descriptor. Note: the arc memory descriptor table
    keeps track of everything in OS pages, and we are getting information
    from the EFI memory descriptor table which is in EFI pages.
    So conversions will be made for PriorEntry since this
    will be in OS pages.

    there are two options, either shrink the previous entry (from the end)
    or shrink the current entry from the begining.  this will be determined
    by each's memory type.

    This routine will align all blocks (they need to be aligned at the end)

    Note: the memory descriptor's memory types need to be in ARC type

Arguments:

    PriorEntry - Previous memory descriptor in MDArray (in OS pages)

    CurrentEntry - Entry we are working on to place in MDArray (in EFI pages)

Return Value:

    BOOLEAN value indicating if coalescing occurred (merged with previous
            entry.  TRUE if so, FALSE otherwise.  Therefore, if TRUE
            is returned, do not add to the descriptor table

--*/
{
    ULONG NumPagesToShrink;
    ULONG NumPagesToExtend;
    BOOLEAN RetVal = FALSE;
    MEMORY_DESCRIPTOR PriorEntry;
    MEMORY_DESCRIPTOR *MemoryDescriptor;
    BOOLEAN ShrinkPrior = FALSE;

    //
    // convert prev entry's page information to be in efi pages
    //
    if (PrevEntry != NULL) {
#if DBG_MEMORY
        wsprintf(DebugBuffer,
                 L"PriorEntry(OsPages): BasePage=0x%x PageCount=0x%x MemoryType=0x%x\r\n",
                 PrevEntry->BasePage,
                 PrevEntry->PageCount,
                 PrevEntry->MemoryType
                 );
        EfiPrint(DebugBuffer);
#endif
        PriorEntry.BasePage = (ULONG)(((ULONGLONG)PrevEntry->BasePage << PAGE_SHIFT) >> EFI_PAGE_SHIFT);
        PriorEntry.PageCount = (ULONG)(((ULONGLONG)PrevEntry->PageCount << PAGE_SHIFT) >> EFI_PAGE_SHIFT);
        PriorEntry.MemoryType = PrevEntry->MemoryType;
    }
    else {
        //
        // initialize for w4 compiler... even though the below if statement
        // will already be true by the time we look at PriorEntry
        //
        PriorEntry.BasePage = PriorEntry.PageCount = PriorEntry.MemoryType = 0;
    }

#if DBG_MEMORY
    wsprintf(DebugBuffer,
             L"PriorEntry(EfiPages): BasePage=0x%x PageCount=0x%x MemoryType=0x%x\r\n",
             PriorEntry.BasePage,
             PriorEntry.PageCount,
             PriorEntry.MemoryType
             );
    EfiPrint(DebugBuffer);
    wsprintf(DebugBuffer,
             L"CurrentEntry(EfiPages): BasePage=0x%x PageCount=0x%x MemoryType=0x%x\r\n",
             CurrentEntry->BasePage,
             CurrentEntry->PageCount,
             CurrentEntry->MemoryType
             );
    EfiPrint(DebugBuffer);

#endif

    //
    // calculate the number of pages we have to move to be on an OS page
    // boundary
    //
    NumPagesToShrink = CurrentEntry->BasePage % EFI_PAGES_PER_OS_PAGE;
    NumPagesToExtend = (NumPagesToShrink != 0) ? (EFI_PAGES_PER_OS_PAGE - NumPagesToShrink) : 0;

#if DBG_MEMORY
    wsprintf(DebugBuffer,
             L"NumPagesToShrink=0x%x, NumPagesToExtend=0x%x\r\n",
             NumPagesToShrink,
             NumPagesToExtend
             );
    EfiPrint(DebugBuffer);
#endif

    //
    // do the simple cases where coealescing is easy or non-existent
    // case 1: No pages to Shrink
    // case 2: this is the first memory descriptor
    // case 3: previous page does not extend to new page
    // case 4: previous descriptor extends past current page... something is messed up
    // or list is not ordered.  assume we are suppose to just insert this entry
    //
    if ( (PrevEntry == NULL) ||
         (NumPagesToShrink == 0 && (PriorEntry.MemoryType != CurrentEntry->MemoryType)) ||
         (PriorEntry.BasePage + PriorEntry.PageCount < CurrentEntry->BasePage - NumPagesToShrink) ||
         (PriorEntry.BasePage + PriorEntry.PageCount > CurrentEntry->BasePage + NumPagesToExtend)
         ) {
        CurrentEntry->BasePage -= NumPagesToShrink;
        CurrentEntry->PageCount += NumPagesToShrink;
    }
    //
    // if none of the previous cases were met, we are going to have to try
    // to coellesce with the previous entry
    //
    else {
#if DBG_MEMORY
        wsprintf(
            DebugBuffer,
            L"must coellesce because the BasePage isn't module PAGE_SIZE (%x mod %x = %x).\r\n",
            CurrentEntry->BasePage,
            EFI_PAGES_PER_OS_PAGE,
            NumPagesToShrink );
        EfiPrint(DebugBuffer);
#endif

        if (CurrentEntry->MemoryType == PriorEntry.MemoryType) {
            //
            // same memory type... coalesce the entire region
            //
            // we are only changing the base page, so we can reuse the code below
            // that converts efi pages to os pages
            //
            RetVal = TRUE;
            PrevEntry->PageCount = CurrentEntry->BasePage + CurrentEntry->PageCount - PriorEntry.BasePage;
            PrevEntry->BasePage = (ULONG)(((ULONGLONG)PrevEntry->BasePage << PAGE_SHIFT) >> EFI_PAGE_SHIFT);

#if DBG_MEMORY
            wsprintf(DebugBuffer,
                     L"Merge with previous entry (basepage=0x%x, pagecount= 0x%x, memorytype=0x%x\r\n",
                     PrevEntry->BasePage,
                     PrevEntry->PageCount,
                     PrevEntry->MemoryType
                     );
            EfiPrint(DebugBuffer);
#endif

        }
        else {
            //
            // determine which end we will shrink
            //
            switch( CurrentEntry->MemoryType ) {
                case MemoryFirmwarePermanent:
                    //
                    // if the current type is permanent, we must steal from the prior entry
                    //
                    ShrinkPrior = TRUE;
                    break;
                case MemoryLoadedProgram:
                    if (PriorEntry.MemoryType == MemoryFirmwarePermanent) {
                        ShrinkPrior = FALSE;
                    } else {
                        ShrinkPrior = TRUE;
                    }
                    break;
                case MemoryFirmwareTemporary:
                    if (PriorEntry.MemoryType == MemoryFirmwarePermanent ||
                        PriorEntry.MemoryType == MemoryLoadedProgram) {
                        ShrinkPrior = FALSE;
                    } else {
                        ShrinkPrior = TRUE;
                    }
                    break;
                case MemoryFree:
                    ShrinkPrior = FALSE;
                    break;
                case MemoryBad:
                    ShrinkPrior = TRUE;
                    break;
                default:
                    EfiPrint(L"SuMain: bad memory type in InsertDescriptor\r\n");
                    EfiBS->Exit(EfiImageHandle, 0, 0, 0);
            }

            if (ShrinkPrior) {
                //
                // shrink the previous descriptor (from the end)
                //
                //  we can just subtrace 1 OS page from the previous entry,
                // since we can never Shrink more than one OS page.
                //
                PrevEntry->PageCount--;
                CurrentEntry->BasePage -= NumPagesToShrink;
                CurrentEntry->PageCount += NumPagesToShrink;

                //
                // if we shrunk this to nothing, get rid of it
                //
                if (PrevEntry->PageCount == 0) {
                    PrevEntry->BasePage = CurrentEntry->BasePage;
                    PrevEntry->PageCount = CurrentEntry->PageCount;
                    PrevEntry->MemoryType = CurrentEntry->MemoryType;
                    CurrentEntry->BasePage = CurrentEntry->PageCount = CurrentEntry->MemoryType = 0;
                    RetVal = TRUE;
                }

#if DBG_MEMORY
                wsprintf(DebugBuffer,
                         L"Shrink previous descriptor by 0x%x EFI pages\r\n",
                         NumPagesToShrink
                         );
                EfiPrint(DebugBuffer);
#endif
            }
            else {
                //
                // shrink the current descriptor (from the start)
                //
                // don't have to touch the previous entry, just
                // shift the current entry to the next os page
                // boundary
                CurrentEntry->BasePage += NumPagesToExtend;
                CurrentEntry->PageCount -= NumPagesToExtend;

                //
                // if we shrunk this to nothing, get rid of it
                //
                if (CurrentEntry->PageCount == 0) {
                    //
                    // need to convert previous entry back to efi pages, so checks work
                    // at the bottome
                    //
                    PrevEntry->BasePage =  (ULONG)(((ULONGLONG)PrevEntry->BasePage << PAGE_SHIFT) >> EFI_PAGE_SHIFT);
                    PrevEntry->PageCount = (ULONG)(((ULONGLONG)PrevEntry->PageCount << PAGE_SHIFT) >> EFI_PAGE_SHIFT);
                    CurrentEntry->BasePage = CurrentEntry->PageCount = CurrentEntry->MemoryType = 0;
                    RetVal = TRUE;
                }

#if DBG_MEMORY
                wsprintf(DebugBuffer,
                         L"Shrink this descriptor by 0x%x EFI pages\r\n",
                         NumPagesToExtend
                         );
                EfiPrint(DebugBuffer);
#endif
            }
        }
    }

    //
    // set one variable to the entry we modified.  that way we can use the same
    // code to convert efi pages to os pages + extend the page count
    //
    MemoryDescriptor = (RetVal == TRUE) ? PrevEntry : CurrentEntry;

#if DBG_MEMORY
    wsprintf(DebugBuffer,
             L"MemoryDescriptor: BasePage=0x%x PageCount=0x%x MemoryType=0x%x\r\n",
             MemoryDescriptor->BasePage,
             MemoryDescriptor->PageCount,
             MemoryDescriptor->MemoryType
             );
    EfiPrint(DebugBuffer);
#endif


    //
    // we think we are done coalescing, and have done so successfully
    // make sure this is indeed the case
    //
    ASSERT( MemoryDescriptor->BasePage % EFI_PAGES_PER_OS_PAGE == 0 );
    if ( MemoryDescriptor->BasePage % EFI_PAGES_PER_OS_PAGE != 0 ) {
        EfiPrint(L"CoalesceDescriptor: BasePage not on OS page boundary\r\n");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
    }

    //
    // great... we did this right.
    // now extend then end of a region to an os page boundary, and
    // set the values to os pages (instead of efi pages)
    //
    NumPagesToExtend = EFI_PAGES_PER_OS_PAGE - (MemoryDescriptor->PageCount % EFI_PAGES_PER_OS_PAGE);
    MemoryDescriptor->PageCount += (NumPagesToExtend == EFI_PAGES_PER_OS_PAGE) ? 0 : NumPagesToExtend;

    ASSERT( MemoryDescriptor->PageCount % EFI_PAGES_PER_OS_PAGE == 0 );
    if ( MemoryDescriptor->PageCount % EFI_PAGES_PER_OS_PAGE != 0 ) {
        EfiPrint(L"CoalesceDescriptor: PageCount not on OS page boundary\r\n");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
    }

    //
    // convert to os pages
    //
    MemoryDescriptor->PageCount = (ULONG)(((ULONGLONG)MemoryDescriptor->PageCount << EFI_PAGE_SHIFT) >> PAGE_SHIFT);
    MemoryDescriptor->BasePage =  (ULONG)(((ULONGLONG)MemoryDescriptor->BasePage  << EFI_PAGE_SHIFT) >> PAGE_SHIFT);

#if DBG_MEMORY
        wsprintf( DebugBuffer,
                  L"descriptor value #%x of %x, BasePage %x, NumberOfPages %x, Type (%x)\r\n",
                  NumberDescriptors, MaxDescriptors, MemoryDescriptor->BasePage,
                  MemoryDescriptor->PageCount, MemoryDescriptor->MemoryType);
        EfiPrint(DebugBuffer);
#endif

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\mca.h ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1991  NCR Corporation

Module Name:

    mca.h

Abstract:

    This module contains the defines and structure definitions for
    Micro Channel machines.

Author:

    David Risner  (o-ncrdr) 21-Jul-1991

Revision History:


--*/

#ifndef _MCA_
#define _MCA_





//
// Define the DMA page register structure (for 8237 compatibility)
//
#if defined(NEC_98)
#else
#ifndef _EISA_
typedef struct _DMA_PAGE{
    UCHAR Reserved1;
    UCHAR Channel2;
    UCHAR Channel3;
    UCHAR Channel1;
    UCHAR Reserved2[3];
    UCHAR Channel0;
    UCHAR Reserved3;
    UCHAR Channel6;
    UCHAR Channel7;
    UCHAR Channel5;
    UCHAR Reserved4[3];
    UCHAR RefreshPage;
} DMA_PAGE, *PDMA_PAGE;

//
// Define DMA 1 address and count structure (for 8237 compatibility)
//

typedef struct _DMA1_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR DmaBaseCount;
} DMA1_ADDRESS_COUNT, *PDMA1_ADDRESS_COUNT;

//
// Define DMA 2 address and count structure (for 8237 compatibility)
//

typedef struct _DMA2_ADDRESS_COUNT {
    UCHAR DmaBaseAddress;
    UCHAR Reserved1;
    UCHAR DmaBaseCount;
    UCHAR Reserved2;
} DMA2_ADDRESS_COUNT, *PDMA2_ADDRESS_COUNT;

//
// Define DMA 1 control register structure (for 8237 compatibility)
//

typedef struct _DMA1_CONTROL {
    DMA1_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR DmaRequest;
    UCHAR SingleMask;
    UCHAR Mode;
    UCHAR ClearBytePointer;
    UCHAR MasterClear;
    UCHAR ClearMask;
    UCHAR AllMask;
} DMA1_CONTROL, *PDMA1_CONTROL;

//
// Define DMA 2 control register structure (for 8237 compatibility)
//

typedef struct _DMA2_CONTROL {
    DMA2_ADDRESS_COUNT DmaAddressCount[4];
    UCHAR DmaStatus;
    UCHAR Reserved1;
    UCHAR DmaRequest;
    UCHAR Reserved2;    
    UCHAR SingleMask;
    UCHAR Reserved3;    
    UCHAR Mode;
    UCHAR Reserved4;    
    UCHAR ClearBytePointer;
    UCHAR Reserved5;    
    UCHAR MasterClear;
    UCHAR Reserved6;    
    UCHAR ClearMask;
    UCHAR Reserved7;    
    UCHAR AllMask;
    UCHAR Reserved8;    
} DMA2_CONTROL, *PDMA2_CONTROL;
#endif //_EISA_
#endif //NEC_98

typedef struct _MCA_DMA_CONTROLLER {
    UCHAR DmaFunctionLsb;               // Offset 0x018
    UCHAR DmaFunctionMsb;               // Offset 0x019
    UCHAR DmaFunctionData;              // Offset 0x01a
    UCHAR Reserved01;
    UCHAR ScbAttentionPort;             // Offset 0x01c
    UCHAR ScbCommandPort;               // Offset 0x01d
    UCHAR Reserved02;
    UCHAR ScbStatusPort;                // Offset 0x01f
} MCA_DMA_CONTROLLER, *PMCA_DMA_CONTROLLER;

//
// Define Programmable Option Select register set
//

typedef struct _PROGRAMMABLE_OPTION_SELECT {
    UCHAR AdapterIdLsb;
    UCHAR AdapterIdMsb;
    UCHAR OptionSelectData1;
    UCHAR OptionSelectData2;
    UCHAR OptionSelectData3;
    UCHAR OptionSelectData4;
    UCHAR SubaddressExtensionLsb;
    UCHAR SubaddressExtensionMsb;
} PROGRAMMABLE_OPTION_SELECT, *PPROGRAMMABLE_OPTION_SELECT;

//
// Define Micro Channel i/o address map
//

typedef struct _MCA_CONTROL {
    DMA1_CONTROL Dma1BasePort;          // Offset 0x000
    UCHAR Reserved0[8];
    UCHAR ExtendedDmaBasePort[8];       // Offset 0x018 
    UCHAR Interrupt1ControlPort0;       // Offset 0x020
    UCHAR Interrupt1ControlPort1;       // Offset 0x021
    UCHAR Reserved1[64 - 1];
    UCHAR SystemControlPortB;           // Offset 0x061
    UCHAR Reserved2[32 - 2];
    DMA_PAGE DmaPageLowPort;            // Offset 0x080
    UCHAR Reserved3;
    UCHAR CardSelectedFeedback;         // Offset 0x091
    UCHAR SystemControlPortA;           // Offset 0x092
    UCHAR Reserved4;
    UCHAR SystemBoardSetup;             // Offset 0x094
    UCHAR Reserved5;
    UCHAR AdapterSetup;                 // Offset 0x096
    UCHAR AdapterSetup2;                // Offset 0x097
    UCHAR Reserved7[8];
    UCHAR Interrupt2ControlPort0;       // Offset 0x0a0
    UCHAR Interrupt2ControlPort1;       // Offset 0x0a1
    UCHAR Reserved8[32-2];
#if defined(NEC_98)
#else
    DMA2_CONTROL Dma2BasePort;          // Offset 0x0c0
    UCHAR Reserved9[32];
    PROGRAMMABLE_OPTION_SELECT Pos;     // Offset 0x100
#endif //NEC_98
} MCA_CONTROL, *PMCA_CONTROL;

//
// Define POS adapter setup equates for use with AdapterSetup field above
//

#define MCA_ADAPTER_SETUP_ON  0x008
#define MCA_ADAPTER_SETUP_OFF 0x000

//
// Define DMA Extended Function register
//

typedef struct _DMA_EXTENDED_FUNCTION {
    UCHAR ChannelNumber : 3;
    UCHAR Reserved      : 1;
    UCHAR Command       : 4;
} DMA_EXTENDED_FUNCTION, *PDMA_EXTENDED_FUNCTION;

//
// Define Command values
//

#define WRITE_IO_ADDRESS         0x00   // write I/O address reg
#define WRITE_MEMORY_ADDRESS     0x20   // write memory address reg
#define READ_MEMORY_ADDRESS      0x30   // read memory address reg
#define WRITE_TRANSFER_COUNT     0x40   // write transfer count reg
#define READ_TRANSFER_COUNT      0x50   // read transfer count reg
#define READ_STATUS              0x60   // read status register
#define WRITE_MODE               0x70   // write mode register
#define WRITE_ARBUS              0x80   // write arbus register
#define SET_MASK_BIT             0x90   // set bit in mask reg
#define CLEAR_MASK_BIT           0xa0   // clear bit in mask reg
#define MASTER_CLEAR             0xd0   // master clear

//
// Define DMA Extended Mode register
//

typedef struct _DMA_EXTENDED_MODE_MCA {
    UCHAR ProgrammedIo      : 1;     // 0 = do not use programmed i/o address
    UCHAR Reserved0         : 1;
    UCHAR DmaOpcode         : 1;     // 0 = verify memory, 1 = data transfer
    UCHAR TransferDirection : 1;     // 0 = read memory, 1 = write memory
    UCHAR Reserved1         : 2;
    UCHAR DmaWidth          : 1;     // 0 = 8bit, 1 = 16bit
    UCHAR Reserved2         : 1;
} DMA_EXTENDED_MODE_MCA, *PDMA_EXTENDED_MODE_MCA;

//
// DMA Extended Mode equates for use with the _DMA_EXTENDED_MODE structure.
//

#define DMA_EXT_USE_PIO       0x01
#define DMA_EXT_NO_PIO        0x00
#define DMA_EXT_VERIFY        0x00
#define DMA_EXT_DATA_XFER     0x01
#define DMA_EXT_WIDTH_8_BIT   0x00
#define DMA_EXT_WIDTH_16_BIT  0x01

//
// DMA mode option definitions
//

#define DMA_MODE_READ          0x00   // read data into memory
#define DMA_MODE_WRITE         0x08   // write data from memory
#define DMA_MODE_VERIFY        0x00   // verify data
#define DMA_MODE_TRANSFER      0x04   // transfer data

// 
// DMA extended mode constants
//

#define MAX_MCA_DMA_CHANNEL_NUMBER  0x07 // maximum MCA DMA channel number
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\miscs.s ===
//++
//
//  Module name
//      miscs.s
//  Author
//      Allen Kay    (allen.m.kay@intel.com)    Jun-12-95
//  Description
//      Misc. assembly functions.
//
//---

#include "ksia64.h"

        .file   "miscs.s"

        .global    PalProcPhysical
        .global    PalPhysicalBase
        .global    PalTrPs
        .global    IoPortPhysicalBase
        .global    IoPortTrPs
        .global    OsLoaderBase

//
// Setup CPU state to go from physical to virtual
//

        LEAF_ENTRY(MempGoVirtual)

        rpT0       = t21
        rpT1       = t20
        rTrPs      = t19
        rPPN       = t18
        rPsr       = t17
        rPsri      = t22
        
//
// Save the state of psr.i before turning it off
//        
        mov     rPsr = psr 
        movl    rpT0  = (1 << PSR_I) 
        ;;      
        and     rPsri =  rpT0, rPsr
        mov     ar.rsc = r0
 
        ;;

        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        movl    t0 = FPSR_FOR_KERNEL
        ;;
        mov     ar.fpsr = t0                   // initialize fpsr
        ;;

        //
        // Initialize Region Registers
        //
        mov     t1 = (START_GLOBAL_RID << RR_RID) | (PAGE_SHIFT << RR_PS) | RR_PS_VE
        movl    t3 = KSEG0_BASE
        ;;
        mov     rr[t3] = t1

        //
        // Invalidate all protection key registers
        //
        mov     t1 = zero
        ;;

Bl_PKRLoop:
        mov     pkr[t1] = zero
        ;;
        add     t1 = 1, t1
        ;;
        cmp.gtu pt0, pt1 = PKRNUM, t1
        ;;
(pt0)   br.cond.sptk.few.clr Bl_PKRLoop
        ;;

        //
        // Setup the 1-to-1 translation for the loader
        //
        
        movl    rpT1 = OsLoaderBase
        ;;
        ld8     rpT0 = [rpT1]
        ;;
        dep     rpT0 = 0, rpT0, 0, PS_4M
        movl    rpT1 = PS_4M       // Min page size.
                                   // Size should include Text/Data/Stack/BackStore/BdPcr.
                                   // SAL TLB Miss handlers provide TC 1:1 mapping.
        ;;
        mov     cr.ifa = rpT0
        movl    t4 = IITR_ATTRIBUTE_PPN_MASK         // construct GR[r]
        movl    t5 = TR_VALUE(1,0,3,0,1,1,0,1)
        ;;

        shl     t2 = rpT1, ITIR_PS
        and     t6 = rpT0, t4                          // t6 is PPN in GR[r]
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_LOADER_INDEX                // pre-assigned index
        mov     t4 = ITR_LOADER_INDEX                // pre-assigned index
        or      t2 = t5, t6                          // t2 is now GR[r]
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t4] = t2
        ;;

        //
        // Setup a 64MB translation for the drivers.
        //
        movl    t0 = KSEG0_BASE + BL_64M
        ;;

        movl    t2 = ITIR_VALUE(0,PS_64M)
        
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_DRIVER0_INDEX
        
        movl    t2 = TR_VALUE(1,BL_64M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

        //
        // Setup 16MB translation for kernel/hal binary.
        //
        movl    t0 = KSEG0_BASE + BL_48M;
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_KERNEL_INDEX
        movl    t2 = TR_VALUE(1,BL_48M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

        //
        // Setup 16MB translation for decompression buffer used by setupldr.
        //
        movl    t0 = KSEG0_BASE + BL_32M;
        ;;

        movl    t2 = ITIR_VALUE(0,PS_16M)
        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = BL_DECOMPRESS_INDEX
        movl    t2 = TR_VALUE(1,BL_32M,3,0,1,1,0,1)
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2

        //
        // Setup translation for I/O port space
        //
        movl    rpT0 = IoPortPhysicalBase            // IO Port base addr
        movl    rpT1 = IoPortTrPs                    // IO Port page size
        movl    t1 = VIRTUAL_IO_BASE
        ;;

        ld8     t0 = [rpT0]
        ld8     rTrPs = [rpT1]
        mov     cr.ifa = t1

        movl    t4 = IITR_ATTRIBUTE_PPN_MASK         // construct GR[r]
        movl    t5 = TR_VALUE(1,0,3,0,1,1,4,1)
        ;;

        shl     t2 = rTrPs, ITIR_PS
        and     t6 = t0, t4                          // t6 is PPN in GR[r]
        ;;

        mov     cr.itir = t2
        ;;

        mov     t3 = DTR_IO_PORT_INDEX               // pre-assigned index
        or      t2 = t5, t6                          // t2 is now GR[r]
        ;;

        itr.d   dtr[t3] = t2

        //
        // Turn on address translation, interrupt, psr.ed, protection key.
        //
        movl    t1 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_IC,1) | MASK_IA64(PSR_AC,1) | MASK_IA64(PSR_DB,1)
        ;;
        or      t1 = t1, rPsr
        ;;
        mov     cr.ipsr = t1

        //
        // Initialize DCR to defer all speculation faults
        //
        mov     t0 = DCR_DEFER_ALL
        ;;
        mov     cr.dcr = t0

        //
        // Prepare to do RFI to return to the caller.
        //


        movl    t0 = return_label
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

return_label:
        mov     v0 = zero
        ;;
        cmp.eq  pt0, pt1 = zero, rPsri
        ;;
(pt1)   ssm     1 << PSR_I              // set PSR.i bit if it was set originally
        srlz.i
        ;;
        LEAF_RETURN
        LEAF_EXIT(MempGoVirtual)


//
// Flip psr.it bit from virtual to physical addressing mode.
//

        LEAF_ENTRY(FlipToPhysical)

        rPsr    = t17
        rPsri   = t18
        rPi     = t19

//
// Save the state of psr.i before turning it off
//        
        mov     rPsr = psr 
        movl    rPi  = (1 << PSR_I)   
        ;;    
        and     rPsri =  rPi, rPsr
        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        mov     rPsr = psr
        movl    t1 = ~ (MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1))
        movl    t2 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1)
        ;;

        and     t1 = t1, rPsr
        ;;
        or      t1 = t1, t2
        ;;
        mov     cr.ipsr = t1



        //
        // Prepare to do RFI to return to the caller.
        //


        movl    t0 = FlipToPhysicalReturn
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

FlipToPhysicalReturn:
        mov     v0 = zero
        ;;
        cmp.eq  pt0, pt1 = zero, rPsri
        ;;
(pt1)   ssm     1 << PSR_I              // set PSR.i bit if it was set originally
        srlz.i
        ;;

        LEAF_RETURN
        LEAF_EXIT(FlipToPhysical)


//
// Flip psr.it bit from physical to virtual addressing mode.
//

        LEAF_ENTRY(FlipToVirtual)

        rPsr    = t17
        rPsri   = t18
        rPi     = t19

//
// Save the state of psr.i before turning it off
//        
        mov     rPsr = psr 
        movl    rPi  = (1 << PSR_I)  
        ;;     
        and     rPsri =  rPi, rPsr
        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        mov     rPsr = psr
        movl    t1 = MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1)
        ;;

        or      t1 = t1, rPsr
        ;;
        mov     cr.ipsr = t1



        //
        // Prepare to do RFI to return to the caller.
        //


        movl    t0 = FlipToVirtualReturn
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

FlipToVirtualReturn:
        mov     v0 = zero
        ;;
        cmp.eq  pt0, pt1 = zero, rPsri
        ;;
(pt1)   ssm     1 << PSR_I              // set PSR.i bit if it was set originally
        srlz.i
        ;;
        LEAF_RETURN
        LEAF_EXIT(FlipToVirtual)


//++
//
// BOOLEAN
// IsPsrDtOn(VOID);
//
// Routine Description:
//
// This function returns the value of psr.dt for this cpu
//
// Arguements:
//
// Return Value:
//
//    psr.dt
//
//--

         LEAF_ENTRY(IsPsrDtOn)

         mov    t0 = psr
         movl   t1 = 1 << PSR_DT
         ;;
         and    t2 = t0, t1
         ;;
         shr.u  v0 = t2, PSR_DT

         LEAF_RETURN

         LEAF_EXIT(IsPsrDtOn)


//
// Clean up TR mappings used only by NT loader.
//

        LEAF_ENTRY(BlTrCleanUp)

        rpT0 = t22
        rPsr = t17

        //
        // purge BL_DECOMPRESS_INDEX
        //
        movl    t0 = PS_16M << PS_SHIFT
        movl    t1 = KSEG0_BASE + BL_32M
        ;;

        ptr.d   t1, t0
        ;;

        //
        // Turn on address translation, interrupt, psr.ed, protection key.
        //
        rsm     (1 << PSR_I)
        ;;
        rsm     (1 << PSR_IC)
        ;;
        srlz.i
        ;;

        //
        // At this point, turn on psr.it so that we can pass control to
        // the kernel.
        //
        mov     rPsr = psr
        movl    t1 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_IC,1) | MASK_IA64(PSR_AC,1) | MASK_IA64(PSR_DB,1)
        ;;
        or      t1 = t1, rPsr
        ;;
        mov     cr.ipsr = t1

        //
        // Prepare to do RFI to return to the caller.
        //

        movl    t0 = BlTrCleanupReturn
        ;;

        mov     cr.iip = t0
        ;;

        mov     cr.ifs = r0
        ;;

        rfi
        ;;

BlTrCleanupReturn:
        mov     v0 = zero
        ;;

        LEAF_RETURN
        LEAF_EXIT (BlTrCleanUp)


//++
//
//  VOID
//  BlpPalProc(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine sets up the correct registers for input into PAL depending on
//      if the call uses static or stacked registers, turns off interrupts, ensures
//      the correct bank registers are being used and calls into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(BlpPalProc)
        NESTED_SETUP(4,3,4,0)
        PROLOGUE_END

        // For both the static and stacked register conventions, load r28 with FunctionID

        mov     r28 = a0

        // If static register calling convention (1-255, 512-767), copy arguments to r29->r31
        // Otherwise, copy to out0->out3 so they are in r32->r35 in PAL_PROC

        mov     t0 = a0
        ;;
        shr     t0 = t0, 8
        ;;
        tbit.z pt0, pt1 = t0, 0
        ;;

        //
        // Static proc: do br not call
        //
(pt0)   mov         r29 = a1
(pt0)   mov         r30 = a2
(pt0)   mov         r31 = a3

        //
        // Stacked call
        //
(pt1)   mov     out0 = a0
(pt1)   mov     out1 = a1
(pt1)   mov     out2 = a2
(pt1)   mov     out3 = a3

        // Load up the address of PAL_PROC and call it

        addl     t1 = @gprel(PalProcPhysical), gp
        ;;
        ld8      t0 = [t1]
        ;;
        mov      bt0 = t0

        // Call into PAL_PROC

(pt0)   addl t1 = @ltoff(PalReturn), gp
        ;;
(pt0)   ld8 t0 = [t1]
        ;;
(pt0)   mov brp = t0
        ;;
        // Disable interrupts

        DISABLE_INTERRUPTS(loc2)
        ;;
        srlz.d
        ;;
(pt0)   br.sptk.many bt0
        ;;
(pt1)   br.call.sptk brp = bt0        
        ;;
PalReturn:
        // Restore the interrupt state

        RESTORE_INTERRUPTS(loc2)
        ;;
        NESTED_RETURN
        NESTED_EXIT(BlpPalProc)

        LEAF_ENTRY(BlpMapRamdiskPages)

        //
        // Setup a 1MB translation for the RAM disk pages. The starting physical
        // address of the translation is the input page number, which must be a
        // multiple of 1MB/8192. The starting virtual address is KSEG0 + 32MB.
        // 
        // rsm to reset PSR.i bit
        //

        rsm     1 << PSR_I    // reset PSR.i bit
        ;;
        rsm     1 << PSR_IC    // reset PSR.ic bit
        ;;

        srlz.d                 // serialize
        ;;
        srlz.i
        ;;

        movl    t0 = KSEG0_BASE
        movl    t2 = ITIR_VALUE(0,PS_1M)
        ;;
        add     t0 = t0, a0
        ;;

        mov     cr.ifa = t0
        ;;
        mov     cr.itir = t2
        ;;

        mov     t3 = BL_LOADER_INDEX
        movl    t2 = TR_VALUE(1,0,3,0,1,1,0,1)
        ;;

        or      t2 = t2, a0
        mov     v0 = t0
        ;;

        itr.d   dtr[t3] = t2
        ;;
        itr.i   itr[t3] = t2
        ;;

        srlz.d                 // serialize
        ;;
        srlz.i
        ;;

        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;        
        ssm     1 << PSR_I              // set PSR.i bit again
        ;;

        srlz.d                 // serialize
        ;;
        srlz.i
        ;;

        LEAF_RETURN
        LEAF_EXIT(BlpMapRamdiskPages)

        LEAF_ENTRY(BlpUnmapRamdiskPages)

        // 
        // rsm to reset PSR.i bit
        //

        rsm     1 << PSR_I    // reset PSR.i bit
        ;;
        rsm     1 << PSR_IC    // reset PSR.ic bit
        ;;

        srlz.d                 // serialize
        ;;
        srlz.i
        ;;

        movl    t0 = KSEG0_BASE
        movl    t2 = ITIR_VALUE(0,PS_1M)
        ;;
        add     t0 = t0, a0
        ;;

        ptr.i   t0, t2
        ;;
        ptr.d   t0, t2
        ;;

        srlz.d                 // serialize
        ;;
        srlz.i
        ;;

        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;        
        ssm     1 << PSR_I              // set PSR.i bit again
        ;;

        srlz.d                 // serialize
        ;;
        srlz.i
        ;;

        LEAF_RETURN
        LEAF_EXIT(BlpUnmapRamdiskPages)

        LEAF_ENTRY(BlpInitializeRamdiskMapping)
        LEAF_RETURN
        LEAF_EXIT(BlpInitializeRamdiskMapping)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\pioflush.c ===
#define IcacheLineSize 32

void __fc (__int64);                     
#pragma intrinsic (__fc)                

void
PioICacheFlush (
    unsigned char *BaseAddress,
    unsigned int Length
    )
{
    unsigned char *EndAddress;
    unsigned long NumberOfLines;

    if (Length < IcacheLineSize) {
        Length = IcacheLineSize;
    }
    
    NumberOfLines = Length / IcacheLineSize;

    if (Length % IcacheLineSize != 0) {
        NumberOfLines = NumberOfLines+1;
    }

    EndAddress = (unsigned char *)(BaseAddress)+(NumberOfLines * IcacheLineSize);
    do {
       __fc((__int64)BaseAddress);
       BaseAddress += IcacheLineSize;
    } while (BaseAddress < EndAddress);

    __synci();
    __isrlz();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\miscc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    miscc.c

Abstract:

    This file contains misc. functions used by NTLDR.

Author:

    Allen Kay (akay) 03-Mar-1999

Environment:

    Kernel mode

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"
#include "bootia64.h"
#include "efi.h"
#include "extern.h"


WCHAR EfiBuffer[256];

void
EfiPrintf(
        IN PWCHAR Format,
        ...
        )
{
    va_list arglist;

    va_start(arglist, Format);

    if (_vsnwprintf( EfiBuffer, sizeof(EfiBuffer), Format, arglist) > 0) {
        EfiPrint(EfiBuffer);
    }

}

typedef struct _PAL_RETURN_VALUES {
    ULONGLONG ReturnValue0;
    ULONGLONG ReturnValue1;
    ULONGLONG ReturnValue2;
    ULONGLONG ReturnValue3;
} PAL_RETURN_VALUES, *PPAL_RETURN_VALUES;

typedef union _PAL_REVISION {
    struct {
        ULONGLONG PalBRevLower:4;
        ULONGLONG PalBRevUpper:4;
        ULONGLONG PalBModel:8;
        ULONGLONG Reserved0:8;
        ULONGLONG PalVendor:8;
        ULONGLONG PalARevision:8;
        ULONGLONG PalAModel:8;
        ULONGLONG Reserved1:16;
    };
    ULONGLONG PalVersion;
} PAL_REVISION;

extern
PAL_RETURN_VALUES
BlpPalProc(
    IN ULONGLONG FunctionIndex,
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3
);


VOID
CallPal(
    IN  ULONGLONG FunctionIndex,
    IN  ULONGLONG Argument0,
    IN  ULONGLONG Argument1,
    IN  ULONGLONG Argument2,
    OUT PULONGLONG ReturnValue0,
    OUT PULONGLONG ReturnValue1,
    OUT PULONGLONG ReturnValue2,
    OUT PULONGLONG ReturnValue3
    )
{
    PAL_RETURN_VALUES RetVal;

    RetVal = BlpPalProc(FunctionIndex, Argument0, Argument1, Argument2);
    *ReturnValue0 = RetVal.ReturnValue0;
    *ReturnValue1 = RetVal.ReturnValue1;
    *ReturnValue2 = RetVal.ReturnValue2;
    *ReturnValue3 = RetVal.ReturnValue3;
}

VOID
ReadProcessorConfigInfo(
    PPROCESSOR_CONFIG_INFO ProcessorConfigInfo
    )
{
    ULONGLONG Status;
    ULONGLONG Reserved;
    ULONGLONG CacheLevels;
    ULONGLONG UniqueCaches;
    ULONGLONG CacheIndex;
    IA64_CACHE_INFO1 CacheInfo1;
    IA64_CACHE_INFO2 CacheInfo2;
    
    if ((PUCHAR) ProcessorConfigInfo >= (PUCHAR) KSEG0_BASE) {
        ProcessorConfigInfo = (PPROCESSOR_CONFIG_INFO)((PUCHAR)ProcessorConfigInfo - KSEG0_BASE);
    }

    ProcessorConfigInfo->CpuId3 = __getReg(CV_IA64_CPUID3);

    CallPal (
        PAL_VM_PAGE_SIZE,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->InsertPageSizeInfo,
        &ProcessorConfigInfo->PurgePageSizeInfo,
        &Reserved
        );

    if (Status) {
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_VM_PAGE_SIZE failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_VM_SUMMARY,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->VmSummaryInfo1.Ulong64,
        &ProcessorConfigInfo->VmSummaryInfo2.Ulong64,
        &Reserved
        );

    if (Status) {
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_VM_SUMMARY failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_RSE_INFO,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->NumOfPhysStackedRegs,
        &ProcessorConfigInfo->RseHints,
        &Reserved
        );

    if (Status) {
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_RSE_INFO failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_PTCE_INFO,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->PtceInfo.PtceBase,
        &ProcessorConfigInfo->PtceInfo.PtceTcCount.Ulong64,
        &ProcessorConfigInfo->PtceInfo.PtceStrides.Ulong64
        );

    if (Status) {
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_PTCE_INFO failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal (
        PAL_PROC_GET_FEATURES,
        0,
        0,
        0,
        &Status,
        &ProcessorConfigInfo->FeaturesImplemented.Ulong64,
        &ProcessorConfigInfo->FeaturesCurSetting.Ulong64,
        &ProcessorConfigInfo->FeaturesSoftControl.Ulong64
        );

    if (Status) {
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_PROC_GET_FEATURES failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    CallPal(
        PAL_CACHE_SUMMARY,
        0,
        0,
        0,
        &Status,
        &CacheLevels,
        &UniqueCaches,
        &Reserved
        );

    if (Status) {
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_CACHE_SUMMARY failed.\r\n");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    if (CacheLevels < 2) {

        EfiPrint(L"ReadProcessorConfigInfo: Invalid number of Cache Levels.\r\n");
        EfiBS->Exit(EfiImageHandle, (EFI_STATUS)-1, 0, 0);
    }

    ProcessorConfigInfo->NumberOfCacheLevels = CONFIG_INFO_CACHE_LEVELS;
    ProcessorConfigInfo->LargestCacheLine = 0;

    if (CacheLevels < CONFIG_INFO_CACHE_LEVELS) {
        ProcessorConfigInfo->NumberOfCacheLevels = (ULONG) CacheLevels;
    }


    for (CacheIndex = 0; CacheIndex < ProcessorConfigInfo->NumberOfCacheLevels; CacheIndex++) {

        CallPal(
            PAL_CACHE_INFO,
            CacheIndex,         // Cache Level
            2,                  // Data or Unified Cache
            0,                  // Not used
            &Status,
            &ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_DCACHE][CacheIndex].Ulong64,
            &ProcessorConfigInfo->CacheInfo2[CONFIG_INFO_DCACHE][CacheIndex].Ulong64,
            &Reserved
            );

        if (Status != 0) {
            EfiPrintf(L"ReadProcessorConfigInfo: PAL call PAL_CACHE_INFO D cache failed. Index = %d, Status = %d\r\n", CacheIndex, Status);
            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
        }
        
        //
        // Detemine the largest stride for memory allocation.
        //

        if ((1UL << ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_DCACHE][CacheIndex].LineSize) >
            ProcessorConfigInfo->LargestCacheLine) {

            ProcessorConfigInfo->LargestCacheLine = 
                1UL << ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_DCACHE][CacheIndex].LineSize;
        }

        //
        // If this is a unified cache then data and instructions are the same so skip 
        // the instruction cache.
        //

        if (ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_DCACHE][CacheIndex].Unified) {

            ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_ICACHE][CacheIndex] = ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_DCACHE][CacheIndex];
            ProcessorConfigInfo->CacheInfo2[CONFIG_INFO_ICACHE][CacheIndex] = ProcessorConfigInfo->CacheInfo2[CONFIG_INFO_DCACHE][CacheIndex];

            continue;
        }

        CallPal(
            PAL_CACHE_INFO,
            CacheIndex,         // Cache Level
            1,                  // Instruction Cache
            0,                  // Not used
            &Status,
            &ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_ICACHE][CacheIndex].Ulong64,
            &ProcessorConfigInfo->CacheInfo2[CONFIG_INFO_ICACHE][CacheIndex].Ulong64,
            &Reserved
            );

        if (Status != 0) {
            EfiPrintf(L"ReadProcessorConfigInfo: PAL call PAL_CACHE_INFO I cache failed. Index = %d, Status = %d\r\n", CacheIndex, Status);
            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
        }

    }

    //
    // Scan the any remaining cache levels for a the maximum line size value.
    //

    for (CacheIndex = ProcessorConfigInfo->NumberOfCacheLevels; CacheIndex < CacheLevels; CacheIndex++) {

        CallPal(
            PAL_CACHE_INFO,
            CacheIndex,         // Cache Level
            2,                  // Data Cache
            0,                  // Not used
            &Status,
            &CacheInfo1.Ulong64,
            &CacheInfo2.Ulong64,
            &Reserved
            );

        if (Status != 0) {
            EfiPrintf(L"ReadProcessorConfigInfo: PAL call PAL_CACHE_INFO Line failed. Index = %d, Status = %d\r\n", CacheIndex, Status);
            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
        }
        
        //
        // Detemine the largest stride for memory allocation.
        //

        if ((1UL << CacheInfo1.LineSize) > ProcessorConfigInfo->LargestCacheLine) {

            ProcessorConfigInfo->LargestCacheLine = 1UL << CacheInfo1.LineSize;
        }

    }

    //
    // We need to retrieve the stride value for the "FC" instruction.  Since the
    // "FC" instruction isn't targetted at a specific cache rather it is
    // supposed to flush all the caches the stride value should be the same for
    // all cache levels.  Unfortunately this isn't currently true for
    // Itanium systems.
    //
    // Fortunately the value for Level 2 (index 1) is correct on both Itanium
    // and McKinley systems.  So we will just retrieve it.
    //

    ProcessorConfigInfo->CacheFlushStride = 1 << (ProcessorConfigInfo->CacheInfo1[CONFIG_INFO_DCACHE][1].Stride);

#if 0
    {

        //
        // Dump out all the cache info for debugging purposes.
        //
        EfiPrintf(L"ReadProcessorConfigInfo: CacheLevels = %d, UniqueCaches = %d\r\n", CacheLevels, UniqueCaches);
        EfiPrintf(L"ReadProcessorConfigInfo: CacheFlushStride = %d, LargestCacheLine = %d\r\n", ProcessorConfigInfo->CacheFlushStride, ProcessorConfigInfo->LargestCacheLine);
 
        for (CacheIndex = 0; CacheIndex < (2 * CacheLevels); CacheIndex++) {

            CallPal(
                PAL_CACHE_INFO,
                CacheIndex >> 1,
                (CacheIndex & 0x01) + 1,
                0,
                &Status,
                &CacheInfo1.Ulong64,
                &CacheInfo2.Ulong64,
                &Reserved
                );

            if (Status == 0) {

                EfiPrintf(L"ReadProcessorConfigInfo: CacheLevel(%s) = %d, ConfigInfo1 = 0x%I64X, ConfigInfo2 = 0x%I64X\r\n",
                         (CacheIndex & 0x01) ? L"Data" : L"Instruction",
                         CacheIndex >> 1,
                         CacheInfo1.Ulong64, CacheInfo2.Ulong64);

                EfiPrintf(L"    Stride = %d, LineSize = %d, Associativity = %d, Attributes = %d, Unified = %d\r\n",
                         CacheInfo1.Stride,
                         CacheInfo1.LineSize,
                         CacheInfo1.Associativity,
                         CacheInfo1.Attributes,
                         CacheInfo1.Unified
                         );

                EfiPrintf(L"    LoadHints = %d, StoreHints = %d, LoadLatency = %d, StoreLatency = %d\r\n",
                         CacheInfo1.LoadHints,
                         CacheInfo1.StoreHints,
                         CacheInfo1.LoadLatency,
                         CacheInfo1.StoreLatency
                         );

                EfiPrintf(L"    CacheSize = %d, TagMSBit = %d, TagLSBit = %d, AliasBoundary = %d\r\n",
                         CacheInfo2.Size,
                         CacheInfo2.TagLeastBit,
                         CacheInfo2.TagMostBit,
                         CacheInfo2.Alias);

            } else {

                EfiPrintf(L"ReadProcessorConfigInfo: PAL call PAL_CACHE_INFO failed, Status = %d.\r\n", Status);

                // EfiBS->Exit(EfiImageHandle, Status, 0, 0);
            }
        }

    }
#endif

    //
    // IA64 Debug Registers info. 
    //

    CallPal (
        PAL_DEBUG_INFO,
        0,
        0,
        0,
        &ProcessorConfigInfo->DebugInfo.Status,
        &ProcessorConfigInfo->DebugInfo.InstDebugRegisterPairs,
        &ProcessorConfigInfo->DebugInfo.DataDebugRegisterPairs,
        0
        );

    if (ProcessorConfigInfo->DebugInfo.Status) {
#if DBG
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_DEBUG_INFO failed.\n\r");
        EfiPrint(L"ReadProcessorConfigInfo: Fixing DebugInfo with architected default values.\n\r");
#endif 
        ProcessorConfigInfo->DebugInfo.InstDebugRegisterPairs = NUMBER_OF_DEBUG_REGISTER_PAIRS;
        ProcessorConfigInfo->DebugInfo.DataDebugRegisterPairs = NUMBER_OF_DEBUG_REGISTER_PAIRS;
    }

    //
    // IA64 Performance Monitor Registers info. 
    //

    CallPal (
        PAL_PERF_MON_INFO,
        (ULONGLONG)&ProcessorConfigInfo->PerfMonInfo.PerfMonCnfgMask[0],
        0,
        0,
        &ProcessorConfigInfo->PerfMonInfo.Status,
        &ProcessorConfigInfo->PerfMonInfo.Ulong64,
        0,
        0
        );

    if (ProcessorConfigInfo->PerfMonInfo.Status) {

        //
        // Workaround known family or models values.
        //
 
        ULONGLONG cpuFamily = (ProcessorConfigInfo->CpuId3 >> 24) && 0xff;
        ULONGLONG counterWidth = 47; // Default McKinley-core Family PMU.

        if ( cpuFamily == 7 )   {
            counterWidth = 32;
        }
      
#if DBG
        EfiPrint(L"ReadProcessorConfigInfo: PAL call PAL_PERF_MON_INFO failed.\n\r");
        EfiPrint(L"ReadProcessorConfigInfo: Fixing PerfMonInfo with architected default values.\n\r");
#endif

        ProcessorConfigInfo->PerfMonInfo.PerfMonGenericPairs = NUMBER_OF_PERFMON_REGISTER_PAIRS;
        ProcessorConfigInfo->PerfMonInfo.ImplementedCounterWidth = counterWidth;
        ProcessorConfigInfo->PerfMonInfo.ProcessorCyclesEventType = 0x12;
        ProcessorConfigInfo->PerfMonInfo.RetiredInstructionBundlesEventType = 0x8;
        ProcessorConfigInfo->PerfMonInfo.PerfMonCnfgMask[0] = (UCHAR)0xff;
        ProcessorConfigInfo->PerfMonInfo.PerfMonCnfgMask[1] = (UCHAR)0xff;
        ProcessorConfigInfo->PerfMonInfo.PerfMonDataMask[0] = (UCHAR)0xff;
        ProcessorConfigInfo->PerfMonInfo.PerfMonDataMask[1] = (UCHAR)0xff;
        ProcessorConfigInfo->PerfMonInfo.PerfMonDataMask[2] = (UCHAR)0x03;
        ProcessorConfigInfo->PerfMonInfo.ProcessorCyclesMask[0] = (UCHAR)0xf0;
        ProcessorConfigInfo->PerfMonInfo.RetiredInstructionBundlesMask[0] = (UCHAR)0xf0;
  
    }

}


VOID
CpuSpecificWork(
    )
/*++

Routine Description:

    This routine checks for CPU ID and applies processor specific workarounds.

Arguments:

    None

Returns:

    None

--*/

{
    ULONGLONG CpuId;
    ULONGLONG CpuFamily;

    CpuId     = __getReg(CV_IA64_CPUID3);
    CpuFamily = (CpuId >> 24) & 0xff;

    //
    // if the processor is an Itanium...
    //
    if (CpuFamily == 7) {

        //
        // We must ensure that the processor and PAL are supported before continuing.
        //

        EnforcePostB2Processor();
        EnforcePostVersion16PAL();
        EfiCheckFirmwareRevision();

#if 0
        //
        // This is redundant since A2 < B3
        //
        CheckForPreA2Processors();
#endif
    }
}

VOID
EnforcePostB2Processor(
    )
/*++

Routine Description:

    This routine checks enforces that the system has a post B2 processor stepping.

Arguments:

    None

Returns:

    None

--*/

{
    ULONGLONG CpuId3;

    CpuId3    = __getReg(CV_IA64_CPUID3);

#if 0
    {
        WCHAR       Buffer[256];
        ULONGLONG   x;

        x = (CpuId3 >> 0) & 0xff;
        wsprintf(Buffer, L"Number = %x\r\n", x);
        EfiPrint(Buffer);

        x = (CpuId3 >> 8) & 0xff;
        wsprintf(Buffer, L"Revision = %x\r\n", x);
        EfiPrint(Buffer);

        x = (CpuId3 >> 16) & 0xff;
        wsprintf(Buffer, L"Model = %x\r\n", x);
        EfiPrint(Buffer);

        x = (CpuId3 >> 24) & 0xff;
        wsprintf(Buffer, L"Family = %x\r\n", x);
        EfiPrint(Buffer);

        x = (CpuId3 >> 32) & 0xff;
        wsprintf(Buffer, L"Archrev = %x\r\n", x);
        EfiPrint(Buffer);

        DBG_EFI_PAUSE();
    }
#endif

    //
    // Block Processor steppings below B3
    //
    // Note: this switch came from: ntos\ke\ia64\initkr.c
    //
    switch (CpuId3) {
    case 0x0007000004: // Itanium, A stepping
    case 0x0007000104: // Itanium, B0 stepping
    case 0x0007000204: // Itanium, B1 stepping
    case 0x0007000304: // Itanium, B2 stepping
        //
        // unsupported steppings
        //
        EfiPrint(L"Your Itanium system contains a pre-B3 stepping processor.\n\r");
        EfiPrint(L"You need to upgrade it to a B3 or later stepping to run Win64.\n\r");
        EfiBS->Exit(EfiImageHandle, 0, 0, 0);
        break;

    case 0x0007000404: // Itanium, B3 stepping
    case 0x0007000504: // Itanium, B4 stepping
    case 0x0007000604: // Itanium, C0 or later stepping
    default:
        //
        // supported steppings, do nothing
        //
        break;
    }

}

VOID
EnforcePostVersion16PAL(
    )

/*++

Routine Description:

    This routine enforces that the system has a PAL version >= 20.

    Note:

    The return value from get PAL version call has the
    PAL B model and revision has the least significant
    16 bits (Intel IA-64 Architecture Software Developer's Manual, Rav. 1.0, Page 11-109).
    We should be using this to determine a minimum PAL revision for the firmware.
    The first byte has the PAL_B_revision which is a monotonically increasing number
    and is 0x17 for Lion 71b and 0x20 for Softsur 103b.
    The PAL_B model indicates the stepping of the processor supported (We can ignore this one).
    So we need to be using PAL B revision for our minimum firmware test.

    Just an FYI:
    There is a disconnect in the PAL_REVISION structure and what appears to be the specified
    PAL revision layout.  We use PAL_B_REVISION to get the PAL version rather than PAL_A_REVISION.

Arguments:

    None

Returns:

    None

--*/

{
    ULONGLONG Status;
    PAL_REVISION MinimumPalVersion;
    PAL_REVISION CurrentPalVersion;
    ULONGLONG Reserved;

#define MIN_PAL_REVISION 0x23

    CallPal (
        PAL_VERSION,
        0,
        0,
        0,
        &Status,
        &MinimumPalVersion.PalVersion,
        &CurrentPalVersion.PalVersion,
        &Reserved
        );

    if (Status) {
        EfiPrint(L"CheckForPreA2Processors: PAL call PAL_VERSION failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

#if 0
    {
        WCHAR       Buffer[256];

        wsprintf(Buffer, L"PalBRevLower = %x\r\n", CurrentPalVersion.PalBRevLower);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"PalBRevUpper = %x\r\n", CurrentPalVersion.PalBRevUpper);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"PalBModel = %x\r\n", CurrentPalVersion.PalBModel);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"Reserved0 = %x\r\n", CurrentPalVersion.Reserved0);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"PalVendor = %x\r\n", CurrentPalVersion.PalVendor);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"PalARevision = %x\r\n", CurrentPalVersion.PalARevision);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"PalAModel = %x\r\n", CurrentPalVersion.PalAModel);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"Reserved1 = %x\r\n", CurrentPalVersion.Reserved1);
        EfiPrint(Buffer);

        DBG_EFI_PAUSE();
    }
#endif

    if (CurrentPalVersion.PalARevision < MIN_PAL_REVISION) {
        WCHAR       Buffer[256];

        wsprintf(Buffer, L"Your Itanium system's PAL version is less than 0x%x.\n\r", MIN_PAL_REVISION);
        EfiPrint(Buffer);

        wsprintf(Buffer, L"To upgrade system's PAL version, please update the system's firmware.\n\r");
        EfiPrint(Buffer);

        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

}



VOID
CheckForPreA2Processors(
    )
{
    ULONGLONG Status;
    PAL_REVISION MinimumPalVersion;
    PAL_REVISION CurrentPalVersion;
    ULONGLONG Reserved;

    CallPal (
        PAL_VERSION,
        0,
        0,
        0,
        &Status,
        &MinimumPalVersion.PalVersion,
        &CurrentPalVersion.PalVersion,
        &Reserved
        );

    if (Status) {
        EfiPrint(L"CheckForPreA2Processors: PAL call PAL_VERSION failed.\n\r");
        EfiBS->Exit(EfiImageHandle, Status, 0, 0);
    }

    //
    // If PalBRevUpper if 0, 1, 3 or 4 then it is A0/A1 stepping.
    //
    if (CurrentPalVersion.PalBModel == 0) {
        if ( (CurrentPalVersion.PalBRevUpper == 0) ||
             (CurrentPalVersion.PalBRevUpper == 1) ||
             (CurrentPalVersion.PalBRevUpper == 3) ||
             (CurrentPalVersion.PalBRevUpper == 4) ) {

            //
            // Since PAL version 27 supports A2 and A3 but
            // it returns 0, we need to special case this and
            // just return.
            //
            if ((CurrentPalVersion.PalBRevUpper == 0) &&
                (CurrentPalVersion.PalBRevLower == 0)    ) {
                return;
            }

            EfiPrint(L"Your Itanium system contains an pre-A2 stepping processor.\n\r");
            EfiPrint(L"You need to upgrade it to an A2 or later stepping to run Win64.\n\r");
            EfiBS->Exit(EfiImageHandle, Status, 0, 0);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\stubs.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This module implements stub routines for the boot code.

Author:

    David N. Cutler (davec) 7-Nov-1990

Environment:

    Kernel mode only.

Revision History:

--*/


#include "bootia64.h"
#include "stdio.h"
#include "stdarg.h"

VOID
KeBugCheck (
    IN ULONG BugCheckCode
    )

/*++

Routine Description:

    This function crashes the system in a controlled manner.

Arguments:

    BugCheckCode - Supplies the reason for the bug check.

Return Value:

    None.

--*/

{

    //
    // Print out the bug check code and break.
    //

    BlPrint(TEXT("\n*** BugCheck (%lx) ***\n\n"), BugCheckCode);
    while(TRUE) {
    };
}

VOID
RtlAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{

    BlPrint( TEXT("\n*** Assertion failed %S in %S line %d\n"),
            FailedAssertion,
            FileName,
            LineNumber );
    if (Message) {
        //bugbug UNICODE
        //BlPrint(Message);
    }

    while (TRUE) {
    }
}

VOID
KiCheckForSoftwareInterrupt (
    KIRQL RequestIrql
    )
{
    UNREFERENCED_PARAMETER( RequestIrql ); 
    BlPrint( TEXT("\n*** Assertion in KiCheckForSoftwareInterrupt\n") );
}

VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )
/*++

Routine Description:

   This function is similar to the kernel routine with the same name. It is
   very simplified relative to the kernel routine as during the boot process
   the environment is much more restrictive. Specifically, we boot
   as a uniprocessor and we always do DMA. Thus, we can simplify this
   code considerably.

   In the kernel, KeFlushIoBuffer() is used to flush the I-cache for the
   PIO cases.  Architecturally, it is required to perform a flush cache,
   sync.i, and srlz.i to invalidate the I-cache. This sequence should
   supports both UP and MP cases (though booting is a UP case only)

Arugements:

   Mdl - Supplies a pointer to a memory descriptor list that describes the
       I/O buffer location. [unused]

   ReadOperation - Supplies a boolean value that determines whether the I/O
       operation is a read into memory. [unused]

   DmaOperation - Supplies a boolean value that deternines whether the I/O
       operation is a DMA operation.

Return Value:

   None.

--*/
{
    UNREFERENCED_PARAMETER( Mdl );
    UNREFERENCED_PARAMETER( ReadOperation );

    //
    // If we are doing something besides a DMA operation, we
    // have a problem. This routine is not designed to handle anything
    // except DMA
    //

    if (!DmaOperation) {
        RtlAssert("!DmaOperation", __FILE__, __LINE__,
                  "Boot version of KeFlushIOBuffers can only handle DMA operations");
        // Never returns
    }
    __mf();
}


NTHALAPI
VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:


    This function is similar to the kernel routine with the same name. It is
    very simplified relative to the kernel routine as during the boot process
    the environment is much more restrictive. Specifically, we boot
    as a uniprocessor.

    This routine is responsible for flushing all write buffers
    and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

    NOTE: In the simulation environment, there is no write buffer and
    nothing needs to be done.

Arguments:

    None

Return Value:

    None.

--*/
{
    //
    // NOTE: The real hardware may need more than this
    //
    __mf();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\ntsetup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntsetup.c

Abstract:

    This module is the tail-end of the OS loader program. It performs all
    IA64 specific allocations and initialize. The OS loader invokes this
    this routine immediately before calling the loaded kernel image.

Author:

    Allen Kay (akay) 19-May-1999
    based on MIPS version by John Vert (jvert) 20-Jun-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"
#include "bootia64.h"
#include "sal.h"
#include "efi.h"
#include "fpswa.h"
#include "extern.h"
#include <stdlib.h>


//
// Define macro to round structure size to next 16-byte boundary
//

#undef ROUND_UP
#define ROUND_UP(x) ((sizeof(x) + 15) & (~15))
#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) <= (_b)) ? (_b) : (_a))

//
// Configuration Data Header
// The following structure is copied from fw\mips\oli2msft.h
// NOTE shielint - Somehow, this structure got incorporated into
//     firmware EISA configuration data.  We need to know the size of the
//     header and remove it before writing eisa configuration data to
//     registry.
//

typedef struct _CONFIGURATION_DATA_HEADER {
            USHORT Version;
            USHORT Revision;
            PCHAR  Type;
            PCHAR  Vendor;
            PCHAR  ProductName;
            PCHAR  SerialNumber;
} CONFIGURATION_DATA_HEADER;

#define CONFIGURATION_DATA_HEADER_SIZE sizeof(CONFIGURATION_DATA_HEADER)

//
// Global Definition: This structure value is setup in sumain.c
//
TR_INFO ItrInfo[8], DtrInfo[8];

extern ULONGLONG MemoryMapKey;
extern ULONG     BlPlatformPropertiesEfiFlags;

//
// Internal function references
//

VOID
BlQueryImplementationAndRevision (
    OUT PULONG ProcessorId,
    OUT PULONG FloatingId
    );

VOID
BlTrCleanUp (
    );

VOID
BlPostProcessLoadOptions(
    PCHAR szOsLoadOptions
    );

VOID
BlpRemapReserve (
    VOID
    );

ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )

/*++

Routine Description:

    This function initializes the IA64 specific kernel data structures
    required by the NT system.

Arguments:

    BlLoaderBlock - Supplies the address of the loader parameter block.

Return Value:

    ESUCCESS is returned if the setup is successfully complete. Otherwise,
    an unsuccessful status is returned.

--*/

{

    ULONG KernelPage;
    ULONGLONG PrcbPage;
    ARC_STATUS Status;
    PHARDWARE_PTE Pde;
    PHARDWARE_PTE HalPT;
    ULONG HalPteOffset;
    PLIST_ENTRY NextMd;

    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PKLDR_DATA_TABLE_ENTRY BiosDataTableEntry;

    EFI_MEMORY_DESCRIPTOR * MemoryMap = NULL;
    ULONGLONG MemoryMapSize = 0;
    ULONGLONG MapKey;
    ULONGLONG DescriptorSize;
    ULONG DescriptorVersion;
    ULONG LastDescriptor;
    EFI_STATUS EfiStatus;

    EFI_GUID FpswaId = EFI_INTEL_FPSWA;
    EFI_HANDLE FpswaImage;
    FPSWA_INTERFACE *FpswaInterface = NULL;
    ULONGLONG BufferSize;
    BOOLEAN FpswaFound = FALSE;

    //
    // Change LoaderReserve memory back to LoaderFirmwareTemporary.
    //

    BlpRemapReserve();

    //
    // Allocate DPC stack pages for the boot processor.
    //

    Status = BlAllocateDescriptor(LoaderStartupDpcStack,
                                  0,
                                  (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Ia64.InterruptStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate kernel stack pages for the boot processor idle thread.
    //

    Status = BlAllocateDescriptor(LoaderStartupKernelStack,
                                  0,
                                  (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->KernelStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate panic stack pages for the boot processor.
    //

    Status = BlAllocateDescriptor(LoaderStartupPanicStack,
                                  0,
                                  (KERNEL_BSTORE_SIZE + KERNEL_STACK_SIZE) >> PAGE_SHIFT,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Ia64.PanicStack =
                (KSEG0_BASE | (KernelPage << PAGE_SHIFT)) + KERNEL_STACK_SIZE;

    //
    // Allocate and zero two pages for the PCR.
    //

    Status = BlAllocateDescriptor(LoaderStartupPcrPage,
                                  0,
                                  2,
                                  (PULONG) &BlLoaderBlock->u.Ia64.PcrPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    BlLoaderBlock->u.Ia64.PcrPage2 = BlLoaderBlock->u.Ia64.PcrPage + 1;
    RtlZeroMemory((PVOID)(KSEG0_BASE | (BlLoaderBlock->u.Ia64.PcrPage << PAGE_SHIFT)),
                  PAGE_SIZE * 2);

    //
    // Allocate and zero four pages for the PDR and one page of memory for
    // the initial processor block, idle process, and idle thread structures.
    //

    Status = BlAllocateDescriptor(LoaderStartupPdrPage,
                                  0,
                                  3,
                                  (PULONG) &BlLoaderBlock->u.Ia64.PdrPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    RtlZeroMemory((PVOID)(KSEG0_BASE | (BlLoaderBlock->u.Ia64.PdrPage << PAGE_SHIFT)),
                  PAGE_SIZE * 3);

    //
    // The storage for processor control block, the idle thread object, and
    // the idle thread process object are allocated from the third page of the
    // PDR allocation. The addresses of these data structures are computed
    // and stored in the loader parameter block and the memory is zeroed.
    //

    PrcbPage = BlLoaderBlock->u.Ia64.PdrPage + 1;
    if ((PAGE_SIZE * 2) >= (ROUND_UP(KPRCB) + ROUND_UP(EPROCESS) + ROUND_UP(ETHREAD))) {
        BlLoaderBlock->Prcb = KSEG0_BASE | (PrcbPage << PAGE_SHIFT);
        BlLoaderBlock->Process = BlLoaderBlock->Prcb + ROUND_UP(KPRCB);
        BlLoaderBlock->Thread = BlLoaderBlock->Process + ROUND_UP(EPROCESS);

    } else {
        return(ENOMEM);
    }

    Status = BlAllocateDescriptor(LoaderStartupPdrPage,
                                  0,
                                  1,
                                  &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    RtlZeroMemory((PVOID)(KSEG0_BASE | ((ULONGLONG) KernelPage << PAGE_SHIFT)),
                   PAGE_SIZE * 1);

    //
    // Add the address of the PAL to the list of Firmware Symbols
    //
    Status = BlAllocateFirmwareTableEntry(
        "Efi-PAL",
        "\\System\\Firmware\\Efi-PAL",
        (PVOID) Pal.VirtualAddress,
        (ULONG) (Pal.PageSizeMemoryDescriptor << EFI_PAGE_SHIFT),
        &BiosDataTableEntry
        );
    if (Status != ESUCCESS) {

        BlPrint(TEXT("BlSetupForNt: Failed to Add EFI-PAL to Firmware Table.\n"));

    }

    //
    // Setup last two entries in the page directory table for HAL and
    // allocate page tables for them.
    //

    Pde = (PHARDWARE_PTE) (KSEG0_BASE|((ULONG_PTR)((BlLoaderBlock->u.Ia64.PdrPage) << PAGE_SHIFT)));

    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].PageFrameNumber = (ULONG) KernelPage;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Valid = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Cache = 0;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Accessed = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Dirty = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Execute = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].Write = 1;
    Pde[(KIPCR & 0xffffffff) >> PDI_SHIFT].CopyOnWrite = 1;

    //
    // 0xFFC00000 is the starting virtual address of Pde[2046].
    //

    HalPT = (PHARDWARE_PTE)(KSEG0_BASE|((ULONG_PTR) KernelPage << PAGE_SHIFT));
    HalPteOffset = GetPteOffset(KI_USER_SHARED_DATA & 0xffffffff);

    HalPT[HalPteOffset].PageFrameNumber = BlLoaderBlock->u.Ia64.PcrPage2;
    HalPT[HalPteOffset].Valid = 1;
    HalPT[HalPteOffset].Cache = 0;
    HalPT[HalPteOffset].Accessed = 1;
    HalPT[HalPteOffset].Dirty = 1;
    HalPT[HalPteOffset].Execute = 1;
    HalPT[HalPteOffset].Write = 1;
    HalPT[HalPteOffset].CopyOnWrite = 1;

    //
    // Fill in the rest of the loader block fields.
    //
    BlLoaderBlock->u.Ia64.AcpiRsdt       = (ULONG_PTR) AcpiTable;

    BlLoaderBlock->u.Ia64.WakeupVector   = WakeupVector;

    //
    // Fill the ItrInfo and DtrInfo fields
    //
    BlLoaderBlock->u.Ia64.EfiSystemTable = (ULONG_PTR) EfiST;

    RtlCopyMemory(&BlLoaderBlock->u.Ia64.Pal, &Pal, sizeof(TR_INFO));
    RtlCopyMemory(&BlLoaderBlock->u.Ia64.Sal, &Sal, sizeof(TR_INFO));
    RtlCopyMemory(&BlLoaderBlock->u.Ia64.SalGP, &SalGP, sizeof(TR_INFO));

    //
    // Fill the Os Loader base for initial OS TR purge.
    //
    {
    ULONGLONG address = OsLoaderBase & ~((1<<PS_4M)-1);
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_LOADER_INDEX].Index = ITR_LOADER_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_LOADER_INDEX].PageSize = PS_4M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_LOADER_INDEX].VirtualAddress  = address; // 1:1 mapping
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_LOADER_INDEX].PhysicalAddress = address;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_LOADER_INDEX].Valid = TRUE;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_LOADER_INDEX].Index = DTR_LOADER_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_LOADER_INDEX].PageSize = PS_4M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_LOADER_INDEX].VirtualAddress  = address; // 1:1 mapping
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_LOADER_INDEX].PhysicalAddress = address;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_LOADER_INDEX].Valid = TRUE;
    }

    //
    // Fill in ItrInfo and DtrInfo for DRIVER0
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].Index = ITR_DRIVER0_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].PageSize = PS_64M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].VirtualAddress = KSEG0_BASE + BL_64M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].PhysicalAddress = BL_64M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER0_INDEX].Valid = TRUE;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].Index = DTR_DRIVER0_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].PageSize = PS_64M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].VirtualAddress = KSEG0_BASE + BL_64M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].PhysicalAddress = BL_64M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER0_INDEX].Valid = TRUE;

    //
    // Fill in ItrInfo and DtrInfo for DRIVER1
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].Index = ITR_DRIVER1_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].PageSize = 0;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].VirtualAddress = 0;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].PhysicalAddress = 0;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_DRIVER1_INDEX].Valid = FALSE;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].Index = DTR_DRIVER1_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].PageSize = 0;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].VirtualAddress = 0;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].PhysicalAddress = 0;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_DRIVER1_INDEX].Valid = FALSE;

    //
    // Fill in ItrInfo and DtrInfo for KERNEL
    //
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].Index = ITR_KERNEL_INDEX;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].VirtualAddress = KSEG0_BASE + BL_48M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].PhysicalAddress = BL_48M;
    BlLoaderBlock->u.Ia64.ItrInfo[ITR_KERNEL_INDEX].Valid = TRUE;

    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].Index = DTR_KERNEL_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].PageSize = PS_16M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].VirtualAddress = KSEG0_BASE + BL_48M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].PhysicalAddress = BL_48M;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_KERNEL_INDEX].Valid = TRUE;

    //
    // Fill in ItrInfo and DtrInfo for IO port
    //
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].Index = DTR_IO_PORT_INDEX;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].PageSize = (ULONG) IoPortTrPs;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].VirtualAddress = VIRTUAL_IO_BASE;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].PhysicalAddress = IoPortPhysicalBase;
    BlLoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].Valid = TRUE;

    //
    // Flush all caches.
    //

    if (SYSTEM_BLOCK->FirmwareVectorLength > (sizeof(PVOID) * FlushAllCachesRoutine)) {
        ArcFlushAllCaches();
    }

    //
    // make memory map by TR's unavailable for kernel use.
    //
    NextMd = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        //
        // lock down pages we don't want the kernel to use.
        // NB. The only reason we need to lock down LoaderLoadedProgram because
        // there is static data in the loader image that the kernel uses.
        //
        if ((MemoryDescriptor->MemoryType == LoaderLoadedProgram) ||
            (MemoryDescriptor->MemoryType == LoaderOsloaderStack)) {

            MemoryDescriptor->MemoryType = LoaderFirmwarePermanent;
        }

        //
        // we've marked lots of memory as off limits to trick our allocator
        // into allocating memory at a specific location (which is necessary to
        // get hte kernel loaded at the right location, etc.). We do this by
        // marking the page type as LoaderSystemBlock.  Now that we're done
        // allocating memory, we can restore all of the LoaderSystemBlock pages
        // to LoaderFree, so that the kernel can use this memory.
        //
        if (MemoryDescriptor->MemoryType == LoaderSystemBlock) {
            MemoryDescriptor->MemoryType = LoaderFree;
        }


        NextMd = MemoryDescriptor->ListEntry.Flink;

    }


    //
    // Go to physical mode before making EFI calls.
    //
    FlipToPhysical();

    //
    // Get processor configuration information
    //

    ReadProcessorConfigInfo( &BlLoaderBlock->u.Ia64.ProcessorConfigInfo );

    //
    // Get FP assist handle
    //
    BufferSize = sizeof(FpswaImage);
    EfiStatus = EfiBS->LocateHandle(ByProtocol,
                                    &FpswaId,
                                    NULL,
                                    &BufferSize,
                                    &FpswaImage
                                   );
    if (!EFI_ERROR(EfiStatus)) {
        //
        // Get FP assist protocol interface.
        //
        EfiStatus = EfiBS->HandleProtocol(FpswaImage, &FpswaId, &FpswaInterface);

        if (EFI_ERROR(EfiStatus)) {
            EfiPrint(L"BlSetupForNt: Could not get FP assist entry point\n");
            EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
        }

        FpswaFound = TRUE;
    }


#if 1
//
// The following code must be fixed to handle ExitBootServices() failing
// because the memory map has changed in between calls to GetMemoryMap and
// the call to ExitBootServices().  We should also walk the EFI memory map
// and correlate it against the MemoryDescriptorList to ensure that all of
// the memory is properly accounted for.
//

    //
    // reconstruct the arc memory descriptors,
    // this time do it for the rest of memory (we only did the
    // first 80 mb last time.)
    // then we need to insert the new descriptors into
    // the loaderblock's memory descriptor list.
    //
    EfiStatus = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                MemoryMap,
                &MapKey,
                &DescriptorSize,
                (UINT32 *)&DescriptorVersion
                );

    if (EfiStatus != EFI_BUFFER_TOO_SMALL) {
        EfiPrint(L"BlSetupForNt: GetMemoryMap failed\r\n");
        EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
    }

    FlipToVirtual();

    Status = BlAllocateAlignedDescriptor(LoaderOsloaderHeap,
                                         0,
                                         (ULONG) BYTES_TO_PAGES(MemoryMapSize),
                                         0,
                                         &KernelPage);

    if (Status != ESUCCESS) {
        return(Status);
    }

    FlipToPhysical();

    //
    // We need a physical address for EFI, and the hal expects a physical
    // address as well.
    //
    MemoryMap = (PVOID)(ULONGLONG)((ULONGLONG)KernelPage << PAGE_SHIFT);

    EfiStatus = EfiBS->GetMemoryMap (
                &MemoryMapSize,
                MemoryMap,
                &MapKey,
                &DescriptorSize,
                (UINT32 *)&DescriptorVersion
                );

    if (EFI_ERROR(EfiStatus)) {
        EfiPrint(L"BlSetupForNt: GetMemoryMap failed\r\n");
        EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
    }


    //
    // Reuse the MDArray from before.
    // zero it out, so we don't coalesce with the last entry in
    // the previous MDArray.
    //
    RtlZeroMemory(MDArray, MaxDescriptors * sizeof(MEMORY_DESCRIPTOR));
    NumberDescriptors = 0;

    //
    // now we can construct the arc memory descriptors
    //
    ConstructArcMemoryDescriptors(MemoryMap,
                                  MDArray,
                                  MemoryMapSize,
                                  DescriptorSize,
                                  BL_DRIVER_RANGE_HIGH << PAGE_SHIFT, // start at 128 mb
                                  (ULONGLONG)-1          // don't have an upper boundary
                                  );

#if DBG_MEMORY
    PrintArcMemoryDescriptorList(MDArray,
                                 NumberDescriptors
                                 );
#endif

    FlipToVirtual();

    //
    // insert the newly constructed arc memory descriptors into
    // the loader block memory descriptor list
    //
    for (LastDescriptor = 0; LastDescriptor < NumberDescriptors; LastDescriptor++) {
        PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;

        //
        // this could potentially be bad... we are allocated memory in between
        // our last memory map call and EFI exit boot services.
        //
        AllocationDescriptor =
            (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

        if (AllocationDescriptor == NULL) {
            DBGTRACE( TEXT("Couldn't allocate heap for memory allocation descriptor\r\n"));
            return ENOMEM;
        }

        AllocationDescriptor->MemoryType =
            (TYPE_OF_MEMORY)MDArray[LastDescriptor].MemoryType;

        if (MDArray[LastDescriptor].MemoryType == MemoryFreeContiguous ||
            MDArray[LastDescriptor].MemoryType == LoaderFirmwareTemporary) {
            AllocationDescriptor->MemoryType = LoaderFree;
        }
        else if (MDArray[LastDescriptor].MemoryType == MemorySpecialMemory) {
            AllocationDescriptor->MemoryType = LoaderSpecialMemory;
        }

        AllocationDescriptor->BasePage = MDArray[LastDescriptor].BasePage;
        AllocationDescriptor->PageCount = MDArray[LastDescriptor].PageCount;

        BlInsertDescriptor(AllocationDescriptor);
    }

    //
    // Post process Load Options.  If the user used the /maxmem
    // switch, we will need to truncate the MemoryDescriptorList
    // here since memory descriptors over 80GB were just added. 
    // 
    BlPostProcessLoadOptions(BlLoaderBlock->LoadOptions);


#if DBG_MEMORY
    NextMd = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextMd,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        wsprintf(DebugBuffer,
                 L"basepage 0x%x pagecount 0x%x memorytype 0x%x\r\n",
                 MemoryDescriptor->BasePage,
                 MemoryDescriptor->PageCount,
                 MemoryDescriptor->MemoryType
                 );
        EfiPrint(DebugBuffer);

        NextMd = MemoryDescriptor->ListEntry.Flink;

    }

    wsprintf(DebugBuffer,
             L"MemoryMap 0x%x MemoryMapPage 0x%x\r\n",
             (ULONGLONG)MemoryMap,
             (ULONGLONG)MemoryMap >> PAGE_SHIFT
             );
    EfiPrint(DebugBuffer);
#endif

    FlipToPhysical();

    //
    // Call EFI exit boot services.  No more Efi calls to boot services
    // API's will be called beyond this point.
    //
    EfiStatus = EfiBS->ExitBootServices (
                EfiImageHandle,
                MapKey
                );

    if (EFI_ERROR(EfiStatus)) {
        EfiPrint(L"BlSetupForNt: ExitBootServices failed\r\n");
        EfiBS->Exit(EfiImageHandle, EfiStatus, 0, 0);
    }
#endif

    //
    // Go back to virtual mode.
    //
    FlipToVirtual();

    //
    // Pass EFI memory descriptor Parameters to kernel through OS
    // loader block.
    //
    BlLoaderBlock->u.Ia64.EfiMemMapParam.MemoryMapSize = MemoryMapSize;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.MemoryMap = (PUCHAR) MemoryMap;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.MapKey = MapKey;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.DescriptorSize = DescriptorSize;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.DescriptorVersion = DescriptorVersion;
    BlLoaderBlock->u.Ia64.EfiMemMapParam.InitialPlatformPropertiesEfiFlags = BlPlatformPropertiesEfiFlags;

    if (FpswaFound) {
        BlLoaderBlock->u.Ia64.FpswaInterface = (ULONG_PTR) FpswaInterface;
    } else {
        BlLoaderBlock->u.Ia64.FpswaInterface = (ULONG_PTR) NULL;
    }

    //
    // Clean up TR's used by boot loader but not needed by ntoskrnl.
    //
    BlTrCleanUp();

    //
    // Flush the memory range where kernel, hal, and the drivers are
    // loaded into.
    //
    PioICacheFlush(KSEG0_BASE+BL_48M, BL_80M);

    return(ESUCCESS);
}

//
// Convert remaining LoaderReserve to MemoryFirmwareTemporary.
//
//

VOID
BlpRemapReserve (
    VOID
    )
{
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);
        if ((NextDescriptor->MemoryType == LoaderReserve)) {
            NextDescriptor->MemoryType = LoaderFirmwareTemporary;
        }
        NextEntry = NextEntry->Flink;
    }

    return;
}


VOID
BlPostProcessLoadOptions(
    PCHAR szOsLoadOptions
    )
/*++

Routine Description:

    The routine does any necessary work for the Load Options 
    when setting up to transfer to the kernel.  
    
    The memory descriptor list needs to be truncated when the user uses /maxmem

Arguments:

    szOsLoadOptions - string with the user defined Load Options

Return Value:

    none

--*/
{
    PCHAR p;
    ULONG MaxMemory;
    ULONG MaxPage;

    //
    // Process MAXMEM (Value is the highest physical
    // address to be used (in MB).
    //
    if( (p = strstr( szOsLoadOptions, "/MAXMEM=" )) != NULL ) {
        MaxMemory = atoi( p + sizeof("/MAXMEM=") - 1 );        
        MaxPage = MaxMemory * ((1024 * 1024) / PAGE_SIZE) - 1;
        BlTruncateDescriptors(MaxPage);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\wake.c ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wake.c

Abstract:

    This module contains architecture dependent support for hibernation
    on IA-64.

Author:

    Allen Kay (allen.m.kay@intel.com)

Revision History:

--*/

#include <bldr.h>


#if defined (HIBER_DEBUG)
extern VOID HbPrint(PUCHAR);
extern VOID HbPrintNum(ULONG n);
extern VOID HbPrintHex(ULONG n);
extern VOID HbPause(VOID);
#define SHOWNUM(x) ((void) (HbPrint(#x " = "), HbPrintNum((ULONG) (x)), HbPrint("\r\n")))
#define SHOWHEX(x) ((void) (HbPrint(#x " = "), HbPrintHex((ULONG) (x)), HbPrint("\r\n")))
#endif


//
// When the hibernation image is read from disk each page must return to the
// same page frame it came from.  Some of those page frames are currently in
// use by firmware or OS Loader, so the pages that belong there must be
// loaded temporarily somewhere else and copied into place just before the
// saved image is restarted.
//
// The hibernation file contains a list of pages that were not in use by
// the saved image, and were allocated from memory marked as MemoryFree by
// firmware.  MapPage is initialized to point to this list; as pages are
// needed for relocation, they are chosen from this list.  RemapPage is
// a corresponding array of where each relocated page actually belongs.
//

PPFN_NUMBER HiberMapPage;
PPFN_NUMBER HiberRemapPage;

ULONG HiberCurrentMapIndex;


VOID
HbInitRemap(
    PPFN_NUMBER FreeList
    )
/*++

Routine Description:

    Initialize memory allocation and remapping.  Find a free page
    in the FreeList, copy the FreeList into it, and point HiberMapPage
    to it.  Find another free page and and point HiberRemapPage to it.
    Initialize HiberLastRemap.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HiberMapPage = HiberRemapPage = FreeList;   // so HbNextSharedPage will work
    HiberMapPage = HbNextSharedPage(0, 0);
    RtlCopyMemory(HiberMapPage, FreeList, PAGE_SIZE);
    HiberRemapPage = HbNextSharedPage(0, 0);
}


PVOID
HbMapPte (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   Page
    )
/*++

Routine Description:

    Return a 32 superpage pointer to the specified physical page.
    (On x86, this function maps the page and returns a virtual address.)

Arguments:

    PteToMap    - unused, present only for x86 compatibility

    Page        - the physical page (page frame number) to map,
                  must be below 1 GB.

Return Value:

    32 bit superpage address of the page.

--*/
{
    UNREFERENCED_PARAMETER( PteToMap );

    ASSERT (Page < (1024L * 1024L * 1024L >> PAGE_SHIFT)) ;
    return (PVOID) ((Page << PAGE_SHIFT) + KSEG0_BASE) ;
}


PVOID
HbNextSharedPage (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   RealPage
    )
/*++

Routine Description:

    Allocates the next available page in the free list and
    maps the Hiber pte to the page.   The allocated page
    is put onto the remap list.

Arguments:

    PteToMap    - unused, present only for x86 compatibility

    RealPage    - The page to enter into the remap table for
                  this allocation

Return Value:

    Virtual address of the mapping

--*/

{
    PFN_NUMBER  DestPage;
    ULONG       i;

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
    HbPrint("HbNextSharedPage("); HbPrintHex(RealPage); HbPrint(")\r\n");
    SHOWNUM(HiberCurrentMapIndex);
    SHOWNUM(HiberNoMappings);
#endif

    //
    // Loop until we find a free page which is not in
    // use by the loader image, then map it
    //

    while (HiberCurrentMapIndex < HiberNoMappings) {
        DestPage = HiberMapPage[HiberCurrentMapIndex];
        HiberCurrentMapIndex += 1;

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
        SHOWHEX(DestPage);
#endif

        i = HbPageDisposition (DestPage);
        if (i == HbPageInvalid) {
#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
            HbPrint("Invalid\n");
            HbPause();
#endif
            HiberIoError = TRUE;
            return HiberBuffer;
        }

        if (i == HbPageNotInUse) {
#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 2)
            HbPrint("Not in use\r\n");
            HbPause();
#endif

#if defined (HIBER_DEBUG) && (HIBER_DEBUG & 4)
            HbPrint("\r\n"); HbPrintHex(RealPage); HbPrint(" at "); HbPrintHex(DestPage);
#endif
            HiberMapPage[HiberLastRemap] = DestPage;
            HiberRemapPage[HiberLastRemap] = RealPage;
            HiberLastRemap += 1;
            return HbMapPte(PteToMap, DestPage);
        }
#if defined (HIBER_DEBUG)
        SHOWNUM(i);  
#endif
    }
#if defined (HIBER_DEBUG)
    HbPrint("Out of remap\r\n");
    HbPause();
#endif
    HiberOutOfRemap = TRUE;
    return HiberBuffer;
}


VOID
HiberSetupForWakeDispatch (
    VOID
    )
{
    //
    // Make sure the I-cache is coherent with the wake dispatch code that was
    // copied to a free page.
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\wakes.s ===
//      TITLE("Hibernation wake dispatcher")
//++
//
// Copyright (c) 1999  Intel Corporation
//
// Module Name:
//
//    wakes.s
//
// Abstract:
//
//
// Author:
//
//    Allen Kay (allen.m.kay@intel.com)    8 June, 1999
//
// Environment:
//
//    Firmware, OS Loader.  Position-independent.
//
// Revision History:
//
//--

#include "ksia64.h"
#include "paldef.h"

        .global HiberMapPage
        .global HiberRemapPage
        .global HiberWakeState
        .global HiberFirstRemap
        .global HiberLastRemap
        .global HiberImagePageSelf
        .global HiberBreakOnWake


// VOID
// WakeDispatcher(
//     VOID
//     )
//
// Routine description:
//
//      This code performs the final stages of restarting the hibernation
//      image.  Pages that were loaded in temporary buffer space because
//      the memory they belong in was in use by the firmware are copied
//      to their final destination; an IMB is issued after this to ensure
//      that the I-cache is coherent with any code that got copied; and
//      necessary context is loaded into registers and NT is reentered.
//
//      Because this code is part of the loader image that may be overwritten
//      by this copy process, it must itself have been copied to a free
//      page before it is executed.  Note that because there is presently
//      no mechanism for allocating multiple contiguous pages, this code cannot
//      exceed one page (8K).
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      Never returns.


        LEAF_ENTRY(WakeDispatcherStartLocal)

        .prologue
        .regstk    1, 30, 2, 0
        alloc      t4 = ar.pfs, 1, 30, 2, 0
        ARGPTR(a0)

        rMapPage        = loc11
        rRemapPage      = loc12
        rWakeState      = loc13
        rPageCount      = loc14
        rPageSelf       = loc15
        rBreakOnWake    = loc16
        src1            = loc17
        src2            = loc18
        tmp             = loc19
        rKSEG0          = loc20
        rpT0            = loc21
        rpT1            = loc22
        rpT2            = loc23
        rpT3            = loc24

//
// Get variables into registers before copying any pages, as they may be
// overwritten.
//
        movl    rpT0 = HiberMapPage     // pointer to source pages
        movl    rpT1 = HiberRemapPage   // pointer to target pages
        movl    rpT2 = HiberWakeState   // pointer to KPROCESSOR_STATE for
                                        // restarting the hibernation image
        ;;

        ld8     rMapPage   = [rpT0]     // load them
        ld8     rRemapPage = [rpT1]
        ld8     rWakeState = [rpT2]
        ;;
        
        movl    rpT0 = HiberFirstRemap  // first page index
        movl    rpT1 = HiberLastRemap   // last page index
        movl    rpT2 = HiberImagePageSelf // PFN where MemImage ends up
        movl    rpT3 = HiberBreakOnWake // "break on wake" flag
        ;;

        ld4     t0 = [rpT0]             // load them
        ld4     t1 = [rpT1]
        ld8     rPageSelf = [rpT2]
        ld1     rBreakOnWake = [rpT3]
        ;;

        sub     rPageCount = t1, t0            // number of pages to copy
        add     rMapPage = t0, rMapPage        // first source page
        add     rRemapPage = t0, rRemapPage    // first target page
        ;;
        cmp.eq  pt1, pt0 = rPageCount, zero    // nothing to copy
        ;;

(pt1)   br.cond.spnt CopyDone

//
// Copy pages.
//

NextPage:
        add     rPageCount = -1, rPageCount    // count page copied
        movl    rKSEG0 = KSEG0_BASE            // physical -> KSEG0

        ld8.fill    t0 = [rMapPage], 8         // source page number
        ;;
        shl     t0 = t0, PAGE_SHIFT            // page -> physical address
        ;;
        add     t0 = rKSEG0, t0                // physical -> KSEG0

        ld8.fill    t1 = [rRemapPage], 8       // destination address
        ;;
        shl     t1 = t1, PAGE_SHIFT            // page -> physical address
        ;;
        add     t1 = rKSEG0, t1                // physical -> KSEG0
        movl    t2 = 1024                      // 8KB = 1024 quadwords
        ;;

NextQuadWord:
        add     t2 = -1, t2                    // count quadword
        ld8.fill   t3 = [t0], 8                // load a quadword
        ;;
        st8.spill  [t1] = t3, 8                // store it
        ;;
        
        cmp.eq  pt0, pt1 = t2, zero
        ;;
(pt1)   br.cond.spnt NextQuadWord

        cmp.eq  pt0, pt1 = rPageCount, zero
        ;;
(pt1)   br.cond.spnt NextPage

//
// All necessary pages have been copied.  Check the break-on-wake flag,
// and change the signature NT will see when it wakes up if it was set.
//

CopyDone:
        cmp.eq  pt1, pt0 = rBreakOnWake, zero  // no flag set, do nothing
        ;;
(pt1)   br.cond.spnt SkipSigChange

        shl     rPageSelf = rPageSelf, PAGE_SHIFT   // convert to physical
        ;;
        add     rPageSelf = rKSEG0, rPageSelf       // make superpage address
        movl    t0 = 0x706b7262                     // 'brkp'
        ;;
        st4     [rPageSelf] = t0   // signature is first longword of MemImage
        
//
// Synchronize the I-cache, load essential NT context, and transfer control
// to the restored system.
//

SkipSigChange:
#if 0
        PublicFunction(PalProc)

        mov     out0 = PAL_CACHE_FLUSH         // call PAL cache flush routine
        mov     out1 = 1                       // flush I-cache only

        movl    rpT0 = PalProc
        ;;
        ld8     t0 = [rpT0]
        ;;
        mov     bt0 = t0
        ;;
        br.call.spnt brp = bt0
#endif

//
// Restore context.  Only the integer registers are restored; this code runs
// in the firmware environment, so floating point can't be used, and NT
// PALcode abstractions such as the PSR don't exist.  It is the responsibility
// of NT's code that saves the hibernation context to put enough information
// in the integer registers in the CONTEXT to be able to finish restoring
// context to restart NT.
//

        mov         a0 = rWakeState            // CONTEXT is the first thing
                                               //  in the KPROCESSOR_STATE
        ;;

//
// Restore all the registers.
//

        add         src1 = CxIntNats, a0
        add         src2 = CxPreds, a0
        add         tmp = CxIntGp, a0
        ;;

        ld8.nt1     t17 = [src1], CxBrRp - CxIntNats
        ld8.nt1     t16 = [src2], CxBrS0 - CxPreds
        shr         tmp = tmp, 3
        ;;

        ld8.nt1     t0 = [src1], CxBrS1 - CxBrRp
        ld8.nt1     t1 = [src2], CxBrS2 - CxBrS0
        and         tmp = 0x3f, tmp
        ;;

        ld8.nt1     t2 = [src1], CxBrS3 - CxBrS1
        ld8.nt1     t3 = [src2], CxBrS4 - CxBrS2
        cmp4.ge     pt1, pt0 = 1, tmp
        ;;

        ld8.nt1     t4 = [src1], CxBrT0 - CxBrS3
        ld8.nt1     t5 = [src2], CxBrT1 - CxBrS4
 (pt1)  sub         loc5 = 1, tmp
        ;;

        ld8.nt1     t6 = [src1], CxApUNAT - CxBrT0
        ld8.nt1     t7 = [src2], CxApLC - CxBrT1
 (pt0)  add         loc5 = -1, tmp
        ;;

        ld8.nt1     loc0 = [src1], CxApEC - CxApUNAT
        ld8.nt1     t8 = [src2], CxApCCV - CxApLC
 (pt0)  sub         loc6 = 65, tmp
        ;; 

        ld8.nt1     t9 = [src1], CxApDCR - CxApEC
        ld8.nt1     t10 = [src2], CxRsPFS - CxApCCV
 (pt1)  shr.u       t17 = t17, loc5
        ;;

        ld8.nt1     loc1 = [src1], CxRsBSP - CxApDCR
        ld8.nt1     t11 = [src2], CxRsRSC - CxRsPFS
 (pt0)  shl         loc7 = t17, loc5
        ;;

        ld8.nt1     loc2 = [src1], CxStIIP - CxRsBSP
        ld8.nt1     loc3 = [src2], CxStIFS - CxRsRSC
 (pt0)  shr.u       loc8 = t17, loc6
        ;;

        ld8.nt1     loc9 = [src1]
        ld8.nt1     loc10 = [src2]
 (pt0)  or          t17 = loc7, loc8
        ;;

        mov         ar.unat = t17
        add         src1 = CxFltS0, a0
        shr         t12 = loc2, 3
        ;;

        add         src2 = CxFltS1, a0
        and         t12 = 0x3f, t12             // current rnat save index
        and         t13 = 0x7f, loc10           // total frame size
        ;;

        mov         ar.ccv = t10
        add         t14 = t13, t12
        mov         ar.pfs = t11
        ;;

Rrc20:
        cmp4.gt     pt1, pt0 = 63, t14
        ;;
 (pt0)  add         t14 = -63, t14
 (pt0)  add         t13 = 1, t13
        ;;

        nop.m       0
 (pt1)  shl         t13 = t13, 3
 (pt0)  br.cond.spnt Rrc20
        ;;

        add         loc2 = loc2, t13
        nop.f       0
        mov         pr = t16, -1

        ldf.fill.nt1  fs0 = [src1], CxFltS2 - CxFltS0
        ldf.fill.nt1  fs1 = [src2], CxFltS3 - CxFltS1
        mov         brp = t0
        ;;
         
        ldf.fill.nt1  fs2 = [src1], CxFltT0 - CxFltS2
        ldf.fill.nt1  fs3 = [src2], CxFltT1 - CxFltS3
        mov         bs0 = t1
        ;;
        
        ldf.fill.nt1  ft0 = [src1], CxFltT2 - CxFltT0
        ldf.fill.nt1  ft1 = [src2], CxFltT3 - CxFltT1
        mov         bs1 = t2
        ;;
        
        ldf.fill.nt1  ft2 = [src1], CxFltT4 - CxFltT2
        ldf.fill.nt1  ft3 = [src2], CxFltT5 - CxFltT3
        mov         bs2 = t3
        ;;
        
        ldf.fill.nt1  ft4 = [src1], CxFltT6 - CxFltT4
        ldf.fill.nt1  ft5 = [src2], CxFltT7 - CxFltT5
        mov         bs3 = t4
        ;;
        
        ldf.fill.nt1  ft6 = [src1], CxFltT8 - CxFltT6
        ldf.fill.nt1  ft7 = [src2], CxFltT9 - CxFltT7
        mov         bs4 = t5
        ;;
        
        ldf.fill.nt1  ft8 = [src1], CxFltS4 - CxFltT8
        ldf.fill.nt1  ft9 = [src2], CxFltS5 - CxFltT9
        mov         bt0 = t6
        ;;

        ldf.fill.nt1  fs4 = [src1], CxFltS6 - CxFltS4
        ldf.fill.nt1  fs5 = [src2], CxFltS7 - CxFltS5
        mov         bt1 = t7
        ;;

        ldf.fill.nt1  fs6 = [src1], CxFltS8 - CxFltS6
        ldf.fill.nt1  fs7 = [src2], CxFltS9 - CxFltS7
        mov         ar.lc = t8
        ;;

        ldf.fill.nt1  fs8 = [src1], CxFltS10 - CxFltS8
        ldf.fill.nt1  fs9 = [src2], CxFltS11 - CxFltS9
        mov         ar.ec = t9
        ;;

        ldf.fill.nt1  fs10 = [src1], CxFltS12 - CxFltS10
        ldf.fill.nt1  fs11 = [src2], CxFltS13 - CxFltS11
        nop.i       0
        ;;

        ldf.fill.nt1  fs12 = [src1], CxFltS14 - CxFltS12
        ldf.fill.nt1  fs13 = [src2], CxFltS15 - CxFltS13
        add         loc6 = CxIntGp, a0
        ;;

        ldf.fill.nt1  fs14 = [src1], CxFltS16 - CxFltS14
        ldf.fill.nt1  fs15 = [src2], CxFltS17 - CxFltS15
        add         loc7 = CxIntT0, a0
        ;;

        ldf.fill.nt1  fs16 = [src1], CxFltS18 - CxFltS16
        ldf.fill.nt1  fs17 = [src2], CxFltS19 - CxFltS17
        add         t19 = CxRsRNAT, a0
        ;;

        ldf.fill.nt1  fs18 = [src1]
        ldf.fill.nt1  fs19 = [src2]
        add         t7 = CxStFPSR, a0
        ;;

        ld8.nt1     loc8 = [t7]                 // load fpsr from context
        ld8.nt1     loc5 = [t19]                // load rnat from context
        nop.i       0

        ld8.fill.nt1 gp = [loc6], CxIntT1 - CxIntGp
        ld8.fill.nt1 t0 = [loc7], CxIntS0 - CxIntT0
        ;;

        ld8.fill.nt1 t1 = [loc6], CxIntS1 - CxIntT1
        ld8.fill.nt1 s0 = [loc7], CxIntS2 - CxIntS0
        ;;

        ld8.fill.nt1 s1 = [loc6], CxIntS3 - CxIntS1
        ld8.fill.nt1 s2 = [loc7], CxIntV0 - CxIntS2
        ;;

        ld8.fill.nt1 s3 = [loc6], CxIntTeb - CxIntS3
        ld8.fill.nt1 v0 = [loc7], CxIntT2 - CxIntV0
        ;;

        ld8.fill.nt1 teb = [loc6], CxIntT3 - CxIntTeb
        ld8.fill.nt1 t2 = [loc7], CxIntSp - CxIntT2
        ;;

        ld8.fill.nt1 t3 = [loc6], CxIntT4 - CxIntT3
        ld8.fill.nt1 loc4 = [loc7], CxIntT5 - CxIntSp
        ;;

        ld8.fill.nt1 t4 = [loc6], CxIntT6 - CxIntT4
        ld8.fill.nt1 t5 = [loc7], CxIntT7 - CxIntT5
        ;;

        ld8.fill.nt1 t6 = [loc6], CxIntT8 - CxIntT6
        ld8.fill.nt1 t7 = [loc7], CxIntT9 - CxIntT7
        ;;

        ld8.fill.nt1 t8 = [loc6], CxIntT10 - CxIntT8
        ld8.fill.nt1 t9 = [loc7], CxIntT11 - CxIntT9
        ;;

        ld8.fill.nt1 t10 = [loc6], CxIntT12 - CxIntT10
        ld8.fill.nt1 t11 = [loc7], CxIntT13 - CxIntT11
        ;;

        ld8.fill.nt1 t12 = [loc6], CxIntT14 - CxIntT12
        ld8.fill.nt1 t13 = [loc7], CxIntT15 - CxIntT13
        ;;

        ld8.fill.nt1 t14 = [loc6], CxIntT16 - CxIntT14
        ld8.fill.nt1 t15 = [loc7], CxIntT17 - CxIntT15
        ;;

        ld8.fill.nt1 t16 = [loc6], CxIntT18 - CxIntT16
        ld8.fill.nt1 t17 = [loc7], CxIntT19 - CxIntT17
        ;;

        ld8.fill.nt1 t18 = [loc6], CxIntT20 - CxIntT18
        ld8.fill.nt1 t19 = [loc7], CxIntT21 - CxIntT19
        ;;

        ld8.fill.nt1 t20 = [loc6], CxIntT22 - CxIntT20
        ld8.fill.nt1 t21 = [loc7]
        ;;

        rsm         1 << PSR_I
        ld8.fill.nt1 t22 = [loc6] 
        ;;

        rsm         1 << PSR_IC
        movl        t0 = 1 << IFS_V
        ;;

        mov         ar.fpsr = loc8              // set fpsr
        mov         ar.unat = loc0
        ;;

        srlz.d
        or          loc10 = t0, loc10           // set ifs valid bit
        ;;

        mov         cr.iip = loc9
        mov         cr.ifs = loc10
        bsw.0
        ;;

        mov         cr.dcr = loc1
        mov         r17 = loc2                  // put BSP in a shadow reg
        or          r16 = 0x3, loc3             // put RSE in eager mode

        mov         ar.rsc = r0                 // put RSE in enforced lazy
        nop.m       0
        add         r20 = CxStIPSR, a0
        ;;

        ld8.nt1     r20 = [r20]                 // load IPSR
        mov         r18 = loc4                  // put SP in a shadow reg
        mov         r19 = loc5                  // put RNaTs in a shadow reg
        ;;

        alloc       t0 = 0, 0, 0, 0
        mov         cr.ipsr = r20
        mov         sp = r18
        ;;

        loadrs
        ;;
        mov         ar.bspstore = r17
        nop.i       0
        ;;

        mov         ar.rnat = r19               // set rnat register
        mov         ar.rsc = r16                // restore RSC
        bsw.1
        ;;

        invala
        nop.i       0
        rfi
        ;;


//
// This label is used to determine the size of the wake dispatcher code in the
// process of copying it to a free page.
//

WakeDispatcherEndLocal::
        LEAF_EXIT(WakeDispatcherEndLocal)


        .sdata
WakeDispatcherStart::
        data4    @secrel(WakeDispatcherStartLocal)
WakeDispatcherEnd::
        data4    @secrel(WakeDispatcherEndLocal)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\inc\efip.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    efip.h

Abstract:

    Private loader additions to efi that aren't in the standard
    efi header files.

Author:

    Scott Brenden (v-sbrend) 28 Feb 2000

Revision History:

--*/



#define DP_PADDING    10
typedef struct _EFI_DEVICE_PATH_ALIGNED {
        EFI_DEVICE_PATH                 DevPath;
        ULONGLONG                       Data[DP_PADDING];
} EFI_DEVICE_PATH_ALIGNED;

#define EfiAlignDp(out, in, length)     RtlCopyMemory(out, in, length);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\inc\paldef.h ===
#ifndef _PALDEF_H_
#define _PALDEF_H_

// iA-64 defined PAL virtual mode function IDs in decimal format as in the PAL spec

#define PAL_CACHE_FLUSH                                       1
#define PAL_CACHE_INFO                                        2
#define PAL_CACHE_INIT                                        3
#define PAL_CACHE_PROT_INFO                                  38
#define PAL_CACHE_SUMMARY                                     4
#define PAL_PTCE_INFO                                         6
#define PAL_VM_INFO                                           7
#define PAL_VM_PAGE_SIZE                                     34
#define PAL_VM_SUMMARY                                        8
#define PAL_PERF_MON_INFO                                    15
#define PAL_MC_CLEAR_LOG                                     21
#define PAL_MC_DRAIN                                         22
#define PAL_MC_ERROR_INFO                                    25
#define PAL_HALT                                             28
#define PAL_HALT_INFO                                       257
#define PAL_HALT_LIGHT                                       29
#define PAL_SHUTDOWN                                         44

// iA-64 defined PAL physical mode function IDs in decimal format as in the PAL spec

#define PAL_VM_TR_READ                                      261
#define PAL_MEM_ATTRIB                                        5
#define PAL_BUS_GET_FEATURES                                  9
#define PAL_BUS_SET_FEATURES                                 10
#define PAL_DEBUG_INFO                                       11
#define PAL_FIXED_ADDR                                       12
#define PAL_FREQ_BASE                                        13
#define PAL_FREQ_RATIOS                                      14
#define PAL_PLATFORM_ADDR                                    16
#define PAL_PROC_GET_FEATURES                                17
#define PAL_PROC_SET_FEATURES                                18
#define PAL_REGISTER_INFO                                    39
#define PAL_RSE_INFO                                         19
#define PAL_VERSION                                          20
#define PAL_MC_DYNAMIC_STATE                                 24
#define PAL_MC_EXPECTED                                      23
#define PAL_MC_REGISTER_MEM                                  27
#define PAL_MC_RESUME                                        26
#define PAL_CACHE_LINE_INIT                                  31
#define PAL_CACHE_READ                                      259
#define PAL_CACHE_WRITE                                     260
#define PAL_MEM_FOR_TEST                                     37
#define PAL_TEST_PROC                                       258
#define PAL_COPY_INFO                                        30
#define PAL_COPY_PAL                                        256
#define PAL_ENTER_IA_32_ENV                                  33
#define PAL_PMI_ENTRYPOINT                                   32

//
// iA-64 defined PAL return values
//

#define PAL_STATUS_INVALID_CACHELINE                          1
#define PAL_STATUS_SUCCESS                                    0
#define PAL_STATUS_NOT_IMPLEMENTED                           -1
#define PAL_STATUS_INVALID_ARGUMENT                          -2
#define PAL_STATUS_ERROR                                     -3
#define PAL_STATUS_UNABLE_TO_INIT_CACHE_LEVEL_AND_TYPE       -4
#define PAL_STATUS_NOT_FOUND_IN_CACHE                        -5
#define PAL_STATUS_NO_ERROR_INFO_AVAILABLE                   -6

#endif  // PALDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\ia64\susetup.s ===
//++
//
//  Module name
//      SuSetup.s
//  Author
//      Allen Kay    (akay)    Jun-12-95
//  Description
//      Startup module for Ia64 NT OS loader.
// Notes
//      This is the startup routine for Ia64 NT boot loader.  It sets up
//      the CPU state and turns on the address translation before calling
//      the C routine main() which then does some initial setup then passes
//      control to BlOsLoader().
//---

#include "ksia64.h"

        .file   "susetup.s"

        PublicFunction(SuMain)

//#define FW_SPEC_PATCH


#if defined(FW_SPEC_PATCH)
	PublicFunction(memcpy)
#endif

        .global    StackBase
        .global    StackLimit
        .global    BspLimit

        NESTED_ENTRY(main)
        NESTED_SETUP(2,6,3,0)

        ImageHandle     = loc2
        SystemTable     = loc3

        mov     ImageHandle = a0
        mov     SystemTable = a1

        movl    gp = _gp                       // setup gp register
        invala                                 // invalidate ALAT
        mov     ar.rsc = r0
        ;;

//
// Switch to our own sp and bspstore.
//
        loadrs
        movl    sp = StackBase
        ;;
        mov     ar.bspstore = sp
        add     sp = -STACK_SCRATCH_AREA, sp
        ;;

#if defined(FW_SPEC_PATCH)

//
// Set Unaligned fault Vector
//
        mov         loc4 = 0x5a00
        mov         loc5 = cr.iva
        movl        out1 = BldrFaultDeferStart
        movl        out2 = BldrFaultDeferEnd - BldrFaultDeferStart
        ;;

        add         out0 = loc4, loc5         // out0 = address of IVT vector
        ;;
        br.call.sptk brp = memcpy
        ;;

//
// Set dirty bit fault Vector
//
        mov         loc4 = 0x2000
        mov         loc5 = cr.iva
        movl        out1 = BldrFaultDeferStart
        movl        out2 = BldrFaultDeferEnd - BldrFaultDeferStart
        ;;
        add         out0 = loc4, loc5         // out0 = address of IVT vector
        ;;

        br.call.sptk brp = memcpy
        ;;

//
// Set instruction access bit fault Vector
//
        mov         loc4 = 0x2400
        mov         loc5 = cr.iva
        movl        out1 = BldrFaultDeferStart
        movl        out2 = BldrFaultDeferEnd - BldrFaultDeferStart
        ;;
        add         out0 = loc4, loc5         // out0 = address of IVT vector
        ;;

        br.call.sptk brp = memcpy
        ;;
        sync.i
        ;;
        srlz.i
        ;;
#endif   // FW_SPEC_PATCH

//
// Transfer control to Sumain()
//
        mov    out0 = ImageHandle
        mov    out1 = SystemTable
        br.call.spnt brp = SuMain
        ;;

        NESTED_EXIT(main)

#if defined(FW_SPEC_PATCH)

BldrFaultDeferStart::
        mov       h28 = pr
        mov       h27 = cr.isr
        mov       h26 = cr.ipsr
        ;;
        tbit.nz   p6, p7 = h27, ISR_SP
        ;;
(p6)    dep       h26 = 1, h26, PSR_ED, 1
        ;;
(p6)    mov       cr.ipsr = h26
        ;;
        mov       pr = h28
        ;;
        rfi
        ;;
BldrFaultDeferEnd::

#endif

//
// Reserve memory for loader stack
//
        .section .StackBase = "wa", "progbits"
StackLimit::
        .skip 0x20000
StackBase::
        .skip 0x4000
BspLimit::

//
// Reserve memory for loader stack
//
         string " -section:.BdPcr,,align=PAGE_SIZE"
        .section .BdPcr = "wa", "progbits"
BdPcr::
        .skip PAGE_SIZE
        .skip PAGE_SIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\inc\fpswa.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    fpswa.h
    
Abstract:

    EFI driver wrapper for FPSWA

Revision History

--*/

//
// First define PAL_RETURN
//
typedef int PAL_RETURN;

//
// Global ID for fpswa driver & protocol
//



#define EFI_INTEL_FPSWA     \
    { 0xc41b6531, 0x97b9, 0x11d3, 0x9a, 0x29, 0x0, 0x90, 0x27, 0x3f, 0xc1, 0x4d }

#define EFI_INTEL_FPSWA_REVISION    0x00010000

//
//
//

typedef 
PAL_RETURN
(EFIAPI *EFI_FPSWA) (
    IN struct _FPSWA_INTERFACE  *This,
    // IN UINTN                    TrapType,
    IN unsigned int		TrapType,
    IN OUT VOID                 *Bundle,
    IN OUT UINT64               *pipsr,
    IN OUT UINT64               *pfsr,
    IN OUT UINT64               *pisr,
    IN OUT UINT64               *ppreds,
    IN OUT UINT64               *pifs,
    IN OUT VOID                 *fp_state
    );


typedef struct _FPSWA_INTERFACE {
    UINT32      Revision;
    UINT32      Reserved;

    EFI_FPSWA   Fpswa;    
} FPSWA_INTERFACE;

//
// Prototypes
//

PAL_RETURN
FpswaEntry (
    IN FPSWA_INTERFACE          *This,
    // IN UINTN                    TrapType,
    IN unsigned int		TrapType,
    IN OUT VOID                 *Bundle,
    IN OUT UINT64               *pipsr,
    IN OUT UINT64               *pfsr,
    IN OUT UINT64               *pisr,
    IN OUT UINT64               *ppreds,
    IN OUT UINT64               *pifs,
    IN OUT VOID                 *fp_state
    );



//
// Globals
//

extern EFI_GUID FpswaId;
extern FPSWA_INTERFACE FpswaInterface;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\biboot.h ===
/*++

Copyright (c) 1998  Intel Corporation

Module Name:

    biboot.h

Abstract:

    Public IBI header files

Author:

    

Revision History

--*/


#include "bootia64.h"            // BUGBUG

// #define IBI32           1       // Building 32 bit IBI
#define IBI64           1       // Building 64 bit IBI

#include "ibi.h"

//
// Console functions
//


IBI_STATUS
BiOutputString (
    VOID        *Context,
    CHAR16      *Str
    );

IBI_STATUS
BiSetAttribute (
    VOID        *Context,
    UINTN       Attribute
    );

IBI_STATUS
BiSetCursorPosition (
    VOID        *Context,
    UINTN       Column,
    UINTN       Row
    );

VOID
BIASSERT (
    IN char     *str
    );

//
// Arc functions
//

ARC_STATUS
BiArcNotImplemented (
    IN ULONG    No
    );


ARC_STATUS
BiArcCloseNop (
    IN ULONG FileId
    );


IBI_STATUS
BiHandleToArcName (
    IN IBI_HANDLE       Handle,
    OUT PUCHAR          Buffer,
    IN UINTN            BufferSize
    );

IBI_STATUS
BiArcNameToHandle (
    IN PCHAR                        OpenPath,
    OUT IBI_ARC_OPEN_CONTEXT        *OpenContext,
    OUT PBL_DEVICE_ENTRY_TABLE      *ArcIo
    );


//
// Allocate and free IBI pool (not loader pool)
//

PVOID
BiAllocatePool (
    IN UINTN    Size
    );


VOID
BiFreePool (
    IN PVOID    Buffer
    );


WCHAR *
BiDupAscizToUnicode (
    PUCHAR      Str
    );

//
//
//

ARC_STATUS
BiArcCode (
    IN IBI_STATUS   Status
    );

//
// Externals
//

extern IBI_SYSTEM_TABLE         *IbiST;
extern IBI_BOOT_SERVICES        *IbiBS;
extern IBI_RUNTIME_SERVICES     *IbiRT;
extern IBI_LOADED_IMAGE         *IbiImageInfo;
extern IBI_HANDLE               IbiNtldr;

extern IBI_GUID IbiLoadedImageProtocol;
extern IBI_GUID IbiDevicePathProtocol;
extern IBI_GUID IbiBlockIoProtocol;
extern IBI_GUID IbiFilesystemProtocol;
extern IBI_GUID IbiDeviceIoProtocol;

extern IBI_GUID IbiFileInformation;
extern IBI_GUID IbiFileSystemInformation;

extern IBI_GUID VendorMicrosoft;

extern BL_DEVICE_ENTRY_TABLE    BiArcConsoleOut;
extern BL_DEVICE_ENTRY_TABLE    BiArcConsoleIn;
extern BL_DEVICE_ENTRY_TABLE    BiArcBlockIo;
extern BL_DEVICE_ENTRY_TABLE    BiArcFsDevIo;
extern PUCHAR                   BiClipBuffer;
extern UINTN                    BiClipBufferSize;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\bldr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    bldr.h

Abstract:

    This module is the header file for the NT boot loader.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#ifndef _BLDR_
#define _BLDR_

#include "ntos.h"
#include "arccodes.h"
#include "setupblk.h"
#include "hdlsblk.h"
#include "remboot.h"
#include "oscpkt.h"
#include "bootstatus.h"

#include <TCHAR.H>

#ifndef _PTUCHAR
typedef _TUCHAR  *_PTUCHAR;
#endif

#pragma warning(disable:4200)     // unsized array


//
// DoApmAttemptReconnect does nothing on non x86 machines.
// On x86 machines, it attempts an APM reconnect, and lives in initx86.c
//
#if defined(_X86_)
VOID DoApmAttemptReconnect();
#else
#define DoApmAttemptReconnect()
#endif

//
// The Alpha OS Loader and Setup Loader run in the environment of the host
// firmware. This environment is restricted to a 32-bit address space and
// cannot result in pointer significance greater than 32-bits. The 64-bit
// OS Loader, however, is compiled using 64-bit pointers for non-firmware
// interfaces and constructs data structures used to pass information to the
// NT kernel using 64-bit pointers. This leads to a large number of false
// pointer truncation warnings. Therefore, pointer truncation warnings are
// turned off in the OS and Setup Loaders for 64-bit Alpha systems.
//

#if defined(_AXP64_)

#pragma warning(4:4244)                 // turn off pointer trunction

#endif

//
// Define boot file id.
//

#define BOOT_FILEID 2                   // boot partition file id

//
// Define image type.
//

#if defined(_X86_)

#define ICEBP __asm { __emit 0xf1 }

//
// Things related to Amd64 support follow
//

#define TARGET_IMAGE ((BlAmd64UseLongMode == FALSE) ? \
                      IMAGE_FILE_MACHINE_I386 : IMAGE_FILE_MACHINE_AMD64)

ARC_STATUS
BlAmd64CheckForLongMode(
    IN     ULONG LoadDeviceId,
    IN OUT PCHAR KernelPath,
    IN     PCHAR KernelFileName
    );

//
// BlUseAmd64Longmode is set when we have made the decision to use long
// mode.
//

extern BOOLEAN BlAmd64UseLongMode;

#else

#define BlAmd64UseLongMode FALSE

#endif  // _X86_


#if defined(_ALPHA_)

#if defined(_AXP64_)

#define TARGET_IMAGE IMAGE_FILE_MACHINE_AXP64

#else

#define TARGET_IMAGE IMAGE_FILE_MACHINE_ALPHA

#endif

#endif

#if defined(_IA64_)

#define TARGET_IMAGE IMAGE_FILE_MACHINE_IA64

#endif

//
// Make headless defines
//

#if defined(_X86_)

#define BlIsTerminalConnected() BlTerminalConnected


#endif

#if defined(_ALPHA_)

#if defined(_AXP64_)

#define BlIsTerminalConnected() FALSE

#else

#define BlIsTerminalConnected() FALSE

#endif

#endif

#if defined(_IA64_)

#define BlIsTerminalConnected() BlTerminalConnected

#endif

BOOLEAN
BlTerminalHandleLoaderFailure(
    VOID
    );




//
// Define size of sector.
//

#define SECTOR_SIZE 512                 // size of disk sector
#define SECTOR_SHIFT 9                  // sector shift value

#define STALE_GPT_PARTITION_ENTRY   0xEE    // The stale MBR partition entry for GPT disks

//
// Define heap allocation block granularity.
//

#define BL_GRANULARITY 8

//
// Define number of entries in file table.
//

#define BL_FILE_TABLE_SIZE 48

//
// Define size of memory allocation table.
//

#define BL_MEMORY_TABLE_SIZE 16

//
// Define number of loader heap and stack pages.
//

#if DBG
#define BL_HEAP_PAGES 32
#else
#define BL_HEAP_PAGES 16
#endif

#define BL_STACK_PAGES 8

//
// Define buffer alignment macro.
//

#define ALIGN_BUFFER(Buffer) (PVOID) \
        ((((ULONG_PTR)(Buffer) + BlDcacheFillSize - 1)) & (~((ULONG_PTR)BlDcacheFillSize - 1)))

#define ALIGN_BUFFER_WITH_SIZE(Buffer, Size) (PVOID) \
        ((((ULONG_PTR)(Buffer) + (Size) - 1)) & (~((ULONG_PTR)(Size) - 1)))



//
// Define kernel names right here.
// We'll use these when we're trying to figure out
// which kernel to load (see BlDetectHalAndKernel).
//
#define LEGACY_KERNEL_NAME  "ntoskrnl.exe"
#define UP_KERNEL_NAME      "ntkrnlup.exe"
#define MP_KERNEL_NAME      "ntkrnlmp.exe"
#define UP_PAE_KERNEL_NAME  "ntkrnlpa.exe"
#define MP_PAE_KERNEL_NAME  "ntkrpamp.exe"


//
// Define various memory page boundaries
//
#define _1MB    ((1*1024*1024) >> PAGE_SHIFT)
#define _4MB    (4   * _1MB)
#define _8MB    (8   * _1MB)
#define _12MB   (12  * _1MB)
#define _16MB   (16  * _1MB)
#define _24MB   (24  * _1MB)
#define _32MB   (32  * _1MB)
#define _48MB   (48  * _1MB)
#define _64MB   (64  * _1MB)
#define _80MB   (80  * _1MB)
#define _96MB   (96  * _1MB)
#define _128MB  (128 * _1MB)
#define _256MB  (256 * _1MB)
#define _512MB  (512 * _1MB)
#define _1024MB (1024 * _1MB)
#define _2048MB (2048 * _1MB)
#define _4096MB (4096 * _1MB)


//
// Useful defines for COM ports.
//
#define COM1_PORT (0x3f8)
#define COM2_PORT (0x2f8)
#define COM3_PORT (0x3e8)
#define COM4_PORT (0x2e8)

#define BD_150      150
#define BD_300      300
#define BD_600      600
#define BD_1200     1200
#define BD_2400     2400
#define BD_4800     4800
#define BD_9600     9600
#define BD_14400    14400
#define BD_19200    19200
#define BD_57600    57600
#define BD_115200   115200

// macros to help check overflow issues
//
#define TRUNCATE_SIZE_AT_VALUE(_sz, _vl) (( _sz > _vl ) ? _vl : _sz)
#define RESET_SIZE_AT_VALUE(_sz, _vl)    (( _sz > _vl ) ?   0 : _sz)

#define TRUNCATE_SIZE_AT_UCHAR_MAX(_sz)  ((UCHAR) TRUNCATE_SIZE_AT_VALUE(_sz, (UCHAR)-1))
#define RESET_SIZE_AT_UCHAR_MAX(_sz)     ((UCHAR) RESET_SIZE_AT_VALUE(_sz, (UCHAR)-1))

#define TRUNCATE_SIZE_AT_USHORT_MAX(_sz) ((USHORT) TRUNCATE_SIZE_AT_VALUE(_sz, (USHORT)-1))
#define RESET_SIZE_AT_USHORT_MAX(_sz)    ((USHORT) RESET_SIZE_AT_VALUE(_sz, (USHORT)-1))

#define TRUNCATE_SIZE_AT_ULONG_MAX(_sz)  ((ULONG) TRUNCATE_SIZE_AT_VALUE(_sz, (ULONG)-1))
#define RESET_SIZE_AT_ULONG_MAX(_sz)     ((ULONG) RESET_SIZE_AT_VALUE(_sz, (ULONG)-1))

#define BL_INVALID_FILE_ID (ULONG)-1



typedef
ARC_STATUS
(*PRENAME_ROUTINE)(
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewName
    );

typedef struct _BOOTFS_INFO {
    WCHAR * FIRMWARE_PTR DriverName;
} BOOTFS_INFO, * FIRMWARE_PTR PBOOTFS_INFO;


//
// Device entry table structure.
//

typedef struct _BL_DEVICE_ENTRY_TABLE {
    PARC_CLOSE_ROUTINE Close;
    PARC_MOUNT_ROUTINE Mount;
    PARC_OPEN_ROUTINE Open;
    PARC_READ_ROUTINE Read;
    PARC_READ_STATUS_ROUTINE GetReadStatus;
    PARC_SEEK_ROUTINE Seek;
    PARC_WRITE_ROUTINE Write;
    PARC_GET_FILE_INFO_ROUTINE GetFileInformation;
    PARC_SET_FILE_INFO_ROUTINE SetFileInformation;
    PRENAME_ROUTINE Rename;
    PARC_GET_DIRECTORY_ENTRY_ROUTINE GetDirectoryEntry;
    PBOOTFS_INFO BootFsInfo;
} BL_DEVICE_ENTRY_TABLE, *PBL_DEVICE_ENTRY_TABLE;

//
// Many functions in the boot loader take a set of paths. Every path is divided
// into two parts, a "Source" and a "PathOffset".
//
// A source is described by the PATH_SOURCE structure. This structure contains
// three parts, the device handle to use for I/O, the ARC name of the device,
// and the offset off the root for that ARC device.
//
// The PATH_SET structures encapsulates up to three different sources. The
// field AliasName optionally points to a PE namespace description of the
// sources (eg \SystemRoot).
//
// Finally, the biggest PATH_SET structure (FULL_PATH_SET) is limited to
// MAX_PATH_COUNT sources so that those using this structure can manipulate
// local stack copies.
//
// Putting it all together, during a last known good boot the PATH_SET
// describing \Winnt\System32 would be:
//      PathCount = 3
//      AliasName = \SystemRoot\
//      PathOffset = System32\
//          Source[0].DirectoryPath = \Winnt\LastGood.tmp
//          Source[1].DirectoryPath = \Winnt\LastGood
//          Source[2].DirectoryPath = \Winnt\
//
#define MAX_PATH_SOURCES    3

typedef struct {

    ULONG   DeviceId;
    LPCSTR  DeviceName;
    PSTR    DirectoryPath; // Should have trailing '\'

} PATH_SOURCE, *PPATH_SOURCE;

typedef struct {

    ULONG       PathCount;
    LPCSTR      AliasName;
    CHAR        PathOffset[256];  // Should have trailing '\' if non-empty
    PATH_SOURCE Source[0];

} SPARSE_PATH_SET, *PSPARSE_PATH_SET;

typedef struct {

    ULONG       PathCount;
    LPCSTR      AliasName;
    CHAR        PathOffset[256];  // Should have trailing '\' if non-empty
    PATH_SOURCE Source[MAX_PATH_SOURCES];

} FULL_PATH_SET, *PFULL_PATH_SET;

//
// A PPATH_SET points to a path set with an undetermined count of paths. We
// make this an alias of PFULL_PATH_SET so as to cut down on casting.
//
typedef PFULL_PATH_SET PPATH_SET;

//
// Define transfer entry of loaded image.
//

typedef
VOID
(*PTRANSFER_ROUTINE) (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


//
// Define main entrypoint.
//

ARC_STATUS
BlOsLoader (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Envp
    );

ARC_STATUS
BlInitStdio (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv
    );


extern UCHAR OsLoaderVersion[];
extern WCHAR OsLoaderVersionW[];
extern UCHAR OsLoaderName[];
extern CHAR KernelFileName[8+1+3+1];
extern CHAR HalFileName[8+1+3+1];

//
// Define boot debugger function prototype.
//

VOID
BdInitDebugger (
    IN PCHAR LoaderName,
    IN PVOID LoaderBase,
    IN PCHAR Options
    );

extern LOGICAL BdDebuggerEnabled;

VOID
BdInitializeTraps (
    VOID
    );

ULONG
BdComPortNumber (
    VOID
    );

ARC_STATUS
BdPullRemoteFile(
    IN PCHAR FileName,
    IN ULONG FileAttributes,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN ULONG FileId
    );



//
// Define com port I/O prototypes.
//
LOGICAL
BlPortInitialize(
    IN ULONG BaudRate,
    IN ULONG PortNumber,
    IN PUCHAR PortAddress OPTIONAL,
    IN BOOLEAN ReInitialize,
    OUT PULONG BlFileId
    );

VOID
BlInitializeHeadlessPort(
    VOID
    );

ULONG
BlPortGetByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    );

VOID
BlPortPutByte (
    IN ULONG BlFileId,
    IN UCHAR Output
    );

ULONG
BlPortPollByte (
    IN ULONG BlFileId,
    OUT PUCHAR Input
    );

ULONG
BlPortPollOnly (
    IN ULONG BlFileId
    );

VOID
BlSetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock
    );

VOID
BlGetHeadlessRestartBlock(
    IN PTFTP_RESTART_BLOCK RestartBlock,
    IN BOOLEAN RestartBlockValid
    );

LOGICAL
BlRetrieveBIOSRedirectionInformation();

extern HEADLESS_LOADER_BLOCK LoaderRedirectionInformation;


//
// Define file I/O prototypes.
//

ARC_STATUS
BlIoInitialize (
    VOID
    );

ARC_STATUS
BlClose (
    IN ULONG FileId
    );

PBOOTFS_INFO
BlGetFsInfo(
    IN ULONG DeviceId
    );

ARC_STATUS
BlMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
BlOpen (
    IN ULONG DeviceId,
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
BlRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BlReadAtOffset(
    IN ULONG FileId,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PVOID Data
    );

ARC_STATUS
BlRename (
    IN ULONG FileId,
    IN PCHAR NewName
    );

ARC_STATUS
BlGetReadStatus (
    IN ULONG FileId
    );

ARC_STATUS
BlSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
BlWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
BlGetFileInformation (
    IN ULONG FileId,
    IN PFILE_INFORMATION FileInformation
    );

ARC_STATUS
BlSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

#ifdef DBLSPACE_LEGAL
VOID
BlSetAutoDoubleSpace (
    IN BOOLEAN Enable
    );
#endif

//
// Define image manipulation routine prototyupes.
//
#define BlLoadImage(_id_,_memtype_,_file_,_imagetype_,_base_) \
        BlLoadImageEx(_id_,_memtype_,_file_,_imagetype_,0,0,_base_)

ARC_STATUS
BlLoadImageEx(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadFile,
    IN USHORT ImageType,
    IN OPTIONAL ULONG PreferredAlignment,
    IN OPTIONAL ULONG PreferredBasePage,
    OUT PVOID *ImageBase
    );

ARC_STATUS
BlLoadDeviceDriver(
    IN PPATH_SET               PathSet,
    IN PCHAR                   DriverName,
    IN PTCHAR                  DriverDescription OPTIONAL,
    IN ULONG                   DriverFlags,
    OUT PKLDR_DATA_TABLE_ENTRY *DriverDataTableEntry
    );

ARC_STATUS
BlLoadNLSData(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING AnsiCodepage,
    IN PUNICODE_STRING OemCodepage,
    IN PUNICODE_STRING LanguageTable,
    OUT PCHAR BadFileName
    );

ARC_STATUS
BlLoadOemHalFont(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING OemHalFont,
    OUT PCHAR BadFileName
    );



PVOID
BlImageNtHeader (
    IN PVOID Base
    );

ARC_STATUS
BlSetupForNt(
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

ARC_STATUS
BlScanImportDescriptorTable (
    IN PPATH_SET                PathSet,
    IN PKLDR_DATA_TABLE_ENTRY    ScanEntry,
    IN TYPE_OF_MEMORY           MemoryType
    );

ARC_STATUS
BlScanOsloaderBoundImportTable (
    IN PKLDR_DATA_TABLE_ENTRY ScanEntry
    );

VOID
BlTransferToKernel(
    PTRANSFER_ROUTINE SystemEntry,
    PLOADER_PARAMETER_BLOCK BlLoaderBlock
    );

#if defined(_ALPHA_)

ARC_STATUS
BlAllocateAnyMemory (
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount,
    OUT PULONG ActualBase
    );

ARC_STATUS
BlGeneratePalName(
    IN PCHAR PalFIleName
    );

ARC_STATUS
BlLoadPal(
    IN ULONG DeviceId,
    IN TYPE_OF_MEMORY MemoryType,
    IN PCHAR LoadPath,
    IN USHORT ImageType,
    OUT PVOID *ImageBase,
    IN PCHAR LoadDevice
    );

VOID
BlSetGranularityHints (
    IN PHARDWARE_PTE PageTableArray,
    IN ULONG PageTableCount
    );

#endif

#if defined(_PPC_)

ARC_STATUS
BlPpcInitialize (
    VOID
    );

#endif // defined(_PPC)

//
// Define configuration allocation prototypes.
//


ARC_STATUS
BlConfigurationInitialize (
    IN PCONFIGURATION_COMPONENT Parent,
    IN PCONFIGURATION_COMPONENT_DATA ParentEntry
    );

//
// define routines for searching the ARC firmware tree
//
typedef
BOOLEAN
(*PNODE_CALLBACK)(
    IN PCONFIGURATION_COMPONENT_DATA FoundComponent
    );

BOOLEAN
BlSearchConfigTree(
    IN PCONFIGURATION_COMPONENT_DATA Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PNODE_CALLBACK CallbackRoutine
    );

VOID
BlGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT_DATA Component,
    OUT PCHAR ArcName
    );

BOOLEAN
BlGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    );

ARC_STATUS
BlGetArcDiskInformation(
    IN BOOLEAN XInt13Support
    );

BOOLEAN
BlReadSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    );

BOOLEAN
BlGetDiskSignature(
    IN PCHAR Name,
    IN BOOLEAN IsCdRom,
    PARC_DISK_SIGNATURE Signature
    );

#if defined(REMOTE_BOOT)
ARC_STATUS
BlCheckMachineReplacement (
    IN PCHAR SystemDevice,
    IN ULONG SystemDeviceId,
    IN ULONGLONG NetRebootParameter,
    IN PUCHAR OsLoader
    );

#endif

//
// Define memory allocation prototypes.
//

extern ULONG BlUsableBase;

#if defined(_X86_)

extern ULONG BlUsableLimitX86;
extern ULONG BlUsableLimitAmd64;

#define BlUsableLimit (*(BlAmd64UseLongMode ? &BlUsableLimitAmd64 : &BlUsableLimitX86))

#else
extern ULONG BlUsableLimit;
#endif

typedef enum _ALLOCATION_POLICY {
    BlAllocateLowestFit,
    BlAllocateBestFit,
    BlAllocateHighestFit
} ALLOCATION_POLICY, *PALLOCATION_POLICY;

extern ALLOCATION_POLICY BlMemoryAllocationPolicy;
extern ALLOCATION_POLICY BlHeapAllocationPolicy;

VOID
BlSetAllocationPolicy (
    IN ALLOCATION_POLICY MemoryAllocationPolicy,
    IN ALLOCATION_POLICY HeapAllocationPolicy
    );

ARC_STATUS
BlMemoryInitialize (
    VOID
    );

ARC_STATUS
BlAllocateDataTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID ImageHeader,
    OUT PKLDR_DATA_TABLE_ENTRY *Entry
    );

ARC_STATUS
BlAllocateFirmwareTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID ImageHeader,
    IN ULONG Size,
    OUT PKLDR_DATA_TABLE_ENTRY *Entry
    );


#define BlAllocateDescriptor(_MemoryType, _BasePage, _PageCount, _ActualBase)   \
            BlAllocateAlignedDescriptor((_MemoryType),                          \
                                        (_BasePage),                            \
                                        (_PageCount),                           \
                                        1,                                      \
                                        (_ActualBase))

#if defined (_X86_)
#define BlpCheckMapping(_page,_npages) MempCheckMapping (_page,_npages)
#define BlpFixOSMapping(_page,_npages) MempFixMapping ( _page, _npages )
#else
#define BlpCheckMapping(_page,_npages) ESUCCESS
#define BlpFixOSMapping(_page,_npages) ESUCCESS
#endif

ARC_STATUS
BlAllocateAlignedDescriptor (
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount,
    IN ULONG Alignment,
    OUT PULONG ActualBase
    );

ARC_STATUS
BlFreeDescriptor (
    IN ULONG BasePage
    );


VOID
BlTruncateDescriptors (
    IN ULONG HighestPage
    );

PVOID
BlAllocateHeapAligned (
    IN ULONG Size
    );

PVOID
BlAllocateHeap (
    IN ULONG Size
    );

BOOLEAN
BlAmd64Setup (
    IN PCHAR SetupDevice
    );

ULONG
BlAmd64FieldOffset_PO_MEMORY_IMAGE(
    ULONG offset32
    );

ULONG
BlAmd64FieldOffset_PO_MEMORY_RANGE_ARRAY_LINK(
    ULONG offset32
    );

ULONG
BlAmd64FieldOffset_PO_MEMORY_RANGE_ARRAY_RANGE(
    ULONG offset32
    );

ULONG
BlAmd64ElementOffset_PO_MEMORY_RANGE_ARRAY_LINK(
    ULONG index
    );

ULONG
BlAmd64ElementOffset_PO_MEMORY_RANGE_ARRAY_RANGE(
    ULONG index
    );

VOID
BlCheckForAmd64Image(
    PPO_MEMORY_IMAGE MemImage
    );

VOID
BlStartConfigPrompt(
    VOID
    );

BOOLEAN
BlEndConfigPrompt(
    VOID
    );

BOOLEAN
BlCheckForLoadedDll (
    IN PCHAR DllName,
    OUT PKLDR_DATA_TABLE_ENTRY *FoundEntry
    );

PMEMORY_ALLOCATION_DESCRIPTOR
BlFindMemoryDescriptor(
    IN ULONG BasePage
    );

ARC_STATUS
BlInitResources(
    IN PCHAR StartCommand
    );

PTCHAR
BlFindMessage(
    IN ULONG Id
    );

//
// Define debug function to write on the display console.
//

VOID
BlPrint(
    PTCHAR cp,
    ...
    );

#if DBG
#define DBGTRACE   BlPrint
#else
#define DBGTRACE
#endif


ARC_STATUS
BlGenerateDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor,
    IN MEMORY_TYPE MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount
    );

VOID
BlInsertDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor
    );

#if defined (_X86_)


ARC_STATUS
MempCheckMapping (
    ULONG StartPage,
    ULONG NumberPages
    );

ARC_STATUS
MempFixMapping(
    ULONG StartPage,
    ULONG NumberPages
    );

ARC_STATUS
MempRemoveMapping (
    ULONG StartPage,
    ULONG NumberPages
    );

#endif

#define BlRemoveDescriptor(_md_) RemoveEntryList(&(_md_)->ListEntry)



ARC_STATUS
BlGenerateDeviceNames (
    IN PCHAR ArcDeviceName,
    OUT PCHAR ArcCanonicalName,
    OUT OPTIONAL PCHAR NtDevicePrefix
    );

PCHAR
BlGetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName
    );

PCHAR
BlSetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName,
    IN PCHAR NewValue
    );

//
// Defines for doing console I/O
//
#define ASCII_CR 0x0d
#define ASCII_LF 0x0a
#define ESC 0x1B
#define SGR_INVERSE 7
#define SGR_INTENSE 1
#define SGR_NORMAL 0

extern ULONG ScreenWidth;
extern ULONG ScreenHeight;

//
// Define I/O prototypes.
//

VOID
BlClearScreen(
    VOID
    );

VOID
BlClearToEndOfScreen(
    VOID
    );

VOID
BlClearToEndOfLine(
    VOID
    );

VOID
BlPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

VOID
BlSetInverseMode(
    IN BOOLEAN InverseOn
    );

VOID
BlOutputLoadMessage (
    IN PCHAR DeviceName,
    IN PCHAR FileName,
    IN PTCHAR FileDescription OPTIONAL
    );

ULONG
BlCountLines(
    IN PTCHAR Lines
    );

//
// advanced boot menu prototypes
//

LONG
BlDoAdvancedBoot(
    IN ULONG MenuTitleId,
    IN LONG DefaultBootOption,
    IN BOOLEAN AutoAdvancedBoot,
    IN UCHAR Timeout
    );

PTSTR
BlGetAdvancedBootDisplayString(
    LONG BootOption
    );

PSTR
BlGetAdvancedBootLoadOptions(
    LONG BootOption
    );

VOID
BlDoAdvancedBootLoadProcessing(
    LONG BootOption
    );

ULONG
BlGetAdvancedBootOption(
    VOID
    );


//
// Define file structure recognition prototypes.
//

PBL_DEVICE_ENTRY_TABLE
IsCdfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

#ifdef DBLSPACE_LEGAL
PBL_DEVICE_ENTRY_TABLE
IsDblsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );
#endif

PBL_DEVICE_ENTRY_TABLE
IsFatFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

PBL_DEVICE_ENTRY_TABLE
IsHpfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

PBL_DEVICE_ENTRY_TABLE
IsNtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

#if defined(ELTORITO)
PBL_DEVICE_ENTRY_TABLE
IsEtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );
#endif

PBL_DEVICE_ENTRY_TABLE
IsNetFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    );

//
// Define registry prototypes
//

ARC_STATUS
BlLoadSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName
    );

ARC_STATUS
BlLoadSystemHiveLog(
    IN  ULONG       DeviceId,
    IN  PCHAR       DeviceName,
    IN  PCHAR       DirectoryPath,
    IN  PCHAR       HiveName,
    OUT PULONG_PTR  LogData
    );

ARC_STATUS
BlLoadAndScanSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PWSTR BootFileSystem,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT BOOLEAN *ServerHive,
    OUT PCHAR BadFileName
    );

ARC_STATUS
BlLoadAndInitSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName,
    IN BOOLEAN IsAlternate,
    OUT PBOOLEAN RestartSetup,
    OUT PBOOLEAN LogPresent
    );

ARC_STATUS
BlLoadBootDrivers(
    IN  PPATH_SET   DefaultPathSet,
    IN  PLIST_ENTRY BootDriverListHead,
    OUT PCHAR       BadFileName
    );

PTCHAR
BlScanRegistry(
    IN PWSTR BootFileSystemPath,
    IN OUT BOOLEAN *LastKnownGoodBoot,
    OUT PLIST_ENTRY BootDriverListHead,
    OUT PUNICODE_STRING AnsiCodepage,
    OUT PUNICODE_STRING OemCodepage,
    OUT PUNICODE_STRING LanguageTable,
    OUT PUNICODE_STRING OemHalFont,
#ifdef _WANT_MACHINE_IDENTIFICATION
    OUT PUNICODE_STRING Biosinfo,
#endif
    OUT PSETUP_LOADER_BLOCK SetupLoaderBlock,
    OUT BOOLEAN *ServerHive
    );

ARC_STATUS
BlAddToBootDriverList(
    IN PLIST_ENTRY BootDriverListHead,
    IN PWSTR DriverName,
    IN PWSTR Name,
    IN PWSTR Group,
    IN ULONG Tag,
    IN ULONG ErrorControl,
    IN BOOLEAN InsertAtHead
    );

//
// Define hibernation prototypes
//

ULONG
BlHiberRestore (
    IN ULONG DriveId,
    OUT OPTIONAL PCHAR *BadLinkName
    );

VOID
HbAllocatePtes (
    IN ULONG NumberPages,
    OUT PVOID *PteAddress,
    OUT PVOID *MappedAddress
    );

VOID
HbInitRemap (
    PPFN_NUMBER FreeList
    );

PVOID
HbMapPte (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   Page
    );

PVOID
HbNextSharedPage (
    IN ULONG        PteToMap,
    IN PFN_NUMBER   RealPage
    );

VOID
HbSetPte (
    IN PVOID Va,
    IN PHARDWARE_PTE Pte,
    IN ULONG Index,
    IN ULONG PageNumber
    );

ULONG
HbPageDisposition (
    IN PFN_NUMBER Page
    );

#define HbPageNotInUse          0
#define HbPageInUseByLoader     1
#define HbPageInvalid           2


VOID
HiberSetupForWakeDispatch (
    VOID
    );

typedef
VOID
(*PHIBER_WAKE_DISPATCH)(
    VOID
    );


//
// PTEs reserved for hiberfile (one set used while in
// the loader, and another set provided in the kernels
// memory image)
//

#define PTE_SOURCE              0   // Attention! These defines and
#define PTE_DEST                1   // equates in ntos\boot\lib\i386\wakea.asm
#define PTE_MAP_PAGE            2   // must be the same !!!
#define PTE_REMAP_PAGE          3
#define PTE_HIBER_CONTEXT       4
#define PTE_TRANSFER_PDE        5
#define PTE_WAKE_PTE            6
#define PTE_DISPATCHER_START    7
#define PTE_DISPATCHER_END      8
#define PTE_XPRESS_DEST_FIRST   9
#define PTE_XPRESS_DEST_LAST    (PTE_XPRESS_DEST_FIRST + XPRESS_MAX_PAGES)


// Attention: should be the same as POP_MAX_MDL_SIZE in ntos\po\pop.h !!!
#define HIBER_PTES              (16 + XPRESS_MAX_PAGES)

extern PUCHAR HiberBuffer;
extern PVOID HiberPtes;
extern PUCHAR HiberVa;
extern PVOID HiberIdentityVa;
extern ULONG64 HiberIdentityVaAmd64;
extern ULONG HiberPageFrames[HIBER_PTES];

//
// Define routines for secrets.
//

#define SECPKG_CRED_OWF_PASSWORD  0x00000010

#if defined(REMOTE_BOOT)
ARC_STATUS
BlOpenRawDisk(
    PULONG FileId
    );

ARC_STATUS
BlCloseRawDisk(
    ULONG FileId
    );

ARC_STATUS
BlCheckForFreeSectors (
    ULONG FileId
    );

ARC_STATUS
BlReadSecret(
    ULONG FileId,
    PRI_SECRET Secret
    );

ARC_STATUS
BlWriteSecret(
    ULONG FileId,
    PRI_SECRET Secret
    );
#endif // defined(REMOTE_BOOT)

VOID
BlInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
#endif // defined(REMOTE_BOOT)
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    );

#if defined(REMOTE_BOOT_SECURITY)
VOID
BlParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    );
#endif // defined(REMOTE_BOOT_SECURITY)

VOID
BlOwfPassword(
    IN PUCHAR Password,
    IN PUNICODE_STRING UnicodePassword,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    );


//
// Define external references.
//

extern ULONG BlConsoleOutDeviceId;
extern ULONG BlConsoleInDeviceId;
extern ULONG BlDcacheFillSize;
extern PLOADER_PARAMETER_BLOCK BlLoaderBlock;
extern ULONG DbcsLangId;
extern BOOLEAN BlRebootSystem;
extern ULONG BlVirtualBias;
extern BOOLEAN BlBootingFromNet;
extern BOOLEAN BlUsePae;
extern BOOLEAN BlOldKernel;
extern BOOLEAN BlKernelChecked;
extern BOOLEAN BlRestoring;


#if defined(_ALPHA_) || defined(_IA64_)

extern ULONG HiberNoMappings;
extern ULONG HiberFirstRemap;
extern ULONG HiberLastRemap;
extern BOOLEAN HiberOutOfRemap;
extern BOOLEAN HiberIoError;

#endif
//
// Special linker-defined symbols.  osloader_EXPORTS is the RVA of the
// export table in the osloader.exe image.
// header is the base address of the osloader image.
//
// This allows the OsLoader to export entry points for SCSI miniport drivers.
//

#if defined(_X86_)

extern ULONG OsLoaderBase;
extern ULONG OsLoaderExports;

#endif

#if defined(_IA64_)

extern LONG_PTR OsLoaderBase;
extern LONG_PTR OsLoaderExports;

#endif

//
// Routine to get graphics characters.
//

typedef enum {
    GraphicsCharDoubleRightDoubleDown = 0,
    GraphicsCharDoubleLeftDoubleDown,
    GraphicsCharDoubleRightDoubleUp,
    GraphicsCharDoubleLeftDoubleUp,
    GraphicsCharDoubleVertical,
    GraphicsCharDoubleHorizontal,
#ifdef EFI
    GraphicsCharFullBlock,
    GraphicsCharLightShade,
#endif
    GraphicsCharMax
} GraphicsChar;

_TUCHAR
GetGraphicsChar(
    IN GraphicsChar WhichOne
    );

_TUCHAR
TextGetGraphicsCharacter(
    IN GraphicsChar WhichOne
    );

//
// Control sequence introducer.
//
// On x86 machines the loaders support dbcs and so using
// 0x9b for output is no good (that value is a dbcs lead byte
// in several codepages). Escape-leftbracket is a synonym for CSI
// in the emulated ARC console on x86 (and on many ARC machines too
// but since we can't be sure all the machines out there support
// this we use the old-style csi on non-x86).
//
// We ignore this issue for characters read from the ARC console
// since we don't ask for any text to be typed in, just arrow keys,
// escape, F#, enter, etc.
//

#define ASCI_CSI_IN     0x9b
#if defined(_X86_) || defined(_IA64_)
#define ASCI_CSI_OUT    TEXT("\033[")     // escape-leftbracket
#else
#define ASCI_CSI_OUT    TEXT("\233")      // 0x9b
#endif

//
// Define OS/2 executable resource information structure.
//

#define FONT_DIRECTORY 0x8007
#define FONT_RESOURCE 0x8008

typedef struct _RESOURCE_TYPE_INFORMATION {
    USHORT Ident;
    USHORT Number;
    LONG Proc;
} RESOURCE_TYPE_INFORMATION, *PRESOURCE_TYPE_INFORMATION;

//
// Define OS/2 executable resource name information structure.
//

typedef struct _RESOURCE_NAME_INFORMATION {
    USHORT Offset;
    USHORT Length;
    USHORT Flags;
    USHORT Ident;
    USHORT Handle;
    USHORT Usage;
} RESOURCE_NAME_INFORMATION, *PRESOURCE_NAME_INFORMATION;

//
// Support for reading compressed files directly (single-file MS-ZIP cabinets)
//
VOID
DecompEnableDecompression(
    IN BOOLEAN Enable
    );

ULONG
DecompPrepareToReadCompressedFile(
    IN LPCSTR Filename,
    IN ULONG  FileId
    );

BOOLEAN
DecompGenerateCompressedName(
    IN  LPCSTR Filename,
    OUT LPSTR  CompressedName
    );

//
// Define debug logging macros and functions.
//

#if !DBG && !BLLOGENABLED

#define BlLogInitialize(_x_)
#define BlLogTerminate()
#define BlLog(_x_)
#define BlLogArcDescriptors(_x_)
#define BlLogMemoryDescriptors(_x_)
#define BlLogWaitForKeystroke()

#else

VOID
BlLogInitialize (
    IN ULONG LogfileDeviceId
    );

VOID
BlLogTerminate (
    VOID
    );

#define BlLog(_x_) BlLogPrint _x_

#define LOG_DISPLAY     0x0001
#define LOG_LOGFILE     0x0002
#define LOG_DEBUGGER    0x0004
#define LOG_WAIT        0x8000
#define LOG_ALL         (LOG_DISPLAY | LOG_LOGFILE | LOG_DEBUGGER)
#define LOG_ALL_W       (LOG_ALL | LOG_WAIT)

VOID
BlLogPrint (
    ULONG Targets,
    PCHAR Format,
    ...
    );

VOID
BlLogArcDescriptors (
    ULONG Targets
    );

VOID
BlLogMemoryDescriptors (
    ULONG Targets
    );

VOID
BlLogWaitForKeystroke (
    VOID
    );

#endif // DBG

VOID
BlWaitForReboot (
    VOID
    );

//
// Machine identification related functions.
//

#ifdef _WANT_MACHINE_IDENTIFICATION

#define BlLoadBiosinfoInf(id,n,d,f,i,is,bn) BlLoadFileImage(id,n,d,f,LoaderRegistryData,i,is,bn)

#endif

#define BlLoadDrvDB(id,n,d,f,i,is,bn) BlLoadFileImage(id,n,d,f,LoaderRegistryData,i,is,bn)

ARC_STATUS
BlLoadFileImage(
    IN  ULONG           DeviceId,
    IN  PCHAR           DeviceName,
    IN  PCHAR           Directory,
    IN  PUNICODE_STRING FileName,
    IN  TYPE_OF_MEMORY  MemoryType,
    OUT PVOID           *Image,
    OUT PULONG          ImageSize,
    OUT PCHAR           BadFileName
    );

#if defined(_X86_)
BOOLEAN
BlFindDiskSignature(
    IN PCHAR DiskName,
    IN PARC_DISK_SIGNATURE Signature
    );

VOID
AETerminateIo(
    VOID
    );

BOOLEAN
BlDetectLegacyFreeBios(
    VOID
    );

#endif

//
//
// N.B. We can speed up the boot time, by not
// querying the device for all the possible file systems
// for every open call. This saves approximately 30 secs
// on CD-ROM / DVD-ROM boot time. To disable this feature
// just undef CACHE_DEVINFO below
//
//
#define CACHE_DEVINFO  1

#ifdef CACHE_DEVINFO

//
// NB: make sure that the arc close now invalidates the
// device to filesystem cache entry
//
#ifdef ArcClose

ARC_STATUS
ArcCacheClose(
    IN ULONG DeviceId
    );

//
// Redefine the arc close
//
#undef ArcClose
#define ArcClose(_x) ArcCacheClose(_x)


//
// File system cache clearing hook
//
typedef
VOID
(*PARC_DEVICE_CLOSE_NOTIFICATION) (
    IN ULONG DeviceId
    );

//
// Maximum entities which can register for device close
// notification
//
#define MAX_DEVICE_CLOSE_NOTIFICATION_SIZE   5

extern PARC_DEVICE_CLOSE_NOTIFICATION
DeviceCloseNotify[MAX_DEVICE_CLOSE_NOTIFICATION_SIZE];

ARC_STATUS
ArcRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    );

ARC_STATUS
ArcDeRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    );

#endif //ArcClose

#endif // CACHE_DEVINFO


//
// progress bar functions
// (in blload.c)
//
VOID
BlUpdateBootStatus(
    VOID
    );

VOID
BlRedrawProgressBar(
    VOID
    );

VOID
BlUpdateProgressBar(
    ULONG fPercentage
    );

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    );

VOID
BlOutputStartupMsgStr(
    PCTSTR MsgStr
    );

VOID
BlOutputTrailerMsg(
    ULONG   uMsgID
    );

VOID
BlOutputTrailerMsgStr(
    PCTSTR MsgStr
    );

VOID
BlSetProgBarCharacteristics(
    IN  ULONG   FrontCharMsgID,
    IN  ULONG   BackCharMsgID
    );

//
// The following routines are used by the loader to translate signature-based
// arcnames to scsi-based names.
//

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredTargetComponent(
    IN ULONG ScsiNumber
    );

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredTargetComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    );

PCONFIGURATION_COMPONENT
ScsiGetFirstConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT TargetComponent
    );

PCONFIGURATION_COMPONENT
ScsiGetNextConfiguredLunComponent(
    IN PCONFIGURATION_COMPONENT LunComponent
    );

BOOLEAN
ScsiGetDevicePath(
    IN ULONG ScsiNumber,
    IN PCONFIGURATION_COMPONENT TargetComponent,
    IN PCONFIGURATION_COMPONENT LunComponent,
    OUT PCHAR DevicePath
    );

//
// Boot Status Data support functions.
//

ULONG
BlGetLastBootStatus(
    IN PVOID DataHandle,
    OUT BSD_LAST_BOOT_STATUS *LastBootStatus
    );

VOID
BlAutoAdvancedBoot(
    IN OUT PCHAR *LoadOptions,
    IN BSD_LAST_BOOT_STATUS LastBootStatus,
    IN ULONG AdvancedMode
    );

VOID
BlWriteBootStatusFlags(
    IN ULONG SystemPartitionId,
    IN PUCHAR SystemDirectory,
    IN BOOLEAN LastBootGood,
    IN BOOLEAN LastBootShutdown
    );

ARC_STATUS
BlLockBootStatusData(
    IN ULONG SystemPartitionId,
    IN PCHAR SystemPartition,
    IN PCHAR SystemDirectory,
    OUT PVOID *DataHandle
    );

ARC_STATUS
BlGetSetBootStatusData(
    IN PVOID DataHandle,
    IN BOOLEAN Get,
    IN RTL_BSD_ITEM_TYPE DataItem,
    IN PVOID DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned OPTIONAL
    );

VOID
BlUnlockBootStatusData(
    IN PVOID DataHandle
    );

#if defined(_IA64_) || defined(_X86_)

#define EFI_PARTITION_SUPPORT   1

#endif

#if defined(_IA64_)
extern BOOLEAN BlUsePrivateDescriptor;
#endif


//
// Boot Flags. These are passed from the startup module (startup.com,
// startrom.com or any of the other flavors) to NTLDR. NTDLR will use
// this flag to control different boot options, such as, whether
// to reboot on an NTDLR failure.
//

// upon any startup / ntldr failures the machine will reboot
// instead of waiting for a key press
#define BOOTFLAG_REBOOT_ON_FAILURE      0x000000001

#endif // _BLDR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\efi\inc\sal.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//++
//
//  Module name
//	sal.h
//  Author
//	Allen Kay    (akay)    Jun-12-95
//  Description
//	Defines SAL data structures
//--

#ifndef __SUSAL__
#define __SUSAL__

typedef struct _IA32_BIOS_REGISTER_STATE {

    // general registers
    ULONG eax;    
    ULONG ecx;    
    ULONG edx;    
    ULONG ebx;    
    ULONG esp;    

    // stack registers
    ULONG ebp;    
    ULONG esi;    
    ULONG edi;    

    // eflags
    ULONG eflags;    

    // instruction pointer
    ULONG eip;

    // segment registers
    USHORT cs;    
    USHORT ds;    
    USHORT es;    
    USHORT fs;    
    USHORT gs;    
    USHORT ss;    

    ULONG Reserved1;
    ULONGLONG Reserved2;
} IA32_BIOS_REGISTER_STATE, *PIA32_BIOS_REGISTER_STATE;

typedef union _BIT32_AND_BIT16 {
    ULONG Part32;
    struct {
        USHORT LowPart16;
        USHORT HighPart16;
    };
    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };
} BIT32_AND_BIT16;

//
// EFLAG definition
//
#define CARRY_FLAG       0x1
#define PARITY_FLAG      0x2
#define AUXILARY_FLAG    0x4
#define ZERO_FLAG        0x8
#define SIGN_FLAG        0x10
#define TRAP_FLAG        0x11

//
// SAL descriptor types
//
typedef enum {
    PAL_SAL_EP_TYPE = 0,
    SAL_MEMORY_TYPE,
    PLATFORM_FEATURES_TYPE,
    TRANSLATION_REGISTER_TYPE,
    PTC_COHERENCE_TYPE,
    AP_WAKEUP_TYPE
};

//
//  Format of the SAL System Table (SST) Header. SAL Specs July 2000, Revision: 2.9.
//  The SST is followed by a variable number of entries with varying length.
//

typedef struct _SST_HEADER {
    ULONG   Signature;
    ULONG   Length;
    USHORT  SalRev;
    USHORT  EntryCount;
    UCHAR   CheckSum;
    UCHAR   Reserved1[7];
    USHORT  Sal_A_Version;
    USHORT  Sal_B_Version;
    UCHAR   OemId[32];
    UCHAR   ProductId[32];
    UCHAR   Reserved2[8];
} SST_HEADER, *PSST_HEADER;

//
// PAL and SAL entry point descriptor
//
typedef struct _PAL_SAL_ENTRY_POINT {
    UCHAR EntryType;
    UCHAR Reserved0[7];
    ULONGLONG PalEntryPoint;
    ULONGLONG SalEntryPoint;
    ULONGLONG GlobalPointer;
    UCHAR Reserved1[16];
} PAL_SAL_ENTRY_POINT, *PPAL_SAL_ENTRY_POINT;

//
// Memory descriptor
//
typedef struct _SAL_MEMORY_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR NeedVaReg;
    UCHAR CurrentAttribute;
    UCHAR PageAccessRights;
    UCHAR SupportedAttribute;
    UCHAR Reserved1[1];
    UCHAR MemoryType;
    UCHAR MemoryUsage;
    ULONGLONG Address;
    ULONG Length;
    UCHAR Reserved[4];
    UCHAR OemReserved[8];
} SAL_MEMORY_DESCRIPTOR, *PSAL_MEMORY_DESCRIPTOR;

typedef struct _PLATFORM_FEATURES {
    UCHAR EntryType;
    UCHAR FeatureList;
    UCHAR Reserved[14];
} PLATFORM_FEATURES, *PPLATFORM_FEATURES;

typedef struct _TRANSLATION_REGISTER {
    UCHAR EntryType;
    UCHAR TRType;
    UCHAR TRNumber;
    UCHAR Reserved1[5];
    ULONGLONG VirtualAddress;
    ULONGLONG PageSize;
    UCHAR Reserved2[8];
} TRANSLATION_REGISTER, *PTRANSLATION_REGISTER;

typedef struct _PTC_COHERENCE_DOMAIN {
    UCHAR EntryType;
    UCHAR Reserved[3];
    ULONG NumberOfDomains;
    ULONGLONG CoherenceDomainInfo;
} PTC_COHERENCE_DOMAIN, *PPTC_COHERENCE_DOMAIN;

typedef struct _COHERENCE_DOMAIN_INFO {
    ULONGLONG NumberOfProcessors;
    ULONGLONG LocalIdRegisters;
} COHERENCE_DOMAIN_INFO, *PCOHERENCE_DOMAIN_INFO;

typedef struct _AP_WAKEUP_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR WakeupMechanism;
    UCHAR Reserved[6];
    ULONGLONG WakeupVector;
} AP_WAKEUP_DESCRIPTOR, *PAP_WAKEUP_DESCRIPTOR;

typedef struct _BOOT_INFO_TABLE {
    ULONGLONG Signature;
    ULONG TableLength;
    UCHAR CheckSum;
    UCHAR DriveNumber;
    UCHAR OsRecord;
    UCHAR Reserved1[1];
    PULONGLONG OsBootDevice;
    UCHAR ConsoleInputNumber;
    UCHAR ConsoleOutputNumber;
    UCHAR Reserved2[6];
    ULONGLONG OsBootDeviceRecord;
    ULONGLONG ConsoleIn1DevInfo;
    ULONGLONG ConsoleOut1DevInfo;
} BOOT_INFO_TABLE, *PBOOT_INFO_TABLE;

//
//
// EDD Disk Address Packet definition
//
typedef struct _DISK_ADDRESS_PACKET {
    UCHAR PacketSize;
    UCHAR Reserved0;
    UCHAR BlocksToTransfer;
    UCHAR Reserved1;
    ULONG Buffer32;
    ULONGLONG LBA;
    PUCHAR Buffer64;
} DISK_ADDRESS_PACKET, *PDISK_ADDRESS_PACKET;

//
// SAL procedure function ID's
//
#define SAL_SYSTEM_RESET           0x01000000
#define SAL_SET_VECTORS            0x01000001
#define SAL_GET_STATE_INFO         0x01000002
#define SAL_GET_STATE_INFO_SIZE    0x01000003
#define SAL_CLEAR_STATE_INFO       0x01000004
#define SAL_MC_RENDEZ              0x01000005
#define SAL_MC_SET_PARAMS          0x01000006
#define SAL_VERSION                0x01000007
#define SAL_CACHE_FLUSH            0x01000010
#define SAL_CACHE_INIT             0x01000011
#define SAL_PCI_CONFIG_READ        0x01000030
#define SAL_PCI_CONFIG_WRITE       0x01000031
#define SAL_FREQ_BASE              0x01000032
#define SAL_EXT_ISR_ADD            0x01000033
#define SAL_EXT_ISR_DELETE         0x01000034
#define SAL_ALLOC_MEM              0x01000050
#define SAL_FREE_MEM               0x01000051
#define SAL_UPDATE_PAL             0x01000060

//
// Macro used by functions in exp.c
//
#define BCD_TO_BIN(BcdNumber)       (BcdNumber & 0xf0) + (BcdNumber & 0x0f)

//
// Structure definitions and equates for INT 15 function E820
//

typedef struct _E820_FRAME {
    ULONG ErrorFlag;
    ULONG Key;
    ULONG DescSize;

    ULONG BaseAddrLow;
    ULONG BaseAddrHigh;
    ULONG SizeLow;
    ULONG SizeHigh;
    ULONG MemoryType;
} E820_FRAME, *PE820_FRAME;

//
// Return value structure
//
typedef struct _SAL_RETURN_VALUES {
    ULONGLONG RetVal0;
    ULONGLONG RetVal1;
    ULONGLONG RetVal2;
    ULONGLONG RetVal3;
} SAL_RETURN_VALUES, *PSAL_RETURN_VALUES;

//
// SAL Handoff Parameters
//
typedef struct _SAL_HANDOFF_PARAMS {
    ULONG_PTR MPSConfigTable;
    ULONG_PTR SalSystemTable;
    ULONG_PTR BootInfoTable;
    ULONG_PTR PalProcEp;
    ULONG_PTR SalProcEp;
    ULONGLONG SalProcGp;
    ULONG_PTR AcpiRsdt;
} SAL_HANDOFF_PARAMS, *PSAL_HANDOFF_PARAMS;

//
// Defining entry point for SAL_PROC.
//
typedef
VOID
(*PTRANSFER_ROUTINE) ();

//
// Misc. definitions.
//
#define SAL_BLOCK_SIZE       0x1000    // SAL memory block size

#endif __SUSAL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\blrange.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blrange.h

Abstract:

    This module declares ranges, rangelists and their methods. These
    can be used to keep track of cached ranges of a disk for instance.

Author:

    Cenk Ergan (cenke) 11-Jan-2000

Revision History:

--*/

#ifndef _BLRANGE_H
#define _BLRANGE_H

#include "bldr.h"

//
// Define range & range list data structures. 
//

//
// NOTE: BLCRANGE's Start is inclusive and End is exclusive. E.g.
// 200-400 contains 200th but does not contain 400th byte, apple, 
// meter etc. This allows a single subtraction to determine the 
// number of elements in the range.
//

//
// NOTE: BLCRANGE's Start should be less than or equal to its End.
//

//
// Representing ranges with start and end instead of start and length
// seems to simplify the code and remove a lot of addition and
// subtractions. We could maybe use a ULONG Length, which would save 4
// bytes per range, but lists make it hard to have thousands of ranges
// and even if you had 10 thousand ranges, you'd save only 40KB, which
// seemed to be insignificant to the cons above when I began changing
// the code to have Length instead of End. With both Start and End
// ULONGLONG more data can be represented by ranges, e.g. 64bit
// offsets [memory or disk] where 4GB Length may not be enough.
//

typedef struct _BLCRANGE
{
    ULONGLONG Start;
    ULONGLONG End;
} BLCRANGE, *PBLCRANGE;

typedef struct _BLCRANGE_ENTRY
{
    LIST_ENTRY Link;
    BLCRANGE Range;
    PVOID UserData;      // UserData field is not used by range functions.
    LIST_ENTRY UserLink; // UserLink field is not used by range functions.
} BLCRANGE_ENTRY, *PBLCRANGE_ENTRY;

//
// Define range entry merging routine type. This routine should
// perform the necessary operations to merge the user controlled /
// maintained Data field of the pSrcEntry to pDestEntry's Data
// field. It should not manipulate any other BLCRANGE_ENTRT fields. It
// should return FALSE if there was an error and it could not merge
// the two Data fields, TRUE otherwise. If it returns FALSE, it should
// undo its modifications to pDestEntry and pSrcEntry.
//

typedef 
BOOLEAN
(*PBLCRANGE_MERGE_ROUTINE) (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    );

//
// Define range entry free'ing routine type. This routine should free
// all the resources & memory allocated for a range entry.
//

typedef
VOID
(*PBLCRANGE_FREE_ROUTINE) (
    PBLCRANGE_ENTRY pRangeEntry
    );

//
// BLCRANGE_LIST maintains a sorted list of non-overlapping range
// entries off its Head field.
//

typedef struct _BLCRANGE_LIST
{
    LIST_ENTRY Head;
    ULONG NumEntries;
    PBLCRANGE_MERGE_ROUTINE MergeRoutine;
    PBLCRANGE_FREE_ROUTINE FreeRoutine;
} BLCRANGE_LIST, *PBLCRANGE_LIST;

//
// Useful macros. Be mindful of expression reevaluation as with
// all macros.
//

#define BLRGMIN(a,b) (((a) <= (b)) ? (a) : (b))
#define BLRGMAX(a,b) (((a) >= (b)) ? (a) : (b))

//
// Range function prototypes. See ntos\boot\lib\blrange.c for comments
// and implementation.
//

VOID
BlRangeListInitialize (
    PBLCRANGE_LIST pRangeList,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine,
    OPTIONAL PBLCRANGE_FREE_ROUTINE pFreeRoutine
    );

BOOLEAN
BlRangeListAddRange (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE_ENTRY pRangeEntry
    );

BOOLEAN
BlRangeListFindOverlaps (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE_ENTRY *pOverlapsBuffer,
    ULONG OverlapsBufferSize,
    OUT ULONG *pNumOverlaps
    );

BOOLEAN
BlRangeListFindDistinctRanges (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE pDistinctRanges,
    ULONG BufferSize,
    OUT ULONG *pNumRanges
    );

VOID
BlRangeListRemoveRange (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange
);

VOID
BlRangeListRemoveAllRanges (
    PBLCRANGE_LIST pRangeList
);

BOOLEAN
BlRangeListMergeRangeEntries (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    );

BOOLEAN
BlRangeEntryMerge (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine
    );

#endif // _BLRANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\blcache.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blcache.h

Abstract:

    This module declares parameters, data structures and functions for
    a general purpose disk caching for the boot loader. Although it is
    mostly general purpose, it is mainly used for caching filesystem
    metadata, since that is the only frequently reaccessed data in the
    boot loader. In order to use caching on a device, you must make
    sure that there is only one unique BlFileTable entry for that
    device and the same device is not opened & cached simultaneously
    multiple times under different device ids. Otherwise there will be
    cache inconsistencies, since cached data and structures are
    maintained based on device id. Also you must make sure to stop
    caching when the device is closed.

Author:

    Cenk Ergan (cenke) 14-Jan-2000

Revision History:

--*/

#ifndef _BLCACHE_H
#define _BLCACHE_H

#include "bldr.h"
#include "blrange.h"

//
// Define boot loader disk cache parameters and data structures.
//

//
// Currently device id - cache header pairing is done using a global
// table. This determines maximum number of entries in this table. We
// really need just two entries, one for LoadDevice, one for
// SystemDevice. Caches for all devices share the same resources
// [e.g. cache blocks and Most Recently Used list etc.]
//

#define BL_DISKCACHE_DEVICE_TABLE_SIZE 2

//
// Size of ranges that are cached. We read & cache fixed size blocks
// from the devices which makes memory management easy, since we can't
// use boot loader's: there is no HeapFree, just HeapAlloc! BLOCK_SIZE
// has to be a power of two for alignment arithmetic to work.
//

#define BL_DISKCACHE_BLOCK_SIZE (32 * 1024)

//
// Maximum number of bytes cached in the disk cache [i.e. maximum size
// disk cache may grow to]. This should be a multiple of BLOCK_SIZE below.
//

#define BL_DISKCACHE_SIZE (64 * BL_DISKCACHE_BLOCK_SIZE)

//
// Maximum number of cache blocks / range entries there can be in the
// cache. There will be a range entry for each block, i.e. it should
// be cache size / block size.
//

#define BL_DISKCACHE_NUM_BLOCKS (BL_DISKCACHE_SIZE / BL_DISKCACHE_BLOCK_SIZE)

//
// Size of the buffer needed for storing maximum number of overlapping
// or distinct range entries for a 64KBs request given BLOCK_SIZE. We
// reserve this on the stack [i.e. buffer is a local variable] in
// BlDiskCacheRead: make sure it is not too big! We base it assuming
// that distincts buffer will be larger [since it is BLCRANGE entries
// instead where as overlaps buffer contains BLCRANGE_ENTRY pointers.]
//

#define BL_DISKCACHE_FIND_RANGES_BUF_SIZE \
    (((64 * 1024 / BL_DISKCACHE_BLOCK_SIZE) + 3) * (sizeof(BLCRANGE)))

//
// This is the header for the cache for a particular device. The
// cached ranges on this device are stored in the Ranges list.
//

typedef struct _BL_DISK_SUBCACHE
{
    BOOLEAN Initialized;
    ULONG DeviceId;
    BLCRANGE_LIST Ranges;
} BL_DISK_SUBCACHE, *PBL_DISK_SUBCACHE;

//
// Define structure for the global boot loader diskcache.
//

typedef struct _BL_DISKCACHE
{
    //
    // Table that contains cache headers. Cache - DeviceId pairing is
    // also done using this table.
    //

    BL_DISK_SUBCACHE DeviceTable[BL_DISKCACHE_DEVICE_TABLE_SIZE];

    //
    // Most recently used list for cached blocks [range
    // entries]. Entries are linked through the UserLink field in the
    // BLCRANGE_ENTRY. The least recently used block is at the very
    // end. Any entries placed on a cache's range list is also put on
    // this list. When removing a range from a cache's range list, the
    // callback removes it from this list too. BlDiskCacheRead updates
    // this list and prunes it if normal cache entry allocation fails.
    //

    LIST_ENTRY MRUBlockList;

    //
    // This is where cached data is stored. Its size is
    // BL_DISKCACHE_SIZE. It is divided up into BL_DISKCACHE_NUM_BLOCKS 
    // blocks. Nth block belongs to Nth entry in the EntryBuffer.
    //

    PUCHAR DataBuffer;

    //
    // Range entries to be put into the cache's range lists are
    // allocated from here. It has BL_DISKCACHE_NUM_BLOCKS elements.
    //

    PBLCRANGE_ENTRY EntryBuffer;

    //
    // This array is used for keeping track of the free range entries
    // in EntryBuffer. Free range entries get linked up on this list
    // using the UserLink field. Once the entry is allocated, the
    // UserLink field is usually used to link it up to the MRU list.
    //

    LIST_ENTRY FreeEntryList;

    //
    // Keep track of whether we are initialized or not.
    //
    
    BOOLEAN Initialized;

} BL_DISKCACHE, *PBL_DISKCACHE;

//
// Declare global variables.
//

//
// This is the boot loader disk cache with all its bells and whistles.
//

extern BL_DISKCACHE BlDiskCache;

//
// Debug defines. Use these to actively debug the disk cache. These
// are not turned on for checked build, because they would spew out
// too much to the console.
//

#ifdef BL_DISKCACHE_DEBUG
#define DPRINT(_x) DbgPrint _x;
#define DASSERT(_c) do { if (_c) DbgBreakPoint(); } while (0);
#else // BL_DISKCACHE_DEBUG
#define DPRINT(_x)
#define DASSERT(_c)
#endif // BL_DISKCACHE_DEBUG

//
// These two defines are used as the last parameter to BlDiskCacheRead.
// They specify whether any new data read from the disk should be put
// into the disk cache or not. In the boot loader file systems we usually 
// choose to cache new data if we are reading metadata, and not choose to 
// cache it if we are reading file data.
//

#define CACHE_NEW_DATA       (TRUE)
#define DONT_CACHE_NEW_DATA  (FALSE)

//
// Useful macros. Be mindful of expression reevaluation as with
// all macros.
//

#define BLCMIN(a,b) (((a) <= (b)) ? (a) : (b))
#define BLCMAX(a,b) (((a) >= (b)) ? (a) : (b))

//
// Cache function prototypes. See ntos\boot\lib\blcache.c for comments
// and implementation.
//

ARC_STATUS
BlDiskCacheInitialize(
    VOID
    );

VOID
BlDiskCacheUninitialize(
    VOID
    );

PBL_DISK_SUBCACHE
BlDiskCacheStartCachingOnDevice(
    ULONG DeviceId
    );

VOID
BlDiskCacheStopCachingOnDevice(
    ULONG DeviceId
    );

ARC_STATUS
BlDiskCacheRead (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,
    PVOID Buffer,
    ULONG Length,
    PULONG pCount,
    BOOLEAN CacheNewData
    );

ARC_STATUS
BlDiskCacheWrite (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,   
    PVOID Buffer,
    ULONG Length,
    PULONG pCount
    );

#endif // _BLCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\bldrx86.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bldrx86.h

Abstract:

    Contains definitions and prototypes specific to the x86 NTLDR.

Author:

    John Vert (jvert) 20-Dec-1993

Revision History:

--*/

#ifndef _BLDRX86_
#define _BLDRX86_

#include "bldr.h"

//
// Define specific ranges where parts of the system should be loaded
//
//
// X86 is limited to the first 512MB of physical address space
// We also try to pack kernel and HAL into a single 4MB page
//
#define BL_KERNEL_RANGE_LOW  (ULONG)((BlVirtualBias) ? _12MB : _4MB )
#define BL_KERNEL_RANGE_HIGH (ULONG)((BlVirtualBias) ? _16MB : _8MB )

//
// Specific range for the disk cache since this is allocated before the
// kernel and HAL are loaded and we want to keep its 2MB out of the 4MB
// page we are trying to cram the kernel and HAL into.
//
#define BL_DISK_CACHE_RANGE_LOW   (_8MB)
#define BL_DISK_CACHE_RANGE_HIGH  (_16MB)

#define BL_DRIVER_RANGE_LOW  (ULONG)0
#define BL_DRIVER_RANGE_HIGH (ULONG)(_512MB)

#define BL_DECOMPRESS_RANGE_LOW  (ULONG)(0)
#define BL_DECOMPRESS_RANGE_HIGH (ULONG)(_512MB)

#define BL_XIPROM_RANGE_LOW   (ULONG)BlUsableBase
#define BL_XIPROM_RANGE_HIGH  (ULONG)(_512MB)

#define OLD_ALTERNATE (0xe1000000 - 64 * 1024 * 1024)

VOID
AEInitializeStall(
    VOID
    );

ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    );

VOID
AEGetArcDiskInformation(
    VOID
    );

PVOID
FwAllocateHeap(
    IN ULONG Size
    );

VOID
MdShutoffFloppy(
    VOID
    );

PCHAR
BlSelectKernel(
    IN ULONG DriveId,
    IN PCHAR BootFile,
    OUT PCHAR *LoadOptions,
    IN BOOLEAN UseTimeOut
    );


BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );

VOID
BlStartup(
    IN PCHAR PartitionName
    );

//
// Arc routines for supporting common VGA I/O routines
//
#define ARC_DISPLAY_CLEAR_ESCAPE "\033[2J"
#define ARC_DISPLAY_CLEAR()  { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, ARC_DISPLAY_CLEAR_ESCAPE, \
              sizeof(ARC_DISPLAY_CLEAR_ESCAPE) - 1, &LocalCount); \
     }

#define ARC_DISPLAY_CLEAR_TO_EOD() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0J", sizeof("\033[0J") - 1, &LocalCount); \
}

#define ARC_DISPLAY_CLEAR_TO_EOL() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0K", sizeof("\033[0K") - 1, &LocalCount); \
}

#define ARC_DISPLAY_ATTRIBUTES_OFF() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0m", sizeof("\033[0m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_INVERSE_VIDEO() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[7m", sizeof("\033[7m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_SET_COLOR(c) { \
     ULONG LocalCount; \
     CHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%sm", c); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}

#define ARC_DISPLAY_POSITION_CURSOR(x, y) { \
     ULONG LocalCount; \
     CHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%d;%dH", y + 1, x + 1); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}

extern BOOLEAN BlTerminalConnected;
extern ULONG BlTerminalDeviceId;
extern ULONG BlTerminalDelay;


LOGICAL
BlTerminalAttached(
    IN ULONG TerminalDeviceId
    );


//
// Routine for checking if a character is the lead byt to a double-byte
//
BOOLEAN
GrIsDBCSLeadByte(
    IN UCHAR c
    );

VOID
UTF8Encode(
    USHORT  InputValue,
    PUCHAR UTF8Encoding
    );

VOID
GetDBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    );


VOID
GetSBCSUtf8Translation(
    PUCHAR InputChar,
    PUCHAR UTF8Encoding
    );

ARC_STATUS
MempAllocDescriptor(
    IN ULONG StartPage,
    IN ULONG EndPage,
    IN TYPE_OF_MEMORY MemoryType
    );

typedef struct {
    ULONG       ErrorFlag;
    ULONG       Key;
    ULONG       Size;
    struct {
        ULONG       BaseAddrLow;
        ULONG       BaseAddrHigh;
        ULONG       SizeLow;
        ULONG       SizeHigh;
        ULONG       MemoryType;
    } Descriptor;
} E820FRAME, *PE820FRAME;


//          E X T E R N A L   S E R V I C E S   T A B L E
//
// External Services Table - machine dependent services
// like reading a sector from the disk and finding out how
// much memory is installed are provided by a lower level
// module or a ROM BIOS. The EST provides entry points
// for the OS loader.
//

//**
// NOTE WELL
//      The offsets of entries in this structure MUST MATCH
//      the offsets of BOTH the ExportEntryTable in ....\startup\i386\sudata.asm
//      AND ...\startrom\i386\sudata.asm.  You must change all 3
//      locations together.
//**

typedef struct _EXTERNAL_SERVICES_TABLE {
    VOID (__cdecl *  RebootProcessor)(VOID);
    NTSTATUS (__cdecl * DiskIOSystem)(UCHAR,UCHAR,USHORT,USHORT,UCHAR,UCHAR,PUCHAR);
    ULONG (__cdecl * GetKey)(VOID);
    ULONG (__cdecl * GetCounter)(VOID);
    VOID (__cdecl * Reboot)(ULONG);
    VOID (__cdecl * DetectHardware)(ULONG, ULONG, PVOID, PULONG, PCHAR, ULONG);
    VOID (__cdecl * HardwareCursor)(ULONG,ULONG);
    VOID (__cdecl * GetDateTime)(PULONG,PULONG);
    VOID (__cdecl * ComPort)(LONG,ULONG,UCHAR);
    ULONG (__cdecl * GetStallCount)(VOID);
    VOID (__cdecl * InitializeDisplayForNt)(VOID);
    VOID (__cdecl * GetMemoryDescriptor)(P820FRAME);
    NTSTATUS (__cdecl * GetEddsSector)(UCHAR,ULONG,ULONG,USHORT,PUCHAR,UCHAR);
    NTSTATUS (__cdecl * GetElToritoStatus)(PUCHAR,UCHAR);
    BOOLEAN (__cdecl * GetExtendedInt13Params)(PUCHAR,UCHAR);
    USHORT (__cdecl * NetPcRomServices)(ULONG,PVOID);
    VOID (__cdecl * ApmAttemptReconnect)(VOID);
    ULONG (__cdecl * BiosRedirectService)(ULONG);
} EXTERNAL_SERVICES_TABLE, *PEXTERNAL_SERVICES_TABLE;
extern PEXTERNAL_SERVICES_TABLE ExternalServicesTable;

//**
// SEE NOTE AT TOP OF STRUCTURE
//**

//
// External Services Macros
//

#define REBOOT_PROCESSOR    (*ExternalServicesTable->RebootProcessor)
#define GET_SECTOR          (*ExternalServicesTable->DiskIOSystem)
#define RESET_DISK          (*ExternalServicesTable->DiskIOSystem)
#define BIOS_IO             (*ExternalServicesTable->DiskIOSystem)
#define GET_KEY             (*ExternalServicesTable->GetKey)
#define GET_COUNTER         (*ExternalServicesTable->GetCounter)
#define REBOOT              (*ExternalServicesTable->Reboot)
#define DETECT_HARDWARE     (*ExternalServicesTable->DetectHardware)
#define HW_CURSOR           (*ExternalServicesTable->HardwareCursor)
#define GET_DATETIME        (*ExternalServicesTable->GetDateTime)
#define COMPORT             (*ExternalServicesTable->ComPort)
#define GET_STALL_COUNT     (*ExternalServicesTable->GetStallCount)
#define SETUP_DISPLAY_FOR_NT (*ExternalServicesTable->InitializeDisplayForNt)
#define GET_MEMORY_DESCRIPTOR (*ExternalServicesTable->GetMemoryDescriptor)
#define GET_EDDS_SECTOR     (*ExternalServicesTable->GetEddsSector)
#define GET_ELTORITO_STATUS (*ExternalServicesTable->GetElToritoStatus)
#define GET_XINT13_PARAMS   (*ExternalServicesTable->GetExtendedInt13Params)
#define NETPC_ROM_SERVICES  (*ExternalServicesTable->NetPcRomServices)
#define APM_ATTEMPT_RECONNECT (*ExternalServicesTable->ApmAttemptReconnect)
#define BIOS_REDIRECT_SERVICE (*ExternalServicesTable->BiosRedirectService)

//
// Define special key input values
//
#define DOWN_ARROW  0x5000
#define UP_ARROW    0x4800
#define HOME_KEY    0x4700
#define END_KEY     0x4F00
#define LEFT_KEY    0x4B00
#define RIGHT_KEY   0x4D00
#define INS_KEY     0x5200
#define DEL_KEY     0x5300
#define BKSP_KEY    0x0E08
#define TAB_KEY     0x0009
#define BACKTAB_KEY 0x0F00
#define F1_KEY      0x3B00
#define F2_KEY      0x3C00
#define F3_KEY      0x3D00
#define F4_KEY      0x3E00
#define F5_KEY      0x3F00
#define F6_KEY      0x4000
#define F7_KEY      0x4100
#define F8_KEY      0x4200
#define F10_KEY     0x4400
#define F11_KEY     0xD900
#define F12_KEY     0xDA00
#define ENTER_KEY   0x000D
#define ESCAPE_KEY  0x011B



//
// x86-specific video support
//
VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    );

VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    );

VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGetCurrentAttribute(
    VOID
    );

VOID
TextClearDisplay(
    VOID
    );

VOID
TextClearToEndOfDisplay(
    VOID
    );

VOID
TextClearFromStartOfLine(
    VOID
    );

VOID
TextClearToEndOfLine(
    VOID
    );

VOID
TextStringOut(
    IN PUCHAR String
    );

PUCHAR
TextCharOut(
    IN PUCHAR pc
    );

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );

VOID
TextGrInitialize(
    IN ULONG DiskId,
    OUT PULONG ImageLength
    );

VOID
TextGrTerminate(
    VOID
    );

#define BlPuts(str) TextStringOut(str)

ULONG
BlGetKey(
    VOID
    );

VOID
BlInputString(
    IN ULONG Prompt,
    IN ULONG CursorX,
    IN ULONG CursorY,
    IN PUCHAR String,
    IN ULONG MaxLength
    );

//
// Watchdog Timer
//

#define X86_WATCHDOG_TIMEOUT  (60*5)

VOID
SetX86WatchDog(
    ULONG TimeOut
    );

#endif // _BLDRX86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\bootefi.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bootefi.h

Abstract:

    Contains definitions and prototypes specific to EFI based os loaders.

Author:

    Andrew Ritz (andrewr) 21-Nov-2000

Revision History:

--*/

#ifndef _BOOTEFI_
#define _BOOTEFI_

#include "efi.h"
//
// these are ARC constants, used for mapping ARC attributes to EFI
// attributes
//
#define ATT_FG_BLACK        0
#define ATT_FG_RED          1
#define ATT_FG_GREEN        2
#define ATT_FG_YELLOW       3
#define ATT_FG_BLUE         4
#define ATT_FG_MAGENTA      5
#define ATT_FG_CYAN         6
#define ATT_FG_WHITE        7

#define ATT_BG_BLACK       (ATT_FG_BLACK   << 4)
#define ATT_BG_BLUE        (ATT_FG_BLUE    << 4)
#define ATT_BG_GREEN       (ATT_FG_GREEN   << 4)
#define ATT_BG_CYAN        (ATT_FG_CYAN    << 4)
#define ATT_BG_RED         (ATT_FG_RED     << 4)
#define ATT_BG_MAGENTA     (ATT_FG_MAGENTA << 4)
#define ATT_BG_YELLOW      (ATT_FG_YELLOW  << 4)
#define ATT_BG_WHITE       (ATT_FG_WHITE   << 4)

#define ATT_FG_INTENSE      8
#define ATT_BG_INTENSE     (ATT_FG_INTENSE << 4)

#define DEFIATT   (ATT_FG_WHITE | ATT_BG_BLUE | ATT_FG_INTENSE)
// intense red on blue doesn't show up on all monitors.
//#define DEFERRATT (ATT_FG_RED   | ATT_BG_BLUE | ATT_FG_INTENSE)
#define DEFERRATT DEFATT
#define DEFSTATTR (ATT_FG_BLACK | ATT_BG_WHITE)
#define DEFDLGATT (ATT_FG_RED   | ATT_BG_WHITE)




//
// EFI utility prototypes
//                
VOID
FlipToPhysical();

VOID
FlipToVirtual();

BOOLEAN
IsPsrDtOn();

//
// display related prototypes
//      
BOOLEAN
BlEfiClearDisplay(
    VOID
    );

BOOLEAN
BlEfiClearToEndOfDisplay(
    VOID
    );

BOOLEAN
BlEfiClearToEndOfLine(
    VOID
    );

ULONG
BlEfiGetColumnsPerLine(
    VOID
    );

ULONG
BlEfiGetLinesPerRow(
    VOID
    );


BOOLEAN
BlEfiGetCursorPosition(
    OUT PULONG x, OPTIONAL
    OUT PULONG y OPTIONAL
    );

BOOLEAN
BlEfiPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    );

BOOLEAN
BlEfiEnableCursor(
    BOOLEAN bVisible
    );

BOOLEAN
BlEfiSetAttribute(
    ULONG Attribute
    );

BOOLEAN
BlEfiSetInverseMode(
    BOOLEAN fInverseOn
    );

USHORT
BlEfiGetGraphicsChar(
    IN GraphicsChar WhichOne
    );

VOID
DBG_EFI_PAUSE(
    VOID
    );

VOID
EFITRACE( PTCHAR p, ... );


UINT16
__cdecl
wsprintf(
    CHAR16 *buf,
    const CHAR16 *fmt,
    ...);

extern WCHAR DebugBuffer[512];

CHAR16*
DevicePathToStr(
    EFI_DEVICE_PATH UNALIGNED *DevPath
    );

VOID
DisableEFIWatchDog(
    VOID
    );

#define EFI_WATCHDOG_TIMEOUT 60 * 20

VOID
SetEFIWatchDog(
    ULONG Timeout
    );

ARC_STATUS
BlGetEfiProtocolHandles(
    IN EFI_GUID *ProtocolType,
    OUT EFI_HANDLE **pHandleArray,
    OUT ULONG *NumberOfDevices
    );

ARC_STATUS
BlLoadEFIImage(
    IN PCCHAR PartitionArcName,
    IN PCCHAR ImagePath,
    IN PCCHAR ImageName OPTIONAL,
    IN BOOLEAN StartImage,
    OUT EFI_HANDLE* EfiHandle OPTIONAL
    );

VOID
SetupSMBiosInLoaderBlock(
    VOID
    );


#endif // _BOOTEFI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\bldria64.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    bldria64.h

Abstract:

    Contains definitions and prototypes specific to the IA64 NTLDR.

Author:

    John Vert (jvert) 20-Dec-1993

Revision History:

--*/

#ifndef _BLDRIA64_
#define _BLDRIA64_

#include "bldr.h"
#include "bootefi.h"
#include "efi.h"

VOID
AEInitializeStall(
    VOID
    );

ARC_STATUS
AEInitializeIo(
    IN ULONG DriveId
    );

//
// FIX: this routine is currently broken on IA64.
//
PVOID
FwAllocateHeap(
    IN ULONG Size
    );

PCHAR
BlSelectKernel(
    VOID
    );


BOOLEAN
BlDetectHardware(
    IN ULONG DriveId,
    IN PCHAR LoadOptions
    );

VOID
BlStartup(
    IN PCHAR PartitionName
    );

#ifndef EFI
//
// Arc routines for supporting common VGA I/O routines
//
#define ARC_DISPLAY_CLEAR_ESCAPE "\033[2J"
#define ARC_DISPLAY_CLEAR()  { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, ARC_DISPLAY_CLEAR_ESCAPE, \
              sizeof(ARC_DISPLAY_CLEAR_ESCAPE) - 1, &LocalCount); \
     }

#define ARC_DISPLAY_CLEAR_TO_EOD() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0J", sizeof("\033[0J") - 1, &LocalCount); \
}

#define ARC_DISPLAY_CLEAR_TO_EOL() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0K", sizeof("\033[0K") - 1, &LocalCount); \
}

#define ARC_DISPLAY_ATTRIBUTES_OFF() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[0m", sizeof("\033[0m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_INVERSE_VIDEO() { \
     ULONG LocalCount; \
     ArcWrite(BlConsoleOutDeviceId, "\033[7m", sizeof("\033[7m") - 1, &LocalCount); \
}

#define ARC_DISPLAY_SET_COLOR(c) { \
     ULONG LocalCount; \
     UCHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%sm", c); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}

#define ARC_DISPLAY_POSITION_CURSOR(x, y) { \
     ULONG LocalCount; \
     UCHAR LocalBuffer[40]; \
     sprintf(LocalBuffer, "\033[%d;%dH", y + 1, x + 1); \
     ArcWrite(BlConsoleOutDeviceId, LocalBuffer, strlen(LocalBuffer), &LocalCount); \
}
#endif

//
// headless routines
//
extern BOOLEAN BlTerminalConnected;
extern ULONG BlTerminalDeviceId;
extern ULONG BlTerminalDelay;

LOGICAL
BlTerminalAttached(
    IN ULONG TerminalDeviceId
    );

//          E X T E R N A L   S E R V I C E S   T A B L E
//
// External Services Table - machine dependent services
// like reading a sector from the disk and finding out how
// much memory is installed are provided by a lower level
// module or a ROM BIOS. The EST provides entry points
// for the OS loader.
//

//**
// NOTE WELL
//      The offsets of entries in this structure MUST MATCH
//      the offsets of BOTH the ExportEntryTable in ....\startup\i386\sudata.asm
//      AND ...\startrom\i386\sudata.asm.  You must change all 3
//      locations together.
//**

typedef struct _EXTERNAL_SERVICES_TABLE {
    ARC_STATUS (__cdecl *  RebootProcessor)(VOID);
    ARC_STATUS (__cdecl * DiskIOSystem)(ULONG,ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
    ULONG (__cdecl * GetKey)(VOID);
    ULONG (__cdecl * GetCounter)(VOID);
    VOID (__cdecl * Reboot)(ULONG);
    ULONG (__cdecl * AbiosServices)(USHORT,PUCHAR,PUCHAR,PUCHAR,PUCHAR,USHORT,USHORT);
    VOID (__cdecl * DetectHardware)(ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
    VOID (__cdecl * HardwareCursor)(ULONG,ULONG);
    VOID (__cdecl * GetDateTime)(PULONG,PULONG);
    VOID (__cdecl * ComPort)(LONG,ULONG,UCHAR);
    BOOLEAN (__cdecl * IsMcaMachine)(VOID);
    ULONG (__cdecl * GetStallCount)(VOID);
    VOID (__cdecl * InitializeDisplayForNt)(VOID);
    VOID (__cdecl * GetMemoryDescriptor)(P820FRAME);
    ARC_STATUS (__cdecl * GetEddsSector)(EFI_HANDLE,ULONG,ULONG,ULONG,PUCHAR,UCHAR);
    BOOLEAN (__cdecl * GetElToritoStatus)(PUCHAR,UCHAR);
    BOOLEAN (__cdecl * GetExtendedInt13Params)(PUCHAR,UCHAR);
    USHORT (__cdecl * NetPcRomServices)(ULONG,PVOID);
    VOID (__cdecl * ApmAttemptReconnect)(VOID);
    ULONG (__cdecl * BiosRedirectService)(ULONG);
} EXTERNAL_SERVICES_TABLE, *PEXTERNAL_SERVICES_TABLE;
extern PEXTERNAL_SERVICES_TABLE ExternalServicesTable;

//**
// SEE NOTE AT TOP OF STRUCTURE
//**

//
// External Services Macros
//

#define REBOOT_PROCESSOR    (*ExternalServicesTable->RebootProcessor)
#define GET_SECTOR          (*ExternalServicesTable->DiskIOSystem)
#define RESET_DISK          (*ExternalServicesTable->DiskIOSystem)
#define BIOS_IO             (*ExternalServicesTable->DiskIOSystem)
#define GET_KEY             (*ExternalServicesTable->GetKey)
#define GET_COUNTER         (*ExternalServicesTable->GetCounter)
#define REBOOT              (*ExternalServicesTable->Reboot)
#define ABIOS_SERVICES      (*ExternalServicesTable->AbiosServices)
#define DETECT_HARDWARE     (*ExternalServicesTable->DetectHardware)
#define HW_CURSOR           (*ExternalServicesTable->HardwareCursor)
#define GET_DATETIME        (*ExternalServicesTable->GetDateTime)
#define COMPORT             (*ExternalServicesTable->ComPort)
#define ISMCA               (*ExternalServicesTable->IsMcaMachine)
#define GET_STALL_COUNT     (*ExternalServicesTable->GetStallCount)
#define SETUP_DISPLAY_FOR_NT (*ExternalServicesTable->InitializeDisplayForNt)
#define GET_MEMORY_DESCRIPTOR (*ExternalServicesTable->GetMemoryDescriptor)
#define GET_EDDS_SECTOR     (*ExternalServicesTable->GetEddsSector)
#define GET_ELTORITO_STATUS (*ExternalServicesTable->GetElToritoStatus)
#define GET_XINT13_PARAMS   (*ExternalServicesTable->GetExtendedInt13Params)
#define NETPC_ROM_SERVICES  (*ExternalServicesTable->NetPcRomServices)
#define APM_ATTEMPT_RECONNECT (*ExternalServicesTable->ApmAttemptReconnect)
#define BIOS_REDIRECT_SERVICE (*ExternalServicesTable->BiosRedirectService)

//
// Define special key input values
//
#define DOWN_ARROW  0x5000
#define UP_ARROW    0x4800
#define HOME_KEY    0x4700
#define END_KEY     0x4F00
#define LEFT_KEY    0x4B00
#define RIGHT_KEY   0x4D00
#define INS_KEY     0x5200
#define DEL_KEY     0x5300
#define BKSP_KEY    0x0E08
#define TAB_KEY     0x0009
#define BACKTAB_KEY 0x0F00
#define F1_KEY      0x3B00
#define F2_KEY      0x3C00
#define F3_KEY      0x3D00
#define F4_KEY      0x3E00
#define F5_KEY      0x3F00
#define F6_KEY      0x4000
#define F7_KEY      0x4100
#define F8_KEY      0x4200
#define F10_KEY     0x4400
#define ENTER_KEY   0x000D
#define ESCAPE_KEY  0x011B

//
// define various memory segments that are needed by the ia64 loaders
//


#define ROM_START_PAGE (0x0A0000 >> PAGE_SHIFT)
#define ROM_END_PAGE   (0x100000 >> PAGE_SHIFT)

//
// Define specific ranges where parts of the system should be loaded
//
#define BL_KERNEL_RANGE_LOW  _48MB
#define BL_KERNEL_RANGE_HIGH _64MB

#define BL_DRIVER_RANGE_LOW  _64MB
#define BL_DRIVER_RANGE_HIGH _128MB

#define BL_DECOMPRESS_RANGE_LOW  _32MB
#define BL_DECOMPRESS_RANGE_HIGH _48MB

#define BL_DISK_CACHE_RANGE_LOW   BlUsableBase
#define BL_DISK_CACHE_RANGE_HIGH  BlUsableLimit

#define BL_XIPROM_RANGE_LOW   BlUsableBase
#define BL_XIPROM_RANGE_HIGH  0xffffffff


//
// x86-specific video support
//
VOID
TextGetCursorPosition(
    OUT PULONG X,
    OUT PULONG Y
    );

VOID
TextSetCursorPosition(
    IN ULONG X,
    IN ULONG Y
    );

VOID
TextSetCurrentAttribute(
    IN UCHAR Attribute
    );

UCHAR
TextGetCurrentAttribute(
    VOID
    );

VOID
TextClearDisplay(
    VOID
    );

VOID
TextClearToEndOfDisplay(
    VOID
    );

VOID
TextClearFromStartOfLine(
    VOID
    );

VOID
TextClearToEndOfLine(
    VOID
    );

VOID
TextStringOut(
    IN PWCHAR String
    );

VOID
TextCharOut(
    IN PWCHAR pc
    );

VOID
TextFillAttribute(
    IN UCHAR Attribute,
    IN ULONG Length
    );


#define BlPuts(str) TextStringOut(str)

ULONG
BlGetKey(
    VOID
    );

ULONGLONG
BlSetInputTimeout(
    ULONGLONG
    );

ULONGLONG
BlGetInputTimeout(
    VOID
    );

EFI_STATUS
BlWaitForInput(
    EFI_INPUT_KEY *Key,
    ULONGLONG Timeout
    );

VOID
BlInputString(
    IN ULONG Prompt,
    IN ULONG CursorX,
    IN ULONG CursorY,
    IN PUCHAR String,
    IN ULONG MaxLength
    );

EFI_STATUS
EfiGetVariable(
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    OUT UINT32 *Attributes OPTIONAL,
    IN OUT UINTN *DataSize,
    OUT VOID *Data
    );
    
EFI_STATUS
EfiSetVariable (
    IN CHAR16 *VariableName,
    IN EFI_GUID *VendorGuid,
    IN UINT32 Attributes,
    IN UINTN DataSize,
    IN VOID *Data
    );
    
EFI_STATUS
EfiGetNextVariableName (
    IN OUT UINTN *VariableNameSize,
    IN OUT CHAR16 *VariableName,
    IN OUT EFI_GUID *VendorGuid
    );

PVOID
FindSMBIOSTable(
    UCHAR   RequestedTableType
    );

VOID
EfiCheckFirmwareRevision(
    VOID
    );


EFI_STATUS
EfiAllocateAndZeroMemory(
    EFI_MEMORY_TYPE     MemoryType,
    UINTN               Size,
    PVOID               *ReturnPtr
    );

#endif // _BLDRIA64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\bootp.h ===
/*
 *
 * Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/inc/bootp.h_v   1.4   Apr 04 1997 13:57:00   GRGUSTAF  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef __BOOTP_H
#define __BOOTP_H


#include "ip.h"

#define BOOTP_VENDOR    64      /* BOOTP standard vendor field size */
#define BOOTP_DHCPVEND  312     /* DHCP standard vendor field size */
#define BOOTP_EXVENDOR  1024    /* .. our max. size (MTU 1500) */

/* BOOTstrap Protocol (BOOTP) header */
typedef struct bootph {
	UINT8   opcode,                 /* operation code */
		hardware,               /* hardware type */
		hardlen,                /* length of hardware address */
		gatehops;               /* gateways hops */
	UINT32  ident;                  /* transaction identification */
	UINT16  seconds,                /* seconds elapsed since boot began */
		flags;                  /* flags */
	UINT8   cip[IPLEN],             /* client IP address */
		yip[IPLEN],             /* your IP address */
		sip[IPLEN],             /* server IP address */
		gip[IPLEN];             /* gateway IP address */
	UINT8   caddr[16],              /* client hardware address */
		sname[64],              /* server name */
		bootfile[128];          /* bootfile name */
	union {
		UINT8   d[BOOTP_EXVENDOR];      /* vendor-specific stuff */
		struct {
			UINT8   magic[4];       /* magic number */
			UINT32  flags;          /* flags/opcodes etc */
			UINT8   pad[56];        /* padding chars */
		} v;
	} vendor;
} BOOTPLAYER;

#define VM_RFC1048      0x63538263L     /* RFC1048 magic number (in network order) */

#define BOOTP_SPORT     67              /* BOOTP server port */
#define BOOTP_CPORT     68              /* .. client port */

#define BOOTP_REQ       1               /* BOOTP request */
#define BOOTP_REP       2               /* .. reply */

/* BOOTP flags field */
#define BOOTP_BCAST     0x8000          /* BOOTP broadcast flag */
#define BOOTP_FLAGS     BOOTP_BCAST     /* .. for FDDI address transl. */


#endif /* __BOOTP_H */

/* EOF - $Workfile:   bootp.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\cdfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CdfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by Cdfs boot.

Author:

    Brian Andrew    [BrianAn]   05-Aug-1991

Revision History:

--*/

#ifndef _CDFSBOOT_
#define _CDFSBOOT_

#define MAX_CDROM_READ                  (16 * CD_SECTOR_SIZE)

typedef struct _CDFS_STRUCTURE_CONTEXT {

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG RootDirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG RootDirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG RootDirSize;

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG DirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG DirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG DirSize;

    //
    //  The following field indicates the size of the disk Logical Blocks.
    //

    ULONG LbnBlockSize;

    //
    //  The following field indicates the number of logical blocks on the
    //  disk.
    //

    ULONG LogicalBlockCount;

    //
    //  The following indicates whether this is an Iso or Hsg disk.
    //

    BOOLEAN IsIsoVol;

} CDFS_STRUCTURE_CONTEXT, *PCDFS_STRUCTURE_CONTEXT;

//
// Define Cdfs file context structure.
//

typedef struct _CDFS_FILE_CONTEXT {

    //
    //  The following is the disk offset of the read position for the
    //  start of the file.  This may include the above number of non-file
    //  bytes.
    //

    ULONG DiskOffset;

    //
    //  The following field contains the size of the file, in bytes.
    //

    ULONG FileSize;

    //
    //  The following field indicates whether this is a directory.
    //

    BOOLEAN IsDirectory;

} CDFS_FILE_CONTEXT, *PCDFS_FILE_CONTEXT;

//
// Define file I/O prototypes.
//

ARC_STATUS
CdfsClose (
    IN ULONG FileId
    );

ARC_STATUS
CdfsOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
CdfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
CdfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
CdfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
CdfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
CdfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
CdfsInitialize(
    VOID
    );

#endif // _CDFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\haldtect.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    haldtect.h

Abstract:

    Common header file for HAL detection routines

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC environment

Revision History:

--*/
#include "bldr.h"
#include "setupblk.h"
#include "parseini.h"
#include "stdio.h"
#include "stdarg.h"



PCHAR
SlDetectHal(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\dhcp.h ===
/*
 *
 * Modifications:   $Header:   V:/archives/include/dhcp.h_v   1.1   Apr 16 1997 11:39:12   PWICKERX  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#define DHCP_PAD		 0	/* DHCP pad character */
#define DHCP_SUBNET		 1 	/* DHCP subnet mask */
#define DHCP_TOFFSET		 2	/* DHCP time offset */
#define DHCP_ROUTER		 3	/* DHCP router option */
#define DHCP_TSRV		 4	/* DHCP time server */
#define DHCP_NSRV		 5	/* DHCP name server */
#define DHCP_DNSRV		 6	/* DHCP domain name server */
#define DHCP_LSRV		 7	/* DHCP log server */
#define DHCP_CSRV		 8	/* DHCP cookie server */
#define DHCP_HNAME		12	/* DHCP hostname */
#define DHCP_DNAME		15	/* DHCP domainname */
#define DHCP_VENDOR		43	/* DHCP vendor specific */
#define DHCP_REQIP		50	/* DHCP requested IP address */
#define DHCP_LEASE		51	/* DHCP IP addr lease time */
#define DHCP_OVRLOAD	52	/* DHCP Option overload */

#define DHCP_MSGTYPE	53	/* DHCP message type opcode */
	#define DHCP_DISCOVER	0x01	/* DHCP discover package */
	#define DHCP_OFFER		0x02	/* DHCP offer package */
	#define DHCP_REQUEST	0x03	/* DHCP offer request */
	#define DHCP_DECLINE	0x04	/* DHCP invalid config */
	#define DHCP_ACK		0x05	/* DHCP ACK */
	#define DHCP_NAK		0x06	/* DHCP NAK */
	#define DHCP_RELEASE	0x07	/* DHCP release IP addr */

#define DHCP_SRVID		54	/* DHCP server ID */
#define DHCP_PREQLST	55	/* DHCP parameter request list */
#define DHCP_MESSAGE	56	/* DHCP message */
#define DHCP_MAXMSG		57	/* DHCP maximum message size */
#define DHCP_CLASS		60  /* DHCP class identifier */
#define DHCP_CLIENTID  	61  /* DHCP client identifier */
	/* sample number assigned for new client ID type */
	#define DHCP_CLIENTID_GUID  85  /* new type for DHCP_CLIENTID option */

/* sample numbers assigned for new options */
#define DHCP_SYSARCH       	90	/* DHCP system architecture */
	/* sample numbers assigned for system architecture types */
	#define DHCP_STD_X86	0x00
	#define DHCP_PC98_X86	0x01
#define DHCP_NICIF	   	91	/* NIC Interface specifier */
	/* sample numbers assigned for NIC Interface types */
	#define DHCP_UNDI	0x01  /* followed by two bytes of data */
	#define DHCP_PCI	0x02  /* followed by eight bytes of data */
	#define DHCP_PNP	0x03  /* followed by seven bytes of data */
#define DHCP_CLIENT_GUID   	97	/* Guid of the client */

/* 

"Private use" options from 128 - 254 

*/ 

/* Path to NTLDR that will be downloaded by startrom.com */
#define DHCP_LOADER_PATH            251

/* Multicast Download options. Used in the same manner as vendor 
   options for PXE. Specifically the following are 
   the enacapsulated options within this field:

        Tag #1 PXE_MTFTP_IP        - Multicast IP address for loader
        Tag #2 PXE_MTFTP_CPORT     - UDP port the client should monitor
        Tag #3 PXE_MTFTP_SPORT     - UDP port the MTFTP server are listening on
        Tag #4 PXE_MTFTP_TMOUT     - Number of seconds client must listen for activity
        Tag #5 PXE_MTFTP_DELAY     - Number of seconds client must listen before restarting
   
*/
#define DHCP_LOADER_MCAST_OPTIONS   252 

/* Contents of the boot.ini file. Each DHCP option is limited to 255 bytes.
   This option can have multiple instances in the same DHCP packet and the
   client is expected to concatenate them for larger boot.ini files.
   
   From RFC 2131:
   The values to be passed in an 'option' tag may be too long to fit in
   the 255 octets available to a single option (e.g., a list of routers
   in a 'router' option [21]).  Options may appear only once, unless
   otherwise specified in the options document.  The client concatenates
   the values of multiple instances of the same option into a single
   parameter list for configuration.

*/
#define DHCP_LOADER_BOOT_INI        253

/* Path to boot.ini file if greater than 255 bytes in length */
#define DHCP_LOADER_BOOT_INI_PATH   254 /* Path to boot.ini */

/* EOF - $Workfile:   dhcp.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\dockinfo.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dockinfo.h

Abstract:

    This file defines a structure that is used to pass docking
    station info from NTDETECT to NTLDR. See PNP BIOS Specification
    Function 5 - "Get Docking Station Info" for details.

Author:

    Doug Fritz     [DFritz]    01-Oct-1997

Environment:

    Both 16-bit real mode and 32-bit protected mode.

Revision History:

--*/

#ifndef _DOCKINFO_
#define _DOCKINFO_


//
// FW_DOCKINFO_NOT_CALLED is used by NTLDR to detect the case where
//   NTDETECT never called BIOS to get docking station info.
//   (e.g., BIOS was not PnP). SUCCESS and NOT_DOCKED are from
//   the Plug and Play BIOS Specification appendix E.
//

#define FW_DOCKINFO_SUCCESS                 0x0000
#define FW_DOCKINFO_FUNCTION_NOT_SUPPORTED  0x0082
#define FW_DOCKINFO_SYSTEM_NOT_DOCKED       0x0087
#define FW_DOCKINFO_DOCK_STATE_UNKNOWN      0x0089
#define FW_DOCKINFO_BIOS_NOT_CALLED         0xffff

//
// Define FAR macro appropriately based on whether we're compiling 16-bit
// or 32-bit.
//
#ifdef X86_REAL_MODE

#ifndef FAR
#define FAR far
#endif

#else  // not x86 real mode

#ifndef FAR
#define FAR
#endif

#endif // not x86 real mode

typedef struct {
    ULONG       DockID;
    ULONG       SerialNumber;
    USHORT      Capabilities;
    USHORT      ReturnCode;     // initialize with FW_DOCKINFO_NOT_CALLED
} DOCKING_STATION_INFO, FAR * FPDOCKING_STATION_INFO, * PDOCKING_STATION_INFO;

#endif // _DOCKINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\hpfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    HpfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by Hpfs boot.

Author:

    Gary Kimura     [GaryKi]    19-Jul-1991

Revision History:

--*/

#ifndef _HPFSBOOT_
#define _HPFSBOOT_

typedef ULONG LBN;
typedef LBN *PLBN;

typedef ULONG VBN;
typedef VBN *PVBN;


//
// The following structure is a context block used by the exported
// procedures in the Hpfs boot package.  The context contains our cached
// part of the boot mcb structure.  The max number must not be smaller than
// the maximum number of leafs possible in a pinball allocation sector plus
// one.
//

#define MAXIMUM_NUMBER_OF_BOOT_MCB       (41)

typedef struct _HPFS_BOOT_MCB {

    //
    //  The following fields indicate the number of entries in use by
    //  the boot mcb. and the boot mcb itself.  The boot mcb is
    //  just a collection of vbn - lbn pairs.  The last InUse entry
    //  Lbn's value is ignored, because it is only used to give the
    //  length of the previous run.
    //

    ULONG InUse;

    VBN Vbn[ MAXIMUM_NUMBER_OF_BOOT_MCB ];
    LBN Lbn[ MAXIMUM_NUMBER_OF_BOOT_MCB ];

} HPFS_BOOT_MCB, *PHPFS_BOOT_MCB;

typedef struct _HPFS_STRUCTURE_CONTEXT {

    //
    //  The following field contains the fnode lbn of the file
    //

    LBN Fnode;

    //
    //  The following field contains the cached mcb
    //

    HPFS_BOOT_MCB BootMcb;

} HPFS_STRUCTURE_CONTEXT, *PHPFS_STRUCTURE_CONTEXT;

//
// Define Hpfs file context structure.
//

typedef struct _HPFS_FILE_CONTEXT {

    //
    //  The following field contains the size of the file, in bytes.
    //

    ULONG FileSize;

} HPFS_FILE_CONTEXT, *PHPFS_FILE_CONTEXT;

//
// HPFS file system structures
//
typedef ULONG SIGNATURE;
typedef SIGNATURE *PSIGNATURE;

typedef ULONG PINBALL_TIME;
typedef PINBALL_TIME *PPINBALL_TIME;
//
//  There are only three sectors on the disk that have fixed locations.  They
//  are the boot sector, the super sector, and the spare sector.
//

#define BOOT_SECTOR_LBN                  (0)
#define SUPER_SECTOR_LBN                 (16)
#define SPARE_SECTOR_LBN                 (17)

typedef struct _SUPER_SECTOR {

    //
    //  The Super Sector starts with a double signature.
    //

    SIGNATURE Signature1;                           // offset = 0x000   0
    SIGNATURE Signature2;                           // offset = 0x004   4

    //
    //  The version and functional version describe the version of
    //  the on-disk file system structures and the oldest version of the
    //  file system that can understand this disk.
    //

    UCHAR Version;                                  // offset = 0x008   8
    UCHAR FunctionalVersion;                        // offset = 0x009   9
    USHORT Unused1;                                 // offset = 0x00A  10

    //
    //  This field denotes the sector containing the FNODE for the root
    //  directory for the volume.
    //

    LBN RootDirectoryFnode;                         // offset = 0x00C  12

    //
    //  The follow two fields indicate the number of total sectors on the
    //  volume (good and bad), and the number of bad sectors on the volume.
    //

    ULONG NumberOfSectors;                          // offset = 0x010  16
    ULONG NumberOfBadSectors;                       // offset = 0x014  20

    //
    //  This field denotes the sector containing the first level of the
    //  volumes bitmap table.
    //

    LBN BitMapIndirect;                             // offset = 0x018  24
    ULONG Unused2;                                  // offset = 0x01C  28

    //
    //  This field denotes the sector containing the first bad sector disk
    //  buffer for the volume.
    //

    LBN BadSectorList;                              // offset = 0x020  32
    ULONG Unused3;                                  // offset = 0x024  36

    //
    //  The following two dates are the time of the last execution of
    //  chkdsk and disk optimize on the volume.
    //

    PINBALL_TIME ChkdskDate;                        // offset = 0x028  40
    PINBALL_TIME DiskOptimizeDate;                  // offset = 0x02C  44

    //
    //  The following four fields describe the directory disk buffer pool.
    //  It is a contiguous run on of sectors on the disk set aside for
    //  holding directory disk buffers.  PoolSize is the total number of
    //  sectors in the pool.  First and Last Sector denote the boundaries
    //  of the pool, and BitMap denotes the start of a small bitmap used to
    //  describe the directory disk buffer pool's current allocation.  The
    //  bitmap is 4 contiguous sectors in size, and each bit in the map
    //  corresponds to 1 Directory Disk Buffer (i.e., 4 Sectors worth)
    //

    ULONG DirDiskBufferPoolSize;                    // offset = 0x030  48
    LBN DirDiskBufferPoolFirstSector;               // offset = 0x034  52
    LBN DirDiskBufferPoolLastSector;                // offset = 0x038  56
    LBN DirDiskBufferPoolBitMap;                    // offset = 0x03C  60

    //
    //  The following field contains the name of the volume
    //

    UCHAR VolumeName[32];                           // offset = 0x040  64

    //
    //  The following field denotes the start of the Small ID (SID) table
    //  which is used to store the Small ID to GUID mappings used on the
    //  volume.  The SID table is 8 contiguous sectors in size.
    //

    LBN SidTable;                                   // offset = 0x060  96
    UCHAR Unused4[512-100];                         // offset = 0x064 100

} SUPER_SECTOR;                                     // sizeof = 0x200 512
typedef SUPER_SECTOR *PSUPER_SECTOR;

//
//  Super Sector signatures
//

#define SUPER_SECTOR_SIGNATURE1          (0xf995e849)
#define SUPER_SECTOR_SIGNATURE2          (0xfa53e9c5)

//
//  Super Sector versions
//

#define SUPER_SECTOR_VERSION             (0x02)
#define SUPER_SECTOR_FUNC_VERSION        (0x02)

typedef struct _SPARE_SECTOR {

    //
    //  The Spare Sector starts with a double signature.
    //

    SIGNATURE Signature1;                           // offset = 0x000   0
    SIGNATURE Signature2;                           // offset = 0x004   4

    //
    //  The flags field describe how "clean" the volume is.
    //

    UCHAR Flags;                                    // offset = 0x008   8
    UCHAR Unused1[3];                               // offset = 0x009   9

    //
    //  The following three fields describe the hotfix structure for the
    //  volume.  The List field is denotes the disk buffer used to store
    //  the hotfix table.  The InUse describes how many hotfixes are
    //  currently being used, and MaxSize is the total number of hotfixes
    //  that can be in use at any one time.
    //

    LBN HotFixList;                                 // offset = 0x00C  12
    ULONG HotFixInUse;                              // offset = 0x010  16
    ULONG HotFixMaxSize;                            // offset = 0x014  20

    //
    //  The following two fields describe the "emergency" pool of spare
    //  directory disk buffers.  Free describes how many spare directory
    //  disk buffers are currently available for use.  MaxSize is the total
    //  number of spare directory disk buffers available.  The actual location
    //  of the spare directory disk buffers is denoted in the table at the
    //  end of the spare sector (i.e., field SpareDirDiskBuffer).
    //

    ULONG SpareDirDiskBufferAvailable;              // offset = 0x018  24
    ULONG SpareDirDiskBufferMaxSize;                // offset = 0x01C  28

    //
    //  The following two fields describe the code page information used
    //  on the volume.  The InfoSector field is the sector of the beginning
    //  Code Page Information Sector, and the InUse field is the total number
    //  of code pages currently in use on the volume.
    //

    LBN CodePageInfoSector;                         // offset = 0x020  32
    ULONG CodePageInUse;                            // offset = 0x024  36
    ULONG Unused2[17];                              // offset = 0x028  40

    //
    //  The following field is an array of LBN's for the spare directory
    //  disk buffers that are for "emergency" use.
    //

    LBN SpareDirDiskBuffer[101];                    // offset = 0x06C 108

} SPARE_SECTOR;                                     // sizeof = 0x200 512
typedef SPARE_SECTOR *PSPARE_SECTOR;

//
//  Spare Sector signatures
//

#define SPARE_SECTOR_SIGNATURE1          (0xf9911849)
#define SPARE_SECTOR_SIGNATURE2          (0xfa5229c5)


//
//  The on-disk allocation structure is defined using B-Trees.  For every
//  B-Tree block there is an Allocation Header, followed by a list of
//  either Allocation Leafs or Allocation Nodes.  This structure will either
//  appear in an FNODE or in an AllocationSector.
//
//  The allocation header (called Allocation Block in earlier implementations)
//  describes a B-tree block.
//

typedef struct _ALLOCATION_HEADER {

    //
    //  The following flag describes the state of the B-tree block (e.g.,
    //  indicates if the block is a leaf or an internal node.
    //

    UCHAR Flags;                                    // offset = 0x000  0
    UCHAR Unused[3];                                // offset = 0x001  1

    //
    //  The following two fields denote the number of free records in the
    //  B-Tree block, and the number of records that are currently in use
    //

    UCHAR FreeCount;                                // offset = 0x004  4
    UCHAR OccupiedCount;                            // offset = 0x005  5

    //
    //  The next field contains the offset (in bytes) from the beginning
    //  of the allocation header to the first free byte in the B-Tree block
    //

    USHORT FirstFreeByte;                           // offset = 0x006  6

} ALLOCATION_HEADER;                                // sizeof = 0x008  8
typedef ALLOCATION_HEADER *PALLOCATION_HEADER;

//
//  Allocation header flags
//
//      NODE - if set this indicates that the B-Tree block contains internal
//          nodes and not leaf entries.
//
//      BINARY_SEARCH - if set this suggest that a binary search should be used
//          to search the B-Tree block.
//
//      FNODE_PARENT - if set this indicates that the sector which is the
//          parent of the sector with this header (not this sector), is an
//          FNODE.
//

#define ALLOCATION_BLOCK_NODE            (0x80)
#define ALLOCATION_BLOCK_BINARY          (0x40)
#define ALLOCATION_BLOCK_FNODE_PARENT    (0x20)

//
//  Immediately following an allocation header are one or more allocation nodes
//  of allocation leafs.
//

typedef struct _ALLOCATION_NODE {

    //
    //  All children of this allocation node will have values less than
    //  the following VBN field.
    //

    VBN Vbn;                                        // offset = 0x000  0

    //
    //  This is the LBN of the allocation sector refered to by this node
    //

    LBN Lbn;                                        // offset = 0x004  4

} ALLOCATION_NODE;                                  // sizeof = 0x008  8
typedef ALLOCATION_NODE *PALLOCATION_NODE;

typedef struct _ALLOCATION_LEAF {

    //
    //  The following field has the starting VBN for this run
    //

    VBN Vbn;                                        // offset = 0x000  0

    //
    //  This is the length of the run in sectors
    //

    ULONG Length;                                   // offset = 0x004  4

    //
    //  This is the starting LBN of the run
    //

    LBN Lbn;                                        // offset = 0x008  8

} ALLOCATION_LEAF;                                  // sizeof = 0x00C 12
typedef ALLOCATION_LEAF *PALLOCATION_LEAF;

//
//  An allocation sector is an on-disk structure that contains allocation
//  information.  It contains some bookkeeping information, an allocation
//  header and then an array of either allocation leafs or allocation nodes.
//
//       AllocationSector
//      +-------------------+
//      | bookkeeping       |
//      +- - - - - - - - - -+
//      | Allocation Header |
//      +- - - - - - - - - -+
//      | Allocation Leafs  |
//      |        or         |
//      | Allocation Nodes  |
//      +-------------------+
//
//  where the number of allocation leafs that can be stored in a sector is
//  40 and the number of nodes is 60.
//

#define ALLOCATION_NODES_PER_SECTOR      (60)
#define ALLOCATION_LEAFS_PER_SECTOR      (40)

typedef struct _ALLOCATION_SECTOR {

    //
    //  The allocation sector starts off with a signature field
    //

    SIGNATURE Signature;                            // offset = 0x000   0

    //
    //  This following two fields contains the LBN of this allocation
    //  sector itself, and the LBN of the parent of this sector (the
    //  parent is either an FNODE or another allocation sector)
    //

    LBN Lbn;                                        // offset = 0x004   4
    LBN ParentLbn;                                  // offset = 0x008   8

    //
    //  The allocation header for the sector
    //

    ALLOCATION_HEADER AllocationHeader;             // offset = 0x00C  12

    //
    //  The remainder of the sector is either an array of allocation leafs
    //  of allocation nodes
    //

    union {                                         // offset = 0x014  20
        ALLOCATION_NODE Node[ ALLOCATION_NODES_PER_SECTOR ];
        ALLOCATION_LEAF Leaf[ ALLOCATION_LEAFS_PER_SECTOR ];
    } Allocation;

    UCHAR Unused[12];                               // offset = 0x1F4 500

} ALLOCATION_SECTOR;                                // sizeof = 0x200 512
typedef ALLOCATION_SECTOR *PALLOCATION_SECTOR;

//
//  The allocation sector signature
//

#define ALLOCATION_SECTOR_SIGNATURE      (0x37e40aae)

//
//  The on-disk FNODE structure is used to describe both files and directories
//  It contains some fixed data information, the EA and ACL lookup information,
//  allocation information and then a free space for storing some EAs and
//  ACLs that fit in the sector
//

#define ALLOCATION_NODES_PER_FNODE       (12)
#define ALLOCATION_LEAFS_PER_FNODE       (8)

typedef struct _FNODE_SECTOR {

    //
    //  The sector starts with a signature field
    //

    SIGNATURE Signature;                            // offset = 0x000   0

    //
    //  The following fields was for history tracking, but in NT Pinball
    //  doesn't need this information.
    //

    ULONG Unused1[2];                               // offset = 0x004   4

    //
    //  The following two fields contain the file name length, and the first
    //  15 bytes of the filename, as stored in the dirent that references
    //  this fnode.  For the root directory theses values are all zeros.
    //

    UCHAR FileNameLength;                           // offset = 0x00C  12
    UCHAR FileName[15];                             // offset = 0x00D  13

    //
    //  The following field denotes the parent directory's FNODE
    //

    LBN ParentFnode;                                // offset = 0x01C  28

    //
    //  The following four fields describe the ACL for the file/directory.
    //
    //  AclDiskAllocationLength holds the number of bytes in the ACL that
    //      are stored outside of this FNODE.  If this value is not zero
    //      then AclFnodeLength must be equal to zero.
    //
    //  AclLbn points to the first sector of the data run or the allocation
    //      sector containing describing the ACL.  AclFlags indicates if
    //      it is a data run or an allocation sector. AclLbn is only used
    //      if AclDiskAllocationLength is not zero.
    //
    //  AclFnodeLength holds the number of bytes in the ACL that are
    //      stored within this FNODE.  If value is not zero then
    //      AclDiskAllocationLength must be equal to zero.  The ACL, if stored
    //      in the FNODE, is located at AclEaFnodeBuffer in this FNODE sector.
    //
    //  AclFlags if the data is outside the FNODE this flag indicates whether
    //      ACL is stored in a single data run (AclFlags == 0) or via an
    //      allocation sector (AclFlags != 0).  AclFlags is only used if
    //      AclDiskAllocationLength is not zero.
    //

    ULONG AclDiskAllocationLength;                  // offset = 0x020  32
    LBN AclLbn;                                     // offset = 0x024  36
    USHORT AclFnodeLength;                          // offset = 0x028  40
    UCHAR AclFlags;                                 // offset = 0x02A  42

    //
    //  The following field was used for the number of valid history
    //  bits but we don't need this field of NT Pinball
    //

    UCHAR Unused2;                                  // offset = 0x02B  43

    //
    //  The following four fields describe the EA for the file/directory.
    //
    //  EaDiskAllocationLength holds the number of bytes in the EA that
    //      are stored outside of this FNODE.  If this value is not zero
    //      then EaFnodeLength must be equal to zero.
    //
    //  EaLbn points to the first sector of the data run or the allocation
    //      sector containing describing the EA.  EaFlags indicates if
    //      it is a data run or an allocation sector.  EaLbn is only used
    //      if EaDiskAllocationLength is not zero.
    //
    //  EaFnodeLength holds the number of bytes in the EA that are
    //      stored within this FNODE.  If value is not zero then
    //      EaDiskAllocationLength must be equal to zero.  The EA, if stored
    //      in the FNODE, is located immediately after the ACL stored in the
    //      AclEaFnodeBuffer.
    //
    //  EaFlags if the data is outside the FNODE this flag indicates whether
    //      EA is stored in a single data run (EaFlags == 0) or via an
    //      allocation sector (EaFlags != 0).  EaFlags is only used if
    //      EaDiskAllocationLength is not zero.
    //

    ULONG EaDiskAllocationLength;                   // offset = 0x02C  44
    LBN EaLbn;                                      // offset = 0x030  48
    USHORT EaFnodeLength;                           // offset = 0x034  52
    UCHAR EaFlags;                                  // offset = 0x036  54

    //
    //  The following byte contains the FNODE flags
    //

    UCHAR Flags;                                    // offset = 0x037  55

    //
    //  The following two fields describe the top level allocation for
    //  this file/directory
    //

    ALLOCATION_HEADER AllocationHeader;             // offset = 0x038  56

    union {                                         // offset = 0x040  64
        ALLOCATION_NODE Node[ ALLOCATION_NODES_PER_FNODE ];
        ALLOCATION_LEAF Leaf[ ALLOCATION_LEAFS_PER_FNODE ];
    } Allocation;

    //
    //  The following field contains the valid length of the file.  The size
    //  of the file is stored in the dirent.  The difference between these two
    //  values is that the file size is the actual size allocated and visible
    //  to the user.  The Valid length is the number of bytes that have
    //  had their data zeroed out or modified.  (i.e., if a read request
    //  is greater than valid length but less than file size then the file
    //  system must first zero out the data in the file up to and including
    //  data being read.
    //

    ULONG ValidDataLength;                          // offset = 0x0A0 160

    //
    //  The following field contains the number of EAs in this file that have
    //  the need ea attribute set.
    //

    ULONG NeedEaCount;                              // offset = 0x0A4 164
    UCHAR Unused3[16];                              // offset = 0x0A8 168

    //
    //  The following field contains the offset, in bytes, from the start of
    //  FNODE to the first ACE stored in the FNODE
    //

    USHORT AclBase;                                 // offset = 0x0B8 184
    UCHAR Unused4[10];                              // offset = 0x0BA 186

    //
    //  The following buffer is used to store acl/ea in the FNODE
    //

    UCHAR AclEaFnodeBuffer[316];                    // offset = 0x0C4 196

} FNODE_SECTOR;                                     // sizeof = 0x200 512
typedef FNODE_SECTOR *PFNODE_SECTOR;

//
//  The FNODE Sector signature
//

#define FNODE_SECTOR_SIGNATURE           (0xf7e40aae)

//
//  The on-disk directory disk buffer is used to contain directory entries.
//  It contains a fixed header followed by a collection of one or more
//  dirents.  Dirents are variable so size we cannot use a simply C struct
//  declartion for the entire disk buffer.
//

typedef struct _DIRECTORY_DISK_BUFFER {

    //
    //  The disk buffer starts with a signature field
    //

    SIGNATURE Signature;                            // offset = 0x000    0

    //
    //  The following field is the offset to the first free byte in this
    //  disk buffer
    //

    ULONG FirstFree;                                // offset = 0x004    4

    //
    //  The following field is a change count that is kept around for
    //  bookkeeping purposes.  It is incremented whenever we move any
    //  of the entries in this disk buffer.  This means for any file if we
    //  remember its offset and its change count we will be able to quickly
    //  locate the dirent again without needing to search from the top
    //  of the directory again. (i.e., only if the remembered change count
    //  and the current change count match).  For this to work the file system
    //  in memory will need to keep track of whenever it removes a Directory
    //  Disk Buffer from a directory, and have each saved dirent location
    //  keep this Directory change count, the Directory Disk Buffer Change
    //  Count, LBN and Offset.
    //
    //  In addition we overload the bit in this value to indicate if this
    //  is the topmost directory disk buffer for the directory (low order bit
    //  = 1) or if it is a lower lever buffer (low order bit = 0).
    //

    ULONG ChangeCount;                              // offset = 0x008    8

    //
    //  The following field contains the LBN of either the parent
    //  directory disk buffer containing this disk buffer or the FNODE.
    //  It is the FNODE if this is a topmost disk buffer and a parent
    //  directory disk buffer otherwise.
    //

    LBN Parent;                                     // offset = 0x00C   12

    //
    //  The following field is the LBN of the sector containing the
    //  start of this disk buffer
    //

    LBN Sector;                                     // offset = 0x010   16

    //
    //  This following buffer contains the dirents stored in this disk buffer
    //

    UCHAR Dirents[2028];                            // offset = 0x014   20

} DIRECTORY_DISK_BUFFER;                            // sizeof = 0x800 2048
typedef DIRECTORY_DISK_BUFFER *PDIRECTORY_DISK_BUFFER;

//
// Size of Directory Disk Buffer in sectors.
//

#define DIRECTORY_DISK_BUFFER_SECTORS    (4)

//
//  Directory Disk Buffer Signature
//

#define DIRECTORY_DISK_BUFFER_SIGNATURE  (0x77e40aae)

typedef struct _PBDIRENT {

    USHORT DirentSize;                              // offset = 0x000  0
    UCHAR Flags;                                    // offset = 0x002  2
    UCHAR FatFlags;                                 // offset = 0x003  3

    LBN Fnode;                                      // offset = 0x004  4

    PINBALL_TIME LastModificationTime;              // offset = 0x008  8

    ULONG FileSize;                                 // offset = 0x00C 12

    PINBALL_TIME LastAccessTime;                    // offset = 0x010 16

    PINBALL_TIME FnodeCreationTime;                 // offset = 0x014 20

    ULONG EaLength;                                 // offset = 0x018 24

    UCHAR ResidentAceCount;                         // offset = 0x01C 28
    UCHAR CodePageIndex;                            // offset = 0x01D 29
    UCHAR FileNameLength;                           // offset = 0x01E 30
    UCHAR FileName[1];                              // offset = 0x01F 31

} PBDIRENT;                                           // sizeof = 0x020 32
typedef PBDIRENT *PPBDIRENT;

//
// Define sizes of .. and End PBDIRENT.
//

#define SIZEOF_DIR_DOTDOT                (sizeof(PBDIRENT) + sizeof(LONG))
#define SIZEOF_DIR_END                   (sizeof(PBDIRENT))
#define SIZEOF_DIR_MAXPBDIRENT             (sizeof(PBDIRENT) + 256 + \
                                          (3*sizeof(PINBALL_ACE)) + sizeof(LBN))

#define DIRENT_FIRST_ENTRY               (0x0001)
#define DIRENT_ACL                       (0x0002)
#define DIRENT_BTREE_POINTER             (0x0004)
#define DIRENT_END                       (0x0008)
#define DIRENT_EXPLICIT_ACL              (0x0040)
#define DIRENT_NEED_EA                   (0x0080)
#define DIRENT_NEW_NAMING_RULES          (0x4000)
//
//  The following macros are used to help locate dirents within a Directory
//  Disk Buffer.  GetFirstDirent returns a pointer to the first dirent entry
//  in the directory disk buffer.  GetNextDirent returns a pointer to the
//  next dirent entry in a directory disk buffer, without checking for the
//  end of the Directory Disk Buffer.
//
//      PDIRENT
//      GetFirstDirent (
//          IN PDIRECTORY_DISK_BUFFER DirectoryDiskBuffer
//          );
//
//      PDIRENT
//      GetNextDirent (
//          IN PDIRENT Dirent
//          );
//

#define GetFirstDirent(DIR) (   \
    (PDIRENT)&(DIR)->Dirents[0] \
)

//
//  This macro blindly returns a pointer to the next Dirent, without checking
//  for the end of the Directory Disk Buffer, i.e., callers must always check
//  for the End record in the Directory Disk Buffer.  If GetNextDirent is
//  called with the End record as input, it will return the next free byte
//  in the buffer.
//

#define GetNextDirent(ENT) (                        \
    (PDIRENT)((PUCHAR)(ENT)+(ENT)->DirentSize)      \
)
//
//  The following macros are used to help retrieve the variable fields
//  within a dirent.  GetAceInDirent returns a pointer to the ACE within
//  the dirent corresponding to the supplied index, or NULL if there isn't
//  a corresponding ACE.  GetBtreePointerInDirent returns the LBN field of
//  the down B-tree pointer stored in the dirent, or it returns a value of
//  zero if there isn't a down pointer.  SetBtreePointerInDirent sets the
//  LBN downpointer field.
//
//      PPINBALL_ACE
//      GetAceInDirent (
//          IN PDIRENT Dirent,
//          IN ULONG Index // (0, 1, or 2)
//          );
//
//      LBN
//      GetBtreePointerInDirent (
//          IN PDIRENT Dirent
//          );
//
//      VOID
//      SetBtreePointerInDirent (
//          IN OUT PDIRENT Dirent,
//          IN LBN Blbn
//          );
//
//
//
//  To return a pointer to an ACE in a dirent we need to check to see if the
//  index is within the resident ace count.  The first ace is the address of
//  the first longword after the filename, the second ace is the second long
//  word.
//

#define GetAceInDirent(ENT,I) (                                          \
    ((I) >= 0 && (I) < (ENT)->ResidentAceCount ?                         \
        (PPINBALL_ACE)(                                                  \
            (LONG)LongAlign((ENT)->FileName[(ENT)->FileNameLength]) +    \
            (I)*sizeof(PINBALL_ACE)                                      \
        )                                                                \
    :                                                                    \
        NULL                                                             \
    )                                                                    \
)

//
//  To return the Btree pointer we need to first check to see if there
//  is Btree pointer field, otherwise we return NULL.  The field, if present,
//  is located 4 bytes back from the end of the dirent.
//

#define GetBtreePointerInDirent(ENT) (                              \
    (FlagOn((ENT)->Flags,DIRENT_BTREE_POINTER) ?                    \
        *(PLBN)(((PUCHAR)(ENT)) + (ENT)->DirentSize - sizeof(LBN))  \
    :                                                               \
        0                                                           \
    )                                                               \
)

//
//  To set the Btree pointer we assume there is a Btree pointer field.
//  The field is located 4 bytes back from the end of the dirent.
//

#define SetBtreePointerInDirent(ENT,BLBN) (                             \
    *(PLBN)(((PUCHAR)(ENT)) + (ENT)->DirentSize - sizeof(LBN)) = (BLBN) \
)

//
// Define file I/O prototypes.
//

ARC_STATUS
HpfsClose (
    IN ULONG FileId
    );

ARC_STATUS
HpfsOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
HpfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
HpfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
HpfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
HpfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
HpfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
HpfsInitialize(
    VOID
    );

#endif // _HPFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\fatboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fatboot.h

Abstract:

    This module defines globally used procedure and data structures used
    by fat boot.

Author:

    Gary Kimura (garyki) 29-Aug-1989

Revision History:

--*/

#ifndef _FATBOOT_
#define _FATBOOT_
#include "fat.h"


//
//  The following structure is used to define the local mcb structure used within
//  the fat boot loader to maintain a small cache of the retrieval information
//  for a single file/directory
//

#define FAT_MAXIMUM_MCB                  (41)

typedef struct _FAT_MCB {

    //
    //  The following fields indicate the number of entries in use by
    //  the boot mcb. and the boot mcb itself.  The boot mcb is
    //  just a collection of [vbo, lbo] pairs.  The last InUse entry
    //  Lbo's value is ignored, because it is only used to give the
    //  length of the previous run.
    //

    ULONG InUse;

    VBO Vbo[ FAT_MAXIMUM_MCB ];
    LBO Lbo[ FAT_MAXIMUM_MCB ];

} FAT_MCB, *PFAT_MCB;

//
//  The following structure is used to define the geometry of the fat volume
//  There is one for every mounted volume.  It describes the size/configuration
//  of the volume, contains a small cached mcb for the last file being accessed
//  on the volume, and contains a small cache of the fat.  Given a FileId we
//  can access the structure context through the structure context field in the
//  global BlFileTable (e.g., BlFileTable[FileId].StructureContext).
//

//
//  The following constant is used to determine how much of the fat we keep
//  cached in memory at any one time.  It must be a multiple of 6 bytes in order to
//  hold complete 12 and 16 bit fat entries in the cache at any one time.
//

#define FAT_CACHE_SIZE                   (512*3)

typedef struct _FAT_STRUCTURE_CONTEXT {

    //
    //  The following field contains an unpacked copy of the bios parameter block
    //  for the mounted volume
    //

    BIOS_PARAMETER_BLOCK Bpb;

    //
    //  The following two fields contain current file id of the file/directory
    //  whose mcb we are keeping around, and the second field is the mcb itself
    //

    ULONG FileId;
    FAT_MCB Mcb;

    //
    //  The following fields describe/contain the current cached fat.  The vbo
    //  is the smallest vbo of the fat currently in the cache, and cached fat
    //  is a pointer to the cached data.  The extra buffer/indirectiion is needed
    //  to keep everything aligned properly.  The dirty flag is used to indicate
    //  if the current cached fat has been modified and needs to be flushed to disk.
    //  Vbo is used because this allows us to do a lot of our computations having
    //  already biased lbo offset to the first fat table.
    //

    BOOLEAN CachedFatDirty;
    VBO CachedFatVbo;
    PUCHAR CachedFat;
    UCHAR CachedFatBuffer[ FAT_CACHE_SIZE + 256 ];

} FAT_STRUCTURE_CONTEXT, *PFAT_STRUCTURE_CONTEXT;

//
//  The following structure is used to define the location and size of each
//  opened file.  There is one of these of every opened file.  It is part of
//  the union of a BL_FILE_TABLE structuure.  Given a FileId we can access the
//  file context via the BlFileTable (e.g., BlFileTable[FileId].u.FatFileContext)
//

typedef struct _FAT_FILE_CONTEXT {

    //
    //  The following two fields describe where on the disk the dirent for the
    //  file is located and also contains a copy of the dirent
    //

    LBO DirentLbo;
    DIRENT Dirent;

} FAT_FILE_CONTEXT, *PFAT_FILE_CONTEXT;


//
// Define file I/O prototypes.
//

ARC_STATUS
FatClose (
    IN ULONG FileId
    );

ARC_STATUS
FatOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
FatRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
FatSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
FatWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
FatGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
FatSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
FatRename(
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    );

ARC_STATUS
FatGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    );

ARC_STATUS
FatInitialize(
    VOID
    );

#endif // _FATBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\ip.h ===
/*
 *
 * Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/inc/ip.h_v   1.3   Apr 04 1997 13:57:08   GRGUSTAF  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _IP_H
#define _IP_H


#define	IPLEN		4		/* length of an IP address */
#define	PROTUDP		17		/* IP package type is UDP */
#define	PROTIGMP	2		/* .. is IGMP */
#define	FR_MF		0x2000		/* .. fragment bit */
#define	FR_OFS		0x1fff		/* .. fragment offset */

/* Internet Protocol (IP) header */
typedef struct iph {

	UINT8	version; 		/* version and hdr length */
					/* each half is four bits */
	UINT8	service;		/* type of service for IP */
	UINT16	length,			/* total length of IP packet */
		ident,			/* transaction identification */
		frags;			/* combination of flags and value */

	UINT8	ttl,    		/* time to live */
		protocol;		/* higher level protocol type */

	UINT16	chksum;			/* header checksum */

	UINT8	source[IPLEN],		/* IP addresses */
		dest[IPLEN];

} IPLAYER;

struct in_addr {			/* INTERNET address */
	UINT32	s_addr;
};


#endif /* _IP_H */

/* EOF - $Workfile:   ip.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\netfs.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netfs.h

Abstract:

    This module defines globally used procedure and data structures used
    by net boot.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#ifndef _NETFS_
#define _NETFS_

#include <undi_api.h>

//
// Progress bar update function
//

VOID
BlUpdateProgressBar(
    ULONG fPercentage
    );


//////////////////////////////////////////////////////////////////////////////
//
// ROM layer definitions.
//
//////////////////////////////////////////////////////////////////////////////

extern UCHAR NetLocalHardwareAddress[16];

extern USHORT NetUnicastUdpDestinationPort;

#if 0
extern USHORT NetMulticastUdpDestinationPort;
extern ULONG NetMulticastUdpDestinationAddress;
extern USHORT NetMulticastUdpSourcePort;
extern ULONG NetMulticastUdpSourceAddress;
#endif

VOID
RomSetBroadcastStatus(
    BOOLEAN Enable
    );

VOID
RomSetReceiveStatus (
    IN USHORT UnicastUdpDestinationPort
#if 0
    ,
    IN USHORT MulticastUdpDestinationPort,
    IN ULONG MulticastUdpDestinationAddress,
    IN USHORT MulticastUdpSourcePort,
    IN ULONG MulticastUdpSourceAddress
#endif
    );

ULONG
RomSendUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    );

ULONG
RomReceiveUdpPacket (
    IN PVOID Buffer,
    IN ULONG Length,
    IN ULONG Timeout,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort
    );

ULONG
RomGetNicType (
    OUT t_PXENV_UNDI_GET_NIC_TYPE *NicType
    );

ULONG
RomMtftpReadFile (
    IN PUCHAR FileName,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG ServerIPAddress, // network byte order
    IN ULONG MCastIPAddress, // network byte order
    IN USHORT MCastCPort, // network byte order
    IN USHORT MCastSPort, // network byte order
    IN USHORT Timeout,
    IN USHORT Delay,
    OUT PULONG DownloadSize
    );

//////////////////////////////////////////////////////////////////////////////
//
// TFTP layer definitions.
//
//////////////////////////////////////////////////////////////////////////////

typedef struct _TFTP_REQUEST {
    PUCHAR RemoteFileName;
    ULONG ServerIpAddress;
    PUCHAR MemoryAddress;
    ULONG MaximumLength;
    ULONG BytesTransferred;
    USHORT Operation;
#if defined(REMOTE_BOOT_SECURITY)
    ULONG SecurityHandle;
#endif // defined(REMOTE_BOOT_SECURITY)
    TYPE_OF_MEMORY MemoryType;

    // If TRUE will update the progress bar
    BOOLEAN ShowProgress;
    
} TFTP_REQUEST, *PTFTP_REQUEST;

NTSTATUS
TftpInit (
    VOID
    );

NTSTATUS
TftpGetPut (
    IN PTFTP_REQUEST Request
    );

#if defined(REMOTE_BOOT_SECURITY)
NTSTATUS
TftpLogin (
    IN PUCHAR Domain,
    IN PUCHAR Name,
    IN PUCHAR OwfPassword,
    IN ULONG ServerIpAddress,
    OUT PULONG LoginHandle
    );

NTSTATUS
TftpLogoff (
    IN ULONG ServerIpAddress,
    IN ULONG LoginHandle
    );

NTSTATUS
TftpSignString (
    IN PUCHAR String,
    OUT PUCHAR * Sign,
    OUT ULONG * SignLength
    );
#endif // defined(REMOTE_BOOT_SECURITY)

//
// This file contains the definitions for the TFTP connection control
// block, which contains all the information pertaining to a connection.
// A conn structure is allocated at connection open time and retained
// until the connection is closed.  The routines in the file conn.c
// are sufficient for dealing with connections.
// It also contains the structure definition for tftp packets.
//

//
// Connection control block.
//

typedef struct _CONNECTION {

    ULONG BlockSize;                // block size for transfer

    PVOID LastSentPacket;           // previous packet sent
    ULONG LastSentLength;           // size of previous packet

    ULONG NextRetransmit;           // when to retransmit
    ULONG Retransmissions;          // number of retransmits
    ULONG Timeout;                  // retransmit timeout

    PVOID CurrentPacket;            // current packet (send or rcv)
    ULONG CurrentLength;            // current packet len

    PVOID LastReceivedPacket;       // last received packet
    ULONG LastReceivedLength;       // size of last rcvd. packet

    ULONG RemoteHost;               // remote host IP address
    USHORT RemotePort;              // remote port for connection
    USHORT LocalPort;               // local port for connection

    USHORT Operation;               // direction of transfer
    USHORT BlockNumber;             // next block number
    BOOLEAN Synced;                 // conn synchronized flag

} CONNECTION, *PCONNECTION;

#include <packon.h>

#define ETHERNET_ADDRESS_LENGTH 6

#define COPY_ETHERNET_ADDRESS(_d,_s) RtlCopyMemory( (_d), (_s), ETHERNET_ADDRESS_LENGTH );

#define COPY_IP_ADDRESS(_d,_s) RtlCopyMemory( (_d), (_s), sizeof(ULONG) )
#define COMPARE_IP_ADDRESSES(_a,_b) RtlEqualMemory( (_a), (_b), sizeof(ULONG) )

typedef struct _TFTP_HEADER {
    USHORT Opcode;                      // packet type
    USHORT BlockNumber;                 // block number
} TFTP_HEADER, *PTFTP_HEADER;

typedef struct _TFTP_PACKET {
    TFTP_HEADER ;
    UCHAR Data[1];
} TFTP_PACKET, *PTFTP_PACKET;

#include <packoff.h>

//
// Connection constants.
//

#define TFTP_PORT 0x4500                // big-endian 69

#define TIMEOUT         1               // initial retransmit timeout
#define INITIAL_TIMEOUT 1               // initial connection timeout
#define MAX_TIMEOUT     8               // max. retransmit timeout
#define MAX_RETRANS     8               // max. no. of retransmits

#define DEFAULT_BLOCK_SIZE 1432         // size of data portion of tftp pkt

//
// ideally this should be the commented out size.  But we overload the
// use of this constant to also be the size we use for udp receives.
// Since we can receive larger packets than this when we get the driver
// info packet, we need to bump up this buffer size.  ideally we would
// allocate enough space at runtime, but this is a safer fix at this point
// in the product.
//
//#define MAXIMUM_TFTP_PACKET_LENGTH (sizeof(TFTP_HEADER) + DEFAULT_BLOCK_SIZE)
#define MAXIMUM_TFTP_PACKET_LENGTH (4096)

#define SWAP_WORD(_w) (USHORT)((((_w) << 8) & 0xff00) | (((_w) >> 8) & 0x00ff))
#define SWAP_DWORD(_dw) (ULONG)((((_dw) << 24) & 0xff000000) | \
                                (((_dw) << 8) & 0x00ff0000) | \
                                (((_dw) >> 8) & 0x0000ff00) | \
                                (((_dw) >> 24) & 0x000000ff))

//
// Packet types.
//
// N.B. The constants below are defined as big-endian USHORTs.
//

#define TFTP_RRQ        0x0100          // Read Request
#define TFTP_WRQ        0x0200          // Write Request
#define TFTP_DATA       0x0300          // Data block
#define TFTP_DACK       0x0400          // Data Acknowledge
#define TFTP_ERROR      0x0500          // Error
#define TFTP_OACK       0x0600          // Options Acknowledge

//
// Values for error codes in ERROR packets.
//
// N.B. The constants below are defined as big-endian USHORTs.
//

#define TFTP_ERROR_UNDEFINED            0x0000
#define TFTP_ERROR_FILE_NOT_FOUND       0x0100
#define TFTP_ERROR_ACCESS_VIOLATION     0x0200
#define TFTP_ERROR_DISK_FULL            0x0300
#define TFTP_ERROR_ILLEGAL_OPERATION    0x0400
#define TFTP_ERROR_UNKNOWN_TRANSFER_ID  0x0500
#define TFTP_ERROR_FILE_EXISTS          0x0600
#define TFTP_ERROR_NO_SUCH_USER         0x0700
#define TFTP_ERROR_OPTION_NEGOT_FAILED  0x0800

//
// Global variables.
//

extern CONNECTION NetTftpConnection;
extern UCHAR NetTftpPacket[3][MAXIMUM_TFTP_PACKET_LENGTH];

//
// External declarations.
//

NTSTATUS
ConnInitialize (
    OUT PCONNECTION *Connection,
    IN USHORT Operation,
    IN ULONG RemoteHost,
    IN USHORT RemotePort,
    IN PUCHAR Filename,
    IN ULONG BlockSize,
#if defined(REMOTE_BOOT_SECURITY)
    IN OUT PULONG SecurityHandle,
#endif // defined(REMOTE_BOOT_SECURITY)
    IN OUT PULONG FileSize
    );

NTSTATUS
ConnReceive (
    IN PCONNECTION Connection,
    OUT PTFTP_PACKET *Packet
    );

PTFTP_PACKET
ConnPrepareSend (
    IN PCONNECTION Connection
    );

VOID
ConnAck (
    IN PCONNECTION Connection
    );

VOID
ConnSendPacket (
    IN PCONNECTION Connection,
    IN PVOID Packet,
    IN ULONG Length
    );

NTSTATUS
ConnWait (
    IN PCONNECTION Connection,
    IN USHORT Opcode,
    OUT PTFTP_PACKET *Packet OPTIONAL
    );

BOOLEAN
ConnRetransmit (
    IN PCONNECTION Connection,
    IN BOOLEAN Timeout
    );

NTSTATUS
ConnSend (
    IN PCONNECTION Connection,
    IN ULONG Length
    );

NTSTATUS
ConnWaitForFinalAck (
    IN PCONNECTION Connection
    );

VOID
ConnError (
    PCONNECTION Connection,
    ULONG RemoteHost,
    USHORT RemotePort,
    USHORT ErrorCode,
    PUCHAR ErrorMessage
    );

ULONG
ConnSafeAtol (
    IN PUCHAR Buffer,
    IN PUCHAR BufferEnd
    );

ULONG
ConnItoa (
    IN ULONG Value,
    OUT PUCHAR Buffer
    );

//
// UDP definitions.
//

extern USHORT UdpUnicastDestinationPort;

USHORT
UdpAssignUnicastPort (
    VOID
    );

#if 0
VOID
UdpSetMulticastPort (
    IN USHORT DestinationPort,
    IN ULONG DestinationAddress,
    IN USHORT SourcePort,
    IN ULONG SourceAddress
    );
#endif

ULONG
UdpReceive (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG RemoteHost,
    OUT PUSHORT RemotePort,
    IN ULONG Timeout
    );

ULONG
UdpSend (
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG RemoteHost,
    IN USHORT RemotePort
    );

ULONG
tcpxsum (
    IN ULONG cksum,
    IN PUCHAR buf,
    IN ULONG len
    );

#define SysGetRelativeTime ArcGetRelativeTime

//////////////////////////////////////////////////////////////////////////////
//
// Debugging package definitions.
//
//////////////////////////////////////////////////////////////////////////////

#if DBG

extern ULONG NetDebugFlag;

#define DEBUG_ERROR              0x00000001
#define DEBUG_CONN_ERROR         0x00000002
#define DEBUG_LOUD               0x00000004
#define DEBUG_REAL_LOUD          0x00000008
#define DEBUG_STATISTICS         0x00000010
#define DEBUG_SEND_RECEIVE       0x00000020
#define DEBUG_TRACE              0x00000040
#define DEBUG_ARP                0x00000080
#define DEBUG_OSC                0x00000100
#define DEBUG_INITIAL_BREAK      0x80000000

#undef IF_DEBUG
#define IF_DEBUG(_f) if ( (NetDebugFlag & DEBUG_ ## _f) != 0 )

#define DPRINT(_f,_a) IF_DEBUG(_f) DbgPrint _a

#define DEBUG if ( TRUE )

#else // DBG

#undef IF_DEBUG
#define IF_DEBUG(_f) if ( FALSE )
#define DPRINT(_f,_a)
#define DEBUG if ( FALSE )

#endif // else DBG

#endif // _NETFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\parseini.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    parseini.h

Abstract:

    Common header file for parsing .ini files

Author:

    John Vert (jvert) 6-Oct-1993

Environment:

    ARC environment

Revision History:

--*/
#include "bldr.h"
#include "setupblk.h"
#include "stdio.h"
#include "stdarg.h"

#define BL_INF_FILE_ERROR (ULONG)-1

//
// Defines for *externally* fulfilled error handling routines.  setupldr and osloader each
// have different versions of these routines.
//

#if DEVL

#define SlError(x) SlErrorBox(x , __LINE__, __FILE__ )

#else

#define SlError(x)

#endif

#define SlNoMemoryError() SlNoMemError(__LINE__, __FILE__ )

VOID
SlNoMemError(
    IN ULONG Line,
    IN PCHAR File
    );

VOID
SlBadInfLineError(
    IN ULONG Line,
    IN PCHAR INFFile
    );

VOID
SlErrorBox(
    IN ULONG MessageId,
    IN ULONG Line,
    IN PCHAR File
    );

VOID
SlFatalError(
    IN ULONG MessageId,
    ...
    );

VOID
SlFriendlyError(
    IN ULONG uStatus,
    IN PCHAR pchBadFile,
    IN ULONG uLine,
    IN PCHAR pchCodeFile
    );



//
// Routines for parsing the setupldr.ini file
//

#define SIF_FILENAME_INDEX 0

extern PVOID InfFile;
extern PVOID WinntSifHandle;

ARC_STATUS
SlInitIniFile(
   IN  PCHAR   DevicePath,
   IN  ULONG   DeviceId,
   IN  PCHAR   INFFile,
   OUT PVOID  *pINFHandle,
   OUT PVOID  *pINFBuffer OPTIONAL,
   OUT PULONG  INFBufferSize OPTIONAL,
   OUT PULONG  ErrorLine
   );

PCHAR
SlGetIniValue(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PCHAR Default
    );

#ifdef UNICODE
PWCHAR
SlGetIniValueW(
    IN PVOID InfHandle,
    IN PCHAR SectionName,
    IN PCHAR KeyName,
    IN PWCHAR Default
    );
#endif


PCHAR
SlGetKeyName(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );

#ifdef UNICODE
PWCHAR
SlGetKeyNameW(
    IN PVOID INFHandle,
    IN PCHAR SectionName,
    IN ULONG LineIndex
    );
#endif

ULONG
SlGetSectionKeyOrdinal(
    IN  PVOID INFHandle,
    IN  PCHAR SectionName,
    IN  PCHAR Key
    );

PCHAR
SlGetSectionKeyIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   );

#ifdef UNICODE
PWCHAR
SlGetSectionKeyIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN PCHAR Key,
   IN ULONG ValueIndex
   );
#endif

PTCHAR
SlCopyString(
    IN PTCHAR String
    );

PCHAR
SlCopyStringA(
    IN PCSTR String
    );

PWCHAR
SlCopyStringAW(
    IN PCHAR String
    );

#ifdef UNICODE
#define SlCopyStringAT  SlCopyStringAW
#else
#define SlCopyStringAT  SlCopyStringA
#endif

PCHAR
SlGetSectionLineIndex (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   );

#ifdef UNICODE
PWCHAR
SlGetSectionLineIndexW (
   IN PVOID INFHandle,
   IN PCHAR SectionName,
   IN ULONG LineIndex,
   IN ULONG ValueIndex
   );
#endif


ULONG
SlCountLinesInSection(
    IN PVOID INFHandle,
    IN PCHAR SectionName
    );

BOOLEAN
SpSearchINFSection (
   IN PVOID INFHandle,
   IN PCHAR SectionName
   );

PCHAR
SlSearchSection(
    IN PCHAR SectionName,
    IN PCHAR TargetName
    );

ARC_STATUS
SpFreeINFBuffer (
   IN PVOID INFHandle
   );


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\pxe_api.h ===
/*
 *
 * Modifications:   $Header:   J:/Archives/preboot/lsa2/inc/pxe_api.h_v   1.0   May 02 1997 17:01:00   MJOHNSOX  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _PXENV_API_H
#define	_PXENV_API_H

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/*	Parameter structure and type definitions for PXENV API version 2.x
 *
 *	PXENV.H needs to be #included before this file.
 *
 *	None of the PXENV API services are available after the stack
 *	has been unloaded.
 */

#include "bootp.h"			/* Defines BOOTPLAYER */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Format of PXENV entry point structure.
 */
typedef struct s_PXENV_ENTRY {
	UINT8 signature[6];		/* 'PXENV+' */
	UINT16 version;			/* MSB=major, LSB=minor */
	UINT8 length;			/* sizeof(struct s_PXENV_ENTRY) */
	UINT8 checksum;			/* 8-bit checksum off structure, */
					/* including this bytes should */
					/* be 0. */
	UINT16 rm_entry_off;		/* 16-bit real-mode offset and */
	UINT16 rm_entry_seg;		/* segment of the PXENV API entry */
					/* point. */
	UINT16 pm_entry_off;		/* 16-bit protected-mode offset */
	UINT32 pm_entry_seg;		/* and segment base address of */
					/* the PXENV API entry point. */
    /* The PROM stack, base code and data segment selectors are only */
    /* required until the base code (TFTP API) layer is removed from */
    /* memory (this can only be done in real mode). */
    UINT16 stack_sel;           /* PROM stack segment. Will be set */
    UINT16 stack_size;          /* to 0 when removed from memory. */
    UINT16 base_cs_sel;         /* Base code segment. Will be set */
    UINT16 base_cs_size;        /* to 0 when removed from memory. */
    UINT16 base_ds_sel;         /* Base data segment. Will be set */
    UINT16 base_ds_size;        /* to 0 when removed from memory. */
    UINT16 mlid_ds_sel;         /* MLID data segment. Will be set */
    UINT16 mlid_ds_size;        /* to 0 when removed from memory. */
    UINT16 mlid_cs_sel;         /* MLID code segment. Will be set */
    UINT16 mlid_cs_size;        /* to 0 when removed from memory. */
#if 0
    UINT16 unknown1;            /* The V1.0 beta ROM added two extra unknown fields. */
    UINT16 unknown2;            /* They are not included in the definition here in   */
                                /* order to allow startrom\main.c\PxenvVerifyEntry   */
                                /* to work with older ROMs.                          */
#endif
} t_PXENV_ENTRY;

#define	PXENV_ENTRY_SIG			"PXENV+"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a PXENV API service.
 */
#define PXENV_UNLOAD_STACK		0x70
#define PXENV_GET_BINL_INFO		0x71
#define	PXENV_RESTART_DHCP		0x72
#define	PXENV_RESTART_TFTP		0x73
#define	PXENV_GET_RAMD_INFO		0x74


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* PXENV API parameter structure typedefs.
 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_UNLOAD_STACK {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT16 rm_entry_off;		/* Out: 16-bit real-mode segment and */
	UINT16 rm_entry_seg;		/*      offset of PXENV Entry Point */
					/*      structure. */
	UINT16 pm_entry_off;		/* Out: 16-bit protected-mode offset */
	UINT32 pm_entry_base;		/*      and segment base address of */
					/*      PXENV Entry Point structure. */
} t_PXENV_UNLOAD_STACK;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Packet types that can be requested in the s_PXENV_GET_BINL_INFO structure. */
#define PXENV_PACKET_TYPE_DHCP_DISCOVER  1
#define PXENV_PACKET_TYPE_DHCP_ACK       2
#define PXENV_PACKET_TYPE_BINL_REPLY     3

/* Three packets are preserved and available through this interface: 1) The
 * DHCP Discover packet sent by the client, 2) the DHCP acknowledgement
 * packet returned by the DHCP server, and 3) the reply packet from the BINL
 * server.  If the DHCP server provided the image bootfile name, the
 * DHCP_ACK and BINL_REPLY packets will identical.
 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_GET_BINL_INFO {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT16 packet_type;		/* In: See PXENV_PACKET_TYPE_xxx */
					/*     constants */
	UINT16 buffer_size;		/* In: Size of the buffer in */
					/*     bytes.  Specifies the maximum */
					/*     amount of data that will be */
					/*     copied by the service.  A size */
					/*     of zero is valid. */
					/* Out: Amount of BINL data, in */
					/*      bytes, that was copied into */
					/*      the buffer.  For an input */
					/*      size of zero, no data will be */
					/*      copied and buffer_size will */
					/*      be set to the maximum amount */
					/*      of data available to be */
					/*      copied. */
	UINT16 buffer_offset;		/* In: 16-bit offset and segment */
	UINT16 buffer_segment;		/*     selector of a buffer where the */
					/*     requested packet will be */
					/*     copied. */
} t_PXENV_GET_BINL_INFO;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_RESTART_DHCP {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
} t_PXENV_RESTART_DHCP;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
#define	s_PXENV_RESTART_TFTP	s_PXENV_TFTP_READ_FILE
#define	t_PXENV_RESTART_TFTP	t_PXENV_TFTP_READ_FILE


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_GET_RAMD_INFO {
	UINT16 status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT32 ramd_info;		/* Out: Far pointer to RAMDisk */
					/*      information structure. */
} t_PXENV_GET_RAMD_INFO;


typedef struct s_PXENV_RAMD_INFO {
	UINT16 orig_fbms;		/* Original free base memory size. */
	UINT32 ramd_addr;		/* RAMDisk physical address. */
	UINT32 orig_int13;		/* Original Int 13h ISR. */
	UINT32 orig_int1A;		/* Original Int 1Ah ISR. */
	UINT32 orig_pxenv;
	UINT16 dhcp_discover_seg;	/* Segment address & length of */
	UINT16 dhcp_discover_len;	/* DHCP discover packet. */
	UINT16 dhcp_ack_seg;		/* Segment address & length of */
	UINT16 dhcp_ack_len;		/* DHCP ack packet. */
	UINT16 binl_reply_seg;		/* Segment address & length of */
	UINT16 binl_reply_len;		/* BINL reply packet. */
	UINT16 flags;			/* RAMDisk operation flags. */
	UINT16 xms_page;		/* XMS page number of relocated */
					/* RAMDisk image.  0 == use Int 87h. */
	UINT32 xms_entry;		/* XMS API entry point. */
} t_PXENV_RAMD_INFO;


#define	PXENV_RAMD_FLAG_DISABLE		0x0001
#define	PXENV_RAMD_FLAG_PROTECTED	0x0002


#endif /* _PXENV_API_H */

/* EOF - $Workfile:   pxe_api.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\netboot.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netboot.h

Abstract:

    This module defines globally used procedure and data structures used
    by net boot.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#ifndef _NETBOOT_
#define _NETBOOT_

#include <oscpkt.h>    // defines NET_CARD_INFO

#ifdef EFI
#include <efi.h>
#endif

#define NET_DEVICE_ID 'dten'


//
//  The following structure is used to define the parameters of the net
//  volume.  Given a FileId we can access the structure context through
//  the structure context field in the global BlFileTable (e.g.,
//  BlFileTable[FileId].StructureContext).
//

typedef struct _NET_STRUCTURE_CONTEXT {

    ULONG Dummy;

} NET_STRUCTURE_CONTEXT, *PNET_STRUCTURE_CONTEXT;

//
//  The following structure is used to define the location and size of each
//  opened file.  There is one of these of every opened file.  It is part of
//  the union of a BL_FILE_TABLE structuure.  Given a FileId we can access the
//  file context via the BlFileTable (e.g., BlFileTable[FileId].u.NetFileContext)
//

typedef struct _NET_FILE_CONTEXT {

    PUCHAR InMemoryCopy;
    ULONG FileSize;

#if defined(REMOTE_BOOT)
    BOOLEAN CachedFile;
    ULONG CachedFileId;
#endif // defined(REMOTE_BOOT)

} NET_FILE_CONTEXT, *PNET_FILE_CONTEXT;


#if defined(REMOTE_BOOT)
//
// The following defines are for parameter passing between loaders, when switching.
// Each parameter contains a 4-byte quantity which is completely random, and then a
// 4 byte checksum generated by the following formula:
//   CkSum = (((b1 * 2) + b2) * 2) + b3) * 2 + b4
//
#define NET_REBOOT_WRITE_SECRET_ONLY           0x53A590F10000073D
#define NET_REBOOT_DISK_SECRET_VALID           0xE32C78B70000096F
#endif // defined(REMOTE_BOOT)
#define NET_REBOOT_COMMAND_CONSOLE_ONLY        0x83CDA43F000008D3
#define NET_REBOOT_ASR                         0x9cb2521700000863

//
// Global variables available outside of the "network file system" part
// of the loader.
//

extern ULONG NetLocalIpAddress;
extern ULONG NetLocalSubnetMask;

extern ULONG NetServerIpAddress;
extern ULONG NetGatewayIpAddress;

extern CHAR NetBootPath[129];
extern PCHAR NetServerShare;

extern UCHAR NetBootIniContents[1020 + 1];
extern UCHAR NetBootIniPath[256 + 1];

extern USHORT NetMaxTranUnit; // MTU
extern USHORT NetHwAddrLen; // actual length of hardware address
extern USHORT NetHwType; // Type of protocol at the hardware level from rfc1010

extern BOOLEAN NetBootTftpUsedPassword2;

#if defined(_IA64_)
extern EFI_PXE_BASE_CODE *PXEClient;
extern EFI_HANDLE         PXEHandle;
#endif

#if defined(REMOTE_BOOT)

extern BOOLEAN NetBootRepin;
extern BOOLEAN NetworkBootRom;
extern BOOLEAN NetBootCSC;

extern CHAR NetBootActivePartitionName[80];
extern CHAR NetBootCSCPartitionName[80];
extern BOOLEAN NetBootSearchedForCSC;

#endif // defined(REMOTE_BOOT)


//
// Define ARC hooks.
//

ARC_STATUS
NetArcClose (
    IN ULONG FileId
    );

ARC_STATUS
NetArcOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

//
// Define file I/O prototypes.
//

ARC_STATUS
NetClose (
    IN ULONG FileId
    );

ARC_STATUS
NetMount (
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
NetOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
NetRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NetGetReadStatus (
    IN ULONG FileId
    );

ARC_STATUS
NetSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
NetWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NetGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
NetSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
NetRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    );

ARC_STATUS
NetGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    );

ARC_STATUS
NetInitialize (
    VOID
    );

VOID
NetTerminate (
    VOID
    );

//
//
// Define network helper functions for the loaders.
//

NTSTATUS
NetQueryCardInfo(
    IN OUT PNET_CARD_INFO CardInfo
    );

NTSTATUS
NetQueryDriverInfo(
    IN PNET_CARD_INFO CardInfo,
    IN PCHAR SetupPath,
    IN PCHAR NtBootPathName,
    IN OUT PWCHAR HardwareId,
    IN ULONG HardwareIdLength,  // in bytes
    IN OUT PWCHAR DriverName,
    IN OUT PCHAR DriverNameAnsi,
    IN ULONG DriverNameLength,  // in bytes
    IN OUT PWCHAR ServiceName,
    IN ULONG ServiceNameLength, // in bytes
    OUT PCHAR * Registry,
    OUT ULONG * RegistryLength
    );

#if defined(REMOTE_BOOT)
NTSTATUS
NetCopyHalAndKernel(
    IN PCHAR HalName,
    IN PCHAR Guid,
    IN ULONG GuidLength
    );

NTSTATUS
NetPrepareIpsec(
    IN ULONG InboundSpi,
    OUT ULONG * SessionKey,
    OUT ULONG * OutboundSpi
    );
#endif // defined(REMOTE_BOOT)

ARC_STATUS
GetGuid(
    OUT PUCHAR *Guid,
    OUT PULONG GuidLength
    );

VOID
NetGetRebootParameters(
    OUT PULONGLONG Param OPTIONAL,
    OUT PUCHAR RebootFile OPTIONAL,
    OUT PUCHAR SifFile OPTIONAL,
    OUT PUCHAR User OPTIONAL,
    OUT PUCHAR Domain OPTIONAL,
    OUT PUCHAR Password OPTIONAL,
    OUT PUCHAR AdministratorPassword OPTIONAL,
    IN BOOLEAN ClearRestartBlock
    );

NTSTATUS
NetSoftReboot(
    IN PUCHAR NextBootFile,
    IN ULONGLONG Param,
    IN PUCHAR RebootFile OPTIONAL,
    IN PUCHAR SifFile OPTIONAL,
    IN PUCHAR User OPTIONAL,
    IN PUCHAR Domain OPTIONAL,
    IN PUCHAR Password OPTIONAL,
    IN PUCHAR AdministratorPassword OPTIONAL
    );

ARC_STATUS
NetFillNetworkLoaderBlock (
    PNETWORK_LOADER_BLOCK NetworkLoaderBlock
    );

#if defined(_ALPHA_)
#define NetFindCSCPartitionName() FALSE
#else
BOOLEAN
NetFindCSCPartitionName(
    VOID
    );
#endif

#endif // _NETBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\pxe.h ===
/*
 *
 * Modifications:   $Header:   V:/archives/INCLUDE/pxe.h_v   1.1   Apr 16 1997 15:55:56   PWICKERX  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

/* Sample PXE Constants for Extensions to DHCP Protocol */

/* All numbers are temporary for testing and subject to review */

/* sample UDP port assigned to PXE/BINL */
#define PXE_BINL_PORT		256

#define PXE_CLS_CLIENT		"PXEClient"

#define PXE_LCMSERVER_TAG	179 /* Option tag for Server. */
#define PXE_LCMDOMAIN_TAG	180 /* Option tag for Domain. */
#define PXE_LCMNICOPT0_TAG	181 /* Option tag for NIC option 0. */
#define PXE_LCMWRKGRP_TAG	190 /* Option tag for Work group. */

/* 43 options used by bstrap.1 */
#define	PXE_NIC_PATH		64	/* 64,len,'name',0 */
#define	PXE_MAN_INFO		65	/* 65,len,ip2,ip3,'name',0 */
#define	PXE_OS_INFO			66	/* 66,len,ip2,ip3,'name',0,'text',0 */

/* externally specified "PXEClient" class 43 options */
#define PXE_MTFTP_IP		1
#define PXE_MTFTP_CPORT		2
#define PXE_MTFTP_SPORT		3
#define PXE_MTFTP_TMOUT		4
#define PXE_MTFTP_DELAY		5

/* EOF - $Workfile:   pxe.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\ramdisk.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    ramdisk.h

Abstract:

    Provides the ARC emulation routines for I/O to a RAM disk device.

Author:

    Chuck Lenzmeier (chuckl) 29-Apr-2001

Revision History:

--*/


//
// Ramdisk error Codes. These are defined in \bldr\msg.* or 
// \setup\msgs.*. They are redefined here since ramdisk.c
// is in \lib and is used in both osloader and setupldr.
//
#define RAMDISK_GENERAL_FAILURE             15000
#define RAMDISK_INVALID_OPTIONS             15001
#define RAMDISK_BUILD_FAILURE               15002
#define RAMDISK_BOOT_FAILURE                15003
#define RAMDISK_BUILD_DISCOVER              15004
#define RAMDISK_BUILD_REQUEST               15005
#define RAMDISK_BUILD_PROGRESS_TIMEOUT      15006
#define RAMDISK_BUILD_PROGRESS_PENDING      15007
#define RAMDISK_BUILD_PROGRESS_ERROR        15008
#define RAMDISK_BUILD_PROGRESS              15009
#define RAMDISK_DOWNLOAD                    15010
#define RAMDISK_DOWNLOAD_NETWORK            15011
#define RAMDISK_DOWNLOAD_NETWORK_MCAST      15012

//
// Ramdisk Initialization
//

ARC_STATUS
RamdiskInitialize(
    IN PCHAR LoadOptions,
    IN BOOLEAN SdiBoot
    );

#if defined(_X86_)
VOID
RamdiskSdiBoot(
    PCHAR SdiFile
    );
#endif

//
// ARC I/O functions
//

ARC_STATUS
RamdiskClose(
    IN ULONG FileId
    );

ARC_STATUS
RamdiskMount(
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    );

ARC_STATUS
RamdiskOpen(
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
RamdiskRead(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
RamdiskReadStatus(
    IN ULONG FileId
    );

ARC_STATUS
RamdiskSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
RamdiskWrite(
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
RamdiskGetFileInfo(
    IN ULONG FileId,
    OUT PFILE_INFORMATION Finfo
    );

ARC_STATUS
RamdiskSetFileInfo (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
RamdiskRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewName
    );

ARC_STATUS
RamdiskGetDirectoryEntry (
    IN ULONG FileId,
    OUT PDIRECTORY_ENTRY Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

//
// Global variables
//

ULONG_PTR SdiAddress;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\pxe_cmn.h ===
/*
 *
 * Modifications:   $Header:   H:/ARCHIVES/preboot/lsa2/inc/pxe_cmn.h_v   1.3   May 09 1997 08:50:12   vprabhax  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _PXENV_CMN_H
#define _PXENV_CMN_H

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* PXENV.H - PXENV/TFTP/UNDI API common, Version 2.x, 97-Jan-17
 *
 * Constant and type definitions used in other PXENV API header files.
 */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Parameter/Result structure storage types.
 */
#ifndef _BASETSD_H_
typedef signed char INT8;
typedef signed short INT16;
typedef signed long INT32;
typedef unsigned char UINT8;
typedef unsigned short UINT16;
typedef unsigned long UINT32;
#endif

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Result codes returned in AX by a PXENV API service.
 */
#define PXENV_EXIT_SUCCESS	0x0000
#define PXENV_EXIT_FAILURE	0x0001
#define	PXENV_EXIT_CHAIN		0xFFFF	/* used internally */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* CPU types
 */
#define	PXENV_CPU_X86		0
#define	PXENV_CPU_ALPHA		1
#define	PXENV_CPU_PPC		2


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Bus types
 */
#define	PXENV_BUS_ISA		0
#define	PXENV_BUS_EISA		1
#define	PXENV_BUS_MCA		2
#define	PXENV_BUS_PCI		3
#define	PXENV_BUS_VESA		4
#define	PXENV_BUS_PCMCIA		5


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Status codes returned in the status word of PXENV API parameter structures.
 */

/* General errors */
#define PXENV_STATUS_SUCCESS	0x00
#define	PXENV_STATUS_FAILURE	0x01	/* General failure. */
#define	PXENV_STATUS_BAD_FUNC	0x02	/* Invalid function number. */
#define	PXENV_STATUS_UNSUPPORTED	0x03	/* Function is not yet supported. */
#define	PXENV_STATUS_1A_HOOKED	0x04	/* Int 1Ah cannot be unhooked. */

/* ARP errors */
#define	PXENV_STATUS_ARP_TIMEOUT				0x11

/* TFTP errors */
#define	PXENV_STATUS_TFTP_CANNOT_ARP_ADDRESS		0x30
#define	PXENV_STATUS_TFTP_OPEN_TIMEOUT			0x32
#define	PXENV_STATUS_TFTP_UNKNOWN_OPCODE			0x33
#define	PXENV_STATUS_TFTP_ERROR_OPCODE			0x34
#define	PXENV_STATUS_TFTP_READ_TIMEOUT			0x35
#define	PXENV_STATUS_TFTP_WRITE_TIMEOUT			0x37
#define	PXENV_STATUS_TFTP_CANNOT_OPEN_CONNECTION		0x38
#define	PXENV_STATUS_TFTP_CANNOT_READ_FROM_CONNECTION	0x39
#define	PXENV_STATUS_TFTP_CANNOT_WRITE_TO_CONNECTION	0x3A

/* BOOTP errors */
#define	PXENV_STATUS_BOOTP_TIMEOUT			0x41
#define	PXENV_STATUS_BOOTP_NO_CLIENT_OR_SERVER_IP		0x42
#define	PXENV_STATUS_BOOTP_NO_BOOTFILE_NAME		0x43
#define	PXENV_STATUS_BOOTP_CANNOT_ARP_REDIR_SRVR		0x44

/* DHCP errors */
#define	PXENV_STATUS_DHCP_TIMEOUT				0x51

#define PXENV_STATUS_UNDI_MEDIATEST_FAILED 		0x61

/* MTFTP errors */
#define	PXENV_STATUS_MTFTP_CANNOT_ARP_ADDRESS		0x90
#define	PXENV_STATUS_MTFTP_OPEN_TIMEOUT			0x92
#define	PXENV_STATUS_MTFTP_UNKNOWN_OPCODE			0x93
#define	PXENV_STATUS_MTFTP_READ_TIMEOUT			0x95
#define	PXENV_STATUS_MTFTP_WRITE_TIMEOUT			0x97
#define	PXENV_STATUS_MTFTP_CANNOT_OPEN_CONNECTION		0x98
#define	PXENV_STATUS_MTFTP_CANNOT_READ_FROM_CONNECTION	0x99
#define	PXENV_STATUS_MTFTP_CANNOT_WRITE_TO_CONNECTION	0x9A
#define	PXENV_STATUS_MTFTP_CANNOT_INIT_NIC_FOR_MCAST	0x9B
#define	PXENV_STATUS_MTFTP_TOO_MANY_PACKAGES		0x9C
#define	PXENV_STATUS_MTFTP_MCOPY_PROBLEM		0x9D


#endif /* _PXENV_CMN_H */

/* EOF - $Workfile:   pxe_cmn.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\ntfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used by Ntfs boot.

Author:

    Gary Kimura     [GaryKi]    10-Apr-1992

Revision History:

--*/

#ifndef _NTFSBOOT_
#define _NTFSBOOT_


//
//  Some important manifest constants.  These are the maximum byte size we'll ever
//  see for a file record or an index allocation buffer.
//

#define MAXIMUM_FILE_RECORD_SIZE         (4096)

#define MAXIMUM_INDEX_ALLOCATION_SIZE    (4096)

#define MAXIMUM_COMPRESSION_UNIT_SIZE    (65536)

//
//  The following structure is an mcb structure for storing cached retrieval pointer
//  information.
//

#define MAXIMUM_NUMBER_OF_MCB_ENTRIES    (16)

typedef struct _NTFS_MCB {

    //
    //  The following fields indicate the number of entries in use by the mcb. and
    //  the mcb itself.  The mcb is just a collection of vbo - lbo pairs.  The last
    //  InUse entry Lbo's value is ignored, because it is only used to give the
    //  length of the previous run.
    //

    ULONG InUse;

    LONGLONG Vbo[ MAXIMUM_NUMBER_OF_MCB_ENTRIES ];
    LONGLONG Lbo[ MAXIMUM_NUMBER_OF_MCB_ENTRIES ];

} NTFS_MCB, *PNTFS_MCB;
typedef const NTFS_MCB *PCNTFS_MCB;

//
//  Define the Ntfs file context structure and the attribute context structure.
//

typedef struct _NTFS_FILE_CONTEXT {

    //
    //  The following field indicates the type of attribute opened
    //

    ULONG TypeCode;

    //
    //  The following field indicates the size of the data portion of the attribute
    //

    LONGLONG DataSize;

    //
    //  The following two fields identify and locate the attribute on the volume.
    //  The first number is the file record where the attribute header is located and
    //  the second number is the offset in the file record of the attribute header
    //

    LONGLONG FileRecord;
    USHORT FileRecordOffset;

    //
    //  The following field indicates if the attribute is resident
    //

    BOOLEAN IsAttributeResident;

    //
    //  The following fields are only used if the data stream is compressed.
    //  If it is compressed then the CompressionFormat field is not zero, and
    //  contains the value to pass to the decompression engine.  CompressionUnit
    //  is the number of bytes in each unit of compression.
    //

    USHORT  CompressionFormat;
    ULONG CompressionUnit;

} NTFS_FILE_CONTEXT, *PNTFS_FILE_CONTEXT;
typedef NTFS_FILE_CONTEXT NTFS_ATTRIBUTE_CONTEXT, *PNTFS_ATTRIBUTE_CONTEXT;
typedef const NTFS_FILE_CONTEXT *PCNTFS_ATTRIBUTE_CONTEXT;

//
//  Define the Ntfs volume structure context
//

typedef struct _NTFS_STRUCTURE_CONTEXT {

    //
    //  This is the device that we talk to
    //

    ULONG DeviceId;

    //
    //  Some volume specific constants that describe the size of various records
    //

    ULONG BytesPerCluster;
    ULONG BytesPerFileRecord;

    //
    //  The following three fields describe the $DATA stream for the the MFT.  We
    //  need two Mcbs one holds the base of the mft and the other to hold any excess
    //  retrival information.  I.e., we must not loose the base mcb otherwise we
    //  can't find anything.
    //

    NTFS_ATTRIBUTE_CONTEXT MftAttributeContext;
    NTFS_MCB MftBaseMcb;

    //
    //  The following three fields hold a cached mcb that we use for non-resident
    //  attributes other than the mft data stream.  The first two fields identify the
    //  attribute and the third field contains the cached mcb.
    //

    LONGLONG CachedMcbFileRecord[16];
    USHORT CachedMcbFileRecordOffset[16];
    NTFS_MCB CachedMcb[16];

} NTFS_STRUCTURE_CONTEXT, *PNTFS_STRUCTURE_CONTEXT;
typedef const NTFS_STRUCTURE_CONTEXT *PCNTFS_STRUCTURE_CONTEXT;


//
// Define file I/O prototypes.
//

ARC_STATUS
NtfsClose (
    IN ULONG FileId
    );

ARC_STATUS
NtfsOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    );

ARC_STATUS
NtfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NtfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
NtfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    );

ARC_STATUS
NtfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    );

ARC_STATUS
NtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
NtfsInitialize(
    VOID
    );

#endif // _NTFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\udfsboot.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    UDFSBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by CD/DVD boot for UDF images.

Author:

	Vijayachandran Jayaseelan (vijayj@microsoft.com)

Revision History:

--*/

#ifndef _UDFSBOOT_
#define _UDFSBOOT_

#include <udf.h>

#ifdef __cplusplus
extern "C" {
#endif

#define UDF_BLOCK_SIZE	2048
#define UDF_MAX_VOLUMES	1

//
// forward declarations
//
typedef struct _UDF_VOLUME* PUDF_VOLUME;
typedef struct _UDF_CACHE_ENTRY* PUDF_CACHE_ENTRY;
typedef struct _UDF_FILE_DIRECTORY* PUDF_FILE_DIRECTORY;
typedef PVOID PUDF_BLOCK;

//
// Volume abstraction
//
typedef struct _UDF_VOLUME {
  PUDF_CACHE_ENTRY  Cache;
  ULONG             StartBlk;
  ULONG             BlockSize;
  ULONG             DeviceId;
  ULONG             RootDirBlk;
} UDF_VOLUME;


ARC_STATUS
UDFSVolumeOpen(
  IN PUDF_VOLUME	Volume,
  IN ULONG 		DeviceId
  );

ARC_STATUS
UDFSVolumeReadBlock(
  IN PUDF_VOLUME Volume,
  IN ULONG BlockIdx, 
  OUT PUDF_BLOCK Block
  );

//
// File or Directory abstraction
//
typedef struct _UDF_FILE_IDENTIFIER {
  ULONG   BlockIdx;
  USHORT  Offset;		// inside the block
} UDF_FILE_IDENTIFIER, * PUDF_FILE_IDENTIFIER;


typedef struct _UDF_FILE_DIRECTORY {
  PUDF_VOLUME           Volume;
  ULONGLONG             Size;
  ULONG                 IcbBlk;
  ULONG                 StartDataBlk;	
  UDF_FILE_IDENTIFIER   FileId;
  UCHAR                 NumExtents;
  BOOLEAN               IsDirectory;
} UDF_FILE_DIRECTORY;


ARC_STATUS
UDFSDirGetFirstFID(
  IN PUDF_FILE_DIRECTORY Dir, 
  OUT PUDF_FILE_IDENTIFIER File,
  OUT PUDF_BLOCK Block
  );

ARC_STATUS
UDFSDirGetNextFID(
  IN PUDF_FILE_DIRECTORY Dir,
  IN OUT PUDF_FILE_IDENTIFIER File,
  IN OUT PUDF_BLOCK Block
  );

ARC_STATUS
UDFSDirGetFile(
  IN PUDF_FILE_DIRECTORY Dir,
  IN PCHAR Name,
  OUT PUDF_FILE_DIRECTORY File
  );

ARC_STATUS
UDFSFileReadBlock(
  IN PUDF_FILE_DIRECTORY  File,
  IN ULONG BlockIdx,
  IN ULONG Size,
  OUT PUDF_BLOCK Block
  );
	

ARC_STATUS
UDFSFileRead(
  IN PUDF_FILE_DIRECTORY File,
  IN PVOID Buffer,
  IN ULONG BufferSize,
  OUT PULONG Transfer
  );

ARC_STATUS	
UDFSFileSeek(
  IN PUDF_FILE_DIRECTORY File,
  IN PLARGE_INTEGER Offset,
  IN SEEK_MODE SeekMode
  );

ARC_STATUS
UDFSFileClose(
  IN PUDF_FILE_DIRECTORY File
  );

//
// Cache abstractions
//
#define UDF_MAX_PATH_LEN		256
#define UDF_MAX_CACHE_ENTRIES	48

typedef struct _UDF_CACHE_ENTRY {
  CHAR                Name[UDF_MAX_PATH_LEN];
  USHORT              Usage;
  UDF_FILE_DIRECTORY  File;
} UDF_CACHE_ENTRY;


ULONG
UDFCachePutEntry(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN PCHAR Name, 
  IN PUDF_FILE_DIRECTORY File
  );

ULONG
UDFCacheGetEntryByName(
  IN PUDF_CACHE_ENTRY Cache,
  IN PCHAR Name,
  IN BOOLEAN Increment
  );

VOID
UDFCacheFreeEntry(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN ULONG Idx
  );

VOID
UDFCacheIncrementUsage(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN ULONG Idx
  );

VOID
UDFCacheDecrementUsage(
  IN OUT PUDF_CACHE_ENTRY Cache,
  IN ULONG Idx
  );

//
// abstractions used by outside (loader) world
//
typedef struct _UDFS_STRUCTURE_CONTEXT {
  PUDF_VOLUME Volume;
} UDFS_STRUCTURE_CONTEXT, *PUDFS_STRUCTURE_CONTEXT;

//
// Define UDFS file context structure.
//
typedef struct _UDFS_FILE_CONTEXT {
  ULONG CacheIdx;
} UDFS_FILE_CONTEXT, *PUDFS_FILE_CONTEXT;

//
// Define file I/O prototypes.
//
PBL_DEVICE_ENTRY_TABLE
IsUDFSFileStructure (
  IN ULONG DeviceId,
  IN PVOID StructureContext
  );

ARC_STATUS
UDFSOpen (
  IN CHAR * FIRMWARE_PTR OpenPath,
  IN OPEN_MODE OpenMode,
  OUT ULONG * FIRMWARE_PTR FileId
  );

ARC_STATUS
UDFSClose (
  IN ULONG FileId
  );
    
ARC_STATUS
UDFSRead (
  IN ULONG FileId,
  OUT VOID * FIRMWARE_PTR Buffer,
  IN ULONG Length,
  OUT ULONG * FIRMWARE_PTR Count
  );

ARC_STATUS
UDFSSeek (
  IN ULONG FileId,
  IN LARGE_INTEGER * FIRMWARE_PTR Offset,
  IN SEEK_MODE SeekMode
  );

ARC_STATUS
UDFSWrite (
  IN ULONG FileId,
  IN VOID * FIRMWARE_PTR Buffer,
  IN ULONG Length,
  OUT ULONG * FIRMWARE_PTR Count
  );

ARC_STATUS
UDFSGetFileInformation (
  IN ULONG FileId,
  OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
  );

ARC_STATUS
UDFSSetFileInformation (
  IN ULONG FileId,
  IN ULONG AttributeFlags,
  IN ULONG AttributeMask
  );

ARC_STATUS
UDFSInitialize(
  VOID
  );

#ifdef __cplusplus
}
#endif

#endif // _UDFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\udp_api.h ===
#ifndef _UDP_API_H
#define _UDP_API_H


#include "pxe_cmn.h"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* #defines and constants
 */

/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a UDP API service.
 */
#define PXENV_UDP_OPEN			0x30
#define PXENV_UDP_CLOSE		0x31
#define PXENV_UDP_READ			0x32
#define PXENV_UDP_WRITE	0x33


typedef struct s_PXENV_UDP_OPEN {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
    UINT8 SrcIp[4];         /* Out: 32-bit IP address of this station. */
} t_PXENV_UDP_OPEN;


typedef struct s_PXENV_UDP_CLOSE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
} t_PXENV_UDP_CLOSE;


typedef struct s_PXENV_UDP_READ {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx #defines. */
    UINT8 SrcIp[4];         /* Out: See description below */
    UINT8 DestIp[4];        /* In/Out: See description below */
    UINT16 SrcPort;         /* Out: See description below */
    UINT16 DestPort;        /* In/Out: See description below */
    UINT16 BufferSize;      /* In: Size of receive buffer. */
                            /* Out: Length of packet written into */
                            /*      receive buffer. */
    UINT16 BufferOffset;    /* In: Segment/Selector and offset */
    UINT16 BufferSegment;   /*     of receive buffer. */
} t_PXENV_UDP_READ;

/*
src_ip: (Output)
======
UDP_READ fills this value on return with the 32-bit IP address
of the sender.

dest_ip: (Input/Output)
=======
If this field is non-zero then UDP_READ will filter the incoming
packets and accept those that are sent to this IP address.

If this field is zero then UDP_READ will accept any incoming
packet and return it's destination IP address in this field.

s_port: (Output)
=======
UDP_READ fills this value on return with the UDP port number
of the sender.

d_port: (Input/Output)
=======
If this field is non-zero then UDP_READ will filter the incoming
packets and accept those that are sent to this UDP port.

If this field is zero then UDP_READ will accept any incoming
packet and return it's destination UDP port in this field.

*/


typedef struct s_PXENV_UDP_WRITE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
    UINT8 DestIp[4];        /* In: 32-bit server IP address. */
    UINT8 GatewayIp[4];     /* In: 32-bit gateway IP address. */
    UINT16 SrcPort;         /* In: Source UDP port. */
    UINT16 DestPort;        /* In: Destination UDP port. */
	UINT16 BufferSize;		/* In: Length of packet in buffer. */
	UINT16 BufferOffset;		/* In: Segment/Selector and */
	UINT16 BufferSegment;		/*     offset of transmit buffer. */
} t_PXENV_UDP_WRITE;


#endif /* _UDP_API_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\ximagdef.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ximagdef.h

Abstract:

    This file contains image definitions and for both 32-bit and 64-bit
    images.

Author:

    Forrest C. Foltz (forrestf) 23-May-2000

Revision History:

--*/

#if defined(_X86AMD64_)

#undef IMAGE_ORDINAL_FLAG 
#undef IMAGE_ORDINAL
#undef IMAGE_THUNK_DATA
#undef PIMAGE_THUNK_DATA
#undef IMAGE_SNAP_BY_ORDINAL
#undef IMAGE_TLS_DIRECTORY
#undef PIMAGE_TLS_DIRECTORY
#undef IMAGE_NT_HEADERS
#undef PIMAGE_NT_HEADERS


#if IMAGE_DEFINITIONS == 32

#define IMAGE_ORDINAL_FLAG             IMAGE_ORDINAL_FLAG32
#define IMAGE_ORDINAL(x)               IMAGE_ORDINAL32(x)
#define IMAGE_THUNK_DATA               IMAGE_THUNK_DATA32
#define PIMAGE_THUNK_DATA              PIMAGE_THUNK_DATA32
#define IMAGE_SNAP_BY_ORDINAL(x)       IMAGE_SNAP_BY_ORDINAL32(x)
#define IMAGE_TLS_DIRECTORY            IMAGE_TLS_DIRECTORY32
#define PIMAGE_TLS_DIRECTORY           PIMAGE_TLS_DIRECTORY32
#define IMAGE_NT_HEADERS               IMAGE_NT_HEADERS32
#define PIMAGE_NT_HEADERS              PIMAGE_NT_HEADERS32

#elif IMAGE_DEFINITIONS == 64

#define IMAGE_ORDINAL_FLAG             IMAGE_ORDINAL_FLAG64
#define IMAGE_ORDINAL(x)               IMAGE_ORDINAL64(x)
#define IMAGE_THUNK_DATA               IMAGE_THUNK_DATA64
#define PIMAGE_THUNK_DATA              PIMAGE_THUNK_DATA64
#define IMAGE_SNAP_BY_ORDINAL(x)       IMAGE_SNAP_BY_ORDINAL64(x)
#define IMAGE_TLS_DIRECTORY            IMAGE_TLS_DIRECTORY64
#define PIMAGE_TLS_DIRECTORY           PIMAGE_TLS_DIRECTORY64
#define IMAGE_NT_HEADERS               IMAGE_NT_HEADERS64
#define PIMAGE_NT_HEADERS              PIMAGE_NT_HEADERS64

#endif

#define IMAGE_NT_HEADER(x) ((PIMAGE_NT_HEADERS)RtlImageNtHeader(x))

#ifndef _XIMAGDEF_H_
#define _XIMAGDEF_H_

//
// Macros used to determine whether an image is 32-bit or 64-bit, and an
// assert to make sure the Magic field has the same offset in both.
//

#define IMAGE_64BIT( ntheader )                                     \
    (((PIMAGE_NT_HEADERS32)(ntheader))->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)

#define IMAGE_32BIT( ntheader )                                     \
    (((PIMAGE_NT_HEADERS32)(ntheader))->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)

C_ASSERT( FIELD_OFFSET(IMAGE_NT_HEADERS32, OptionalHeader.Magic) ==
          FIELD_OFFSET(IMAGE_NT_HEADERS64, OptionalHeader.Magic) );


#endif  // _XIMAGDEF_H_

#endif  // _X86AMD64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\scsiboot.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    scsiboot.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the common SCSI boot port driver.

Author:

    Jeff Havens  (jhavens) 28-Feb-1991
    Mike Glass

Revision History:

--*/

#include "ntddscsi.h"

//
// SCSI Get Configuration Information
//
// LUN Information
//

typedef struct _LUNINFO {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    PVOID DeviceObject;
    struct _LUNINFO *NextLunInfo;
    UCHAR InquiryData[INQUIRYDATABUFFERSIZE];
} LUNINFO, *PLUNINFO;

typedef struct _SCSI_BUS_SCAN_DATA {
    USHORT Length;
    UCHAR InitiatorBusId;
    UCHAR NumberOfLogicalUnits;
    PLUNINFO LunInfoList;
} SCSI_BUS_SCAN_DATA, *PSCSI_BUS_SCAN_DATA;

typedef struct _SCSI_CONFIGURATION_INFO {
    UCHAR NumberOfBuses;
    PSCSI_BUS_SCAN_DATA BusScanData[1];
} SCSI_CONFIGURATION_INFO, *PSCSI_CONFIGURATION_INFO;

#define MAXIMUM_RETRIES 4

//
// SCSI device timeout values in seconds
//

#define SCSI_DISK_TIMEOUT   10
#define SCSI_CDROM_TIMEOUT  10
#define SCSI_TAPE_TIMEOUT  120

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    PSCSI_REQUEST_BLOCK Srb;
    PVOID LogicalAddress;
    ULONG Length;
}ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

typedef struct _SRB_SCATTER_GATHER {
    ULONG PhysicalAddress;
    ULONG Length;
}SRB_SCATTER_GATHER, *PSRB_SCATTER_GATHER;

//
// Srb Structure plus extra storage for the port driver.
//

#define IRP_STACK_SIZE 2

typedef struct _FULL_SCSI_REQUEST_BLOCK {
    SCSI_REQUEST_BLOCK Srb;
    PVOID PreviousIrp;
    IRP Irp;
    IO_STACK_LOCATION IrpStack[IRP_STACK_SIZE];
    ULONG SrbExtensionSize;
    MDL Mdl;
    ULONG PageFrame[20];
}FULL_SCSI_REQUEST_BLOCK, *PFULL_SCSI_REQUEST_BLOCK;

//
// Logical unit extension
//

typedef struct _LOGICAL_UNIT_EXTENSION {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG Flags;
    PIRP CurrentRequest;
    KSPIN_LOCK CurrentRequestSpinLock;
    PVOID SpecificLuExtension;
    struct _LOGICAL_UNIT_EXTENSION *NextLogicalUnit;
    KDEVICE_QUEUE RequestQueue;
    KSPIN_LOCK RequestQueueSpinLock;
    LONG RequestTimeoutCounter;
    ULONG RetryCount;
    UCHAR NumberOfLogicalUnits;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    SRB_SCATTER_GATHER ScatterGather[17];
} LOGICAL_UNIT_EXTENSION, *PLOGICAL_UNIT_EXTENSION;

//
// Device extension
//

typedef struct _DEVICE_EXTENSION {

    PDEVICE_OBJECT DeviceObject;

    //
    // Dma Adapter information.
    //

    PVOID MapRegisterBase;
    PADAPTER_OBJECT DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;

    //
    // Number of SCSI buses
    //

    UCHAR NumberOfBuses;

    //
    // Maximum targets per bus
    //

    UCHAR MaximumTargetIds;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // SCSI port driver flags
    //

    ULONG Flags;

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PIRP CompletedRequests;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    KSPIN_LOCK SpinLock;

    //
    // Miniport Initialization Routine
    //

    PHW_INITIALIZE HwInitialize;

    //
    // Miniport Start IO Routine
    //

    PHW_STARTIO HwStartIo;

    //
    // Miniport Interrupt Service Routine
    //

    PHW_INTERRUPT HwInterrupt;

    //
    // Miniport Reset Routine
    //

    PHW_RESET_BUS HwReset;

    //
    // Miniport DMA started Routine
    //

    PHW_DMA_STARTED HwDmaStarted;

    //
    // Buffers must be mapped into system space.
    //

    BOOLEAN MapBuffers;

    //
    // Is this device a bus master and does it require map registers.
    //

    BOOLEAN MasterWithAdapter;
    //
    // Device extension for miniport routines.
    //

    PVOID HwDeviceExtension;

    //
    // Miniport request interrupt enabled/disable routine.
    //

    PHW_INTERRUPT HwRequestInterrupt;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Adapter control routine.
    //

    PHW_ADAPTER_CONTROL HwAdapterControl;

    //
    // SCSI configuration information from inquiries.
    //

    PSCSI_CONFIGURATION_INFO ScsiInfo;

    //
    // Miniport noncached device extension
    //

    PVOID NonCachedExtension;

    //
    // The length of the non-cached extension
    //

    ULONG NonCachedExtensionSize;

    //
    // SrbExtension Zone Pool
    //

    PVOID SrbExtensionZonePool;
    PCHAR SrbExtensionPointer;

    //
    // Physical address of zone pool
    //

    ULONG PhysicalZoneBase;

    //
    // Size of Srb extension.
    //

    ULONG SrbExtensionSize;

    //
    // Spinlock for zoned hash table entries
    //

    KSPIN_LOCK ZoneSpinLock;

    //
    // Logical Unit Extension
    //

    ULONG HwLogicalUnitExtensionSize;

    PLOGICAL_UNIT_EXTENSION LogicalUnitList;


    ULONG TimerValue;

    //
    // Port timing count.
    //

    LONG PortTimeoutCounter;

    //
    // Shutdown Information.
    //

    BOOLEAN HasShutdown;
    BOOLEAN HasSetBoot;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)

//
// Port driver extension flags.
//

#define PD_CURRENT_IRP_VALID         0X0001
#define PD_RESET_DETECTED            0X0002
#define PD_NOTIFICATION_IN_PROGRESS  0X0004
#define PD_READY_FOR_NEXT_REQUEST    0X0008
#define PD_FLUSH_ADAPTER_BUFFERS     0X0010
#define PD_MAP_TRANSFER              0X0020
#define PD_CALL_DMA_STARTED          0X01000
#define PD_DISABLE_CALL_REQUEST      0X02000
#define PD_DISABLE_INTERRUPTS        0X04000
#define PD_ENABLE_CALL_REQUEST       0X08000
#define PD_TIMER_CALL_REQUEST        0X10000

//
// Logical unit extension flags.
//

#define PD_QUEUE_FROZEN              0X0001
#define PD_LOGICAL_UNIT_IS_ACTIVE    0X0002
#define PD_CURRENT_REQUEST_COMPLETE  0X0004
#define PD_LOGICAL_UNIT_IS_BUSY      0X0008

//
// The timer interval for the miniport timer routine specified in
// units of 100 nanoseconds.
//
#define PD_TIMER_INTERVAL (250 * 1000 * 10)   // 250 ms

#define PD_TIMER_RESET_HOLD_TIME    4

//
// The define the interloop stall.
//

#define PD_INTERLOOP_STALL 5

#define MINIMUM_SRB_EXTENSIONS 8
#define COMPLETION_DELAY 10

//
// Port driver error logging
//

#define ERROR_LOG_ENTRY_LENGTH 8

typedef struct _ERROR_LOG_ENTRY {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG ErrorCode;
    ULONG UniqueId;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;


//
// Define global data structures
//

extern ULONG ScsiPortCount;
extern FULL_SCSI_REQUEST_BLOCK PrimarySrb;
extern FULL_SCSI_REQUEST_BLOCK AbortSrb;

#define MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS 16
extern PDEVICE_OBJECT ScsiPortDeviceObject[MAXIMUM_NUMBER_OF_SCSIPORT_OBJECTS];

extern PREAD_CAPACITY_DATA ReadCapacityBuffer;
extern PUCHAR SenseInfoBuffer;

//
// Support routine.
//

PIRP
InitializeIrp(
   PFULL_SCSI_REQUEST_BLOCK FullSrb,
   CCHAR MajorFunction,
   PVOID DeviceObject,
   PVOID BufferPointer,
   ULONG BufferSize
   );


ARC_STATUS
GetAdapterCapabilities(
    IN PDEVICE_OBJECT PortDeviceObject,
    OUT PIO_SCSI_CAPABILITIES *PortCapabilities
    );

ARC_STATUS
GetInquiryData(
    IN PDEVICE_OBJECT PortDeviceObject,
    IN PSCSI_CONFIGURATION_INFO *ConfigInfo
    );

ARC_STATUS
ReadDriveCapacity(
    IN PPARTITION_CONTEXT PartitionContext
    );

ARC_STATUS
ScsiClassIoComplete(
    IN PPARTITION_CONTEXT PartitionContext,
    IN PIRP Irp,
    IN PVOID Context
    );

ARC_STATUS
SendSrbSynchronous(
        PPARTITION_CONTEXT PartitionContext,
        PSCSI_REQUEST_BLOCK Srb,
        PVOID BufferAddress,
        ULONG BufferLength,
        BOOLEAN WriteToDevice
        );

BOOLEAN
InterpretSenseInfo(
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT ARC_STATUS *Status,
    PPARTITION_CONTEXT PartitionContext
    );

VOID
RetryRequest(
    PPARTITION_CONTEXT PartitionContext,
    PIRP Irp
    );

PIRP
BuildRequest(
    IN PPARTITION_CONTEXT PartitionContext,
    IN PMDL Mdl,
    IN ULONG LogicalBlockAddress,
    IN BOOLEAN Operation
    );


//
// Define the necessary functions to simulate the I/O environment.
//

#define ExAllocatePool(Type, Size) FwAllocatePool(Size)

#if !defined(_MIPS_) && !defined(_ALPHA_) && !defined(_PPC_)
#define PAUSE while (!GET_KEY());

typedef struct _DRIVER_LOOKUP_ENTRY {
    PCHAR                    DevicePath;
    PBL_DEVICE_ENTRY_TABLE   DispatchTable;
} DRIVER_LOOKUP_ENTRY, *PDRIVER_LOOKUP_ENTRY;
#undef ASSERT
#define ASSERT( exp ) { \
    if (!(#exp)) {         \
        BlPrint("ASSERT File: %s line: %lx\n", __FILE__, __LINE__); \
    PAUSE; \
    }   \
}

VOID
ScsiPortExecute(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#endif

#if defined ExFreePool
#undef ExFreePool
#endif
#define ExFreePool(Size)

#ifdef IoCallDriver
#undef IoCallDriver
#endif
#define IoCallDriver(DeviceObject, Irp) (       \
    DeviceObject->CurrentIrp = Irp,             \
    Irp->Tail.Overlay.CurrentStackLocation--,   \
    ScsiPortExecute(DeviceObject, Irp),         \
    Irp->Tail.Overlay.CurrentStackLocation++ )
#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif
#define IoCompleteRequest(Irp, Boost) Irp->PendingReturned = FALSE
#define IoAllocateErrorLogEntry(DeviceObject, Length) NULL
#define IoWriteErrorLogEntry(Entry)
#ifdef KeAcquireSpinLock
#undef KeAcquireSpinLock
#endif
#define KeAcquireSpinLock(Lock, Irql)
#ifdef KeReleaseSpinLock
#undef KeReleaseSpinLock
#endif
#define KeReleaseSpinLock(Lock, Irql)
#define KiAcquireSpinLock(Lock)
#ifdef KiReleaseSpinLock
#undef KiReleaseSpinLock
#endif
#define KiReleaseSpinLock(Lock)
#define KeSynchronizeExecution(InterruptObject, ExecutionRoutine, Context) \
    (ExecutionRoutine)(Context)

#ifdef KeRaiseIrql
#undef KeRaiseIrql
#endif
#define KeRaiseIrql(NewLevel, OldLevel)
#ifdef KeLowerIrql
#undef KeLowerIrql
#endif
#define KeLowerIrql(Level)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\vmode.h ===
#ifndef __VMODE_H__

#include "bldr.h"

#define TXT_MOD 0x3
#define GFX_MOD 0x12
#define SET_VMODE(x) HW_CURSOR(0x80000000,x)

void DummyDebugDelay (VOID);
VOID BlRedrawGfxProgressBar(VOID);	//	Redraws the progress bar (with the last percentage) 
VOID BlUpdateGfxProgressBar(ULONG fPercentage);
VOID LoadBootLogoBitmap (IN ULONG DriveId, PCHAR path);	//	Loads ntldr bitmap and initializes
VOID DrawBitmap (VOID);
VOID PaletteOff (VOID);
VOID PaletteOn (VOID);
VOID PrepareGfxProgressBar (VOID);
VOID VgaEnableVideo();

extern BOOLEAN DisplayLogoOnBoot;
extern BOOLEAN GraphicsMode;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\tftp_api.h ===
/*
 * Modifications:   $Header:   W:/LCS/ARCHIVES/preboot/lsa2/inc/tftp_api.h_v   1.15   Apr 09 1997 21:27:50   vprabhax  $
 *
 * Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

/* TFTP_API.H
 *	Parameter structure and type definitions for TFTP API version 2.x
 *
 *	PXENV.H needs to be #included before this file.
 *
 *	None of the TFTP API services are available after the stack
 *	has been unloaded.
 */

#ifndef _TFTP_API_H
#define _TFTP_API_H


#include "pxe_cmn.h"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* #defines and constants
 */

/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a TFTP API service.
 */
#define PXENV_TFTP_OPEN			0x20
#define PXENV_TFTP_CLOSE		0x21
#define PXENV_TFTP_READ			0x22
#define PXENV_TFTP_READ_FILE	0x23


/* Definitions of TFTP API parameter structures.
 */

typedef struct s_PXENV_TFTP_OPEN {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT8 ServerIPAddress[4]; 	/* In: 32-bit server IP */
					/*     address. Big-endian. */
	UINT8 GatewayIPAddress[4]; 	/* In: 32-bit gateway IP */
					/*     address. Big-endian. */
	UINT8 FileName[128];		
	UINT16 TFTPPort; 		/* In: Socket endpoint at */
					/*     which the TFTP server is */
					/*     listening to requests. */
					/*     Big-endian. */
} t_PXENV_TFTP_OPEN;


typedef struct s_PXENV_TFTP_CLOSE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
} t_PXENV_TFTP_CLOSE;


typedef struct s_PXENV_TFTP_READ {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT16 PacketNumber;		/* Out: 16-bit packet number. */
	UINT16 BufferSize;		/* In: Size of the receive */
					/*     buffer in bytes. */
					/* Out: Size of the packet */
					/*      written into the buffer. */
	UINT16 BufferOffset;		/* In: Segment/Selector and */
	UINT16 BufferSegment;		/*     offset of the receive buffer. */
					/* Out: Unchanged */
} t_PXENV_TFTP_READ;

#include <pshpack2.h>

typedef struct s_PXENV_TFTP_READ_FILE {
	UINT16 Status;			/* Out: See PXENV_STATUS_xxx */
					/*      constants. */
	UINT8 FileName[128];		/* In: file to be read */
	UINT32 BufferSize;		/* In: Size of the receive */
					/*     buffer in bytes. */
					/* Out: Size of the file */
					/*      written into the buffer. */
	UINT32 BufferOffset;		/* In: 32-bit physical address of the */
					/*     buffer to load the file into. */
	UINT8 ServerIPAddress[4]; 	/* In: 32-bit server IP */
					/*     address. Big-endian. */
	UINT8 GatewayIPAddress[4]; 	/* In: 32-bit gateway IP */
					/*     address. Big-endian. */
	UINT8 McastIPAddress[4]; 	/* In: 32-bit multicast IP address */
					/*     on which file can be received */
					/*     can be null for unicast */
	UINT16 TFTPClntPort; 		/* In: Socket endpoint on the Client */
					/*     at which the file can be */
					/*     received in case of Multicast */
	UINT16 TFTPSrvPort; 		/* In: Socket endpoint at which */
					/*     server listens for requests. */
	UINT16 TFTPOpenTimeOut;		/* In: Timeout value in seconds to be */
					/*     used for receiving data or ACK */
					/*     packets.  If zero, default */
					/*     TFTP-timeout is used. */
	UINT16 TFTPReopenDelay;		/* In: wait time in seconds to delay */
					/*     a reopen request in case of */
					/*     multicast. */
} t_PXENV_TFTP_READ_FILE;

#include <poppack.h>

/* Note:
	If the McastIPAddress specifies a non-zero value, the TFTP_ReadFile call
	tries to listen for multicast packets on the TFTPClntPort before
	opening a TFTP/MTFTP connection to the server.
	If it receives any packets (and not all) or if does not receive any,
	it waits for specified time and tries to reopen a multicast connection
	to the server.
	If the server supports multicast, it notifies the acknowledging client
	with a unicast and starts sending (multicast) the file.
	If the multicast open request times out, the client tries to connect to
	the server at TFTP server port for a unicast transfer.
*/


#endif /* _TFTP_API_H */

/* EOF - $Workfile:   tftp_api.h  $ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kd1394\kd1394.c ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    kd1394.c

Abstract:

    1394 Kernel Debugger DLL

Author:

    George Chrysanthakopoulos (georgioc) Feb-2000

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

#define _KD1394_C
#include "pch.h"
#undef _KD1394_C

BOOLEAN
Kd1394pInitialize(
    IN PDEBUG_1394_PARAMETERS   DebugParameters,
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    )
/*++

Routine Description:

    This routine enumerates the bus controller of DebugParameters.BusType, using
    the appropriate ClassCode (generic enumeration). If PCI addressing info was
    found on the Options String passed by the Loader, will use this and go directly
    to that bus number, slot, function to setup that controller.

Arguments:

    DebugParameters - Supplies Debug parameters parsed from Options string

    LoaderBlock - Supplies a pointer to the LOADER_PARAMETER_BLOCK passed
                  in from the OS Loader.

Return Value:

    None.

--*/
{
    NTSTATUS    ntStatus;
    ULONG       maxPhys;

    //
    // Find the controller, setup the PCI registers for it
    // and do bus specific initialization
    //
    DebugParameters->DbgDeviceDescriptor.Memory.Length = sizeof(DEBUG_1394_DATA);

    ntStatus = KdSetupPciDeviceForDebugging( LoaderBlock,
                                             &DebugParameters->DbgDeviceDescriptor
                                             );
    if (!NT_SUCCESS(ntStatus)) {

        return(FALSE);
    }

    Kd1394Data = DebugParameters->DbgDeviceDescriptor.Memory.VirtualAddress;
    RtlZeroMemory(Kd1394Data, sizeof(DEBUG_1394_DATA));

    return(Dbg1394_InitializeController(Kd1394Data, DebugParameters));
} // Kd1394pInitialize

NTSTATUS
KdD0Transition(
    void
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API after it
    processes a D0 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    LOADER_PARAMETER_BLOCK  LoaderBlock = {0};

    // see if we need to activate the debugger
    if (Kd1394Parameters.DebuggerActive == FALSE) {

        if (Kd1394pInitialize(&Kd1394Parameters, &LoaderBlock)) {

            Kd1394Parameters.DebuggerActive = TRUE;
        }            
    }        

    return(STATUS_SUCCESS);
} // KdD0Transition

NTSTATUS
KdD3Transition(
    void
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API before it
    processes a D3 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    Kd1394Parameters.DebuggerActive = FALSE;
    return(STATUS_SUCCESS);
} // KdD3Transition

NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to parse the boot.ini strings and
    perform any initialization.  It cannot be assumed that the entire NT
    kernel has been initialized at this time.  Memory management services,
    for example, will not be available.  After this call has returned, the
    debugger DLL may receive requests to send and receive packets.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    NTSTATUS                    ntStatus = STATUS_UNSUCCESSFUL;
    PCHAR                       Options;
    PCHAR                       BusParametersOption;
    PCHAR                       ChannelOption;
    PCHAR                       BusOption;
    PCI_SLOT_NUMBER             slotNumber;
    PDEBUG_DEVICE_DESCRIPTOR    DbgDeviceDescriptor = &Kd1394Parameters.DbgDeviceDescriptor;

    // first time is called with valid LoaderBlock
    if (LoaderBlock != NULL) {

        // set the debugger as inactive
        Kd1394Parameters.DebuggerActive = FALSE;

        if (LoaderBlock->LoadOptions != NULL) {

            Options = LoaderBlock->LoadOptions;
            _strupr(Options);

            // retrieve the channel number
            // CHANGE: this is actually an instance id and should be changed.
            ChannelOption = strstr(Options, CHANNEL_OPTION);

            if (ChannelOption) {

                ChannelOption += strlen(CHANNEL_OPTION);
                while (*ChannelOption == ' ') {
                    ChannelOption++;
                }

                if (*ChannelOption != '\0') {
                    Kd1394Parameters.Id = atol(ChannelOption + 1);
                }
            }
            else {

                // default to channel 0 - there should be no default???
                Kd1394Parameters.Id = 0;
            }

            // set vendor/class
            DbgDeviceDescriptor->VendorID = -1;
            DbgDeviceDescriptor->DeviceID = -1;
            DbgDeviceDescriptor->BaseClass = PCI_CLASS_SERIAL_BUS_CTLR;
            DbgDeviceDescriptor->SubClass = PCI_SUBCLASS_SB_IEEE1394;

            // support only ohci controllers
            DbgDeviceDescriptor->ProgIf = 0x10; 
            DbgDeviceDescriptor->Bus = -1;
            DbgDeviceDescriptor->Slot = -1;

            // now find PCI addressing information
            BusParametersOption = strstr(Options, BUSPARAMETERS_OPTION);

            if (BusParametersOption) {

                do {

                    BusParametersOption += strlen(BUSPARAMETERS_OPTION);
                    while (*BusParametersOption == ' ') {
                        BusParametersOption++;
                    }

                    // first get the pci bus number
                    if ((*BusParametersOption != '\0')) {

                        DbgDeviceDescriptor->Bus = atol(BusParametersOption+1);
                    }
                    else {

                        break;
                    }

                    // now find the device number
                    while ((*BusParametersOption != '.') && (*BusParametersOption != '\0')) {
                        BusParametersOption++;
                    }

                    if ((*BusParametersOption != '\0')) {

                        slotNumber.u.AsULONG = 0;
                        slotNumber.u.bits.DeviceNumber = atol(++BusParametersOption);
                    }
                    else {

                        break;
                    }

                    // now find the function number
                    while ((*BusParametersOption != '.') && (*BusParametersOption != '\0')) {
                        BusParametersOption++;
                    }

                    if ((*BusParametersOption != '\0')) {

                        slotNumber.u.bits.FunctionNumber = atol(BusParametersOption+1);
                    }
                    else {

                        break;
                    }

                    DbgDeviceDescriptor->Slot = slotNumber.u.AsULONG;

                } while (FALSE);
            }

            // see if the nobus flag is set
            BusOption = strstr(Options, BUS_OPTION);

            if (BusOption) {

                Kd1394Parameters.NoBus = TRUE;
            }
            else {

                Kd1394Parameters.NoBus = FALSE;
            }

            // find and configure the pci controller and do 1394 specific init
            if (Kd1394pInitialize(&Kd1394Parameters, LoaderBlock)) {

                Kd1394Parameters.DebuggerActive = TRUE;
                ntStatus = STATUS_SUCCESS;
            }
        }

        // hmmm...what happens if LoaderBlock->LoadOptions == NULL??
    }
    else {

        ntStatus = STATUS_SUCCESS;
    }

    return(ntStatus);
} // KdDebuggerInitialize0

NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to do any initialization that it needs
    to do after the NT kernel services are available.  Mm and registry APIs
    will be guaranteed to be available at this time.  If the specific
    debugger DLL implementation uses a PCI device, it will set a registry
    key (discussed later) that notifies the PCI driver that a specific PCI
    device is being used for debugging.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    WCHAR                           Buffer[16];
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  UnicodeString;
    HANDLE                          BaseHandle = NULL;
    HANDLE                          Handle = NULL;
    ULONG                           disposition, i;
    ULONG                           ulLength, ulResult;
    NTSTATUS                        ntStatus;
    PHYSICAL_ADDRESS                physAddr;
    ULONG                           BusNumber;
    ULONG                           SlotNumber;
    PKEY_VALUE_PARTIAL_INFORMATION  PartialInfo;

    // make sure we are active, if not, exit
    if (Kd1394Parameters.DebuggerActive == FALSE) {

        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Open PCI Debug service key.
    //
    RtlInitUnicodeString( &UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\PCI\\DEBUG"
                          );

    InitializeObjectAttributes( &ObjectAttributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR)NULL
                                );

    ntStatus = ZwOpenKey(&BaseHandle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(ntStatus)) {

        return(STATUS_SUCCESS);
    }

    for (i=0; i<MAX_DEBUGGING_DEVICES_SUPPORTED; i++) {

        swprintf(Buffer, L"%d", i);

        RtlInitUnicodeString(&UnicodeString, Buffer);

        InitializeObjectAttributes( &ObjectAttributes,
                                    &UnicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    BaseHandle,
                                    (PSECURITY_DESCRIPTOR)NULL
                                    );

        ntStatus = ZwOpenKey(&Handle, KEY_READ, &ObjectAttributes);

        if (NT_SUCCESS(ntStatus)) {

            ulLength = sizeof(KEY_VALUE_FULL_INFORMATION)+sizeof(ULONG);
            PartialInfo = ExAllocatePoolWithTag(NonPagedPool, ulLength, '31kd');

            if (PartialInfo == NULL) {

                ZwClose(Handle);
                continue;
            }

            RtlInitUnicodeString (&UnicodeString, L"Bus");

            ntStatus = ZwQueryValueKey( Handle,
                                        &UnicodeString,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        ulLength,
                                        &ulResult
                                        );

            if (NT_SUCCESS(ntStatus)) {

                RtlCopyMemory(&BusNumber, &PartialInfo->Data, sizeof(ULONG));
            }

            RtlInitUnicodeString (&UnicodeString, L"Slot");

            ntStatus = ZwQueryValueKey( Handle,
                                        &UnicodeString,
                                        KeyValuePartialInformation,
                                        PartialInfo,
                                        ulLength,
                                        &ulResult
                                        );

            if (NT_SUCCESS(ntStatus)) {

                RtlCopyMemory(&SlotNumber, &PartialInfo->Data, sizeof(ULONG));
            }

            ExFreePool(PartialInfo);

            if ((Kd1394Parameters.DbgDeviceDescriptor.Bus == BusNumber) &&
                (Kd1394Parameters.DbgDeviceDescriptor.Slot == SlotNumber)) {

                // we found our instance, let's add our keys...
                physAddr = MmGetPhysicalAddress(&Kd1394Data->Config);

                RtlInitUnicodeString (&UnicodeString, L"DebugAddress");

                ntStatus = ZwSetValueKey( Handle,
                                          &UnicodeString,
                                          0,
                                          REG_QWORD,
                                          &physAddr,
                                          sizeof(ULARGE_INTEGER)
                                          );

                RtlInitUnicodeString (&UnicodeString, L"NoBus");

                ntStatus = ZwSetValueKey( Handle,
                                          &UnicodeString,
                                          0,
                                          REG_DWORD,
                                          &Kd1394Parameters.NoBus,
                                          sizeof(ULONG)
                                          );
            }

            ZwClose(Handle);
        }
    }

    ZwClose(BaseHandle);

    return(STATUS_SUCCESS);
} // KdDebuggerInitialize1

NTSTATUS
KdSave(
    IN BOOLEAN  KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as late as possible before putting the
    machine to sleep.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return(STATUS_SUCCESS);
} // KdSave

NTSTATUS
KdRestore(
    IN BOOLEAN  KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as early as possible after resuming from a
    sleep state.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return(STATUS_SUCCESS);
} // KdRestore
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\inc\undi_api.h ===
#ifndef _UNDI_API_H
#define _UNDI_API_H


#include "pxe_cmn.h"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* #defines and constants
 */

/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call an UNDI API service.
 */
#define PXENV_UNDI_SHUTDOWN     0x05
#define PXENV_UNDI_OPEN			0x06
#define PXENV_UNDI_CLOSE		0x07
#define PXENV_UNDI_SET_PACKET_FILTER 0x0B
#define PXENV_UNDI_GET_NIC_TYPE	0x12
#define PXENV_UNDI_GET_INFORMATION	0x000C

#define ADDR_LEN 16
#define MAXNUM_MCADDR 8


typedef struct s_PXENV_UNDI_MCAST_ADDR {
	UINT16 MCastAddrCount;
    UINT8 MCastAddr[MAXNUM_MCADDR][ADDR_LEN];
} t_PXENV_UNDI_MCAST_ADDR;


typedef struct s_PXENV_UNDI_SHUTDOWN {
	UINT16 Status;
} t_PXENV_UNDI_SHUTDOWN;

typedef struct s_PXENV_UNDI_OPEN {
	UINT16 Status;
    UINT16 OpenFlag;
    UINT16 PktFilter;
    t_PXENV_UNDI_MCAST_ADDR McastBuffer;
} t_PXENV_UNDI_OPEN;

#define FLTR_DIRECTED 0x0001
#define FLTR_BRDCST   0x0002
#define FLTR_PRMSCS   0x0004
#define FLTR_SRC_RTG  0x0008

typedef struct s_PXENV_UNDI_SET_PACKET_FILTER {
    UINT16 Status;
    UINT8 filter;
} t_PXENV_UNDI_SET_PACKET_FILTER;

typedef struct s_PXENV_UNDI_CLOSE {
	UINT16 Status;
} t_PXENV_UNDI_CLOSE;

#include <pshpack1.h>

typedef struct s_PXENV_UNDI_GET_NIC_TYPE {
    UINT16 Status;  /* OUT: See PXENV_STATUS_xxx constants */
    UINT8 NicType;  /* OUT: 2=PCI, 3=PnP */
    union{
        struct{
            UINT16 Vendor_ID;   /* OUT:  */
            UINT16 Dev_ID;  /* OUT:  */
            UINT8 Base_Class;   /* OUT: */
            UINT8 Sub_Class;    /* OUT: */
            UINT8 Prog_Intf;    /* OUT: program interface */
            UINT8 Rev;  /* OUT: Revision number */
            UINT16 BusDevFunc;  /* OUT: Bus, Device */
            UINT32 Subsys_ID;   /* OUT: Subsystem ID */
            /* & Function numbers */
        }pci;
        struct{
            UINT32 EISA_Dev_ID; /* Out:  */
            UINT8 Base_Class;   /* OUT: */
            UINT8 Sub_Class;    /* OUT: */
            UINT8 Prog_Intf;    /* OUT: program interface */
            UINT16 CardSelNum;  /* OUT: Card Selector Number */
        }pnp;
    }pci_pnp_info;

} t_PXENV_UNDI_GET_NIC_TYPE;


typedef struct s_PXENV_UNDI_GET_INFORMATION {
	UINT16 Status;			/* Out: PXENV_STATUS_xxx */
	UINT16 BaseIo;			/* Out: Adapter's Base IO */
	UINT16 IntNumber;		/* Out: IRQ number */
	UINT16 MaxTranUnit;		/* Out: MTU	*/
	UINT16  HwType;			/* Out: type of protocol at hardware level */

#define ETHER_TYPE	1
#define EXP_ETHER_TYPE	2
#define IEEE_TYPE	6
#define ARCNET_TYPE	7

    /*  other numbers can  be obtained from  rfc1010 for "Assigned
    Numbers".  This number may not be validated by the application
    and hence adding new numbers to the list should be fine at any
    time.  */

	UINT16 HwAddrLen;		/* Out: actual length of hardware address */
	UINT8 CurrentNodeAddress[ADDR_LEN]; /* Out: Current hardware address*/
	UINT8 PermNodeAddress[ADDR_LEN]; /* Out: Permanent hardware address*/
	UINT16 ROMAddress;		/* Out: ROM address */
	UINT16 RxBufCt;			/* Out: receive Queue length	*/
	UINT16 TxBufCt;			/* Out: Transmit Queue length */
} t_PXENV_UNDI_GET_INFORMATION;



#include <poppack.h>

#endif /* _UNDI_API_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kd1394\pch.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    1394 Kernel Debugger DLL

Author:

    Peter Binder (pbinder)

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/21/2001 pbinder   having fun...
--*/

#include "nthal.h"
#include "kdbg1394.h"

#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "stdlib.h"
#include "kddll.h"
#include "stdio.h"
#include "pci.h"
#include "ohci1394.h"
#include "kd1394.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kd1394\ohci1394.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ohci1394.h

Abstract:

    1394 Kernel Debugger DLL

Author:

    George Chrysanthakopoulos (georgioc) 31-October-1999

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

//
// Various OHCI definitions
//

#define min(a,b)                            (((a) < (b)) ? (a) : (b))
#define max(a,b)                            (((a) > (b)) ? (a) : (b))

#define PHY_CABLE_POWER_STATUS              0x01        // CPS @ Address 0
#define PHY_LOCAL_NODE_ROOT                 0x02        // R @ Address 0
#define PHY_PHYSICAL_ID_MASK                0xFC        // Physical ID @ Address 0

#define PHY_ROOT_HOLD_OFF_BIT               0x80        // RHB @ Address 1
#define PHY_INITIATE_BUS_RESET              0x40        // IBR @ Address 1
#define PHY_MAX_GAP_COUNT                   0x3f        // GC  @ Address 1

#define OHCI_REGISTER_MAP_SIZE              0x800
#define OHCI_SELFID_BUFFER_SZ               2048
#define OHCI_CONFIG_ROM_SIZE                1024

#define OHCI_SELFID_DELAY                   0
#define OHCI_SELFID_POWER_CLASS             4

//
// IntEvent OHCI Register Bit Masks
//
#define MASTER_INT_ENABLE                   0x80000000
#define VENDOR_SPECIFIC_INT                 0x40000000
#define PHY_REG_RECEIVED_INT                0x04000000
#define CYCLE_TOO_LONG_INT                  0x02000000
#define UNRECOVERABLE_ERROR_INT             0x01000000
#define CYCLE_INCONSISTENT_INT              0x00800000
#define CYCLE_LOST_INT                      0x00400000
#define CYCLE_64_SECS_INT                   0x00200000
#define CYCLE_SYNCH_INT                     0x00100000
#define PHY_INT                             0x00080000
#define PHY_BUS_RESET_INT                   0x00020000
#define SELF_ID_COMPLETE_INT                0x00010000
#define LOCK_RESP_ERR_INT                   0x00000200
#define POSTED_WRITE_ERR_INT                0x00000100
#define ISOCH_RX_INT                        0x00000080
#define ISOCH_TX_INT                        0x00000040
#define RSPKT_INT                           0x00000020
#define RQPKT_INT                           0x00000010
#define ARRS_INT                            0x00000008
#define ARRQ_INT                            0x00000004
#define RESP_TX_COMPLETE_INT                0x00000002
#define REQ_TX_COMPLETE_INT                 0x00000001


#define USED_INT_MASK               (RESP_TX_COMPLETE_INT | REQ_TX_COMPLETE_INT | RSPKT_INT | RQPKT_INT |       \
                                     ISOCH_RX_INT | ISOCH_TX_INT | PHY_BUS_RESET_INT | SELF_ID_COMPLETE_INT |   \
                                     MASTER_INT_ENABLE | CYCLE_TOO_LONG_INT | CYCLE_INCONSISTENT_INT)

//
// DMA Async Context numbers
//
#define AT_REQ_DMA_CONTEXT                  0
#define AT_RSP_DMA_CONTEXT                  1
#define AR_REQ_DMA_CONTEXT                  2
#define AR_RSP_DMA_CONTEXT                  3
#define NUM_DMA_CONTEXTS                    4

//
// DMA Context Commands
//
#define OUTPUT_MORE_CMD                     0
#define OUTPUT_MORE_IMMEDIATE_CMD           0
#define OUTPUT_LAST_CMD                     1
#define OUTPUT_LAST_IMMEDIATE_CMD           1
#define INPUT_MORE_CMD                      2
#define INPUT_LAST_CMD                      3
#define STORE_VALUE_CMD                     8

//
// DMA context descriptor header values
//
#define DESC_KEY                            0
#define DESC_IMMEDIATE_KEY                  2

#define DESC_INPUT_MORE_IMM_BRANCH_CONTROL  0
#define DESC_OUT_MORE_BRANCH_CONTROL        0
#define DESC_OUT_LAST_BRANCH_CONTROL        3
#define DESC_INPUT_MORE_BRANCH_CONTROL      3
#define DESC_INPUT_LAST_BRANCH_CONTROL      3

#define DESC_WAIT_CONTROL_ON                3
#define DESC_WAIT_CONTROL_OFF               0

#define DESC_GENERATE_INT                   3
#define DESC_NO_INT                         0

//
// command descriptors XfreStatus field masks
//
#define DESC_XFER_STATUS_ACTIVE             0x0400
#define DESC_XFER_STATUS_DEAD               0x0800

//
// OHCI EVENT CODEs
//
#define OHCI_EVT_MISSING_ACK                0x03
#define OHCI_EVT_UNDERRUN                   0x04
#define OHCI_EVT_OVERRUN                    0x05
#define OHCI_EVT_TIMEOUT                    0x0a
#define OHCI_EVT_FLUSHED                    0x0F
#define OHCI_EVT_BUS_RESET                  0x09

//
// each packet must have up to 7 fragments ( including first and last descriptors)
//
#define MAX_OHCI_COMMAND_DESCRIPTOR_BLOCKS  8

//
// max buffer size one cmd descriptor can address
//
#define MAX_CMD_DESC_DATA_LENGTH            65535

//
// OHCI Register definitions
//
typedef struct _VERSION_REGISTER {

        ULONG       Revision:8;             // bits 0-7
        ULONG       Reserved:8;             // bits 8-15
        ULONG       Version:8;              // bits 16-23
        ULONG       GUID_ROM:1;             // bit 24
        ULONG       Reserved1:7;            // bits 25-31

} VERSION_REGISTER, *PVERSION_REGISTER;

typedef struct _VENDOR_ID_REGISTER {

        ULONG       VendorCompanyId:24;     // Bits 0-23
        ULONG       VendorUnique:8;         // Bits 24-31

} VENDOR_ID_REGISTER, *PVENDOR_ID_REGISTER;

typedef struct _GUID_ROM_REGISTER {

        ULONG       Reserved0:16;           // bits 0-15
        ULONG       RdData:8;               // bits 16-23
        ULONG       Reserved1:1;            // bit 24
        ULONG       RdStart:1;              // bit 25
        ULONG       Reserved2:5;            // bits 26-30
        ULONG       AddrReset:1;            // bits 31

} GUID_ROM_REGISTER, *PGUID_ROM_REGISTER;

typedef struct _AT_RETRIES_REGISTER {

        ULONG       MaxATReqRetries:4;      // bits 0-3
        ULONG       MaxATRespRetries:4;     // bits 4-7
        ULONG       MaxPhysRespRetries:4;   // bits 8-11
        ULONG       Reserved:4;             // bits 12-15
        ULONG       CycleLimit:13;          // bits 16-28
        ULONG       SecondLimit:3;          // bits 29-31

} AT_RETRIES_REGISTER, *PAT_RETRIES_REGISTER;

typedef struct _CSR_CONTROL_REGISTER {

        ULONG       CsrSel:2;               // bits 0-1
        ULONG       Reserved:29;            // bits 2-30;
        ULONG       CsrDone:1;              // bit 31

} CSR_CONTROL_REGISTER, *PCSR_CONTROL_REGISTER;

typedef struct _CONFIG_ROM_HEADER_REGISTER {

        ULONG       Rom_crc_value:16;       // bits 0-15
        ULONG       Crc_length:8;           // bits 16-23
        ULONG       Info_length:8;          // bits 24-31

} CONFIG_ROM_HEADER_REGISTER, *PCONFIG_ROM_HEADER_REGISTER;

typedef struct _BUS_OPTIONS_REGISTER {

        ULONG       Link_spd:3;             // bits 0-2
        ULONG       Reserved0:3;            // bits 3-5
        ULONG       g:2;                    // bits 6-7
        ULONG       Reserved1:4;            // bits 8-11
        ULONG       Max_rec:4;              // bits 12-15
        ULONG       Cyc_clk_acc:8;          // bits 16-23
        ULONG       Reserved2:3;            // bits 24-26
        ULONG       Pmc:1;                  // bit 27
        ULONG       Bmc:1;                  // bit 28
        ULONG       Isc:1;                  // bit 29
        ULONG       Cmc:1;                  // bit 30
        ULONG       Irmc:1;                 // bit 31

} BUS_OPTIONS_REGISTER, *PBUS_OPTIONS_REGISTER;

typedef struct _HC_CONTROL_REGISTER {

        ULONG       Reserved:16;            // Bit 0-15
        ULONG       SoftReset:1;            // Bit 16
        ULONG       LinkEnable:1;           // Bit 17
        ULONG       PostedWriteEnable:1;    // Bit 18
        ULONG       Lps:1;                  // bit 19
        ULONG       Reserved2:2;            // Bits 20-21
        ULONG       APhyEnhanceEnable:1;    // bit 22
        ULONG       ProgramPhyEnable:1;     // bit 23
        ULONG       Reserved3:6;            // bits 24-29
        ULONG       NoByteSwapData:1;       // Bit 30
        ULONG       Reserved4:1;            // Bit 31

} HC_CONTROL_REGISTER, *PHC_CONTROL_REGISTER;

typedef struct _FAIRNESS_CONTROL_REGISTER {

    ULONG       Pri_req:8;                  // Bits 0-7
    ULONG       Reserved0:24;                // Bit 8-31

} FAIRNESS_CONTROL_REGISTER;

typedef struct _LINK_CONTROL_REGISTER {

        ULONG       Reserved0:4;            // Bits 0-3
        ULONG       CycleSyncLReqEnable:1;  // Bit 4
        ULONG       Reserved1:4;            // Bits 5-8
        ULONG       RcvSelfId:1;            // Bit 9
        ULONG       RcvPhyPkt:1;            // Bit 10
        ULONG       Reserved2:9;            // Bits 11-19
        ULONG       CycleTimerEnable:1;     // Bit 20
        ULONG       CycleMaster:1;          // Bit 21
        ULONG       CycleSource:1;          // Bit 22
        ULONG       Reserved3:9;            // Bits 23-31

} LINK_CONTROL_REGISTER, *PLINK_CONTROL_REGISTER;

typedef struct _NODE_ID_REGISTER {
        ULONG       NodeId:6;               // Bits 0-5
        ULONG       BusId:10;               // Bits 6-15
        ULONG       Reserved1:11;           // Bits 16-26;
        ULONG       Cps:1;                  // Bit  27;
        ULONG       Reserved2:2;            // Bits 28-29
        ULONG       Root:1;                 // Bit  30
        ULONG       IdValid:1;              // Bit  31

} NODE_ID_REGISTER, *PNODE_ID_REGISTER;

typedef struct _SELF_ID_BUFFER_REGISTER {
        union {

            ULONG   SelfIdBufferPointer;

            struct {
                ULONG   Reserved0:11;       // bits 0-10
                ULONG   SelfIdBuffer:21;    // Bits 11-32
            } bits; 

        } u;

} SELF_ID_BUFFER_REGISTER, *PSELF_ID_BUFFER_REGISTER;

typedef struct _SELF_ID_COUNT_REGISTER {

        ULONG       Reserved0:2;            // bits 0-1
        ULONG       SelfIdSize:11;          // Bits 2-12
        ULONG       Reserved1:3;            // bits 13-15
        ULONG       SelfIdGeneration:8;     // bits 16-23
        ULONG       Reserved2:7;            // bits 24-30
        ULONG       SelfIdError:1;          // bit 31

} SELF_ID_COUNT_REGISTER, *PSELF_ID_COUNT_REGISTER;

typedef struct _PHY_CONTROL_REGISTER {

    ULONG   WrData:8;                       // bits 0-7
    ULONG   RegAddr:4;                      // bits 8-11
    ULONG   Reserved0:2;                    // bits 12-13
    ULONG   WrReg:1;                        // bit 14
    ULONG   RdReg:1;                        // bit 15
    ULONG   RdData:8;                       // bits 16-23
    ULONG   RdAddr:4;                       // bits 24-27
    ULONG   Reserved1:3;                    // bits 28-30
    ULONG   RdDone:1;                       // bit 31

} PHY_CONTROL_REGISTER, *PPHY_CONTROL_REGISTER;

typedef struct _ISOCH_CYCLE_TIMER_REGISTER {

    ULONG   CycleOffset:12;                 // bits 0-11
    ULONG   CycleCount:13;                  // bits 12-24
    ULONG   CycleSeconds:7;                 // bits 25-31

} ISOCH_CYCLE_TIMER_REGISTER, *PISOCH_CYCLE_TIMER_REGISTER;

typedef struct _INT_EVENT_MASK_REGISTER {
        ULONG       ReqTxComplete:1;        // Bit 0
        ULONG       RspTxComplete:1;        // Bit 1
        ULONG       ARRQ:1;                 // Bit 2
        ULONG       ARRS:1;                 // Bit 3
        ULONG       RQPkt:1;                // Bit 4
        ULONG       RSPPkt:1;               // Bit 5
        ULONG       IsochTx:1;              // Bit 6
        ULONG       IsochRx:1;              // Bit 7
        ULONG       PostedWriteErr:1;       // Bit 8
        ULONG       LockRespErr:1;          // Bit 9
        ULONG       Reserved0:6;            // Bits 10-15
        ULONG       SelfIdComplete:1;       // Bit 16
        ULONG       BusReset:1;             // Bit 17
        ULONG       Reserved1:1;            // Bit 18
        ULONG       Phy:1;                  // Bit 19
        ULONG       CycleSynch:1;           // Bit 20
        ULONG       Cycle64Secs:1;          // Bit 21
        ULONG       CycleLost:1;            // Bit 22
        ULONG       CycleInconsistent:1;    // Bit 23
        ULONG       UnrecoverableError:1;   // Bit 24
        ULONG       CycleTooLong:1;         // Bit 25
        ULONG       PhyRegRcvd:1;           // Bit 26
        ULONG       Reserved2:3;            // Bits 27-29
        ULONG       VendorSpecific:1;       // Bit 30
        ULONG       MasterIntEnable:1;      // Bit 31
} INT_EVENT_MASK_REGISTER, *PINT_EVENT_MASK_REGISTER;


typedef struct COMMAND_POINTER_REGISTER {

        ULONG       Z:4;                    // bits 0-3
        ULONG       DescriptorAddr:28;      // bits 4-31

} COMMAND_POINTER_REGISTER, *PCOMMAND_POINTER_REGISTER;

typedef struct CONTEXT_CONTROL_REGISTER {

        ULONG       EventCode:5;            // bits 0-4
        ULONG       Spd:3;                  // bits 5-7
        ULONG       Reserved0:2;            // bits 8-9
        ULONG       Active:1;               // bit 10
        ULONG       Dead:1;                 // bit 11
        ULONG       Wake:1;                 // bit 12
        ULONG       Reserved1:2;            // bits 13-14
        ULONG       Run:1;                  // bit 15
        ULONG       Reserved2:16;           // bits 16-31

} CONTEXT_CONTROL_REGISTER, *PCONTEXT_CONTROL_REGISTER;

typedef struct IT_CONTEXT_CONTROL_REGISTER {

        ULONG       EventCode:5;            // bits 0-4
        ULONG       Spd:3;                  // bits 5-7
        ULONG       Reserved0:2;            // bits 8-9
        ULONG       Active:1;               // bit 10
        ULONG       Dead:1;                 // bit 11
        ULONG       Wake:1;                 // bit 12
        ULONG       Reserved1:2;            // bits 13-14
        ULONG       Run:1;                  // bit 15
        ULONG       CycleMatch:15;          // bits 16-30
        ULONG       CycleMatchEnable:1;     // bit 31

} IT_CONTEXT_CONTROL_REGISTER, *PIT_CONTEXT_CONTROL_REGISTER;

typedef struct IR_CONTEXT_CONTROL_REGISTER {

        ULONG       EventCode:5;            // bits 0-4
        ULONG       Spd:3;                  // bits 5-7
        ULONG       Reserved0:2;            // bits 8-9
        ULONG       Active:1;               // bit 10
        ULONG       Dead:1;                 // bit 11
        ULONG       Wake:1;                 // bit 12
        ULONG       Reserved1:2;            // bits 13-14
        ULONG       Run:1;                  // bit 15
        ULONG       CycleMatch:12;          // bits 16-27
        ULONG       MultiChanMode:1;        // bit 28
        ULONG       CycleMatchEnable:1;     // bit 29
        ULONG       IsochHeader:1;          // bit 30
        ULONG       BufferFill:1;           // bit 31

} IR_CONTEXT_CONTROL_REGISTER, *PIR_CONTEXT_CONTROL_REGISTER;

typedef struct _CONTEXT_MATCH_REGISTER {

        ULONG       ChannelNumber:6;        // bits 0-5
        ULONG       Reserved:1;             // bit 6
        ULONG       Tag1SyncFilter:1;       // bit 7
        ULONG       Sync:4;                 // bits 8-11
        ULONG       CycleMatch:13;          // bits 12-24
        ULONG       Reserved1:3;            // bits 25-27
        ULONG       Tag:4;                  // bit 28-31

} CONTEXT_MATCH_REGISTER, *PCONTEXT_MATCH_REGISTER;

typedef struct _DMA_CONTEXT_REGISTERS {

        CONTEXT_CONTROL_REGISTER    ContextControlSet; 
        CONTEXT_CONTROL_REGISTER    ContextControlClear;
        ULONG                       Reserved0[1];      
        COMMAND_POINTER_REGISTER    CommandPtr;   
        ULONG                       Reserved1[4]; 

} DMA_CONTEXT_REGISTERS, *PDMA_CONTEXT_REGISTERS;

typedef struct _DMA_ISOCH_RCV_CONTEXT_REGISTERS {

        IR_CONTEXT_CONTROL_REGISTER ContextControlSet; 
        IR_CONTEXT_CONTROL_REGISTER ContextControlClear;
        ULONG                       Reserved0[1];      
        COMMAND_POINTER_REGISTER    CommandPtr;   
        CONTEXT_MATCH_REGISTER      ContextMatch; 
        ULONG                       Reserved1[3];

} DMA_ISOCH_RCV_CONTEXT_REGISTERS, *PDMA_ISOCH_RCV_CONTEXT_REGISTERS;

typedef struct _DMA_ISOCH_XMIT_CONTEXT_REGISTERS {

        IT_CONTEXT_CONTROL_REGISTER ContextControlSet; 
        IT_CONTEXT_CONTROL_REGISTER ContextControlClear;
        ULONG                       Reserved0[1];      
        COMMAND_POINTER_REGISTER    CommandPtr;   

} DMA_ISOCH_XMIT_CONTEXT_REGISTERS, *PDMA_ISOCH_XMIT_CONTEXT_REGISTERS;

typedef struct _OHCI_REGISTER_MAP {

        VERSION_REGISTER            Version;                // @ 0
        GUID_ROM_REGISTER           GUID_ROM;               // @ 4
        AT_RETRIES_REGISTER         ATRetries;              // @ 8
        ULONG                       CsrData;                // @ C
        ULONG                       CsrCompare;             // @ 10
        CSR_CONTROL_REGISTER        CsrControl;             // @ 14
        CONFIG_ROM_HEADER_REGISTER  ConfigRomHeader;        // @ 18
        ULONG                       BusId;                  // @ 1C
        BUS_OPTIONS_REGISTER        BusOptions;             // @ 20
        ULONG                       GuidHi;                 // @ 24
        ULONG                       GuidLo;                 // @ 28
        ULONG                       Reserved0[2];           // @ 2C
        ULONG                       ConfigRomMap;           // @ 34

        ULONG                       PostedWriteAddressLo;   // @ 38
        ULONG                       PostedWriteAddressHi;   // @ 3C

        VENDOR_ID_REGISTER          VendorId;               // @ 40
        ULONG                       Reserved1[3];           // @ 44

        HC_CONTROL_REGISTER         HCControlSet;           // @ 50
        HC_CONTROL_REGISTER         HCControlClear;         // @ 54

        ULONG                       Reserved2[3];           // @ 58

        SELF_ID_BUFFER_REGISTER     SelfIdBufferPtr;        // @ 64
        SELF_ID_COUNT_REGISTER      SelfIdCount;            // @ 68

        ULONG                       Reserved3[1];           // @ 6C

        ULONG                       IRChannelMaskHiSet;     // @ 70
        ULONG                       IRChannelMaskHiClear;   // @ 74
        ULONG                       IRChannelMaskLoSet;     // @ 78
        ULONG                       IRChannelMaskLoClear;   // @ 7C

        INT_EVENT_MASK_REGISTER     IntEventSet;            // @ 80
        INT_EVENT_MASK_REGISTER     IntEventClear;          // @ 84

        INT_EVENT_MASK_REGISTER     IntMaskSet;             // @ 88
        INT_EVENT_MASK_REGISTER     IntMaskClear;           // @ 8C

        ULONG                       IsoXmitIntEventSet;     // @ 90
        ULONG                       IsoXmitIntEventClear;   // @ 94

        ULONG                       IsoXmitIntMaskSet;      // @ 98
        ULONG                       IsoXmitIntMaskClear;    // @ 9C

        ULONG                       IsoRecvIntEventSet;     // @ A0
        ULONG                       IsoRecvIntEventClear;   // @ A4

        ULONG                       IsoRecvIntMaskSet;      // @ A8
        ULONG                       IsoRecvIntMaskClear;    // @ AC

        ULONG                       Reserved4[11];          // @ B0

        FAIRNESS_CONTROL_REGISTER   FairnessControl;        // @ DC

        LINK_CONTROL_REGISTER       LinkControlSet;         // @ E0
        LINK_CONTROL_REGISTER       LinkControlClear;       // @ E4

        NODE_ID_REGISTER            NodeId;                 // @ E8
        PHY_CONTROL_REGISTER        PhyControl;             // @ EC

        ISOCH_CYCLE_TIMER_REGISTER  IsochCycleTimer;        // @ F0

        ULONG                       Reserved5[3];           // @ F4

        ULONG                       AsynchReqFilterHiSet;   // @ 100
        ULONG                       AsynchReqFilterHiClear; // @ 104

        ULONG                       AsynchReqFilterLoSet;   // @ 108
        ULONG                       AsynchReqFilterLoClear; // @ 10C

        ULONG                       PhyReqFilterHiSet;      // @ 110
        ULONG                       PhyReqFilterHiClear;    // @ 114

        ULONG                       PhyReqFilterLoSet;      // @ 118
        ULONG                       PhyReqFilterLoClear;    // @ 11C

        ULONG                       PhysicalUpperBound;     // @ 120
        ULONG                       Reserved6[23];          // @ 124

        DMA_CONTEXT_REGISTERS       AsynchContext[4];       // @ 180
        // ATRsp_Context;   // @ 1A0
        // ARReq_Context;   // @ 1C0
        // ARRsp_Context;   // @ 1E0

        DMA_ISOCH_XMIT_CONTEXT_REGISTERS IT_Context[32];    // @ 200

        DMA_ISOCH_RCV_CONTEXT_REGISTERS IR_Context[32];     // @ 400

} OHCI_REGISTER_MAP, *POHCI_REGISTER_MAP;

typedef struct _OHCI1394_PHY_REGISTER_MAP {

        UCHAR       Cable_Power_Status:1;           // @ reg 0
        UCHAR       Root:1;
        UCHAR       Physical_ID:6;
        UCHAR       Gap_Count:6;                    // @ reg 1
        UCHAR       Initiate_BusReset:1;
        UCHAR       Root_Hold_Off:1;
        UCHAR       Number_Ports:4;                 // @ reg 2
        UCHAR       Reserved:2;
        UCHAR       Speed:2;
        UCHAR       Reserved1:2;                    // @ reg 3
        UCHAR       Connected1:1;
        UCHAR       Child1:1;
        UCHAR       BStat1:2;
        UCHAR       AStat1:2;
        UCHAR       Reserved2:2;                    // @ reg 4
        UCHAR       Connected2:1;
        UCHAR       Child2:1;
        UCHAR       BStat2:2;
        UCHAR       AStat2:2;                       // in 1394A, bit 0 of Astat, is the contender bit
        UCHAR       Reserved3:2;                    // @ reg 5
        UCHAR       Connected3:1;
        UCHAR       Child3:1;
        UCHAR       BStat3:2;
        UCHAR       AStat3:2;
        UCHAR       Manager_Capable:1;              // @ reg 6
        UCHAR       Reserved4:3;
        UCHAR       Initiated_Reset:1;
        UCHAR       Cable_Power_Stat:1;
        UCHAR       Cable_Power_Status_Int:1;
        UCHAR       Loop_Int:1;

} OHCI1394_PHY_REGISTER_MAP, *POHCI1394_PHY_REGISTER_MAP;

typedef struct _OHCI1394A_PHY_REGISTER_MAP {

        UCHAR       Cable_Power_Status:1;           // @ reg 0
        UCHAR       Root:1;
        UCHAR       Physical_ID:6;
        UCHAR       Gap_Count:6;                    // @ reg 1
        UCHAR       Initiate_BusReset:1;
        UCHAR       Root_Hold_Off:1;
        UCHAR       Number_Ports:4;                 // @ reg 2
        UCHAR       Reserved1:1;
        UCHAR       Extended:3;
        UCHAR       Delay:4;                        // @ reg 3
        UCHAR       Reserved2:1;
        UCHAR       Max_Speed:3;                        
        UCHAR       Pwr:3;                          // @ reg 4
        UCHAR       Jitter:3;
        UCHAR       Contender:1;
        UCHAR       Link_Active:1;
        UCHAR       Enab_Multi:1;                   // @ reg 5
        UCHAR       Enab_Accel:1;
        UCHAR       Port_event:1;
        UCHAR       Timeout:1;
        UCHAR       Pwr_Fail:1;
        UCHAR       Loop:1;
        UCHAR       ISBR:1;
        UCHAR       Resume_int:1;
        UCHAR       Reg6Reserved:8;                 // @ reg 6
        UCHAR       PortSelect:4;                   // @ reg 7
        UCHAR       Reserved3:1;
        UCHAR       PageSelect:3;
        UCHAR       Register0:8;
        UCHAR       Register1:8;
        UCHAR       Register2:8;
        UCHAR       Register3:8;
        UCHAR       Register4:8;
        UCHAR       Register5:8;
        UCHAR       Register6:8;
        UCHAR       Register7:8;

} OHCI1394A_PHY_REGISTER_MAP, *POHCI1394A_PHY_REGISTER_MAP;

typedef struct _OHCI_SELF_ID_PACKET_HEADER {

            ULONG       TimeStamp:16;       // bits 0-15
            ULONG       SelfIdGeneration:8; // bits 16-23
            ULONG       Reserved:8;         // bits 24-31

} OHCI_SELF_ID_PACKET_HEADER, *POHCI_SELF_ID_PACKET_HEADER;

typedef struct _OHCI_IT_ISOCH_HEADER {

            ULONG       OHCI_Sy:4;          // bits 0-3
            ULONG       OHCI_Tcode:4;       // bits 4-7
            ULONG       OHCI_ChanNum:6;     // bits 8-13
            ULONG       OHCI_Tag:2;         // bits 14-15
            ULONG       OHCI_Spd:3;         // bits 16-18
            ULONG       OHCI_Reserved:13;   // bits 19-31

            USHORT      OHCI_Reserved1;
            USHORT      OHCI_DataLength;
            
} OHCI_IT_ISOCH_HEADER, *POHCI_IT_ISOCH_HEADER;

typedef struct _BUS1394_NODE_ADDRESS {
    USHORT              NA_Node_Number:6;       // Bits 10-15
    USHORT              NA_Bus_Number:10;       // Bits 0-9
} BUS1394_NODE_ADDRESS, *PBUS1394_NODE_ADDRESS;

//
// Definition of Command Descriptor Lists (CDL's)
//
typedef struct _COMMAND_DESCRIPTOR {

    struct {

        ULONG       ReqCount:16;            // bits 0-15
        ULONG       w:2;                    // bits 16-17
        ULONG       b:2;                    // bits 18-19
        ULONG       i:2;                    // bits 20-21
        ULONG       Reserved1:1;            // bit 22
        ULONG       p:1;                    // bit 23
        ULONG       Key:3;                  // bits 24-26
        ULONG       Status:1;               // bit 27
        ULONG       Cmd:4;                  // bits 28-31

    } Header;

    ULONG   DataAddress;

    union {

        ULONG BranchAddress;

        struct {

            ULONG   Z:4;                    // bits 0-3
            ULONG   Reserved:28;            // bits 4-31

        } z;

    } u;
    
    struct {
        
        union {
            USHORT  TimeStamp:16;           // bits 0-15
            USHORT  ResCount:16;            // bits 0-15
        } u;
        
        USHORT XferStatus;              // bits 16-31

    } Status;

} COMMAND_DESCRIPTOR, *PCOMMAND_DESCRIPTOR;

typedef struct _OHCI_ASYNC_PACKET {


    USHORT              OHCI_Reserved3:4;      
    USHORT              OHCI_tCode:4;        
    USHORT              OHCI_rt:2;            
    USHORT              OHCI_tLabel:6;        

    union {

        struct {
           BUS1394_NODE_ADDRESS        OHCI_Destination_ID; // 1st quadlet
        } Rx;

        struct {

            USHORT              OHCI_spd:3;         // 1st quadlet
            USHORT              OHCI_Reserved2:4;
            USHORT              OHCI_srcBusId:1;
            USHORT              OHCI_Reserved:8;          

        } Tx;

    } u;
    
    union {

        USHORT          OHCI_Offset_High;     
        struct {

            USHORT      OHCI_Reserved2:8;
            USHORT      OHCI_Reserved1:4;
            USHORT      OHCI_Rcode:4;

        } Response;

    } u2;

    union {
        struct {
            BUS1394_NODE_ADDRESS        OHCI_Destination_ID;    // 2nd quadlet
        } Tx;

        struct {
            BUS1394_NODE_ADDRESS        OHCI_Source_ID;         // 2nd quadlet
        } Rx;
        
    } u1;
    
    ULONG               OHCI_Offset_Low;     // 3rd quadlet

    union {
        struct {

            USHORT      OHCI_Extended_tCode;  
            USHORT      OHCI_Data_Length;    // 4th quadlet

        } Block;
        ULONG           OHCI_Quadlet_Data;   // 4th quadlet
    } u3;
        
} OHCI_ASYNC_PACKET, *POHCI_ASYNC_PACKET;


typedef struct _DESCRIPTOR_BLOCK {

    union {

        COMMAND_DESCRIPTOR CdArray[MAX_OHCI_COMMAND_DESCRIPTOR_BLOCKS];

        struct {
            COMMAND_DESCRIPTOR Cd;
            OHCI_ASYNC_PACKET  Pkt;
        } Imm;
        

    }u;
    
} DESCRIPTOR_BLOCK, *PDESCRIPTOR_BLOCK;

//
// phy access operations
//

#define OHCI_PHY_ACCESS_SET_CONTENDER           0x01000000
#define OHCI_PHY_ACCESS_SET_GAP_COUNT           0x02000000
#define OHCI_PHY_ACCESS_RAW_READ                0x10000000
#define OHCI_PHY_ACCESS_RAW_WRITE               0x20000000

//
// 1394 Speed codes
//

#define SCODE_100_RATE                          0
#define SCODE_200_RATE                          1
#define SCODE_400_RATE                          2
#define SCODE_800_RATE                          3
#define SCODE_1600_RATE                         4
#define SCODE_3200_RATE                         5

#define TCODE_WRITE_REQUEST_QUADLET             0           // 0000b
#define TCODE_WRITE_REQUEST_BLOCK               1           // 0001b
#define TCODE_WRITE_RESPONSE                    2           // 0010b
#define TCODE_RESERVED1                         3
#define TCODE_READ_REQUEST_QUADLET              4           // 0100b
#define TCODE_READ_REQUEST_BLOCK                5           // 0101b
#define TCODE_READ_RESPONSE_QUADLET             6           // 0110b
#define TCODE_READ_RESPONSE_BLOCK               7           // 0111b
#define TCODE_CYCLE_START                       8           // 1000b
#define TCODE_LOCK_REQUEST                      9           // 1001b
#define TCODE_ISOCH_DATA_BLOCK                  10          // 1010b
#define TCODE_LOCK_RESPONSE                     11          // 1011b
#define TCODE_RESERVED2                         12
#define TCODE_RESERVED3                         13
#define TCODE_SELFID                            14
#define TCODE_RESERVED4                         15

//
// IEEE 1212 Configuration Rom header definition
//
typedef struct _CONFIG_ROM_INFO {
    union {
        USHORT          CRI_CRC_Value:16;
        struct {
            UCHAR       CRI_Saved_Info_Length;
            UCHAR       CRI_Saved_CRC_Length;
        } Saved;
    } u;
    UCHAR               CRI_CRC_Length;
    UCHAR               CRI_Info_Length;
} CONFIG_ROM_INFO, *PCONFIG_ROM_INFO;

//
// IEEE 1212 Immediate entry definition
//
typedef struct _IMMEDIATE_ENTRY {
    ULONG               IE_Value:24;
    ULONG               IE_Key:8;
} IMMEDIATE_ENTRY, *PIMMEDIATE_ENTRY;

//
// IEEE 1212 Directory definition
//
typedef struct _DIRECTORY_INFO {
    union {
        USHORT          DI_CRC;
        USHORT          DI_Saved_Length;
    } u;
    USHORT              DI_Length;
} DIRECTORY_INFO, *PDIRECTORY_INFO;

//
// IEEE 1212 Node Capabilities entry definition
//
typedef struct _NODE_CAPABILITES {
    ULONG               NC_Init:1;                  // These can be found
    ULONG               NC_Ded:1;                   // in the IEEE 1212 doc
    ULONG               NC_Off:1;
    ULONG               NC_Atn:1;
    ULONG               NC_Elo:1;
    ULONG               NC_Reserved1:1;
    ULONG               NC_Drq:1;
    ULONG               NC_Lst:1;
    ULONG               NC_Fix:1;
    ULONG               NC_64:1;
    ULONG               NC_Prv:1;
    ULONG               NC_Bas:1;
    ULONG               NC_Ext:1;
    ULONG               NC_Int:1;
    ULONG               NC_Ms:1;
    ULONG               NC_Spt:1;
    ULONG               NC_Reserved2:8;
    ULONG               NC_Key:8;
} NODE_CAPABILITIES, *PNODE_CAPABILITIES;


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kdcom\ixkdcom.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixkdcom.c

Abstract:

    This module contains a very simply package to do com I/O on machines
    with standard AT com-ports.  It is C code derived from the debugger's
    com code.  Likely does not work on a PS/2.  (Only rewrote the thing
    into C so we wouldn't have to deal with random debugger macros.)

    Procedures to init a com object, set and query baud rate, output
    character, input character.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-1990

Revision History:

    John Vert (jvert) 12-Jun-1991
        Added ability to check for com-port's existence and hook onto the
        highest com-port available.

    John Vert (jvert) 19-Jul-1991
        Moved into HAL

--*/

#include <nthal.h>
#include "kdcomp.h"
#include "kdcom.h"
#include "inbv.h"
#define     TIMEOUT_COUNT  1024 * 200

UCHAR CpReadLsr (PCPPORT, UCHAR);

BOOLEAN KdCompDbgPortsPresent = TRUE;
UCHAR   KdCompDbgErrorCount = 0;

#define DBG_ACCEPTABLE_ERRORS   25

static UCHAR   LastLsr, LastMsr;

extern pKWriteUchar KdWriteUchar;
extern pKReadUchar  KdReadUchar;


VOID
CpInitialize (
    PCPPORT Port,
    PUCHAR  Address,
    ULONG  Rate
    )

/*++

    Routine Description:

        Fill in the com port port object, set the initial baud rate,
        turn on the hardware.

    Arguments:

        Port - address of port object

        Address - port address of the com port
                    (CP_COM1_PORT, CP_COM2_PORT)

        Rate - baud rate  (CP_BD_150 ... CP_BD_19200)

--*/

{
    PUCHAR hwport;
    UCHAR   mcr, ier;

    Port->Address = Address;
    Port->Baud = 0;

    CpSetBaud(Port, Rate);

    //
    // Assert DTR, RTS.
    //

    hwport = Port->Address;
    hwport += COM_MCR;

    mcr = MC_DTRRTS;
    KdWriteUchar(hwport, mcr);

    hwport = Port->Address;
    hwport += COM_IEN;

    ier = 0;
    KdWriteUchar(hwport, ier);
}




VOID
CpSetBaud (
    PCPPORT  Port,
    ULONG   Rate
    )

/*++

    Routine Description:

        Set the baud rate for the port and record it in the port object.

    Arguments:

        Port - address of port object

        Rate - baud rate  (CP_BD_150 ... CP_BD_56000)

--*/

{
    ULONG   divisorlatch;
    PUCHAR  hwport;
    UCHAR   lcr;

    //
    // compute the divsor
    //

    divisorlatch = CLOCK_RATE / Rate;

    //
    // set the divisor latch access bit (DLAB) in the line control reg
    //

    hwport = Port->Address;
    hwport += COM_LCR;                  // hwport = LCR register

    lcr = KdReadUchar(hwport);

    lcr |= LC_DLAB;
    KdWriteUchar(hwport, lcr);

    //
    // set the divisor latch value.
    //

    hwport = Port->Address;
    hwport += COM_DLM;                  // divisor latch msb
    KdWriteUchar(hwport, (UCHAR)((divisorlatch >> 8) & 0xff));

    hwport--;                           // divisor latch lsb
    KdWriteUchar(hwport, (UCHAR)(divisorlatch & 0xff));


    //
    // Set LCR to 3.  (3 is a magic number in the original assembler)
    //

    hwport = Port->Address;
    hwport += COM_LCR;
    KdWriteUchar(hwport, 3);


    //
    // Remember the baud rate
    //

    Port->Baud = Rate;
}



USHORT
CpQueryBaud (
    PCPPORT  Port
    )

/*++

    Routine Description:

        Return the last value baud rate was set to.

    Arguments:

        Port - address of cpport object which describes the hw port of interest.

    Return Value:

        Baud rate.  0 = none has been set.

--*/

{
    return  (USHORT) Port->Baud;
}

VOID
CpSendModemString (
    PCPPORT Port,
    IN PUCHAR   String
    )
/*++

    Routine Description:

        Sends a command string to the modem.
        This is down in order to aid the modem in determining th
        baud rate the local connect is at.

    Arguments:

        Port - Address of CPPORT
        String - String to send to modem

--*/
{
    static ULONG    Delay;
    TIME_FIELDS CurrentTime;
    UCHAR   i;
    ULONG   l;

    if (Port->Flags & PORT_SENDINGSTRING)
        return ;

    Port->Flags |= PORT_SENDINGSTRING;
    if (!Delay) {
        // see how long 1 second is
        HalQueryRealTimeClock (&CurrentTime);
        l = CurrentTime.Second;
        while (l == (ULONG) CurrentTime.Second) {
            CpReadLsr(Port, 0);
            HalQueryRealTimeClock (&CurrentTime);
            Delay++;
        }
        Delay = Delay / 3;
    }

    l = Delay;
    while (*String) {
        HalQueryRealTimeClock (&CurrentTime);
        i = CpReadLsr (Port, 0);
        if (i & COM_OUTRDY) {
            if ((--l) == 0) {
                KdWriteUchar(Port->Address+COM_DAT, *String);
                String++;
                l = Delay;
            }
        }
        if (i & COM_DATRDY)
            KdReadUchar(Port->Address + COM_DAT);
    }
    Port->Flags &= ~PORT_SENDINGSTRING;
}

UCHAR
CpReadLsr (
    PCPPORT Port,
    UCHAR   waiting
    )

/*++

    Routine Description:

        Read LSR byte from specified port.  If HAL owns port & display
        it will also cause a debug status to be kept up to date.

        Handles entering & exiting modem control mode for debugger.

    Arguments:

        Port - Address of CPPORT

    Returns:

        Byte read from port

--*/
{
    static  UCHAR   ringflag = 0;
    static  UCHAR   diagout[3];
    static  ULONG   diagmsg[3] = { 'TRP ', 'LVO ', 'MRF ' };
    static  UCHAR   ModemString[] = "\n\rAT\n\r";
    TIME_FIELDS CurrentTime;
    UCHAR   lsr, msr, i;
    ULONG   diagstr[12];

    lsr = KdReadUchar(Port->Address + COM_LSR);

    //
    // Check to see if the port still exists.
    //
    if (lsr == SERIAL_LSR_NOT_PRESENT) {
        
        KdCompDbgErrorCount++;
        
        if (KdCompDbgErrorCount >= DBG_ACCEPTABLE_ERRORS) {
            KdCompDbgPortsPresent = FALSE;
            KdCompDbgErrorCount = 0;
        }
        return SERIAL_LSR_NOT_PRESENT;
    }

    if (lsr & COM_PE)
        diagout[0] = 8;         // Parity error

    if (lsr & COM_OE)
        diagout[1] = 8;         // Overflow error

    if (lsr & COM_FE)
        diagout[2] = 8;         // Framing error

    if (lsr & waiting) {
        LastLsr = ~COM_DATRDY | (lsr & COM_DATRDY);
        return lsr;
    }

    msr = KdReadUchar (Port->Address + COM_MSR);

    if (Port->Flags & PORT_MODEMCONTROL) {
        if (msr & SERIAL_MSR_DCD) {

            //
            // In modem control mode with carrier detect
            // Reset carrier lost time
            //

            Port->Flags |= PORT_NOCDLTIME | PORT_MDM_CD;

        } else {

            //
            // In modem control mode, but no carrier detect.  After
            // 60 seconds drop out of modem control mode
            //

            if (Port->Flags & PORT_NOCDLTIME) {
                HalQueryRealTimeClock (&Port->CarrierLostTime);
                Port->Flags &= ~PORT_NOCDLTIME;
                ringflag = 0;
            }

            HalQueryRealTimeClock (&CurrentTime);
            if (CurrentTime.Minute != Port->CarrierLostTime.Minute  &&
                CurrentTime.Second >= Port->CarrierLostTime.Second) {

                //
                // It's been at least 60 seconds - drop out of
                // modem control mode until next RI
                //

                Port->Flags &= ~PORT_MODEMCONTROL;
                CpSendModemString (Port, ModemString);
            }

            if (Port->Flags & PORT_MDM_CD) {

                //
                // We had a connection - if it's the connection has been
                // down for a few seconds, then send a string to the modem
                //

                if (CurrentTime.Second < Port->CarrierLostTime.Second)
                    CurrentTime.Second += 60;

                if (CurrentTime.Second > Port->CarrierLostTime.Second + 10) {
                    Port->Flags &= ~PORT_MDM_CD;
                    CpSendModemString (Port, ModemString);
                }
            }
        }
    }

    if (!(Port->Flags & PORT_SAVED)) {
        return lsr;
    }

    KdCheckPowerButton();

    if (lsr == LastLsr  &&  msr == LastMsr) {
        return lsr;
    }

    ringflag |= (msr & SERIAL_MSR_RI) ? 1 : 2;
    if (ringflag == 3) {

        //
        // The ring indicate line has toggled
        // Use modem control from now on
        //

        ringflag = 0;
        Port->Flags |= PORT_MODEMCONTROL | PORT_NOCDLTIME;
        Port->Flags &= ~PORT_MDM_CD;

        if (Port->Flags & PORT_DEFAULTRATE  &&  Port->Baud != BD_9600) {

            //
            // Baud rate was never specified switch
            // to 9600 baud as default (for modem usage).
            //

            InbvDisplayString (MSG_DEBUG_9600);
            CpSetBaud (Port, BD_9600);
            //Port->Flags |= PORT_DISBAUD;
        }
    }

    for (i=0; i < 3; i++) {
        if (diagout[i]) {
            diagout[i]--;
            diagstr[10-i] = diagmsg[i];
        } else {
            diagstr[10-i] = '    ';
        }
    }

    diagstr[7] = (LastLsr & COM_DATRDY) ? 'VCR ' : '    ';
    diagstr[6] = (lsr & COM_OUTRDY)     ? '    ' : 'DNS ';
    diagstr[5] = (msr & 0x10) ? 'STC ' : '    ';
    diagstr[4] = (msr & 0x20) ? 'RSD ' : '    ';
    diagstr[3] = (msr & 0x40) ? ' IR ' : '    ';
    diagstr[2] = (msr & 0x80) ? ' DC ' : '    ';
    diagstr[1] = (Port->Flags & PORT_MODEMCONTROL) ? 'MDM ' : '    ';
    diagstr[0] = '    ';
#if 0
    if (Port->Flags & PORT_DISBAUD) {
        switch (Port->Baud) {
            case BD_9600:   diagstr[0] = ' 69 ';    break;
            case BD_14400:  diagstr[0] = 'K41 ';    break;
            case BD_19200:  diagstr[0] = 'K91 ';    break;
            case BD_56000:  diagstr[0] = 'K65 ';    break;
        }
    }
#endif

    //HalpDisplayDebugStatus ((PUCHAR) diagstr, 11*4);
    LastLsr = lsr;
    LastMsr = msr;
    return lsr;
}




VOID
CpPutByte (
    PCPPORT  Port,
    UCHAR   Byte
    )

/*++

    Routine Description:

        Write a byte out to the specified com port.

    Arguments:

        Port - Address of CPPORT object

        Byte - data to emit

--*/

{
    UCHAR   msr, lsr;
    
    if (KdCompDbgPortsPresent == FALSE) {
        return;
    }
    
    //
    // If modem control, make sure DSR, CTS and CD are all set before
    // sending any data.
    //

    while ((Port->Flags & PORT_MODEMCONTROL)  &&
           (msr = KdReadUchar(Port->Address + COM_MSR) & MS_DSRCTSCD) != MS_DSRCTSCD) {

        //
        // If no CD, and there's a charactor ready, eat it
        //

        lsr = CpReadLsr (Port, 0);
        if ((msr & MS_CD) == 0  && (lsr & COM_DATRDY) == COM_DATRDY) {
            KdReadUchar(Port->Address + COM_DAT);
        }
    }

    //
    //  Wait for port to not be busy
    //

    while (!(CpReadLsr(Port, COM_OUTRDY) & COM_OUTRDY)) ;

    //
    // Send the byte
    //

    KdWriteUchar(Port->Address + COM_DAT, Byte);
}

USHORT
CpGetByte (
    PCPPORT  Port,
    PUCHAR Byte,
    BOOLEAN WaitForByte
    )

/*++

    Routine Description:

        Fetch a byte and return it.

    Arguments:

        Port - address of port object that describes hw port

        Byte - address of variable to hold the result

        WaitForByte - flag indicates wait for byte or not.

    Return Value:

        CP_GET_SUCCESS if data returned.

        CP_GET_NODATA if no data available, but no error.

        CP_GET_ERROR if error (overrun, parity, etc.)

--*/

{
    UCHAR   lsr;
    UCHAR   value;
    ULONG   limitcount;

    //
    //  Make sure DTR and CTS are set
    //
    //  (What does CTS have to do with reading from a full duplex line???)


    //
    // Check to make sure the CPPORT we were passed has been initialized.
    // (The only time it won't be initialized is when the kernel debugger
    // is disabled, in which case we just return.)
    //
    if (Port->Address == NULL) {
        KdCheckPowerButton();
        return(CP_GET_NODATA);
    }

    if (KdCompDbgPortsPresent == FALSE) {
        
        if (CpReadLsr(Port, COM_DATRDY) == SERIAL_LSR_NOT_PRESENT) {

            return(CP_GET_NODATA);
        } else {
            
            CpSetBaud(Port, Port->Baud);
            KdCompDbgPortsPresent = TRUE;
        }
    }
    
    limitcount = WaitForByte ? TIMEOUT_COUNT : 1;
    while (limitcount != 0) {
        limitcount--;

        lsr = CpReadLsr(Port, COM_DATRDY);
        
        if (lsr == SERIAL_LSR_NOT_PRESENT) {
            return(CP_GET_NODATA); 
        }
        
        if ((lsr & COM_DATRDY) == COM_DATRDY) {

            //
            // Check for errors
            //
            if (lsr & (COM_FE | COM_PE | COM_OE)) {
                *Byte = 0;
                return(CP_GET_ERROR);
            }

            //
            // fetch the byte
            //

            value = KdReadUchar(Port->Address + COM_DAT);

            if (Port->Flags & PORT_MODEMCONTROL) {

                //
                // Using modem control.  If no CD, then skip this byte.
                //

                if ((KdReadUchar(Port->Address + COM_MSR) & MS_CD) == 0) {
                    continue;
                }
            }

            *Byte = value & (UCHAR)0xff;
            return CP_GET_SUCCESS;
        }
    }

    LastLsr = 0;
    CpReadLsr (Port, 0);
    return CP_GET_NODATA;
}



BOOLEAN
CpDoesPortExist(
    IN PUCHAR Address
    )

/*++

Routine Description:

    This routine will attempt to place the port into its
    diagnostic mode.  If it does it will twiddle a bit in
    the modem control register.  If the port exists this
    twiddling should show up in the modem status register.

    NOTE: This routine must be called before the device is
          enabled for interrupts, this includes setting the
          output2 bit in the modem control register.

    This is blatantly stolen from TonyE's code in ntos\dd\serial\serial.c.

Arguments:

    Address - address of hw port.

Return Value:

    TRUE - Port exists.  Party on.

    FALSE - Port doesn't exist.  Don't use it.

--*/

{
    UCHAR OldModemStatus;
    UCHAR ModemStatus;
    BOOLEAN ReturnValue = TRUE;

    //
    // Save the old value of the modem control register.
    //

    OldModemStatus = KdReadUchar(Address+COM_MCR);

    //
    // Set the port into diagnostic mode.
    //

    KdWriteUchar(
        Address+COM_MCR,
        SERIAL_MCR_LOOP
        );

    //
    // Bang on it again to make sure that all the lower bits
    // are clear.
    //

    KdWriteUchar(
        Address+COM_MCR,
        SERIAL_MCR_LOOP
        );

    //
    // Read the modem status register.  The high for bits should
    // be clear.
    //

    ModemStatus = KdReadUchar(Address+COM_MSR);

    if (ModemStatus & (SERIAL_MSR_CTS | SERIAL_MSR_DSR |
                       SERIAL_MSR_RI  | SERIAL_MSR_DCD)) {

        ReturnValue = FALSE;
        goto AllDone;

    }

    //
    // So far so good.  Now turn on OUT1 in the modem control register
    // and this should turn on ring indicator in the modem status register.
    //

    KdWriteUchar(
        Address+COM_MCR,
        (SERIAL_MCR_OUT1 | SERIAL_MCR_LOOP)
        );

    ModemStatus = KdReadUchar(Address+COM_MSR);

    if (!(ModemStatus & SERIAL_MSR_RI)) {

        ReturnValue = FALSE;
        goto AllDone;

    }

AllDone: ;

    //
    // Put the modem control back into a clean state.
    //

    KdWriteUchar(
        Address+COM_MCR,
        OldModemStatus
        );

    return ReturnValue;
}

VOID
CpWritePortUchar(
    IN PUCHAR Address, 
    IN UCHAR Value
)
{
    WRITE_PORT_UCHAR(Address, Value); 
} // CpWritePortUchar()

UCHAR
CpReadPortUchar(
    IN PUCHAR Address
    )
{
    return READ_PORT_UCHAR(Address); 
} // CpReadPortUchar()

VOID
CpWriteRegisterUchar(
    IN PUCHAR Address,
    IN UCHAR Value
    )
{
    WRITE_REGISTER_UCHAR(Address, Value);
} // CpWriteRegisterValue()

UCHAR
CpReadRegisterUchar(
    IN PUCHAR Address
    )
{
    return READ_REGISTER_UCHAR(Address); 
} // CpReadRegisterUchar()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kd1394\kd1394.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    kd1394.h

Abstract:

    1394 Kernel Debugger DLL

Author:

    Peter Binder (pbinder)

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/21/2001 pbinder   having fun...
--*/

//
// boot.ini parameters
//
#define BUSPARAMETERS_OPTION            "BUSPARAMS"
#define CHANNEL_OPTION                  "CHANNEL"
#define BUS_OPTION                      "NOBUS"

// global 1394 debug controller data
#define DBG_BUS1394_CROM_BUFFER_SIZE    64

#define TIMEOUT_COUNT                   1024*500
#define MAX_REGISTER_READS              400000

typedef struct _DEBUG_1394_DATA {

    //
    // our config rom - must be 1k aligned
    //
    ULONG                       CromBuffer[DBG_BUS1394_CROM_BUFFER_SIZE];

    //
    // our ohci register map
    //
    POHCI_REGISTER_MAP          BaseAddress;

    //
    // our config for this session
    //
    DEBUG_1394_CONFIG           Config;

    //
    // our send packet (isoch packet)
    //
    DEBUG_1394_SEND_PACKET      SendPacket;

    //
    // our receive packet
    //
    DEBUG_1394_RECEIVE_PACKET   ReceivePacket;

} DEBUG_1394_DATA, *PDEBUG_1394_DATA;

//
// Debug 1394 Parameters
//
typedef struct _DEBUG_1394_PARAMETERS {

    //
    // device descriptor (pci slot, bus, etc)
    //
    DEBUG_DEVICE_DESCRIPTOR     DbgDeviceDescriptor;

    //
    // is the debugger active?
    //
    BOOLEAN                     DebuggerActive;

    //
    // should we disable 1394bus?
    //
    ULONG                       NoBus;

    //
    // Id for this target
    //
    ULONG                       Id;

} DEBUG_1394_PARAMETERS, *PDEBUG_1394_PARAMETERS;

//
// Global Data Structures
//
#ifdef _KD1394_C

DEBUG_1394_PARAMETERS           Kd1394Parameters;
PDEBUG_1394_DATA                Kd1394Data;

#else

extern DEBUG_1394_PARAMETERS    Kd1394Parameters;
extern PDEBUG_1394_DATA         Kd1394Data;

#endif

//
// kd1394.c
//
BOOLEAN
Kd1394pInitialize(
    IN PDEBUG_1394_PARAMETERS   DebugParameters,
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    );

NTSTATUS
KdD0Transition(
    void
    );

NTSTATUS
KdD3Transition(
    void
    );

NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    );

NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK  LoaderBlock
    );

NTSTATUS
KdSave(
    IN BOOLEAN  KdSleepTransition
    );

NTSTATUS
KdRestore(
    IN BOOLEAN  KdSleepTransition
    );

//
// kd1394io.c
//
ULONG
KdpComputeChecksum(
    IN PUCHAR   Buffer,
    IN ULONG    Length
    );

void
KdpSendControlPacket(
    IN USHORT   PacketType,
    IN ULONG    PacketId OPTIONAL
    );

ULONG
KdReceivePacket (
    IN ULONG            PacketType,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    OUT PULONG          DataLength,
    IN OUT PKD_CONTEXT  KdContext
    );

void
KdSendPacket(
    IN ULONG            PacketType,
    IN PSTRING          MessageHeader,
    IN PSTRING          MessageData OPTIONAL,
    IN OUT PKD_CONTEXT  KdContext
    );

//
// ohci1394.c
//
ULONG
FASTCALL
Dbg1394_ByteSwap(
    IN ULONG Source
    );

ULONG
Dbg1394_CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    );

ULONG
Dbg1394_Crc16(
    IN ULONG data,
    IN ULONG check
    );

NTSTATUS
Dbg1394_ReadPhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    PUCHAR              pData
    );

NTSTATUS
Dbg1394_WritePhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    UCHAR               Data
    );

BOOLEAN
Dbg1394_InitializeController(
    IN PDEBUG_1394_DATA         DebugData,
    IN PDEBUG_1394_PARAMETERS   DebugParameters
    );

ULONG
Dbg1394_StallExecution(
    ULONG   LoopCount
    );

void
Dbg1394_EnablePhysicalAccess(
    IN PDEBUG_1394_DATA     DebugData
    );

ULONG
Dbg1394_ReadPacket(
    PDEBUG_1394_DATA    DebugData,
    OUT PKD_PACKET      PacketHeader,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    BOOLEAN             Wait
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kdcom\kdcom.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    kdcom.c

Abstract:

    Kernel Debugger HW Extension DLL com port debugger support module

Author:

    Eric F. Nelson (enelson) 7-Jan-99

Revision History:

--*/

#include "kdcomp.h"

#define BAUD_OPTION "BAUDRATE"
#define PORT_OPTION "DEBUGPORT"

DEBUG_PARAMETERS KdCompDbgParams = {0, 0};

VOID
SleepResetKd(
    VOID
    );


NTSTATUS
KdD0Transition(
    VOID
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API after it
    processes a D0 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return STATUS_SUCCESS;
}



NTSTATUS
KdD3Transition(
    VOID
    )
/*++

Routine Description:

    The PCI driver (or relevant bus driver) will call this API before it
    processes a D3 IRP for this device

Arguments:

    None

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    return STATUS_SUCCESS;
}



NTSTATUS
KdDebuggerInitialize0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to parse the boot.ini strings and
    perform any initialization.  It cannot be assumed that the entire NT
    kernel has been initialized at this time.  Memory management services,
    for example, will not be available.  After this call has returned, the
    debugger DLL may receive requests to send and receive packets.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    PCHAR Options;
    NTSTATUS Status;
    PCHAR BaudOption;
    PCHAR PortOption;

    if (LoaderBlock != NULL) {
        if (LoaderBlock->LoadOptions != NULL) {
            Options = LoaderBlock->LoadOptions;
         
            _strupr(Options);

            PortOption = strstr(Options, PORT_OPTION);
            BaudOption = strstr(Options, BAUD_OPTION);

            if (PortOption) {
                PortOption = strstr(PortOption, "COM");
                if (PortOption) {
                    KdCompDbgParams.CommunicationPort = atol(PortOption + 3);
                }
            }

            if (BaudOption) {
                BaudOption += strlen(BAUD_OPTION);
                while (*BaudOption == ' ') {
                    BaudOption++;
                }

                if (*BaudOption != '\0') {
                    KdCompDbgParams.BaudRate = atol(BaudOption + 1);
                }
            }
        }
    }

    Status = KdCompInitialize(&KdCompDbgParams, LoaderBlock);

    //
    // Initialize ID for NEXT packet to send and Expect ID of next incoming
    // packet.
    //
    if (NT_SUCCESS(Status)) {
        KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
        KdCompPacketIdExpected = INITIAL_PACKET_ID;
    }

    return Status;
}



NTSTATUS
KdDebuggerInitialize1(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This API allows the debugger DLL to do any initialization that it needs
    to do after the NT kernel services are available.  Mm and registry APIs
    will be guaranteed to be available at this time.  If the specific
    debugger DLL implementation uses a PCI device, it will set a registry
    key (discussed later) that notifies the PCI driver that a specific PCI
    device is being used for debugging.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    KdCompInitialize1();
    return STATUS_SUCCESS;
}



NTSTATUS
KdSave(
    IN BOOLEAN KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as late as possible before putting the
    machine to sleep.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    KdCompSave();

    return STATUS_SUCCESS;
}



NTSTATUS
KdRestore(
    IN BOOLEAN KdSleepTransition
    )
/*++

Routine Description:

    The HAL calls this function as early as possible after resuming from a
    sleep state.

Arguments:

    KdSleepTransition - TRUE when transitioning to/from sleep state

Return Value:

    STATUS_SUCCESS, or appropriate error status

--*/
{
    //
    // Force resync when transitioning to/from sleep state
    //
    if (KdSleepTransition) {
#ifdef ALPHA
        SleepResetKd();
#else
        KdCompDbgPortsPresent = FALSE;
#endif
    } else {
        KdCompRestore();
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kd1394\ohci1394.c ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ohci1394.c

Abstract:

    1394 Kernel Debugger DLL

Author:

    Peter Binder (pbinder)

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/21/2001 pbinder   having fun...
--*/

#define _OHCI1394_C
#include "pch.h"
#undef _OHCI1394_C

ULONG
FASTCALL
Dbg1394_ByteSwap(
    IN ULONG Source
    )
/*++

Routine Description:

    The RtlUlongByteSwap function exchanges byte pairs 0:3 and 1:2 of
    Source and returns the resulting ULONG.

Arguments:

    Source - 32-bit value to byteswap.

Return Value:

    Swapped 32-bit value.

--*/
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
} // Dbg1394_ByteSwap

ULONG
Dbg1394_CalculateCrc(
    IN PULONG Quadlet,
    IN ULONG length
    )
/*++

Routine Description:

    This routine calculates a CRC for the pointer to the Quadlet data.

Arguments:

    Quadlet - Pointer to data to CRC

    length - length of data to CRC

Return Value:

    returns the CRC

--*/
{
    LONG temp;
    ULONG index;

    temp = index = 0;

    while (index < length) {

        temp = Dbg1394_Crc16(Quadlet[index++], temp);
    }

    return (temp);
} // Dbg1394_CalculateCrc

ULONG
Dbg1394_Crc16(
    IN ULONG data,
    IN ULONG check
    )
/*++

Routine Description:

    This routine derives the 16 bit CRC as defined by IEEE 1212
    clause 8.1.5.  (ISO/IEC 13213) First edition 1994-10-05.

Arguments:

    data - ULONG data to derive CRC from

    check - check value

Return Value:

    Returns CRC.

--*/
{
    LONG shift, sum, next;

    for (next = check, shift = 28; shift >= 0; shift -= 4) {

        sum = ((next >> 12) ^ (data >> shift)) & 0xf;
        next = (next << 4) ^ (sum << 12) ^ (sum << 5) ^ (sum);
    }

    return(next & 0xFFFF);
} // Dbg1394_Crc16

NTSTATUS
Dbg1394_ReadPhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    PUCHAR              pData
    )
{
    union {
        ULONG                   AsUlong;
        PHY_CONTROL_REGISTER    PhyControl;
    } u;

    ULONG   retry = 0;

    u.AsUlong = 0;
    u.PhyControl.RdReg = TRUE;
    u.PhyControl.RegAddr = Offset;

    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl, u.AsUlong);

    retry = MAX_REGISTER_READS;

    do {

        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl);

    } while ((!u.PhyControl.RdDone) && --retry);


    if (!retry) {

        return(STATUS_UNSUCCESSFUL);
    }

    *pData = (UCHAR)u.PhyControl.RdData;
    return(STATUS_SUCCESS);
} // Dbg1394_ReadPhyRegister

NTSTATUS
Dbg1394_WritePhyRegister(
    PDEBUG_1394_DATA    DebugData,
    ULONG               Offset,
    UCHAR               Data
    )
{
    union {
        ULONG                   AsUlong;
        PHY_CONTROL_REGISTER    PhyControl;
    } u;

    ULONG   retry = 0;

    u.AsUlong = 0;
    u.PhyControl.WrReg = TRUE;
    u.PhyControl.RegAddr = Offset;
    u.PhyControl.WrData = Data;

    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl, u.AsUlong);

    retry = MAX_REGISTER_READS;

    do {

        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyControl);

    } while (u.PhyControl.WrReg && --retry);

    if (!retry) {

        return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
} // Dbg1394_WritePhyRegister

BOOLEAN
Dbg1394_InitializeController(
    IN PDEBUG_1394_DATA         DebugData,
    IN PDEBUG_1394_PARAMETERS   DebugParameters
    )
{
    BOOLEAN             bReturn = TRUE;

    ULONG               ulVersion;
    UCHAR               MajorVersion;
    UCHAR               MinorVersion;

    ULONG               ReadRetry;

    PHYSICAL_ADDRESS    physAddr;

    UCHAR               Data;
    NTSTATUS            ntStatus;

    union {
        ULONG                       AsUlong;
        HC_CONTROL_REGISTER         HCControl;
        LINK_CONTROL_REGISTER       LinkControl;
        NODE_ID_REGISTER            NodeId;
        CONFIG_ROM_INFO             ConfigRomHeader;
        BUS_OPTIONS_REGISTER        BusOptions;
        IMMEDIATE_ENTRY             CromEntry;
        DIRECTORY_INFO              DirectoryInfo;
    } u;

    // initialize our bus info
    DebugData->Config.Tag = DEBUG_1394_CONFIG_TAG;
    DebugData->Config.MajorVersion = DEBUG_1394_MAJOR_VERSION;
    DebugData->Config.MinorVersion = DEBUG_1394_MINOR_VERSION;
    DebugData->Config.Id = DebugParameters->Id;
    DebugData->Config.BusPresent = FALSE;
    DebugData->Config.SendPacket = MmGetPhysicalAddress(&DebugData->SendPacket);
    DebugData->Config.ReceivePacket = MmGetPhysicalAddress(&DebugData->ReceivePacket);

    // get our base address
    DebugData->BaseAddress = \
        (POHCI_REGISTER_MAP)DebugParameters->DbgDeviceDescriptor.BaseAddress[0].TranslatedAddress;

    // get our version
    ulVersion = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->Version);

    MajorVersion = (UCHAR)(ulVersion >> 16);
    MinorVersion = (UCHAR)ulVersion;

    // make sure we have a valid version
    if (MajorVersion != 1) { // INVESTIGATE

        bReturn = FALSE;
        goto Exit_Dbg1394_InitializeController;
    }

    // soft reset to initialize the controller
    u.AsUlong = 0;
    u.HCControl.SoftReset = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    // wait until reset complete - ??
    ReadRetry = 1000; // ??

    do {

        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet);
        Dbg1394_StallExecution(1);

    } while ((u.HCControl.SoftReset) && (--ReadRetry));

    // see if reset succeeded
    if (ReadRetry == 0) {

        bReturn = FALSE;
        goto Exit_Dbg1394_InitializeController;
    }

    // what's this do???
    u.AsUlong = 0;
    u.HCControl.Lps = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    Dbg1394_StallExecution(20);

    // initialize HCControl register
    u.AsUlong = 0;
    u.HCControl.NoByteSwapData = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlClear, u.AsUlong);

    u.AsUlong = 0;
    u.HCControl.PostedWriteEnable = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    // setup the link control
    u.AsUlong = 0x0;
    u.LinkControl.CycleTimerEnable = TRUE;
    u.LinkControl.CycleMaster = TRUE;
    u.LinkControl.RcvPhyPkt = TRUE;
    u.LinkControl.RcvSelfId = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->LinkControlClear, u.AsUlong);

    u.AsUlong = 0;
    u.LinkControl.CycleTimerEnable = TRUE;
    u.LinkControl.CycleMaster = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->LinkControlSet, u.AsUlong);

    // set the bus number (hardcoded to 0x3FF) - ??? what about node id??
    u.AsUlong = 0;
    u.NodeId.BusId = (USHORT)0x3FF;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->NodeId, u.AsUlong);

    // ???????????????
    // IA64 BUGBUG assumes that our global buffers, that were loaded with our 
    // image are placed < 32bit memory
    // ???????????????

    // do something with the crom...

    // 0xf0000404 - bus id register
    DebugData->CromBuffer[1] = 0x31333934;

    // 0xf0000408 - bus options register
    u.AsUlong = Dbg1394_ByteSwap(READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->BusOptions));
    u.BusOptions.Pmc = FALSE;
    u.BusOptions.Bmc = FALSE;
    u.BusOptions.Isc = FALSE;
    u.BusOptions.Cmc = FALSE;
    u.BusOptions.Irmc = FALSE;
    u.BusOptions.g = 1;
    DebugData->CromBuffer[2] = Dbg1394_ByteSwap(u.AsUlong);

    // 0xf000040c - global unique id hi
    u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidHi);
    DebugData->CromBuffer[3] = u.AsUlong;

    // 0xf0000410 - global unique id lo
    u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidLo);
    DebugData->CromBuffer[4] = u.AsUlong;

    // 0xf0000400 - config rom header - set last to calculate CRC!
    u.AsUlong = 0;
    u.ConfigRomHeader.CRI_Info_Length = 4;
    u.ConfigRomHeader.CRI_CRC_Length = 4;
    u.ConfigRomHeader.u.CRI_CRC_Value = (USHORT)Dbg1394_CalculateCrc( &DebugData->CromBuffer[1],
                                                                      u.ConfigRomHeader.CRI_CRC_Length
                                                                      );
    DebugData->CromBuffer[0] = u.AsUlong;

    // 0xf0000418 - node capabilities
    DebugData->CromBuffer[6] = 0xC083000C;

    // 0xf000041C - module vendor id
    DebugData->CromBuffer[7] = 0xF2500003;

    // 0xf0000420 - extended key
    DebugData->CromBuffer[8] = 0xF250001C;

    // 0xf0000424 - debug key
    DebugData->CromBuffer[9] = 0x0200001D;

    // 0xf0000428 - debug value
    physAddr = MmGetPhysicalAddress(&DebugData->Config);
    u.AsUlong = (ULONG)physAddr.LowPart;
    u.CromEntry.IE_Key = 0x1E;
    DebugData->CromBuffer[10] = Dbg1394_ByteSwap(u.AsUlong);

    // 0xf0000414 - root directory header - set last to calculate CRC!
    u.AsUlong = 0;
    u.DirectoryInfo.DI_Length = 5;
    u.DirectoryInfo.u.DI_CRC = (USHORT)Dbg1394_CalculateCrc( &DebugData->CromBuffer[6],
                                                             u.DirectoryInfo.DI_Length
                                                             );
    DebugData->CromBuffer[5] = Dbg1394_ByteSwap(u.AsUlong);

    // write the first few registers
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->ConfigRomHeader, DebugData->CromBuffer[0]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->BusId, DebugData->CromBuffer[1]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->BusOptions, DebugData->CromBuffer[2]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidHi, DebugData->CromBuffer[3]);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->GuidLo, DebugData->CromBuffer[4]);

    // set our crom
    physAddr = MmGetPhysicalAddress(&DebugData->CromBuffer);

    u.AsUlong = (ULONG)physAddr.LowPart; // FIXFIX quadpart to ulong??
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->ConfigRomMap, u.AsUlong);

    // disable all interrupts. wdm driver will enable them later - ??
    u.AsUlong = 0xFFFFFFFF;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->IntMaskClear, u.AsUlong);

    // enable the link
    u.AsUlong = 0;
    u.HCControl.LinkEnable = TRUE;
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet, u.AsUlong);

    Dbg1394_StallExecution(1000);

    // enable access filters to all nodes
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterLoSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterLoSet, 0xFFFFFFFF);

    // hard reset on the bus
    ntStatus = Dbg1394_ReadPhyRegister(DebugData, 1, &Data);

    if (NT_SUCCESS(ntStatus)) {

        Data |= PHY_INITIATE_BUS_RESET;
        Dbg1394_WritePhyRegister(DebugData, 1, Data);

        Dbg1394_StallExecution(1000);
    }
    else {

        bReturn = FALSE;
    }

Exit_Dbg1394_InitializeController:

    return(bReturn);
} // Dbg1394_InitializeController

ULONG // ?? need to look into this
Dbg1394_StallExecution(
    ULONG   LoopCount
    )
{
    ULONG i,j,b,k,l;

    b = 1;

    for (k=0;k<LoopCount;k++) {

        for (i=1;i<100000;i++) {

            PAUSE_PROCESSOR
            b=b* (i>>k);
        }
    };

    return(b);
} // Dbg1394_StallExecution

void
Dbg1394_EnablePhysicalAccess(
    IN PDEBUG_1394_DATA     DebugData
    )
{
    union {
        ULONG                       AsUlong;
        INT_EVENT_MASK_REGISTER     IntEvent;
        HC_CONTROL_REGISTER         HCControl;
    } u;

    // see if ohci1394 is being loaded...
    u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->HCControlSet);

    if (!u.HCControl.LinkEnable || !u.HCControl.Lps || u.HCControl.SoftReset) {

        return;
    }

    // only clear the bus reset interrupt if ohci1394 isn't loaded...
//    if (DebugData->Config.BusPresent == FALSE) {

        // if the bus reset interrupt is not cleared, we have to clear it...
        u.AsUlong = READ_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->IntEventSet);

        if (u.IntEvent.BusReset) {

            WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->IntEventClear, PHY_BUS_RESET_INT);
        }
//    }

    // we might need to reenable physical access, if so, do it.
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->AsynchReqFilterLoSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterHiSet, 0xFFFFFFFF);
    WRITE_REGISTER_ULONG((PULONG)&DebugData->BaseAddress->PhyReqFilterLoSet, 0xFFFFFFFF);

    return;
} // Dbg1394_EnablePhysicalAccess

ULONG
Dbg1394_ReadPacket(
    PDEBUG_1394_DATA    DebugData,
    OUT PKD_PACKET      PacketHeader,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    BOOLEAN             Wait
    )
//    KDP_PACKET_RESEND - if resend is required.  = 2 = CP_GET_ERROR
//    KDP_PACKET_TIMEOUT - if timeout.            = 1 = CP_GET_NODATA
//    KDP_PACKET_RECEIVED - if packet received.   = 0 = CP_GET_SUCCESS
{
    ULONG   timeoutLimit = 0;

    do {

        // make sure our link is enabled..
        Dbg1394_EnablePhysicalAccess(Kd1394Data);

        if (DebugData->ReceivePacket.TransferStatus == STATUS_PENDING) {

            *KdDebuggerNotPresent = FALSE;
            SharedUserData->KdDebuggerEnabled |= 0x00000002;

            RtlCopyMemory( PacketHeader,
                           &DebugData->ReceivePacket.Packet[0],
                           sizeof(KD_PACKET)
                           );

            // make sure we have a valid PacketHeader
            if (DebugData->ReceivePacket.Length < sizeof(KD_PACKET)) {

                // short packet, we are done...
                DebugData->ReceivePacket.TransferStatus = STATUS_SUCCESS;
                return(KDP_PACKET_RESEND);
            }

            if (MessageHeader) {

                RtlCopyMemory( MessageHeader->Buffer,
                               &DebugData->ReceivePacket.Packet[sizeof(KD_PACKET)],
                               MessageHeader->MaximumLength
                               );

                if (DebugData->ReceivePacket.Length <= (USHORT)(sizeof(KD_PACKET)+MessageHeader->MaximumLength)) {

                    DebugData->ReceivePacket.TransferStatus = STATUS_SUCCESS;
                    return(KDP_PACKET_RECEIVED);
                }

                if (MessageData) {

                    RtlCopyMemory( MessageData->Buffer,
                                   &DebugData->ReceivePacket.Packet[sizeof(KD_PACKET) + MessageHeader->MaximumLength],
                                   DebugData->ReceivePacket.Length - (sizeof(KD_PACKET) + MessageHeader->MaximumLength)
                                   );
                }
            }

            DebugData->ReceivePacket.TransferStatus = STATUS_SUCCESS;
            return(KDP_PACKET_RECEIVED);
        }

        timeoutLimit++;

        if (Wait == FALSE) {

            return(KDP_PACKET_RESEND);
        }

    } while (timeoutLimit <= TIMEOUT_COUNT);

    return(KDP_PACKET_TIMEOUT);
} // Dbg1394_ReadPacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kd1394\kd1394io.c ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    kd1394io.c

Abstract:

    1394 Kernel Debugger DLL

Author:

    George Chrysanthakopoulos (georgioc) Nov-1999

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

#define _KD1394IO_C
#include "pch.h"
#undef _KD1394IO_C

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpComputeChecksum)
#pragma alloc_text(PAGEKD, KdpSendControlPacket)
#pragma alloc_text(PAGEKD, KdReceivePacket)
#pragma alloc_text(PAGEKD, KdSendPacket)
#endif

//
// KdpRetryCount controls the number of retries before we give
// up and assume kernel debugger is not present.
// KdpNumberRetries is the number of retries left.  Initially,
// it is set to 5 such that booting NT without debugger won't be
// delayed to long.
//
ULONG KdCompNumberRetries = 5;
ULONG KdCompRetryCount = 5;

ULONG KdPacketId = 0;

ULONG
KdpComputeChecksum(
    IN PUCHAR   Buffer,
    IN ULONG    Length
    )
/*++

Routine Description:

    This routine computes the checksum for the string passed in.

Arguments:

    Buffer - Supplies a pointer to the string.

    Length - Supplies the length of the string.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/
{
    ULONG   Checksum = 0;

    while (Length > 0) {

        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }

    return(Checksum);
} // KdpComputeChecksum

void
KdpSendControlPacket(
    IN USHORT   PacketType,
    IN ULONG    PacketId OPTIONAL
    )
/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/
{
    KD_PACKET   PacketHeader;

    //
    // Initialize and send the packet header.
    //
    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;

    if (ARGUMENT_PRESENT((PVOID)(ULONG_PTR)PacketId)) {

        PacketHeader.PacketId = PacketId;
    }
    PacketHeader.PacketId = 0;
    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;

    // setup our send packet
    RtlZeroMemory(&Kd1394Data->SendPacket, sizeof(DEBUG_1394_SEND_PACKET));
    Kd1394Data->SendPacket.Length = 0;

    RtlCopyMemory( &Kd1394Data->SendPacket.PacketHeader[0],
                   &PacketHeader,
                   sizeof(KD_PACKET)
                   );

    Kd1394Data->SendPacket.TransferStatus = STATUS_PENDING;

    return;
} // KdpSendControlPacket

ULONG
KdReceivePacket(
    IN ULONG            PacketType,
    OUT PSTRING         MessageHeader,
    OUT PSTRING         MessageData,
    OUT PULONG          DataLength,
    IN OUT PKD_CONTEXT  KdContext
    )
/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is KdPrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    KDP_PACKET_RESEND - if resend is required.  = 2 = CP_GET_ERROR
    KDP_PACKET_TIMEOUT - if timeout.            = 1 = CP_GET_NODATA
    KDP_PACKET_RECEIVED - if packet received.   = 0 = CP_GET_SUCCESS

--*/
{
    UCHAR       Input;
    ULONG       MessageLength;
    KD_PACKET   PacketHeader;
    ULONG       ReturnCode;
    ULONG       Checksum;
    ULONG       Status;

// this dispatch gets called with PacketType != PACKET_TYPE_KD_POLL_BREAKIN for
// the number of times specified in KdCompNumberRetries (??). if we always timeout
// then we'll get called with PacketType == PACKET_TYPE_KD_POLL_BREAKIN

    // make sure our link is enabled..
    Dbg1394_EnablePhysicalAccess(Kd1394Data);

    //
    // Just check for breakin packet and return
    //
    if (PacketType == PACKET_TYPE_KD_POLL_BREAKIN) {

        // let's peak into our receive packet and see if it's a breakin
        if ((Kd1394Data->ReceivePacket.TransferStatus == STATUS_PENDING) &&
            (Kd1394Data->ReceivePacket.Packet[0] == BREAKIN_PACKET_BYTE)) {

            *KdDebuggerNotPresent = FALSE;
            SharedUserData->KdDebuggerEnabled |= 0x00000002;

            // we have a breakin packet
            Kd1394Data->ReceivePacket.TransferStatus = STATUS_SUCCESS;
            return(KDP_PACKET_RECEIVED);
        }
        else {

            return(KDP_PACKET_TIMEOUT);
        }
    }

WaitForPacketLeader:

    // read in our packet, if available...
    ReturnCode = Dbg1394_ReadPacket( Kd1394Data,
                                     &PacketHeader,
                                     MessageHeader,
                                     MessageData,
                                     TRUE
                                     );


    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //
    if (ReturnCode != KDP_PACKET_TIMEOUT) {

        KdCompNumberRetries = KdCompRetryCount;
    }

    if (ReturnCode != KDP_PACKET_RECEIVED) {

        // see if it's a breakin packet...
        if ((PacketHeader.PacketLeader & 0xFF) == BREAKIN_PACKET_BYTE) {

            KdContext->KdpControlCPending = TRUE;
            return(KDP_PACKET_RESEND);
        }

        return(ReturnCode);
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //
    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
        PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {

        return(KDP_PACKET_RESEND);
    }

    //
    // Check ByteCount received is valid
    //
    MessageLength = MessageHeader->MaximumLength;

    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {

        goto SendResendPacket;
    }
    *DataLength = PacketHeader.ByteCount - MessageLength;

    MessageData->Length = (USHORT)*DataLength;
    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Check PacketType is what we are waiting for.
    //
    if (PacketType != PacketHeader.PacketType) {

        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //
    Checksum = KdpComputeChecksum(MessageHeader->Buffer, MessageHeader->Length);
    Checksum += KdpComputeChecksum(MessageData->Buffer, MessageData->Length);

    if (Checksum != PacketHeader.Checksum) {

        goto SendResendPacket;
    }

    return(KDP_PACKET_RECEIVED);

SendResendPacket:

    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
} // KdReceivePacket

void
KdSendPacket(
    IN ULONG            PacketType,
    IN PSTRING          MessageHeader,
    IN PSTRING          MessageData OPTIONAL,
    IN OUT PKD_CONTEXT  KdContext
    )
/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    None.

--*/
{
    KD_PACKET                   PacketHeader;
    ULONG                       MessageDataLength;
    ULONG                       ReturnCode;
    PDBGKD_DEBUG_IO             DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64  StateChange;
    PDBGKD_FILE_IO              FileIo;
    BOOLEAN                     bException = FALSE;

    PacketHeader.Checksum = 0;

    if (ARGUMENT_PRESENT(MessageData)) {

        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = KdpComputeChecksum(MessageData->Buffer, MessageData->Length);
    }
    else {

        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += KdpComputeChecksum(MessageHeader->Buffer, MessageHeader->Length);

    //
    // Initialize and send the packet header.
    //
    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;

    PacketHeader.PacketId = KdPacketId;

    KdPacketId++;

    KdCompNumberRetries = KdCompRetryCount;

    // setup our send packet
    RtlZeroMemory(&Kd1394Data->SendPacket, sizeof(DEBUG_1394_SEND_PACKET));
    Kd1394Data->SendPacket.Length = 0;

    // copy our packet header...
    RtlCopyMemory( &Kd1394Data->SendPacket.PacketHeader[0],
                   &PacketHeader,
                   sizeof(KD_PACKET)
                   );

    // setup our message header
    if (MessageHeader) {

        RtlCopyMemory( &Kd1394Data->SendPacket.Packet[0],
                       MessageHeader->Buffer,
                       MessageHeader->Length
                       );

        Kd1394Data->SendPacket.Length += MessageHeader->Length;
    }

    // setup our message data
    if (ARGUMENT_PRESENT(MessageData)) {

        RtlCopyMemory( &Kd1394Data->SendPacket.Packet[Kd1394Data->SendPacket.Length],
                       MessageData->Buffer,
                       MessageData->Length
                       );

        Kd1394Data->SendPacket.Length += MessageData->Length;
    }

    Kd1394Data->SendPacket.TransferStatus = STATUS_PENDING;

    do {

        // make sure our link is enabled..
        Dbg1394_EnablePhysicalAccess(Kd1394Data);

        if (KdCompNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //
            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {

                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;

                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {

                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;

                    Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;
                    return;
                }
            }
            else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {

                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;

                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {

                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;

                    Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;
                    return;
                }
            }
            else if (PacketType == PACKET_TYPE_KD_FILE_IO) {
                
                FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;

                if (FileIo->ApiNumber == DbgKdCreateFileApi) {

                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;

                    Kd1394Data->SendPacket.TransferStatus = STATUS_SUCCESS;
                    return;
                }
            }
            else {

                bException = TRUE;
            }
        }

        ReturnCode = KDP_PACKET_TIMEOUT;

        {
            ULONG                   count = 0;
            volatile NTSTATUS       *pStatus;

            pStatus = &Kd1394Data->ReceivePacket.TransferStatus;

            //
            // now sit here and poll for a response from the target machine
            //
            do {

                // make sure our link is enabled..
                Dbg1394_EnablePhysicalAccess(Kd1394Data);

                //
                // while in this loop check if the host layed in a request.
                // If they did, mark it read and double buffer it
                //
                count++;
                if (Kd1394Data->SendPacket.TransferStatus != STATUS_PENDING) {

                    ReturnCode = KDP_PACKET_RECEIVED;
                    break;
                }

                if ((*pStatus == STATUS_PENDING) && (!bException)) {

                    ReturnCode = KDP_PACKET_RECEIVED;
                    break;
                }

            } while (count < TIMEOUT_COUNT);
        }

        if (ReturnCode == KDP_PACKET_TIMEOUT) {

            KdCompNumberRetries--;
        }

    } while (ReturnCode != KDP_PACKET_RECEIVED);

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //
    KdCompRetryCount = KdContext->KdpDefaultRetries;

    return;
} // KdSendPacket
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kdcom\kdcomio.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    kdcomio.c

Abstract:

    This module implements the I/O comunications for the portable kernel
    debugger.

Author:

    David N. Cutler 27-July-1990

Revision History:

--*/

#include "kdcomp.h"


ULONG
KdpComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    );

ULONG
KdpReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    );

VOID
KdpSendString (
    IN PCHAR Source,
    IN ULONG Length
    );

VOID
KdpSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEKD, KdpComputeChecksum)
#pragma alloc_text(PAGEKD, KdCompReceivePacketLeader)
#pragma alloc_text(PAGEKD, KdpReceiveString)
#pragma alloc_text(PAGEKD, KdpSendString)
#pragma alloc_text(PAGEKD, KdpSendControlPacket)
#pragma alloc_text(PAGEKD, KdReceivePacket)
#pragma alloc_text(PAGEKD, KdSendPacket)
#endif

ULONG KdCompPacketIdExpected = 0;
ULONG KdCompNextPacketIdToSend = 0;

//
// KdpRetryCount controls the number of retries before we give
// up and assume kernel debugger is not present.
// KdpNumberRetries is the number of retries left.  Initially,
// it is set to 5 such that booting NT without debugger won't be
// delayed to long.
//
ULONG KdCompNumberRetries = 5;
ULONG KdCompRetryCount = 5;


ULONG
KdpComputeChecksum (
    IN PUCHAR Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine computes the checksum for the string passed in.

Arguments:

    Buffer - Supplies a pointer to the string.

    Length - Supplies the length of the string.

Return Value:

    A ULONG is return as the checksum for the input string.

--*/

{

    ULONG Checksum = 0;

    while (Length > 0) {
        Checksum = Checksum + (ULONG)*Buffer++;
        Length--;
    }
    return Checksum;
}

USHORT
KdCompReceivePacketLeader (
    IN ULONG PacketType,
    OUT PULONG PacketLeader,
    IN OUT PKD_CONTEXT KdContext
    )

/*++

Routine Description:

    This routine waits for a packet header leader.

Arguments:

    PacketType - supplies the type of packet we are expecting.

    PacketLeader - supplies a pointer to a ulong variable to receive
                   packet leader bytes.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input, PreviousByte = 0;
    ULONG PacketId = 0;
    ULONG Index;
    ULONG ReturnCode;
    BOOLEAN BreakinDetected = FALSE;

    //
    // NOTE - With all the interrupts being off, it is very hard
    // to implement the actual timeout code. (Maybe, by reading the CMOS.)
    // Here we use a loop count to wait about 3 seconds.  The CpGetByte
    // will return with error code = CP_GET_NODATA if it cannot find data
    // byte within 1 second. Kernel debugger's timeout period is 5 seconds.
    //

    Index = 0;
    do {
        ReturnCode = KdCompGetByte(&Input);
        if (ReturnCode == CP_GET_NODATA) {
            if (BreakinDetected) {
                KdContext->KdpControlCPending = TRUE;
                return KDP_PACKET_RESEND;
            } else {
                return KDP_PACKET_TIMEOUT;
            }
        } else if (ReturnCode == CP_GET_ERROR) {
            Index = 0;
            continue;
        } else {                    // if (ReturnCode == CP_GET_SUCCESS)
            if ( Input == PACKET_LEADER_BYTE ||
                 Input == CONTROL_PACKET_LEADER_BYTE ) {
                if ( Index == 0 ) {
                    PreviousByte = Input;
                    Index++;
                } else if (Input == PreviousByte ) {
                    Index++;
                } else {
                    PreviousByte = Input;
                    Index = 1;
                }
            } else {

                //
                // If we detect breakin character, we need to verify it
                // validity.  (It is possible that we missed a packet leader
                // and the breakin character is simply a data byte in the
                // packet.)
                // Since kernel debugger send out breakin character ONLY
                // when it is waiting for State Change packet.  The breakin
                // character should not be followed by any other character
                // except packet leader byte.
                //

                if ( Input == BREAKIN_PACKET_BYTE ) {
                    BreakinDetected = TRUE;
                } else {

                    //
                    // The following statement is ABSOLUTELY necessary.
                    //

                    BreakinDetected = FALSE;
                }
                Index = 0;
            }
        }
    } while ( Index < 4 );

    if (BreakinDetected) {
        KdContext->KdpControlCPending = TRUE;
    }

    //
    // return the packet leader and FALSE to indicate no resend is needed.
    //

    if ( Input == PACKET_LEADER_BYTE ) {
        *PacketLeader = PACKET_LEADER;
    } else {
        *PacketLeader = CONTROL_PACKET_LEADER;
    }

    *KdDebuggerNotPresent = FALSE;
    SharedUserData->KdDebuggerEnabled |= 0x00000002;
    return KDP_PACKET_RECEIVED;
}

ULONG
KdpReceiveString (
    OUT PCHAR Destination,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine reads a string from the kernel debugger port.

Arguments:

    Destination - Supplies a pointer to the input string.

    Length - Supplies the length of the string to be read.

Return Value:

    CP_GET_SUCCESS is returned if string is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{

    UCHAR Input;
    ULONG ReturnCode;

    //
    // Read bytes until either a error is encountered or the entire string
    // has been read.
    //
    while (Length > 0) {
        ReturnCode = KdCompGetByte(&Input);
        if (ReturnCode != CP_GET_SUCCESS) {
            return ReturnCode;
        } else {
            *Destination++ = Input;
            Length -= 1;
        }
    }
    return CP_GET_SUCCESS;
}

VOID
KdpSendString (
    IN PCHAR Source,
    IN ULONG Length
    )

/*++

Routine Description:

    This routine writes a string to the kernel debugger port.

Arguments:

    Source - Supplies a pointer to the output string.

    Length - Supplies the length of the string to be written.

Return Value:

    None.

--*/

{

    UCHAR Output;

    //
    // Write bytes to the kernel debugger port.
    //

    while (Length > 0) {
        Output = *Source++;
        KdCompPutByte(Output);
        Length -= 1;
    }
    return;
}

VOID
KdpSendControlPacket (
    IN USHORT PacketType,
    IN ULONG PacketId OPTIONAL
    )

/*++

Routine Description:

    This routine sends a control packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    PacketId - Supplies packet id, optionally.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = CONTROL_PACKET_LEADER;
    if (ARGUMENT_PRESENT( (PVOID)(ULONG_PTR) PacketId )) {
        PacketHeader.PacketId = PacketId;
    }
    PacketHeader.ByteCount = 0;
    PacketHeader.Checksum = 0;
    PacketHeader.PacketType = PacketType;
    KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

    return;
}

ULONG
KdReceivePacket (
    IN ULONG PacketType,
    OUT PSTRING MessageHeader,
    OUT PSTRING MessageData,
    OUT PULONG DataLength,
    IN OUT PKD_CONTEXT KdContext
    )

/*++

Routine Description:

    This routine receives a packet from the host machine that is running
    the kernel debugger UI.  This routine is ALWAYS called after packet being
    sent by caller.  It first waits for ACK packet for the packet sent and
    then waits for the packet desired.

    N.B. If caller is KdPrintString, the parameter PacketType is
       PACKET_TYPE_KD_ACKNOWLEDGE.  In this case, this routine will return
       right after the ack packet is received.

Arguments:

    PacketType - Supplies the type of packet that is excepted.

    MessageHeader - Supplies a pointer to a string descriptor for the input
        message.

    MessageData - Supplies a pointer to a string descriptor for the input data.

    DataLength - Supplies pointer to ULONG to receive length of recv. data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    KDP_PACKET_RESEND - if resend is required.
    KDP_PAKCET_TIMEOUT - if timeout.
    KDP_PACKET_RECEIVED - if packet received.

--*/

{

    UCHAR Input;
    ULONG MessageLength;
    KD_PACKET PacketHeader;
    ULONG ReturnCode;
    ULONG Checksum;
    ULONG Status;

    //
    // Just check for breakin packet and return
    //
    if (PacketType == PACKET_TYPE_KD_POLL_BREAKIN) {
        Status = KdCompPollByte(&Input);
        return ((Status == CP_GET_SUCCESS) && (Input == BREAKIN_PACKET_BYTE)) ?
            KDP_PACKET_RECEIVED: KDP_PACKET_TIMEOUT;
    }

WaitForPacketLeader:

    //
    // Read Packet Leader
    //

    ReturnCode = KdCompReceivePacketLeader(PacketType, &PacketHeader.PacketLeader, KdContext);

    //
    // If we can successfully read packet leader, it has high possibility that
    // kernel debugger is alive.  So reset count.
    //

    if (ReturnCode != KDP_PACKET_TIMEOUT) {
        KdCompNumberRetries = KdCompRetryCount;
    }
    if (ReturnCode != KDP_PACKET_RECEIVED) {
        return ReturnCode;
    }

    //
    // Read packet type.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketType,
                                  sizeof(PacketHeader.PacketType));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {

            //
            // If read error and it is for a control packet, simply
            // preptend that we have not seen this packet.  Hopefully
            // we will receive the packet we desire which automatically acks
            // the packet we just sent.
            //

            goto WaitForPacketLeader;
        } else {

            //
            // if read error while reading data packet, we have to ask
            // kernel debugger to resend us the packet.
            //

            goto SendResendPacket;
        }
    }

    //
    // if the packet we received is a resend request, we return true and
    // let caller resend the packet.
    //

    if ( PacketHeader.PacketLeader == CONTROL_PACKET_LEADER &&
         PacketHeader.PacketType == PACKET_TYPE_KD_RESEND ) {
        return KDP_PACKET_RESEND;
    }

    //
    // Read data length.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.ByteCount,
                                  sizeof(PacketHeader.ByteCount));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read Packet Id.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.PacketId,
                                  sizeof(PacketHeader.PacketId));

    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // Read packet checksum.
    //

    ReturnCode = KdpReceiveString((PCHAR)&PacketHeader.Checksum,
                                  sizeof(PacketHeader.Checksum));
    if (ReturnCode == CP_GET_NODATA) {
        return KDP_PACKET_TIMEOUT;
    } else if (ReturnCode == CP_GET_ERROR) {
        if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER) {
            goto WaitForPacketLeader;
        } else {
            goto SendResendPacket;
        }
    }

    //
    // A complete packet header is received.  Check its validity and
    // perform appropriate action depending on packet type.
    //

    if (PacketHeader.PacketLeader == CONTROL_PACKET_LEADER ) {
        if (PacketHeader.PacketType == PACKET_TYPE_KD_ACKNOWLEDGE ) {

            //
            // If we received an expected ACK packet and we are not
            // waiting for any new packet, update outgoing packet id
            // and return.  If we are NOT waiting for ACK packet
            // we will keep on waiting.  If the ACK packet
            // is not for the packet we send, ignore it and keep on waiting.
            //

            if (PacketHeader.PacketId !=
                (KdCompNextPacketIdToSend & ~SYNC_PACKET_ID))  {
                goto WaitForPacketLeader;
            } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {
                KdCompNextPacketIdToSend ^= 1;
                return KDP_PACKET_RECEIVED;
            } else {
                goto WaitForPacketLeader;
            }
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESET) {

            //
            // if we received Reset packet, reset the packet control variables
            // and resend earlier packet.
            //

            KdCompNextPacketIdToSend = INITIAL_PACKET_ID;
            KdCompPacketIdExpected = INITIAL_PACKET_ID;
            KdpSendControlPacket(PACKET_TYPE_KD_RESET, 0L);
            return KDP_PACKET_RESEND;
        } else if (PacketHeader.PacketType == PACKET_TYPE_KD_RESEND) {
            return KDP_PACKET_RESEND;
        } else {

            //
            // Invalid packet header, ignore it.
            //

            goto WaitForPacketLeader;
        }

    //
    // The packet header is for data packet (not control packet).
    //

    } else if (PacketType == PACKET_TYPE_KD_ACKNOWLEDGE) {

        //
        // if we are waiting for ACK packet ONLY
        // and we receive a data packet header, check if the packet id
        // is what we expected.  If yes, assume the acknowledge is lost (but
        // sent), ask sender to resend and return with PACKET_RECEIVED.
        //

        if (PacketHeader.PacketId == KdCompPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
            KdCompNextPacketIdToSend ^= 1;
            return KDP_PACKET_RECEIVED;
        } else {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    }

    //
    // we are waiting for data packet and we received the packet header
    // for data packet. Perform the following checkings to make sure
    // it is the packet we are waiting for.
    //

    //
    // Check ByteCount received is valid
    //

    MessageLength = MessageHeader->MaximumLength;
    if ((PacketHeader.ByteCount > (USHORT)PACKET_MAX_SIZE) ||
        (PacketHeader.ByteCount < (USHORT)MessageLength)) {
        goto SendResendPacket;
    }
    *DataLength = PacketHeader.ByteCount - MessageLength;

    //
    // Read the message header.
    //

    ReturnCode = KdpReceiveString(MessageHeader->Buffer, MessageLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageHeader->Length = (USHORT)MessageLength;

    //
    // Read the message data.
    //

    ReturnCode = KdpReceiveString(MessageData->Buffer, *DataLength);
    if (ReturnCode != CP_GET_SUCCESS) {
        goto SendResendPacket;
    }
    MessageData->Length = (USHORT)*DataLength;

    //
    // Read packet trailing byte
    //

    ReturnCode = KdCompGetByte(&Input);
    if (ReturnCode != CP_GET_SUCCESS || Input != PACKET_TRAILING_BYTE) {
        goto SendResendPacket;
    }

    //
    // Check PacketType is what we are waiting for.
    //

    if (PacketType != PacketHeader.PacketType) {
        KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                             PacketHeader.PacketId
                             );
        goto WaitForPacketLeader;
    }

    //
    // Check PacketId is valid.
    //

    if (PacketHeader.PacketId == INITIAL_PACKET_ID ||
        PacketHeader.PacketId == (INITIAL_PACKET_ID ^ 1)) {
        if (PacketHeader.PacketId != KdCompPacketIdExpected) {
            KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                                 PacketHeader.PacketId
                                 );
            goto WaitForPacketLeader;
        }
    } else {
        goto SendResendPacket;
    }

    //
    // Check checksum is valid.
    //

    Checksum = KdpComputeChecksum(
                            MessageHeader->Buffer,
                            MessageHeader->Length
                            );

    Checksum += KdpComputeChecksum(
                            MessageData->Buffer,
                            MessageData->Length
                            );
    if (Checksum != PacketHeader.Checksum) {
        goto SendResendPacket;
    }

    //
    // Send Acknowledge byte and the Id of the packet received.
    // Then, update the ExpectId for next incoming packet.
    //

    KdpSendControlPacket(PACKET_TYPE_KD_ACKNOWLEDGE,
                         PacketHeader.PacketId
                         );

    //
    // We have successfully received the packet so update the
    // packet control variables and return sucess.
    //

    KdCompPacketIdExpected ^= 1;
    return KDP_PACKET_RECEIVED;

SendResendPacket:
    KdpSendControlPacket(PACKET_TYPE_KD_RESEND, 0L);
    goto WaitForPacketLeader;
}

VOID
KdSendPacket (
    IN ULONG PacketType,
    IN PSTRING MessageHeader,
    IN PSTRING MessageData OPTIONAL,
    IN OUT PKD_CONTEXT KdContext
    )

/*++

Routine Description:

    This routine sends a packet to the host machine that is running the
    kernel debugger and waits for an ACK.

Arguments:

    PacketType - Supplies the type of packet to send.

    MessageHeader - Supplies a pointer to a string descriptor that describes
        the message information.

    MessageData - Supplies a pointer to a string descriptor that describes
        the optional message data.

    KdContext - Supplies a pointer to the kernel debugger context.

Return Value:

    None.

--*/

{

    KD_PACKET PacketHeader;
    ULONG MessageDataLength;
    ULONG ReturnCode;
    PDBGKD_DEBUG_IO DebugIo;
    PDBGKD_WAIT_STATE_CHANGE64 StateChange;

    if ( ARGUMENT_PRESENT(MessageData) ) {
        MessageDataLength = MessageData->Length;
        PacketHeader.Checksum = KdpComputeChecksum(
                                        MessageData->Buffer,
                                        MessageData->Length
                                        );
    } else {
        MessageDataLength = 0;
        PacketHeader.Checksum = 0;
    }

    PacketHeader.Checksum += KdpComputeChecksum (
                                    MessageHeader->Buffer,
                                    MessageHeader->Length
                                    );

    //
    // Initialize and send the packet header.
    //

    PacketHeader.PacketLeader = PACKET_LEADER;
    PacketHeader.ByteCount = (USHORT)(MessageHeader->Length + MessageDataLength);
    PacketHeader.PacketType = (USHORT)PacketType;
    KdCompNumberRetries = KdCompRetryCount;
    do {
        if (KdCompNumberRetries == 0) {

            //
            // If the packet is not for reporting exception, we give up
            // and declare debugger not present.
            //

            if (PacketType == PACKET_TYPE_KD_DEBUG_IO) {
                DebugIo = (PDBGKD_DEBUG_IO)MessageHeader->Buffer;
                if (DebugIo->ApiNumber == DbgKdPrintStringApi) {
                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;
                    KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdCompPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_STATE_CHANGE64) {
                StateChange = (PDBGKD_WAIT_STATE_CHANGE64)MessageHeader->Buffer;
                if (StateChange->NewState == DbgKdLoadSymbolsStateChange) {
                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;
                    KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdCompPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            } else if (PacketType == PACKET_TYPE_KD_FILE_IO) {
                PDBGKD_FILE_IO FileIo;
                
                FileIo = (PDBGKD_FILE_IO)MessageHeader->Buffer;
                if (FileIo->ApiNumber == DbgKdCreateFileApi) {
                    *KdDebuggerNotPresent = TRUE;
                    SharedUserData->KdDebuggerEnabled &= ~0x00000002;
                    KdCompNextPacketIdToSend = INITIAL_PACKET_ID | SYNC_PACKET_ID;
                    KdCompPacketIdExpected = INITIAL_PACKET_ID;
                    return;
                }
            }
        }

        //
        // Setting PacketId has to be in the do loop in case Packet Id was
        // reset.
        //

        PacketHeader.PacketId = KdCompNextPacketIdToSend;
        KdpSendString((PCHAR)&PacketHeader, sizeof(KD_PACKET));

        //
        // Output message header.
        //

        KdpSendString(MessageHeader->Buffer, MessageHeader->Length);

        //
        // Output message data.
        //

        if ( MessageDataLength ) {
            KdpSendString(MessageData->Buffer, MessageData->Length);
        }

        //
        // Output a packet trailing byte
        //

        KdCompPutByte(PACKET_TRAILING_BYTE);

        //
        // Wait for the Ack Packet
        //

        ReturnCode = KdReceivePacket(
                         PACKET_TYPE_KD_ACKNOWLEDGE,
                         NULL,
                         NULL,
                         NULL,
                         KdContext
                         );
        if (ReturnCode == KDP_PACKET_TIMEOUT) {
            KdCompNumberRetries--;
        }
    } while (ReturnCode != KDP_PACKET_RECEIVED);

    //
    // Reset Sync bit in packet id.  The packet we sent may have Sync bit set
    //

    KdCompNextPacketIdToSend &= ~SYNC_PACKET_ID;

    //
    // Since we are able to talk to debugger, the retrycount is set to
    // maximum value.
    //

    KdCompRetryCount = KdContext->KdpDefaultRetries;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kdcom\sources.inc ===
MAJORCOMP=ntos
MINORCOMP=kdcom

TARGETNAME=kdcom
TARGETPATH=obj

TARGETLIBS=$(DDK_LIB_PATH)\hal.lib

MSC_WARNING_LEVEL=/W3 /WX

INCLUDES=..\..\..\ntos\inc;        \
         $(SDKTOOLS_INC_PATH);  \
         $(HALKIT_INC_PATH)

C_DEFINES=$(C_DEFINES) -DACPI_HAL

SOURCES=..\kdcom.rc  \
        ..\kdcom.c   \
        ..\kdcomio.c \
        ..\ixkdcom.c \
        ..\xxkdsup.c

# Turn off speculation in this module so debugger
# does not wipe out all the interupt history with
# speculation faults.
IA64_DEBUGGABLE_OPTIMIZATION=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blacpi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation
All rights reserved

Module Name:

    acpisetd.c

Abstract:

    This module detects an ACPI system.  It
    is included into setup so that setup
    can figure out which HAL to load

Author:

    Jake Oshins (jakeo) - August 24, 2000.

Environment:

    Textmode setup.

Revision History:

    split from i386\acpidtct.c so that the code could be used on IA64
    

--*/

#include "bootlib.h"
#include "stdlib.h"
#include "string.h"
#include "acpitabl.h"

VOID
BlFindRsdp (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blbindt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blbind.c

Abstract:

    This module contains the code that implements the funtions required
    to relocate an image and bind DLL entry points.

Author:

    David N. Cutler (davec) 21-May-1991

Revision History:

    Forrest Foltz (forrestf) 10-Jun-2000

        Broke out x86 32/64 code into this module

--*/

#if defined(_X86AMD64_)
//
// warning 4305 is "typecast truncation"
// right now, the amd64 code grabs certain 64 bit definitions, 
// but is compiled for 32 bit.  as a result, a pointer here
// is only 32 bits, but there are definitions for 64 bit 
// structures.  ignore these for now, but amd64 should really 
// have it's own headers for these structures
//
#pragma warning(disable:4305)
#endif

//
// Define local procedure prototypes.
//

ARC_STATUS
BlpScanImportAddressTable(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkNameTable,
    IN PIMAGE_THUNK_DATA ThunkAddressTable
    );

ARC_STATUS
BlpBindImportName (
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkNameEntry,
    IN PIMAGE_THUNK_DATA ThunkAddressEntry,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN SnapForwarder
    );


ARC_STATUS
BlAllocateDataTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID Base,
    OUT PKLDR_DATA_TABLE_ENTRY *AllocatedEntry
    )

/*++

Routine Description:

    This routine allocates a data table entry for the specified image
    and inserts the entry in the loaded module list.

Arguments:

    BaseDllName - Supplies a pointer to a zero terminated base DLL name.

    FullDllName - Supplies a pointer to a zero terminated full DLL name.

    Base - Supplies a pointer to the base of the DLL image.

    AllocatedEntry - Supplies a pointer to a variable that receives a
        pointer to the allocated data table entry.

Return Value:

    ESUCCESS is returned if a data table entry is allocated. Otherwise,
    return a unsuccessful status.

--*/

{

    PWSTR Buffer;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PIMAGE_NT_HEADERS NtHeaders;
    USHORT Length;

    //
    // Allocate a data table entry.
    //

    DataTableEntry =
            (PKLDR_DATA_TABLE_ENTRY)BlAllocateHeap(sizeof(KLDR_DATA_TABLE_ENTRY));

    if (DataTableEntry == NULL) {
        return ENOMEM;
    }

    //
    // Initialize the address of the DLL image file header and the entry
    // point address.
    //

    NtHeaders = IMAGE_NT_HEADER(Base);
    DataTableEntry->DllBase = Base;
    DataTableEntry->SizeOfImage = NtHeaders->OptionalHeader.SizeOfImage;
    DataTableEntry->EntryPoint = (PVOID)((ULONG_PTR)Base +
                              NtHeaders->OptionalHeader.AddressOfEntryPoint);
    DataTableEntry->SectionPointer = 0;
    DataTableEntry->CheckSum = NtHeaders->OptionalHeader.CheckSum;

    //
    // Compute the length of the base DLL name, allocate a buffer to hold
    // the name, copy the name into the buffer, and initialize the base
    // DLL string descriptor.
    //

    Length = (USHORT)(strlen(BaseDllName) * sizeof(WCHAR));
    Buffer = (PWSTR)BlAllocateHeap(Length);
    if (Buffer == NULL) {
        return ENOMEM;
    }

    DataTableEntry->BaseDllName.Length = Length;
    DataTableEntry->BaseDllName.MaximumLength = Length;
    DataTableEntry->BaseDllName.Buffer = Buffer;
    while (*BaseDllName != 0) {
        *Buffer++ = *BaseDllName++;
    }

    //
    // Compute the length of the full DLL name, allocate a buffer to hold
    // the name, copy the name into the buffer, and initialize the full
    // DLL string descriptor.
    //

    Length = (USHORT)(strlen(FullDllName) * sizeof(WCHAR));
    Buffer = (PWSTR)BlAllocateHeap(Length);
    if (Buffer == NULL) {
        return ENOMEM;
    }

    DataTableEntry->FullDllName.Length = Length;
    DataTableEntry->FullDllName.MaximumLength = Length;
    DataTableEntry->FullDllName.Buffer = Buffer;
    while (*FullDllName != 0) {
        *Buffer++ = *FullDllName++;
    }

    //
    // Initialize the flags, load count, and insert the data table entry
    // in the loaded module list.
    //

    DataTableEntry->Flags = LDRP_ENTRY_PROCESSED;
    DataTableEntry->LoadCount = 1;
    InsertTailList(&BlLoaderBlock->LoadOrderListHead,
                   &DataTableEntry->InLoadOrderLinks);

    *AllocatedEntry = DataTableEntry;
    return ESUCCESS;
}

ARC_STATUS
BlAllocateFirmwareTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID Base,
    IN ULONG Size,
    OUT PKLDR_DATA_TABLE_ENTRY *AllocatedEntry
    )

/*++

Routine Description:

    This routine allocates a firmware table entry for the specified image
    and inserts the entry in the loaded module list.

Arguments:

    BaseDllName - Supplies a pointer to a zero terminated base DLL name.

    FullDllName - Supplies a pointer to a zero terminated full DLL name.

    Base - Supplies a pointer to the base of the DLL image.

    Size - Supplies how big the image is.

    AllocatedEntry - Supplies a pointer to a variable that receives a
        pointer to the allocated data table entry.

Return Value:

    ESUCCESS is returned if a data table entry is allocated. Otherwise,
    return a unsuccessful status.

--*/
{
    PWSTR Buffer;
    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    USHORT Length;

    //
    // Allocate a data table entry.
    //

    DataTableEntry =
            (PKLDR_DATA_TABLE_ENTRY)BlAllocateHeap(sizeof(KLDR_DATA_TABLE_ENTRY));

    if (DataTableEntry == NULL) {
        return ENOMEM;
    }

    //
    // Initialize the address of the firmware image
    //
    DataTableEntry->DllBase = Base;
    DataTableEntry->SizeOfImage = Size;
    DataTableEntry->EntryPoint = Base;
    DataTableEntry->SectionPointer = 0;
    DataTableEntry->CheckSum = 0;

    //
    // Compute the length of the base DLL name, allocate a buffer to hold
    // the name, copy the name into the buffer, and initialize the base
    // DLL string descriptor.
    //
    Length = (USHORT)(strlen(BaseDllName) * sizeof(WCHAR));
    Buffer = (PWSTR)BlAllocateHeap(Length);
    if (Buffer == NULL) {
        return ENOMEM;
    }

    DataTableEntry->BaseDllName.Length = Length;
    DataTableEntry->BaseDllName.MaximumLength = Length;
    DataTableEntry->BaseDllName.Buffer = Buffer;
    while (*BaseDllName != 0) {
        *Buffer++ = *BaseDllName++;
    }

    //
    // Compute the length of the full DLL name, allocate a buffer to hold
    // the name, copy the name into the buffer, and initialize the full
    // DLL string descriptor.
    //

    Length = (USHORT)(strlen(FullDllName) * sizeof(WCHAR));
    Buffer = (PWSTR)BlAllocateHeap(Length);
    if (Buffer == NULL) {
        return ENOMEM;
    }

    DataTableEntry->FullDllName.Length = Length;
    DataTableEntry->FullDllName.MaximumLength = Length;
    DataTableEntry->FullDllName.Buffer = Buffer;
    while (*FullDllName != 0) {
        *Buffer++ = *FullDllName++;
    }

    //
    // Initialize the flags, load count, and insert the data table entry
    // in the loaded module list.
    //

    DataTableEntry->Flags = LDRP_ENTRY_PROCESSED;
    DataTableEntry->LoadCount = 1;
    InsertTailList(&BlLoaderBlock->Extension->FirmwareDescriptorListHead,
                   &DataTableEntry->InLoadOrderLinks);

    *AllocatedEntry = DataTableEntry;
    return ESUCCESS;
}

ARC_STATUS
BlpBindImportName (
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkNameEntry,
    IN PIMAGE_THUNK_DATA ThunkAddressEntry,
    IN PIMAGE_EXPORT_DIRECTORY ExportDirectory,
    IN ULONG ExportSize,
    IN BOOLEAN SnapForwarder
    )

/*++

Routine Description:

    This routine binds an import table reference with an exported entry
    point and fills in the thunk data.

Arguments:

    DllBase - Supplies the base address of the DLL image that contains
        the export directory.  On x86 systems, a NULL DllBase binds the
        import table reference to the OsLoader's exported entry points.

    ImageBase - Supplies the base address of the image that contains
        the import thunk table.

    ThunkNameEntry - Supplies a pointer to a thunk table name entry.

    ThunkAddressEntry - Supplies a pointer to a thunk table address entry.

    ExportDirectory - Supplies a pointer to the export directory of the
        DLL from which references are to be resolved.

    SnapForwarder - determine if the snap is for a forwarder, and therefore
       Address of Data is already setup.

Return Value:

    ESUCCESS is returned if the specified thunk is bound. Otherwise, an
    return an unsuccessful status.

--*/

{

    PULONG FunctionTable;
    LONG High;
    ULONG HintIndex;
    LONG Low;
    LONG Middle = 0;
    PULONG NameTable;
    ULONG Ordinal;
    PUSHORT OrdinalTable;
    LONG Result;
    PCHAR Temp;

#if defined(_X86_)

    if(DllBase == NULL) {
        DllBase = (PVOID)OsLoaderBase;
    }

#endif

    //
    // If the reference is by ordinal, then compute the ordinal number.
    // Otherwise, lookup the import name in the export directory.
    //

    if (IMAGE_SNAP_BY_ORDINAL(ThunkNameEntry->u1.Ordinal) && !SnapForwarder) {

        //
        // Compute the ordinal.
        //

        Ordinal = (ULONG)(IMAGE_ORDINAL(ThunkNameEntry->u1.Ordinal) - ExportDirectory->Base);

    } else {

        if (!SnapForwarder) {
            //
            // Change AddressOfData from an RVA to a VA.
            //

            ThunkNameEntry->u1.AddressOfData = ((ULONG_PTR)ImageBase + ThunkNameEntry->u1.AddressOfData);
        }

        //
        // Lookup the import name in the export table to determine the
        // ordinal.
        //

        NameTable = (PULONG)((ULONG_PTR)DllBase +
                                          ExportDirectory->AddressOfNames);

        OrdinalTable = (PUSHORT)((ULONG_PTR)DllBase +
                                          ExportDirectory->AddressOfNameOrdinals);

        //
        // If the hint index is within the limits of the name table and the
        // import and export names match, then the ordinal number can be
        // obtained directly from the ordinal table. Otherwise, the name
        // table must be searched for the specified name.
        //

        HintIndex = ((PIMAGE_IMPORT_BY_NAME)ThunkNameEntry->u1.AddressOfData)->Hint;
        if ((HintIndex < ExportDirectory->NumberOfNames) &&
            (strcmp((PCHAR)(&((PIMAGE_IMPORT_BY_NAME)ThunkNameEntry->u1.AddressOfData)->Name[0]),
                    (PCHAR)((ULONG_PTR)DllBase + NameTable[HintIndex])) == 0)) {

            //
            // Get the ordinal number from the ordinal table.
            //

            Ordinal = OrdinalTable[HintIndex];

        } else {

            //
            // Lookup the import name in the name table using a binary search.
            //

            Low = 0;
            High = ExportDirectory->NumberOfNames - 1;
            while (High >= Low) {

                //
                // Compute the next probe index and compare the import name
                // with the export name entry.
                //

                Middle = (Low + High) >> 1;
                Result = strcmp((PCHAR)(&((PIMAGE_IMPORT_BY_NAME)ThunkNameEntry->u1.AddressOfData)->Name[0]),
                                (PCHAR)((ULONG_PTR)DllBase + NameTable[Middle]));

                if (Result < 0) {
                    High = Middle - 1;

                } else if (Result > 0) {
                    Low = Middle + 1;

                } else {
                    break;
                }
            }

            //
            // If the high index is less than the low index, then a matching
            // table entry was not found. Otherwise, get the ordinal number
            // from the ordinal table.
            //

            if (High < Low) {
                return EINVAL;

            } else {
                Ordinal = OrdinalTable[Middle];
            }
        }
    }

    //
    // If the ordinal number is valid, then bind the import reference and
    // return success. Otherwise, return an unsuccessful status.
    //

    if (Ordinal >= ExportDirectory->NumberOfFunctions) {
        return EINVAL;
    }

    FunctionTable = (PULONG)((ULONG_PTR)DllBase + ExportDirectory->AddressOfFunctions);
    ThunkAddressEntry->u1.Function = ((ULONG_PTR)DllBase + FunctionTable[Ordinal]);

    //
    // Check for a forwarder.
    //
    if ( ((ULONG_PTR)ThunkAddressEntry->u1.Function > (ULONG_PTR)ExportDirectory) &&
         ((ULONG_PTR)ThunkAddressEntry->u1.Function < ((ULONG_PTR)ExportDirectory + ExportSize)) ) {
        CHAR ForwardDllName[10];
        PKLDR_DATA_TABLE_ENTRY DataTableEntry;
        ULONG TargetExportSize;
        PIMAGE_EXPORT_DIRECTORY TargetExportDirectory;

        RtlCopyMemory(ForwardDllName,
                      (PCHAR)ThunkAddressEntry->u1.Function,
                      sizeof(ForwardDllName));
        Temp = strchr(ForwardDllName,'.');

        ASSERT(Temp != NULL);  // Malformed name, stop here and debug why.

        if (Temp != NULL) {
            *Temp = '\0';
        }

        if (!BlCheckForLoadedDll(ForwardDllName,&DataTableEntry)) {
            //
            // Should load the referenced DLL here, just return failure for now.
            //

            return(EINVAL);
        }
        TargetExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
            RtlImageDirectoryEntryToData(DataTableEntry->DllBase,
                                         TRUE,
                                         IMAGE_DIRECTORY_ENTRY_EXPORT,
                                         &TargetExportSize);
        if (TargetExportDirectory) {

            IMAGE_THUNK_DATA thunkData;
            PIMAGE_IMPORT_BY_NAME addressOfData;
            UCHAR Buffer[128];
            PCHAR ImportName;
            ARC_STATUS Status;

            ImportName = strchr((PCHAR)ThunkAddressEntry->u1.Function, '.') + 1;
            addressOfData = (PIMAGE_IMPORT_BY_NAME)Buffer;
            RtlCopyMemory(&addressOfData->Name[0], ImportName, strlen(ImportName)+1);
            addressOfData->Hint = 0;
            thunkData.u1.AddressOfData = (ULONG_PTR)addressOfData;
            Status = BlpBindImportName(DataTableEntry->DllBase,
                                       ImageBase,
                                       &thunkData,
                                       &thunkData,
                                       TargetExportDirectory,
                                       TargetExportSize,
                                       TRUE);
            ThunkAddressEntry->u1 = thunkData.u1;
            return(Status);
        } else {
            return(EINVAL);
        }
    }

#if IMAGE_DEFINITIONS == 64

    //
    // The import is relative to KSEG0_BASE_X86.  Adjust it so that it is
    // relative to KSEG0_BASE_AMD64.
    //

    ThunkAddressEntry->u1.Function +=
        ((ULONG64)KSEG0_BASE_AMD64 - (ULONG)KSEG0_BASE_X86);

#endif

    return ESUCCESS;
}

ARC_STATUS
BlpScanImportAddressTable(
    IN PVOID DllBase,
    IN PVOID ImageBase,
    IN PIMAGE_THUNK_DATA ThunkNameTable,
    IN PIMAGE_THUNK_DATA ThunkAddressTable
    )

/*++

Routine Description:

    This routine scans the import address table for the specified image
    file and snaps each reference.

Arguments:

    DllBase - Supplies the base address of the specified DLL.
        If NULL, then references in the image's import table are to
        be resolved against the osloader's export table.

    ImageBase - Supplies the base address of the image.

    ThunkNameTable - Supplies a pointer to the import thunk name table.

    ThunkAddressTable - Supplies a pointer to the import thunk address table.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{

    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportTableSize;
    ARC_STATUS Status;

    //
    // Locate the export table in the image specified by the DLL base
    // address.
    //

#if i386
    if (DllBase == NULL) {
        ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)OsLoaderExports;
        ExportTableSize = 0;    // this is OK as this is only used to bind forwarded exports and osloader does not have any
    } else {
        ExportDirectory =
            (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(DllBase,
                                                                 TRUE,
                                                                 IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                                 &ExportTableSize);
    }
#else
    ExportDirectory =
        (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(DllBase,
                                                             TRUE,
                                                             IMAGE_DIRECTORY_ENTRY_EXPORT,
                                                             &ExportTableSize);
#endif
    if (ExportDirectory == NULL) {
        return EBADF;
    }

    //
    // Scan the thunk table and bind each import reference.
    //

    while (ThunkNameTable->u1.AddressOfData) {
        Status = BlpBindImportName(DllBase,
                                   ImageBase,
                                   ThunkNameTable,
                                   ThunkAddressTable,
                                   ExportDirectory,
                                   ExportTableSize,
                                   FALSE);
        if (Status != ESUCCESS) {
#if defined(_X86AMD64_)
            ICEBP;
#endif
            return Status;
        }
        ThunkNameTable++;
        ThunkAddressTable++;
    }

    return ESUCCESS;
}

ARC_STATUS
BlScanImportDescriptorTable(
    IN PPATH_SET                PathSet,
    IN PKLDR_DATA_TABLE_ENTRY    ScanEntry,
    IN TYPE_OF_MEMORY           MemoryType
    )

/*++

Routine Description:

    This routine scans the import descriptor table for the specified image
    file and loads each DLL that is referenced.

Arguments:

    PathSet - Supplies a pointer to a set of paths to scan when searching
        for DLL's.

    ScanEntry - Supplies a pointer to the data table entry for the
        image whose import table is to be scanned.

    MemoryType - Supplies the type of memory to to be assigned to any DLL's
        referenced.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{

    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    CHAR FullDllName[256];
    PVOID Base = NULL;
    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportTableSize;
    ARC_STATUS Status;
    PSZ ImportName;
    ULONG Index;
    PPATH_SOURCE PathSource;

    //
    // Locate the import table in the image specified by the data table entry.
    //

    ImportDescriptor =
        (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(ScanEntry->DllBase,
                                                              TRUE,
                                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                              &ImportTableSize);

    //
    // If the image has an import directory, then scan the import table and
    // load the specified DLLs.
    //

    if (ImportDescriptor != NULL) {
        while ((ImportDescriptor->Name != 0) &&
               (ImportDescriptor->OriginalFirstThunk != 0)) {

            //
            // Change the name from an RVA to a VA.
            //

            ImportName = (PSZ)((ULONG_PTR)ScanEntry->DllBase + ImportDescriptor->Name);

            //
            // If the DLL references itself, then skip the import entry.
            //

            if (BlpCompareDllName((PCHAR)ImportName,
                                  &ScanEntry->BaseDllName) == FALSE) {

                //
                // If the DLL is not already loaded, then load the DLL and
                // scan its import table.
                //

                if (BlCheckForLoadedDll((PCHAR)ImportName,
                                        &DataTableEntry) == FALSE) {

                    //
                    // Start walking our list of DevicePaths. If the list is
                    // empty (bad caller!) we fail with ENOENT.
                    //
                    Status = ENOENT;
                    for(Index=0; Index < PathSet->PathCount; Index++) {

                        PathSource = &PathSet->Source[Index];

                        strcpy(&FullDllName[0], PathSource->DirectoryPath);
                        strcat(&FullDllName[0], PathSet->PathOffset);
                        strcat(&FullDllName[0], (PCHAR)ImportName);

                        Status = BlLoadImage(
                            PathSource->DeviceId,
                            MemoryType,
                            &FullDllName[0],
                            TARGET_IMAGE,
                            &Base
                            );

                        if (Status == ESUCCESS) {

                            BlOutputLoadMessage(
                                (PCHAR) PathSource->DeviceName,
                                &FullDllName[0],
                                NULL
                                );

                            break;
                        }
                    }

                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    //
                    // ISSUE - 2000/29/03 - ADRIAO: Existant namespace polution
                    //     For the FullDllName field We should really be passing
                    // in AliasName\PathOffset\ImportName.
                    //
                    Status = BlAllocateDataTableEntry((PCHAR)ImportName,
                                                      &FullDllName[0],
                                                      Base,
                                                      &DataTableEntry);

                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    DataTableEntry->Flags |= (ScanEntry->Flags & LDRP_DRIVER_DEPENDENT_DLL);

                    Status = BlScanImportDescriptorTable(PathSet,
                                                         DataTableEntry,
                                                         MemoryType);

                    if (Status != ESUCCESS) {
                        return Status;
                    }

                    //
                    // BlAllocateDataTableEntry inserts the data table entry into the load order
                    // linked list in the order the dlls were found. We want the order to be the
                    // order of dependency. For example if driver A needed Dll B which needed Dll C
                    // we want the order to be ACB and not ABC. So here we remove this DLLs entry
                    // and add it at the end. This way when IoInitializeBootDrivers calls DllInitialize
                    // it will call them in the right order.
                    //
                    if (DataTableEntry->Flags &LDRP_DRIVER_DEPENDENT_DLL) {
                        RemoveEntryList(&(DataTableEntry)->InLoadOrderLinks);
                        InsertTailList(&BlLoaderBlock->LoadOrderListHead,
                                       &DataTableEntry->InLoadOrderLinks);
                    }

                } else {
                    //
                    // Dll already exists but it might not be marked as a driver dependent DLL.
                    // For example it might be a driver. So mark it now.
                    //
                    DataTableEntry->Flags |= (ScanEntry->Flags & LDRP_DRIVER_DEPENDENT_DLL);
                }

                //
                // Scan the import address table and snap links.
                //

                Status = BlpScanImportAddressTable(DataTableEntry->DllBase,
                            ScanEntry->DllBase,
                            (PIMAGE_THUNK_DATA)((ULONG_PTR)ScanEntry->DllBase +
                                                ImportDescriptor->OriginalFirstThunk),
                            (PIMAGE_THUNK_DATA)((ULONG_PTR)ScanEntry->DllBase +
                                                ImportDescriptor->FirstThunk));

                if (Status != ESUCCESS) {
                    return Status;
                }
            }

            ImportDescriptor += 1;
        }
    }

    return ESUCCESS;
}

ARC_STATUS
BlScanOsloaderBoundImportTable (
    IN PKLDR_DATA_TABLE_ENTRY ScanEntry
    )

/*++

Routine Description:

    This routine scans the import descriptor table for the specified image
    file and loads each DLL that is referenced.

Arguments:

    DataTableEntry - Supplies a pointer to the data table entry for the
        image whose import table is to be scanned.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{

    PIMAGE_IMPORT_DESCRIPTOR ImportDescriptor;
    ULONG ImportTableSize;
    ARC_STATUS Status;
    PSZ ImportName;

    //
    // Locate the import table in the image specified by the data table entry.
    //

    ImportDescriptor =
        (PIMAGE_IMPORT_DESCRIPTOR)RtlImageDirectoryEntryToData(ScanEntry->DllBase,
                                                              TRUE,
                                                              IMAGE_DIRECTORY_ENTRY_IMPORT,
                                                              &ImportTableSize);

    //
    // If the image has an import directory, then scan the import table.
    //

    if (ImportDescriptor != NULL) {
        while ((ImportDescriptor->Name != 0) &&
               (ImportDescriptor->OriginalFirstThunk != 0)) {

            //
            // Change the name from an RVA to a VA.
            //

            ImportName = (PSZ)((ULONG_PTR)ScanEntry->DllBase + ImportDescriptor->Name);

            //
            // If the DLL references itself, then skip the import entry.
            //

            if (BlpCompareDllName((PCHAR)ImportName,
                                  &ScanEntry->BaseDllName) == FALSE) {

                //
                // Scan the import address table and snap links.
                //

                Status = BlpScanImportAddressTable(NULL,
                            ScanEntry->DllBase,
                            (PIMAGE_THUNK_DATA)((ULONG_PTR)ScanEntry->DllBase +
                                    ImportDescriptor->OriginalFirstThunk),
                            (PIMAGE_THUNK_DATA)((ULONG_PTR)ScanEntry->DllBase +
                                    ImportDescriptor->FirstThunk));

                if (Status != ESUCCESS) {
                    return Status;
                }
            }

            ImportDescriptor += 1;
        }
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kdcom\kdcomp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation    
    
Module Name:

    kdcomp.h

Abstract:
    
    Private Kernel Debugger HW Extension DLL com port definitions

Author:

    Eric Nelson (enelson) 1/10/2000

Revision History:

--*/

#include "nthal.h"
#define NOEXTAPI
#include "wdbgexts.h"
#include "ntdbg.h"
#include "string.h"
#include "stdlib.h"
#include "kddll.h"
#include "acpitabl.h"

#ifndef __KDCOMP_H__
#define __KDCOMP_H__

extern ULONG KdCompPacketIdExpected;
extern ULONG KdCompNextPacketIdToSend;
extern BOOLEAN KdCompDbgPortsPresent;

//
// Local functions 
//
ULONG
KdCompGetByte(
    OUT PUCHAR Input
    );

NTSTATUS
KdCompInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
KdCompInitialize1(
    VOID
    );

ULONG
KdCompPollByte (
    OUT PUCHAR Input
    );

VOID
KdCompPutByte(
    IN UCHAR Output
    );

USHORT
KdCompReceivePacketLeader(
    IN ULONG PacketType,
    OUT PULONG PacketLeader,
    IN OUT PKD_CONTEXT KdContext
    );

VOID
KdCompRestore(
    VOID
    );

VOID
KdCompSave(
    VOID
    );

VOID
CpWritePortUchar(
    IN PUCHAR Address, 
    IN UCHAR Value
    );

UCHAR
CpReadPortUchar(
    IN PUCHAR Address
    );

VOID
CpWriteRegisterUchar(
    IN PUCHAR Address,
    IN UCHAR Value
    );

UCHAR
CpReadRegisterUchar(
    IN PUCHAR Address
    );

typedef
VOID
(*pKWriteUchar) (
    IN PUCHAR Address,
    IN UCHAR  Value
    );

typedef
UCHAR
(*pKReadUchar) (
    IN PUCHAR Address
    );

#endif // __KDCOMP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blbind.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blbind.c

Abstract:

    This module contains the code that implements the funtions required
    to relocate an image and bind DLL entry points.

Author:

    David N. Cutler (davec) 21-May-1991

Revision History:

--*/

#include "bldr.h"
#include "ctype.h"
#include "string.h"

//
// Define local procedure prototypes.
//

BOOLEAN
BlpCompareDllName (
    IN PCHAR Name,
    IN PUNICODE_STRING UnicodeString
    );

#if defined(_X86AMD64_)

//
// For this version of the loader there are several routines that are needed
// in both a 32-bit and 64-bit flavor.  The code for these routines exists
// in blbindt.c.
//
// First, set up various definitions to cause 32-bit functions to be
// generated, then include blbindt.c.
//

#define BlAllocateDataTableEntry        BlAllocateDataTableEntry32
#define BlAllocateFirmwareTableEntry    BlAllocateFirmwareTableEntry32
#define BlpBindImportName               BlpBindImportName32
#define BlpScanImportAddressTable       BlpScanImportAddressTable32
#define BlScanImportDescriptorTable     BlScanImportDescriptorTable32
#define BlScanOsloaderBoundImportTable  BlScanOsloaderBoundImportTable32

#undef   IMAGE_DEFINITIONS
#define  IMAGE_DEFINITIONS 32
#include <ximagdef.h>
#include "amd64\amd64prv.h"
#include "blbindt.c"

#undef BlAllocateDataTableEntry
#undef BlAllocateFirmwareTableEntry
#undef BlpBindImportName
#undef BlpScanImportAddressTable
#undef BlScanImportDescriptorTable
#undef BlScanOsloaderBoundImportTable

//
// Now, change those definitions in order to generate 64-bit versions of
// those same functions.
//

#define BlAllocateDataTableEntry        BlAllocateDataTableEntry64
#define BlAllocateFirmwareTableEntry    BlAllocateFirmwareTableEntry64
#define BlpBindImportName               BlpBindImportName64
#define BlpScanImportAddressTable       BlpScanImportAddressTable64
#define BlScanImportDescriptorTable     BlScanImportDescriptorTable64
#define BlScanOsloaderBoundImportTable  BlScanOsloaderBoundImportTable64

#undef   IMAGE_DEFINITIONS
#define  IMAGE_DEFINITIONS 64
#include <ximagdef.h>
#include "amd64\amd64prv.h"
#include "blbindt.c"

#undef BlAllocateDataTableEntry
#undef BlAllocateFirmwareTableEntry
#undef BlpBindImportName
#undef BlpScanImportAddressTable
#undef BlScanImportDescriptorTable
#undef BlScanOsloaderBoundImportTable

#else   // _X86AMD64_

#define IMAGE_DEFINITIONS 32

#define IMAGE_NT_HEADER(x) RtlImageNtHeader(x)
#include "blbindt.c"

#endif  // _X86AMD64_


BOOLEAN
BlCheckForLoadedDll (
    IN PCHAR DllName,
    OUT PKLDR_DATA_TABLE_ENTRY *FoundEntry
    )

/*++

Routine Description:

    This routine scans the loaded DLL list to determine if the specified
    DLL has already been loaded. If the DLL has already been loaded, then
    its reference count is incremented.

Arguments:

    DllName - Supplies a pointer to a null terminated DLL name.

    FoundEntry - Supplies a pointer to a variable that receives a pointer
        to the matching data table entry.

Return Value:

    If the specified DLL has already been loaded, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PKLDR_DATA_TABLE_ENTRY DataTableEntry;
    PLIST_ENTRY NextEntry;

    //
    // Scan the loaded data table list to determine if the specified DLL
    // has already been loaded.
    //

    NextEntry = BlLoaderBlock->LoadOrderListHead.Flink;
    while (NextEntry != &BlLoaderBlock->LoadOrderListHead) {
        DataTableEntry = CONTAINING_RECORD(NextEntry,
                                           KLDR_DATA_TABLE_ENTRY,
                                           InLoadOrderLinks);

        if (BlpCompareDllName(DllName, &DataTableEntry->BaseDllName) != FALSE) {
            *FoundEntry = DataTableEntry;
            DataTableEntry->LoadCount += 1;
            return TRUE;
        }

        NextEntry = NextEntry->Flink;
    }

    return FALSE;
}

BOOLEAN
BlpCompareDllName (
    IN PCHAR DllName,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine compares a zero terminated character string with a unicode
    string. The UnicodeString's extension is ignored.

Arguments:

    DllName - Supplies a pointer to a null terminated DLL name.

    UnicodeString - Supplies a pointer to a Unicode string descriptor.

Return Value:

    If the specified name matches the Unicode name, then TRUE is returned.
    Otherwise, FALSE is returned.

--*/

{

    PWSTR Buffer;
    ULONG Index;
    ULONG Length;

    //
    // Compute the length of the DLL Name and compare with the length of
    // the Unicode name. If the DLL Name is longer, the strings are not
    // equal.
    //

    Length = (ULONG)strlen(DllName);
    if ((Length * sizeof(WCHAR)) > UnicodeString->Length) {
        return FALSE;
    }

    //
    // Compare the two strings case insensitive, ignoring the Unicode
    // string's extension.
    //

    Buffer = UnicodeString->Buffer;
    for (Index = 0; Index < Length; Index += 1) {
        if (toupper(*DllName) != toupper((CHAR)*Buffer)) {
            return FALSE;
        }

        DllName += 1;
        Buffer += 1;
    }
    if ((UnicodeString->Length == Length * sizeof(WCHAR)) ||
        (*Buffer == L'.')) {
        //
        // Strings match exactly or match up until the UnicodeString's extension.
        //
        return(TRUE);
    }
    return FALSE;
}

#if defined(_X86AMD64_)


ARC_STATUS
BlScanImportDescriptorTable(
    IN PPATH_SET                PathSet,
    IN PKLDR_DATA_TABLE_ENTRY   ScanEntry,
    IN TYPE_OF_MEMORY           MemoryType
    )

/*++

Routine Description:

    This routine scans the import descriptor table for the specified image
    file and loads each DLL that is referenced.

Arguments:

    PathSet - Supplies a pointer to a set of paths to scan when searching
        for DLL's.

    ScanEntry - Supplies a pointer to the data table entry for the
        image whose import table is to be scanned.

    MemoryType - Supplies the type of memory to to be assigned to any DLL's
        referenced.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{
    ARC_STATUS status;

    if (BlAmd64UseLongMode != FALSE) {
        status = BlScanImportDescriptorTable64( PathSet,
                                                ScanEntry,
                                                MemoryType );
    } else {
        status = BlScanImportDescriptorTable32( PathSet,
                                                ScanEntry,
                                                MemoryType );
    }

    return status;
}

ARC_STATUS
BlScanOsloaderBoundImportTable (
    IN PKLDR_DATA_TABLE_ENTRY ScanEntry
    )

/*++

Routine Description:

    This routine scans the import descriptor table for the specified image
    file and loads each DLL that is referenced.

Arguments:

    DataTableEntry - Supplies a pointer to the data table entry for the
        image whose import table is to be scanned.

Return Value:

    ESUCCESS is returned in the scan is successful. Otherwise, return an
    unsuccessful status.

--*/

{
    ARC_STATUS status;

    if (BlAmd64UseLongMode != FALSE) {
        status = BlScanOsloaderBoundImportTable64( ScanEntry );
    } else {
        status = BlScanOsloaderBoundImportTable32( ScanEntry );
    }

    return status;
}

ARC_STATUS
BlAllocateDataTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID Base,
    OUT PKLDR_DATA_TABLE_ENTRY *AllocatedEntry
    )

/*++

Routine Description:

    This routine allocates a data table entry for the specified image
    and inserts the entry in the loaded module list.

Arguments:

    BaseDllName - Supplies a pointer to a zero terminated base DLL name.

    FullDllName - Supplies a pointer to a zero terminated full DLL name.

    Base - Supplies a pointer to the base of the DLL image.

    AllocatedEntry - Supplies a pointer to a variable that receives a
        pointer to the allocated data table entry.

Return Value:

    ESUCCESS is returned if a data table entry is allocated. Otherwise,
    return a unsuccessful status.

--*/

{
    ARC_STATUS status;

    if (BlAmd64UseLongMode != FALSE) {
        status = BlAllocateDataTableEntry64( BaseDllName,
                                             FullDllName,
                                             Base,
                                             AllocatedEntry );
    } else {
        status = BlAllocateDataTableEntry32( BaseDllName,
                                             FullDllName,
                                             Base,
                                             AllocatedEntry );
    }

    return status;
}

ARC_STATUS
BlAllocateFirmwareTableEntry (
    IN PCHAR BaseDllName,
    IN PCHAR FullDllName,
    IN PVOID Base,
    IN ULONG Size,
    OUT PKLDR_DATA_TABLE_ENTRY *AllocatedEntry
    )

/*++

Routine Description:

    This routine allocates a firmware table entry for the specified image
    and inserts the entry in the loaded module list.

Arguments:

    BaseDllName - Supplies a pointer to a zero terminated base DLL name.

    FullDllName - Supplies a pointer to a zero terminated full DLL name.

    Base - Supplies a pointer to the base of the DLL image.

    Size - Supplies how big the image is.

    AllocatedEntry - Supplies a pointer to a variable that receives a
        pointer to the allocated data table entry.

Return Value:

    ESUCCESS is returned if a data table entry is allocated. Otherwise,
    return a unsuccessful status.

--*/
{
    ARC_STATUS status;

    if (BlAmd64UseLongMode != FALSE) {
        status = BlAllocateFirmwareTableEntry64( BaseDllName,
                                                 FullDllName,
                                                 Base,
                                                 Size,
                                                 AllocatedEntry );
    } else {
        status = BlAllocateFirmwareTableEntry32( BaseDllName,
                                                 FullDllName,
                                                 Base,
                                                 Size,
                                                 AllocatedEntry );
    }

    return status;
}
#endif  // _X86AMD64_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blcache.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blcache.c

Abstract:

    This module implements general purpose disk caching based on
    ranges [blrange.c] but it is used mainly for the file system
    metadata caching on load & system devices. In order to use caching
    on a device, you must make sure that there is only one unique
    BlFileTable entry for that device and the same device is not
    opened & cached simultaneously multiple times under different
    device ids. Otherwise there will be cache inconsistencies, since
    cached data and structures are maintained based on device id. Also
    you must make sure to stop caching when the device is closed.

Author:

    Cenk Ergan (cenke) 14-Jan-2000

Revision History:

--*/

#include "blcache.h"
#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

//
// Define global variables.
//

//
// This is the boot loader disk cache with all its bells and whistles.
//

BL_DISKCACHE BlDiskCache = {0};

//
// Useful defines for alignment and size in memory allocations.
//

//
// This define is used with BlAllocateAlignedDescriptor to allocate 64KB
// aligned memory. It is the number of pages for 64KB.
//

#define BL_DISKCACHE_64KB_ALIGNED  (0x10000 >> PAGE_SHIFT)

//
// Prototypes for internal functions.
//

PBL_DISK_SUBCACHE
BlDiskCacheFindCacheForDevice(
    ULONG DeviceId
    );

BOOLEAN
BlDiskCacheMergeRangeRoutine (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    );

VOID
BlDiskCacheFreeRangeRoutine (
    PBLCRANGE_ENTRY pRangeEntry
    );

PBLCRANGE_ENTRY
BlDiskCacheAllocateRangeEntry (
    VOID
    );

VOID
BlDiskCacheFreeRangeEntry (
    PBLCRANGE_ENTRY pEntry
    );

//
// Disk cache functions' implementation.
//

ARC_STATUS
BlDiskCacheInitialize(
    VOID
    )

/*++

Routine Description:

    This routine initializes the global state for the boot loader
    disk cache, allocates the necessary memory etc.

Arguments:

    None.

Return Value:

    ESUCCESS - Disk caching is initialized and is on line.

    ARC_STATUS - There was a problem. Disk caching is not online.

--*/

{
    PCHAR   LoadOptions;
    ARC_STATUS Status = ESUCCESS;
    ULONG DevIdx;
    ULONG EntryIdx;
    ULONG ActualBase;
    ULONG SizeInPages;
    ULONG OldUsableBase, OldUsableLimit;

    //
    // If we have already initialized, return success right away
    // denoting that the disk cache is on line. Returning failure
    // from this function when called after the disk cache has already
    // been initialized may be ambiguous, i.e. as if the disk cache
    // failed to initialize and is not started. So we return ESUCCESS.
    //

    if (BlDiskCache.Initialized)
    {
        return ESUCCESS;
    }

    //
    // Set a bias in the allocation strategy. Typically, we want to allocate
    // the disk cach above the 8MB point
    //
    OldUsableBase = BlUsableBase;
    OldUsableLimit = BlUsableLimit;
    BlUsableBase = BL_DISK_CACHE_RANGE_LOW;
    BlUsableLimit = BL_DISK_CACHE_RANGE_HIGH;

    //
    // We are going to apply various hacks depending on what bootoptions are
    // specified. In particular, if this is a /3GB system, then we will
    // ensure that the cache is at the 1st free hole in memory. The reason
    // we do this is that we don't to put anything over the 16MB boundary
    // or the system won't boot.
    //
    LoadOptions = BlLoaderBlock->LoadOptions;
#if defined(_X86_)
    if (LoadOptions != NULL) {

        if (strstr(LoadOptions, "3GB") != NULL ||
            strstr(LoadOptions, "3gb") != NULL) {

            BlUsableBase = 0;

        }
    }
#endif

    //
    // Try to allocate the tables & buffers for caching. We don't
    // allocate them together in one big allocation, because it may be
    // harder for the memory manager to give us that. This way
    // although some memory may be wasted [since returned memory is
    // multiple of PAGE_SIZE], two seperate free memory blocks may be
    // utilized.
    //
    Status = BlAllocateAlignedDescriptor(LoaderOsloaderHeap,
                                         0,
                                         (BL_DISKCACHE_SIZE >> PAGE_SHIFT) + 1,
                                         BL_DISKCACHE_64KB_ALIGNED,
                                         &ActualBase);

    if (Status != ESUCCESS) goto cleanup;

    BlDiskCache.DataBuffer = (PVOID) (KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    SizeInPages = (BL_DISKCACHE_NUM_BLOCKS * sizeof(BLCRANGE_ENTRY) >> PAGE_SHIFT) + 1;
    Status = BlAllocateDescriptor(LoaderOsloaderHeap,
                                  0,
                                  SizeInPages,
                                  &ActualBase);

    if (Status != ESUCCESS) goto cleanup;

    BlDiskCache.EntryBuffer = (PVOID) (KSEG0_BASE | (ActualBase << PAGE_SHIFT));

    //
    // Make sure all entries in the device cache lookup table are
    // marked uninitialized.
    //

    for (DevIdx = 0; DevIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; DevIdx++)
    {
        BlDiskCache.DeviceTable[DevIdx].Initialized = FALSE;
    }

    //
    // Initialize free entry list.
    //

    InitializeListHead(&BlDiskCache.FreeEntryList);

    //
    // Initialize EntryBuffer used for "allocating" & "freeing"
    // range entries for the cached range lists.
    //

    for (EntryIdx = 0; EntryIdx < BL_DISKCACHE_NUM_BLOCKS; EntryIdx++)
    {
        //
        // Add this entry to the free list.
        //

        InsertHeadList(&BlDiskCache.FreeEntryList,
                       &BlDiskCache.EntryBuffer[EntryIdx].UserLink);

        //
        // Point the UserData field to a BLOCK_SIZE chunk of the
        // DataBuffer.
        //

        BlDiskCache.EntryBuffer[EntryIdx].UserData =
            BlDiskCache.DataBuffer + (EntryIdx * BL_DISKCACHE_BLOCK_SIZE);
    }

    //
    // Initialize the MRU blocks list head.
    //

    InitializeListHead(&BlDiskCache.MRUBlockList);

    //
    // Mark ourselves initialized.
    //

    BlDiskCache.Initialized = TRUE;

    Status = ESUCCESS;

    DPRINT(("DK: Disk cache initialized.\n"));

 cleanup:

    BlUsableBase = OldUsableBase;
    BlUsableLimit = OldUsableLimit;
    if (Status != ESUCCESS) {
        if (BlDiskCache.DataBuffer) {
            ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.DataBuffer & (~KSEG0_BASE)) >>PAGE_SHIFT;
            BlFreeDescriptor(ActualBase);
        }

        if (BlDiskCache.EntryBuffer) {
            ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.EntryBuffer & (~KSEG0_BASE)) >>PAGE_SHIFT;
            BlFreeDescriptor(ActualBase);
        }

        DPRINT(("DK: Disk cache initialization failed.\n"));
    }

    return Status;
}

VOID
BlDiskCacheUninitialize(
    VOID
    )

/*++

Routine Description:

    This routine uninitializes the boot loader disk cache: flushes &
    disables caches, free's allocated memory etc.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG DevIdx;
    ULONG ActualBase;

    //
    // Stop caching for all devices.
    //

    for (DevIdx = 0; DevIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; DevIdx++)
    {
        if (BlDiskCache.DeviceTable[DevIdx].Initialized)
        {
            BlDiskCacheStopCachingOnDevice(DevIdx);
        }
    }

    //
    // Free allocated memory.
    //

    if (BlDiskCache.DataBuffer)
    {
        ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.DataBuffer & (~KSEG0_BASE)) >> PAGE_SHIFT;
        BlFreeDescriptor(ActualBase);
    }

    if (BlDiskCache.EntryBuffer)
    {
        ActualBase = (ULONG)((ULONG_PTR)BlDiskCache.EntryBuffer & (~KSEG0_BASE)) >> PAGE_SHIFT;
        BlFreeDescriptor(ActualBase);
    }

    //
    // Mark the disk cache uninitialized.
    //

    BlDiskCache.Initialized = FALSE;

    DPRINT(("DK: Disk cache uninitialized.\n"));

    return;
}

PBL_DISK_SUBCACHE
BlDiskCacheFindCacheForDevice(
    ULONG DeviceId
    )

/*++

Routine Description:

    Return a cache header for a device id.

Arguments:

    DeviceId - Device that we want to access cached.

Return Value:

    Pointer to cache header or NULL if one could not be found.

--*/

{
    ULONG CurIdx;

    //
    // If we have not done global disk cache initialization or we
    // could not allocate memory for caching data we could not have
    // started caching.
    //

    if ((!BlDiskCache.Initialized) || (BlDiskCache.DataBuffer == NULL))
    {
        return NULL;
    }

    //
    // Go through the table to see if there is an intialized cache for
    // this device.
    //

    for (CurIdx = 0; CurIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; CurIdx++)
    {
        if (BlDiskCache.DeviceTable[CurIdx].Initialized &&
            BlDiskCache.DeviceTable[CurIdx].DeviceId == DeviceId)
        {
            return &BlDiskCache.DeviceTable[CurIdx];
        }
    }

    //
    // Could not find an initialized cache for this device.
    //

    return NULL;
}

PBL_DISK_SUBCACHE
BlDiskCacheStartCachingOnDevice(
    ULONG DeviceId
    )

/*++

Routine Description:

    Attempt at start caching on the specified device by allocating a
    cache header and initializing it. If caching is already enabled
    on that device, return existing cache header.

Arguments:

    DeviceId - Device that we want to access cached.

Return Value:

    Pointer to created / found cache header or NULL if there was a
    problem.

--*/

{
    ULONG CurIdx;
    PBL_DISK_SUBCACHE pFoundEntry;
    PBL_DISK_SUBCACHE pFreeEntry = NULL;

    //
    // If we have not done global disk cache initialization or we
    // could not allocate memory for caching data, we could not have
    // started caching.
    //

    if ((!BlDiskCache.Initialized) || (BlDiskCache.DataBuffer == NULL))
    {
        return NULL;
    }

    //
    // First see if we already cache this device.
    //

    if ((pFoundEntry = BlDiskCacheFindCacheForDevice(DeviceId)) != 0)
    {
        return pFoundEntry;
    }

    //
    // Go through the device table to find an empty slot.
    //

    for (CurIdx = 0; CurIdx < BL_DISKCACHE_DEVICE_TABLE_SIZE; CurIdx++)
    {
        if (!BlDiskCache.DeviceTable[CurIdx].Initialized)
        {
            pFreeEntry = &BlDiskCache.DeviceTable[CurIdx];
            break;
        }
    }

    if (!pFreeEntry)
    {
        //
        // There were no free entries.
        //

        return NULL;
    }

    //
    // Initialize & return cache entry.
    //

    pFreeEntry->DeviceId = DeviceId;

    BlRangeListInitialize(&pFreeEntry->Ranges,
                          BlDiskCacheMergeRangeRoutine,
                          BlDiskCacheFreeRangeRoutine);

    pFreeEntry->Initialized = TRUE;

    DPRINT(("DK: Started cache on device %u.\n", DeviceId));

    return pFreeEntry;
}

VOID
BlDiskCacheStopCachingOnDevice(
    ULONG DeviceId
    )

/*++

Routine Description:

    Stop caching for DeviceId if we are and flush the cache.

Arguments:

    DeviceId - Device that we want to stop caching.

Return Value:

    None.

--*/

{
    PBL_DISK_SUBCACHE pCache;

    //
    // If we have not done global disk cache initialization or we
    // could not allocate memory for caching data, we could not have
    // started caching.
    //

    if ((!BlDiskCache.Initialized) || (BlDiskCache.DataBuffer == NULL))
    {
        return;
    }

    //
    // Find the cache.
    //

    pCache = BlDiskCacheFindCacheForDevice(DeviceId);

    if (pCache)
    {
        //
        // Free all the allocated ranges.
        //

        BlRangeListRemoveAllRanges(&pCache->Ranges);

        //
        // Mark the cache entry free.
        //

        pCache->Initialized = FALSE;

        DPRINT(("DK: Stopped cache on device %u.\n", DeviceId));
    }
}

ARC_STATUS
BlDiskCacheRead (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,
    PVOID Buffer,
    ULONG Length,
    PULONG pCount,
    BOOLEAN CacheNewData
    )

/*++

Routine Description:

    Perform a cached read from the device. Copy over parts that are in
    the cache, and perform ArcRead on DeviceId for parts that are
    not. The data read by ArcRead will be added to the cache if
    CacheNewData is TRUE.

    NOTE. Do not call this function directly with Length > 64KB. It
    uses a fixed size buffer for containing list of overlapping cached
    ranges, and if they don't all fit into the buffer, it bails out and
    calls ArcRead directly [i.e. non-cached].

Arguments:

    DeviceId - Device to read from.

    Offset - Offset to read from.

    Buffer - To read data into.

    Length - Number of bytes to read into Buffer from Offset on DeviceId.

    pCount - Number of bytes read.

    CacheNewData - Data that is not in the cache but was read from the
        disk is added to the cache.

Return Value:

    Status.

    NOTE: DeviceId's (Seek) Position is undefined after this call.

--*/

{
    PBL_DISK_SUBCACHE pCache;
    ARC_STATUS Status;
    LARGE_INTEGER LargeEndOffset;
    BLCRANGE ReadRange;

    //
    // We use ResultsBuffer for both finding overlapping range entries and
    // distinct ranges.
    //

    UCHAR ResultsBuffer[BL_DISKCACHE_FIND_RANGES_BUF_SIZE];
    ULONG ResultsBufferSize = BL_DISKCACHE_FIND_RANGES_BUF_SIZE;

    PBLCRANGE_ENTRY *pOverlaps = (PBLCRANGE_ENTRY *) ResultsBuffer;
    ULONG NumOverlaps;
    PBLCRANGE pDistinctRanges = (PBLCRANGE) ResultsBuffer;
    ULONG NumDistincts;

    ULONG OverlapIdx;
    ULONG DistinctIdx;

    ULONGLONG StartOffset;
    ULONGLONG EndOffset;
    ULONGLONG ReadOffset;
    LARGE_INTEGER LIReadOffset;
    PUCHAR pSrc;
    PUCHAR pDest;
    PUCHAR pDestEnd;
    ULONG CopyLength;
    ULONG ReadLength;
    ULONG BytesRead;
    LIST_ENTRY *pLastMRUEntrysLink;
    PBLCRANGE_ENTRY pNewCacheEntry;
    PBLCRANGE_ENTRY pLastMRUEntry;
    ULONGLONG HeadBlockOffset;
    ULONGLONG TailBlockOffset;
    ULONG HeadBytesOffset;
    ULONG NumTailBytes;
#ifdef BL_DISKCACHE_DEBUG
    PUCHAR EndOfCallersBuffer = ((PUCHAR) Buffer) + Length;
#endif

    DPRINT(("DK: READ(%5u,%016I64x,%08x,%8u,%d)\n", DeviceId,
            pOffset->QuadPart, Buffer, Length, (DWORD)CacheNewData));

    //
    // Reset the number of bytes read.
    //

    *pCount = 0;

    //
    // Note where the device's position has to be after a successful
    // completion of the request.
    //

    LargeEndOffset.QuadPart = pOffset->QuadPart + Length;

    //
    // Look for a cache for this device.
    //

    pCache = BlDiskCacheFindCacheForDevice(DeviceId);

    if (pCache)
    {
        //
        // Determine read range.
        //

        ReadRange.Start = pOffset->QuadPart;
        ReadRange.End = ReadRange.Start + Length;

        //
        // If any part of the read range is in the cache, copy it over
        // into the buffer. First find out all cache entries that
        // contain data for this range. This function returns an array
        // of pointers to overlapping entries.
        //

        if (!BlRangeListFindOverlaps(&pCache->Ranges,
                                     &ReadRange,
                                     pOverlaps,
                                     ResultsBufferSize,
                                     &NumOverlaps))
        {
            goto SkipCache;
        }

        for (OverlapIdx = 0; OverlapIdx < NumOverlaps; OverlapIdx++)
        {
            //
            // Move this cache entry to the head of the MRU list.
            //

            RemoveEntryList(&pOverlaps[OverlapIdx]->UserLink);
            InsertHeadList(&BlDiskCache.MRUBlockList,
                           &pOverlaps[OverlapIdx]->UserLink);

            //
            // Copy cached part. This is the overlap between the readrange
            // and this overlapping range, i.e. max of starts, min of ends.
            //

            StartOffset = BLCMAX(pOverlaps[OverlapIdx]->Range.Start,
                                 (ULONGLONG) pOffset->QuadPart);
            EndOffset = BLCMIN(pOverlaps[OverlapIdx]->Range.End,
                               ((ULONGLONG) pOffset->QuadPart) + Length);
            CopyLength = (ULONG) (EndOffset - StartOffset);

            pSrc = ((PUCHAR) pOverlaps[OverlapIdx]->UserData) +
                (StartOffset - pOverlaps[OverlapIdx]->Range.Start);
            pDest = ((PUCHAR) Buffer) +
                (StartOffset - (ULONGLONG) pOffset->QuadPart);

            DPRINT(("DK:  CopyCached:%08x,%08x,%d\n", pDest, pSrc, CopyLength));
            DASSERT((pDest < (PUCHAR) Buffer) ||
                    (pDest + CopyLength > EndOfCallersBuffer));

            RtlCopyMemory(pDest, pSrc, CopyLength);

            *pCount += CopyLength;
        }

        if (*pCount == Length)
        {
            //
            // The full request was satisfied from the cache. Seek to
            // where the device position should be if the request was
            // read from the device.
            //

            if (ArcSeek(DeviceId, &LargeEndOffset, SeekAbsolute) != ESUCCESS)
            {
                goto SkipCache;
            }

            return ESUCCESS;
        }

        //
        // Identify distinct ranges that are not in the cache.
        //

        if (!BlRangeListFindDistinctRanges(&pCache->Ranges,
                                           &ReadRange,
                                           pDistinctRanges,
                                           ResultsBufferSize,
                                           &NumDistincts))
        {
            goto SkipCache;
        }

        //
        // Read the distinct ranges from the disk and copy them into
        // caller's buffer. This function returns an array of
        // BLCRANGE's that are subranges of the requested range that
        // do not overlap with any ranges in the cache.
        //

        for (DistinctIdx = 0; DistinctIdx < NumDistincts; DistinctIdx++)
        {
            if (CacheNewData)
            {
                //
                // Not only do we have to read uncached parts from the disk,
                // we also have to add them to our cache.
                //

                StartOffset = pDistinctRanges[DistinctIdx].Start;
                EndOffset = pDistinctRanges[DistinctIdx].End;
                pDest = ((PUCHAR) Buffer) +
                    (StartOffset - pOffset->QuadPart);

                ReadLength = BL_DISKCACHE_BLOCK_SIZE;
                ReadOffset = StartOffset & (~(BL_DISKCACHE_BLOCK_SIZE - 1));

                //
                // Make note of Head & Tail block offsets and number
                // of bytes, so it is easy to recognize that we will
                // copy only a part of the data we read from the disk
                // into the callers buffer. Setting these up here, we
                // don't have to handle the four cases seperately: i.e.
                // - when the block we read is the head [i.e. first] block
                //   and the range starts from an offset into the block
                // - when the block we read is the tail [i.e. last] block
                //   and the range extends only a number of bytes into it.
                // - when the block we read is both the head and the tail.
                // - when the block we read is from the middle of the range
                //   and all of it is in the range.
                //

                HeadBlockOffset = StartOffset & (~(BL_DISKCACHE_BLOCK_SIZE - 1));
                TailBlockOffset = EndOffset   & (~(BL_DISKCACHE_BLOCK_SIZE - 1));

                HeadBytesOffset = (ULONG)(StartOffset & (BL_DISKCACHE_BLOCK_SIZE - 1));
                NumTailBytes = (ULONG)(EndOffset & (BL_DISKCACHE_BLOCK_SIZE - 1));

                //
                // We need to read this range from the disk in
                // BLOCK_SIZE aligned BLOCK_SIZE chunks, build new
                // cache entries to add to the cached ranges list and
                // copy it to the target buffer.
                //

                pDestEnd = ((PUCHAR)Buffer) + (EndOffset - pOffset->QuadPart);
                while (pDest < pDestEnd)
                {
                    //
                    // First get our hands on a new cache entry.
                    //

                    pNewCacheEntry = BlDiskCacheAllocateRangeEntry();

                    if (!pNewCacheEntry)
                    {
                        //
                        // We will free the last MRU entry and use that.
                        //

                        if (IsListEmpty(&BlDiskCache.MRUBlockList))
                        {
                            goto SkipCache;
                        }

                        //
                        // Identify the last MRU entry.
                        //

                        pLastMRUEntrysLink = BlDiskCache.MRUBlockList.Blink;
                        pLastMRUEntry = CONTAINING_RECORD(pLastMRUEntrysLink,
                                                          BLCRANGE_ENTRY,
                                                          UserLink);

                        //
                        // Remove the entry from cached list. When the
                        // entry is freed, it is removed from MRU and
                        // put onto the free list.
                        //

                        BlRangeListRemoveRange(&pCache->Ranges,
                                               &pLastMRUEntry->Range);

                        //
                        // Now try allocating a new entry.
                        //

                        pNewCacheEntry = BlDiskCacheAllocateRangeEntry();

                        if (!pNewCacheEntry) {
                            goto SkipCache;
                        }

                    }

                    //
                    // Read BLOCK_SIZE from device into the cache
                    // entry's buffer.
                    //

                    pNewCacheEntry->Range.Start = ReadOffset;
                    pNewCacheEntry->Range.End = ReadOffset + ReadLength;

                    LIReadOffset.QuadPart = ReadOffset;

                    if (ArcSeek(DeviceId,
                                &LIReadOffset,
                                SeekAbsolute) != ESUCCESS)
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }

                    if (ArcRead(DeviceId,
                                pNewCacheEntry->UserData,
                                ReadLength,
                                &BytesRead) != ESUCCESS)
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }

                    if (BytesRead != ReadLength)
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }

                    //
                    // Add this range to cached ranges.
                    //

                    if (!BlRangeListAddRange(&pCache->Ranges, pNewCacheEntry))
                    {
                        BlDiskCacheFreeRangeEntry(pNewCacheEntry);
                        goto SkipCache;
                    }

                    //
                    // Put this cache entry at the head of MRU.
                    //

                    InsertHeadList(&BlDiskCache.MRUBlockList,
                                   &pNewCacheEntry->UserLink);

                    //
                    // Now copy read data into callers buffer. Adjust
                    // the source pointer and the number of bytes to
                    // copy depending on whether the block we are going
                    // to copy from is the head or tail block, or both.
                    //

                    CopyLength = ReadLength;
                    pSrc = pNewCacheEntry->UserData;

                    if (ReadOffset == HeadBlockOffset)
                    {
                        CopyLength -= HeadBytesOffset;
                        pSrc += HeadBytesOffset;
                    }

                    if (ReadOffset == TailBlockOffset)
                    {
                        CopyLength -= (BL_DISKCACHE_BLOCK_SIZE - NumTailBytes);
                    }

                    DPRINT(("DK:  CopyNew:%08x,%08x,%d\n", pDest, pSrc, CopyLength));
                    DASSERT((pDest < (PUCHAR) Buffer) ||
                            (pDest + CopyLength > EndOfCallersBuffer));

                    RtlCopyMemory(pDest, pSrc, CopyLength);

                    //
                    // Set new ReadOffset.
                    //

                    ReadOffset += ReadLength;

                    //
                    // Update pDest & number of bytes we've filled in
                    // so far.
                    //

                    pDest += CopyLength;
                    *pCount += CopyLength;
                }
            }
            else
            {
                //
                // We don't need to cache what we read. Just read the
                // range from the disk.
                //

                StartOffset = pDistinctRanges[DistinctIdx].Start;
                pDest = ((PUCHAR) Buffer) +
                    (StartOffset - pOffset->QuadPart);
                ReadLength = (ULONG) (pDistinctRanges[DistinctIdx].End -
                                      pDistinctRanges[DistinctIdx].Start);
                LIReadOffset.QuadPart = StartOffset;

                if (ArcSeek(DeviceId,
                            &LIReadOffset,
                            SeekAbsolute) != ESUCCESS)
                {
                    goto SkipCache;
                }

                DPRINT(("DK:  ReadDistinct:%016I64x,%08x,%8d\n",
                        LIReadOffset.QuadPart, pDest, ReadLength));

                if (ArcRead(DeviceId,
                            pDest,
                            ReadLength,
                            &BytesRead) != ESUCCESS)
                {
                    goto SkipCache;
                }

                if (BytesRead != ReadLength)
                {
                    goto SkipCache;
                }

                *pCount += BytesRead;
            }
        }

        //
        // We should have read Length bytes.
        //

        ASSERT(*pCount == Length);

        //
        // Seek to where the device position should be if the request was
        // read from the device.
        //

        if (ArcSeek(DeviceId, &LargeEndOffset, SeekAbsolute) != ESUCCESS)
        {
            goto SkipCache;
        }

        return ESUCCESS;
    }

    //
    // If we hit a problem satisfying the request through the cache,
    // we'll jump here to try the normal read.
    //

 SkipCache:

    //
    // Reset the number of bytes read.
    //

    *pCount = 0;

    //
    // If no cache was found or data could not be read from the cache,
    // hand over to ArcRead.
    //

    if ((Status = ArcSeek(DeviceId, pOffset, SeekAbsolute)) != ESUCCESS)
    {
        return Status;
    }

    DPRINT(("DK:  SkipCacheRead:%016I64x,%08x,%d\n",
            LIReadOffset.QuadPart, pDest, CopyLength));

    Status = ArcRead(DeviceId, Buffer, Length, pCount);

    return Status;
}

ARC_STATUS
BlDiskCacheWrite (
    ULONG DeviceId,
    PLARGE_INTEGER pOffset,
    PVOID Buffer,
    ULONG Length,
    PULONG pCount
    )

/*++

Routine Description:

    Perform a write to the cached device. Currently simply invalidate
    any cached data around that range and call ArcWrite.

Arguments:

    DeviceId - Device to write to.

    Offset - Offset to write beginning from.

    Buffer - Data to write.

    Length - Number of bytes to write.

    pCount - Number of bytes written.

Return Value:

    Status.

    NOTE: DeviceId's (Seek) Position is undefined after this call.

--*/

{
    PBL_DISK_SUBCACHE pCache;
    ARC_STATUS Status;
    BLCRANGE WriteRange;

    DPRINT(("DK: WRITE(%5u,%016I64x,%08x,%8u)\n",
            DeviceId, pOffset->QuadPart, Buffer, Length));

    pCache = BlDiskCacheFindCacheForDevice(DeviceId);

    //
    // If a cache was found, invalidate cached data around
    // the range.
    //

    if (pCache)
    {
        WriteRange.Start = pOffset->QuadPart;
        WriteRange.End = WriteRange.Start + Length;

        //
        // The free-range-entry routine we initialized the rangelist
        // with will remove entries from the MRU list in addition to
        // free'ing them. So all we have to do is to call RemoveRange.
        //

        BlRangeListRemoveRange(&pCache->Ranges, &WriteRange);
    }

    if ((Status = ArcSeek(DeviceId, pOffset, SeekAbsolute)) != ESUCCESS)
    {
        return Status;
    }

    Status = ArcWrite(DeviceId, Buffer, Length, pCount);

    return Status;
}

BOOLEAN
BlDiskCacheMergeRangeRoutine (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    )

/*++

Routine Description:

    This routine is passed to rangelist initialization, so rangelist
    functions can use it to merge two cache blocks that are
    consecutive.

Arguments:

    pDestEntry, pSrcEntry - Two entries to merge.

Return Value:

    FALSE.

--*/

{
    UNREFERENCED_PARAMETER( pDestEntry );
    UNREFERENCED_PARAMETER( pSrcEntry );

    //
    // We don't want anything to get merged, because our block size is
    // fixed. So we always return FALSE.
    //

    return FALSE;
}

VOID
BlDiskCacheFreeRangeRoutine (
    PBLCRANGE_ENTRY pRangeEntry
    )

/*++

Routine Description:

    This routine is passed to rangelist initialization, so rangelist
    functions can use it to free a cache block entry and its data.

Arguments:

    pRangeEntry - Range entry to free.

Return Value:

    None.

--*/

{

    //
    // Remove from the MRU list.
    //

    RemoveEntryList(&pRangeEntry->UserLink);

    //
    // Call the function to free the range entry.
    //

    BlDiskCacheFreeRangeEntry(pRangeEntry);

    return;
}

PBLCRANGE_ENTRY
BlDiskCacheAllocateRangeEntry (
    VOID
    )

/*++

Routine Description:

    This routine allocates a range entry used to describe a cached
    range on a device. Its UserData points to a BLOCK_SIZE of memory
    to contain the cached data.

Arguments:

    None.

Return Value:

    Pointer to a range entry or NULL if out of memory.

--*/

{
    PBLCRANGE_ENTRY pFreeEntry = NULL;
    LIST_ENTRY *pFreeEntryLink;

    //
    // If the free list is not empty, remove an entry and return it.
    //

    if (!IsListEmpty(&BlDiskCache.FreeEntryList))
    {
        pFreeEntryLink = RemoveHeadList(&BlDiskCache.FreeEntryList);
        pFreeEntry = CONTAINING_RECORD(pFreeEntryLink,
                                       BLCRANGE_ENTRY,
                                       UserLink);
    }

    return pFreeEntry;
}

VOID
BlDiskCacheFreeRangeEntry (
    PBLCRANGE_ENTRY pEntry
    )

/*++

Routine Description:

    This routine frees a range entry. Currently it simply inserts it
    back on the FreeList, so it can be "allocated" when we need
    another range entry.

Arguments:

    pEntry - Pointer to the entry to be freed.

Return Value:

    None.

--*/

{
    //
    // Insert this entry back on the free list.
    //

    InsertHeadList(&BlDiskCache.FreeEntryList,
                   &pEntry->UserLink);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\kdcom\xxkdsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xxkdsup.c

Abstract:

    Com support.  Code to init a com port, store port state, map
    portable procedures to x86 procedures.

Author:

    Bryan M. Willman (bryanwi) 24-Sep-90

Revision History:

    Shielin Tzong (shielint) 10-Apr-91
                Add packet control protocol.

    John Vert (jvert) 11-Jul-1991
        Moved from KD/i386 to HAL

    Eric Nelson (enelson) 1-Jan-00
        Move from HAL into DLL

--*/

#include "kdcomp.h"
#include "kdcom.h"
#include "stdio.h"
#include "acpitabl.h"

#if DBG && IA64
CHAR KdProtocolTraceIn[4096];
ULONG KdProtocolIndexIn;
CHAR KdProtocolTraceOut[4096];
ULONG KdProtocolIndexOut;
#endif

PDEBUG_PORT_TABLE HalpDebugPortTable;

//
// This MUST be initialized to zero so we know not to do anything when
// CpGetByte is called when the kernel debugger is disabled.
//

CPPORT Port = {NULL, 0, PORT_DEFAULTRATE };

//
// Remember the debugger port information
//

CPPORT PortInformation = {NULL, 0, PORT_DEFAULTRATE};
ULONG ComPort = 0;
PHYSICAL_ADDRESS DbgpKdComPhysicalAddress; // ACPI DBGP KdCom physical address.

//
// Default debugger port in IO space.
//

UCHAR KdComAddressID = 1;                     // port debugger ident. : MMIO or IO space. Def:IO.
pKWriteUchar KdWriteUchar = CpWritePortUchar; // stub to real function: MMIO or IO space. Def:IO.
pKReadUchar  KdReadUchar  = CpReadPortUchar;  // stub to real function: MMIO or IO space. Def:IO.

//
//      We need this so the serial driver knows that the kernel debugger
//      is using a particular port.  The serial driver then knows not to
//      touch this port.  KdInitCom fills this in with the number of the
//      COM port it is using (1 or 2)
//
//      This will go in the registry as soon as the registry is working.
//

extern PUCHAR *KdComPortInUse;

BOOLEAN HalpGetInfoFromACPI = FALSE;



NTSTATUS
KdCompInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This procedure checks for which COM port should be used by kernel
    debugger.  If DebugParameter specifies a COM port, we will use it
    even if we can not find it (we trust user).  Otherwise, if COM2
    is present and there is no mouse attaching to it, we use COM2.
    If COM2 is not availabe, we check COM1.  If both COM1 and COM2 are
    not present, we give up and return false.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    LoaderBlock - supplies a pointer to the loader parameter block.

Returned Value:

    TRUE - If a debug port is found.

--*/
{

    PCONFIGURATION_COMPONENT_DATA ConfigurationEntry, ChildEntry;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    PCM_PARTIAL_RESOURCE_LIST List;
    ULONG MatchKey, i;
    ULONG BaudRate = BD_19200;
    PUCHAR PortAddress = NULL;
    UCHAR Irq = 0;
    ULONG Com = 0;

    if (LoaderBlock && KdGetAcpiTablePhase0) {
        HalpDebugPortTable =
            KdGetAcpiTablePhase0(LoaderBlock, DBGP_SIGNATURE);
    }

    if (HalpDebugPortTable) {

        KdComAddressID = HalpDebugPortTable->BaseAddress.AddressSpaceID; 

        //
        // Debug ports are supported in memory and IO space only.
        //

        if ((KdComAddressID == 0) ||
            (KdComAddressID == 1)) {

            DbgpKdComPhysicalAddress = HalpDebugPortTable->BaseAddress.Address;

            if(KdComAddressID == 0) {

                //
                // The address is memory, map it.
                //

                if (KdMapPhysicalMemory64) {
                    PortInformation.Address =
                        KdMapPhysicalMemory64(DbgpKdComPhysicalAddress, 1);
                }
            } else {

                // 
                // The address is in IO space.
                //

                PortInformation.Address = (PUCHAR)UlongToPtr(DbgpKdComPhysicalAddress.LowPart);
            }

            Port.Flags &= ~(PORT_MODEMCONTROL | PORT_DEFAULTRATE);
            HalpGetInfoFromACPI = TRUE;

            if (HalpDebugPortTable->InterfaceType == 0) {

                //
                // This is actually a 16550.  So pay attention
                // to the baud rate requested by the user.
                //

                if(DebugParameters->BaudRate != 0){
                    // Baud rate set by user so use it
                    PortInformation.Baud = DebugParameters->BaudRate;
#if 0
                //
                // There's no 'BaudRate' field specified in the _DEBUG_PORT_TABLE
                // structure, so don't use it.
                // matth (1/2002)
                } else if(HalpDebugPortTable->BaudRate != 0){
                    // not specified by user so get it out of the debug table
                    PortInformation.Baud = KdCompGetDebugTblBaudRate(HalpDebugPortTable->BaudRate);
#endif
                } else {
                    // No debug table information available so use default
                    PortInformation.Baud = BD_57600;
                }

            } else {

                //
                // This is not a 16550.  So we must use
                // the fixed baud rate of 57600.
                //

                PortInformation.Baud = BD_57600;
            }
        }
    }

    //
    // Check if Port and baudrate have been determined.
    //

    if ((PortInformation.Address == NULL) && !HalpGetInfoFromACPI) {

        //
        // First see if the DebugParameters contains debugging port info.
        //

        if (DebugParameters->BaudRate != 0) {
            BaudRate = DebugParameters->BaudRate;
            Port.Flags &= ~PORT_DEFAULTRATE;
        }

        if (DebugParameters->CommunicationPort != 0) {

            //
            // Find the configuration information of the specified serial port.
            //

            Com = DebugParameters->CommunicationPort;
            MatchKey = Com - 1;
            if (LoaderBlock != NULL) {
                ConfigurationEntry = KeFindConfigurationEntry(LoaderBlock->ConfigurationRoot,
                                                              ControllerClass,
                                                              SerialController,
                                                              &MatchKey);

            } else {
                ConfigurationEntry = NULL;
            }

        } else {

            //
            // Check if COM2 is present and make sure no mouse attaches to it.
            //

            MatchKey = 1;
            if (LoaderBlock != NULL) {
                ConfigurationEntry = KeFindConfigurationEntry(LoaderBlock->ConfigurationRoot,
                                                              ControllerClass,
                                                              SerialController,
                                                              &MatchKey);

            } else {
                ConfigurationEntry = NULL;
            }

            if (ConfigurationEntry != NULL) {
                ChildEntry = ConfigurationEntry->Child;
                if ((ChildEntry != NULL) &&
                    (ChildEntry->ComponentEntry.Type == PointerPeripheral)) {
                    ConfigurationEntry = NULL;
                }
            }

            //
            // If COM2 does not exist or a serial mouse attaches to it, try
            // COM1.  If COM1 exists, we will use it no matter what is on
            // it.
            //

            if (ConfigurationEntry == NULL) {
                MatchKey = 0;
                if (LoaderBlock != NULL) {
                    ConfigurationEntry = KeFindConfigurationEntry(LoaderBlock->ConfigurationRoot,
                                                                  ControllerClass,
                                                                  SerialController,
                                                                  &MatchKey);

                } else {
                    ConfigurationEntry = NULL;
                }

                if (ConfigurationEntry != NULL) {
                    Com = 1;
                } else if (CpDoesPortExist((PUCHAR)COM2_PORT)) {
                    PortAddress = (PUCHAR)COM2_PORT;
                    Com = 2;
                } else if (CpDoesPortExist((PUCHAR)COM1_PORT)) {
                    PortAddress = (PUCHAR)COM1_PORT;
                    Com = 1;
                } else {
                    return STATUS_NOT_FOUND;
                }
            } else {
                Com = 2;
            }
        }

        //
        // Get Comport address from the component configuration data.
        // (If we find the ComponentEntry associated with the com port)
        //

        if (ConfigurationEntry) {
            List = (PCM_PARTIAL_RESOURCE_LIST)ConfigurationEntry->ConfigurationData;
            for (i = 0; i < List->Count ; i++ ) {
                Descriptor = &List->PartialDescriptors[i];
                if (Descriptor->Type == CmResourceTypePort) {
                    PortAddress = (PUCHAR)UlongToPtr(Descriptor->u.Port.Start.LowPart);
                }
            }
        }

        //
        // If we can not find the port address for the comport, simply use
        // default value.
        //

        if (PortAddress == NULL) {
            switch (Com) {
            case 1:
               PortAddress = (PUCHAR)COM1_PORT;
               break;
            case 2:
               PortAddress = (PUCHAR)COM2_PORT;
               break;
            case 3:
               PortAddress = (PUCHAR)COM3_PORT;
               break;
            case 4:
               PortAddress = (PUCHAR)COM4_PORT;
            }
        }

        //
        // Initialize the port structure.
        //

        ComPort = Com;
        PortInformation.Address = PortAddress;
        PortInformation.Baud = BaudRate;
    }

    if (KdComAddressID == 0) { // MMIO
        KdWriteUchar = CpWriteRegisterUchar;
        KdReadUchar  = CpReadRegisterUchar;
    }

    CpInitialize(&Port,
                 PortInformation.Address,
                 PortInformation.Baud
                 );

    //
    // The following should be reworked in conjunction with the serial
    // driver.   The serial driver doesn't understand the concept of
    // ports being memory so we need to have it believe we are using 
    // the IO port even though we are using a memory mapped equivalent.
    //

    if (HalpDebugPortTable && (KdComAddressID == 0))  {
        *KdComPortInUse = (UCHAR *)((ULONG_PTR)(*KdComPortInUse) & (PAGE_SIZE-1));
    }
    else  {
        *KdComPortInUse = PortInformation.Address;
    }

    return STATUS_SUCCESS;
}



ULONG
KdCompGetByte(
    OUT PUCHAR Input
    )
/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/
{
    ULONG status = CpGetByte(&Port, Input, TRUE);
#if DBG && IA64
    KdProtocolTraceIn[KdProtocolIndexIn++%4096]=*Input;
#endif
    return status;
}



ULONG
KdCompPollByte(
    OUT PUCHAR Input
    )
/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/
{
    ULONG status = CpGetByte(&Port, Input, FALSE);
#if DBG && IA64
    KdProtocolTraceIn[KdProtocolIndexIn++%4096]=*Input;
#endif
    return status;
}



VOID
KdCompPutByte(
    IN UCHAR Output
    )
/*++

Routine Description:

    Write a byte to the debug port.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/
{
#if DBG && IA64
    KdProtocolTraceOut[KdProtocolIndexOut++%4096]=Output;
#endif
    CpPutByte(&Port, Output);
}



VOID
KdCompRestore(
    VOID
    )
/*++

Routine Description:

    This routine does NOTHING on the x86.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Port.Flags &= ~PORT_SAVED;
}



VOID
KdCompSave(
    VOID
    )
/*++

Routine Description:

    This routine does NOTHING on the x86.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Port.Flags |= PORT_SAVED;
}


VOID
KdCompInitialize1(
    VOID
    )
{
    if(KdComAddressID == 0) {  // MMIO
       Port.Address    = (PUCHAR)MmMapIoSpace(DbgpKdComPhysicalAddress,8,MmNonCached);
       *KdComPortInUse = Port.Address;
    }
} // KdCompInitialize1()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\arcdisk.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    arcdisk.c

Abstract:

    Provides the routines for collecting the disk information for all the ARC
    disks visible in the ARC environment.

Author:

    John Vert (jvert) 3-Nov-1993

Revision History:

   Vijay Jayaseelan (vijayj)    2-April-2000
   
        -   Added EFI partition table support

--*/
#include "bootlib.h"

#ifdef i386
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#ifdef EFI_PARTITION_SUPPORT

//
// EFI partition entries
//
UNALIGNED EFI_PARTITION_ENTRY EfiPartitionBuffer[128] = {0};

#endif

BOOLEAN
BlpEnumerateDisks(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    );


#if defined(_X86_) && !defined(ARCI386)

static
VOID
BlpEnumerateXInt13(
    VOID
    )
/*++

Routine Description:

    This routine will go through all the enumerated disks and record
    their ability to support xInt13.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CHAR Partition[100];
    ULONG DiskId;
    ARC_STATUS Status;
    PARC_DISK_SIGNATURE DiskSignature;
    PARC_DISK_INFORMATION DiskInfo;
    PLIST_ENTRY Entry;

    DiskInfo = BlLoaderBlock->ArcDiskInformation;
    Entry = DiskInfo->DiskSignatures.Flink;

    while (Entry != &DiskInfo->DiskSignatures) {
        DiskSignature = CONTAINING_RECORD(Entry,ARC_DISK_SIGNATURE,ListEntry);

        //
        // Open partition0 on the disk and get it's device ID.
        //
        strcpy(Partition, DiskSignature->ArcName);
        strcat(Partition, "partition(0)");

        Status = ArcOpen(Partition, ArcOpenReadOnly, &DiskId);

        if( Status == ESUCCESS ) {
            //
            // Now we've got the DiskId.  Fortunately, someone
            // has been keeping track of all the DiskIds on the
            // machine and whether or not they've got xint13 support.
            // All we need to do now is go lookup our diskid in
            // that database and get the xint13 BOOLEAN.
            //
            DiskSignature->xInt13 = BlFileTable[DiskId].u.DriveContext.xInt13;

            //
            // We don't need you anymore.
            //
            ArcClose(DiskId);
        } else {
            DiskSignature->xInt13 = FALSE;

        }

        Entry = Entry->Flink;
    }

}

#endif // for defined(_X86_) && !defined(ARCI386)

ARC_STATUS
BlGetArcDiskInformation(
    BOOLEAN XInt13Support
    )

/*++

Routine Description:

    Enumerates the ARC disks present in the system and collects the identifying disk
    information from each one.

Arguments:

    XInt13Support  :  Indicates whether to find XInt13 support or not

Return Value:

    None.

--*/

{
    PARC_DISK_INFORMATION DiskInfo;

#if !(defined(_X86_) && !defined(ARCI386))
    UNREFERENCED_PARAMETER(XInt13Support);
#endif

    DiskInfo = BlAllocateHeap(sizeof(ARC_DISK_INFORMATION));
    if (DiskInfo==NULL) {
        return(ENOMEM);
    }

    InitializeListHead(&DiskInfo->DiskSignatures);

    BlLoaderBlock->ArcDiskInformation = DiskInfo;

    BlSearchConfigTree(BlLoaderBlock->ConfigurationRoot,
                       PeripheralClass,
                       DiskPeripheral,
                       (ULONG)-1,
                       BlpEnumerateDisks);

#if defined(_X86_) && !defined(ARCI386)

    //
    // Enumerate XInt13 support on X86 only if asked for
    //
    if (XInt13Support) {
        BlpEnumerateXInt13();
    }

#endif    
    
    return(ESUCCESS);

}


BOOLEAN
BlpEnumerateDisks(
    IN PCONFIGURATION_COMPONENT_DATA ConfigData
    )

/*++

Routine Description:

    Callback routine for enumerating the disks in the ARC firmware tree.  It
    reads all the necessary information from the disk to uniquely identify
    it.

Arguments:

    ConfigData - Supplies a pointer to the disk's ARC component data.

Return Value:

    TRUE - continue searching

    FALSE - stop searching tree.

--*/

{
    CHAR DiskName[100];

    BlGetPathnameFromComponent(ConfigData, DiskName);
    return(BlReadSignature(DiskName,FALSE));
}


BOOLEAN
BlReadSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom
    )

/*++

Routine Description:

    Given an ARC disk name, reads the MBR and adds its signature to the list of
    disks.

Arguments:

    Diskname - Supplies the name of the disk.

    IsCdRom - Indicates whether the disk is a CD-ROM.

Return Value:

    TRUE - Success

    FALSE - Failure

--*/

{
    PARC_DISK_SIGNATURE Signature;
    BOOLEAN Status = FALSE;

    Signature = BlAllocateHeap(sizeof(ARC_DISK_SIGNATURE));
    if (Signature==NULL) {
        return(FALSE);
    }

    Signature->ArcName = BlAllocateHeap((ULONG)strlen(DiskName)+2);
    if (Signature->ArcName==NULL) {
        return(FALSE);
    }

#if defined(i386) 
    Status = BlFindDiskSignature(DiskName, Signature);
#endif

    if(!Status) {
        Status = BlGetDiskSignature(DiskName, IsCdRom, Signature);
    }

    if (Status) {
        InsertHeadList(&BlLoaderBlock->ArcDiskInformation->DiskSignatures,
                       &Signature->ListEntry);

    }

    return(TRUE);

}

BOOLEAN
ArcDiskGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
/*++

Routine Description:

    This routine is a callback for reading data for a routine that
    validates the GPT partition table.
    
    NOTE: This routine changes the seek position on disk, and you must seek
          back to your original seek position if you plan on reading from the
          disk after making this call.

Arguments:

    StartingLBA - starting logical block address to read from.

    BytesToRead - Indicates how many bytes are to be read.

    pContext - context pointer for hte function (in this case, a pointer to the disk id.)
    
    OutputBuffer - a buffer that receives the data.  It's assumed that it is at least
                   BytesToRead big enough.

Return Value:

    TRUE - success, data has been read

    FALSE - failed, data has not been read.

--*/
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    PUSHORT DataPointer;
    ULONG DiskId;
    ULONG ReadCount = 0;
    

    DiskId = *((PULONG)pContext);
    //
    // read the second LBA on the disk
    //
    SeekPosition.QuadPart = StartingLBA * SECTOR_SIZE;
    
    Status = ArcSeek(DiskId,
                      &SeekPosition,
                      SeekAbsolute );

    if (Status != ESUCCESS) {
        return FALSE;
    }

    DataPointer = OutputBuffer;

    Status = ArcRead(
                DiskId,
                DataPointer,
                BytesToRead,
                &ReadCount);

    if ((Status == ESUCCESS) && (ReadCount == BytesToRead)) {
        return(TRUE);
    }
    
    return(FALSE);

}



BOOLEAN
BlGetDiskSignature(
    IN PCHAR DiskName,
    IN BOOLEAN IsCdRom,
    PARC_DISK_SIGNATURE Signature
    )

/*++

Routine Description:

    This routine gets the NTFT disk signature for a specified partition or
    path.

Arguments:

    DiskName - Supplies the arcname of the partition or drive.

    IsCdRom - Indicates whether the disk is a CD-ROM.

    Signature - Returns a full ARC_DISK_SIGNATURE.

Return Value:

    TRUE - success, Signature will be filled in.

    FALSE - failed, Signature will not be filled in.

--*/

{
    UCHAR SectorBuffer[2048+256] = {0};
    CHAR Partition[100];
    ULONG DiskId;
    ULONG Status;
    LARGE_INTEGER SeekValue;
    PUCHAR Sector;
    ULONG i;
    ULONG Sum;
    ULONG Count;
    ULONG SectorSize;
    EFI_PARTITION_TABLE *EfiHdr;

    if (IsCdRom) {
        SectorSize = 2048;
    } else {
        SectorSize = 512;
    }

#if defined(_i386_)
    //
    // NTDETECT creates an "eisa(0)..." arcname for detected
    // BIOS disks on an EISA machine.  Change this to "multi(0)..."
    // in order to be consistent with the rest of the system
    // (particularly the arcname in boot.ini)
    //
    if (_strnicmp(DiskName,"eisa",4)==0) {
        strcpy(Signature->ArcName,"multi");
        strcpy(Partition,"multi");
        strcat(Signature->ArcName,DiskName+4);
        strcat(Partition,DiskName+4);
    } else {
        strcpy(Signature->ArcName, DiskName);
        strcpy(Partition, DiskName);
    }
#else
    strcpy(Signature->ArcName, DiskName);
    strcpy(Partition, DiskName);
#endif

    strcat(Partition, "partition(0)");

    Status = ArcOpen(Partition, ArcOpenReadOnly, &DiskId);
    if (Status != ESUCCESS) {
        return(FALSE);
    }

    //
    // Read in the first sector
    //
    Sector = ALIGN_BUFFER(SectorBuffer);
    if (IsCdRom) {
        //
        // For a CD-ROM, the interesting data starts at 0x8000.
        //
        SeekValue.QuadPart = 0x8000;
    } else {
        SeekValue.QuadPart = 0;
    }
    Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
    if (Status == ESUCCESS) {
        Status = ArcRead(DiskId,
                         Sector,
                         SectorSize,
                         &Count);
    }
    if (Status != ESUCCESS) {
        ArcClose(DiskId);
        return(FALSE);
    }
       

    //
    // Check to see whether this disk has a valid partition table signature or not.
    //
    if (((PUSHORT)Sector)[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {
        Signature->ValidPartitionTable = FALSE;
    } else {
        Signature->ValidPartitionTable = TRUE;
    }

    Signature->Signature = ((PULONG)Sector)[PARTITION_TABLE_OFFSET/2-1];

    //
    // compute the checksum
    //
    Sum = 0;
    for (i=0; i<(SectorSize/4); i++) {
        Sum += ((PULONG)Sector)[i];
    }
    Signature->CheckSum = ~Sum + 1;

    //
    // Check for GPT disk.
    //
    Signature->IsGpt = FALSE;

    if (!IsCdRom) {
        SeekValue.QuadPart = 1 * SectorSize;
        Status = ArcSeek(DiskId, &SeekValue, SeekAbsolute);
        if (Status == ESUCCESS) {
            Status = ArcRead(DiskId,
                             Sector,
                             SectorSize,
                             &Count);
            if (Status == ESUCCESS) {
                ULONG tmpDiskId = DiskId;
    
                //
                // verify EFI partition table
                //
                EfiHdr = (EFI_PARTITION_TABLE *)Sector;
    
                if (BlIsValidGUIDPartitionTable(
                            EfiHdr,
                            1,
                            &tmpDiskId,
                            ArcDiskGPTDiskReadCallback)) {
                    Signature->IsGpt = TRUE;
                    memcpy(
                        Signature->GptSignature, 
                        EfiHdr->DiskGuid,
                        sizeof(EfiHdr->DiskGuid) );
                }
            }
        }
    }        

    ArcClose(DiskId);
    return(TRUE);
}


#ifdef EFI_PARTITION_SUPPORT



/*
void DbgOut(PWSTR Str);

//#define DBG_PRINT(x)    DbgOut(x);
ULONG BlGetKey();

#if defined(_IA64_)

#define STR_PREFIX  L

#define DBG_PRINT(x)    DbgOut(x)    

#else

#define STR_PREFIX  

#define DBG_PRINT(x)    \
{\
    BlPrint(x); \
    while (!BlGetKey()); \
} 

#endif  // _IA64_
*/

#define DBG_PRINT(x)
#define STR_PREFIX

UNALIGNED EFI_PARTITION_ENTRY *
BlLocateGPTPartition(
    IN UCHAR PartitionNumber,
    IN UCHAR MaxPartitions,
    IN PUCHAR ValidPartCount
    )
{
    UNALIGNED EFI_PARTITION_ENTRY *PartEntry = NULL;    
    UCHAR NullGuid[16] = {0};
    UCHAR PartIdx = 0;
    UCHAR PartCount = 0;

#if 0
    BlPrint("BlLocateGPTPartition(%d,%d,%d)\r\n",
                PartitionNumber,
                MaxPartitions,
                ValidPartCount ? *ValidPartCount : 0);
    while (!BlGetKey());                
#endif    

    if (ARGUMENT_PRESENT(ValidPartCount)) {
        PartCount = *ValidPartCount;
    }        

    PartitionNumber++;  // convert to one based index
    
    //
    // Locate the requested valid partition
    //    
    while ((PartIdx < MaxPartitions) && (PartCount < PartitionNumber)) {
        DBG_PRINT(STR_PREFIX"Verifying GPT Partition Entry\r\n");

        PartEntry = (UNALIGNED EFI_PARTITION_ENTRY *)(EfiPartitionBuffer + PartIdx);
        
        if ((memcmp(PartEntry->Type, NullGuid, 16)) &&
            (memcmp(PartEntry->Id, NullGuid, 16)) &&
            (PartEntry->StartingLBA != 0) && (PartEntry->EndingLBA != 0)) {
            DBG_PRINT(STR_PREFIX"Found Valid GPT Partition Entry\r\n");
            PartCount++;

            if (ARGUMENT_PRESENT(ValidPartCount)) {
                (*ValidPartCount)++;
            }                

            //
            // Get hold of the partition entry
            //
            if (PartCount == PartitionNumber) {
                break;
            } else {
                PartEntry = NULL;
            }                
        } else {
            PartEntry = NULL;
        }            

        PartIdx++;
    }   

    return PartEntry;
}

BOOLEAN
BlDiskOpenGPTDiskReadCallback(
    ULONGLONG StartingLBA,
    ULONG    BytesToRead,
    PVOID     pContext,
    UNALIGNED PVOID OutputBuffer
    )
/*++

Routine Description:

    This routine is a callback for reading data for a routine that
    validates the GPT partition table.

Arguments:

    StartingLBA - starting logical block address to read from.

    BytesToRead - Indicates how many bytes are to be read.

    pContext - context pointer for hte function (in this case, a pointer to the disk id.)
    
    OutputBuffer - a buffer that receives the data.  It's assumed that it is at least
                   BytesToRead big enough.

Return Value:

    TRUE - success, data has been read

    FALSE - failed, data has not been read.

--*/
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    PUSHORT DataPointer;
    ULONG DiskId;
    ULONG ReadCount = 0;
    

    DiskId = *((PULONG)pContext);
    //
    // read the second LBA on the disk
    //
    SeekPosition.QuadPart = StartingLBA * SECTOR_SIZE;
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &SeekPosition,
                                                          SeekAbsolute );

    if (Status != ESUCCESS) {
        return FALSE;
    }

    DataPointer = OutputBuffer;

    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          DataPointer,
                                                          BytesToRead,
                                                          &ReadCount);

    if ((Status == ESUCCESS) && (ReadCount == BytesToRead)) {
        return(TRUE);
    }
    
    return(FALSE);

}



ARC_STATUS
BlOpenGPTDiskPartition(
    IN ULONG FileId,
    IN ULONG DiskId,
    IN UCHAR PartitionNumber
    )
{
    ARC_STATUS          Status;
    LARGE_INTEGER       SeekPosition;
    UCHAR               DataBuffer[SECTOR_SIZE * 2] = {0};
    ULONG               ReadCount = 0;
    UCHAR               NullGuid[16] = {0};
    UNALIGNED EFI_PARTITION_TABLE  *EfiHdr;
    UNALIGNED EFI_PARTITION_ENTRY *PartEntry;
    ULONG               tmpDiskId = DiskId;

    if (PartitionNumber >= 128)
        return EINVAL;

    DBG_PRINT(STR_PREFIX"Seeking GPT PT\r\n");
    
    //
    // read the second LBA on the disk
    //
    SeekPosition.QuadPart = 1 * SECTOR_SIZE;
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &SeekPosition,
                                                          SeekAbsolute );

    if (Status != ESUCCESS)
        return Status;

    DBG_PRINT(STR_PREFIX"Reading GPT PT\r\n");
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          DataBuffer,
                                                          SECTOR_SIZE,
                                                          &ReadCount);
                                                          
    if (Status != ESUCCESS)
        return Status;

    if (ReadCount != SECTOR_SIZE) {
        Status = EIO;

        return Status;
    }        

    EfiHdr = (UNALIGNED EFI_PARTITION_TABLE *)DataBuffer;
                                                          
    DBG_PRINT(STR_PREFIX"Verifying GPT PT\r\n");
    
    //
    // verify EFI partition table
    //
    if (!BlIsValidGUIDPartitionTable(
                            EfiHdr,
                            1,
                            &tmpDiskId,
                            BlDiskOpenGPTDiskReadCallback)) {    
        Status = EBADF;
        return Status;
    }        

    //
    // Locate and read the partition entry
    // which is requested
    //
    SeekPosition.QuadPart = EfiHdr->PartitionEntryLBA * SECTOR_SIZE;
        
    DBG_PRINT(STR_PREFIX"Seeking GPT Partition Entries\r\n");
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Seek)(DiskId,
                                                          &SeekPosition,
                                                          SeekAbsolute );

    if (Status != ESUCCESS)
        return Status;

    RtlZeroMemory(EfiPartitionBuffer, sizeof(EfiPartitionBuffer));        

    DBG_PRINT(STR_PREFIX"Reading GPT Partition Entries\r\n");
    
    Status = (BlFileTable[DiskId].DeviceEntryTable->Read)(DiskId,
                                                          EfiPartitionBuffer,
                                                          sizeof(EfiPartitionBuffer),
                                                          &ReadCount);
                                                          
    if (Status != ESUCCESS)
        return Status;

    if (ReadCount != sizeof(EfiPartitionBuffer)) {
        Status = EIO;

        return Status;
    }  

    DBG_PRINT(STR_PREFIX"Locating the correct GPT partition entry\r\n");
    
    PartEntry = (UNALIGNED EFI_PARTITION_ENTRY *)BlLocateGPTPartition(PartitionNumber, 128, NULL);

    if (PartEntry) {
        DBG_PRINT(STR_PREFIX"Verifying GPT Partition Entry\r\n");
    
        if ((memcmp(PartEntry->Type, NullGuid, 16)) &&
            (memcmp(PartEntry->Id, NullGuid, 16)) &&
            (PartEntry->StartingLBA != 0) && (PartEntry->EndingLBA != 0)) {
            PPARTITION_CONTEXT PartContext = &(BlFileTable[FileId].u.PartitionContext);
            ULONG   SectorCount = (ULONG)(PartEntry->EndingLBA - PartEntry->StartingLBA);

            DBG_PRINT(STR_PREFIX"Initializing GPT Partition Entry Context\r\n");

            //
            // Fill the partition context structure
            //
            PartContext->PartitionLength.QuadPart = SectorCount * SECTOR_SIZE;
            PartContext->StartingSector = (ULONG)(PartEntry->StartingLBA);
            PartContext->EndingSector = (ULONG)(PartEntry->EndingLBA);
            PartContext->DiskId = (UCHAR)DiskId;

            BlFileTable[FileId].Position.QuadPart = 0;

#if 0
            BlPrint("GPT Partition opened:L:%ld,%ld:%ld,SS:%ld,ES:%ld\n",
                    PartitionNumber,
                    (ULONG)PartContext->PartitionLength.QuadPart,
                    (ULONG)PartContext->StartingSector,
                    (ULONG)PartContext->EndingSector);

            while (!GET_KEY());                
#endif        

            Status = ESUCCESS;
        } else {
            Status = EBADF;
        }
    } else {
        Status = EBADF;
    }        

    DBG_PRINT(STR_PREFIX"Returning from BlOpenGPTDiskPartition(...)\r\n");

    return Status;
}

#endif //   for EFI_PARTITION_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blconfig.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blconfig.c

Abstract:

    This module implements the OS loader configuration initialization.

Author:

    David N. Cutler (davec) 9-Sep-1991

Revision History:

--*/
#include "bootlib.h"
#include "stdio.h"
#include "stdlib.h"

ULONG
BlMatchToken (
    IN PCHAR TokenValue,
    IN CHAR * FIRMWARE_PTR TokenArray[]
    );

PCHAR
BlGetNextToken (
    IN PCHAR TokenString,
    OUT PCHAR OutputToken,
    OUT PULONG UnitNumber
    );

//
// Define types of adapters that can be booted from.
//

typedef enum _ADAPTER_TYPES {
    AdapterEisa,
    AdapterScsi,
    AdapterMulti,
    AdapterNet,
    AdapterRamdisk,
    AdapterMaximum
    } ADAPTER_TYPES;

//
// Define type of controllers that can be booted from.
//

typedef enum _CONTROLLER_TYPES {
    ControllerDisk,
    ControllerCdrom,
    ControllerMaximum
    } CONTROLLER_TYPES;

//
// Define type of peripheral that can be booted from.
//

typedef enum _PERIPHERAL_TYPES {
    PeripheralRigidDisk,
    PeripheralFloppyDisk,
#if defined(ELTORITO)
    PeripheralElTorito,
#endif
    PeripheralMaximum
    } PERIPHERAL_TYPES;

//
// Define the ARC pathname mnemonics.
//

CHAR * FIRMWARE_PTR MnemonicTable[] = {
    "arc",
    "cpu",
    "fpu",
    "pic",
    "pdc",
    "sic",
    "sdc",
    "sc",
    "eisa",
    "tc",
    "scsi",
    "dti",
    "multi",
    "disk",
    "tape",
    "cdrom",
    "worm",
    "serial",
    "net",
    "video",
    "par",
    "point",
    "key",
    "audio",
    "other",
    "rdisk",
    "fdisk",
    "tape",
    "modem",
    "monitor",
    "print",
    "pointer",
    "keyboard",
    "term",
    "other"
    };

CHAR * FIRMWARE_PTR BlAdapterTypes[AdapterMaximum + 1] = {"eisa","scsi","multi","net","ramdisk",NULL};
CHAR * FIRMWARE_PTR BlControllerTypes[ControllerMaximum + 1] = {"disk","cdrom",NULL};
#if defined(ELTORITO)
CHAR * FIRMWARE_PTR BlPeripheralTypes[PeripheralMaximum + 1] = {"rdisk","fdisk","cdrom",NULL};
#else
CHAR * FIRMWARE_PTR BlPeripheralTypes[PeripheralMaximum + 1] = {"rdisk","fdisk",NULL};
#endif


ARC_STATUS
BlConfigurationInitialize (
    IN PCONFIGURATION_COMPONENT Parent,
    IN PCONFIGURATION_COMPONENT_DATA ParentEntry
    )

/*++

Routine Description:

    This routine traverses the firmware configuration tree from the specified
    parent entry and constructs the corresponding NT configuration tree.

Arguments:

    None.

Return Value:

    ESUCCESS is returned if the initialization is successful. Otherwise,
    an unsuccessful status that describes the error is returned.

--*/

{

    PCONFIGURATION_COMPONENT Child;
    PCONFIGURATION_COMPONENT_DATA ChildEntry;
    PCHAR ConfigurationData;
    PCONFIGURATION_COMPONENT_DATA PreviousSibling;
    PCONFIGURATION_COMPONENT Sibling;
    PCONFIGURATION_COMPONENT_DATA SiblingEntry;
    ARC_STATUS Status;

    //
    // Traverse the child configuration tree and allocate, initialize, and
    // construct the corresponding NT configuration tree.
    //

    Child = ArcGetChild(Parent);
    while (Child != NULL) {

        //
        // Allocate an entry of the appropriate size to hold the child
        // configuration information.
        //

        ChildEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap(
                                        sizeof(CONFIGURATION_COMPONENT_DATA) +
                                            Child->IdentifierLength +
                                                Child->ConfigurationDataLength);

        if (ChildEntry == NULL) {
            return ENOMEM;
        }

        //
        // Initialize the tree pointers and copy the component data.
        //

        if (ParentEntry == NULL) {
            BlLoaderBlock->ConfigurationRoot = ChildEntry;

        } else {
            ParentEntry->Child = ChildEntry;
        }

        ChildEntry->Parent = ParentEntry;
        ChildEntry->Sibling = NULL;
        ChildEntry->Child = NULL;
        RtlMoveMemory((PVOID)&ChildEntry->ComponentEntry,
                      (PVOID)Child,
                      sizeof(CONFIGURATION_COMPONENT));

        ConfigurationData = (PCHAR)(ChildEntry + 1);

        //
        // If configuration data is specified, then copy the configuration
        // data.
        //

        if (Child->ConfigurationDataLength != 0) {
            ChildEntry->ConfigurationData = (PVOID)ConfigurationData;
            Status = ArcGetConfigurationData((PVOID)ConfigurationData,
                                             Child);

            if (Status != ESUCCESS) {
                return Status;
            }

            ConfigurationData += Child->ConfigurationDataLength;

        } else {
            ChildEntry->ConfigurationData = NULL;
        }

        //
        // If identifier data is specified, then copy the identifier data.
        //

        if (Child->IdentifierLength !=0) {
            ChildEntry->ComponentEntry.Identifier = ConfigurationData;
            RtlMoveMemory((PVOID)ConfigurationData,
                          (PVOID)Child->Identifier,
                          Child->IdentifierLength);

        } else {
            ChildEntry->ComponentEntry.Identifier = NULL;
        }

        //
        // Traverse the sibling configuration tree and allocate, initialize,
        // and construct the corresponding NT configuration tree.
        //

        PreviousSibling = ChildEntry;
        Sibling = ArcGetPeer(Child);
        while (Sibling != NULL) {

            //
            // Allocate an entry of the appropriate size to hold the sibling
            // configuration information.
            //

            SiblingEntry = (PCONFIGURATION_COMPONENT_DATA)BlAllocateHeap(
                                    sizeof(CONFIGURATION_COMPONENT_DATA) +
                                        Sibling->IdentifierLength +
                                            Sibling->ConfigurationDataLength);

            if (SiblingEntry == NULL) {
                return ENOMEM;
            }

            //
            // Initialize the tree pointers and copy the component data.
            //

            SiblingEntry->Parent = ParentEntry;
            SiblingEntry->Sibling = NULL;
            ChildEntry->Child = NULL;
            RtlMoveMemory((PVOID)&SiblingEntry->ComponentEntry,
                          (PVOID)Sibling,
                          sizeof(CONFIGURATION_COMPONENT));

            ConfigurationData = (PCHAR)(SiblingEntry + 1);

            //
            // If configuration data is specified, then copy the configuration
            // data.
            //

            if (Sibling->ConfigurationDataLength != 0) {
                SiblingEntry->ConfigurationData = (PVOID)ConfigurationData;
                Status = ArcGetConfigurationData((PVOID)ConfigurationData,
                                                 Sibling);

                if (Status != ESUCCESS) {
                    return Status;
                }

                ConfigurationData += Sibling->ConfigurationDataLength;

            } else {
                SiblingEntry->ConfigurationData = NULL;
            }

            //
            // If identifier data is specified, then copy the identifier data.
            //

            if (Sibling->IdentifierLength !=0) {
                SiblingEntry->ComponentEntry.Identifier = ConfigurationData;
                RtlMoveMemory((PVOID)ConfigurationData,
                              (PVOID)Sibling->Identifier,
                              Sibling->IdentifierLength);

            } else {
                SiblingEntry->ComponentEntry.Identifier = NULL;
            }

            //
            // If the sibling has a child, then generate the tree for the
            // child.
            //

            if (ArcGetChild(Sibling) != NULL) {
                Status = BlConfigurationInitialize(Sibling, SiblingEntry);
                if (Status != ESUCCESS) {
                    return Status;
                }
            }

            //
            // Set new sibling pointers and get the next sibling tree entry.
            //

            PreviousSibling->Sibling = SiblingEntry;
            PreviousSibling = SiblingEntry;
            Sibling = ArcGetPeer(Sibling);
        }

        //
        // Set new parent pointers and get the next child tree entry.
        //

        Parent = Child;
        ParentEntry = ChildEntry;
        Child = ArcGetChild(Child);
    }

    return ESUCCESS;
}



BOOLEAN
BlSearchConfigTree(
    IN PCONFIGURATION_COMPONENT_DATA Node,
    IN CONFIGURATION_CLASS Class,
    IN CONFIGURATION_TYPE Type,
    IN ULONG Key,
    IN PNODE_CALLBACK CallbackRoutine
    )
/*++

Routine Description:

    Conduct a depth-first search of the firmware configuration tree starting
    at a given node, looking for nodes that match a given class and type.
    When a matching node is found, call a callback routine.

Arguments:

    CurrentNode - node at which to begin the search.

    Class - configuration class to match, or -1 to match any class

    Type - configuration type to match, or -1 to match any class

    Key - key to match, or -1 to match any key

    FoundRoutine - pointer to a routine to be called when a node whose
        class and type match the class and type passed in is located.
        The routine takes a pointer to the configuration node and must
        return a boolean indicating whether to continue with the traversal.

Return Value:

    FALSE if the caller should abandon the search.
--*/
{
    PCONFIGURATION_COMPONENT_DATA Child;

    do {
        if ((Child = Node->Child) != 0) {
            if (!BlSearchConfigTree(Child,
                                     Class,
                                     Type,
                                     Key,
                                     CallbackRoutine)) {
                return(FALSE);
            }
        }

        if (((Class == -1) || (Node->ComponentEntry.Class == Class))
          &&((Type == -1) || (Node->ComponentEntry.Type == Type))
          &&((Key == (ULONG)-1) || (Node->ComponentEntry.Key == Key))) {

              if (!CallbackRoutine(Node)) {
                  return(FALSE);
              }
        }

        Node = Node->Sibling;

    } while ( Node != NULL );

    return(TRUE);
}


VOID
BlGetPathnameFromComponent(
    IN PCONFIGURATION_COMPONENT_DATA Component,
    OUT PCHAR ArcName
    )

/*++

Routine Description:

    This function builds an ARC pathname for the specified component.

Arguments:

    Component - Supplies a pointer to a configuration component.

    ArcName - Returns the ARC name of the specified component.  Caller must
        provide a large enough buffer.

Return Value:

    None.

--*/
{

    if (Component->Parent != NULL) {
        BlGetPathnameFromComponent(Component->Parent,ArcName);
        //
        // append our segment to the arcname
        //

        sprintf(ArcName+strlen(ArcName),
                "%s(%d)",
                MnemonicTable[Component->ComponentEntry.Type],
                Component->ComponentEntry.Key);

    } else {
        //
        // We are the parent, initialize the string and return
        //
        ArcName[0] = '\0';
    }

    return;
}


BOOLEAN
BlGetPathMnemonicKey(
    IN PCHAR OpenPath,
    IN PCHAR Mnemonic,
    IN PULONG Key
    )

/*++

Routine Description:

    This routine looks for the given Mnemonic in OpenPath.
    If Mnemonic is a component of the path, then it converts the key
    value to an integer wich is returned in Key.

Arguments:

    OpenPath - Pointer to a string that contains an ARC pathname.

    Mnemonic - Pointer to a string that contains a ARC Mnemonic

    Key      - Pointer to a ULONG where the Key value is stored.


Return Value:

    FALSE  if mnemonic is found in path and a valid key is converted.
    TRUE   otherwise.

--*/

{

    PCHAR Tmp;
    CHAR  Digits[9];
    ULONG i;
    CHAR  String[16];

    //
    // Construct a string of the form ")mnemonic("
    //
    String[0]=')';
    for(i=1;*Mnemonic;i++) {
        String[i] = * Mnemonic++;
    }
    String[i++]='(';
    String[i]='\0';

    if ((Tmp=strstr(OpenPath,&String[1])) == NULL) {
        return TRUE;
    }

    if (Tmp != OpenPath) {
        if ((Tmp=strstr(OpenPath,String)) == NULL) {
            return TRUE;
        }
    } else {
        i--;
    }
    //
    // skip the mnemonic and convert the value in between parentheses to integer
    //
    Tmp+=i;
    for (i=0;i<sizeof(Digits) - 1;i++) {
        if (*Tmp == ')') {
            Digits[i] = '\0';
            break;
        }
        Digits[i] = *Tmp++;
    }
    Digits[i]='\0';
    *Key = atoi(Digits);
    return FALSE;
}


ARC_STATUS
BlGenerateDeviceNames (
    IN PCHAR ArcDeviceName,
    OUT PCHAR ArcCanonicalName,
    OUT OPTIONAL PCHAR NtDevicePrefix
    )

/*++

Routine Description:

    This routine generates an NT device name prefix and a canonical ARC
    device name from an ARC device name.

Arguments:

    ArcDeviceName - Supplies a pointer to a zero terminated ARC device
        name.

    ArcCanonicalName - Supplies a pointer to a variable that receives the
        ARC canonical device name.

    NtDevicePrefix - If present, supplies a pointer to a variable that receives the
        NT device name prefix.

Return Value:

    ESUCCESS is returned if an NT device name prefix and the canonical
    ARC device name are successfully generated from the ARC device name.
    Otherwise, an invalid argument status is returned.

--*/

{

    CHAR AdapterPath[64];
    CHAR AdapterName[32];
    ULONG AdapterNumber;
    CHAR ControllerName[32];
    ULONG ControllerNumber;
    ULONG MatchIndex;
    CHAR PartitionName[32];
    ULONG PartitionNumber;
    CHAR PeripheralName[32];
    ULONG PeripheralNumber;
    CHAR TokenValue[32];

    //
    // Get the adapter and make sure it is valid.
    //

    ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                   &AdapterName[0],
                                   &AdapterNumber);

    if (ArcDeviceName == NULL) {
        return EINVAL;
    }

    MatchIndex = BlMatchToken(&AdapterName[0], &BlAdapterTypes[0]);
    if (MatchIndex == AdapterMaximum) {
        return EINVAL;
    }

    sprintf(AdapterPath, "%s(%d)", AdapterName, AdapterNumber);
    if ((MatchIndex == AdapterNet) || (MatchIndex == AdapterRamdisk)) {
        strcpy(ArcCanonicalName, AdapterPath);
        if (ARGUMENT_PRESENT(NtDevicePrefix)) {
            *NtDevicePrefix = 0;
        }
        return ESUCCESS;
    }

    //
    // The next token is either another adapter or a controller.  ARC
    // names can have multiple adapters.  (e.g. "multi(0)scsi(0)disk(0)...")
    // Iterate until we find a token that is not an adapter.
    //

    do {
        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &ControllerName[0],
                                       &ControllerNumber);

        if (ArcDeviceName == NULL) {
            return EINVAL;
        }

        MatchIndex = BlMatchToken(&ControllerName[0], &BlAdapterTypes[0]);
        if (MatchIndex == AdapterMaximum) {
            //
            // If it is not an adapter, we must have reached the last
            // adapter in the name.  Fall through to the controller logic.
            //
            break;
        } else {
            //
            // We have found another adapter, add it to
            // the canonical adapter path
            //

            sprintf(AdapterPath+strlen(AdapterPath),
                    "%s(%d)",
                    ControllerName,
                    ControllerNumber);

        }

    } while ( TRUE );

    MatchIndex = BlMatchToken(&ControllerName[0], &BlControllerTypes[0]);
    switch (MatchIndex) {

        //
        // Cdrom controller.
        //
        // Get the peripheral name and make sure it is valid.
        //

    case ControllerCdrom:
        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &PeripheralName[0],
                                       &PeripheralNumber);

        if (ArcDeviceName == NULL) {
            return EINVAL;
        }

        if (_stricmp(&PeripheralName[0], "fdisk") != 0) {
            return EINVAL;
        }

        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &TokenValue[0],
                                       &MatchIndex);

        if (ArcDeviceName != NULL) {
            return EINVAL;
        }

        sprintf(ArcCanonicalName,
                "%s%s(%d)%s(%d)",
                &AdapterPath[0],
                &ControllerName[0],
                ControllerNumber,
                &PeripheralName[0],
                PeripheralNumber);

        if (ARGUMENT_PRESENT(NtDevicePrefix)) {
            strcpy(NtDevicePrefix, "\\Device\\CDRom");
        }
        break;

        //
        // Disk controller.
        //
        // Get the peripheral and make sure it is valid.
        //

    case ControllerDisk:
        ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                       &PeripheralName[0],
                                       &PeripheralNumber);

        if (ArcDeviceName == NULL) {
            return EINVAL;
        }

        MatchIndex = BlMatchToken(&PeripheralName[0], &BlPeripheralTypes[0]);
        switch (MatchIndex) {

            //
            // Rigid Disk.
            //
            // If a partition is specified, then parse the partition number.
            //

        case PeripheralRigidDisk:
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &PartitionName[0],
                                           &PartitionNumber);

            if (ArcDeviceName == NULL) {
                strcpy(&PartitionName[0], "partition");
                PartitionNumber = 1;

            } else {
                if (_stricmp(&PartitionName[0], "partition") != 0) {
                    return EINVAL;
                }

                ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                               &TokenValue[0],
                                               &MatchIndex);

                if (ArcDeviceName != NULL) {
                    return EINVAL;
                }
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber,
                    &PartitionName[0],
                    PartitionNumber);

            if (ARGUMENT_PRESENT(NtDevicePrefix)) {
                strcpy(NtDevicePrefix, "\\Device\\Harddisk");
            }
            break;

            //
            // Floppy disk.
            //

        case PeripheralFloppyDisk:
#if defined(ARCI386)
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &PartitionName[0],
                                           &PartitionNumber);

            if (ArcDeviceName == NULL) {
                strcpy(&PartitionName[0], "partition");
                PartitionNumber = 1;

            } else {
                if (_stricmp(&PartitionName[0], "partition") != 0) {
                    return EINVAL;
                }

                ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                               &TokenValue[0],
                                               &MatchIndex);

                if (ArcDeviceName != NULL) {
                    return EINVAL;
                }
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber,
                    &PartitionName[0],
                    PartitionNumber);
#else
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &TokenValue[0],
                                           &MatchIndex);

            if (ArcDeviceName != NULL) {
                return EINVAL;
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber);

#endif  // defined(NEC_98)

            if (ARGUMENT_PRESENT(NtDevicePrefix)) {
                strcpy(NtDevicePrefix, "\\Device\\Floppy");
            }
            break;

#if defined(ELTORITO)
            //
            // El Torito CD-ROM.
            //

        case PeripheralElTorito:
            ArcDeviceName = BlGetNextToken(ArcDeviceName,
                                           &TokenValue[0],
                                           &MatchIndex);

            if (ArcDeviceName != NULL) {
                return EINVAL;
            }

            sprintf(ArcCanonicalName,
                    "%s%s(%d)%s(%d)",
                    &AdapterPath[0],
                    &ControllerName[0],
                    ControllerNumber,
                    &PeripheralName[0],
                    PeripheralNumber);

            if (ARGUMENT_PRESENT(NtDevicePrefix)) {
                strcpy(NtDevicePrefix, "\\Device\\CDRom");
            }
            break;
#endif

            //
            // Invalid peripheral.
            //

        default:
            return EINVAL;
        }

        break;

        //
        // Invalid controller.
        //

    default:
        return EINVAL;
    }

    return ESUCCESS;
}

PCHAR
BlGetNextToken (
    IN PCHAR TokenString,
    OUT PCHAR OutputToken,
    OUT PULONG UnitNumber
    )

/*++

Routine Description:

    This routine scans the specified token string for the next token and
    unit number. The token format is:

        name[(unit)]

Arguments:

    TokenString - Supplies a pointer to a zero terminated token string.

    OutputToken - Supplies a pointer to a variable that receives the next
        token.

    UnitNumber - Supplies a pointer to a variable that receives the unit
        number.

Return Value:

    If another token exists in the token string, then a pointer to the
    start of the next token is returned. Otherwise, a value of NULL is
    returned.

--*/

{

    //
    // If there are more characters in the token string, then parse the
    // next token. Otherwise, return a value of NULL.
    //

    if (*TokenString == '\0') {
        return NULL;

    } else {
        while ((*TokenString != '\0') && (*TokenString != '(')) {
            *OutputToken++ = *TokenString++;
        }

        *OutputToken = '\0';

        //
        // If a unit number is specified, then convert it to binary.
        // Otherwise, default the unit number to zero.
        //

        *UnitNumber = 0;
        if (*TokenString == '(') {
            TokenString += 1;
            while ((*TokenString != '\0') && (*TokenString != ')')) {
                *UnitNumber = (*UnitNumber * 10) + (*TokenString++ - '0');
            }

            if (*TokenString == ')') {
                TokenString += 1;
            }
        }
    }

    return TokenString;
}

ULONG
BlMatchToken (
    IN PCHAR TokenValue,
    IN CHAR * FIRMWARE_PTR TokenArray[]
    )

/*++

Routine Description:

    This routine attempts to match a token with an array of possible
    values.

Arguments:

    TokenValue - Supplies a pointer to a zero terminated token value.

    TokenArray - Supplies a pointer to a vector of pointers to null terminated
        match strings.

Return Value:

    If a token match is located, then the index of the matching value is
    returned as the function value. Otherwise, an index one greater than
    the size of the match array is returned.

--*/

{

    ULONG Index;
    PCHAR MatchString;
    PCHAR TokenString;

    //
    // Scan the match array until either a match is found or all of
    // the match strings have been scanned.
    //

    Index = 0;
    while (TokenArray[Index] != NULL) {
        MatchString = TokenArray[Index];
        TokenString = TokenValue;
        while ((*MatchString != '\0') && (*TokenString != '\0')) {
            if (toupper(*MatchString) != toupper(*TokenString)) {
                break;
            }

            MatchString += 1;
            TokenString += 1;
        }

        if ((*MatchString == '\0') && (*TokenString == '\0')) {
            break;
        }

        Index += 1;
    }

    return Index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blgpt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blgpt.c

Abstract:

    This module implements routines relating to GPT partitions.

Author:

    Andrew Ritz (andrewr) 20-March-2001

Revision History:

    Andrew Ritz (andrewr) 20-March-2001 - Created based on existing code.

--*/

#include "bldr.h"  // defines EFI_PARTITION_SUPPORT
#ifdef EFI_PARTITION_SUPPORT

#include "bootlib.h"

#ifndef MIN
#define MIN(a,b)  ((a < b) ? a : b)
#endif

#if 0 && DBG

ULONG
BlGetKey(
    VOID
    );

#define DBG_PRINT(x)  BlPrint(x);
//{\
//    BlPrint(x); \
//    while (!BlGetKey()); \
//}
#else
#define DBG_PRINT(x)
#endif

#ifdef UNICODE
#define STR_PREFIX  L
#else
#define STR_PREFIX
#endif

UCHAR GptScratchBuffer[1024*17];
//
// we read 16K chunks at a time.
//
#define GPT_READ_SIZE 1024*16
UCHAR GptScratchBuffer2[1024];



BOOLEAN
BlIsValidGUIDPartitionTableHelper(
    IN UNALIGNED EFI_PARTITION_TABLE  *PartitionTableHeader,
    IN ULONGLONG LBAOfPartitionTable,
    IN PVOID Context,
    IN PGPT_READ_CALLBACK DiskReadFunction
    )
/*++

Routine Description:

    This function checks the validity of a GUID Partition table.
    
    Per EFI Spec, the following tests must be performed to determine if a GUID
    Partition Table is valid:
    
    1) Check the GUID Partition Table Signature
    2) Check the GUID Partition Table CRC
    3) Check that the MyLBA entry points to the LBA that contains the GUID
       partition table
    4) Check the CRC of the GUID Partition Entry Array        
        
Arguments:

    PartitionTableHeader - pointer to header for partition table.
    
    LBAOfPartitionTable - logical block address that the header was read from.
    
    Context - pass through value to callback function used to read from disk
    
    DiskReadFunction - callback function used to read from the disk.
    
Return Value:

    TRUE indicates that the table is valid.

--*/

{
    CHAR *PartitionEntryArray = (PCHAR) GptScratchBuffer;
    ULONG Crc32, CalculatedCrc32;
    ULONG TotalSize,CurrentSize;
    ULONGLONG CurrentLBA;
    DBG_PRINT(STR_PREFIX"Verifying GPT PT\r\n");

    //
    // 1) Check the GUID Partition Table Signature
    //
    if (memcmp(PartitionTableHeader->Signature, EFI_SIGNATURE, sizeof(EFI_SIGNATURE))) {
        DBG_PRINT(STR_PREFIX"Signature does not match, invalid partition table\r\n");
        return(FALSE);           
    }

    //
    // 2) Check the GUID Partition Table CRC
    //
    // To do this we save off the old CRC value, calculate the CRC, and compare
    // the results (remembering that we need to put the CRC back when we're 
    // done with it).
    //
    Crc32 = PartitionTableHeader->HeaderCRC;
    PartitionTableHeader->HeaderCRC = 0;
    CalculatedCrc32 = RtlComputeCrc32( 0, PartitionTableHeader, PartitionTableHeader->HeaderSize );
    PartitionTableHeader->HeaderCRC = Crc32;
    if (CalculatedCrc32 != Crc32) {
        DBG_PRINT(STR_PREFIX"Partition table CRC does not calculate, invalid partition table\r\n");                  
        return(FALSE);
    }    

    //
    // 3) Check that the MyLBA entry points to the LBA that contains the GUID Partition Table
    //
    if (LBAOfPartitionTable != PartitionTableHeader->MyLBA) {
        DBG_PRINT(STR_PREFIX"LBA of Partition table does not match LBA in partition table header, invalid partition table\r\n");
        return(FALSE);
    }

    //
    // 4) Check the CRC of the GUID Partition Entry Array
    //
    //
    // first read the GUID Partition Entry Array
    //
    CurrentLBA = PartitionTableHeader->PartitionEntryLBA;
    TotalSize = PartitionTableHeader->PartitionEntrySize * PartitionTableHeader->PartitionCount;
    CurrentSize = 0;
    CalculatedCrc32 = 0;
    while (TotalSize != 0) {
        CurrentSize = MIN(TotalSize, GPT_READ_SIZE);
        if (DiskReadFunction( 
            (ULONGLONG)CurrentLBA,
            CurrentSize,
            Context,
            PartitionEntryArray )) {
            CalculatedCrc32 = RtlComputeCrc32( 
                                           CalculatedCrc32, 
                                           PartitionEntryArray,
                                           CurrentSize);
        } else {
            DBG_PRINT(STR_PREFIX"DiskReadFunction for PartitionTableHeader failed, invalid partition table\r\n");
            return(FALSE);
            break;
        }   

        TotalSize -= CurrentSize;
        CurrentLBA += CurrentSize*SECTOR_SIZE;

    }

    if (CalculatedCrc32 == ((UNALIGNED EFI_PARTITION_TABLE *)PartitionTableHeader)->PartitionEntryArrayCRC) {            
        return(TRUE);
    } else {
        DBG_PRINT(STR_PREFIX"CRC for PartitionEntryArray does not calculate, invalid partition table\r\n");
        return(FALSE);
    }
}

BOOLEAN
BlIsValidGUIDPartitionTable(
    IN UNALIGNED EFI_PARTITION_TABLE  *PartitionTableHeader,
    IN ULONGLONG LBAOfPartitionTable,
    IN PVOID Context,
    IN PGPT_READ_CALLBACK DiskReadFunction
    )
{
    UNALIGNED EFI_PARTITION_TABLE  *BackupPartitionTableHeader = (EFI_PARTITION_TABLE *)&GptScratchBuffer2;
    BOOLEAN RetVal = FALSE;
    if (BlIsValidGUIDPartitionTableHelper( 
                            PartitionTableHeader,
                            LBAOfPartitionTable,
                            Context,
                            DiskReadFunction)) {
        //
        // If the primary table @ LBA 1, check the AlternateLBA to see if it
        // is valid.
        //
        if (LBAOfPartitionTable == 1) {
            //
            // Read the backup partition table into memory and validate it as 
            // well.
            //
            if (DiskReadFunction( 
                            PartitionTableHeader->AlternateLBA,
                            PartitionTableHeader->HeaderSize,
                            Context,
                            BackupPartitionTableHeader)) {
                if (BlIsValidGUIDPartitionTableHelper( 
                                            (UNALIGNED EFI_PARTITION_TABLE *)BackupPartitionTableHeader,
                                            PartitionTableHeader->AlternateLBA,
                                            Context,
                                            DiskReadFunction)) {
                    RetVal = TRUE;
                    DBG_PRINT(STR_PREFIX"BlIsValidGUIDPartitionTable succeeded\r\n");
                }
            } else {
                DBG_PRINT(STR_PREFIX"DiskReadFunction for BackupPartitionTableHeader failed, invalid partition table\r\n");
            }
        } else {
            DBG_PRINT(STR_PREFIX"WARNING: LBA of PartitionTableHeader is not 1.\r\n");
            RetVal = TRUE;
        }
    }
    return(RetVal);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blload.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blload.c

Abstract:

    This module provides common code for loading things like drivers, NLS files, registry.
    Used by both the osloader and the setupldr.

Author:

    John Vert (jvert) 8-Oct-1993

Environment:

    ARC environment

Revision History:

--*/

#include "bldr.h"
#include "stdio.h"
#include "stdlib.h"
#include "vmode.h"

#ifdef EFI
#include "bootefi.h"
#endif

//
// progress bar message ids
//
// HIBER_UI_BAR_ELEMENT    0x00002CF9L
// BLDR_UI_BAR_BACKGROUND  0x00002CFAL
//
ULONG BlProgBarFrontMsgID = 0x00002CF9L;
ULONG BlProgBarBackMsgID = 0x00002CFAL;

//
// Size of the font file buffer
//

ULONG BlOemFontFileSize;

//
// number of files loaded (for progress bar)
//
int BlNumFilesLoaded = 0;
int BlNumProgressBarFilesLoaded = 0;

//
// maximum number of files to load (for progress bar)
//
int BlMaxFilesToLoad = 80;
int BlProgressBarFilesToLoad = 0;

#if defined(_X86_)
ULONG BlProgressBarShowTimeOut = 3;
#else
ULONG BlProgressBarShowTimeOut = 0;
#endif

BOOLEAN BlDisableProgressBar = FALSE;

//
// The progress bar width (in characters)
//
#define PROGRESS_BAR_WIDTH  80

//
// The progress bar characters
//
#define DEFAULT_FRONT_CHAR  0xDB    // block cursor
#define DEFAULT_BACK_CHAR   ' '

USHORT BlFrontChar = DEFAULT_FRONT_CHAR;
USHORT BlBackChar = DEFAULT_BACK_CHAR;

//
// defines whether to draw the progress bar or not
//
#if DBG

BOOLEAN BlOutputDots=FALSE;
//BOOLEAN BlOutputDots=TRUE;

#else

BOOLEAN BlOutputDots=TRUE;

#endif

//
// To show the progress bar or not
//
BOOLEAN BlShowProgressBar = FALSE;
ULONG   BlStartTime = 0L;

ARC_STATUS
BlLoadSystemHiveLog(
    IN  ULONG       DeviceId,
    IN  PCHAR       DeviceName,
    IN  PCHAR       DirectoryPath,
    IN  PCHAR       HiveName,
    OUT PULONG_PTR  LogData
    )

/*++

Routine Description:

    Loads the registry log file for the system hive from <BootDirectory>\config\system.LOG.

    Allocates a memory descriptor to hold the hive image, reads the hive
    image into this descriptor,

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT tree.

    HiveName - Supplies the name of the system hive ("SYSTEM.LOG")

    LogData - flat image of the log file

    LogLength - length of the data in LogData

Return Value:

    TRUE - system hive successfully loaded.

    FALSE - system hive could not be loaded.

--*/

{
    CHAR RegistryName[256];
    ULONG FileId;
    ARC_STATUS Status;
    FILE_INFORMATION FileInformation;
    ULONG FileSize;
    ULONG ActualBase;
    ULONG_PTR LocalPointer;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    PCHAR FailReason;

    //
    // Create the full filename for the SYSTEM hive.
    //

    strcpy(&RegistryName[0], DirectoryPath);
    strcat(&RegistryName[0], HiveName);
    BlOutputLoadMessage(DeviceName, &RegistryName[0], NULL);

    Status = BlOpen(DeviceId, &RegistryName[0], ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlOpen";
        goto HiveLoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Determine the length of the registry file
    //
    Status = BlGetFileInformation(FileId, &FileInformation);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlGetFileInformation";
        goto HiveLoadFailed;
    }

    FileSize = FileInformation.EndingAddress.LowPart;
    if (FileSize == 0) {
        Status = EINVAL;
        BlClose(FileId);
        FailReason = "FileSize == 0";
        goto HiveLoadFailed;
    }

    //
    // Round up to a page boundary, allocate a memory descriptor, fill in the
    // registry fields in the loader parameter block, and read the registry
    // data into memory.
    //

    Status = BlAllocateDescriptor(LoaderRegistryData,
                                  0x0,
                                  (FileSize + PAGE_SIZE - 1) >> PAGE_SHIFT,
                                  &ActualBase);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlAllocateDescriptor";
        goto HiveLoadFailed;
    }

    *LogData = LocalPointer = KSEG0_BASE | (ActualBase << PAGE_SHIFT);

    //
    // Read the SYSTEM hive into the allocated memory.
    //

    SeekValue.QuadPart = 0;
    Status = BlSeek(FileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlSeek";
        BlFreeDescriptor(ActualBase);
        goto HiveLoadFailed;
    }

    Status = BlRead(FileId, (PVOID)LocalPointer, FileSize, &Count);
    BlClose(FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlRead";
        BlFreeDescriptor(ActualBase);
        goto HiveLoadFailed;
    }

HiveLoadFailed:
    return Status;
}

ARC_STATUS
BlLoadSystemHive(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PCHAR HiveName
    )

/*++

Routine Description:

    Loads the registry SYSTEM hive from <BootDirectory>\config\system.

    Allocates a memory descriptor to hold the hive image, reads the hive
    image into this descriptor, and updates the registry pointers in the
    LoaderBlock.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated directory path
        of the root of the NT tree.

    HiveName - Supplies the name of the system hive ("SYSTEM" or "SYSTEM.ALT")

Return Value:

    TRUE - system hive successfully loaded.

    FALSE - system hive could not be loaded.

--*/

{
    CHAR RegistryName[256];
    ULONG FileId;
    ARC_STATUS Status;
    FILE_INFORMATION FileInformation;
    ULONG FileSize;
    ULONG ActualBase;
    ULONG_PTR LocalPointer;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    PCHAR FailReason;

    //
    // Create the full filename for the SYSTEM hive.
    //

    strcpy(&RegistryName[0], DirectoryPath);
    strcat(&RegistryName[0], HiveName);
    BlOutputLoadMessage(DeviceName, &RegistryName[0], NULL);

    Status = BlOpen(DeviceId, &RegistryName[0], ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlOpen";
        goto HiveLoadFailed;
    }

    BlUpdateBootStatus();

    //
    // Determine the length of the registry file
    //
    Status = BlGetFileInformation(FileId, &FileInformation);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlGetFileInformation";
        goto HiveLoadFailed;
    }

    FileSize = FileInformation.EndingAddress.LowPart;
    if (FileSize == 0) {
        Status = EINVAL;
        BlClose(FileId);
        FailReason = "FileSize == 0";
        goto HiveLoadFailed;
    }

    //
    // Round up to a page boundary, allocate a memory descriptor, fill in the
    // registry fields in the loader parameter block, and read the registry
    // data into memory.
    //

    Status = BlAllocateDescriptor(LoaderRegistryData,
                                  0x0,
                                  (FileSize + PAGE_SIZE - 1) >> PAGE_SHIFT,
                                  &ActualBase);

    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlAllocateDescriptor";
        goto HiveLoadFailed;
    }

    LocalPointer = KSEG0_BASE | (ActualBase << PAGE_SHIFT);
    BlLoaderBlock->RegistryLength = FileSize;
    BlLoaderBlock->RegistryBase = (PVOID)(LocalPointer + BlVirtualBias);

    //
    // Read the SYSTEM hive into the allocated memory.
    //

    SeekValue.QuadPart = 0;
    Status = BlSeek(FileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        BlClose(FileId);
        FailReason = "BlSeek";
        goto HiveLoadFailed;
    }

    Status = BlRead(FileId, (PVOID)LocalPointer, FileSize, &Count);
    BlClose(FileId);
    if (Status != ESUCCESS) {
        FailReason = "BlRead";
        goto HiveLoadFailed;
    }

HiveLoadFailed:
    return Status;
}

ARC_STATUS
BlLoadNLSData(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING AnsiCodepage,
    IN PUNICODE_STRING OemCodepage,
    IN PUNICODE_STRING LanguageTable,
    OUT PCHAR BadFileName
    )

/*++

Routine Description:

    This routine loads all the NLS data files into one contiguous block of
    memory.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the zero-terminated path
        of the directory containing the NLS files.

    AnsiCodePage - Supplies the filename of the ANSI codepage data file.

    OemCodePage - Supplies the filename of the OEM codepage data file.

    LanguageTable - Supplies the filename of the Unicode language case table.

    BadFileName - Returns the filename of the NLS file that was missing
        or invalid.  This will not be filled in if ESUCCESS is returned.

Return Value:

    ESUCCESS is returned if the NLS data was successfully loaded.
        Otherwise, an unsuccessful status is returned.

--*/

{
    CHAR Filename[129];
    ULONG AnsiFileId;
    ULONG OemFileId;
    ULONG LanguageFileId;
    ARC_STATUS Status;
    FILE_INFORMATION FileInformation;
    ULONG AnsiFileSize;
    ULONG OemFileSize;
    ULONG LanguageFileSize;
    ULONG TotalSize;
    ULONG ActualBase;
    ULONG_PTR LocalPointer;
    LARGE_INTEGER SeekValue;
    ULONG Count;
    BOOLEAN OemIsSameAsAnsi = FALSE;

    //
    // Under the Japanese version of NT, ANSI code page and OEM codepage
    // is same. In this case, we share the same data to save and memory.
    //

    if ( (AnsiCodepage->Length == OemCodepage->Length) &&
         (_wcsnicmp(AnsiCodepage->Buffer,
                   OemCodepage->Buffer,
                   AnsiCodepage->Length) == 0)) {

        OemIsSameAsAnsi = TRUE;
    }

    //
    // Open the ANSI data file
    //

    sprintf(Filename, "%s%wZ", DirectoryPath,AnsiCodepage);
    BlOutputLoadMessage(DeviceName, Filename, NULL);

    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &AnsiFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlUpdateBootStatus();

    Status = BlGetFileInformation(AnsiFileId, &FileInformation);
    BlClose(AnsiFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    AnsiFileSize = FileInformation.EndingAddress.LowPart;

    //
    // Open the OEM data file
    //

    if (OemIsSameAsAnsi) {
        OemFileSize = 0;

    } else {
        sprintf(Filename, "%s%wZ", DirectoryPath, OemCodepage);
        BlOutputLoadMessage(DeviceName, Filename, NULL);
        Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &OemFileId);

        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        BlUpdateBootStatus();

        Status = BlGetFileInformation(OemFileId, &FileInformation);
        BlClose(OemFileId);
        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        OemFileSize = FileInformation.EndingAddress.LowPart;
    }

    //
    // Open the language codepage file
    //

    sprintf(Filename, "%s%wZ", DirectoryPath,LanguageTable);
    BlOutputLoadMessage(DeviceName, Filename, NULL);
    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &LanguageFileId);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlUpdateBootStatus();

    Status = BlGetFileInformation(LanguageFileId, &FileInformation);
    BlClose(LanguageFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    LanguageFileSize = FileInformation.EndingAddress.LowPart;

    //
    // Calculate the total size of the descriptor needed.  We want each
    // data file to start on a page boundary, so round up each size to
    // page granularity.
    //

    TotalSize = (ULONG)(ROUND_TO_PAGES(AnsiFileSize) +
                (OemIsSameAsAnsi ? 0 : ROUND_TO_PAGES(OemFileSize)) +
                ROUND_TO_PAGES(LanguageFileSize));

    Status = BlAllocateDescriptor(LoaderNlsData,
                                  0x0,
                                  TotalSize >> PAGE_SHIFT,
                                  &ActualBase);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    LocalPointer = KSEG0_BASE | (ActualBase << PAGE_SHIFT);

    //
    // Read NLS data into memory.
    //
    // Open and read the ANSI file.
    //

    sprintf(Filename, "%s%wZ", DirectoryPath, AnsiCodepage);
    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &AnsiFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    SeekValue.QuadPart = 0;
    Status = BlSeek(AnsiFileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    Status = BlRead(AnsiFileId,
                    (PVOID)LocalPointer,
                    AnsiFileSize,
                    &Count);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlLoaderBlock->NlsData->AnsiCodePageData = (PVOID)(LocalPointer + BlVirtualBias);
    LocalPointer += ROUND_TO_PAGES(AnsiFileSize);
    BlClose(AnsiFileId);

    //
    // If the OEM file is the same as the ANSI file, then define the OEM file as
    // the ANSI file. Otherwise, open and read the OEM file.
    //

    if(OemIsSameAsAnsi) {
        BlLoaderBlock->NlsData->OemCodePageData = BlLoaderBlock->NlsData->AnsiCodePageData;

    } else {
        sprintf(Filename, "%s%wZ", DirectoryPath, OemCodepage);
        Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &OemFileId);
        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        SeekValue.QuadPart = 0;
        Status = BlSeek(OemFileId, &SeekValue, SeekAbsolute);
        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        Status = BlRead(OemFileId,
                        (PVOID)LocalPointer,
                        OemFileSize,
                        &Count);

        if (Status != ESUCCESS) {
            goto NlsLoadFailed;
        }

        BlLoaderBlock->NlsData->OemCodePageData = (PVOID)(LocalPointer + BlVirtualBias);
        LocalPointer += ROUND_TO_PAGES(OemFileSize);
        BlClose(OemFileId);
    }

    //
    // Open and read Language file.
    //

    sprintf(Filename, "%s%wZ", DirectoryPath,LanguageTable);
    Status = BlOpen(DeviceId, Filename, ArcOpenReadOnly, &LanguageFileId);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    SeekValue.QuadPart = 0;
    Status = BlSeek(LanguageFileId, &SeekValue, SeekAbsolute);
    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    Status = BlRead(LanguageFileId,
                    (PVOID)LocalPointer,
                    LanguageFileSize,
                    &Count);

    if (Status != ESUCCESS) {
        goto NlsLoadFailed;
    }

    BlLoaderBlock->NlsData->UnicodeCaseTableData = (PVOID)(LocalPointer + BlVirtualBias);
    BlClose(LanguageFileId);
    return(ESUCCESS);

NlsLoadFailed:
    strcpy(BadFileName, Filename);
    return(Status);
}

ARC_STATUS
BlLoadOemHalFont(
    IN ULONG DeviceId,
    IN PCHAR DeviceName,
    IN PCHAR DirectoryPath,
    IN PUNICODE_STRING OemHalFont,
    OUT PCHAR BadFileName
    )

/*++

Routine Description:

    This routine loads the OEM font file for use the HAL display string
    function.

Arguments:

    DeviceId - Supplies the file id of the device the system tree is on.

    DeviceName - Supplies the name of the device the system tree is on.

    DirectoryPath - Supplies a pointer to the directory path of the root
        of the NT tree.

    Fontfile - Supplies the filename of the OEM font file.

    BadFileName - Returns the filename of the OEM font file that was missing
        or invalid.

Return Value:

    ESUCCESS is returned if the OEM font was successfully loaded. Otherwise,
    an unsuccessful status is returned and the bad file name is filled.

--*/

{

    PVOID FileBuffer = NULL;
    ULONG Count;
    PIMAGE_DOS_HEADER DosHeader;
    ULONG FileId;
    FILE_INFORMATION FileInformation;
    CHAR Filename[129];
    ULONG FileSize = 0;
    ARC_STATUS Status;
    POEM_FONT_FILE_HEADER FontHeader;
    PIMAGE_OS2_HEADER Os2Header;
    ULONG ScaleFactor;
    RESOURCE_TYPE_INFORMATION UNALIGNED *TableAddress;
    RESOURCE_TYPE_INFORMATION UNALIGNED *TableEnd;
    RESOURCE_NAME_INFORMATION UNALIGNED *TableName;

    //
    // Open the OEM font file.
    //

    BlLoaderBlock->OemFontFile = NULL;
    sprintf(&Filename[0], "%s%wZ", DirectoryPath, OemHalFont);
    BlOutputLoadMessage(DeviceName, &Filename[0], NULL);
    Status = BlOpen(DeviceId, &Filename[0], ArcOpenReadOnly, &FileId);
    if (Status != ESUCCESS) {
        goto OemLoadExit1;
    }

    BlUpdateBootStatus();

    //
    // Get the size of the font file and allocate a buffer from the heap
    // to hold the font file. Typically this file is about 4kb in length.
    //

    Status = BlGetFileInformation(FileId, &FileInformation);
    if (Status != ESUCCESS) {
        goto OemLoadExit;
    }

    FileSize = FileInformation.EndingAddress.LowPart;
    FileBuffer = BlAllocateHeap(FileSize + BlDcacheFillSize - 1);
    if (FileBuffer == NULL) {
        Status = ENOMEM;
        goto OemLoadExit;
    }

    //
    // Round the file buffer address up to a cache line boundary and read
    // the file into memory.
    //

    FileBuffer = (PVOID)((ULONG_PTR)FileBuffer + BlDcacheFillSize - 1);
    FileBuffer = (PVOID)((ULONG_PTR)FileBuffer & ~((ULONG_PTR)BlDcacheFillSize - 1));
    Status = BlRead(FileId,
                    FileBuffer,
                    FileSize,
                    &Count);

    if (Status != ESUCCESS) {
        goto OemLoadExit;
    }

    //
    // Attempt to recognize the file as either a .fon or .fnt file.
    //
    // Check if the file has a DOS header or a font file header. If the
    // file has a font file header, then it is a .fnt file. Otherwise,
    // it must be checked for an OS/2 executable with a font resource.
    //

    Status = EBADF;
    DosHeader = (PIMAGE_DOS_HEADER)FileBuffer;
    if (DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {

        //
        // Check if the file has a font file header.
        //

        FontHeader = (POEM_FONT_FILE_HEADER)FileBuffer;
        if ((FontHeader->Version != OEM_FONT_VERSION) ||
            (FontHeader->Type != OEM_FONT_TYPE) ||
            (FontHeader->Italic != OEM_FONT_ITALIC) ||
            (FontHeader->Underline != OEM_FONT_UNDERLINE) ||
            (FontHeader->StrikeOut != OEM_FONT_STRIKEOUT) ||
            (FontHeader->CharacterSet != OEM_FONT_CHARACTER_SET) ||
            (FontHeader->Family != OEM_FONT_FAMILY) ||
            (FontHeader->PixelWidth > 32)) {

            goto OemLoadExit;

        } else {
            BlLoaderBlock->OemFontFile = (PVOID)FontHeader;
            Status = ESUCCESS;
            goto OemLoadExit;
        }
    }

    //
    // Check if the file has an OS/2 header.
    //

    if ((FileSize < sizeof(IMAGE_DOS_HEADER)) || (FileSize < (ULONG)DosHeader->e_lfanew)) {
        goto OemLoadExit;
    }

    Os2Header = (PIMAGE_OS2_HEADER)((PUCHAR)DosHeader + DosHeader->e_lfanew);
    if (Os2Header->ne_magic != IMAGE_OS2_SIGNATURE) {
        goto OemLoadExit;
    }

    //
    // Check if the resource table exists.
    //

    if ((Os2Header->ne_restab - Os2Header->ne_rsrctab) == 0) {
        goto OemLoadExit;
    }

    //
    // Compute address of resource table and search the table for a font
    // resource.
    //

    TableAddress =
        (PRESOURCE_TYPE_INFORMATION)((PUCHAR)Os2Header + Os2Header->ne_rsrctab);

    TableEnd =
        (PRESOURCE_TYPE_INFORMATION)((PUCHAR)Os2Header + Os2Header->ne_restab);

    ScaleFactor = *((SHORT UNALIGNED *)TableAddress);
    TableAddress = (PRESOURCE_TYPE_INFORMATION)((SHORT UNALIGNED *)TableAddress + 1);
    while ((TableAddress < TableEnd) &&
           (TableAddress->Ident != 0) &&
           (TableAddress->Ident != FONT_RESOURCE)) {

        TableAddress =
                (PRESOURCE_TYPE_INFORMATION)((PUCHAR)(TableAddress + 1) +
                    (TableAddress->Number * sizeof(RESOURCE_NAME_INFORMATION)));
    }

    if ((TableAddress >= TableEnd) || (TableAddress->Ident != FONT_RESOURCE)) {
        goto OemLoadExit;
    }

    //
    // Compute address of resource name information and check if the resource
    // is within the file.
    //

    TableName = (PRESOURCE_NAME_INFORMATION)(TableAddress + 1);
    if (FileSize < ((TableName->Offset << ScaleFactor) + sizeof(OEM_FONT_FILE_HEADER))) {
        goto OemLoadExit;
    }

    //
    // Compute the address of the font file header and check if the header
    // contains correct information.
    //

    FontHeader = (POEM_FONT_FILE_HEADER)((PCHAR)FileBuffer +
                                            (TableName->Offset << ScaleFactor));

    if ((FontHeader->Version != OEM_FONT_VERSION) ||
        (FontHeader->Type != OEM_FONT_TYPE) ||
        (FontHeader->Italic != OEM_FONT_ITALIC) ||
        (FontHeader->Underline != OEM_FONT_UNDERLINE) ||
        (FontHeader->StrikeOut != OEM_FONT_STRIKEOUT) ||
        (FontHeader->CharacterSet != OEM_FONT_CHARACTER_SET) ||
        (FontHeader->PixelWidth > 32)) {
        goto OemLoadExit;

    } else {
        BlLoaderBlock->OemFontFile = (PVOID)FontHeader;
        Status = ESUCCESS;
        goto OemLoadExit;
    }

    //
    // Exit loading of the OEM font file.
    //

OemLoadExit:
    BlClose(FileId);
OemLoadExit1:
    strcpy(BadFileName,&Filename[0]);
    if ((Status == ESUCCESS) && (FileBuffer != NULL)) {
        ULONG_PTR bufferEnd;

        bufferEnd = (ULONG_PTR)FileBuffer + FileSize;
        BlOemFontFileSize =
            (ULONG)(bufferEnd - (ULONG_PTR)BlLoaderBlock->OemFontFile);
    }
    return(Status);
}


ARC_STATUS
BlLoadDeviceDriver(
    IN PPATH_SET               PathSet,
    IN PCHAR                   DriverName,
    IN PTCHAR                  DriverDescription OPTIONAL,
    IN ULONG                   DriverFlags,
    OUT PKLDR_DATA_TABLE_ENTRY *DriverDataTableEntry
    )

/*++

Routine Description:

    This routine loads the specified device driver and resolves all DLL
    references if the driver is not already loaded.

Arguments:

    PathSet - Describes all the various locations the driver could be present
        at.

    DriverName - Supplies a pointer to a zero terminated device driver
        name string.

    DriverDescription - Supplies an optional pointer to a zero terminated string
        to be displayed when loading the driver. If NULL, DriverName is used.

    DriverFlags - Supplies the driver flags that are to be set in the
        generated data table entry.

    DriverDataTableEntry - Receives a pointer to the data table entry
        created for the newly-loaded driver.

Return Value:

    ESUCCESS is returned if the specified driver is successfully loaded
    or it is already loaded. Otherwise, and unsuccessful status is
    returned.

--*/

{

    CHAR DllName[256];
    CHAR FullName[256];
    PVOID Base = NULL;
    ARC_STATUS Status;
    ULONG Index;
    PPATH_SOURCE PathSource;

    //
    // Generate the DLL name for the device driver.
    //

    strcpy(&DllName[0], DriverName);

    //
    // If the specified device driver is not already loaded, then load it.
    //

    if (BlCheckForLoadedDll(&DllName[0], DriverDataTableEntry) == FALSE) {

        //
        // Start walking our list of DevicePaths. If the list is
        // empty (bad caller!) we fail with ENOENT.
        //
        Status = ENOENT;
        for(Index=0; Index < PathSet->PathCount; Index++) {

            PathSource = &PathSet->Source[Index];

            //
            // Generate the full path name of device driver.
            //
            strcpy(&FullName[0], PathSource->DirectoryPath);
            strcat(&FullName[0], PathSet->PathOffset);
            strcat(&FullName[0], DriverName);

            //
            // Try to load it.
            //
            Status = BlLoadImage(PathSource->DeviceId,
                                 LoaderBootDriver,
                                 &FullName[0],
                                 TARGET_IMAGE,
                                 &Base);

            if (Status == ESUCCESS) {

                //
                // Print out the driver that loaded.
                //
                BlOutputLoadMessage((PCHAR) PathSource->DeviceName,
                                    &FullName[0],
                                    DriverDescription);

                break;
            }
        }

        if (Status != ESUCCESS) {
            return Status;
        }

        BlUpdateBootStatus();

        //
        // Generate a data table entry for the driver, then clear the entry
        // processed flag. The I/O initialization code calls each DLL in the
        // loaded module list that does not have its entry processed flag set.
        //
        // ISSUE - 2000/29/03 - ADRIAO: Existant namespace polution
        //     Instead of passing in DllName here, we should be passing in
        // AliasName\PathOffset\DriverName.
        //

        Status = BlAllocateDataTableEntry(&DllName[0],
                                          DriverName,
                                          Base,
                                          DriverDataTableEntry);

        if (Status != ESUCCESS) {
            return Status;
        }

        //
        // Set the flag LDRP_DRIVER_DEPENDENT_DLL so that BlScanImportDescriptorTable
        // will set the flag in the data table entries for the dlls that it creates.
        //
        (*DriverDataTableEntry)->Flags |= DriverFlags|LDRP_DRIVER_DEPENDENT_DLL;

        //
        // Scan the import table and load all the referenced DLLs.
        //
        Status = BlScanImportDescriptorTable(PathSet,
                                             *DriverDataTableEntry,
                                             LoaderBootDriver);

        if (Status != ESUCCESS) {
            //
            // Remove the driver from the load order list.
            //
            RemoveEntryList(&(*DriverDataTableEntry)->InLoadOrderLinks);
            return Status;
        }
        //
        // Clear the flag here. This way we don't call DllInitialize for drivers.
        //
        (*DriverDataTableEntry)->Flags &= ~LDRP_DRIVER_DEPENDENT_DLL;

    }
    return ESUCCESS;
}

VOID
BlUpdateBootStatus(
    VOID
    )
/*++

Routine Description:

    Updates the boot status (like updating progress bar currently).
    Generally gets called after important files are loaded.

Arguments:

    None


Return Value:

    None

--*/

{
    BlNumFilesLoaded++;
    if (BlShowProgressBar)
        BlNumProgressBarFilesLoaded++;
    BlRedrawProgressBar();
}

VOID
BlRedrawProgressBar(
    VOID
    )
/*++

Routine Description:

    Redraws the progress bar (with the last percentage)

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // return if progress bar is disabled
    //
    if (BlDisableProgressBar) {
        return;
    }

    if (!BlShowProgressBar) {
        ULONG EndTime = ArcGetRelativeTime();
        if ((BlProgressBarShowTimeOut == 0) ||
            ((EndTime - BlStartTime) > BlProgressBarShowTimeOut)) {
            BlShowProgressBar = TRUE;
            BlNumProgressBarFilesLoaded = 1;
            BlProgressBarFilesToLoad = BlMaxFilesToLoad - BlNumFilesLoaded;
        }
    }

    if (BlShowProgressBar && (BlProgressBarFilesToLoad>0)) {
            BlUpdateProgressBar((BlNumProgressBarFilesLoaded * 100) / BlProgressBarFilesToLoad);
    }
}

VOID
BlUpdateTxtProgressBar(
    ULONG fPercentage
    )
/*++

Routine Description:

    Draws the progress bar with the specified percentage value

Arguments:

    fPercentage : percentage the progress bar needs to show
    (Note : should have a value between  0 & 100 inclusive)

Return Value:

    None

--*/

{
    ULONG           lCount = 0;
    TCHAR           szMsg[PROGRESS_BAR_WIDTH * 2 + 2] = {0};
    int             iNumChars = 0;
    int             iNumBackChars = 0;
    TCHAR         szBarBackStr[PROGRESS_BAR_WIDTH * 2 + 2] = {0};
    TCHAR         szPrgBar[PROGRESS_BAR_WIDTH * 4 + 2] = {0};
    static ULONG    uRow = 0;
    static ULONG    uCol = 0;
    static ULONG    uBarWidth = PROGRESS_BAR_WIDTH;

    if (BlShowProgressBar && BlOutputDots) {
        // fix percentage value (if needed)
        if (fPercentage > 100)
            fPercentage = 100;

        // select the row where to display the progress bar
        if (uRow == 0)
            uRow = ScreenHeight - 2;

        // fix the start column
        if (uCol == 0) {
            if (PROGRESS_BAR_WIDTH >= ScreenWidth) {
                uCol = 1;
                uBarWidth = ScreenWidth;
            } else {
                uCol = (ScreenWidth - PROGRESS_BAR_WIDTH) / 2;
                uBarWidth = PROGRESS_BAR_WIDTH;
            }
        }

        iNumChars = (fPercentage * uBarWidth) / 100;
        iNumBackChars = uBarWidth - iNumChars;

        if (iNumChars) {
#ifdef EFI
            PTCHAR pMsg = szMsg;
            ULONG uNumChars = iNumChars;
            while (uNumChars--) {
                *pMsg++ = BlFrontChar;
            }
#else
            //
            // copy appropriately based on single / double byte character
            // each dbcs character takes two single char space on screen
            //
            if (BlFrontChar & 0xFF00) {
                USHORT  *pMsg = (USHORT *)szMsg;
                ULONG   uNumChars = (iNumChars + 1) / 2;

                while(uNumChars--)
                    *pMsg++ = BlFrontChar;
            } else {
                memset( szMsg, BlFrontChar, min(iNumChars, sizeof(szMsg) - 1));
            }
#endif
        }

        if (iNumBackChars && BlBackChar) {
#ifdef EFI
            PTCHAR pMsg = szBarBackStr;
            ULONG uNumChars = iNumBackChars;
            while (uNumChars--) {
                *pMsg++ = BlBackChar;
            }
#else
            //
            // copy appropriately based on single / double byte character
            // each dbcs character takes two single char space on screen
            //
            if (BlBackChar & 0xFF00) {
                USHORT  *pMsg = (USHORT *)szBarBackStr;
                ULONG   uNumChars = iNumBackChars / 2;

                while(uNumChars--)
                    *pMsg++ = BlBackChar;
            } else {
                memset(szBarBackStr, BlBackChar,
                    min(sizeof(szBarBackStr) - 1, iNumBackChars));
            }
#endif
        }

        _tcscat(szPrgBar, szMsg);
        _tcscat(szPrgBar, szBarBackStr);

#if 0 
        {
            TCHAR   szDbg[512] = { 0 };

            _stprintf(szDbg, TEXT("(%x, %x)=[%d,%d],%x\n%s\n%s\n%s"),
                BlFrontChar, BlBackChar, iNumChars, iNumBackChars, fPercentage,
                szMsg, szBarBackStr, szPrgBar);

            BlPositionCursor(1,1);
            ArcWrite(BlConsoleOutDeviceId,
                    szDbg,
                    (ULONG)_tcslen(szDbg)*sizeof(TCHAR),
                    &lCount);
        }
#endif

        // print out the progress bar
        BlPositionCursor(uCol, uRow);
        ArcWrite(BlConsoleOutDeviceId,
                szPrgBar,
                (ULONG)_tcslen(szPrgBar)*sizeof(TCHAR),
                &lCount);
    }
}


VOID
BlUpdateProgressBar(
    ULONG fPercentage
    )
{
    if (DisplayLogoOnBoot) {
        BlUpdateGfxProgressBar(fPercentage);
    } else {
        BlUpdateTxtProgressBar(fPercentage);
    }        
}

VOID
BlOutputStartupMsgStr(
    PCTSTR MsgStr
    )
/*++

Routine Description:

    Clears the screen and displays the startup message at the specified
    coordinates of screen

Arguments:

    MsgStr - the message that needs to be displayed

Return Value:

    None

--*/
{
    ULONG lCount = 0;
    ULONG uX = 0, uY = 0;
    
    if (!DisplayLogoOnBoot && BlOutputDots && MsgStr) {
        BlClearScreen();
        BlSetInverseMode(FALSE);

        // center the message
        uX = ScreenHeight - 3;
        uY = (ScreenWidth / 2) - (((ULONG)_tcslen(MsgStr)) / 2);

        if (uY > ScreenWidth)
            uY = 1;
            
        // print out the message
        BlPositionCursor(uY, uX);

        ArcWrite(BlConsoleOutDeviceId,
                 (PVOID)MsgStr,
                 (ULONG)_tcslen(MsgStr) * sizeof(TCHAR),
                 &lCount);

        BlRedrawProgressBar();
    }
}

VOID
BlOutputStartupMsg(
    ULONG   uMsgID
    )
/*++

Routine Description:

    Clears the screen and displays the startup message at the specified
    coordinates of screen

Arguments:

    uMsgID - inidicates the message ID that needs to be displayed

Return Value:

    None

--*/
{

    if (!DisplayLogoOnBoot && BlOutputDots) {
        //
        // Proceed only if no logo is displayed.
        //
        BlOutputStartupMsgStr(BlFindMessage(uMsgID));
    }
}

VOID
BlOutputTrailerMsgStr(
    PCTSTR MsgStr
    )
/*++

Routine Description:

    Displays a trailer message at the bottom of the screen

Arguments:

    uMsgID - inidicates the message ID that needs to be displayed


Return Value:

    None

--*/
{
    ULONG   lCount = 0;
    TCHAR   szText[256] = {0};
    ULONG   BufferLength = sizeof(szText)/sizeof(szText[0]);

    if (!DisplayLogoOnBoot && BlOutputDots && MsgStr) {

        ASSERT( _tcslen(MsgStr) < BufferLength );

        BlPositionCursor(1, ScreenHeight);
        
        _tcsncpy(szText, MsgStr, BufferLength);
        szText[BufferLength - 1] = TEXT('\0');

        lCount = (ULONG)_tcslen(szText);

        if ((lCount > 2) && szText[lCount-2] == TEXT('\r') && szText[lCount-1] == TEXT('\n')) {
            szText[lCount-2] = TEXT('\0');
            lCount -= 2;
        }

        ArcWrite(BlConsoleOutDeviceId,
                 szText,
                 lCount*sizeof(TCHAR),
                 &lCount);
    }

}


VOID
BlOutputTrailerMsg(
    ULONG   uMsgID
    )
/*++

Routine Description:

    Displays a trailer message at the bottom of the screen

Arguments:

    uMsgID - inidicates the message ID that needs to be displayed


Return Value:

    None

--*/
{
    BlOutputTrailerMsgStr(BlFindMessage(uMsgID));
}


VOID
BlSetProgBarCharacteristics(
    IN  ULONG   FrontCharMsgID,
    IN  ULONG   BackCharMsgID
    )
/*++

Routine Description:

    Sets the characteristics for progress bar

Arguments:

    IN  ULONG   FrontCharMsgID : Progress bar foreground character
    IN  ULONG   BackCharMsgID : Progress bar background character

Return Value:

    None

--*/
{
#ifdef EFI
    UNREFERENCED_PARAMETER( FrontCharMsgID );
    UNREFERENCED_PARAMETER( BackCharMsgID );

    BlFrontChar = GetGraphicsChar( GraphicsCharFullBlock );
    BlBackChar  = GetGraphicsChar( GraphicsCharLightShade );
#else
    
    PTCHAR  szBar = 0;

    BlProgBarFrontMsgID = FrontCharMsgID;
    BlProgBarBackMsgID = BackCharMsgID;

    // fetch the bar character from resource file
    szBar = BlFindMessage(BlProgBarFrontMsgID);

    if (szBar) {
        ULONG   len = _tcslen(szBar);

        if ((len == 1) ||
                ((len > 2) && (szBar[1] == TEXT('\r')) && (szBar[2] == TEXT('\n')))) {
            BlFrontChar = (TUCHAR)szBar[0];
        } else {
            BlFrontChar = *((USHORT *)((PTUCHAR)szBar));
        }
    }

    // fetch the progress bar background character
    szBar = BlFindMessage(BlProgBarBackMsgID);

    if (szBar) {
        ULONG   len = _tcslen(szBar);

        if ((len == 1) ||
                ((len > 2) && (szBar[1] == TEXT('\r')) && (szBar[2] == TEXT('\n')))) {
            BlBackChar = (TUCHAR)szBar[0];
        } else {
            BlBackChar = *((USHORT *)((PTUCHAR)szBar));
        }
    }

    //
    // make both the progess bar characters double byte characters
    // if one of them is double byte character
    //
    if (BlFrontChar & 0xFF00) {
        if (!(BlBackChar & 0xFF00))
            BlBackChar = BlBackChar | (BlBackChar << 8);
    } else {
        if (BlBackChar & 0xFF00)
            BlFrontChar = BlFrontChar | (BlFrontChar << 8);
    }
#endif
}

ARC_STATUS
BlLoadFileImage(
    IN  ULONG           DeviceId,
    IN  PCHAR           DeviceName,
    IN  PCHAR           Directory,
    IN  PUNICODE_STRING FileName,
    IN  TYPE_OF_MEMORY  MemoryType,
    OUT PVOID           *Image,
    OUT PULONG          ImageSize,
    OUT PCHAR           BadFileName
    )

/*++

Routine Description:

    This routine loads the specified device driver and resolves all DLL
    references if the driver is not already loaded.

Arguments:

    DeviceId - Supplies the file id of the device on which the specified
        device driver is loaded from.

    DeviceName - Supplies the name of the device the system tree is on.

    Directory - Supplies a pointer to the directory path of the root
        of the NT tree.

    FileName - Name of the file to be loaded.

    Image - Receives pointer to the buffer containing the file image in memory.

    ImageSize - Receives the size of file image in memory.

    BadFileName - Returns the filename of the OEM font file that was missing
        or invalid.

Return Value:

    ESUCCESS is returned if the specified file is successfully loaded.
    Otherwise unsuccessful status is returned.

--*/

{
    CHAR                infName[256];
    ARC_STATUS          status;
    ULONG               fileId;
    FILE_INFORMATION    fileInfo;
    ULONG               size;
    ULONG               pageCount;
    ULONG               actualBase;
    PCHAR               buffer;
    ULONG               sizeRead;

    *Image = NULL;
    *ImageSize = 0;

    //
    // Get the fully qualified name for the file being loaded.
    //

    sprintf(&infName[0], "%s%wZ", Directory, FileName);

    //
    // Display the name of file being loaded.
    //

    BlOutputLoadMessage(DeviceName, infName, NULL);

    //
    // Open the file.
    //

    status = BlOpen(DeviceId, infName, ArcOpenReadOnly, &fileId);

    if (status == ESUCCESS) {
        BlUpdateBootStatus();

        //
        // Find out size of INF file.
        //

        status = BlGetFileInformation(fileId, &fileInfo);
        if (status == ESUCCESS) {

            size = fileInfo.EndingAddress.LowPart;

            //
            // Allocate a descriptor large enough to hold the entire file.
            // On x86 this has an unfortunate tendency to slam txtsetup.sif
            // into a free block at 1MB, which means the kernel can't be
            // loaded (it's linked for 0x100000 without relocations).
            // On x86 this has an unfortunate tendency to slam txtsetup.sif
            // into a free block at 1MB, which means the kernel can't be
            // loaded (it's linked for 0x100000 without relocations).
            //
            // (tedm) we're also seeing a similar problem on alphas now
            // because txtsetup.sif has grown too large, so this code has been
            // made non-conditional.
            //


            pageCount = (ULONG)(ROUND_TO_PAGES(size) >> PAGE_SHIFT);

            status = BlAllocateDescriptor(  MemoryType, // Descriptor gets reclaimed by MM.
                                            0,
                                            pageCount,
                                            &actualBase);

            if (status == ESUCCESS) {

                buffer = (PCHAR)(KSEG0_BASE | (actualBase << PAGE_SHIFT));

                //
                // Read the file in.
                //

                status = BlRead(fileId, buffer, size, &sizeRead);
                if (status == ESUCCESS) {

                    //
                    // If the file was successfully read, return the
                    // desired parameters.
                    //

                    if (Image) {

                        *Image = buffer;
                    }

                    if (ImageSize) {

                        *ImageSize = sizeRead;
                    }
                }
                else {

                    //
                    // No need to release the memory as it will get reclaimed by MM anyway.
                    //
                }
            }
        }

        //
        // Close the file handle.
        //

        BlClose(fileId);
    }

    //
    // If there was any error, return the name of the file
    // we failed to load.
    //

    if (status != ESUCCESS)
    {
        strcpy(BadFileName, &infName[0]);
    }

    return(status);
}

VOID
BlClearScreen(
    VOID
    )

/*++

Routine Description:

    Clears the screen.

Arguments:

    None

Return Value:

    None.

--*/

{
#ifdef EFI
    BlEfiClearDisplay();
#else 
    TCHAR Buffer[16];
    ULONG Count;

    _stprintf(Buffer, ASCI_CSI_OUT TEXT("2J"));

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer) *sizeof(TCHAR),
             &Count);
#endif
}


VOID
BlClearToEndOfScreen(
    VOID
    )
{
#ifdef EFI
    BlEfiClearToEndOfDisplay();
#else 
    TCHAR Buffer[16];
    ULONG Count;
    
    _stprintf(Buffer, ASCI_CSI_OUT TEXT("J"));
    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer)*sizeof(TCHAR),
             &Count);
#endif
}


VOID
BlClearToEndOfLine(
    VOID
    )
{
#ifdef EFI
    BlEfiClearToEndOfLine();
#else
    TCHAR Buffer[16];
    ULONG Count;
    
    if (!DisplayLogoOnBoot) {

        _stprintf(Buffer, ASCI_CSI_OUT TEXT("K"));
        ArcWrite(BlConsoleOutDeviceId,
                 Buffer,
                 _tcslen(Buffer)*sizeof(TCHAR),
                 &Count);
    }
#endif
}


VOID
BlPositionCursor(
    IN ULONG Column,
    IN ULONG Row
    )

/*++

Routine Description:

    Sets the position of the cursor on the screen.

Arguments:

    Column - supplies new Column for the cursor position.

    Row - supplies new Row for the cursor position.

Return Value:

    None.

--*/

{
#ifdef EFI
    BlEfiPositionCursor( Column-1, Row-1 );    
#else
    TCHAR Buffer[16];
    ULONG Count;
    
    _stprintf(Buffer, ASCI_CSI_OUT TEXT("%d;%dH"), Row, Column);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer)*sizeof(TCHAR),
             &Count);
#endif

}


VOID
BlSetInverseMode(
    IN BOOLEAN InverseOn
    )

/*++

Routine Description:

    Sets inverse console output mode on or off.

Arguments:

    InverseOn - supplies whether inverse mode should be turned on (TRUE)
                or off (FALSE)

Return Value:

    None.

--*/

{
#ifdef EFI    
    BlEfiSetInverseMode( InverseOn );
#else
    TCHAR Buffer[16];
    ULONG Count;

    
    _stprintf(Buffer, ASCI_CSI_OUT TEXT("%dm"), InverseOn ? SGR_INVERSE : SGR_NORMAL);

    ArcWrite(BlConsoleOutDeviceId,
             Buffer,
             _tcslen(Buffer)*sizeof(TCHAR),
             &Count);
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blmemory.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blmemory.c

Abstract:

    This module implements the OS loader memory allocation routines.

Author:

    David N. Cutler (davec) 19-May-1991

Revision History:

--*/

#include "bldr.h"

#if defined(_X86_)
#include "bldrx86.h"
#endif

#if defined(_IA64_)
#include "bldria64.h"
#endif

#include <stdlib.h>
#include <ntverp.h>

#define MIN(_a,_b) (((_a) <= (_b)) ? (_a) : (_b))
#define MAX(_a,_b) (((_a) >= (_b)) ? (_a) : (_b))

#define IsTrackMem(t) ((t != LoaderFree) &&                 \
                       (t != LoaderBad)  &&                 \
                       (t != LoaderFirmwareTemporary) &&    \
                       (t != LoaderOsloaderStack) &&        \
                       (t != LoaderXIPRom) &&               \
                       (t != LoaderReserve))


//
// The first PDE page is always mapped, on PAE this is the bottom 2MB
//
#define ALWAYS_MAPPED ((2*1024*1024) >> PAGE_SHIFT)

#define IsValidTrackingRange(b,n) (((b+n) > ALWAYS_MAPPED) ? TRUE :FALSE)

ALLOCATION_POLICY BlMemoryAllocationPolicy = BlAllocateBestFit;
ALLOCATION_POLICY BlHeapAllocationPolicy = BlAllocateBestFit;

//
// Define memory allocation descriptor listhead and heap storage variables.
//

ULONG_PTR BlHeapFree;
ULONG_PTR BlHeapLimit;
PLOADER_PARAMETER_BLOCK BlLoaderBlock;
ULONG BlHighestPage;
ULONG BlLowestPage;

//
// Global Value for where to load the kernel
//
BOOLEAN BlOldKernel = FALSE;
BOOLEAN BlRestoring = FALSE;
BOOLEAN BlKernelChecked = FALSE;

//
// Define the lowest and highest usable pages
//
#if defined(_X86_)

//
// X86 is limited to the first 512MB of physical address space
// Until BlMemoryInitialize has happened, we want to limit things
// to the first 16MB as that is all that has been mapped.
//
ULONG BlUsableBase=0;
ULONG BlUsableLimitX86=((16*1024*1024)/PAGE_SIZE);        // 16MB
ULONG BlUsableLimitAmd64=((512*1024*1024)/PAGE_SIZE);     // 512MB

#elif defined(_IA64_)

//
// IA64 uses TRs to map 3 distinct regions (decompression, kernel/hal, 
// drivers).  BlUsableBase/Limit are used in BlAllocateAlignedDescriptor
// to ensure that an allocation in in the desired region.  Kernel/hal and
// decompression allocations change these values for there allocations.  
// The default case is to allocate in the driver region which is from
// 64MB to 128MB.  Set BlUsableBase/Limit to specify this region for
// default descriptor allocations.
//
ULONG BlUsableBase  = BL_DRIVER_RANGE_LOW;
ULONG BlUsableLimit = BL_DRIVER_RANGE_HIGH;

#else

ULONG BlUsableBase = 0;
ULONG BlUsableLimit = 0xffffffff;

#endif

TYPE_OF_MEMORY
BlpDetermineAllocationPolicy (
   TYPE_OF_MEMORY MemoryType,
   ULONG BasePage,
   ULONG PageCount,
   BOOLEAN Retry
   );

void
BlpTrackUsage (
    MEMORY_TYPE MemoryType,
    ULONG ActualBase,
    ULONG  NumberPages
    );


#if DBG
ULONG_PTR TotalHeapAbandoned = 0;
#endif



//
// WARNING: (x86 only) Use this carefully. Currently only temporary buffers
// are allocated top down. The kernel and drivers are loaded bottom up
// this has an effect on PAE. Since the PAE kernel loads at 16MB
// only temp buffers can be above 16MB. If drivers are loaded there the
// system will fail
//
VOID
BlSetAllocationPolicy (
    IN ALLOCATION_POLICY MemoryAllocationPolicy,
    IN ALLOCATION_POLICY HeapAllocationPolicy
    )
{
    BlMemoryAllocationPolicy = MemoryAllocationPolicy;
    BlHeapAllocationPolicy = HeapAllocationPolicy;

    return;
}

VOID
BlInsertDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor
    )

/*++

Routine Description:

    This routine inserts a memory descriptor in the memory allocation list.
    It inserts the new descriptor in sorted order, based on the starting
    page of the block.  It also merges adjacent blocks of free memory.

Arguments:

    ListHead - Supplies the address of the memory allocation list head.

    NewDescriptor - Supplies the address of the descriptor that is to be
        inserted.

Return Value:

    None.

--*/

{
    PLIST_ENTRY ListHead = &BlLoaderBlock->MemoryDescriptorListHead;
    PLIST_ENTRY PreviousEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR PreviousDescriptor = NULL;
    PLIST_ENTRY NextEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor = NULL;

    //
    // Find the first descriptor in the list that starts above the new
    // descriptor.  The new descriptor goes in front of this descriptor.
    //

    PreviousEntry = ListHead;
    NextEntry = ListHead->Flink;
    while (NextEntry != ListHead) {
        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);
        if (NewDescriptor->BasePage < NextDescriptor->BasePage) {
            break;
        }
        PreviousEntry = NextEntry;
        PreviousDescriptor = NextDescriptor;
        NextEntry = NextEntry->Flink;
    }

    //
    // If the new descriptor doesn't describe free memory, just insert it
    // in the list in front of the previous entry.  Otherwise, check to see
    // if free blocks can be merged.
    //

    if (NewDescriptor->MemoryType != LoaderFree) {

        InsertHeadList(PreviousEntry, &NewDescriptor->ListEntry);

    } else {

        //
        // If the previous block also describes free memory, and it's
        // contiguous with the new block, merge them by adding the
        // page count from the new
        //

        if ((PreviousDescriptor != NULL) &&
            (PreviousEntry != ListHead) &&
            ((PreviousDescriptor->MemoryType == LoaderFree) ||
             (PreviousDescriptor->MemoryType == LoaderReserve) ) &&
            ((PreviousDescriptor->BasePage + PreviousDescriptor->PageCount) ==
                                                                    NewDescriptor->BasePage)) {
            PreviousDescriptor->PageCount += NewDescriptor->PageCount;
            NewDescriptor = PreviousDescriptor;
        } else {
            InsertHeadList(PreviousEntry, &NewDescriptor->ListEntry);
        }
        if ((NextDescriptor != NULL) &&
            (NextEntry != ListHead) &&
            ((NextDescriptor->MemoryType == LoaderFree) ||
             (NextDescriptor->MemoryType == LoaderReserve)) &&
            ((NewDescriptor->BasePage + NewDescriptor->PageCount) == NextDescriptor->BasePage)) {
            NewDescriptor->PageCount += NextDescriptor->PageCount;
            NewDescriptor->MemoryType = NextDescriptor->MemoryType;
            BlRemoveDescriptor(NextDescriptor);
        }
    }

    return;
}

ARC_STATUS
BlMemoryInitialize (
    VOID
    )

/*++

Routine Description:

    This routine allocates stack space for the OS loader, initializes
    heap storage, and initializes the memory allocation list.

Arguments:

    None.

Return Value:

    ESUCCESS is returned if the initialization is successful. Otherwise,
    ENOMEM is returned.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;
    PMEMORY_DESCRIPTOR HeapDescriptor;
    PMEMORY_DESCRIPTOR MemoryDescriptor;
#ifndef EFI
    PMEMORY_DESCRIPTOR ProgramDescriptor;
#endif
    ULONG EndPage;
    ULONG HeapAndStackPages;
    ULONG StackPages;
    ULONG StackBasePage;
    CHAR versionBuffer[64];
    PCHAR major;
    PCHAR minor;


    //
    // This code doesn't work under EFI -- we can have multiple
    // MemoryLoadedProgram descriptors under EFI.  We also cannot make the
    // same assumptions about finding a free descriptor below
    // the os loader for a stack and heap as under ARC.  Instead, we'll just
    // search for any suitable place for a heap and stack
    //
#ifndef EFI
    //
    // Find the memory descriptor that describes the allocation for the OS
    // loader itself.
    //

    ProgramDescriptor = NULL;
    while ((ProgramDescriptor = ArcGetMemoryDescriptor(ProgramDescriptor)) != NULL) {
        if (ProgramDescriptor->MemoryType == MemoryLoadedProgram) {
            break;
        }
    }

    //
    // If a loaded program memory descriptor was found, then it must be
    // for the OS loader since that is the only program that can be loaded.
    // If a loaded program memory descriptor was not found, then firmware
    // is not functioning properly and an unsuccessful status is returned.
    //

    if (ProgramDescriptor == NULL) {
        DBGTRACE( TEXT("Couldn't find ProgramDescriptor\r\n"));
        return ENOMEM;
    }

    //
    // Find the free memory descriptor that is just below the loaded
    // program in memory. There should be several megabytes of free
    // memory just preceeding the OS loader.
    //

    StackPages = BL_STACK_PAGES;
    HeapAndStackPages = BL_HEAP_PAGES + BL_STACK_PAGES;

    HeapDescriptor = NULL;
    while ((HeapDescriptor = ArcGetMemoryDescriptor(HeapDescriptor)) != NULL) {
        if (((HeapDescriptor->MemoryType == MemoryFree) ||
            (HeapDescriptor->MemoryType == MemoryFreeContiguous)) &&
            ((HeapDescriptor->BasePage + HeapDescriptor->PageCount) ==
                                                        ProgramDescriptor->BasePage)) {
            break;
        }
    }
#else
    StackPages = BL_STACK_PAGES;
    HeapAndStackPages = BL_HEAP_PAGES + BL_STACK_PAGES;
    HeapDescriptor = NULL;
#endif
    //
    // If a free memory descriptor was not found that describes the free
    // memory just below the OS loader, or the memory descriptor is not
    // large enough for the OS loader stack and heap, then try and find
    // a suitable one.
    //
    if ((HeapDescriptor == NULL) ||
        (HeapDescriptor->PageCount < (BL_HEAP_PAGES + BL_STACK_PAGES))) {

        HeapDescriptor = NULL;
        while ((HeapDescriptor = ArcGetMemoryDescriptor(HeapDescriptor)) != NULL) {
#if defined(_IA64_)
            //
            // The heap should be allocated at the top of the driver region.
            //
            if ((HeapDescriptor->BasePage < BL_DRIVER_RANGE_HIGH) &&
                (HeapDescriptor->BasePage >= BL_DRIVER_RANGE_LOW)) {
#endif
                if (((HeapDescriptor->MemoryType == MemoryFree) ||
                    (HeapDescriptor->MemoryType == MemoryFreeContiguous)) &&
                    (HeapDescriptor->PageCount >= (BL_HEAP_PAGES + BL_STACK_PAGES))) {
                    break;
                }
#if defined(_IA64_)
            }
#endif
        }
    }

    //
    // A suitable descriptor could not be found, return an unsuccessful
    // status.
    //
    if (HeapDescriptor == NULL) {
        DBGTRACE( TEXT("Couldn't find HeapDescriptor\r\n"));
        return(ENOMEM);
    }

    StackBasePage = HeapDescriptor->BasePage + HeapDescriptor->PageCount - BL_STACK_PAGES;

    //
    // Compute the address of the loader heap, initialize the heap
    // allocation variables, and zero the heap memory.
    //
    EndPage = HeapDescriptor->BasePage + HeapDescriptor->PageCount;

    BlpTrackUsage (LoaderOsloaderHeap,HeapDescriptor->BasePage,HeapDescriptor->PageCount);
    BlHeapFree = KSEG0_BASE | ((EndPage - HeapAndStackPages) << PAGE_SHIFT);


    //
    // always reserve enough space in the heap for one more memory
    // descriptor, so we can go create more heap if we run out.
    //
    BlHeapLimit = (BlHeapFree + (BL_HEAP_PAGES << PAGE_SHIFT)) - sizeof(MEMORY_ALLOCATION_DESCRIPTOR);

    RtlZeroMemory((PVOID)BlHeapFree, BL_HEAP_PAGES << PAGE_SHIFT);

    //
    // Allocate and initialize the loader parameter block.
    //

    BlLoaderBlock =
        (PLOADER_PARAMETER_BLOCK)BlAllocateHeap(sizeof(LOADER_PARAMETER_BLOCK));

    if (BlLoaderBlock == NULL) {
        DBGTRACE( TEXT("Couldn't initialize loader block\r\n"));
        return ENOMEM;
    }

    BlLoaderBlock->Extension =
        (PLOADER_PARAMETER_EXTENSION)
        BlAllocateHeap(sizeof(LOADER_PARAMETER_EXTENSION));

    if (BlLoaderBlock->Extension == NULL) {
        DBGTRACE( TEXT("Couldn't initialize loader block extension\r\n"));
        return ENOMEM;
    }

    BlLoaderBlock->Extension->Size = sizeof (LOADER_PARAMETER_EXTENSION);
    major = strcpy(versionBuffer, VER_PRODUCTVERSION_STR);
    minor = strchr(major, '.');
    *minor++ = '\0';
    BlLoaderBlock->Extension->MajorVersion = atoi(major);
    BlLoaderBlock->Extension->MinorVersion = atoi(minor);
    BlLoaderBlock->Extension->InfFileImage = NULL;
    BlLoaderBlock->Extension->InfFileSize = 0;


    InitializeListHead(&BlLoaderBlock->LoadOrderListHead);
    InitializeListHead(&BlLoaderBlock->MemoryDescriptorListHead);
    InitializeListHead(&BlLoaderBlock->Extension->FirmwareDescriptorListHead);

    //
    // Copy the memory descriptor list from firmware into the local heap and
    // deallocate the loader heap and stack from the free memory descriptor.
    //

    MemoryDescriptor = NULL;
    while ((MemoryDescriptor = ArcGetMemoryDescriptor(MemoryDescriptor)) != NULL) {
        AllocationDescriptor =
                    (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                        sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

        if (AllocationDescriptor == NULL) {
            DBGTRACE( TEXT("Couldn't allocate heap for memory allocation descriptor\r\n"));
            return ENOMEM;
        }

        AllocationDescriptor->MemoryType =
                                    (TYPE_OF_MEMORY)MemoryDescriptor->MemoryType;

        if (MemoryDescriptor->MemoryType == MemoryFreeContiguous) {
            AllocationDescriptor->MemoryType = LoaderFree;

        } else if (MemoryDescriptor->MemoryType == MemorySpecialMemory) {
            AllocationDescriptor->MemoryType = LoaderSpecialMemory;
        }

        AllocationDescriptor->BasePage = MemoryDescriptor->BasePage;
        AllocationDescriptor->PageCount = MemoryDescriptor->PageCount;
        if (MemoryDescriptor == HeapDescriptor) {
            AllocationDescriptor->PageCount -= HeapAndStackPages;
        }

        //
        // [chuckl 11/19/2001, fixing a bug from 11/15/1993]
        //
        // In rare cases, the above subtraction of HeapAndStackPages from
        // PageCount can result in a PageCount of 0. MM doesn't like this,
        // so don't insert the descriptor if PageCount is 0. The side
        // effect of this is that we "lose" a descriptor, but that's just
        // a few bytes of heap lost.
        //

        if (AllocationDescriptor->PageCount != 0) {
            BlInsertDescriptor(AllocationDescriptor);
        }
    }

    //
    // Allocate a memory descriptor for the loader stack.
    //

    if (StackPages != 0) {

        AllocationDescriptor =
                (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                        sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

        if (AllocationDescriptor == NULL) {
            DBGTRACE( TEXT("Couldn't allocate heap for loader stack\r\n"));
            return ENOMEM;
        }

        AllocationDescriptor->MemoryType = LoaderOsloaderStack;
        AllocationDescriptor->BasePage = StackBasePage;
        AllocationDescriptor->PageCount = BL_STACK_PAGES;
        BlInsertDescriptor(AllocationDescriptor);
    }

    //
    // Allocate a memory descriptor for the loader heap.
    //

    AllocationDescriptor =
                (PMEMORY_ALLOCATION_DESCRIPTOR)BlAllocateHeap(
                                    sizeof(MEMORY_ALLOCATION_DESCRIPTOR));

    if (AllocationDescriptor == NULL) {
        DBGTRACE( TEXT("Couldn't allocate heap for loader heap\r\n"));
        return ENOMEM;
    }

    AllocationDescriptor->MemoryType = LoaderOsloaderHeap;
    AllocationDescriptor->BasePage = EndPage - HeapAndStackPages;

    AllocationDescriptor->PageCount = BL_HEAP_PAGES;
    BlInsertDescriptor(AllocationDescriptor);

    return ESUCCESS;
}


ARC_STATUS
BlAllocateAlignedDescriptor (
    IN TYPE_OF_MEMORY MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount,
    IN ULONG Alignment,
    OUT PULONG ActualBase
    )

/*++

Routine Description:

    This routine allocates memory and generates one of more memory
    descriptors to describe the allocated region. The first attempt
    is to allocate the specified region of memory (at BasePage).
    If the memory is not free, then the smallest region of free
    memory that satisfies the request is allocated.  The Alignment
    parameter can be used to force the block to be allocated at a
    particular alignment.

Arguments:

    MemoryType - Supplies the memory type that is to be assigned to
        the generated descriptor.

    BasePage - Supplies the base page number of the desired region.
        If 0, no particular base page is required.

    PageCount - Supplies the number of pages required.

    Alignment - Supplies the required alignment, in pages.  (E.g.,
        with 4K page size, 16K alignment requires Alignment == 4.)
        If 0, no particular alignment is required.

        N.B.  If BasePage is not 0, and the specified BasePage is
        available, Alignment is ignored.  It is up to the caller
        to specify a BasePage that meets the caller's alignment
        requirement.

    ActualBase - Supplies a pointer to a variable that receives the
        page number of the allocated region.

Return Value:

    ESUCCESS is returned if an available block of free memory can be
    allocated. Otherwise, return a unsuccessful status.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR FreeDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;
    ARC_STATUS Status;
    ULONG AlignedBasePage = 0, AlignedPageCount;
    ULONG FreeBasePage = 0, FreePageCount = 0;
    MEMORY_TYPE TypeToUse;
    ALLOCATION_POLICY OldPolicy = BlMemoryAllocationPolicy;
    BOOLEAN retryalloc=FALSE;

    //
    // Simplify the alignment checks by changing 0 to 1.
    //

    if (Alignment == 0) {
        Alignment = 1;
    }

    //
    // If the allocation is for zero pages, make it one, because allocation of zero
    // breaks the internal algorithms for merging, etc.
    //
    if (PageCount == 0) {
        PageCount = 1;
    }


    //
    // Attempt to find a free memory descriptor that encompasses the
    // specified region or a free memory descriptor that is large
    // enough to satisfy the request.
    //

retry:

    TypeToUse=BlpDetermineAllocationPolicy (MemoryType,BasePage,PageCount,retryalloc);

    //
    // If a base page was specified, find the containing descriptor and try and use
    // that directly.
    //
    if (BasePage &&
        (BasePage >= BlUsableBase) &&
        (BasePage + PageCount <= BlUsableLimit)) {

        FreeDescriptor = BlFindMemoryDescriptor(BasePage);
        if ((FreeDescriptor) &&
            (FreeDescriptor->MemoryType == TypeToUse) &&
            (FreeDescriptor->BasePage + FreeDescriptor->PageCount >= BasePage + PageCount)) {

            Status = BlGenerateDescriptor(FreeDescriptor,
                                          MemoryType,
                                          BasePage,
                                          PageCount);

            *ActualBase = BasePage;
            BlpTrackUsage (TypeToUse,*ActualBase,PageCount);
            if (BlpCheckMapping (BasePage,PageCount+1) != ESUCCESS) {
                BlMemoryAllocationPolicy=OldPolicy;
                return (ENOMEM);
            }
            BlMemoryAllocationPolicy=OldPolicy;
            return Status;
        }
    }

    FreeDescriptor = NULL;
    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {

        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);

        AlignedBasePage = (NextDescriptor->BasePage + (Alignment - 1)) & ~(Alignment - 1);
        AlignedPageCount= NextDescriptor->PageCount - (AlignedBasePage - NextDescriptor->BasePage);

        if ((NextDescriptor->MemoryType == TypeToUse) &&
            (AlignedPageCount <= NextDescriptor->PageCount) &&
            (AlignedBasePage + AlignedPageCount > BlUsableBase) &&
            (AlignedBasePage <= BlUsableLimit)) {

            //
            // Adjust bounds to account for the usable limits
            //
            if (AlignedBasePage < BlUsableBase) {
                AlignedBasePage = (BlUsableBase + (Alignment - 1)) & ~(Alignment - 1);
                AlignedPageCount= NextDescriptor->PageCount - (AlignedBasePage - NextDescriptor->BasePage);
            }
            if (AlignedBasePage + AlignedPageCount > BlUsableLimit) {
                AlignedPageCount = BlUsableLimit - AlignedBasePage;
            }

            if (PageCount <= AlignedPageCount) {

                //
                // This block will work.  If the allocation policy is
                // LowestFit, take this block (the memory list is sorted).
                // Otherwise, if this block best meets the allocation
                // policy, remember it and keep looking.
                //
                if (BlMemoryAllocationPolicy == BlAllocateLowestFit) {
                    FreeDescriptor = NextDescriptor;
                    FreeBasePage   = AlignedBasePage;
                    FreePageCount  = AlignedPageCount;
                    break;
                } else if ((FreeDescriptor == NULL) ||
                           (BlMemoryAllocationPolicy == BlAllocateHighestFit) ||
                           ((FreeDescriptor != NULL) &&
                            (AlignedPageCount < FreePageCount))) {
                    FreeDescriptor = NextDescriptor;
                    FreeBasePage   = AlignedBasePage;
                    FreePageCount  = AlignedPageCount;
                }
            }
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // If a free region that satisfies the request was found, then allocate
    // the space from that descriptor. Otherwise, return an unsuccessful status.
    //
    // If allocating lowest-fit or best-fit, allocate from the start of the block,
    // rounding up to the required alignment.  If allocating highest-fit, allocate
    // from the end of the block, rounding down to the required alignment.
    //

    if (FreeDescriptor != NULL) {

#if defined(EFI)
        if (MemoryType == LoaderXIPRom) {
            FreeDescriptor->MemoryType = LoaderFirmwareTemporary;
        }
#endif

        if (BlMemoryAllocationPolicy == BlAllocateHighestFit) {
            AlignedBasePage = (FreeBasePage + FreePageCount - PageCount) & ~(Alignment - 1);
        }
        *ActualBase = AlignedBasePage;
        BlpTrackUsage (TypeToUse,*ActualBase,PageCount);
        if (BlpCheckMapping (AlignedBasePage,PageCount+1) != ESUCCESS) {
            BlMemoryAllocationPolicy=OldPolicy;
            return (ENOMEM);
        }
        BlMemoryAllocationPolicy=OldPolicy;
        return BlGenerateDescriptor(FreeDescriptor,
                                    MemoryType,
                                    AlignedBasePage,
                                    PageCount);

    } else {
        //
        // Invade the MemoryLoaderReserve pool.
        //

        if (BlOldKernel || (retryalloc == TRUE)) {
            BlMemoryAllocationPolicy=OldPolicy;
            return ENOMEM;
        } else {
            retryalloc=TRUE;
            goto retry;
        }
    }
}


ARC_STATUS
BlFreeDescriptor (
    IN ULONG BasePage
    )

/*++

Routine Description:

    This routine free the memory block starting at the specified base page.

Arguments:

    BasePage - Supplies the base page number of the region to be freed.

Return Value:

    ESUCCESS.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;

    //
    // Attempt to find a memory descriptor that starts at the
    // specified base page.
    //

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        NextDescriptor = CONTAINING_RECORD(NextEntry,
                                           MEMORY_ALLOCATION_DESCRIPTOR,
                                           ListEntry);

        if (NextDescriptor->BasePage == BasePage) {
            if ((NextDescriptor->MemoryType != LoaderFree)) {
                NextDescriptor->MemoryType = LoaderFree;

                if ((NextDescriptor->BasePage+NextDescriptor->PageCount) == BlHighestPage) {
                    //
                    // Freeing the last descriptor. Set the highest page to 1 before us.
                    // -- this doesn't work if the guy before is free too...but....
                    //
                    BlHighestPage = NextDescriptor->BasePage +1;
                } else if (NextDescriptor->BasePage == BlLowestPage) {
                    BlLowestPage = NextDescriptor->BasePage + NextDescriptor->PageCount;
                }
                BlRemoveDescriptor(NextDescriptor);
                BlInsertDescriptor(NextDescriptor);
            }
            return ESUCCESS;
        }

        NextEntry = NextEntry->Flink;
    }

    //
    // The caller is confused and should be ignored.
    //

    return ESUCCESS;
}


PVOID
BlAllocateHeapAligned (
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the OS loader heap.  The memory
    will be allocated on a cache line boundary.

Arguments:

    Size - Supplies the size of block required in bytes.

Return Value:

    If a free block of memory of the specified size is available, then
    the address of the block is returned. Otherwise, NULL is returned.

--*/

{
    PVOID Buffer;

    Buffer = BlAllocateHeap(Size + BlDcacheFillSize - 1);
    if (Buffer != NULL) {
        //
        // round up to a cache line boundary
        //
        Buffer = ALIGN_BUFFER(Buffer);
    }

    return(Buffer);

}


PVOID
BlAllocateHeap (
    IN ULONG Size
    )

/*++

Routine Description:

    This routine allocates memory from the OS loader heap.

Arguments:

    Size - Supplies the size of block required in bytes.

Return Value:

    If a free block of memory of the specified size is available, then
    the address of the block is returned. Otherwise, NULL is returned.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR FreeDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR NextDescriptor;
    PLIST_ENTRY NextEntry;
    ULONG NewHeapPages;
    ULONG LastAttempt;
    PVOID Block;

    //
    // Round size up to next allocation boundary and attempt to allocate
    // a block of the requested size.
    //

    Size = (Size + (BL_GRANULARITY - 1)) & (~(BL_GRANULARITY - 1));

    Block = (PVOID)BlHeapFree;
    if ((BlHeapFree + Size) <= BlHeapLimit) {
        BlHeapFree += Size;
        return Block;
    } else {

#if DBG
        TotalHeapAbandoned += (BlHeapLimit - BlHeapFree);
        BlLog((LOG_ALL_W,"ABANDONING %d bytes of heap; total abandoned %d\n",
            (BlHeapLimit - BlHeapFree), TotalHeapAbandoned));
#endif
        //
        // Our heap is full.  BlHeapLimit always reserves enough space
        // for one more MEMORY_ALLOCATION_DESCRIPTOR, so use that to
        // go try and find more free memory we can use.
        //
        AllocationDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlHeapLimit;

        //
        // Attempt to find a free memory descriptor big enough to hold this
        // allocation or BL_HEAP_PAGES, whichever is bigger.
        //
        NewHeapPages = ((Size + sizeof(MEMORY_ALLOCATION_DESCRIPTOR) + (PAGE_SIZE-1)) >> PAGE_SHIFT);
        if (NewHeapPages < BL_HEAP_PAGES) {
            NewHeapPages = BL_HEAP_PAGES;
        }

        if (!BlOldKernel && BlVirtualBias) {
            BlHeapAllocationPolicy = BlAllocateHighestFit;
        }else {
            BlHeapAllocationPolicy = BlAllocateLowestFit;
        }

        do {

            FreeDescriptor = NULL;
            NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
            while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
                NextDescriptor = CONTAINING_RECORD(NextEntry,
                                                   MEMORY_ALLOCATION_DESCRIPTOR,
                                                   ListEntry);

#if defined(_IA64_)
                //
                // The heap should be allocated at the top of the driver region.
                //
                if ((NextDescriptor->BasePage < BL_DRIVER_RANGE_HIGH) &&
                    (NextDescriptor->BasePage >= BL_DRIVER_RANGE_LOW)) {
#endif
                    if ((NextDescriptor->MemoryType == LoaderFree) &&
                        (NextDescriptor->PageCount >= NewHeapPages)) {

                        //
                        // This block will work.  If the allocation policy is
                        // LowestFit, take this block (the memory list is sorted).
                        // Otherwise, if this block best meets the allocation
                        // policy, remember it and keep looking.
                        //

                        if (BlHeapAllocationPolicy == BlAllocateLowestFit) {
                            FreeDescriptor = NextDescriptor;
                            break;
                        }

                        if ((FreeDescriptor == NULL) ||
                            (BlHeapAllocationPolicy == BlAllocateHighestFit) ||
                            ((FreeDescriptor != NULL) &&
                             (NextDescriptor->PageCount < FreeDescriptor->PageCount))) {
                            FreeDescriptor = NextDescriptor;
                        }
                    }
#if defined(_IA64_)
                }
#endif
                NextEntry = NextEntry->Flink;

            }

            //
            // If we were unable to find a block of the desired size, memory
            // must be getting tight, so try again, this time looking just
            // enough to keep us going.  (The first time through, we try to
            // allocate at least BL_HEAP_PAGES.)
            //
            if (FreeDescriptor != NULL) {
                break;
            }
            LastAttempt = NewHeapPages;
            NewHeapPages = ((Size + sizeof(MEMORY_ALLOCATION_DESCRIPTOR) + (PAGE_SIZE-1)) >> PAGE_SHIFT);
            if (NewHeapPages == LastAttempt) {

                break;
            }

        } while (TRUE);

        if (FreeDescriptor == NULL) {

            //
            // No free memory left.
            //

            return(NULL);
        }

        //
        // We've found a descriptor that's big enough.  Just carve a
        // piece off the end and use that for our heap.  If we're taking
        // all of the memory from the descriptor, remove it from the
        // memory list.  (This wastes a descriptor, but that's life.)
        //

        FreeDescriptor->PageCount -= NewHeapPages;
        if (FreeDescriptor->PageCount == 0) {
            BlRemoveDescriptor(FreeDescriptor);
        }

        //
        // Initialize our new descriptor and add it to the list.
        //
        AllocationDescriptor->MemoryType = LoaderOsloaderHeap;
        AllocationDescriptor->BasePage = FreeDescriptor->BasePage +
            FreeDescriptor->PageCount;
        AllocationDescriptor->PageCount = NewHeapPages;

        BlpTrackUsage (LoaderOsloaderHeap,AllocationDescriptor->BasePage,AllocationDescriptor->PageCount);
        BlInsertDescriptor(AllocationDescriptor);

        //
        // initialize new heap values and return pointer to newly
        // alloc'd memory.
        //
        BlHeapFree = KSEG0_BASE | (AllocationDescriptor->BasePage << PAGE_SHIFT);


        BlHeapLimit = (BlHeapFree + (NewHeapPages << PAGE_SHIFT)) - sizeof(MEMORY_ALLOCATION_DESCRIPTOR);

        RtlZeroMemory((PVOID)BlHeapFree, NewHeapPages << PAGE_SHIFT);

        Block = (PVOID)BlHeapFree;
        if ((BlHeapFree + Size) < BlHeapLimit) {
            BlHeapFree += Size;
            return Block;
        } else {
            //
            // we should never get here
            //
            return(NULL);
        }
    }
}

VOID
BlGenerateNewHeap (
    IN PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor,
    IN ULONG BasePage,
    IN ULONG PageCount
    )

/*++

Routine Description:

    This routine allocates a new heap block from the specified memory
    descriptor, avoiding the region specified by BasePage and PageCount.
    The caller must ensure that this region does not encompass the entire
    block.

    The allocated heap block may be as small as a single page.

Arguments:

    MemoryDescriptor - Supplies a pointer to a free memory descriptor
        from which the heap block is to be allocated.

    BasePage - Supplies the base page number of the excluded region.

    PageCount - Supplies the number of pages in the excluded region.

Return Value:

    None.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR AllocationDescriptor;
    ULONG NewHeapPages;
    ULONG AvailableAtFront;
    ULONG AvailableAtBack;

    //
    // BlHeapLimit always reserves enough space for one more
    // MEMORY_ALLOCATION_DESCRIPTOR, so use that to describe the
    // new heap block.
    //
    AllocationDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)BlHeapLimit;

    //
    // Allocate the new heap from either the front or the back of the
    // specified descriptor, whichever fits best.  We'd like to allocate
    // BL_HEAP_PAGES pages, but we'll settle for less.
    //
    AvailableAtFront = BasePage - MemoryDescriptor->BasePage;
    AvailableAtBack = (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) -
                      (BasePage + PageCount);

    if ((AvailableAtFront == 0) ||
        ((AvailableAtBack != 0) && (AvailableAtBack < AvailableAtFront))) {
        NewHeapPages = MIN(AvailableAtBack, BL_HEAP_PAGES);
        AllocationDescriptor->BasePage =
            MemoryDescriptor->BasePage + MemoryDescriptor->PageCount - NewHeapPages;
    } else {
        NewHeapPages = MIN(AvailableAtFront, BL_HEAP_PAGES);
        AllocationDescriptor->BasePage = MemoryDescriptor->BasePage;
        MemoryDescriptor->BasePage += NewHeapPages;
    }

    MemoryDescriptor->PageCount -= NewHeapPages;

    //
    // Initialize our new descriptor and add it to the list.
    //
    AllocationDescriptor->MemoryType = LoaderOsloaderHeap;
    AllocationDescriptor->PageCount = NewHeapPages;

    BlInsertDescriptor(AllocationDescriptor);

    //
    // Initialize new heap values.
    //
    BlpTrackUsage (LoaderOsloaderHeap,AllocationDescriptor->BasePage,AllocationDescriptor->PageCount);
    BlHeapFree = KSEG0_BASE | (AllocationDescriptor->BasePage << PAGE_SHIFT);

    BlHeapLimit = (BlHeapFree + (NewHeapPages << PAGE_SHIFT)) - sizeof(MEMORY_ALLOCATION_DESCRIPTOR);

    RtlZeroMemory((PVOID)BlHeapFree, NewHeapPages << PAGE_SHIFT);

    return;
}


ARC_STATUS
BlGenerateDescriptor (
    IN PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor,
    IN MEMORY_TYPE MemoryType,
    IN ULONG BasePage,
    IN ULONG PageCount
    )

/*++

Routine Description:

    This routine allocates a new memory descriptor to describe the
    specified region of memory which is assumed to lie totally within
    the specified region which is free.

Arguments:

    MemoryDescriptor - Supplies a pointer to a free memory descriptor
        from which the specified memory is to be allocated.

    MemoryType - Supplies the type that is assigned to the allocated
        memory.

    BasePage - Supplies the base page number.

    PageCount - Supplies the number of pages.

Return Value:

    ESUCCESS is returned if a descriptor(s) is successfully generated.
    Otherwise, return an unsuccessful status.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor1 = NULL;
    PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor2 = NULL;
    LONG Offset;
    TYPE_OF_MEMORY OldType;
    BOOLEAN SecondDescriptorNeeded;

    //
    // If the allocation is for zero pages, make it one, because allocation of zero
    // breaks the internal algorithms for merging, etc.
    //
    if (PageCount == 0) {
        PageCount = 1;
    }

    //
    // If the specified region totally consumes the free region, then no
    // additional descriptors need to be allocated. If the specified region
    // is at the start or end of the free region, then only one descriptor
    // needs to be allocated. Otherwise, two additional descriptors need to
    // be allocated.
    //

    Offset = BasePage - MemoryDescriptor->BasePage;
    if ((Offset == 0) && (PageCount == MemoryDescriptor->PageCount)) {

        //
        // The specified region totally consumes the free region.
        //

        MemoryDescriptor->MemoryType = MemoryType;

    } else {

        //
        // Mark the entire given memory descriptor as in use.  If we are
        // out of heap, BlAllocateHeap will search for a new descriptor
        // to grow the heap and this prevents both routines from trying
        // to use the same descriptor.
        //
        OldType = MemoryDescriptor->MemoryType;
        MemoryDescriptor->MemoryType = LoaderSpecialMemory;

        //
        // A memory descriptor must be generated to describe the allocated
        // memory.
        //

        SecondDescriptorNeeded =
            (BOOLEAN)((BasePage != MemoryDescriptor->BasePage) &&
                      ((ULONG)(Offset + PageCount) != MemoryDescriptor->PageCount));

        NewDescriptor1 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );

        //
        // If allocation of the first additional memory descriptor failed,
        // then generate new heap using the block from which we are
        // allocating.  This can only be done if the block is free.
        //
        // Note that BlGenerateNewHeap cannot fail, because we know there is
        // at least one more page in the block than we want to take from it.
        //
        // Note also that the allocation following BlGenerateNewHeap is
        // guaranteed to succeed.
        //

        if (NewDescriptor1 == NULL) {
            if (OldType != LoaderFree) {
                MemoryDescriptor->MemoryType = OldType;
                return ENOMEM;
            }
            BlGenerateNewHeap(MemoryDescriptor, BasePage, PageCount);
            NewDescriptor1 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );

            //
            // Recompute offset, as the base page of the memory descriptor
            // has been changed by BlGenerateNewHeap
            //
            Offset = BasePage - MemoryDescriptor->BasePage;
        }

        //
        // If a second descriptor is needed, allocate it.  As above, if the
        // allocation fails, generate new heap using our block.
        //
        // Note that if BlGenerateNewHeap was called above, the first call
        // to BlAllocateHeap below will not fail.  (So we won't call
        // BlGenerateNewHeap twice.)
        //

        if (SecondDescriptorNeeded) {
            NewDescriptor2 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );

            if (NewDescriptor2 == NULL) {
                if (OldType != LoaderFree) {
                    MemoryDescriptor->MemoryType = OldType;
                    return ENOMEM;
                }
                BlGenerateNewHeap(MemoryDescriptor, BasePage, PageCount);
                NewDescriptor2 = BlAllocateHeap( sizeof(MEMORY_ALLOCATION_DESCRIPTOR) );
                Offset = BasePage - MemoryDescriptor->BasePage;
            }
        }

        NewDescriptor1->MemoryType = MemoryType;
        NewDescriptor1->BasePage = BasePage;
        NewDescriptor1->PageCount = PageCount;

        if (BasePage == MemoryDescriptor->BasePage) {

            //
            // The specified region lies at the start of the free region.
            //

            MemoryDescriptor->BasePage += PageCount;
            MemoryDescriptor->PageCount -= PageCount;
            MemoryDescriptor->MemoryType = OldType;

        } else if ((ULONG)(Offset + PageCount) == MemoryDescriptor->PageCount) {

            //
            // The specified region lies at the end of the free region.
            //

            MemoryDescriptor->PageCount -= PageCount;
            MemoryDescriptor->MemoryType = OldType;

        } else {

            //
            // The specified region lies in the middle of the free region.
            //

            NewDescriptor2->MemoryType = OldType;
            NewDescriptor2->BasePage = BasePage + PageCount;
            NewDescriptor2->PageCount =
                            MemoryDescriptor->PageCount - (PageCount + Offset);

            MemoryDescriptor->PageCount = Offset;
            MemoryDescriptor->MemoryType = OldType;

            BlInsertDescriptor(NewDescriptor2);
        }

        BlInsertDescriptor(NewDescriptor1);
    }

    BlpTrackUsage (MemoryType,BasePage,PageCount);

    return ESUCCESS;
}

PMEMORY_ALLOCATION_DESCRIPTOR
BlFindMemoryDescriptor(
    IN ULONG BasePage
    )

/*++

Routine Description:

    Finds the memory allocation descriptor that contains the given page.

Arguments:

    BasePage - Supplies the page whose allocation descriptor is to be found.

Return Value:

    != NULL - Pointer to the requested memory allocation descriptor
    == NULL - indicates no memory descriptor contains the given page

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor=NULL;
    PLIST_ENTRY NextEntry;

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);
        if ((MemoryDescriptor->BasePage <= BasePage) &&
            (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount > BasePage)) {

            //
            // Found it.
            //
            break;
        }

        NextEntry = NextEntry->Flink;
    }

    if (NextEntry == &BlLoaderBlock->MemoryDescriptorListHead) {
        return(NULL);
    } else {
        return(MemoryDescriptor);
    }

}

#ifdef SETUP
PMEMORY_ALLOCATION_DESCRIPTOR
BlFindFreeMemoryBlock(
    IN ULONG PageCount
    )

/*++

Routine Description:

    Find a free memory block of at least a given size (using a best-fit
    algorithm) or find the largest free memory block.

Arguments:

    PageCount - supplies the size in pages of the block.  If this is 0,
        then find the largest free block.

Return Value:

    Pointer to the memory allocation descriptor for the block or NULL if
    no block could be found matching the search criteria.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR FoundMemoryDescriptor=NULL;
    PLIST_ENTRY NextEntry;
    ULONG LargestSize = 0;
    ULONG SmallestLeftOver = (ULONG)(-1);

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {
        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        if (MemoryDescriptor->MemoryType == LoaderFree) {

            if(PageCount) {
                //
                // Looking for a block of a specific size.
                //
                if((MemoryDescriptor->PageCount >= PageCount)
                && (MemoryDescriptor->PageCount - PageCount < SmallestLeftOver))
                {
                    SmallestLeftOver = MemoryDescriptor->PageCount - PageCount;
                    FoundMemoryDescriptor = MemoryDescriptor;
                }
            } else {

                //
                // Looking for the largest free block.
                //

                if(MemoryDescriptor->PageCount > LargestSize) {
                    LargestSize = MemoryDescriptor->PageCount;
                    FoundMemoryDescriptor = MemoryDescriptor;
                }
            }

        }
        NextEntry = NextEntry->Flink;
    }

    return(FoundMemoryDescriptor);
}
#endif  // def SETUP

ULONG
BlDetermineOSVisibleMemory(
    VOID
    )

/*++

Routine Description:

    Determine the total amount of memory in the machine that will
    eventually be visible to the OS.

Arguments:

    None.

Return Value:

    Amount of memory in the system (that we think should be visible
    to the OS), in pages.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR MemoryDescriptor;
    PLIST_ENTRY NextEntry;
    ULONG PageCount;

    NextEntry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    PageCount = 0;
    while(NextEntry != &BlLoaderBlock->MemoryDescriptorListHead) {

        MemoryDescriptor = CONTAINING_RECORD(NextEntry,
                                             MEMORY_ALLOCATION_DESCRIPTOR,
                                             ListEntry);

        //
        // Try and exclude memory that won't be visible to the
        // OS.
        //
        if( (MemoryDescriptor->MemoryType != LoaderBad) &&
            (MemoryDescriptor->MemoryType != LoaderFirmwarePermanent) &&
            (MemoryDescriptor->MemoryType != LoaderSpecialMemory) &&
            (MemoryDescriptor->MemoryType != LoaderBBTMemory) ) {
        
#if i386
            //
            // Note: on x86 machines, we never use the 40h pages below the 16
            // meg line (bios shadow area).  The loader can see this memory, but
            // the OS can't, so we won't account for them here.
            //
            //
            // if(MemoryDescriptor->BasePage + MemoryDescriptor->PageCount == 0xfc0) {
            //     PageCount += 0x40;
            // }

            //
            // On x86 machines, ignore any blocks that start over 4Gig.  We
            // shouldn't be resuming from a hibernate if there's this much 
            // memory.  However, Some machines may map segments above the 4Gig 
            // address space, eventhough there's less than 4Gig of physical 
            // memory.  The OS won't see this memory, so don't account for it
            // here.
            //
            // If these machine does have >= 4Gig of physical memory, then they
            // won't be hibernating anyway because we disallow hibernates on systems
            // with that much memory (see po\pinfo.c\PopFilterCapabilities()), or
            // they're running in non-PAE mode and will only see memory below 4Gig.
            //
            if( (MemoryDescriptor->BasePage + MemoryDescriptor->PageCount) < _4096MB ) {
                // entire descriptor is below 4Gig.
                PageCount += MemoryDescriptor->PageCount;
            } else {
                // all or part of descriptor is above 4Gig.
                if( MemoryDescriptor->BasePage < _4096MB ) {
                    // descriptor starts below 4Gig, so it must be crossing the boundary.
                    PageCount += (_4096MB - MemoryDescriptor->BasePage);
                }
            }
#else
            PageCount += MemoryDescriptor->PageCount;
#endif
        }

        NextEntry = NextEntry->Flink;
    }

    return(PageCount);
}


ULONG
HbPageDisposition (
    IN PFN_NUMBER   Page
    )
{
    static PLIST_ENTRY              Entry;
    PLIST_ENTRY                     Start;
    PMEMORY_ALLOCATION_DESCRIPTOR   MemDesc;
    ULONG                           Disposition;

    //
    // Check to see if page is in the range of the last descritor looked at.
    //

    if (Entry) {
        MemDesc = CONTAINING_RECORD(Entry, MEMORY_ALLOCATION_DESCRIPTOR, ListEntry);
        if (Page >= MemDesc->BasePage && Page < MemDesc->BasePage + MemDesc->PageCount) {
            goto Done;
        }
    }

    //
    // Find descriptor describing this page
    //

    if (!Entry) {
        Entry = BlLoaderBlock->MemoryDescriptorListHead.Flink;
    }

    Start = Entry;
    for (; ;) {
        if (Entry != &BlLoaderBlock->MemoryDescriptorListHead) {
            MemDesc = CONTAINING_RECORD(Entry, MEMORY_ALLOCATION_DESCRIPTOR, ListEntry);
            if (Page >= MemDesc->BasePage && Page < MemDesc->BasePage + MemDesc->PageCount) {
                goto Done;
            }
        }

        Entry = Entry->Flink;

        if (Entry == Start) {
            //
            // Descriptor for this page was not found
            //

            return HbPageInvalid;
        }
    }

Done:
    //
    // Convert memory type to the proper disposition
    //

    switch (MemDesc->MemoryType) {
        case LoaderFree:
        case LoaderReserve:
            Disposition = HbPageNotInUse;
            break;

        case LoaderBad:
            Disposition = HbPageInvalid;
            break;

        case LoaderFirmwareTemporary:
            //
            // On x86 systems memory above 16Mb is marked as firmware temporary
            // by i386\memory.c to prevent the loader from typically trying to
            // map it
            //

            Disposition = HbPageInUseByLoader;

#if i386
            if (Page > ((ULONG)0x1000000 >> PAGE_SHIFT)) {
                Disposition = HbPageNotInUse;
            }
#endif
            break;
        default:
            Disposition = HbPageInUseByLoader;
            break;
    }

    return Disposition;
}

VOID
BlTruncateDescriptors (
    IN ULONG HighestPage
    )
/*++

Routine Description:

    This routine locates and truncates or removes any memory located in a
    page above HighestPage from the memory descriptor list in the loader
    block.

Arguments:

    HighestPage - Supplies the physical page number above which we are to
                  remove all pages.

Return Value:

    None.

--*/

{
    PLIST_ENTRY listHead;
    PLIST_ENTRY listEntry;
    PMEMORY_ALLOCATION_DESCRIPTOR descriptor;
    ULONG lastDescriptorPage;

    listHead = &BlLoaderBlock->MemoryDescriptorListHead;
    listEntry = listHead->Flink;

    while (listEntry != listHead) {

        descriptor = CONTAINING_RECORD( listEntry,
                                        MEMORY_ALLOCATION_DESCRIPTOR,
                                        ListEntry );

        //
        // Determine the page number of the last page in this descriptor
        //
        lastDescriptorPage = descriptor->BasePage +
            descriptor->PageCount - 1;

        if (lastDescriptorPage <= HighestPage) {

            //
            // None of the memory described by this descriptor is above
            // HighestPage.  Ignore this descriptor.
            //

        } else if (descriptor->BasePage > HighestPage) {

            //
            // All of this descriptor is above HighestPage.  Remove it.
            //

            BlRemoveDescriptor( descriptor );

        } else {

            //
            // Some but not all of the memory described by this descriptor lies
            // above HighestPage.  Truncate it.
            //

            descriptor->PageCount = HighestPage - descriptor->BasePage + 1;
        }

        listEntry = listEntry->Flink;
    }
}

TYPE_OF_MEMORY
BlpDetermineAllocationPolicy (
   TYPE_OF_MEMORY MemoryType,
   ULONG BasePage,
   ULONG PageCount,
   BOOLEAN retry
   )
{
    TYPE_OF_MEMORY TypeToUse;

#ifdef EFI
    UNREFERENCED_PARAMETER( PageCount );
#endif
    UNREFERENCED_PARAMETER( BasePage );

    //
    // Give the restore code buffers as low as possible to avoid double buffering
    //
    if (BlRestoring == TRUE) {
        BlMemoryAllocationPolicy = BlAllocateLowestFit;
        return (LoaderFree);
    }

    if (MemoryType == LoaderXIPRom) {
#ifndef EFI
        if (PageCount <= (4*1024*1024 >> PAGE_SHIFT)) {
            TypeToUse = (retry) ? LoaderReserve:LoaderFree;
            BlMemoryAllocationPolicy = BlAllocateLowestFit;
        } else {
            TypeToUse = LoaderReserve;
            BlMemoryAllocationPolicy = BlAllocateHighestFit;
        }
#else
        TypeToUse = LoaderReserve;
        BlMemoryAllocationPolicy = BlAllocateHighestFit;
#endif
        return TypeToUse;
    }

#ifndef EFI
    if (BlVirtualBias != 0) {
        //
        // Booted /3GB
        //
        // With a 5.0 or prior kernel, allocate from the bottom
        // up (this loader will never run setup)
        //
        if (!BlOldKernel) {
            if (IsTrackMem (MemoryType)){
                // We care about this allocation.
                // Allocations from reserve are done lowest fit (growing up from 16MB)
                // Allocations from free are done highest fit (growing down from 16MB)
                TypeToUse = (retry) ? LoaderReserve : LoaderFree;
                BlMemoryAllocationPolicy = (retry) ? BlAllocateLowestFit : BlAllocateHighestFit;
            } else {
                TypeToUse = (retry) ? LoaderReserve : LoaderFree;
                BlMemoryAllocationPolicy = BlAllocateLowestFit;
            }
        } else {
            //
            // Old kernel, load the kernel at the bottom
            //
            TypeToUse = LoaderFree;
            if (IsTrackMem (MemoryType) || (MemoryType == LoaderOsloaderHeap)) {
                // We care about this allocation.
                BlMemoryAllocationPolicy = BlAllocateLowestFit;
            } else {
                BlMemoryAllocationPolicy = BlAllocateHighestFit;
            }

        }
    } else
#endif
    {

#if defined(_X86_)

        if ((BlAmd64UseLongMode != FALSE) &&
            (MemoryType == LoaderBootDriver ||
             MemoryType == LoaderSystemCode ||
             MemoryType == LoaderHalCode) &&
            (retry == FALSE)) {

            //
            // Try to load boot drivers in a "bottom up" fashion starting
            // at the 16MB line.  This reduces pressure on the otherwise
            // special 16MB region, a problem particularly when we are
            // loading AMD64 binaries.
            //

            TypeToUse = LoaderReserve;
            BlMemoryAllocationPolicy = BlAllocateLowestFit;

        } else

#endif
        if (!IsTrackMem (MemoryType)) {

            // We don't care about this allocation.
            TypeToUse = (retry) ? LoaderFree:LoaderReserve;
            BlMemoryAllocationPolicy = BlAllocateHighestFit;
        } else {
            BlMemoryAllocationPolicy = BlAllocateLowestFit;
            TypeToUse = (retry) ? LoaderReserve : LoaderFree;
        }

    }

    if (BlOldKernel) {
        TypeToUse = LoaderFree;
    }

    return (TypeToUse);

}


void
BlpTrackUsage (
    MEMORY_TYPE MemoryType,
    ULONG ActualBase,
    ULONG NumberPages
    )
{



    if (BlRestoring || !(IsTrackMem (MemoryType)) || BlOldKernel ||
        !IsValidTrackingRange (ActualBase,NumberPages)) {
        //
        // Don't track
        //
        return;
    }

    if ((ActualBase+NumberPages) > BlHighestPage) {
        BlHighestPage = ActualBase+NumberPages;
    }

    if ((BlLowestPage == 0) || (BlLowestPage < ActualBase) ) {

        BlLowestPage = ActualBase;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blmisc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blmisc.c

Abstract:

    This module contains miscellaneous routines for use by
    the boot loader and setupldr.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bootlib.h"

#if defined(EFI)
#include "smbios.h"

extern PVOID SMBiosTable;
#endif

#if defined(_X86AMD64_)
#include "amd64\amd64prv.h"
#endif

//
// Value indicating whether a dbcs locale is active.
// If this value is non-0 we use alternate display routines, etc,
// and fetch messages in this language.
//
ULONG DbcsLangId;

PCHAR
BlGetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName
    )

/*++

Routine Description:

    This routine scans the specified argument list for the named argument
    and returns the address of the argument value. Argument strings are
    specified as:

        ArgumentName=ArgumentValue

    Argument names are specified as:

        ArgumentName=

    The argument name match is case insensitive.

Arguments:

    Argc - Supplies the number of argument strings that are to be scanned.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    ArgumentName - Supplies a pointer to a null terminated argument name.

Return Value:

    If the specified argument name is located, then a pointer to the argument
    value is returned as the function value. Otherwise, a value of NULL is
    returned.

--*/

{

    PCHAR Name;
    PCHAR String;

    //
    // Scan the argument strings until either a match is found or all of
    // the strings have been scanned.
    //

    while (Argc > 0) {
        String = Argv[Argc - 1];
        if (String != NULL) {
            Name = ArgumentName;
            while ((*Name != 0) && (*String != 0)) {
                if (toupper(*Name) != toupper(*String)) {
                    break;
                }

                Name += 1;
                String += 1;
            }

            if ((*Name == 0) && (*String == '=')) {
                return String + 1;
            }

            Argc -= 1;
        }
    }

    return NULL;
}


PCHAR
BlSetArgumentValue (
    IN ULONG Argc,
    IN CHAR * FIRMWARE_PTR * FIRMWARE_PTR Argv,
    IN PCHAR ArgumentName,
    IN PCHAR NewValue
    )

/*++

Routine Description:

    This routine scans the specified argument list for the named argument
    and returns the address of the argument value. The value associated
    with the arg is changed to the value passed in. Argument strings are

    specified as:

        ArgumentName=ArgumentValue

    Argument names are specified as:

        ArgumentName=

    The argument name match is case insensitive.

Arguments:

    Argc - Supplies the number of argument strings that are to be scanned.

    Argv - Supplies a pointer to a vector of pointers to null terminated
        argument strings.

    ArgumentName - Supplies a pointer to a null terminated argument name.

Return Value:

    If the specified argument name is located, then a pointer to the argument
    value is returned as the function value. Otherwise, a value of NULL is
    returned.

--*/

{

    PCHAR Name;
    PCHAR String;

    //
    // Scan the argument strings until either a match is found or all of
    // the strings have been scanned.
    //

    while (Argc > 0) {
        String = Argv[Argc - 1];
        if (String != NULL) {
            Name = ArgumentName;
            while ((*Name != 0) && (*String != 0)) {
                if (toupper(*Name) != toupper(*String)) {
                    break;
                }

                Name += 1;
                String += 1;
            }

            if ((*Name == 0) && (*String == '=')) {
                Name = (PCHAR)BlAllocateHeap((ULONG)strlen(ArgumentName)+2+(ULONG)strlen(NewValue));
                if (Name) {
                    strcpy( Name, ArgumentName );
                    strcat( Name, "=" );
                    strcat( Name, NewValue );
                    return Name+strlen(ArgumentName)+1;
                }
                return String + 1;
            }

            Argc -= 1;
        }
    }

    return NULL;
}

//
// Line draw chars -- different scheme in Far East vs. SBCS
//
_TUCHAR
GetGraphicsChar(
    IN GraphicsChar WhichOne
    )
{
#ifdef EFI
    
    return(TextGetGraphicsCharacter(WhichOne));
#else

#if defined(_X86_)  && !defined(ARCI386)   

    return(TextGetGraphicsCharacter(WhichOne));
#else
    //
    // ARC machines don't support dbcs for now
    //
    static _TUCHAR ArcGraphicsChars[GraphicsCharMax] = { (UCHAR)'\311',   // right-down
                                                       (UCHAR)'\273',   // left-down
                                                       (UCHAR)'\310',   // right-up
                                                       (UCHAR)'\274',   // left-up
                                                       (UCHAR)'\272',   // vertical
                                                       (UCHAR)'\315'    // horizontal
                                                     };

    return(((unsigned)WhichOne < (unsigned)GraphicsCharMax) 
             ? ArcGraphicsChars[WhichOne] 
             : TEXT(' '));
#endif
#endif
}


LOGICAL
BdPollBreakIn(
    VOID
    );

#if defined(_X86_)
#include <bldrx86.h>
#endif

VOID
BlWaitForReboot (
    VOID
    )
{
#if defined(_X86)
    BlPrint( TEXT("Press any key to reboot\n") );
#endif

    while (TRUE) {

#if defined(_X86_)
        if ( BdPollBreakIn() ) {
            DbgBreakPoint();
        }
        if ( ArcGetReadStatus(BlConsoleInDeviceId) ) {
            BlPrint( TEXT("Rebooting...\n") );
            ArcReboot();
        }
#endif

        ;
    }
}


#ifdef EFI
VOID 
SetupSMBiosInLoaderBlock(
    VOID
    )
{
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;

    if (SMBiosTable != NULL)
    {
        SMBiosEPSHeader = BlAllocateHeap(sizeof(SMBIOS_EPS_HEADER));
        RtlCopyMemory(SMBiosEPSHeader, SMBiosTable, sizeof(SMBIOS_EPS_HEADER));
    } else {
        SMBiosEPSHeader = NULL;
    }
    BlLoaderBlock->Extension->SMBiosEPSHeader = SMBiosEPSHeader;
}
#endif

VOID
BlTransferToKernel(
    IN PTRANSFER_ROUTINE SystemEntry,
    IN PLOADER_PARAMETER_BLOCK BlLoaderBlock
    )
{
    //
    // Turn off the debugging system
    //

    BlLogTerminate();

    //
    // Inform the boot debugger that the boot phase is complete.
    //

#if defined(ENABLE_LOADER_DEBUG) || DBG

#if (defined(_X86_) || defined(_ALPHA_)) && !defined(ARCI386)

    if (BdDebuggerEnabled == TRUE) {
        DbgUnLoadImageSymbols(NULL, (PVOID)-1, 0);
    }

#endif

#endif

#if defined(_X86AMD64_)
    if (BlAmd64UseLongMode != FALSE) {

        //
        // Do the work to switch to AMD64 long mode, then branch to the
        // kernel image.
        // 

        BlAmd64TransferToKernel(SystemEntry, BlLoaderBlock);
        return;
    }
#endif

    //
    // Transfer control to loaded image.
    //

    (SystemEntry)(BlLoaderBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\bllog.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    blprint.c

Abstract:

    This module implements the OS loader debug logging routines.

Author:

    Chuck Lenzmeier (chuckl) 2-Nov-1995

Revision History:

--*/

#include "bldr.h"
#include <stdio.h>

#if DBG || BLLOGENABLED

ULONG BlLogFileId = (ULONG)-1;
ULONG BlLogActiveTargets = 0;

VOID
BlLogInitialize (
    ULONG LogfileDeviceId
    )
{
    ARC_STATUS Status;

    BlLogActiveTargets = 0;

    if (BlLoaderBlock->LoadOptions != NULL) {

        if (strstr(BlLoaderBlock->LoadOptions,"DBGDISPLAY") != NULL) {
            BlLogActiveTargets |= LOG_DISPLAY;
        }

        if (strstr(BlLoaderBlock->LoadOptions,"DBGDEBUGGER") != NULL) {
            BlLogActiveTargets |= LOG_DEBUGGER;
        }

        if (strstr(BlLoaderBlock->LoadOptions,"DBGLOG") != NULL) {
            Status = BlOpen(LogfileDeviceId, "\\LDRDBG.LOG", ArcSupersedeReadWrite, &BlLogFileId);
            if (Status == 0) {
                BlLogActiveTargets |= LOG_LOGFILE;
            }
        }
    }

#if 0
    BlLogArcDescriptors(LOG_ALL);
    BlLogMemoryDescriptors(LOG_ALL_W);
#endif

    return;
}

VOID
BlLogTerminate (
    VOID
    )
{
#if 0
    BlLogMemoryDescriptors(LOG_ALL);
#endif
    BlLog(( 
        0 ? BlLogActiveTargets | LOG_WAIT : BlLogActiveTargets, 
        "BlLog terminating" 
        ));
    
    if ((BlLogActiveTargets & LOG_LOGFILE) != 0) {
        BlClose(BlLogFileId);
    }
    BlLogActiveTargets = 0;

    return;
}

VOID
BlLogWait (
    IN ULONG Targets
    )
{
    if ((Targets & BlLogActiveTargets & LOG_DEBUGGER) != 0) {
        DbgBreakPoint( );
    } else if ((Targets & BlLogActiveTargets & LOG_DISPLAY) != 0) {
        BlLogWaitForKeystroke();
    }

    return;
}

VOID
BlLogPrint (
    ULONG Targets,
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    int count;
    CHAR buffer[79];
    ULONG activeTargets;

    activeTargets = Targets & BlLogActiveTargets;

    if (activeTargets != 0) {

        va_start(arglist, Format);

        count = _vsnprintf(buffer, sizeof(buffer), Format, arglist);
        if (count != -1) {
            RtlFillMemory(&buffer[count], sizeof(buffer)-count-2, ' ');
        }
        count = sizeof(buffer);
        buffer[count-2] = '\r';
        buffer[count-1] = '\n';

        if ((activeTargets & LOG_LOGFILE) != 0) {
            BlWrite(BlLogFileId, buffer, sizeof(buffer), (PULONG)&count);
        }

        if ((activeTargets & LOG_DISPLAY) != 0) {
            ArcWrite(ARC_CONSOLE_OUTPUT, buffer, sizeof(buffer), (PULONG)&count);
        }
        if ((activeTargets & LOG_DEBUGGER) != 0) {
            DbgPrint( buffer );
        }

        if ((Targets & LOG_WAIT) != 0) {
            BlLogWait( Targets );
        }
    }

    return;
}

VOID
BlLogArcDescriptors (
    ULONG Targets
    )
{
    PMEMORY_DESCRIPTOR CurrentDescriptor;
    ULONG activeTargets;

    activeTargets = Targets & BlLogActiveTargets;

    if (activeTargets != 0) {

        BlLog((activeTargets,"***** ARC Memory List *****"));

        CurrentDescriptor = NULL;
        while ((CurrentDescriptor = ArcGetMemoryDescriptor(CurrentDescriptor)) != NULL) {
            BlLog((activeTargets,
                   "Descriptor %8x:  Type %8x  Base %8x  Pages %8x",
                   CurrentDescriptor,
                   (USHORT)(CurrentDescriptor->MemoryType),
                   CurrentDescriptor->BasePage,
                   CurrentDescriptor->PageCount));
        }

        //BlLog((activeTargets,"***************************"));

        if ((Targets & LOG_WAIT) != 0) {
            BlLogWait( Targets );
        }
    }

    return;
}

VOID
BlLogMemoryDescriptors (
    ULONG Targets
    )
{
    PLIST_ENTRY CurrentLink;
    PMEMORY_ALLOCATION_DESCRIPTOR CurrentDescriptor;
    ULONG Index;
    ULONG ExpectedIndex;
    ULONG ExpectedBase;
    ULONG FoundIndex = 0;
    PMEMORY_ALLOCATION_DESCRIPTOR FoundDescriptor;
    TYPE_OF_MEMORY LastType;
    ULONG FreeBlocks = 0;
    ULONG FreePages = 0;
    ULONG LargestFree = 0;

    ULONG activeTargets;

    activeTargets = Targets & BlLogActiveTargets;

    if (activeTargets != 0) {

        BlLog((activeTargets,"***** System Memory List *****"));

        ExpectedIndex = 0;
        ExpectedBase = 0;
        LastType = (ULONG)-1;

        do {
            Index = 0;
            FoundDescriptor = NULL;
            CurrentLink = BlLoaderBlock->MemoryDescriptorListHead.Flink;

            while (CurrentLink != &BlLoaderBlock->MemoryDescriptorListHead) {

                CurrentDescriptor = (PMEMORY_ALLOCATION_DESCRIPTOR)CurrentLink;
                if (CurrentDescriptor->BasePage == ExpectedBase) {
                    if ((FoundDescriptor != NULL) && (FoundDescriptor->BasePage == ExpectedBase)) {
                        BlLog((activeTargets,
                               "ACK! Found multiple descriptors with base %x: %x and %x",
                               ExpectedBase,
                               FoundDescriptor,
                               CurrentDescriptor));
                    } else {
                        FoundDescriptor = CurrentDescriptor;
                        FoundIndex = Index;
                    }
                } else if (CurrentDescriptor->BasePage > ExpectedBase) {
                    if ((FoundDescriptor == NULL) ||
                        (CurrentDescriptor->BasePage < FoundDescriptor->BasePage)) {
                        FoundDescriptor = CurrentDescriptor;
                        FoundIndex = Index;
                    }
                }

                CurrentLink = CurrentLink->Flink;
                Index++;
            }

            if (FoundDescriptor != NULL) {

                if (FoundDescriptor->BasePage != ExpectedBase) {
                    BlLog((activeTargets,
                           "     ACK! MISSING MEMORY! ACK!  Base %8x  Pages %8x",
                           ExpectedBase,
                           FoundDescriptor->BasePage - ExpectedBase));
                }
                BlLog((activeTargets,
                       "%c%c%2d Descriptor %8x:  Type %8x  Base %8x  Pages %8x",
                       FoundDescriptor->MemoryType == LastType ? '^' : ' ',
                       FoundIndex == ExpectedIndex ? ' ' : '*',
                       FoundIndex,
                       FoundDescriptor,
                       (USHORT)(FoundDescriptor->MemoryType),
                       FoundDescriptor->BasePage,
                       FoundDescriptor->PageCount));

                if (FoundIndex == ExpectedIndex) {
                    ExpectedIndex++;
                }
                ExpectedBase = FoundDescriptor->BasePage + FoundDescriptor->PageCount;

                LastType = FoundDescriptor->MemoryType;
                if (LastType != MemoryFree) {
                    LastType = (ULONG)-1;
                } else {
                    FreeBlocks++;
                    FreePages += FoundDescriptor->PageCount;
                    if (FoundDescriptor->PageCount > LargestFree) {
                        LargestFree = FoundDescriptor->PageCount;
                    }
                }
            }

        } while ( FoundDescriptor != NULL );

        BlLog((activeTargets,
               "Total free blocks %2d, free pages %4x, largest free %4x",
               FreeBlocks,
               FreePages,
               LargestFree));

        //BlLog((activeTargets,"******************************"));

        if ((Targets & LOG_WAIT) != 0) {
            BlLogWait( Targets );
        }
    }

    return;
}

VOID
BlLogWaitForKeystroke (
    VOID
    )
{
    UCHAR Key=0;
    ULONG Count;

    if ((BlLogActiveTargets & LOG_DISPLAY) != 0) {
        do {
            if (ArcGetReadStatus(ARC_CONSOLE_INPUT) == ESUCCESS) {
                ArcRead(ARC_CONSOLE_INPUT,
                        &Key,
                        sizeof(Key),
                        &Count);
                break;
            }
        } while ( TRUE );
    }

    return;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blio.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blio.c

Abstract:

    This module contains the code that implements the switch function for
    I/O operations between then operating system loader, the target file
    system, and the target device.

Author:

    David N. Cutler (davec) 10-May-1991

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"


//
// Define file table.
//
BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

#if DBG
ULONG BlFilesOpened = 0;
#endif

#ifdef CACHE_DEVINFO

//
// Device close notification routines, are registered by the file system 
// which are interested in device close events. This is primarily used for
// invalidating the internal cache, which the file system maintains
// using DeviceId as one of the keys
//
PARC_DEVICE_CLOSE_NOTIFICATION  DeviceCloseNotify[MAX_DEVICE_CLOSE_NOTIFICATION_SIZE] = {0};

//
// Device to filesystem cache table
//
DEVICE_TO_FILESYS   DeviceFSCache[BL_FILE_TABLE_SIZE];

ARC_STATUS
ArcCacheClose(
    IN ULONG DeviceId
    )
/*++

Routine Description:

    This routine invalidates the file system information
    cached for the given device ID.

Arguments:

    DeviceId : Device to close

Return Value:

    ESUCCESS is returned if the close is successful. Otherwise,
    return an unsuccessful status.

--*/
{
  ULONG Index;

  //
  // Notify all the registered file system about the device close
  //
  for (Index = 0; Index < MAX_DEVICE_CLOSE_NOTIFICATION_SIZE; Index++) {
    if (DeviceCloseNotify[Index]) {
        (DeviceCloseNotify[Index])(DeviceId);
    }
  }

  //
  // Update device to file system cache
  //

  for (Index = 0; Index < BL_FILE_TABLE_SIZE; Index++) {
    if (DeviceFSCache[Index].DeviceId == DeviceId){
      DeviceFSCache[Index].DeviceId = UNINITIALIZED_DEVICE_ID;
    }
  }    

  return ((FIRMWARE_VECTOR_BLOCK->CloseRoutine)(DeviceId));
}


ARC_STATUS
ArcRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    )
{
    ARC_STATUS  Status = EINVAL;
    
    if (FlushRoutine) {
        ULONG   Index;

        Status = ENOENT;

        for (Index=0; Index < MAX_DEVICE_CLOSE_NOTIFICATION_SIZE; Index++) {
            if (!DeviceCloseNotify[Index]) {
                DeviceCloseNotify[Index] = FlushRoutine;                
                Status = ESUCCESS;
                
                break;
            }                
        }
    }

    return Status;
}

ARC_STATUS
ArcDeRegisterForDeviceClose(
    PARC_DEVICE_CLOSE_NOTIFICATION FlushRoutine
    )
{
    ARC_STATUS  Status = EINVAL;
    
    if (FlushRoutine) {
        ULONG   Index;

        Status = ENOENT;

        for (Index=0; Index < MAX_DEVICE_CLOSE_NOTIFICATION_SIZE; Index++) {
            if (DeviceCloseNotify[Index] == FlushRoutine) {
                DeviceCloseNotify[Index] = NULL;
                Status = ESUCCESS;

                break;
            }                
        }
    }

    return Status;
}


#endif // CACHE_DEVINFO


ARC_STATUS
BlIoInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the file table used by the OS loader and
    initializes the boot loader filesystems.

Arguments:

    None.

Return Value:

    ESUCCESS is returned if the initialization is successful. Otherwise,
    return an unsuccessful status.

--*/

{

    ULONG Index;
    ARC_STATUS Status;

#ifdef CACHE_DEVINFO

    RtlZeroMemory(DeviceCloseNotify, sizeof(DeviceCloseNotify));
    
#endif

    //
    // Initialize the file table.
    //
    for (Index = 0; Index < BL_FILE_TABLE_SIZE; Index += 1) {
        BlFileTable[Index].Flags.Open = 0;
        BlFileTable[Index].StructureContext = NULL;

#ifdef CACHE_DEVINFO
        DeviceFSCache[Index].DeviceId = UNINITIALIZED_DEVICE_ID;
        DeviceFSCache[Index].Context = NULL;
        DeviceFSCache[Index].DevMethods = NULL;
#endif // for CACHE_DEVINFO       
    }

    if((Status = NetInitialize()) != ESUCCESS) {
        return Status;
    }

    if((Status = FatInitialize()) != ESUCCESS) {
        return Status;
    }

    if((Status = NtfsInitialize()) != ESUCCESS) {
        return Status;
    }

#ifndef DONT_USE_UDF
    if((Status = UDFSInitialize()) != ESUCCESS) {
        return Status;
    }
#endif

    if((Status = CdfsInitialize()) != ESUCCESS) {
        return Status;
    }

    return ESUCCESS;
}


PBOOTFS_INFO
BlGetFsInfo(
    IN ULONG DeviceId
    )

/*++

Routine Description:

    Returns filesystem information for the filesystem on the specified device

Arguments:

    FileId - Supplies the file table index of the device

Return Value:

    PBOOTFS_INFO - Pointer to the BOOTFS_INFO structure for the filesystem

    NULL - unknown filesystem

--*/

{
    FS_STRUCTURE_CONTEXT FsStructure;
    PBL_DEVICE_ENTRY_TABLE Table;

    if ((Table = IsNetFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    if ((Table = IsFatFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    if ((Table = IsNtfsFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    if ((Table = IsCdfsFileStructure(DeviceId, &FsStructure)) != NULL) {
        return(Table->BootFsInfo);
    }

    return(NULL);
}

ARC_STATUS
BlClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This function closes a file or a device that is open.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    If the specified file is open, then a close is attempted and
    the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{
    //
    // If the file is open, then attempt to close it. Otherwise return an
    // access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {

        return (BlFileTable[FileId].DeviceEntryTable->Close)(FileId);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlMount (
    IN PCHAR MountPath,
    IN MOUNT_OPERATION Operation
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    UNREFERENCED_PARAMETER(MountPath);
    UNREFERENCED_PARAMETER(Operation);

    return ESUCCESS;
}


ARC_STATUS
_BlOpen (
    IN ULONG DeviceId,
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    This function opens a file on the specified device. The type of file
    system is automatically recognized.

Arguments:

    DeviceId - Supplies the file table index of the device.

    OpenPath - Supplies a pointer to the name of the file to be opened.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that receives the file
        table index of the open file.

Return Value:

    If a free file table entry is available and the file structure on
    the specified device is recognized, then an open is attempted and
    the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{
    ULONG Index;
    FS_STRUCTURE_CONTEXT FsStructureTemp;
    ULONG ContextSize;
    ARC_STATUS Status;

#ifdef CACHE_DEVINFO

    ULONG   CacheIndex;

    for (CacheIndex = 0; CacheIndex < BL_FILE_TABLE_SIZE; CacheIndex++) {
        if (DeviceFSCache[CacheIndex].DeviceId == DeviceId){
            break;
        }
    }

      
#endif // for CACHE_DEVINFO 
        
    //
    // Search for a free file table entry.
    //
    for (Index = 0; Index < BL_FILE_TABLE_SIZE; Index += 1) {
        if (BlFileTable[Index].Flags.Open == 0) {     
#ifdef CACHE_DEVINFO        
            if (CacheIndex >= BL_FILE_TABLE_SIZE) {
#endif // for CACHE_DEVINFO

                //
                // Attempt to recognize the file system on the specified
                // device. If no one recognizes it then return an unsuccessful
                // status.
                //
                if ((BlFileTable[Index].DeviceEntryTable =
                     IsNetFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                    ContextSize = sizeof(NET_STRUCTURE_CONTEXT);

                } else if ((BlFileTable[Index].DeviceEntryTable =
                            IsFatFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                    ContextSize = sizeof(FAT_STRUCTURE_CONTEXT);

                } else if ((BlFileTable[Index].DeviceEntryTable =
                            IsNtfsFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                    ContextSize = sizeof(NTFS_STRUCTURE_CONTEXT);
#ifndef DONT_USE_UDF
                } else if ((BlFileTable[Index].DeviceEntryTable =
                            IsUDFSFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                    ContextSize = sizeof(UDFS_STRUCTURE_CONTEXT);
#endif                
#if defined(ELTORITO)
                    //
                    // This must go before the check for Cdfs; otherwise Cdfs will be detected.
                    // Since BIOS calls already set up to use EDDS, reads will succeed, and checks
                    // against ISO will succeed.  We check El Torito-specific fields here as well as ISO
                    //
                } else if ((BlFileTable[Index].DeviceEntryTable =
                            IsEtfsFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                    ContextSize = sizeof(ETFS_STRUCTURE_CONTEXT);
#endif
                } else if ((BlFileTable[Index].DeviceEntryTable =
                            IsCdfsFileStructure(DeviceId, &FsStructureTemp)) != NULL) {
                    ContextSize = sizeof(CDFS_STRUCTURE_CONTEXT);

                } else {
                    return EACCES;
                }


#ifndef CACHE_DEVINFO

                //
                // Cut down on the amount of heap we use by attempting to reuse
                // the fs structure context instead of always allocating a
                // new one. The NTFS structure context is over 4K; the FAT one
                // is almost 2K. In the setup case we're loading dozens of files.   
                // Add in compression, where diamond may open each file multiple
                // times, and we waste a lot of heap.
                //
                if(BlFileTable[Index].StructureContext == NULL) {
                    BlFileTable[Index].StructureContext = BlAllocateHeap(sizeof(FS_STRUCTURE_CONTEXT));
                    if(BlFileTable[Index].StructureContext == NULL) {
                        return ENOMEM;
                    }

                    RtlZeroMemory(BlFileTable[Index].StructureContext, sizeof(FS_STRUCTURE_CONTEXT));
                }

                RtlCopyMemory(
                    BlFileTable[Index].StructureContext,
                    &FsStructureTemp,
                    ContextSize
                    );

#else
                //
                // save the collected info in cache for future use
                //
                for (CacheIndex = 0; CacheIndex < BL_FILE_TABLE_SIZE; CacheIndex++) {
                    if (DeviceFSCache[CacheIndex].DeviceId == UNINITIALIZED_DEVICE_ID){
                        PVOID Context = DeviceFSCache[CacheIndex].Context;

                        DeviceFSCache[CacheIndex].DeviceId = DeviceId;

                        //
                        // Cut down on the amount of heap we use by attempting to reuse
                        // the fs structure context instead of always allocating a
                        // new one. The NTFS structure context is over 4K; the FAT one
                        // is almost 2K. In the setup case we're loading dozens of files.
                        // Add in compression, where diamond may open each file multiple
                        // times, and we waste a lot of heap.
                        //
                        if(Context == NULL) {
                            Context = BlAllocateHeap(sizeof(FS_STRUCTURE_CONTEXT));

                            if(Context == NULL) {
                                DeviceFSCache[CacheIndex].DeviceId = UNINITIALIZED_DEVICE_ID;
                                return ENOMEM;
                            }

                            RtlZeroMemory(Context, sizeof(FS_STRUCTURE_CONTEXT));
                            DeviceFSCache[CacheIndex].Context = Context;
                        }

                        RtlCopyMemory(Context,
                                      &FsStructureTemp, 
                                      ContextSize);

                        BlFileTable[Index].StructureContext = Context;              

                        //
                        // save the device table from the filetable entry
                        //
                        DeviceFSCache[CacheIndex].DevMethods = BlFileTable[Index].DeviceEntryTable;                

                        break;
                    }
                }

                if (CacheIndex >= BL_FILE_TABLE_SIZE)
                    return ENOSPC;

            } else {
#if 0
                {
                    char Msg[128] = {0};

                    BlPositionCursor(1, 5);
                    sprintf(Msg,
                            "Using %d cached info %p, %p for device %d, %s",
                            CacheIndex,
                            DeviceFSCache[CacheIndex].Context,
                            DeviceFSCache[CacheIndex].DevMethods,
                            DeviceFSCache[CacheIndex].DeviceId,
                            OpenPath);

                    BlPrint("                                                        ");
                    BlPositionCursor(1, 5);
                    BlPrint(Msg);
                }
#endif                         
                
                //
                // Reuse the already cached entry
                //
                BlFileTable[Index].DeviceEntryTable = DeviceFSCache[CacheIndex].DevMethods;
                BlFileTable[Index].StructureContext = DeviceFSCache[CacheIndex].Context;
            }                 

#endif  // for ! CACHE_DEVINFO

            //
            // Someone has mounted the volume so now attempt to open the file.
            //
            *FileId = Index;
            BlFileTable[Index].DeviceId = DeviceId;


            Status = EBADF;
#if DBG
            //
            // Check and see if a user wants to replace this binary
            // via a transfer through the kernel debugger.  If this
            // fails just continue on with the existing file.
            //
            if( BdDebuggerEnabled ) {

                Status = BdPullRemoteFile( OpenPath,
                                           FILE_ATTRIBUTE_NORMAL,
                                           FILE_OVERWRITE_IF,
                                           FILE_SYNCHRONOUS_IO_NONALERT,
                                           *FileId );
                if( Status == ESUCCESS ) {
                    DbgPrint( "BlLoadImageEx: Pulled %s from Kernel Debugger\r\n", OpenPath );
                
                    //
                    // Make absolutely sure we don't reuse this device filesystem cache
                    // entry because we've piggybacked on the net filesystem to bring
                    // the kdfile over the serial point.  That means we really don't
                    // want to reuse this entry unless we're booting off the net, in which
                    // case we'll take the perf hit (slight) on DBG builds.
                    //
#ifdef CACHE_DEVINFO
                    DeviceFSCache[*FileId].DeviceId = UNINITIALIZED_DEVICE_ID;                
#endif                
                }
            }
#endif


            if( Status != ESUCCESS ) {
                Status = (BlFileTable[Index].DeviceEntryTable->Open)(OpenPath,
                                                                     OpenMode,
                                                                     FileId);
            }

            return(Status);
        }
    }

    //
    // No free file table entry could be found.
    //

    return EACCES;
}

ARC_STATUS
BlOpen (
    IN ULONG DeviceId,
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    )

/*++

Routine Description:

    Wrapper routine for BlOpen that attempts to locate the compressed
    form of a filename before trying to locate the filename itself.

    Callers need not know or care that a file x.exe actually exists
    as a compressed file x.ex_. If the file is being opened for
    read-only access and the decompressor indicates that it wants
    to try locating the compressed form of the file, we transparently
    locate that one instead of the one requested.

Arguments:

    Same as _BlOpen().

Return Value:

    Same as _BlOpen().

--*/

{
    CHAR CompressedName[256];
    ARC_STATUS Status;
   
    if((OpenMode == ArcOpenReadOnly) && DecompGenerateCompressedName(OpenPath,CompressedName)) {
        //
        // Attempt to locate the compressed form of the filename.
        //
        Status = _BlOpen(DeviceId,CompressedName,OpenMode,FileId);
        if(Status == ESUCCESS) {

            Status = DecompPrepareToReadCompressedFile(CompressedName,*FileId);

            if(Status == (ARC_STATUS)(-1)) {
                //
                // This is a special status indicating that the file is not
                // to be processed for decompression. This typically happens
                // when the decompressor opens the file to read the compressed
                // data out of it.
                //
                Status = ESUCCESS;
#if DBG                
                BlFilesOpened++;
#endif                
            }

            return(Status);
        }
    }

    Status = (_BlOpen(DeviceId,OpenPath,OpenMode,FileId));

#if DBG
    if (Status == ESUCCESS)
        BlFilesOpened++;
#endif      

    return Status;
}

ARC_STATUS
BlRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:

    This function reads from a file or a device that is open.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Count - Supplies a pointer to a variable that receives the number of
        bytes actually transfered.

Return Value:

    If the specified file is open for read, then a read is attempted
    and the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{

    //
    // If the file is open for read, then attempt to read from it. Otherwise
    // return an access error.
    //

    if ((BlFileTable[FileId].Flags.Open == 1) &&
        (BlFileTable[FileId].Flags.Read == 1)) {
        return (BlFileTable[FileId].DeviceEntryTable->Read)(FileId,
                                                            Buffer,
                                                            Length,
                                                            Count);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlReadAtOffset(
    IN ULONG FileId,
    IN ULONG Offset,
    IN ULONG Length,
    OUT PVOID Data
    )
/*++

Routine Description:

    This routine seeks to the proper place in FileId and extracts Length bytes of data into
    Data.

Arguments:

    FileId - Supplies the file id where read operations are to be performed.

    Offset - The absolute byte offset to start reading at.

    Length - The number of bytes to read.

    Data - Buffer to hold the read results.

--*/
{
    ARC_STATUS Status;
    LARGE_INTEGER LargeOffset;
    ULONG Count;

    LargeOffset.HighPart = 0;
    LargeOffset.LowPart = Offset;
    Status = BlSeek(FileId, &LargeOffset, SeekAbsolute);

    if (Status != ESUCCESS) {
        return Status;
    }

    Status = BlRead(FileId, Data, Length, &Count);

    if ((Status == ESUCCESS) && (Count != Length)) {
        return EINVAL;
    }

    return Status;
}


ARC_STATUS
BlGetReadStatus (
    IN ULONG FileId
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    UNREFERENCED_PARAMETER( FileId );

    return ESUCCESS;
}

ARC_STATUS
BlSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:


Arguments:


Return Value:

    If the specified file is open, then a seek is attempted and
    the status of the operation is returned. Otherwise, return an
    unsuccessful status.

--*/

{

    //
    // If the file is open, then attempt to seek on it. Otherwise return an
    // access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {
        return (BlFileTable[FileId].DeviceEntryTable->Seek)(FileId,
                                                            Offset,
                                                            SeekMode);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{

    //
    // If the file is open for write, then attempt to write to it. Otherwise
    // return an access error.
    //

    if ((BlFileTable[FileId].Flags.Open == 1) &&
        (BlFileTable[FileId].Flags.Write == 1)) {
        return (BlFileTable[FileId].DeviceEntryTable->Write)(FileId,
                                                             Buffer,
                                                             Length,
                                                             Count);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlGetFileInformation (
    IN ULONG FileId,
    IN PFILE_INFORMATION FileInformation
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    //
    // If the file is open, then attempt to get file information. Otherwise
    // return an access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {
        return (BlFileTable[FileId].DeviceEntryTable->GetFileInformation)(FileId,
                                                                          FileInformation);

    } else {
        return EACCES;
    }
}

ARC_STATUS
BlSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/

{
    //
    // If the file is open, then attempt to Set file information. Otherwise
    // return an access error.
    //

    if (BlFileTable[FileId].Flags.Open == 1) {
        return (BlFileTable[FileId].DeviceEntryTable->SetFileInformation)(FileId,
                                                                          AttributeFlags,
                                                                          AttributeMask);

    } else {
        return EACCES;
    }
}


ARC_STATUS
BlRename(
    IN ULONG FileId,
    IN PCHAR NewName
    )

/*++

Routine Description:

    Rename an open file or directory.

Arguments:

    FileId - supplies a handle to an open file or directory.  The file
        need not be open for write access.

    NewName - New name to give the file or directory (filename part only).

Return Value:

    Status indicating result of the operation.

--*/

{
    if(BlFileTable[FileId].Flags.Open == 1) {
        return(BlFileTable[FileId].DeviceEntryTable->Rename(FileId,
                                                            NewName
                                                           )
              );
    } else {
        return(EACCES);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blrange.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blrange.c

Abstract:

    This module implements ranges and rangelists. These can be used
    to keep track of cached ranges of a disk for instance.

Author:

    Cenk Ergan (cenke) 11-Jan-2000

Revision History:

--*/

#include "blrange.h"

//
// Range function definitions.
//

VOID
BlRangeListInitialize (
    PBLCRANGE_LIST pRangeList,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine,
    OPTIONAL PBLCRANGE_FREE_ROUTINE pFreeRoutine
    )
/*++

Routine Description:

    This routine initializes the range list whose address is passed in
    so it can be used by the other range functions.

Arguments:

    pRangeList - Address of the range list to initialize.

    pMergeRoutine - Optional routine to merge Data fields of merged
        range entries. See PBLCRANGE_MERGE_ROUTINE description.

    pFreeRoutine - Optional routine to free the memory for an entry
        that was merged into another. See PBLCRANGE_FREE_ROUTINE desc.

Return Value:

    None. [Always successful]

--*/
{
    InitializeListHead(&pRangeList->Head);
    pRangeList->NumEntries = 0;
    pRangeList->MergeRoutine = pMergeRoutine;
    pRangeList->FreeRoutine = pFreeRoutine;
}

BOOLEAN
BlRangeListAddRange (
    PBLCRANGE_LIST  pRangeList,
    PBLCRANGE_ENTRY pRangeEntry
    )
/*++

Routine Description:

    This routine adds pRangeEntry to pRangeList only if it does not
    have any overlap with other ranges in the list and its size > 0;
    If merging becomes possible it is attempted. It does not have to
    be successful.

Arguments:

    pRangeList - Address of the range list to add range to.

    pRangeEntry - Range to add to pRangeList.

Return Value:

    TRUE if addition is successful [even if merging was possible but failed]
    FALSE if not [e.g. overlap/collusion]

--*/
{
    PBLCRANGE_ENTRY pCurEntry = NULL;
    PBLCRANGE_ENTRY pLastEntry = NULL;
    LIST_ENTRY *pHead, *pNext;
    
    //
    // Handle special empty range case.
    //

    if (pRangeEntry->Range.Start == pRangeEntry->Range.End)
        return TRUE;

    //
    // Walk through the ranges in the sorted list checking for
    // overlaps and looking for the right place for us.
    //
    
    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
        
        //
        // Check if we are completely before this entry. 
        //

        if (pRangeEntry->Range.End <= pCurEntry->Range.Start)
        {
            //
            // Insert the new entry at its place.
            //

            InsertTailList(pNext, &pRangeEntry->Link);
            pRangeList->NumEntries++;

            //
            // Check if merging is possible.
            //
            
            if (pLastEntry && (pRangeEntry->Range.Start == pLastEntry->Range.End))
            {
                BlRangeListMergeRangeEntries(
                    pRangeList,
                    pRangeEntry,
                    pLastEntry
                    );
            }

            if (pRangeEntry->Range.End == pCurEntry->Range.Start)
            {
                BlRangeListMergeRangeEntries(
                    pRangeList,
                    pRangeEntry,
                    pCurEntry
                    );
            }

            return TRUE;
        }
        
        //
        // Check if we are not completely after this entry.
        //

        if (pRangeEntry->Range.Start < pCurEntry->Range.End)
        {
            //
            // We have an overlapping range.
            //

            return FALSE;
        }
        
        //
        // We come after this entry.
        //

        pLastEntry = pCurEntry;
        pNext = pNext->Flink;
    }  

    //
    // We come after the last entry [if there is one], i.e. before the head.
    // Insert the new entry and check if merging is possible.
    //

    InsertTailList(pHead, &pRangeEntry->Link);
    pRangeList->NumEntries++;

    if (pLastEntry && (pRangeEntry->Range.Start == pLastEntry->Range.End))
    {
        BlRangeListMergeRangeEntries(
            pRangeList,
            pRangeEntry,
            pLastEntry
            );
    }

    return TRUE;
}

BOOLEAN
BlRangeListFindOverlaps (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE_ENTRY *pOverlapsBuffer,
    ULONG OverlapsBufferSize,
    OUT ULONG *pNumOverlaps
    )
/*++

Routine Description:

    This routine will find ranges in pRangeList that overlap with
    pRange and put pointers to them into pOverlapsBuffer one after the
    other. If all overlapping ranges cannot be copied because
    pOverlapsBuffer is NULL or OverlapsBufferSize is 0 or not enough,
    the function will return FALSE and but still put the number of
    overlapping ranges in pNumOverlaps. You can calculate the required
    buffer size from this.

Arguments:

    pRangeList - Address of the range list to search for overlaps.

    pRange - We will look for range entries that overlap with pRange.

    pOverlapsBuffer - Pointer to buffer we can fill with pointers to
        overlapping ranges.

    OverlapsBufferSize - Size up to which we can fill pOverlapsBuffer.

    pNumOverlaps - Number of overlapping ranges will always be put
        here.

Return Value:

    TRUE if successful, FALSE if not. 

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    LIST_ENTRY *pHead, *pNext;
    ULONG NumOverlaps = 0;
    ULONG RequiredOverlapsBufferSize = 0;

    //
    // Handle special empty range case.
    //

    if (pRange->Start == pRange->End)
    {
        *pNumOverlaps = NumOverlaps;
        return (BOOLEAN)(pOverlapsBuffer != NULL);
    }

    //
    // Walk through the ranges in the sorted list and copy over ones
    // that overlap into callers buffer if there is enough space.
    //

    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
        
        if ((pRange->End > pCurEntry->Range.Start) &&
            (pRange->Start < pCurEntry->Range.End))
        {
            //
            // This entry overlaps.
            //

            RequiredOverlapsBufferSize += sizeof(PBLCRANGE_ENTRY);
            if (pOverlapsBuffer && 
                (OverlapsBufferSize >= RequiredOverlapsBufferSize))
            {
                pOverlapsBuffer[NumOverlaps] = pCurEntry;
            }
            NumOverlaps++;
        }

        pNext = pNext->Flink;
    }

    *pNumOverlaps = NumOverlaps;
    
    return ((BOOLEAN)(pOverlapsBuffer && 
                      (OverlapsBufferSize >= RequiredOverlapsBufferSize)));
}


BOOLEAN
BlRangeListFindDistinctRanges (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange,
    PBLCRANGE pDistinctRanges,
    ULONG BufferSize,
    OUT ULONG *pNumRanges
    )
/*++

Routine Description:

    This routine will look at ranges in pRangeList that overlap with
    pRange and extract the overlaps from pRange, thus keeping track of
    those ranges that are distinct. If all distinct ranges cannot be
    put into pDistinctRanges buffer because pDistinctRanges is NULL or
    BufferSize is 0 or not enough, the function will return FALSE and
    but still put the number of resulting distinct ranges in
    pNumRanges. You can calculate the required buffer size from
    this.

Arguments:

    pRangeList - Address of the range list.

    pRange - We will extract distinct ranges in pRange that do not 
        overlap with other ranges in pRangeList.

    pDistinctRanges - Pointer to buffer we can fill with distinct
        ranges.

    BufferSize - Size up to which we can fill pDistinctRanges buffer.

    pNumRanges - Number of resulting distinct ranges will always be
        put here.

Return Value:

    TRUE if successful, FALSE if not. 

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    BLCRANGE RemainingRange = *pRange;
    ULONGLONG OverlapStart;
    ULONGLONG OverlapEnd;
    LIST_ENTRY *pHead, *pNext;
    ULONG NumRanges = 0;
    ULONG RequiredBufferSize = 0;

    if (pRange->Start == pRange->End)
    {
        *pNumRanges = NumRanges;
        return (BOOLEAN)(pDistinctRanges != NULL);
    }
    
    //
    // Looking at each range in the sorted list, we carve out overlap
    // and distinct zones from the start of our range.
    //

    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);

        //
        // Is there still anything remaining from the range that we
        // have not carved out as overlap or distinct?
        //

        if (RemainingRange.Start >= RemainingRange.End)
            break;

        //
        // There are three possibilities:
        //

        //
        // 1. Is the range completely before the current range?
        //

        if (RemainingRange.End <= pCurEntry->Range.Start)
        {
            //
            // The whole range is distinct.
            //

            RequiredBufferSize += sizeof(BLCRANGE);
            if (pDistinctRanges && (RequiredBufferSize <= BufferSize))
            {
                pDistinctRanges[NumRanges].Start = RemainingRange.Start;
                pDistinctRanges[NumRanges].End = RemainingRange.End;
            }
            NumRanges++;
            
            RemainingRange.Start = RemainingRange.End;
        }
        
        //
        // 2. Are we completely beyond the current range?
        //

        if (RemainingRange.Start >= pCurEntry->Range.End)
        {
            //
            // We cannot carve out anything from the remaining range.
            // Fall through to processing the next entry.
            //
        }

        //
        // 3. Is the remaining range overlaps with the current range.
        //

        if ((RemainingRange.End > pCurEntry->Range.Start) &&
            (RemainingRange.Start < pCurEntry->Range.End))
        {
            OverlapStart = BLRGMAX(RemainingRange.Start,
                                   pCurEntry->Range.Start); 
            OverlapEnd = BLRGMIN(RemainingRange.End,
                                 pCurEntry->Range.End);
            
            if (OverlapStart > pRange->Start)
            {
                //
                // There is a distinct region before the overlap
                //
                RequiredBufferSize += sizeof(BLCRANGE);
                if (pDistinctRanges && (RequiredBufferSize <= BufferSize))
                {
                    pDistinctRanges[NumRanges].Start = RemainingRange.Start;
                    pDistinctRanges[NumRanges].End = OverlapStart;
                }
                NumRanges++;
            }

            RemainingRange.Start = OverlapEnd;
        }     

        pNext = pNext->Flink;
    }

    //
    // The remaining range (if there is any) is also distinct.
    //

    if (RemainingRange.Start < RemainingRange.End)
    {
        RequiredBufferSize += sizeof(BLCRANGE);
        if (pDistinctRanges && (RequiredBufferSize <= BufferSize))
        {
            pDistinctRanges[NumRanges].Start = RemainingRange.Start;
            pDistinctRanges[NumRanges].End = RemainingRange.End;
        }
        NumRanges++;
    }
    
    *pNumRanges = NumRanges;

    return ((BOOLEAN)(pDistinctRanges &&
                      RequiredBufferSize <= BufferSize));
}

BOOLEAN
BlRangeListMergeRangeEntries (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    )
/*++

Routine Description:

    Merges SrcEntry and DestEntry range entries into DestEntry by
    calling BlRangeEntryMerge. If successful it tries to remove
    pSrcEntry from the range list it is in and free its memory by
    calling the FreeRoutine specified on the list.

Arguments:

    pRangeList - Range list pDestEntry and pSrcEntry belong to.

    pDestEntry - Range entry that we will merge into.

    pSrcEntry - Range entry that will be merged into pDestEntry,
        removed from its list and free'ed.

Return Value:

    TRUE if successful, FALSE if not. The success is mainly determined
    by calls to a MergeRoutine if specified on the list.

--*/
{

    if(BlRangeEntryMerge(pDestEntry,
                         pSrcEntry,
                         pRangeList->MergeRoutine))
    {
        //
        // Remove pSrcEntry from the list since it is merged into
        // pDestEntry now.
        // 

        pRangeList->NumEntries--;
        RemoveEntryList(&pSrcEntry->Link);

        //
        // Free the removed entry.
        //

        if (pRangeList->FreeRoutine) pRangeList->FreeRoutine(pSrcEntry);

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOLEAN
BlRangeEntryMerge (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry,
    OPTIONAL PBLCRANGE_MERGE_ROUTINE pMergeRoutine
    )
/*++

Routine Description:

    Merges SrcEntry and DestEntry range entries into DestEntry. It
    uses pMergeRoutine if specified to merge the user's Data field of
    the range entries.

Arguments:

    pDestEntry - Range entry that we will merge into
  
    pSrcEntry - Range entry that will be merged into pDestEntry

    pMergeRoutine - Optional routine to merge Data fields of
        merged range entries. See PBLCRANGE_MERGE_ROUTINE description.

Return Value:

    TRUE if successful, FALSE if not. The success is mainly
    determined by calls to the pMergeRoutine if specified.

--*/
{
    BLCRANGE_ENTRY TempDest = *pDestEntry;
    BOOLEAN RetVal = TRUE;

    if (pMergeRoutine)
    {
        RetVal = pMergeRoutine(&TempDest, pSrcEntry);
    }
    
    if (RetVal)
    {
        TempDest.Range.Start = BLRGMIN(TempDest.Range.Start,
                                       pSrcEntry->Range.Start);
        TempDest.Range.End = BLRGMAX(TempDest.Range.End,
                                     pSrcEntry->Range.End);

        *pDestEntry = TempDest;
    }

    return RetVal;
}

VOID
BlRangeListRemoveRange (
    PBLCRANGE_LIST pRangeList,
    PBLCRANGE pRange
)
/*++

Routine Description:

    Find the ranges that overlap with pRange, remove them from the
    list and free them. It may be possible to reclaim non-overlapping
    parts of range entries by allowing the caller to specify a
    DivideRoutine in an _Ex version of this function. This function
    would be called for invalidating part of the cache, if the range
    list is being used for a disk cache.

Arguments:

    pRangeList - Range entry list we are removing range entries that
        overlap with pRange from.

    pRange - Range to remove from the range entry list.

Return Value:

    None.

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    LIST_ENTRY *pHead, *pNext;

    //
    // Handle special empty range case.
    //

    if (pRange->Start == pRange->End)
    {
        return;
    }
    
    //
    // Looking at each range in the list, remove the ones that overlap with
    // pRange even slightly.
    //

    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
        pNext = pNext->Flink;

        if ((pRange->End > pCurEntry->Range.Start) &&
            (pRange->Start < pCurEntry->Range.End))
        {
            pRangeList->NumEntries--;
            RemoveEntryList(&pCurEntry->Link);
            if (pRangeList->FreeRoutine) pRangeList->FreeRoutine(pCurEntry);
        }     
    }

    return;
}

VOID
BlRangeListRemoveAllRanges (
    PBLCRANGE_LIST pRangeList
    )
/*++

Routine Description:

    Remove all ranges from the list and free them. 

Arguments:

    pRangeList - Range entry list we are removing range entries that
        overlap with pRange from.

Return Value:

    None.

--*/
{
    PBLCRANGE_ENTRY pCurEntry;
    LIST_ENTRY *pHead, *pNext;
    
    pHead = &pRangeList->Head;
    pNext = pHead->Flink;
    while (pNext != pHead)
    {
        pCurEntry = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);

        pRangeList->NumEntries--;
        RemoveEntryList(&pCurEntry->Link);      
        if (pRangeList->FreeRoutine) pRangeList->FreeRoutine(pCurEntry);

        pNext = pNext->Flink;
    }

    return;
}

#ifdef BLRANGE_SELF_TEST

//
// In order to to test blrange implementation, define
// BLRANGE_SELF_TEST and call BlRangeSelfTest from you program passing
// in a function to output debug results.
//

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

//
// Keep MAX_RANDOM above 1000 or you may hit difficulties creating new
// entries.
//

#define MAX_RANDOM 10000

VOID
GetRandom_GetNewSeed(
    VOID
    )
{
    srand((unsigned)time(NULL));
}

ULONG
GetRandom(
    VOID
    )
{
    return (rand() * 10000 / RAND_MAX);
}

typedef 
int
(*PBLCRANGE_SELFTEST_FPRINTF_ROUTINE) (
    void *stream,
    const char *format,
    ...
    );

PBLCRANGE_SELFTEST_FPRINTF_ROUTINE g_fpTestPrintf = NULL;
VOID *g_pTestStream = NULL;

BOOLEAN
BlRangeSelfTest_MergeRoutine (
    PBLCRANGE_ENTRY pDestEntry,
    PBLCRANGE_ENTRY pSrcEntry
    )
{
    g_fpTestPrintf(g_pTestStream,
                   "  Merging RangeDest %I64u-%I64u RangeSrc %I64u-%I64u : ",
                   pDestEntry->Range.Start, 
                   pDestEntry->Range.End,
                   pSrcEntry->Range.Start, 
                   pSrcEntry->Range.End);
    
    if (GetRandom() < (MAX_RANDOM / 5))
    {
        g_fpTestPrintf(g_pTestStream,"FAIL\n");
        return FALSE;
    }
    else
    {
        g_fpTestPrintf(g_pTestStream,"SUCCESS\n");
        return TRUE;
    }
}

VOID
BlRangeSelfTest_FreeRoutine (
    PBLCRANGE_ENTRY pRangeEntry
    )
{
    g_fpTestPrintf(g_pTestStream,
                   "  Freeing range %I64u-%I64u \n",
                   pRangeEntry->Range.Start, 
                   pRangeEntry->Range.End);

    free(pRangeEntry);
}

BLCRANGE
BlRangeSelfTest_RandomRange(
    VOID
    )
{
    BLCRANGE RetRange;
    ULONG Rand1;
    ULONG Rand2;
    ULONGLONG Size;
    ULONG i;

    Rand1 = GetRandom();
    Rand2 = GetRandom();

    RetRange.Start = BLRGMIN(Rand1, Rand2);
    RetRange.End = BLRGMAX(Rand1, Rand2);

    //
    // Make sure that ranges are small and there are not just a couple
    // of big ones.
    //

    for (i = 0; i < 3; i++)
    {
        if ((Size = (RetRange.End - RetRange.Start)) > MAX_RANDOM / 20)
        {
            RetRange.Start += (Size / 2);
        }
        else
        {
            break;
        }
    }

    return RetRange;
}

PBLCRANGE_ENTRY
BlRangeSelfTest_CreateNewEntry(
    VOID
    )
{
    PBLCRANGE_ENTRY pNewEntry;
   
    pNewEntry = malloc(sizeof(BLCRANGE_ENTRY));

    if (pNewEntry) 
    {
        pNewEntry->Range = BlRangeSelfTest_RandomRange();
    }

    return pNewEntry;
}

VOID
BlRangeSelfTest_FreeEntry(
    PBLCRANGE_ENTRY pEntry
    )
{
    free(pEntry);
}

typedef enum _BLRANGE_OP_TYPE
{
    BLRANGE_OP_ADD_RANGE,
    BLRANGE_OP_ADD_MERGE_RANGE,
    BLRANGE_OP_REMOVE_RANGE,
    BLRANGE_OP_FIND_OVERLAP,
    BLRANGE_OP_FIND_DISTINCT,
    BLRANGE_OP_MAX_OP_NO, // Leave this at the end of the enumeration.
} BLRANGE_OP_TYPE;

VOID
BlRangeSelfTest(
    PBLCRANGE_SELFTEST_FPRINTF_ROUTINE TestOutFPrintf,
    PVOID TestOutStream,
    ULONG NumIterations
    )
/*++

Routine Description:

    Range routines self test routine.

Arguments:

    TestOutFPrintf - Pointer to a routine like fprintf that will be used to
        print the output.

    TestOutStream - Argument to be passed to fpPrintf as its first argument.

    NumIterations - Number of random operations to perform in this self test.

Return Value:

    None.

--*/
{
    BLCRANGE_LIST RangeList;
    ULONG Rand1;
    ULONG Rand2;
    BLCRANGE Range1;
    PBLCRANGE_ENTRY pEntry1;
    PBLCRANGE_ENTRY pEntry2;
    BLRANGE_OP_TYPE OpType;
    PLIST_ENTRY pHead;
    PLIST_ENTRY pNext;
    PBLCRANGE_ENTRY *pOverlaps;
    PBLCRANGE pDistinctRanges;
    ULONG BufSize;
    ULONG NumDistincts;
    ULONG NumOverlaps;
    ULONG RandEntryNo;
    
    //
    // Simulation Parameters.
    //
    
    ULONG StartNumRanges = 10;
    
    ULONG CurIterIdx;
    ULONG CurRangeIdx;
    ULONG CurEntryIdx;

    //
    // Set global output function and stream variable so merge/free etc.
    // routines can also output.
    //

    g_fpTestPrintf = TestOutFPrintf;
    g_pTestStream = TestOutStream;

    //
    // Set semi-random starting point for pseudorandom number generation.
    //
    
    GetRandom_GetNewSeed();


    //
    // Initialize the range list.
    //

    BlRangeListInitialize(&RangeList, 
                          BlRangeSelfTest_MergeRoutine,
                          BlRangeSelfTest_FreeRoutine);
    
    //
    // Try to add StartNumRanges random entries.
    //

    for(CurRangeIdx = 0; CurRangeIdx < StartNumRanges; CurRangeIdx++)
    {
        pEntry1 = BlRangeSelfTest_CreateNewEntry();
        
        if (!pEntry1) continue;
        
        g_fpTestPrintf(g_pTestStream,
                       "AddStartRange %I64u-%I64u : ",
                       pEntry1->Range.Start,
                       pEntry1->Range.End);
                       
        if (BlRangeListAddRange(&RangeList, pEntry1))
        {
            g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
        }
        else
        {
            g_fpTestPrintf(g_pTestStream, "FAILED\n");
            BlRangeSelfTest_FreeEntry(pEntry1);
        }
    }

    for(CurIterIdx = 0; CurIterIdx < NumIterations; CurIterIdx++)
    {
        //
        // Print out the current list.
        //

        g_fpTestPrintf(g_pTestStream, "List: ");
        pHead = &RangeList.Head;
        pNext = pHead->Flink;
        while (pNext != pHead)
        {
            pEntry1 = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
            
            g_fpTestPrintf(g_pTestStream, 
                           "%I64u-%I64u ", 
                           pEntry1->Range.Start,
                           pEntry1->Range.End);

            pNext = pNext->Flink;
        }
        g_fpTestPrintf(g_pTestStream, "\n");
        
    get_new_optype:
        OpType = GetRandom() % BLRANGE_OP_MAX_OP_NO;
        
        switch (OpType)
        {
        case BLRANGE_OP_ADD_RANGE:

            pEntry1 = BlRangeSelfTest_CreateNewEntry();
            g_fpTestPrintf(g_pTestStream,
                           "AddRange %I64u-%I64u : ",
                           pEntry1->Range.Start,
                           pEntry1->Range.End);
            
            if (BlRangeListAddRange(&RangeList, pEntry1))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAILED\n");
                BlRangeSelfTest_FreeEntry(pEntry1);
            }
            break;

        case BLRANGE_OP_ADD_MERGE_RANGE:
            
            RandEntryNo = GetRandom() * RangeList.NumEntries / MAX_RANDOM;
            
            pHead = &RangeList.Head;
            pNext = pHead->Flink;

            for (CurEntryIdx = 0; CurEntryIdx < RandEntryNo; CurEntryIdx++)
            {
                pNext = pNext->Flink;
            }
            
            if (pNext == pHead) goto get_new_optype;

            pEntry1 = CONTAINING_RECORD(pNext, BLCRANGE_ENTRY, Link);
            pEntry2 = BlRangeSelfTest_CreateNewEntry();

            if (GetRandom() > (MAX_RANDOM / 2))
            {
                pEntry2->Range.Start = pEntry1->Range.End;
                pEntry2->Range.End = pEntry2->Range.Start + 
                    (GetRandom() * (MAX_RANDOM - pEntry2->Range.Start)) / MAX_RANDOM;
            }
            else
            {
                pEntry2->Range.End = pEntry1->Range.Start;
                pEntry2->Range.Start = pEntry2->Range.End - 
                    (GetRandom() * pEntry2->Range.End) / MAX_RANDOM;
            }

            g_fpTestPrintf(g_pTestStream,
                           "MergeAddRange %I64u-%I64u : ",
                           pEntry2->Range.Start,
                           pEntry2->Range.End);
            
            if (BlRangeListAddRange(&RangeList, pEntry2))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAILED\n");
                BlRangeSelfTest_FreeEntry(pEntry2);
            }
            break;

        case BLRANGE_OP_REMOVE_RANGE:
            
            Range1 = BlRangeSelfTest_RandomRange();

            g_fpTestPrintf(g_pTestStream, 
                           "RemoveRange %I64u-%I64u\n",
                           Range1.Start,
                           Range1.End);

            BlRangeListRemoveRange(&RangeList, &Range1);

            break;

        case BLRANGE_OP_FIND_OVERLAP:

            Range1 = BlRangeSelfTest_RandomRange();

            g_fpTestPrintf(g_pTestStream, 
                           "FindOverlaps %I64u-%I64u : ",
                           Range1.Start,
                           Range1.End);

            BlRangeListFindOverlaps(&RangeList,
                                    &Range1,
                                    NULL,
                                    0,
                                    &NumOverlaps);

            g_fpTestPrintf(g_pTestStream, "%u Overlaps... ", NumOverlaps);

            BufSize = NumOverlaps * sizeof(PBLCRANGE_ENTRY);
            pOverlaps = malloc(BufSize);
                        
            if (!pOverlaps) goto get_new_optype;

            if (BlRangeListFindOverlaps(&RangeList,
                                        &Range1,
                                        pOverlaps,
                                        BufSize,
                                        &NumOverlaps) &&
                (BufSize == NumOverlaps * sizeof(PBLCRANGE_ENTRY)))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAIL\n");
                free(pOverlaps);
                break;
            }
          
            for (CurEntryIdx = 0; CurEntryIdx < NumOverlaps; CurEntryIdx++)
            {
                g_fpTestPrintf(g_pTestStream, 
                               "  %I64u-%I64u\n",
                               pOverlaps[CurEntryIdx]->Range.Start,
                               pOverlaps[CurEntryIdx]->Range.End);
            }

            free(pOverlaps);

            break;
            
        case BLRANGE_OP_FIND_DISTINCT:

            Range1 = BlRangeSelfTest_RandomRange();

            g_fpTestPrintf(g_pTestStream, 
                           "FindDistincts %I64u-%I64u : ",
                           Range1.Start,
                           Range1.End);

            BlRangeListFindDistinctRanges(&RangeList,
                                          &Range1,
                                          NULL,
                                          0,
                                          &NumDistincts);

            g_fpTestPrintf(g_pTestStream, "%u Distincts... ", NumDistincts);

            BufSize = NumDistincts * sizeof(BLCRANGE);
            pDistinctRanges = malloc(BufSize);
                        
            if (!pDistinctRanges) goto get_new_optype;

            if (BlRangeListFindDistinctRanges(&RangeList,
                                              &Range1,
                                              pDistinctRanges,
                                              BufSize,
                                              &NumDistincts) &&
                (BufSize == NumDistincts * sizeof(BLCRANGE)))
            {
                g_fpTestPrintf(g_pTestStream, "SUCCESS\n");
            }
            else
            {
                g_fpTestPrintf(g_pTestStream, "FAIL\n");
                free(pDistinctRanges);
                break;
            }

            for (CurRangeIdx = 0; CurRangeIdx < NumDistincts; CurRangeIdx++)
            {
                g_fpTestPrintf(g_pTestStream, 
                               "  %I64u-%I64u\n",
                               pDistinctRanges[CurRangeIdx].Start,
                               pDistinctRanges[CurRangeIdx].End);
            }

            free(pDistinctRanges);

            break;
            
        default:
            g_fpTestPrintf(g_pTestStream, "ERR: INVALID OP CODE!");
            goto get_new_optype;
        }
    }

    return;
}

#endif // BLRANGE_SELF_TEST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\cmdcnst.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cmdcnst.h

Abstract:

    This is the command string interpreter definitions

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//--------------------------------------------------------------------------
//   Definition of the set/clear mode command language.
//
//   Each command is composed of a major portion and a minor portion.
//   The major portion of a command can be found in the most significant
//   nibble of a command byte, while the minor portion is in the least
//   significant portion of a command byte.
//
//   maj  minor      Description
//   ---- -----      --------------------------------------------
//   00              End of data
//
//   10              in and out type commands as described by flags
//        flags:
//
//        xxxx
//        ||||
//        |||+-------- unused
//        ||+--------- 0/1 single/multiple values to output (in's are always 
//        |+---------- 0/1 8/16 bit operation                  single)
//        +----------- 0/1 out/in instruction
//
//       Outs
//       ----------------------------------------------
//       0           reg:W val:B
//       2           reg:W cnt:W val1:B val2:B...valN:B
//       4           reg:W val:W
//       6           reg:W cnt:W val1:W val2:W...valN:W
//
//       Ins
//       ----------------------------------------------
//       8           reg:W
//       a           reg:W cnt:W
//       c           reg:W
//       e           reg:W cnt:W
//
//   20              Special purpose outs
//       00          do indexed outs for seq, crtc, and gdc
//                   indexreg:W cnt:B startindex:B val1:B val2:B...valN:B
//       01          do indexed outs for atc
//                   index-data_reg:W cnt:B startindex:B val1:B val2:B...valN:B
//       02          do masked outs
//                   indexreg:W andmask:B xormask:B
//
//   F0              Nop
//
//---------------------------------------------------------------------------

// some useful equates - major commands

#define EOD     0x000                   // end of data
#define INOUT   0x010                   // do ins or outs
#define METAOUT 0x020                   // do special types of outs
#define NCMD    0x0f0                   // Nop command


// flags for INOUT major command

//#define UNUSED    0x01                    // reserved
#define MULTI   0x02                    // multiple or single outs
#define BW      0x04                    // byte/word size of operation
#define IO      0x08                    // out/in instruction

// minor commands for metout

#define INDXOUT 0x00                    // do indexed outs
#define ATCOUT  0x01                    // do indexed outs for atc
#define MASKOUT 0x02                    // do masked outs using and-xor masks


// composite inout type commands

#define OB      (INOUT)                 // output 8 bit value
#define OBM     (INOUT+MULTI)           // output multiple bytes
#define OW      (INOUT+BW)              // output single word value
#define OWM     (INOUT+BW+MULTI)        // output multiple words

#define IB      (INOUT+IO)              // input byte
#define IBM     (INOUT+IO+MULTI)        // input multiple bytes
#define IW      (INOUT+IO+BW)           // input word
#define IWM     (INOUT+IO+BW+MULTI)     // input multiple words
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blstring.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    parseini.c

Abstract:

    This module implements functions to parse a .INI file

Author:

    John Vert (jvert) 7-Oct-1993

Revision History:

    John Vert (jvert) 7-Oct-1993 - largely lifted from splib\spinf.c

--*/

#include "parseini.h"
#include <string.h>
#include <ctype.h>
#include <stdlib.h>


PWCHAR
SlCopyStringAW(
    IN PCHAR String
    )
/*++

Routine Description:

    Converts an ANSI string into UNICODE and copies it into the loader heap.

Arguments:

    String - Supplies the string to be copied.

Return Value:

    PWCHAR - pointer into the loader heap where the string was copied to.

--*/
{
    PWCHAR Buffer;
    ANSI_STRING aString;
    UNICODE_STRING uString;
    USHORT Length;

    if (String==NULL) {
        SlNoMemoryError();
        return NULL;
    }

    Length = RESET_SIZE_AT_USHORT_MAX(sizeof(WCHAR)*(strlen(String) + 1));

    Buffer = BlAllocateHeap(Length);
    if (Buffer==NULL) {
        SlNoMemoryError();
    } else {

        RtlInitAnsiString( &aString, String );
        uString.Buffer = Buffer;
        uString.MaximumLength = Length;
        
        RtlAnsiStringToUnicodeString( &uString, &aString, FALSE );
        
        Buffer[strlen(String)] = L'\0';

    }

    return(Buffer);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blres.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    blres.c

Abstract:

    Provides rudimentary resource support for the osloader and setupldr

Author:

    John Vert (jvert) 12-Nov-1993

Revision History:

--*/
#include "bootlib.h"

PUCHAR BlpResourceDirectory = NULL;
PUCHAR BlpResourceFileOffset = NULL;

//
// private function prototypes
//
PIMAGE_RESOURCE_DIRECTORY
BlpFindDirectoryEntry(
    IN PIMAGE_RESOURCE_DIRECTORY Directory,
    IN ULONG Id,
    IN PUCHAR SectionStart
    );


ARC_STATUS
BlInitResources(
    IN PCHAR StartCommand
    )

/*++

Routine Description:

    Opens the executable that was run and reads the section headers out of the
    image to determine where the resource section is located in memory.

Arguments:

    StartCommand - Supplies the command used to start the program (argv[0])

Return Value:

    ESUCCESS if successful

    ARC_STATUS if unsuccessful

--*/

{
    CHAR DeviceName[80];
    PCHAR FileName;
    PCHAR p;
    ULONG DeviceId;
    ULONG FileId;
    ARC_STATUS Status;
    UCHAR LocalBuffer[(SECTOR_SIZE * 2) + 256];
    PUCHAR LocalPointer;
    ULONG Count;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER SectionHeader;
    ULONG NumberOfSections;
#if defined(_IA64_)
    PIMAGE_NT_HEADERS NtHeader;
#endif


    if (BlpResourceDirectory != NULL) {
        //
        // Already initialized, just return.
        //
        return(ESUCCESS);
    }
    //
    // extract device name from the startup path
    //
    p=strrchr(StartCommand,')');
    if (p==NULL) {
        return(ENODEV);
    }

    strncpy(DeviceName, StartCommand, (ULONG) (p-StartCommand+1));
    DeviceName[p-StartCommand+1]='\0';

    FileName = p+1;
#ifdef ARCI386
    FileName++;
#endif
    //
    // Open the device.
    //
    Status = ArcOpen(DeviceName, ArcOpenReadOnly, &DeviceId);
    if (Status != ESUCCESS) {
        return(Status);
    }

    //
    // Open the file.
    //
    Status = BlOpen(DeviceId,
                    FileName,
                    ArcOpenReadOnly,
                    &FileId);
    if (Status != ESUCCESS) {
        ArcClose(DeviceId);
        return(Status);
    }

    //
    // Read the first two sectors of the image header from the file.
    //
    LocalPointer = ALIGN_BUFFER(LocalBuffer);
    Status = BlRead(FileId, LocalPointer, SECTOR_SIZE*2, &Count);
    BlClose(FileId);
    ArcClose(DeviceId);

    if (Status != ESUCCESS) {
        return(Status);
    }

#if defined(_IA64_)
    NtHeader = (PIMAGE_NT_HEADERS) ( (PCHAR) LocalPointer +
                                     ((PIMAGE_DOS_HEADER) LocalPointer)->e_lfanew);
    FileHeader = &(NtHeader->FileHeader);
    LocalPointer = (PUCHAR) FileHeader;
#else
    FileHeader = (PIMAGE_FILE_HEADER)LocalPointer;
#endif

    OptionalHeader = (PIMAGE_OPTIONAL_HEADER)(LocalPointer + sizeof(IMAGE_FILE_HEADER));
    NumberOfSections = FileHeader->NumberOfSections;
    SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)OptionalHeader +
                                            FileHeader->SizeOfOptionalHeader);

    //
    // Find .rsrc section
    //

    while (NumberOfSections) {
        if (_stricmp((PCHAR)SectionHeader->Name, ".rsrc")==0) {
            BlpResourceDirectory = (PUCHAR)((LONG_PTR)((LONG)SectionHeader->VirtualAddress));
            BlpResourceFileOffset = (PUCHAR)(ULONG_PTR)SectionHeader->PointerToRawData;
#if defined(ARCI386) || defined(_IA64_)
            // No startup.com to fix up these values for this ARC PROM.
            BlpResourceDirectory += OptionalHeader->ImageBase;
            BlpResourceFileOffset = (PUCHAR)UlongToPtr(SectionHeader->VirtualAddress);  //ResourceDirectory->VirtualAddress;
#endif
            if (FileHeader->Machine == IMAGE_FILE_MACHINE_POWERPC) {
                BlpResourceDirectory += OptionalHeader->ImageBase;
            }

            return(ESUCCESS);
        }

        ++SectionHeader;
        --NumberOfSections;
    }

    return(EBADF);
}


PTCHAR
BlFindMessage(
    IN ULONG Id
    )

/*++

Routine Description:

    Looks up a message resource in the given image.  Note that this routine
    ignores the Language ID.  It is assumed that the osloader/setupldr only
    has messages for one language.

Arguments:

    Id - Supplies the message ID to look up.

Return Value:

    PTCHAR - pointer to the message string.

    NULL - failure.

--*/

{
    PIMAGE_RESOURCE_DIRECTORY ResourceDirectory;
    PIMAGE_RESOURCE_DIRECTORY NextDirectory;
    PMESSAGE_RESOURCE_DATA  MessageData;
    PMESSAGE_RESOURCE_BLOCK MessageBlock;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    PIMAGE_RESOURCE_DATA_ENTRY DataEntry;
    ULONG NumberOfBlocks;
    ULONG Index;

    if (BlpResourceDirectory==NULL) {
        return(NULL);
    }

    ResourceDirectory = (PIMAGE_RESOURCE_DIRECTORY)BlpResourceDirectory;

    //
    // Search the directory.  We are looking for the type RT_MESSAGETABLE (11)
    //
    NextDirectory = BlpFindDirectoryEntry(ResourceDirectory,
                                          11,
                                          (PUCHAR)ResourceDirectory);
    if (NextDirectory==NULL) {
        return(NULL);
    }

    //
    // Find the next directory.  Should only be one entry here (nameid == 1)
    //
    NextDirectory = BlpFindDirectoryEntry(NextDirectory,
                                          1,
                                          (PUCHAR)ResourceDirectory);
    if (NextDirectory==NULL) {
        return(NULL);
    }

    // Find the message table.
    // If a dbcs locale is active, then we look for the appropriate
    // message table first. Otherwise we just look for the first message table.
    //
    if(DbcsLangId) {
        DataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)BlpFindDirectoryEntry(
                                                    NextDirectory,
                                                    DbcsLangId,
                                                    (PUCHAR)ResourceDirectory
                                                    );
    } else {
        DataEntry = NULL;
    }

    if(!DataEntry) {
        DataEntry = (PIMAGE_RESOURCE_DATA_ENTRY)BlpFindDirectoryEntry(
                                                    NextDirectory,
                                                    (ULONG)(-1),
                                                    (PUCHAR)ResourceDirectory
                                                    );
    }

    if(!DataEntry) {
        return(NULL);
    }

    MessageData = (PMESSAGE_RESOURCE_DATA)(BlpResourceDirectory +
                                           DataEntry->OffsetToData -
                                           BlpResourceFileOffset);

    NumberOfBlocks = MessageData->NumberOfBlocks;
    MessageBlock = MessageData->Blocks;
    while (NumberOfBlocks--) {
        if ((Id >= MessageBlock->LowId) &&
            (Id <= MessageBlock->HighId)) {

            //
            // The requested ID is within this block, scan forward until
            // we find it.
            //
            MessageEntry = (PMESSAGE_RESOURCE_ENTRY)((PCHAR)MessageData + MessageBlock->OffsetToEntries);
            Index = Id - MessageBlock->LowId;
            while (Index--) {
                MessageEntry = (PMESSAGE_RESOURCE_ENTRY)((PUCHAR)MessageEntry + MessageEntry->Length);
            }
            return((PTCHAR)MessageEntry->Text);
        }

        //
        // Check the next block for this ID.
        //

        MessageBlock++;
    }

    return(NULL);

}


PIMAGE_RESOURCE_DIRECTORY
BlpFindDirectoryEntry(
    IN PIMAGE_RESOURCE_DIRECTORY Directory,
    IN ULONG Id,
    IN PUCHAR SectionStart
    )

/*++

Routine Description:

    Searches through a resource directory for the given ID.  Ignores entries
    with actual names, only searches for ID.  If the given ID is -1, the
    first entry is returned.

Arguments:

    Directory - Supplies the resource directory to search.

    Id - Supplies the ID to search for.  -1 means return the first ID found.

    SectionStart - Supplies a pointer to the start of the resource section.

Return Value:

    Pointer to the found resource directory.

    NULL for failure.

--*/

{
    ULONG i;
    PIMAGE_RESOURCE_DIRECTORY_ENTRY FoundDirectory;

    FoundDirectory = (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(Directory+1);

    //
    // Skip entries with names.
    //
    for (i=0;i<Directory->NumberOfNamedEntries;i++) {
        ++FoundDirectory;
    }

    //
    // Search for matching ID.
    //
    for (i=0;i<Directory->NumberOfIdEntries;i++) {
        if ((FoundDirectory->Name == Id) || (Id == (ULONG)-1)) {
            //
            // Found a match.
            //
            return((PIMAGE_RESOURCE_DIRECTORY)(SectionStart +
                            (FoundDirectory->OffsetToData & ~IMAGE_RESOURCE_DATA_IS_DIRECTORY)));

        }
        ++FoundDirectory;
    }

    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\blsecret.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    blsecret.c

Abstract:

    This module contains the code to read and write secrets from disk.

Author:

    Adam Barr (adamba) 13-June-1997

Revision History:

--*/

#include "bootlib.h"

#define SEC_FAR
typedef BOOLEAN BOOL;
typedef unsigned char BYTE, *PBYTE;
typedef unsigned long DWORD;
#define LM20_PWLEN 14
#include "crypt.h"
#include "rc4.h"

//
// Defined in the bootssp library.
//

BOOL
CalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    );

BOOL
CalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    );

// This must be evenly divisible by sizeof(USHORT)
#define ASSUMED_SECTOR_SIZE 512

#if 0
VOID
BlpDumpSector(
    PUCHAR Sector
    )
{
    int i, j;

    PUCHAR SectorChar = (PUCHAR)Sector;

    for (i = 0; i < ASSUMED_SECTOR_SIZE; i+= 16) {

        for (j = 0; j < 16; j++) {
            DbgPrint("%2.2x ", SectorChar[i + j]);
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            if ((SectorChar[i+j] >= ' ') && (SectorChar[i+j] < '~')) {
                DbgPrint("%c", SectorChar[i+j]);
            } else {
                DbgPrint(".");
            }
        }
        DbgPrint("\n");
    }
}
#endif


#if defined(REMOTE_BOOT)
ARC_STATUS
BlOpenRawDisk(
    PULONG FileId
    )

/*++

Routine Description:

    This routine opens the raw disk for read/write.

Arguments:

    FileId - returns the FileId is successful, for use in subsequent calls.

Return Value:

    The status return from the ArcOpen.

--*/

{

    ARC_STATUS ArcStatus;

    //
    // Open the disk in raw mode. Need to check if it is the right string for Alpha.
    // On x86 this eventually turns into an int13 read of disk 0x80 which
    // is what we want and is more-or-less guaranteed to be in the format
    // we expect (e.g. 512 byte sectors).
    //

    ArcStatus = ArcOpen("multi(0)disk(0)rdisk(0)partition(0)", ArcOpenReadWrite, FileId);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlOpenRawDisk: ArcStatus on ArcOpen: %x\n", ArcStatus);

    }

    return ArcStatus;

}


ARC_STATUS
BlCloseRawDisk(
    ULONG FileId
    )

/*++

Routine Description:

    This routine closes the raw disk.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    The status return from the ArcClose.

--*/

{

    return ArcClose(FileId);

}


ARC_STATUS
BlCheckForFreeSectors (
    ULONG FileId
    )

/*++

Routine Description:

    This routine makes sure that the MBR looks correct and that there
    is nothing installed (OnTrack or EZ-Drive -- need to detect
    NT fault-tolerance also) that would prevent us from using the third
    sector for storing the password secret.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    ESUCCESS if the disk is OK, or an error.

--*/

{

    ARC_STATUS ArcStatus;
    USHORT Sector[ASSUMED_SECTOR_SIZE/sizeof(USHORT)];
    ULONG BytesProcessed;
    PPARTITION_DESCRIPTOR FirstPartition;
    LARGE_INTEGER SeekPosition;


    //
    // Make sure we are at the beginning of the disk.
    //

    SeekPosition.QuadPart = 0;

    ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcSeek: %x\n", ArcStatus);
        return ArcStatus;

    }

    //
    // Read the MBR at the start of the disk.
    //

    ArcStatus = ArcRead(FileId, Sector, ASSUMED_SECTOR_SIZE, &BytesProcessed);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcRead MBR: %x\n", ArcStatus);
        return ArcStatus;

    }

#if 0
    BlpDumpSector((PUCHAR)Sector);
#endif

    //
    // Make sure the signature is OK, and that the type of partition
    // 0 is not 0x54 (OnTrack) or 0x55 (EZ-Drive).
    //

    if (Sector[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {

        DbgPrint("BlCheckForFreeSectors: Boot record signature %x not found (%x found)\n",
                BOOT_RECORD_SIGNATURE,
                Sector[BOOT_SIGNATURE_OFFSET] );
        return EINVAL;
    }

    //
    // FirstPartition is the first entry in the partition table.
    //

    FirstPartition = (PPARTITION_DESCRIPTOR)&Sector[PARTITION_TABLE_OFFSET];

    if ((FirstPartition->PartitionType == 0x54) ||
        (FirstPartition->PartitionType == 0x55)) {

        DbgPrint("BlCheckForFreeSectors: First partition has type %x, exiting\n", FirstPartition->PartitionType);
        return EINVAL;
    }

    DbgPrint("BlCheckForFreeSectors: Partition type is %d\n", FirstPartition->PartitionType);

#if 0
    //
    // Make the active entry the first one in the partition table.
    //

    if ((FirstPartition->ActiveFlag & PARTITION_ACTIVE_FLAG) != PARTITION_ACTIVE_FLAG) {

        PPARTITION_DESCRIPTOR ActivePartition;
        PARTITION_DESCRIPTOR TempPartition;
        ULONG i;

        ActivePartition = FirstPartition;

        for (i = 1; i < NUM_PARTITION_TABLE_ENTRIES; i++) {

            ++ActivePartition;
            if ((ActivePartition->ActiveFlag & PARTITION_ACTIVE_FLAG) == PARTITION_ACTIVE_FLAG) {

                DbgPrint("BlCheckForFreeSector: Moving active partition %d to the front\n", i);

                TempPartition = *FirstPartition;
                *FirstPartition = *ActivePartition;
                *ActivePartition = TempPartition;
                break;
            }
        }

        if (i == NUM_PARTITION_TABLE_ENTRIES) {

            DbgPrint("BlCheckForFreeSector: Could not find an active partition!!\n");

        } else {
        
            ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);
        
            if (ArcStatus != ESUCCESS) {
        
                DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcSeek: %x\n", ArcStatus);
                return ArcStatus;
            }
        
            ArcStatus = ArcWrite(FileId, Sector, ASSUMED_SECTOR_SIZE, &BytesProcessed);
        
            if ((ArcStatus != ESUCCESS) ||
                (BytesProcessed != ASSUMED_SECTOR_SIZE)) {

                DbgPrint("BlCheckForFreeSectors: ArcStatus on ArcWrite MBR: %x (%x)\n", ArcStatus, BytesProcessed);
                return ArcStatus;
            }
        }
    }
#endif

    return ESUCCESS;

}


ARC_STATUS
BlReadSecret(
    ULONG FileId,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine reads the secret from the disk, if present.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    ESUCCESS if the secret is OK, an error otherwise.

--*/

{

    ARC_STATUS ArcStatus;
    ULONG BytesRead;
    LARGE_INTEGER SeekPosition;


    //
    // Seek to the third sector.
    //

    SeekPosition.QuadPart = 2 * ASSUMED_SECTOR_SIZE;

    ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlReadSecret: ArcStatus on ArcSeek: %x\n", ArcStatus);
        return ArcStatus;

    }

    //
    // Read a secret-sized chunk.
    //

    ArcStatus = ArcRead(FileId, Secret, sizeof(RI_SECRET), &BytesRead);

    if ((ArcStatus != ESUCCESS) ||
        (BytesRead != sizeof(RI_SECRET))) {

        DbgPrint("BlReadSecret: ArcStatus on ArcRead secret: %x, read %d\n", ArcStatus, BytesRead);
        return ArcStatus;

    }

    if (memcmp(Secret->Signature, RI_SECRET_SIGNATURE, 4) != 0) {

        DbgPrint("BlReadSecret: No signature found\n");
        return EINVAL;
    }

    return ESUCCESS;

}



ARC_STATUS
BlWriteSecret(
    ULONG FileId,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine writes the secret to the disk.

Arguments:

    FileId - The FileId returned by BlOpenRawDisk.

Return Value:

    ESUCCESS if the secret is written OK, an error otherwise.

--*/

{

    ARC_STATUS ArcStatus;
    ULONG BytesWritten;
    LARGE_INTEGER SeekPosition;


    //
    // Seek to the third sector.
    //

    SeekPosition.QuadPart = 2 * ASSUMED_SECTOR_SIZE;

    ArcStatus = ArcSeek(FileId, &SeekPosition, SeekAbsolute);

    if (ArcStatus != ESUCCESS) {

        DbgPrint("BlWriteSecret: ArcStatus on ArcSeek: %x\n", ArcStatus);
        return ArcStatus;

    }

    //
    // Write a secret-sized chunk.
    //

    ArcStatus = ArcWrite(FileId, Secret, sizeof(RI_SECRET), &BytesWritten);

    if ((ArcStatus != ESUCCESS) ||
        (BytesWritten != sizeof(RI_SECRET))) {

        DbgPrint("BlWriteSecret: ArcStatus on ArcWrite secret: %x, wrote %d\n", ArcStatus, BytesWritten);
        return ArcStatus;

    }

    return ESUCCESS;

}
#endif // defined(REMOTE_BOOT)


VOID
BlInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
#endif // defined(REMOTE_BOOT)
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine initializes the secret structures. The passwords
    are OWFed and then encrypted with the User string.

Arguments:

Return Value:

    None.

--*/

{
    int Length;
    struct RC4_KEYSTRUCT Key;

#if !defined(BL_USE_LM_PASSWORD)
    UNREFERENCED_PARAMETER( LmOwfPassword1 );
#endif

    memset(Secret, 0, sizeof(RI_SECRET));

    memcpy(Secret->Signature, RI_SECRET_SIGNATURE, 4);
    Secret->Version = 1;

    Length = (ULONG)strlen((PCHAR)Domain);
    memcpy(Secret->Domain, Domain, Length);

    Length = (ULONG)strlen((PCHAR)User);
    memcpy(Secret->User, User, Length);

    memcpy(Secret->Sid, Sid, RI_SECRET_SID_SIZE);

    //
    // Encrypt the passwords using the user name.
    //

#if defined(BL_USE_LM_PASSWORD)
    memcpy(Secret->LmEncryptedPassword1, LmOwfPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword1);

#if defined(REMOTE_BOOT)
    if (LmOwfPassword2 != NULL) {
        memcpy(Secret->LmEncryptedPassword2, LmOwfPassword2, LM_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword2);
    }
#endif // defined(REMOTE_BOOT)
#endif // defined(BL_USE_LM_PASSWORD)

    memcpy(Secret->NtEncryptedPassword1, NtOwfPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, (ULONG)strlen((PCHAR)User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword1);

#if defined(REMOTE_BOOT)
    if (NtOwfPassword2 != NULL) {
        memcpy(Secret->NtEncryptedPassword2, NtOwfPassword2, NT_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword2);
    }
#endif // defined(REMOTE_BOOT)

}



#if defined(REMOTE_BOOT_SECURITY)
VOID
BlParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine parses a secret structure. The passwords
    are unencrypted with the User string and returned in OWF form.

Arguments:

Return Value:

    None.

--*/

{
    struct RC4_KEYSTRUCT Key;

    memcpy(Domain, Secret->Domain, RI_SECRET_DOMAIN_SIZE);
    Domain[RI_SECRET_DOMAIN_SIZE] = '\0';

    memcpy(User, Secret->User, RI_SECRET_USER_SIZE);
    User[RI_SECRET_USER_SIZE] = '\0';

    memcpy(Sid, Secret->Sid, RI_SECRET_SID_SIZE);

    //
    // Decrypt the passwords using the user name.
    //

#if defined(BL_USE_LM_PASSWORD)
    memcpy(LmOwfPassword1, Secret->LmEncryptedPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword1);

    memcpy(LmOwfPassword2, Secret->LmEncryptedPassword2, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword2);
#else
    memset(LmOwfPassword1, 0, LM_OWF_PASSWORD_SIZE);
    memset(LmOwfPassword2, 0, LM_OWF_PASSWORD_SIZE);
#endif // defined(BL_USE_LM_PASSWORD)

    memcpy(NtOwfPassword1, Secret->NtEncryptedPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword1);

    memcpy(NtOwfPassword2, Secret->NtEncryptedPassword2, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword2);

}
#endif // defined(REMOTE_BOOT_SECURITY)



VOID
BlOwfPassword(
    IN PUCHAR Password,
    IN PUNICODE_STRING UnicodePassword,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    )
{
    char TmpText[CLEAR_BLOCK_LENGTH*2] = {'\0'};
    int Length;
    int i;

    Length = (ULONG)strlen((PCHAR)Password);

    //
    // Copy the string to TmpText, converting to uppercase.
    //

    if (Length == 0 || Length > LM20_PWLEN) {
        TmpText[0] = 0;
    } else {
        for (i = 0; i <= Length; i++) {
            TmpText[i] = (char)toupper(Password[i]);
        }
    }

    CalculateLmOwfPassword((PLM_PASSWORD)TmpText, (PLM_OWF_PASSWORD)LmOwfPassword);

    CalculateNtOwfPassword(UnicodePassword, (PNT_OWF_PASSWORD)NtOwfPassword);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\bootlib.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    bootlib.h

Abstract:

    This module is the header file for the common boot library

Author:

    John Vert (jvert) 5-Oct-1993

Revision History:

--*/

#ifndef _BOOTLIB_
#define _BOOTLIB_

#include "ntos.h"
#include "bldr.h"
#include "fatboot.h"
#include "cdfsboot.h"
#include "ntfsboot.h"
#include "hpfsboot.h"
#include "etfsboot.h"
#include "netboot.h"
#include "udfsboot.h"

#define UNINITIALIZED_DEVICE_ID (ULONG)-1

//
// Define partition context structure.
//

typedef struct _PARTITION_CONTEXT {
    LARGE_INTEGER PartitionLength;
    ULONG StartingSector;
    ULONG EndingSector;
    UCHAR DiskId;
    UCHAR DeviceUnit;
    UCHAR TargetId;
    UCHAR PathId;
    ULONG SectorShift;
    ULONG Size;
    struct _DEVICE_OBJECT *PortDeviceObject;
} PARTITION_CONTEXT, *PPARTITION_CONTEXT;

#ifdef EFI_PARTITION_SUPPORT

#pragma pack (1)

typedef struct _EFI_PARTITION_TABLE {
    UCHAR       Signature[8];
    ULONG       Revision;
    ULONG       HeaderSize;
    ULONG       HeaderCRC;
    ULONG       Reserved;
    unsigned __int64 MyLBA;
    unsigned __int64 AlternateLBA;
    unsigned __int64 FirstUsableLBA;
    unsigned __int64 LastUsableLBA;
    UCHAR       DiskGuid[16];
    unsigned __int64 PartitionEntryLBA;
    ULONG       PartitionCount;
    ULONG       PartitionEntrySize;
    ULONG       PartitionEntryArrayCRC;
    UCHAR       ReservedEnd[1];    // will extend till block size
} EFI_PARTITION_TABLE, *PEFI_PARTITION_TABLE;

typedef struct _EFI_PARTITION_ENTRY {
    UCHAR       Type[16];
    UCHAR       Id[16];
    unsigned __int64 StartingLBA;
    unsigned __int64 EndingLBA;
    unsigned __int64 Attributes;
    UCHAR       Name[72];        
} EFI_PARTITION_ENTRY, *PEFI_PARTITION_ENTRY;

#pragma pack ()

#define EFI_SIGNATURE   "EFI PART"

#endif // EFI_PARTITION_SUPPORT

//
// Define serial port context structure
//
typedef struct _SERIAL_CONTEXT {
    ULONG PortBase;
    ULONG PortNumber;
} SERIAL_CONTEXT, *PSERIAL_CONTEXT;


//
// Define drive context structure (for x86 BIOS)
//
typedef struct _DRIVE_CONTEXT {
    BOOLEAN IsCd;
    UCHAR Drive;    
    UCHAR Sectors;          // 1 - 63
    USHORT Cylinders;       // 1 - 1023
    USHORT Heads;           // 1 - 256
    BOOLEAN xInt13;
#if defined(_IA64_)
    ULONGLONG DeviceHandle;
#endif // IA64
} DRIVE_CONTEXT, *PDRIVE_CONTEXT;

//
// Define Floppy context structure
//
typedef struct _FLOPPY_CONTEXT {
    ULONG DriveType;
    ULONG SectorsPerTrack;
    UCHAR DiskId;
} FLOPPY_CONTEXT, *PFLOPPY_CONTEXT;

//
// Define keyboard context structure
//
typedef struct _KEYBOARD_CONTEXT {
    BOOLEAN ScanCodes;
} KEYBOARD_CONTEXT, *PKEYBOARD_CONTEXT;

//
// Define Console context
//
typedef struct _CONSOLE_CONTEXT {
    ULONG ConsoleNumber;
} CONSOLE_CONTEXT, *PCONSOLE_CONTEXT;

//
// Define EFI open handle context
//
typedef struct _EFI_ARC_OPEN_CONTEXT {
    PVOID   Handle;
    PVOID   DeviceEntryProtocol;
} EFI_ARC_OPEN_CONTEXT, *PEFI_ARC_OPEN_CONTEXT;


//
// Define file table structure.
//

typedef struct _BL_FILE_FLAGS {
    ULONG Open : 1;
    ULONG Read : 1;
    ULONG Write : 1;
    ULONG Firmware : 1;
} BL_FILE_FLAGS, *PBL_FILE_FLAGS;

#define MAXIMUM_FILE_NAME_LENGTH 32

typedef struct _BL_FILE_TABLE {
    BL_FILE_FLAGS Flags;
    ULONG DeviceId;
    LARGE_INTEGER Position;
    PVOID StructureContext;
    PBL_DEVICE_ENTRY_TABLE DeviceEntryTable;
    UCHAR FileNameLength;
    CHAR FileName[MAXIMUM_FILE_NAME_LENGTH];
    union {
        NTFS_FILE_CONTEXT NtfsFileContext;
        FAT_FILE_CONTEXT FatFileContext;
        UDFS_FILE_CONTEXT UdfsFileContext;
        CDFS_FILE_CONTEXT CdfsFileContext;
        ETFS_FILE_CONTEXT EtfsFileContext;
        NET_FILE_CONTEXT NetFileContext;
        PARTITION_CONTEXT PartitionContext;
        SERIAL_CONTEXT SerialContext;
        DRIVE_CONTEXT DriveContext;
        FLOPPY_CONTEXT FloppyContext;
        KEYBOARD_CONTEXT KeyboardContext;
        CONSOLE_CONTEXT ConsoleContext;
        EFI_ARC_OPEN_CONTEXT EfiContext;        
    } u;
} BL_FILE_TABLE, *PBL_FILE_TABLE;

extern BL_FILE_TABLE BlFileTable[BL_FILE_TABLE_SIZE];

//
// Context structure for our Decompression pseudo-filesystem
// (filter on top of other FS)
//
typedef struct _DECOMP_STRUCTURE_CONTEXT {
    //
    // File information from the original file system.
    //
    FILE_INFORMATION FileInfo;
} DECOMP_STRUCTURE_CONTEXT, *PDECOMP_STRUCTURE_CONTEXT;

//
// Define generic filesystem context area.
//
// N.B. An FS_STRUCTURE_CONTEXT structure is temporarily used when
// determining the file system for a volume.  Once the file system
// is recognized, a file system specific structure is allocated from
// the heap to retain the file system structure information.
//

typedef union {
    UDFS_STRUCTURE_CONTEXT UdfsStructure;
    CDFS_STRUCTURE_CONTEXT CdfsStructure;
    FAT_STRUCTURE_CONTEXT FatStructure;
    HPFS_STRUCTURE_CONTEXT HpfsStructure;
    NTFS_STRUCTURE_CONTEXT NtfsStructure;
#if defined(ELTORITO)
    ETFS_STRUCTURE_CONTEXT EtfsStructure;
#endif
    NET_STRUCTURE_CONTEXT NetStructure;
    DECOMP_STRUCTURE_CONTEXT DecompStructure;
} FS_STRUCTURE_CONTEXT, *PFS_STRUCTURE_CONTEXT;


//
// 
// N.B. We can speed up the boot time, by not
// querying the device for all the possible file systems
// for every open call. This saves approximately 30 secs
// on CD-ROM / DVD-ROM boot time. To disable this feature
// just undef CACHE_DEVINFO in bldr.h
//
//
#ifdef CACHE_DEVINFO 

//
// Device ID to File System information cache.
// 
// N.B. For removable media its assumed that the device will
// be closed using ArcClose(...) before using the new media.
// This close call will invalidate the cached entry as 
// ArcClose(...) will be mapped to ArcCacheClose(...) 
//
typedef struct _DEVICE_TO_FILESYS {
  ULONG                   DeviceId;
  PFS_STRUCTURE_CONTEXT   Context;
  PBL_DEVICE_ENTRY_TABLE  DevMethods;   
} DEVICE_TO_FILESYS, * PDEVICE_TO_FILESYS;

extern DEVICE_TO_FILESYS    DeviceFSCache[BL_FILE_TABLE_SIZE];

#endif // CACHE_DEVINFO


#ifdef EFI_PARTITION_SUPPORT


typedef
BOOLEAN
(*PGPT_READ_CALLBACK)(
    IN ULONGLONG StartingLBA,
    IN ULONG     BytesToRead,
    IN OUT PVOID Context,
    OUT PVOID    OutputData
    );

BOOLEAN
BlIsValidGUIDPartitionTable(
    IN UNALIGNED EFI_PARTITION_TABLE  *PartitionTableHeader,
    IN ULONGLONG LBAOfPartitionTable,
    IN PVOID  Context,
    IN PGPT_READ_CALLBACK DiskReadFunction
    );


UNALIGNED EFI_PARTITION_ENTRY *
BlLocateGPTPartition(
    IN UCHAR PartitionNumber,
    IN UCHAR MaxPartitions,
    IN PUCHAR ValidPartitionCount OPTIONAL
    );

ARC_STATUS
BlOpenGPTDiskPartition(
    IN ULONG FileId,
    IN ULONG DiskId,
    IN UCHAR PartitionNumber
    );

ARC_STATUS
BlGetGPTDiskPartitionEntry(
    IN ULONG DiskNumber,
    IN UCHAR PartitionNumber,
    OUT EFI_PARTITION_ENTRY UNALIGNED **PartitionEntry
    );

ARC_STATUS
BlGetMbrDiskSignature(
    IN  ULONG  DiskNumber,
    OUT PULONG DiskSignature
    );

//
// EFI partition table buffer
//
extern UNALIGNED EFI_PARTITION_ENTRY EfiPartitionBuffer[128];    

#endif // EFI_PARTITION_SUPPORT    

#endif  _BOOTLIB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    blio.c

Abstract:

    This module contains the stub code for the debug print API's.

Author:

    David N. Cutler (davec) 2-Feby-2000

Revision History:

--*/

#include "bootlib.h"
#include "stdarg.h"

#if !defined(ENABLE_LOADER_DEBUG)

#if !defined (_IA64_) || !defined (FORCE_CD_BOOT)


ULONG
DbgPrint(
    IN PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    UNREFERENCED_PARAMETER( Format );

    return 0;
}
#endif

ULONG
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    PCHAR Format,
    ...
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level.
//    Format     - printf style format string
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    UNREFERENCED_PARAMETER( ComponentId );
    UNREFERENCED_PARAMETER( Level );
    UNREFERENCED_PARAMETER( Format );

    return 0;
}

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level or mask.
//    Arguments   - Supplies a pointer to a variable argument list.
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    UNREFERENCED_PARAMETER( ComponentId );
    UNREFERENCED_PARAMETER( Level );
    UNREFERENCED_PARAMETER( Format );
    UNREFERENCED_PARAMETER( arglist );

    return 0;
}

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCHAR Format,
    va_list arglist
    )

//++
//
// Routine Description:
//
//    This routine provides a "printf" style capability for the kernel
//    debugger.
//
//    Note:  control-C is consumed by the debugger and returned to
//    this routine as status.  If status indicates control-C was
//    pressed, this routine breakpoints.
//
// Arguments:
//
//    Prefix - Supplies a pointer to a message prefix.
//    ComponentId - Supplies the Id of the calling component.
//    Level      - Supplies the output filter level or mask.
//    Arguments   - Supplies a pointer to a variable argument list.
//    ...        - additional arguments consumed according to the
//                 format string.
//
// Return Value:
//
//    Defined as returning a ULONG, actually returns status.
//
//--

{
    UNREFERENCED_PARAMETER( Prefix );
    UNREFERENCED_PARAMETER( ComponentId );
    UNREFERENCED_PARAMETER( Level );
    UNREFERENCED_PARAMETER( Format );
    UNREFERENCED_PARAMETER( arglist );

    return 0;
}

VOID
DbgLoadImageSymbols(
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly loaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    UNREFERENCED_PARAMETER( FileName );
    UNREFERENCED_PARAMETER( ImageBase );
    UNREFERENCED_PARAMETER( ProcessId );

    return;
}

VOID
DbgUnLoadImageSymbols (
    IN PSTRING FileName,
    IN PVOID ImageBase,
    IN ULONG_PTR ProcessId
    )

//++
//
// Routine Description:
//
//    Tells the debugger about newly unloaded symbols.
//
// Arguments:
//
// Return Value:
//
//--

{
    UNREFERENCED_PARAMETER( FileName );
    UNREFERENCED_PARAMETER( ImageBase );
    UNREFERENCED_PARAMETER( ProcessId );

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\etfsboot.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    EtfsBoot.h

Abstract:

    This module defines globally used procedure and data structures used
    by Etfs boot.

Author:

    Steve Collins    [stevec]   25-Nov-1995

Revision History:

--*/

#ifndef _ETFSBOOT_
#define _ETFSBOOT_

//
//  The following constants are values from the disk.
//

#define ELTORITO_VD_SECTOR          (16)
#define ELTORITO_BRVD_SECTOR        (17)
#define ET_SYS_ID                  "EL TORITO SPECIFICATION"
#define BRVD_VERSION_1              (1)
#define VD_BOOTREC                  (0)

typedef struct _RAW_ET_BRVD {

    UCHAR       BrIndicator;        // boot record indicator = 0
    UCHAR       StandardId[5];      // volume structure standard id = "CD001"
    UCHAR       Version;            // descriptor version number = 1
    UCHAR       BootSysId[32];      // boot system identifier = "EL TORITO SPECIFICATION"
    UCHAR       Unused1[32];        // unused = 0
    ULONG       BootCatPtr;         // absolute pointer to first sector of boot catalog
    UCHAR       Reserved[1973];     // unused = 0

} RAW_ET_BRVD;
typedef RAW_ET_BRVD *PRAW_ET_BRVD;


//
//  The following macros are used to recover data from the different
//  volume descriptor structures.
//

#define RBRVD_BR_IND( r )   		( r->BrIndicator )
#define RBRVD_STD_ID( r )			( r->StandardId )
#define RBRVD_VERSION( r )   		( r->Version )
#define RBRVD_SYS_ID( r )			( r->BootSysId )

typedef struct _ETFS_STRUCTURE_CONTEXT {

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG RootDirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG RootDirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG RootDirSize;

    //
    //  The following field is the sector offset of the start of
    //  directory data.
    //

    ULONG DirSectorOffset;

    //
    //  The following field is the start of the sector containing the
    //  this directory.
    //

    ULONG DirDiskOffset;

    //
    //  The following field is the size of the directory.
    //

    ULONG DirSize;

    //
    //  The following field indicates the size of the disk Logical Blocks.
    //

    ULONG LbnBlockSize;

    //
    //  The following field indicates the number of logical blocks on the
    //  disk.
    //

    ULONG LogicalBlockCount;

    //
    //  The following indicates whether this is an Iso or Hsg disk.
    //

    BOOLEAN IsIsoVol;

} ETFS_STRUCTURE_CONTEXT, *PETFS_STRUCTURE_CONTEXT;

//
// Define Etfs file context structure.
//

typedef struct _ETFS_FILE_CONTEXT {

    //
    //  The following is the disk offset of the read position for the
    //  start of the file.  This may include the above number of non-file
    //  bytes.
    //

    ULONG DiskOffset;

    //
    //  The following field contains the size of the file, in bytes.
    //

    ULONG FileSize;

    //
    //  The following field indicates whether this is a directory.
    //

    BOOLEAN IsDirectory;

} ETFS_FILE_CONTEXT, *PETFS_FILE_CONTEXT;

//
// Define file I/O prototypes.
//

ARC_STATUS
EtfsClose (
    IN ULONG FileId
    );

ARC_STATUS
EtfsOpen (
    IN PCHAR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT PULONG FileId
    );

ARC_STATUS
EtfsRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
EtfsSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    );

ARC_STATUS
EtfsWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Count
    );

ARC_STATUS
EtfsGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Buffer
    );

ARC_STATUS
EtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    );

ARC_STATUS
EtfsInitialize(
    VOID
    );

#endif // _ETFSBOOT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\etfsboot.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    EtfsBoot.c

Abstract:

    This module implements the El Torito CD boot file system used by the operating
    system loader.

Author:

    Steve Collins    [stevec]   25-Nov-1995

Revision History:

--*/

#if defined(ELTORITO)
#include "bootlib.h"
#include "cd.h"
#include "blcache.h"

BOOTFS_INFO EtfsBootFsInfo = {L"etfs"};


//
//  Local procedure prototypes.
//

ARC_STATUS
EtfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

VOID
EtfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    );

typedef enum _COMPARISON_RESULTS {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} COMPARISON_RESULTS;

COMPARISON_RESULTS
EtfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    );

ARC_STATUS
EtfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    );

VOID
EtfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    );

COMPARISON_RESULTS
EtfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    );

typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                               \
    ((PUSHORT2)(Dst))->Ushort[0] = ((UNALIGNED USHORT2 *)(Src))->Ushort[0]; \
    ((PUSHORT2)(Dst))->Ushort[1] = ((UNALIGNED USHORT2 *)(Src))->Ushort[1]; \
    }

//
//  The following macro upcases a single ascii character
//

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define SetFlag(Flags,SingleFlag) { (Flags) |= (SingleFlag); }

//
//  The following macro indicate if the flag is on or off
//

#define FlagOn(Flags,SingleFlag) ((BOOLEAN)(       \
    (((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )                                              \
)


//
//  Define global data.
//
//  Context Pointer - This is a pointer to the context for the current file
//      operation that is active.
//

PETFS_STRUCTURE_CONTEXT EtfsStructureContext;

//
//  File Descriptor - This is a pointer to the file descriptor for the current
//      file operation that is active.
//


PBL_FILE_TABLE EtfsFileTableEntry;

//
//  File entry table - This is a structure that provides entry to the Etfs
//      file system procedures. It is exported when an Etfs file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE EtfsDeviceEntryTable;


PBL_DEVICE_ENTRY_TABLE
IsEtfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains an Etfs file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a Etfs file structure context.

Return Value:

    A pointer to the Etfs entry table is returned if the partition is
    recognized as containing an Etfs volume. Otherwise, NULL is returned.

--*/

{
    UCHAR UnalignedSector[CD_SECTOR_SIZE + 256];

    PRAW_ISO_VD RawVd;
    PRAW_DIR_REC RootDe;
    PRAW_ET_BRVD RawBrvd;

    UCHAR DescType;
    UCHAR Version;

    UCHAR BrInd;
    UCHAR BrVersion;

    BOOLEAN EtBootRec;
    BOOLEAN IsoVol;

    STRING IsoVolId;
    STRING EtSysId;
    STRING DiskId;

    ULONG DiskOffset;

    //
    //  Capture in our global variable the Etfs Structure context record
    //

    EtfsStructureContext = (PETFS_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory((PVOID)EtfsStructureContext, sizeof(ETFS_STRUCTURE_CONTEXT));

    //
    //  First check the Boot Record Volume Descriptor at sector 17
    //

    DiskOffset = ELTORITO_BRVD_SECTOR * CD_SECTOR_SIZE;

    //
    //  Compute the properly aligned buffer for reading in cdrom
    //  sectors.
    //

    RawBrvd = ALIGN_BUFFER( UnalignedSector );

    if (EtfsReadDisk( DeviceId,
                      DiskOffset,
                      CD_SECTOR_SIZE,
                      RawBrvd,
                      CACHE_NEW_DATA ) != ESUCCESS) {

        return NULL;
    }

    //
    //  Initialize the string Id to match.
    //

    RtlInitString( &IsoVolId, ISO_VOL_ID );

    DiskId.Length = 5;
    DiskId.MaximumLength = 5;

    //
    //  Compare the standard identifier string in the boot record volume descriptor with the Iso value.
    //

    DiskId.Buffer = (PCHAR) RBRVD_STD_ID( RawBrvd );

    IsoVol = (BOOLEAN)(EtfsCompareNames( &DiskId, &IsoVolId ) == EqualTo);

    if (!IsoVol) {

        return NULL;
    }

    //
    //  Get the boot record indicator and volume descriptor version number.
    //

    BrInd = RBRVD_BR_IND( RawBrvd );
    BrVersion = RBRVD_VERSION( RawBrvd );

    //
    //  Return NULL, if the version is incorrect or this isn't a boot record
    //  volume descriptor.
    //

    if (BrVersion != BRVD_VERSION_1
        || BrInd != VD_BOOTREC) {

        return NULL;
    }

    //
    //  Initialize the string Id to match.
    //

    RtlInitString( &EtSysId, ET_SYS_ID );

    DiskId.Length = 23;
    DiskId.MaximumLength = 23;

    //
    //  Compare the boot system identifier in the boot record volume descriptor with the El Torito value.
    //

    DiskId.Buffer = (PCHAR) RBRVD_SYS_ID( RawBrvd );

    EtBootRec = (BOOLEAN)(EtfsCompareNames( &DiskId, &EtSysId ) == EqualTo);

    if (!EtBootRec) {

        return NULL;
    }

    //
    // Now check the Primary Volume Descriptor
    // We do this second because if it's valid we want to store values from this sector
    // (we only allocate a single buffer for reading in a sector at a time)
    //

    RawVd = ALIGN_BUFFER( UnalignedSector );

    //
    //  For El Torito the Primary Volume Descriptor must be at sector 16
    //

    DiskOffset = ELTORITO_VD_SECTOR * CD_SECTOR_SIZE;

    //
    // Check if this is a valid Primary Volume Descriptor
    //

    if (EtfsReadDisk( DeviceId,
                      DiskOffset,
                      CD_SECTOR_SIZE,
                      RawVd,
                      CACHE_NEW_DATA ) != ESUCCESS) {

        return NULL;
    }

    //
    //  Initialize the string Id to match.
    //

    RtlInitString( &IsoVolId, ISO_VOL_ID );

    DiskId.Length = 5;
    DiskId.MaximumLength = 5;

    //
    //  Compare the standard identifier string in the volume descriptor with the Iso value.
    //

    DiskId.Buffer = (PCHAR) RVD_STD_ID( RawVd, TRUE );

    IsoVol = (BOOLEAN)(EtfsCompareNames( &DiskId, &IsoVolId ) == EqualTo);

    if (!IsoVol) {

        return NULL;
    }

    //
    //  Get the volume descriptor type and volume descriptor version number.
    //

    DescType = RVD_DESC_TYPE( RawVd, IsoVol );
    Version = RVD_VERSION( RawVd, IsoVol );

    //
    //  Return NULL, if the version is incorrect or this isn't a primary
    //  volume descriptor.
    //

    if (Version != VERSION_1
        || DescType != VD_PRIMARY) {

        return NULL;
    }

    //
    //  Update the fields of the Etfs context structure that apply
    //  to the volume.
    //

    EtfsStructureContext->IsIsoVol = IsoVol;
    EtfsStructureContext->LbnBlockSize = RVD_LB_SIZE( RawVd, IsoVol );
    EtfsStructureContext->LogicalBlockCount = RVD_VOL_SIZE( RawVd, IsoVol );

    //
    //  Get the information on the root directory and save it in
    //  the context structure.
    //

    RootDe = (PRAW_DIR_REC) (RVD_ROOT_DE( RawVd, IsoVol ));

    EtfsGetDirectoryInfo( RootDe,
                          IsoVol,
                          &EtfsStructureContext->RootDirSectorOffset,
                          &EtfsStructureContext->RootDirDiskOffset,
                          &EtfsStructureContext->RootDirSize );

    //
    //  Initialize the file entry table.
    //

    EtfsDeviceEntryTable.Open  = EtfsOpen;
    EtfsDeviceEntryTable.Close = EtfsClose;
    EtfsDeviceEntryTable.Read  = EtfsRead;
    EtfsDeviceEntryTable.Seek  = EtfsSeek;
    EtfsDeviceEntryTable.Write = EtfsWrite;
    EtfsDeviceEntryTable.GetFileInformation = EtfsGetFileInformation;
    EtfsDeviceEntryTable.SetFileInformation = EtfsSetFileInformation;
    EtfsDeviceEntryTable.BootFsInfo = &EtfsBootFsInfo;

    //
    //  And return the address of the table to our caller.
    //

    return &EtfsDeviceEntryTable;
}


ARC_STATUS
EtfsClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    //
    //  Indicate that the file isn't open any longer
    //

    BlFileTable[FileId].Flags.Open = 0;

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
EtfsOpen (
    IN PCHAR FileName,
    IN OPEN_MODE OpenMode,
    IN PULONG FileId
    )

/*++

Routine Description:

    This routine searches the root directory for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;

    STRING PathName;

    STRING Name;
    BOOLEAN IsDirectory;
    BOOLEAN SearchSucceeded;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    EtfsFileTableEntry = &BlFileTable[*FileId];
    EtfsStructureContext = (PETFS_STRUCTURE_CONTEXT)EtfsFileTableEntry->StructureContext;

    DeviceId = EtfsFileTableEntry->DeviceId;

    //
    // Construct a file name descriptor from the input file name.
    //

    RtlInitString( &PathName, FileName );

    //
    //  Set the starting directory to be the root directory.
    //

    EtfsStructureContext->DirSectorOffset = EtfsStructureContext->RootDirSectorOffset;
    EtfsStructureContext->DirDiskOffset = EtfsStructureContext->RootDirDiskOffset;
    EtfsStructureContext->DirSize = EtfsStructureContext->RootDirSize;

    //
    //  While the path name has some characters in it we'll go through our
    //  loop which extracts the first part of the path name and searches
    //  the current fnode (which must be a directory) for an the entry.
    //  If what we find is a directory then we have a new directory fnode
    //  and simply continue back to the top of the loop.
    //

    IsDirectory = TRUE;
    SearchSucceeded = TRUE;

    while (PathName.Length > 0
           && IsDirectory) {

        //
        //  Extract the first component.
        //

        EtfsFirstComponent( &PathName, &Name );

        //
        //  Copy the name into the filename buffer.
        //

        EtfsFileTableEntry->FileNameLength = (UCHAR) Name.Length;
        RtlMoveMemory( EtfsFileTableEntry->FileName,
                       Name.Buffer,
                       Name.Length );

        //
        //  Look to see if the file exists.
        //

        Status = EtfsSearchDirectory( &Name,
                                      &IsDirectory );

        if (Status == ENOENT) {

            SearchSucceeded = FALSE;
            break;
        }

        if (Status != ESUCCESS) {

            return Status;
        }

    }

    //
    //  If the path name length is not zero then we were trying to crack a path
    //  with an nonexistent (or non directory) name in it.  For example, we tried
    //  to crack a\b\c\d and b is not a directory or does not exist (then the path
    //  name will still contain c\d).
    //

    if (PathName.Length != 0) {

        return ENOTDIR;
    }

    //
    //  At this point we've cracked the name up to (an maybe including the last
    //  component).  We located the last component if the SearchSucceeded flag is
    //  true, otherwise the last component does not exist.  If we located the last
    //  component then this is like an open or a supersede, but not a create.
    //

    if (SearchSucceeded) {

        //
        //  Check if the last component is a directory
        //

        if (IsDirectory) {

            //
            //  For an existing directory the only valid open mode is OpenDirectory
            //  all other modes return an error
            //

            switch (OpenMode) {

            case ArcOpenReadOnly:
            case ArcOpenWriteOnly:
            case ArcOpenReadWrite:
            case ArcCreateWriteOnly:
            case ArcCreateReadWrite:
            case ArcSupersedeWriteOnly:
            case ArcSupersedeReadWrite:

                //
                //  If we reach here then the caller got a directory but didn't
                //  want to open a directory
                //

                return EISDIR;

            case ArcOpenDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to open a directory.
                //

                EtfsFileTableEntry->u.EtfsFileContext.FileSize = EtfsStructureContext->DirSize;
                EtfsFileTableEntry->u.EtfsFileContext.DiskOffset = EtfsStructureContext->DirDiskOffset;
                EtfsFileTableEntry->u.EtfsFileContext.IsDirectory = TRUE;

                EtfsFileTableEntry->Flags.Open = 1;
                EtfsFileTableEntry->Flags.Read = 1;
                EtfsFileTableEntry->Position.LowPart = 0;
                EtfsFileTableEntry->Position.HighPart = 0;

                return ESUCCESS;

            case ArcCreateDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to create a new directory
                //

                return EACCES;
            }
        }

        //
        //  If we get there then we have an existing file that is being opened.
        //  We can open existing files only read only.
        //

        switch (OpenMode) {

        case ArcOpenReadOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read only
            //

            EtfsFileTableEntry->u.EtfsFileContext.FileSize = EtfsStructureContext->DirSize;
            EtfsFileTableEntry->u.EtfsFileContext.DiskOffset = EtfsStructureContext->DirDiskOffset;
            EtfsFileTableEntry->u.EtfsFileContext.IsDirectory = FALSE;

            EtfsFileTableEntry->Flags.Open = 1;
            EtfsFileTableEntry->Flags.Read = 1;
            EtfsFileTableEntry->Position.LowPart = 0;
            EtfsFileTableEntry->Position.HighPart = 0;

            return ESUCCESS;

        case ArcOpenWriteOnly:
        case ArcOpenReadWrite:
        case ArcCreateWriteOnly:
        case ArcCreateReadWrite:
        case ArcSupersedeWriteOnly:
        case ArcSupersedeReadWrite:

            //
            //  If we reach here then we are trying to open a read only
            //  device for write.
            //

            return EROFS;

        case ArcOpenDirectory:
        case ArcCreateDirectory:

            //
            //  If we reach here then the user got a file and wanted a directory
            //

            return ENOTDIR;
        }
    }

    //
    //  If we get here the last component does not exist so we are trying to create
    //  either a new file or a directory.
    //

    switch (OpenMode) {

    case ArcOpenReadOnly:
    case ArcOpenWriteOnly:
    case ArcOpenReadWrite:
    case ArcOpenDirectory:

        //
        //  If we reach here then the user did not get a file but wanted a file
        //

        return ENOENT;

    case ArcCreateWriteOnly:
    case ArcSupersedeWriteOnly:
    case ArcCreateReadWrite:
    case ArcSupersedeReadWrite:
    case ArcCreateDirectory:

        //
        //  If we get hre the user wants to create something.
        //

        return EROFS;
    }

    //
    //  If we reach here then the path name is exhausted and we didn't
    //  reach a file so return an error to our caller
    //

    return ENOENT;
}


ARC_STATUS
EtfsRead (
    IN ULONG FileId,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;
    ULONG DiskOffset;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    EtfsFileTableEntry = &BlFileTable[FileId];
    EtfsStructureContext = (PETFS_STRUCTURE_CONTEXT)EtfsFileTableEntry->StructureContext;

    DeviceId = EtfsFileTableEntry->DeviceId;

    //
    //  Clear the transfer count and set the initial disk offset.
    //

    *Transfer = 0;

    //
    // Check for end of file.
    //

    //
    // If the file position is currently at the end of file, then return
    // a success status with no bytes read from the file. If the file
    // plus the length of the transfer is beyond the end of file, then
    // read only the remaining part of the file. Otherwise, read the
    // requested number of bytes.
    //

    if (EtfsFileTableEntry->Position.LowPart ==
        EtfsFileTableEntry->u.EtfsFileContext.FileSize) {
        return ESUCCESS;

    } else {
        if ((EtfsFileTableEntry->Position.LowPart + Length) >=
            EtfsFileTableEntry->u.EtfsFileContext.FileSize) {
            Length = EtfsFileTableEntry->u.EtfsFileContext.FileSize -
                                                EtfsFileTableEntry->Position.LowPart;
        }
    }

    DiskOffset = EtfsFileTableEntry->Position.LowPart
                 + EtfsFileTableEntry->u.EtfsFileContext.DiskOffset;

    //
    //  Read in runs (i.e., sectors) until the byte count goes to zero
    //

    while (Length > 0) {

        ULONG CurrentRunByteCount;

        //
        //  Compute the current read byte count.
        //

        if (Length > MAX_CDROM_READ) {

            CurrentRunByteCount = MAX_CDROM_READ;

        } else {

            CurrentRunByteCount = Length;
        }

        //
        //  Read from the disk.
        //

        if ((Status = EtfsReadDisk( DeviceId,
                                    DiskOffset,
                                    CurrentRunByteCount,
                                    Buffer,
                                    DONT_CACHE_NEW_DATA )) != ESUCCESS) {

            return Status;
        }

        //
        //  Update the remaining length.
        //

        Length -= CurrentRunByteCount;

        //
        //  Update the current position and the number of bytes transfered
        //

        EtfsFileTableEntry->Position.LowPart += CurrentRunByteCount;
        DiskOffset += CurrentRunByteCount;

        *Transfer += CurrentRunByteCount;

        //
        //  Update buffer to point to the next byte location to fill in
        //

        Buffer = (PCHAR)Buffer + CurrentRunByteCount;
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
EtfsSeek (
    IN ULONG FileId,
    IN PLARGE_INTEGER Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    ULONG NewPosition;

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->LowPart;

    } else {

        NewPosition = BlFileTable[FileId].Position.LowPart + Offset->LowPart;
    }

    //
    //  If the new position is greater than the file size then return
    //  an error
    //

    if (NewPosition > BlFileTable[FileId].u.EtfsFileContext.FileSize) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    BlFileTable[FileId].Position.LowPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
EtfsWrite (
    IN ULONG FileId,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Transfer );
}


ARC_STATUS
EtfsGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned for all get information requests.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    ULONG i;

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Zero out the buffer, and fill in its non-zero values
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.LowPart = FileTableEntry->u.EtfsFileContext.FileSize;

    Buffer->CurrentPosition.LowPart = FileTableEntry->Position.LowPart;
    Buffer->CurrentPosition.HighPart = 0;

    SetFlag(Buffer->Attributes, ArcReadOnlyFile);

    if (FileTableEntry->u.EtfsFileContext.IsDirectory) {

        SetFlag( Buffer->Attributes, ArcDirectoryFile );
    }

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    return ESUCCESS;
}


ARC_STATUS
EtfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    EROFS is always returned in this case.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );
}


ARC_STATUS
EtfsInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the etfs boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
EtfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more sectors from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO (logical byte offset) to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

    CacheNewData - Whether to cache new data read from the disk.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Lbo;
    Status = BlDiskCacheRead(DeviceId, 
                             &LargeLbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {

        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

VOID
EtfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    )

/*++

Routine Description:

    This routine takes an input path name and separates it into its
    first file name component and the remaining part.

Arguments:

    String - Supplies the original string being dissected.  On return
        this string will now point to the remaining part.

    FirstComponent - Returns the string representing the first file name
        in the input string.

Return Value:

    None.

--*/

{
    ULONG Index;

    //
    //  Copy over the string variable into the first component variable
    //

    *FirstComponent = *String;

    //
    //  Now if the first character in the name is a backslash then
    //  simply skip over the backslash.
    //

    if (FirstComponent->Buffer[0] == '\\') {

        FirstComponent->Buffer += 1;
        FirstComponent->Length -= 1;
    }

    //
    //  Now search the name for a backslash
    //

    for (Index = 0; Index < FirstComponent->Length; Index += 1) {

        if (FirstComponent->Buffer[Index] == '\\') {

            break;
        }
    }

    //
    //  At this point Index denotes a backslash or is equal to the length
    //  of the string.  So update string to be the remaining part.
    //  Decrement the length of the first component by the approprate
    //  amount
    //

    String->Buffer = &FirstComponent->Buffer[Index];
    String->Length = (SHORT)(FirstComponent->Length - Index);

    FirstComponent->Length = (SHORT)Index;

    //
    //  And return to our caller.
    //

    return;
}


//
//  Internal support routine
//

COMPARISON_RESULTS
EtfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    )

/*++

Routine Description:

    This routine takes two names and compare them ignoring case.  This
    routine does not do implied dot or dbcs processing.

Arguments:

    Name1 - Supplies the first name to compare

    Name2 - Supplies the second name to compare

Return Value:

    LessThan    if Name1 is lexically less than Name2
    EqualTo     if Name1 is lexically equal to Name2
    GreaterThan if Name1 is lexically greater than Name2

--*/

{
    ULONG i;
    ULONG MinimumLength;

    //
    //  Compute the smallest of the two name lengths
    //

    MinimumLength = (Name1->Length < Name2->Length ? Name1->Length : Name2->Length);

    //
    //  Now compare each character in the names.
    //

    for (i = 0; i < MinimumLength; i += 1) {

        if (ToUpper(Name1->Buffer[i]) < ToUpper(Name2->Buffer[i])) {

            return LessThan;
        }

        if (ToUpper(Name1->Buffer[i]) > ToUpper(Name2->Buffer[i])) {

            return GreaterThan;
        }
    }

    //
    //  The names compared equal up to the smallest name length so
    //  now check the name lengths
    //

    if (Name1->Length < Name2->Length) {

        return LessThan;
    }

    if (Name1->Length > Name2->Length) {

        return GreaterThan;
    }

    return EqualTo;
}


//
//  Internal support routine.
//

ARC_STATUS
EtfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine walks through the current directory in the Etfs
    context structure, looking for a match for 'Name'.  We will find
    the first non-multi-extent, non-interleave file.  We will ignore
    any version number for the file.  The details about the file, if
    found, are stored in the Etfs context structure.

Arguments:

    Name - This is the name of the file to search for.

    IsDirectory - Supplies the address of a boolean where we store
                  whether this is or is not a directory.

Return Value:

    ESUCCESS is returned if the operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG SectorOffset;
    ULONG SectorDiskOffset;
    ULONG DirentOffset;
    ULONG RemainingBytes;

    BOOLEAN ReadSector;
    BOOLEAN SearchForMultiEnd;

    UCHAR UnalignedBuffer[CD_SECTOR_SIZE + 256];

    PUCHAR RawSector;

    PRAW_DIR_REC RawDe;

    COMPARISON_RESULTS ComparisonResult;

    //
    //  Initialize the local variables.
    //

    RawSector = ALIGN_BUFFER( UnalignedBuffer );

    SearchForMultiEnd = FALSE;

    //
    //  Remember where we are within the disk, sector and directory file.
    //

    SectorOffset = EtfsStructureContext->DirSectorOffset;
    SectorDiskOffset = EtfsStructureContext->DirDiskOffset - SectorOffset;
    DirentOffset = 0;

    ReadSector = FALSE;

    //
    //  If this is the root directory, then we can return immediately.
    //

    if (Name->Length == 1
        && *Name->Buffer == '\\') {

        *IsDirectory = TRUE;

        //
        //  The structure context is already filled in.
        //

        return ESUCCESS;
    }

    //
    //  Compute the remaining bytes in this sector.
    //

    RemainingBytes = CD_SECTOR_SIZE - SectorOffset;

    //
    //  Loop until the directory is exhausted or a matching dirent for the
    //  target name is found.
    //

    while (TRUE) {

        //
        //  If the current offset is beyond the end of the directory,
        //  raise an appropriate status.
        //

        if (DirentOffset >= EtfsStructureContext->DirSize) {

            return ENOENT;
        }

        //
        //  If the remaining bytes in this sector is less than the
        //  minimum needed for a dirent, then move to the next sector.
        //

        if (RemainingBytes < MIN_DIR_REC_SIZE) {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        //
        //  If we have not read in the sector, do so now.
        //

        if (!ReadSector) {

            Status = EtfsReadDisk( EtfsFileTableEntry->DeviceId,
                                   SectorDiskOffset,
                                   CD_SECTOR_SIZE,
                                   RawSector,
                                   CACHE_NEW_DATA );

            if (Status != ESUCCESS) {

                return Status;
            }

            ReadSector = TRUE;
        }

        //
        //  If the first byte of the next dirent is '\0', then we move to
        //  the next sector.
        //

        if (*(RawSector + SectorOffset) == '\0') {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        RawDe = (PRAW_DIR_REC) ((PUCHAR) RawSector + SectorOffset);

        //
        //  If the size of this dirent extends beyond the end of this sector
        //  we abort the search.
        //

        if ((ULONG)RawDe->DirLen > RemainingBytes) {

            return EINVAL;
        }

        //
        //  We have correctly found the next dirent.  We first check whether
        //  we are looking for the last dirent for a multi-extent.
        //

        if (SearchForMultiEnd) {

            //
            //  If this is the last of a multi-extent we change our search
            //  state.
            //

            if (!FlagOn( DE_FILE_FLAGS( EtfsStructureContext->IsIsoVol, RawDe ),
                         ISO_ATTR_MULTI )) {

                SearchForMultiEnd = TRUE;
            }

        //
        //  If this is a multi-extent dirent, we change our search state.
        //

        } else if (FlagOn( DE_FILE_FLAGS( EtfsStructureContext->IsIsoVol, RawDe ),
                           ISO_ATTR_MULTI )) {

            SearchForMultiEnd = TRUE;

        //
        //  If this is a file match, we update the Etfs context structure
        //  and the 'IsDirectory' flag.
        //

        } else {

            ComparisonResult = EtfsFileMatch( RawDe, Name );

            if (ComparisonResult == EqualTo) {

                EtfsGetDirectoryInfo( RawDe,
                                      EtfsStructureContext->IsIsoVol,
                                      &EtfsStructureContext->DirSectorOffset,
                                      &EtfsStructureContext->DirDiskOffset,
                                      &EtfsStructureContext->DirSize );

                *IsDirectory = FlagOn( DE_FILE_FLAGS( EtfsStructureContext->IsIsoVol, RawDe ),
                                       ISO_ATTR_DIRECTORY );

                return ESUCCESS;

            //
            //  If we have passed this file in the directory, then
            //  exit with the appropriate error code.
            //

            } else if (ComparisonResult == GreaterThan) {

                return ENOENT;
            }
        }

        //
        //  Otherwise we simply compute the next sector offset, disk offset
        //  and file offset.
        //

        SectorOffset += RawDe->DirLen;
        DirentOffset += RawDe->DirLen;
        RemainingBytes -= RawDe->DirLen;
    }

    return ESUCCESS;
}


//
//  Internal support routine.
//

VOID
EtfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine takes a pointer to a raw directory structure on the disk
    and computes the file size, disk offset and file length for the
    directory entry.

Arguments:

    DirEntry - This points to raw data from the disk.

    IsoVol - Boolean indicating that this is an ISO volume.

    SectorOffset - This supplies the address to store the sector offset of the
                   start of the disk data.

    DiskOffset - This supplies the address to store the disk offset of the
                 start of the disk data.

    Length - This supplies the address to store the number of bytes in
             the file referred by this disk directory.

Return Value:

    None.

--*/

{
    //
    //  The disk offset is length of the Xar blocks added to the starting
    //  location for the file.
    //

    CopyUshort2( DiskOffset, DirEntry->FileLoc );
    *DiskOffset *= EtfsStructureContext->LbnBlockSize;
    *DiskOffset += (DirEntry->XarLen * EtfsStructureContext->LbnBlockSize);

    //
    //  The sector offset is the least significant bytes of the disk offset.
    //

    *SectorOffset = *DiskOffset & (CD_SECTOR_SIZE - 1);

    //
    //  The file size is pulled straight from the dirent.   We round it
    //  to a sector size to protect us from faulty disks if this is a
    //  directory.  Otherwise we use it directly from the dirent.
    //

    CopyUshort2( Length, DirEntry->DataLen );

    if (FlagOn( DE_FILE_FLAGS( IsoVol, DirEntry ), ISO_ATTR_DIRECTORY )) {

        *Length += (*SectorOffset + CD_SECTOR_SIZE - 1);
        *Length &= ~(CD_SECTOR_SIZE - 1);
        *Length -= *SectorOffset;
    }

    return;
}


//
//  Internal support routine.
//

COMPARISON_RESULTS
EtfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    )

{
    STRING DirentString;
    ULONG Count;

    PCHAR StringPtr;

    //
    //  We never match either '\0' or '\1'.  We will return 'LessThan' in
    //  all of these cases.
    //

    if (DirEntry->FileIdLen == 1
        && (DirEntry->FileId[0] == '\0'
            || DirEntry->FileId[0] == '\1')) {

        return LessThan;
    }

    //
    //  We assume that we can use the entire file name in the dirent.
    //

    DirentString.Length = DirEntry->FileIdLen;
    DirentString.Buffer = (PCHAR)DirEntry->FileId;

    //
    //  We walk backwards through the dirent name to check for the
    //  existance of a ';' character.  We then set the string length
    //  to this position.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == ';') {

            DirentString.Length = (SHORT)Count;
            break;
        }

        StringPtr--;
    }

    //
    //  We also check for a terminating '.' character and truncate it.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == '.') {

            DirentString.Length = (SHORT)Count;

        } else {

            break;
        }

        StringPtr--;
    }

    //
    //  We now have the two filenames to compare.  The result of this
    //  operation is simply the comparison of the two of them.
    //

    DirentString.MaximumLength = DirentString.Length;

    return EtfsCompareNames( &DirentString, FileName );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\cdfsboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    CdfsBoot.c

Abstract:

    This module implements the Cdfs boot file system used by the operating
    system loader.

Author:

    Brian Andrew    [BrianAn]   05-Aug-1991

Revision History:

--*/

#include "bootlib.h"
#include "cd.h"
#include "blcache.h"

BOOTFS_INFO CdfsBootFsInfo = {L"cdfs"};


//
//  Local procedure prototypes.
//

ARC_STATUS
CdfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

VOID
CdfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    );

typedef enum _COMPARISON_RESULTS {
    LessThan = -1,
    EqualTo = 0,
    GreaterThan = 1
} COMPARISON_RESULTS;

COMPARISON_RESULTS
CdfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    );

ARC_STATUS
CdfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    );

VOID
CdfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    );

COMPARISON_RESULTS
CdfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    );


typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                               \
    ((PUSHORT2)(Dst))->Ushort[0] = ((UNALIGNED USHORT2 *)(Src))->Ushort[0]; \
    ((PUSHORT2)(Dst))->Ushort[1] = ((UNALIGNED USHORT2 *)(Src))->Ushort[1]; \
    }

//
//  The following macro upcases a single ascii character
//

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define SetFlag(Flags,SingleFlag) { (Flags) |= (SingleFlag); }

//
//  The following macro indicate if the flag is on or off
//

#define FlagOn(Flags,SingleFlag) ((BOOLEAN)(       \
    (((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE) \
    )                                              \
)


//
//  Define global data.
//
//  Context Pointer - This is a pointer to the context for the current file
//      operation that is active.
//

PCDFS_STRUCTURE_CONTEXT CdfsStructureContext;

//
//  File Descriptor - This is a pointer to the file descriptor for the current
//      file operation that is active.
//

PBL_FILE_TABLE CdfsFileTableEntry;

//
//  File entry table - This is a structure that provides entry to the Cdfs
//      file system procedures. It is exported when a Cdfs file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE CdfsDeviceEntryTable;


PBL_DEVICE_ENTRY_TABLE
IsCdfsFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a Cdfs file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a Hpfs file structure context.

Return Value:

    A pointer to the Cdfs entry table is returned if the partition is
    recognized as containing a Cdfs volume. Otherwise, NULL is returned.

--*/

{
    UCHAR UnalignedSector[CD_SECTOR_SIZE + 256];

    PRAW_ISO_VD RawVd;
    PRAW_DIR_REC RootDe;

    UCHAR DescType;
    UCHAR Version;

    BOOLEAN IsoVol;
    BOOLEAN HsgVol;

    STRING IsoVolId;
    STRING HsgVolId;

    STRING DiskId;

    ULONG DiskOffset;

    //
    //  Capture in our global variable the Cdfs Structure context record
    //

    CdfsStructureContext = (PCDFS_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory((PVOID)CdfsStructureContext, sizeof(CDFS_STRUCTURE_CONTEXT));

    //
    //  Compute the properly aligned buffer for reading in cdrom
    //  sectors.
    //

    RawVd = ALIGN_BUFFER( UnalignedSector );

    //
    //  Initialize the string Id's to match.
    //

    RtlInitString( &IsoVolId, ISO_VOL_ID );
    RtlInitString( &HsgVolId, HSG_VOL_ID );

    DiskId.Length = 5;
    DiskId.MaximumLength = 5;

    //
    //  We initially start at the first volume descriptor.
    //

    DiskOffset = FIRST_VD_SECTOR * CD_SECTOR_SIZE;

    //
    //  We loop, reading in volume descriptors until we find either
    //  a primary, terminator or a sector that cannot contain either.
    //

    while (TRUE) {

        //
        //  Initialize the Hsg boolean.
        //

        HsgVol = FALSE;

        //
        //  Read the sector at our current position.  Return NULL on an
        //  error
        //

        if (CdfsReadDisk( DeviceId,
                          DiskOffset,
                          CD_SECTOR_SIZE,
                          RawVd,
                          CACHE_NEW_DATA) != ESUCCESS) {

            return NULL;
        }

        //
        //  Compare the Id string in the volume descriptor with the Iso
        //  and Hsg values.
        //

        DiskId.Buffer = (PCHAR) RVD_STD_ID( RawVd, TRUE );

        IsoVol = (BOOLEAN)(CdfsCompareNames( &DiskId, &IsoVolId ) == EqualTo);

        if (!IsoVol) {

            //
            //  Repeat the test with the Hsg Id string.
            //

            DiskId.Buffer = (PCHAR) RVD_STD_ID( RawVd, FALSE );

            HsgVol = (BOOLEAN)(CdfsCompareNames( &DiskId, &HsgVolId ) == EqualTo);

            //
            //  If neither, then return NULL.
            //

            if (!HsgVol) {

                return NULL;
            }
        }

        //
        //  Get the volume descriptor type and standard version number.
        //

        DescType = RVD_DESC_TYPE( RawVd, IsoVol );
        Version = RVD_VERSION( RawVd, IsoVol );

        //
        //  Return NULL, if the version is incorrect or this is a terminal
        //  volume descriptor.
        //

        if (Version != VERSION_1
            || DescType == VD_TERMINATOR) {

            return NULL;
        }

        //
        //  If this is a primary volume descriptor, then our search is over.
        //

        if (DescType == VD_PRIMARY) {

            //
            //  Update the fields of the Cdfs context structure that apply
            //  to the volume.
            //

            CdfsStructureContext->IsIsoVol = IsoVol;
            CdfsStructureContext->LbnBlockSize = RVD_LB_SIZE( RawVd, IsoVol );
            CdfsStructureContext->LogicalBlockCount = RVD_VOL_SIZE( RawVd, IsoVol );

            //
            //  Get the information on the root directory and save it in
            //  the context structure.
            //

            RootDe = (PRAW_DIR_REC) (RVD_ROOT_DE( RawVd, IsoVol ));

            CdfsGetDirectoryInfo( RootDe,
                                  IsoVol,
                                  &CdfsStructureContext->RootDirSectorOffset,
                                  &CdfsStructureContext->RootDirDiskOffset,
                                  &CdfsStructureContext->RootDirSize );

            //
            //  Exit the loop.
            //

            break;
        }

        //
        //  Otherwise move to the next sector.
        //

        DiskOffset += CD_SECTOR_SIZE;
    }

    //
    //  Initialize the file entry table.
    //

    CdfsDeviceEntryTable.Open  = CdfsOpen;
    CdfsDeviceEntryTable.Close = CdfsClose;
    CdfsDeviceEntryTable.Read  = CdfsRead;
    CdfsDeviceEntryTable.Seek  = CdfsSeek;
    CdfsDeviceEntryTable.Write = CdfsWrite;
    CdfsDeviceEntryTable.GetFileInformation = CdfsGetFileInformation;
    CdfsDeviceEntryTable.SetFileInformation = CdfsSetFileInformation;
    CdfsDeviceEntryTable.BootFsInfo = &CdfsBootFsInfo;

    //
    //  And return the address of the table to our caller.
    //

    return &CdfsDeviceEntryTable;
}


ARC_STATUS
CdfsClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    //
    //  Indicate that the file isn't open any longer
    //

    BlFileTable[FileId].Flags.Open = 0;

    //
    //  And return to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
CdfsOpen (
    IN CHAR * FIRMWARE_PTR FileName,
    IN OPEN_MODE OpenMode,
    IN ULONG * FIRMWARE_PTR FileId
    )

/*++

Routine Description:

    This routine searches the root directory for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;

    STRING PathName;

    STRING Name;
    BOOLEAN IsDirectory;
    BOOLEAN SearchSucceeded;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    CdfsFileTableEntry = &BlFileTable[*FileId];
    CdfsStructureContext = (PCDFS_STRUCTURE_CONTEXT)CdfsFileTableEntry->StructureContext;

    DeviceId = CdfsFileTableEntry->DeviceId;

    //
    // Construct a file name descriptor from the input file name.
    //

    RtlInitString( &PathName, FileName );

    //
    //  Set the starting directory to be the root directory.
    //

    CdfsStructureContext->DirSectorOffset = CdfsStructureContext->RootDirSectorOffset;
    CdfsStructureContext->DirDiskOffset = CdfsStructureContext->RootDirDiskOffset;
    CdfsStructureContext->DirSize = CdfsStructureContext->RootDirSize;

    //
    //  While the path name has some characters in it we'll go through our
    //  loop which extracts the first part of the path name and searches
    //  the current fnode (which must be a directory) for an the entry.
    //  If what we find is a directory then we have a new directory fnode
    //  and simply continue back to the top of the loop.
    //

    IsDirectory = TRUE;
    SearchSucceeded = TRUE;

    while (PathName.Length > 0
           && IsDirectory) {

        //
        //  Extract the first component.
        //

        CdfsFirstComponent( &PathName, &Name );

        //
        //  Copy the name into the filename buffer.
        //

        CdfsFileTableEntry->FileNameLength = (UCHAR) Name.Length;
        RtlMoveMemory( CdfsFileTableEntry->FileName,
                       Name.Buffer,
                       Name.Length );

        //
        //  Look to see if the file exists.
        //

        Status = CdfsSearchDirectory( &Name,
                                      &IsDirectory );

        if (Status == ENOENT) {

            SearchSucceeded = FALSE;
            break;
        }

        if (Status != ESUCCESS) {

            return Status;
        }

    }

    //
    //  If the path name length is not zero then we were trying to crack a path
    //  with an nonexistent (or non directory) name in it.  For example, we tried
    //  to crack a\b\c\d and b is not a directory or does not exist (then the path
    //  name will still contain c\d).
    //

    if (PathName.Length != 0) {

        return ENOTDIR;
    }

    //
    //  At this point we've cracked the name up to (an maybe including the last
    //  component).  We located the last component if the SearchSucceeded flag is
    //  true, otherwise the last component does not exist.  If we located the last
    //  component then this is like an open or a supersede, but not a create.
    //

    if (SearchSucceeded) {

        //
        //  Check if the last component is a directory
        //

        if (IsDirectory) {

            //
            //  For an existing directory the only valid open mode is OpenDirectory
            //  all other modes return an error
            //

            switch (OpenMode) {

            case ArcOpenReadOnly:
            case ArcOpenWriteOnly:
            case ArcOpenReadWrite:
            case ArcCreateWriteOnly:
            case ArcCreateReadWrite:
            case ArcSupersedeWriteOnly:
            case ArcSupersedeReadWrite:

                //
                //  If we reach here then the caller got a directory but didn't
                //  want to open a directory
                //

                return EISDIR;

            case ArcOpenDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to open a directory.
                //

                CdfsFileTableEntry->u.CdfsFileContext.FileSize = CdfsStructureContext->DirSize;
                CdfsFileTableEntry->u.CdfsFileContext.DiskOffset = CdfsStructureContext->DirDiskOffset;
                CdfsFileTableEntry->u.CdfsFileContext.IsDirectory = TRUE;

                CdfsFileTableEntry->Flags.Open = 1;
                CdfsFileTableEntry->Flags.Read = 1;
                CdfsFileTableEntry->Position.LowPart = 0;
                CdfsFileTableEntry->Position.HighPart = 0;

                return ESUCCESS;

            case ArcCreateDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to create a new directory
                //

                return EACCES;
            }
        }

        //
        //  If we get there then we have an existing file that is being opened.
        //  We can open existing files only read only.
        //

        switch (OpenMode) {

        case ArcOpenReadOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read only
            //

            CdfsFileTableEntry->u.CdfsFileContext.FileSize = CdfsStructureContext->DirSize;
            CdfsFileTableEntry->u.CdfsFileContext.DiskOffset = CdfsStructureContext->DirDiskOffset;
            CdfsFileTableEntry->u.CdfsFileContext.IsDirectory = FALSE;

            CdfsFileTableEntry->Flags.Open = 1;
            CdfsFileTableEntry->Flags.Read = 1;
            CdfsFileTableEntry->Position.LowPart = 0;
            CdfsFileTableEntry->Position.HighPart = 0;

            return ESUCCESS;

        case ArcOpenWriteOnly:
        case ArcOpenReadWrite:
        case ArcCreateWriteOnly:
        case ArcCreateReadWrite:
        case ArcSupersedeWriteOnly:
        case ArcSupersedeReadWrite:

            //
            //  If we reach here then we are trying to open a read only
            //  device for write.
            //

            return EROFS;

        case ArcOpenDirectory:
        case ArcCreateDirectory:

            //
            //  If we reach here then the user got a file and wanted a directory
            //

            return ENOTDIR;
        }
    }

    //
    //  If we get here the last component does not exist so we are trying to create
    //  either a new file or a directory.
    //

    switch (OpenMode) {

    case ArcOpenReadOnly:
    case ArcOpenWriteOnly:
    case ArcOpenReadWrite:
    case ArcOpenDirectory:

        //
        //  If we reach here then the user did not get a file but wanted a file
        //

        return ENOENT;

    case ArcCreateWriteOnly:
    case ArcSupersedeWriteOnly:
    case ArcCreateReadWrite:
    case ArcSupersedeReadWrite:
    case ArcCreateDirectory:

        //
        //  If we get hre the user wants to create something.
        //

        return EROFS;
    }

    //
    //  If we reach here then the path name is exhausted and we didn't
    //  reach a file so return an error to our caller
    //

    return ENOENT;
}


ARC_STATUS
CdfsRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG DeviceId;
    ULONG DiskOffset;

    //
    //  Save the address of the file table entry, context area, and the device
    //  id in use.
    //

    CdfsFileTableEntry = &BlFileTable[FileId];
    CdfsStructureContext = (PCDFS_STRUCTURE_CONTEXT)CdfsFileTableEntry->StructureContext;

    DeviceId = CdfsFileTableEntry->DeviceId;

    //
    //  Clear the transfer count and set the initial disk offset.
    //

    *Transfer = 0;

    //
    // Check for end of file.
    //

    //
    // If the file position is currently at the end of file, then return
    // a success status with no bytes read from the file. If the file
    // plus the length of the transfer is beyond the end of file, then
    // read only the remaining part of the file. Otherwise, read the
    // requested number of bytes.
    //

    if (CdfsFileTableEntry->Position.LowPart ==
        CdfsFileTableEntry->u.CdfsFileContext.FileSize) {
        return ESUCCESS;

    } else {
        if ((CdfsFileTableEntry->Position.LowPart + Length) >=
            CdfsFileTableEntry->u.CdfsFileContext.FileSize) {
            Length = CdfsFileTableEntry->u.CdfsFileContext.FileSize -
                                                CdfsFileTableEntry->Position.LowPart;
        }
    }

    DiskOffset = CdfsFileTableEntry->Position.LowPart
                 + CdfsFileTableEntry->u.CdfsFileContext.DiskOffset;

    //
    //  Read in runs (i.e., sectors) until the byte count goes to zero
    //

    while (Length > 0) {

        ULONG CurrentRunByteCount;

        //
        //  Compute the current read byte count.
        //

        if (Length > MAX_CDROM_READ) {

            CurrentRunByteCount = MAX_CDROM_READ;

        } else {

            CurrentRunByteCount = Length;
        }

        //
        //  Read from the disk.
        //

        if ((Status = CdfsReadDisk( DeviceId,
                                    DiskOffset,
                                    CurrentRunByteCount,
                                    Buffer,
                                    DONT_CACHE_NEW_DATA)) != ESUCCESS) {

            return Status;
        }

        //
        //  Update the remaining length.
        //

        Length -= CurrentRunByteCount;

        //
        //  Update the current position and the number of bytes transfered
        //

        CdfsFileTableEntry->Position.LowPart += CurrentRunByteCount;
        DiskOffset += CurrentRunByteCount;

        *Transfer += CurrentRunByteCount;

        //
        //  Update buffer to point to the next byte location to fill in
        //

        Buffer = (PCHAR)Buffer + CurrentRunByteCount;
    }

    //
    //  If we get here then remaining sector count is zero so we can
    //  return success to our caller
    //

    return ESUCCESS;
}


ARC_STATUS
CdfsSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )

/*++

Routine Description:

    This routine seeks to the specified position for the file specified
    by the file id.

Arguments:

    FileId - Supplies the file table index.

    Offset - Supplies the offset in the file to position to.

    SeekMode - Supplies the mode of the seek operation.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    ULONG NewPosition;

    //
    //  Compute the new position
    //

    if (SeekMode == SeekAbsolute) {

        NewPosition = Offset->LowPart;

    } else {

        NewPosition = BlFileTable[FileId].Position.LowPart + Offset->LowPart;
    }

    //
    //  If the new position is greater than the file size then return
    //  an error
    //

    if (NewPosition > BlFileTable[FileId].u.CdfsFileContext.FileSize) {

        return EINVAL;
    }

    //
    //  Otherwise set the new position and return to our caller
    //

    BlFileTable[FileId].Position.LowPart = NewPosition;

    return ESUCCESS;
}


ARC_STATUS
CdfsWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine writes data to the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that contains the data
        written.

    Length - Supplies the number of bytes that are to be written.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the write operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Transfer );
}


ARC_STATUS
CdfsGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned for all get information requests.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    ULONG i;

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];

    //
    //  Zero out the buffer, and fill in its non-zero values
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.LowPart = FileTableEntry->u.CdfsFileContext.FileSize;

    Buffer->CurrentPosition.LowPart = FileTableEntry->Position.LowPart;
    Buffer->CurrentPosition.HighPart = 0;

    SetFlag(Buffer->Attributes, ArcReadOnlyFile);

    if (FileTableEntry->u.CdfsFileContext.IsDirectory) {

        SetFlag( Buffer->Attributes, ArcDirectoryFile );
    }

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    return ESUCCESS;
}


ARC_STATUS
CdfsSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )

/*++

Routine Description:

    This routine sets the file attributes of the indicated file

Arguments:

    FileId - Supplies the File Id for the operation

    AttributeFlags - Supplies the value (on or off) for each attribute being modified

    AttributeMask - Supplies a mask of the attributes being altered.  All other
        file attributes are left alone.

Return Value:

    EROFS is always returned in this case.

--*/

{
    return EROFS;

    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );
}


ARC_STATUS
CdfsInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the cdfs boot filesystem.
    Currently this is a no-op.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    return ESUCCESS;
}


//
//  Internal support routine
//

ARC_STATUS
CdfsReadDisk(
    IN ULONG DeviceId,
    IN ULONG Lbo,
    IN ULONG ByteCount,
    IN OUT PVOID Buffer,
    IN BOOLEAN CacheNewData
    )

/*++

Routine Description:

    This routine reads in zero or more sectors from the specified device.

Arguments:

    DeviceId - Supplies the device id to use in the arc calls.

    Lbo - Supplies the LBO to start reading from.

    ByteCount - Supplies the number of bytes to read.

    Buffer - Supplies a pointer to the buffer to read the bytes into.

Return Value:

    ESUCCESS is returned if the read operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    LARGE_INTEGER LargeLbo;
    ARC_STATUS Status;
    ULONG i;

    //
    //  Special case the zero byte read request
    //

    if (ByteCount == 0) {

        return ESUCCESS;
    }

    //
    // Issue the read through the cache.
    //

    LargeLbo.QuadPart = Lbo;
    Status = BlDiskCacheRead(DeviceId, 
                             &LargeLbo, 
                             Buffer, 
                             ByteCount, 
                             &i,
                             CacheNewData);

    if (Status != ESUCCESS) {
        return Status;
    }

    //
    //  Make sure we got back the amount requested
    //

    if (ByteCount != i) {

        return EIO;
    }

    //
    //  Everything is fine so return success to our caller
    //

    return ESUCCESS;
}


//
//  Internal support routine
//

VOID
CdfsFirstComponent(
    IN OUT PSTRING String,
    OUT PSTRING FirstComponent
    )

/*++

Routine Description:

    This routine takes an input path name and separates it into its
    first file name component and the remaining part.

Arguments:

    String - Supplies the original string being dissected.  On return
        this string will now point to the remaining part.

    FirstComponent - Returns the string representing the first file name
        in the input string.

Return Value:

    None.

--*/

{
    ULONG Index;

    //
    //  Copy over the string variable into the first component variable
    //

    *FirstComponent = *String;

    //
    //  Now if the first character in the name is a backslash then
    //  simply skip over the backslash.
    //

    if (FirstComponent->Buffer[0] == '\\') {

        FirstComponent->Buffer += 1;
        FirstComponent->Length -= 1;
    }

    //
    //  Now search the name for a backslash
    //

    for (Index = 0; Index < FirstComponent->Length; Index += 1) {

        if (FirstComponent->Buffer[Index] == '\\') {

            break;
        }
    }

    //
    //  At this point Index denotes a backslash or is equal to the length
    //  of the string.  So update string to be the remaining part.
    //  Decrement the length of the first component by the approprate
    //  amount
    //

    String->Buffer = &FirstComponent->Buffer[Index];
    String->Length = (SHORT)(FirstComponent->Length - Index);

    FirstComponent->Length = (SHORT)Index;

    //
    //  And return to our caller.
    //

    return;
}


//
//  Internal support routine
//

COMPARISON_RESULTS
CdfsCompareNames(
    IN PSTRING Name1,
    IN PSTRING Name2
    )

/*++

Routine Description:

    This routine takes two names and compare them ignoring case.  This
    routine does not do implied dot or dbcs processing.

Arguments:

    Name1 - Supplies the first name to compare

    Name2 - Supplies the second name to compare

Return Value:

    LessThan    if Name1 is lexically less than Name2
    EqualTo     if Name1 is lexically equal to Name2
    GreaterThan if Name1 is lexically greater than Name2

--*/

{
    ULONG i;
    ULONG MinimumLength;

    //
    //  Compute the smallest of the two name lengths
    //

    MinimumLength = (Name1->Length < Name2->Length ? Name1->Length : Name2->Length);

    //
    //  Now compare each character in the names.
    //

    for (i = 0; i < MinimumLength; i += 1) {

        if (ToUpper(Name1->Buffer[i]) < ToUpper(Name2->Buffer[i])) {

            return LessThan;
        }

        if (ToUpper(Name1->Buffer[i]) > ToUpper(Name2->Buffer[i])) {

            return GreaterThan;
        }
    }

    //
    //  The names compared equal up to the smallest name length so
    //  now check the name lengths
    //

    if (Name1->Length < Name2->Length) {

        return LessThan;
    }

    if (Name1->Length > Name2->Length) {

        return GreaterThan;
    }

    return EqualTo;
}


//
//  Internal support routine.
//

ARC_STATUS
CdfsSearchDirectory(
    IN PSTRING Name,
    OUT PBOOLEAN IsDirectory
    )

/*++

Routine Description:

    This routine walks through the current directory in the Cdfs
    context structure, looking for a match for 'Name'.  We will find
    the first non-multi-extent, non-interleave file.  We will ignore
    any version number for the file.  The details about the file, if
    found, are stored in the Cdfs context structure.

Arguments:

    Name - This is the name of the file to search for.

    IsDirectory - Supplies the address of a boolean where we store
                  whether this is or is not a directory.

Return Value:

    ESUCCESS is returned if the operation is successful. Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    ARC_STATUS Status;

    ULONG SectorOffset;
    ULONG SectorDiskOffset;
    ULONG DirentOffset;
    ULONG RemainingBytes;

    BOOLEAN ReadSector;
    BOOLEAN SearchForMultiEnd;

    UCHAR UnalignedBuffer[CD_SECTOR_SIZE + 256];

    PUCHAR RawSector;

    PRAW_DIR_REC RawDe;

    COMPARISON_RESULTS ComparisonResult;

    //
    //  Initialize the local variables.
    //

    RawSector = ALIGN_BUFFER( UnalignedBuffer );

    SearchForMultiEnd = FALSE;

    //
    //  Remember where we are within the disk, sector and directory file.
    //

    SectorOffset = CdfsStructureContext->DirSectorOffset;
    SectorDiskOffset = CdfsStructureContext->DirDiskOffset - SectorOffset;
    DirentOffset = 0;

    ReadSector = FALSE;

    //
    //  If this is the root directory, then we can return immediately.
    //

    if (Name->Length == 1
        && *Name->Buffer == '\\') {

        *IsDirectory = TRUE;

        //
        //  The structure context is already filled in.
        //

        return ESUCCESS;
    }

    //
    //  Compute the remaining bytes in this sector.
    //

    RemainingBytes = CD_SECTOR_SIZE - SectorOffset;

    //
    //  Loop until the directory is exhausted or a matching dirent for the
    //  target name is found.
    //

    while (TRUE) {

        //
        //  If the current offset is beyond the end of the directory,
        //  raise an appropriate status.
        //

        if (DirentOffset >= CdfsStructureContext->DirSize) {

            return ENOENT;
        }

        //
        //  If the remaining bytes in this sector is less than the
        //  minimum needed for a dirent, then move to the next sector.
        //

        if (RemainingBytes < MIN_DIR_REC_SIZE) {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        //
        //  If we have not read in the sector, do so now.
        //

        if (!ReadSector) {

            Status = CdfsReadDisk( CdfsFileTableEntry->DeviceId,
                                   SectorDiskOffset,
                                   CD_SECTOR_SIZE,
                                   RawSector,
                                   CACHE_NEW_DATA);

            if (Status != ESUCCESS) {

                return Status;
            }

            ReadSector = TRUE;
        }

        //
        //  If the first byte of the next dirent is '\0', then we move to
        //  the next sector.
        //

        if (*(RawSector + SectorOffset) == '\0') {

            SectorDiskOffset += CD_SECTOR_SIZE;
            DirentOffset += RemainingBytes;
            SectorOffset = 0;
            RemainingBytes = CD_SECTOR_SIZE;
            ReadSector = FALSE;

            continue;
        }

        RawDe = (PRAW_DIR_REC) ((PUCHAR) RawSector + SectorOffset);

        //
        //  If the size of this dirent extends beyond the end of this sector
        //  we abort the search.
        //

        if ((ULONG)RawDe->DirLen > RemainingBytes) {

            return EINVAL;
        }

        //
        //  We have correctly found the next dirent.  We first check whether
        //  we are looking for the last dirent for a multi-extent.
        //

        if (SearchForMultiEnd) {

            //
            //  If this is the last of a multi-extent we change our search
            //  state.
            //

            if (!FlagOn( DE_FILE_FLAGS( CdfsStructureContext->IsIsoVol, RawDe ),
                         ISO_ATTR_MULTI )) {

                SearchForMultiEnd = TRUE;
            }

        //
        //  If this is a multi-extent dirent, we change our search state.
        //

        } else if (FlagOn( DE_FILE_FLAGS( CdfsStructureContext->IsIsoVol, RawDe ),
                           ISO_ATTR_MULTI )) {

            SearchForMultiEnd = TRUE;

        //
        //  If this is a file match, we update the Cdfs context structure
        //  and the 'IsDirectory' flag.
        //

        } else {

            ComparisonResult = CdfsFileMatch( RawDe, Name );

            if (ComparisonResult == EqualTo) {

                CdfsGetDirectoryInfo( RawDe,
                                      CdfsStructureContext->IsIsoVol,
                                      &CdfsStructureContext->DirSectorOffset,
                                      &CdfsStructureContext->DirDiskOffset,
                                      &CdfsStructureContext->DirSize );

                *IsDirectory = FlagOn( DE_FILE_FLAGS( CdfsStructureContext->IsIsoVol, RawDe ),
                                       ISO_ATTR_DIRECTORY );

                return ESUCCESS;

            //
            //  If we have passed this file in the directory, then
            //  exit with the appropriate error code.
            //

            } else if (ComparisonResult == GreaterThan) {

                return ENOENT;
            }
        }

        //
        //  Otherwise we simply compute the next sector offset, disk offset
        //  and file offset.
        //

        SectorOffset += RawDe->DirLen;
        DirentOffset += RawDe->DirLen;
        RemainingBytes -= RawDe->DirLen;
    }

    return ESUCCESS;
}


//
//  Internal support routine.
//

VOID
CdfsGetDirectoryInfo(
    IN PRAW_DIR_REC DirEntry,
    IN BOOLEAN IsoVol,
    OUT PULONG SectorOffset,
    OUT PULONG DiskOffset,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine takes a pointer to a raw directory structure on the disk
    and computes the file size, disk offset and file length for the
    directory entry.

Arguments:

    DirEntry - This points to raw data from the disk.

    IsoVol - Boolean indicating that this is an ISO volume.

    SectorOffset - This supplies the address to store the sector offset of the
                   start of the disk data.

    DiskOffset - This supplies the address to store the disk offset of the
                 start of the disk data.

    Length - This supplies the address to store the number of bytes in
             the file referred by this disk directory.

Return Value:

    None.

--*/

{
    //
    //  The disk offset is length of the Xar blocks added to the starting
    //  location for the file.
    //

    CopyUshort2( DiskOffset, DirEntry->FileLoc );
    *DiskOffset *= CdfsStructureContext->LbnBlockSize;
    *DiskOffset += (DirEntry->XarLen * CdfsStructureContext->LbnBlockSize);

    //
    //  The sector offset is the least significant bytes of the disk offset.
    //

    *SectorOffset = *DiskOffset & (CD_SECTOR_SIZE - 1);

    //
    //  The file size is pulled straight from the dirent.   We round it
    //  to a sector size to protect us from faulty disks if this is a
    //  directory.  Otherwise we use it directly from the dirent.
    //

    CopyUshort2( Length, DirEntry->DataLen );

    if (FlagOn( DE_FILE_FLAGS( IsoVol, DirEntry ), ISO_ATTR_DIRECTORY )) {

        *Length += (*SectorOffset + CD_SECTOR_SIZE - 1);
        *Length &= ~(CD_SECTOR_SIZE - 1);
        *Length -= *SectorOffset;
    }

    return;
}


//
//  Internal support routine.
//

COMPARISON_RESULTS
CdfsFileMatch(
    IN PRAW_DIR_REC DirEntry,
    IN PSTRING FileName
    )

{
    STRING DirentString;
    ULONG Count;

    PCHAR StringPtr;

    //
    //  We never match either '\0' or '\1'.  We will return 'LessThan' in
    //  all of these cases.
    //

    if (DirEntry->FileIdLen == 1
        && (DirEntry->FileId[0] == '\0'
            || DirEntry->FileId[0] == '\1')) {

        return LessThan;
    }

    //
    //  We assume that we can use the entire file name in the dirent.
    //

    DirentString.Length = DirEntry->FileIdLen;
    DirentString.Buffer = (PCHAR) DirEntry->FileId;

    //
    //  We walk backwards through the dirent name to check for the
    //  existance of a ';' character.  We then set the string length
    //  to this position.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == ';') {

            DirentString.Length = (SHORT)Count;
            break;
        }

        StringPtr--;
    }

    //
    //  We also check for a terminating '.' character and truncate it.
    //

    StringPtr = DirentString.Buffer + DirentString.Length - 1;
    Count = DirentString.Length;

    while (Count--) {

        if (*StringPtr == '.') {

            DirentString.Length = (SHORT)Count;

        } else {

            break;
        }

        StringPtr--;
    }

    //
    //  We now have the two filenames to compare.  The result of this
    //  operation is simply the comparison of the two of them.
    //

    DirentString.MaximumLength = DirentString.Length;

    return CdfsCompareNames( &DirentString, FileName );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\makefile.inc ===
!if $(386)

#
# First, clean out any amd64 modules in the i386 directory
#

amd64clean:
    -del $(O)\amd64thk.h        >nul 2>nul
    -del $(O)\amd64thk.c       	>nul 2>nul
    -del $(O)\amd64thk.obj      >nul 2>nul
    -del obj\amd64\amd64thk.obj	>nul 2>nul

clean: amd64clean

THUNK_COMPILER_FLAGS=-I$(INCLUDES:;= -I)
THUNK_COMPILER_FLAGS=$(THUNK_COMPILER_FLAGS) -I$(CRT_INC_PATH:;= -I)
THUNK_COMPILER_FLAGS=$(THUNK_COMPILER_FLAGS) -I$(BASE_INC_PATH:;= -I)
THUNK_COMPILER_FLAGS=$(THUNK_COMPILER_FLAGS) /c -DAMD64 -D_M_AMD64 -D_AMD64_
THUNK_COMPILER_FLAGS=$(THUNK_COMPILER_FLAGS) -D_daytona_ -DWINNT=1
THUNK_COMPILER_FLAGS=$(THUNK_COMPILER_FLAGS) -D_CROSS_PLATFORM_ -DDEVL=1

AMD64_COMPILER=$(BASEDIR)\tools\win64\x86\amd64\cl.exe
AMD64_BLDRTHNK=bldrthnk.exe

$(O)\amd64thk.c4: ..\amd64\amd64thk.m4
    m4 -DBASE_INC_PATH=$(PROJECT_ROOT)\tools\bldrthnk < $** > $@

obj\amd64\amd64thk.obj: $(O)\amd64thk.c4
    -md obj\amd64
    $(AMD64_COMPILER) @<<$(CL_RSP)
$(THUNK_COMPILER_FLAGS) -Fo$@ /Tc$**
<<NOKEEP

# Don't do LTCG on this object

obj\i386\amd64thk.obj: $(O)\amd64thk.c4
    $(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$@ $(USE_FC) $(USECXX_FLAG) /Tc$**
$(EX_C_COMPILER_FLAGS:/GL=)
$<
<<NOKEEP

$(O)\amd64thk.h: $(O)\amd64thk.obj obj\amd64\amd64thk.obj
    $(AMD64_BLDRTHNK) $(O)\amd64thk.obj obj\amd64\amd64thk.obj > $@

amd64thk: $(O)\amd64thk.h

!else

amd64thk:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\hdlsterm.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    hdlsterm.c

Abstract:

    This modules implements stuff that is specific for headless terminal support.

Author:

    Sean Selitrennikoff (v-seans) 1-13-00

Revision History:

--*/

#include "bldr.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "ntverp.h"
#include "bldrx86.h"

#define TERMINAL_LINE_LENGTH 70
BOOLEAN FirstEntry = TRUE;
UCHAR TerminalLine[TERMINAL_LINE_LENGTH];
ULONG LinePosition = 0;

#define TERMINAL_PROMPT "!SAC>"

BOOLEAN
BlpDoCommand(
    IN PCHAR InputLine
    );

BOOLEAN
BlTerminalHandleLoaderFailure(
    VOID
    )

/*++

Routine Description:

    Gives a mini-SAC to the user, return TRUE when the user wants a reboot.

Arguments:

    None.

Return Value:

    TRUE - When the user wants a reboot, else FALSE.

--*/

{
    ULONG Count;
    BOOLEAN Reboot;
    ULONG Key;

    if (!BlIsTerminalConnected()) {
        return TRUE;
    }

    //
    // Position the cursor to the bottom of the screen and write the prompt
    //
    if (FirstEntry) {
        FirstEntry = FALSE;
        BlPositionCursor(1, ScreenHeight);
        ArcWrite(BlConsoleOutDeviceId, "\r\n", (ULONG)strlen("\r\n"), &Count);
        ArcWrite(BlConsoleOutDeviceId, TERMINAL_PROMPT, (ULONG)strlen(TERMINAL_PROMPT), &Count);
    }

    //
    // Check for input.
    // 
    if (ArcGetReadStatus(BlConsoleInDeviceId) == ESUCCESS) {
        
        Key = BlGetKey();

        if (Key == ESCAPE_KEY) {

            //
            // Clear this line
            //

            ArcWrite(BlConsoleOutDeviceId, "\\", (ULONG)strlen("\\"), &Count);
            BlPositionCursor(1, ScreenHeight);
            ArcWrite(BlConsoleOutDeviceId, "\r\n", (ULONG)strlen("\r\n"), &Count);
            ArcWrite(BlConsoleOutDeviceId, TERMINAL_PROMPT, (ULONG)strlen(TERMINAL_PROMPT), &Count);
            return FALSE;
        }

        if (Key == BKSP_KEY) {

            if (LinePosition != 0) {
                BlPositionCursor(LinePosition + sizeof(TERMINAL_PROMPT) - 1, ScreenHeight);
                ArcWrite(BlConsoleOutDeviceId, " ", (ULONG)strlen(" "), &Count);
                BlPositionCursor(LinePosition + sizeof(TERMINAL_PROMPT) - 1, ScreenHeight);
                LinePosition--;
                TerminalLine[LinePosition] = '\0';
            }

            return FALSE;
        }

        if (Key == TAB_KEY) {
            //
            // don't support this key
            //
            return FALSE;
        }

        if (Key == ENTER_KEY) {

            TerminalLine[LinePosition] = '\0';

            ArcWrite(BlConsoleOutDeviceId, "\r\n", (ULONG)strlen("\r\n"), &Count);
            
            if (LinePosition != 0) {
                Reboot = BlpDoCommand((PCHAR)TerminalLine);
            } else {
                Reboot = FALSE;
            }

            if (!Reboot) {
                BlPositionCursor(1, ScreenHeight);
                ArcWrite(BlConsoleOutDeviceId, "\r\n", (ULONG)strlen("\r\n"), &Count);
                ArcWrite(BlConsoleOutDeviceId, TERMINAL_PROMPT, (ULONG)strlen(TERMINAL_PROMPT), &Count);
                LinePosition = 0;
            }

            return Reboot;
        }

        //
        // Ignore all other non-ASCII keys
        //
        if (Key != (ULONG)(Key & 0x7F)) {
            return FALSE;
        }

        //
        // All other keys get recorded.
        //
        TerminalLine[LinePosition] = (UCHAR)Key;

        if (LinePosition < TERMINAL_LINE_LENGTH - 1) {
            LinePosition++;
        } else {
            BlPositionCursor(LinePosition + sizeof(TERMINAL_PROMPT) - 1, ScreenHeight);
        }

        //
        // Echo back to the console the character.
        //
        ArcWrite(BlConsoleOutDeviceId, &((UCHAR)Key), sizeof(UCHAR), &Count);

    }

    return FALSE;
}

BOOLEAN
BlpDoCommand(
    IN PCHAR InputLine
    )

/*++

Routine Description:

    Process an input line.

Arguments:

    InputLine - The command from the user.

Return Value:

    TRUE - When the user wants a reboot, else FALSE.

--*/

{
    ULONG Count;

    if ((_stricmp(InputLine, "?") == 0) ||
        (_stricmp(InputLine, "help") == 0)) {
        ArcWrite(BlConsoleOutDeviceId, 
                 "?        Display this message.\r\n",
                 sizeof("?        Display this message.\r\n"),
                 &Count
                );

        ArcWrite(BlConsoleOutDeviceId, 
                 "restart   Restart the system immediately.\r\n",
                 sizeof("restart   Restart the system immediately.\r\n"),
                 &Count
                );

        return FALSE;
    }

    if (_stricmp(InputLine, "restart") == 0) {
        return TRUE;
    }

    ArcWrite(BlConsoleOutDeviceId,
             "Invalid Command, use '?' for help.\r\n",
             sizeof("Invalid Command, use '?' for help.\r\n"),
             &Count
            );

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\haldtect.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    haldtect.c

Abstract:

    Provides HAL detection for ARC-compliant machines.

Author:

    John Vert (jvert) 21-Oct-1993

Revision History:

--*/

#if defined(_ALPHA_) || defined(_AXP64_) || defined(_MIPS_) || defined(_PPC_)

#include "haldtect.h"
#include <stdlib.h>

PVOID InfFile;
PVOID WinntSifHandle;


PCHAR
SlDetectHal(
    VOID
    )

/*++

Routine Description:

    Determines the canonical short machine name for the HAL to be loaded for
    this machine.

    It does this by enumerating the [Map.Computer] section of the INF file and
    comparing the strings there with the computer description in the ARC tree.

    [Map.Computer]
        msjazz_up   = *Jazz
        desksta1_up = "DESKTECH-ARCStation I"
        pica61_up   = "PICA-61"
        duo_mp      = *Duo

    [Map.Computer]
        DECjensen = "DEC-20Jensen"
        DECjensen = "DEC-10Jensen"

Arguments:

    None.

Return Value:

    PCHAR - pointer to canonical shortname for the machine.
    NULL - the type of machine could not be determined.

--*/

{
    PCONFIGURATION_COMPONENT_DATA Node;
    PCHAR MachineName;

    //
    // Find the system description node
    //
    Node = KeFindConfigurationEntry(BlLoaderBlock->ConfigurationRoot,
                                    SystemClass,
                                    ArcSystem,
                                    NULL);
    if (Node==NULL) {
        SlError(0);
        return(NULL);
    }

    MachineName = Node->ComponentEntry.Identifier;
    MachineName = (MachineName ? SlSearchSection("Map.Computer", MachineName) : NULL);
    return(MachineName);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\netboot.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    netboot.c

Abstract:

    This module implements the net boot file system used by the operating
    system loader.

Author:

    Chuck Lenzmeier (chuckl) 09-Jan-1997

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"

#ifdef UINT16
#undef UINT16
#endif

#ifdef INT16
#undef INT16
#endif

#include <dhcp.h>
#include <netfs.h>
#include <pxe_cmn.h>

#include <pxe_api.h>

#include <udp_api.h>
#include <tftp_api.h>
#if defined(_IA64_)
#include "bootia64.h"
#else
#include "bootx86.h"
#endif

#ifdef EFI
extern VOID EfiNetTerminate();
#endif

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef TRUE
#define TRUE  1
#endif

#ifndef BYTE
typedef unsigned char BYTE;
#endif

#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

#define MAX_PATH          260


//
// Define global data.
//

BOOLEAN BlBootingFromNet = FALSE;

BOOLEAN NetBootInitialized = FALSE;

PARC_OPEN_ROUTINE NetRealArcOpenRoutine;
PARC_CLOSE_ROUTINE NetRealArcCloseRoutine;

BL_DEVICE_ENTRY_TABLE NetDeviceEntryTable;

BOOTFS_INFO NetBootFsInfo={L"net"};

#if defined(REMOTE_BOOT_SECURITY)
ULONG TftpSecurityHandle = 0;
#endif // defined(REMOTE_BOOT_SECURITY)

BOOLEAN NetBootTftpUsedPassword2;

//
// We cache the last file opened, in case we get a request to open it again.
// We don't save a copy of the data, just a pointer to the data read by that
// open. So if the original open is closed before the next open for the
// same file comes in, we won't get a cache hit. But this system works for
// reading compressed files, which is the situation we care about. In that
// case a file is opened once and then re-opened twice more before the
// original open is closed.
//

ULONG CachedFileDeviceId = 0;
CHAR  CachedFilePath[MAX_PATH];
ULONG CachedFileSize = 0;
PUCHAR CachedFileData = NULL;

extern ARC_STATUS
GetParametersFromRom (
    VOID
    );


PBL_DEVICE_ENTRY_TABLE
IsNetFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a net file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a net file structure context.

Return Value:

    A pointer to the net entry table is returned if the partition is
    recognized as containing a net volume.  Otherwise, NULL is returned.

--*/

{
    PNET_STRUCTURE_CONTEXT NetStructureContext;

    DPRINT( TRACE, ("IsNetFileStructure\n") );

    if ( !BlBootingFromNet || (DeviceId != NET_DEVICE_ID) ) {
        return NULL;
    }

    //
    //  Clear the file system context block for the specified channel and
    //  establish a pointer to the context structure that can be used by other
    //  routines
    //

    NetStructureContext = (PNET_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory(NetStructureContext, sizeof(NET_STRUCTURE_CONTEXT));

    //
    //  Return the address of the table.
    //

    return &NetDeviceEntryTable;

} // IsNetFileStructure


ARC_STATUS
NetInitialize (
    VOID
    )

/*++

Routine Description:

    This routine initializes the net boot filesystem.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{
    NTSTATUS status;

    DPRINT( TRACE, ("NetInitialize\n") );
    //DbgBreakPoint( );

    
    if( NetBootInitialized ) {
        return ESUCCESS;
    }

    
    //
    // Initialize the file entry table.  Note that we need to do
    // this even if we aren't booting from the net because we may
    // use the 'Net' I/O functions to lay on top of any files that
    // we download through the debugger port.  So for that case,
    // we need access to all these functions here (see bd\file.c)
    //
    NetDeviceEntryTable.Close = NetClose;
    NetDeviceEntryTable.Mount = NetMount;
    NetDeviceEntryTable.Open  = NetOpen;
    NetDeviceEntryTable.Read  = NetRead;
    NetDeviceEntryTable.GetReadStatus = NetGetReadStatus;
    NetDeviceEntryTable.Seek  = NetSeek;
    NetDeviceEntryTable.Write = NetWrite;
    NetDeviceEntryTable.GetFileInformation = NetGetFileInformation;
    NetDeviceEntryTable.SetFileInformation = NetSetFileInformation;
    NetDeviceEntryTable.Rename = NetRename;
    NetDeviceEntryTable.GetDirectoryEntry   = NetGetDirectoryEntry;
    NetDeviceEntryTable.BootFsInfo = &NetBootFsInfo;

    if( !BlBootingFromNet ) {
        return ESUCCESS;
    }

    NetBootInitialized = TRUE;

    DPRINT( LOUD, ("NetInitialize: booting from net\n") );
    //DPRINT( LOUD, ("  NetInitialize at %08x\n", NetInitialize) );
    //DPRINT( LOUD, ("  NetOpen       at %08x\n", NetOpen) );
    //DbgBreakPoint( );


    //
    // Hook the ArcOpen and ArcClose routines.
    //

    NetRealArcOpenRoutine = FIRMWARE_VECTOR_BLOCK->OpenRoutine;
    FIRMWARE_VECTOR_BLOCK->OpenRoutine = NetArcOpen;

    NetRealArcCloseRoutine = FIRMWARE_VECTOR_BLOCK->CloseRoutine;
    FIRMWARE_VECTOR_BLOCK->CloseRoutine = NetArcClose;

    //
    // Get boot parameters from the boot ROM.
    //

    status = GetParametersFromRom( );

    if ( status != ESUCCESS ) {
        return status;
    }

    return ESUCCESS;
}


VOID
NetTerminate (
    VOID
    )

/*++

Routine Description:

    This routine shuts down the net boot filesystem.

Arguments:

    None.

Return Value:

    ESUCCESS.

--*/

{

#if defined(_X86_)

#if defined(REMOTE_BOOT_SECURITY)
    if ( TftpSecurityHandle != 0 ) {
        TftpLogoff(NetServerIpAddress, TftpSecurityHandle);
        TftpSecurityHandle = 0;
    }
#endif // defined(REMOTE_BOOT_SECURITY)


    //
    //  let's not set the receive status if the card isn't active.
    //
    RomSetReceiveStatus( 0 );
#endif // defined(_X86_)


#ifdef EFI
    EfiNetTerminate();
#endif

    return;

} // NetTerminate


ARC_STATUS
NetArcClose (
    IN ULONG FileId
    )
{
    DPRINT( TRACE, ("NetArcClose\n") );

    if ( FileId != NET_DEVICE_ID ) {
        return NetRealArcCloseRoutine( FileId );
    }

    return ESUCCESS;

} // NetArcClose


ARC_STATUS
NetArcOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    )
{
    DPRINT( TRACE, ("NetArcOpen\n") );

    if ( _strnicmp(OpenPath, "net(", 4) != 0 ) {
        return NetRealArcOpenRoutine( OpenPath, OpenMode, FileId );
    }

    *FileId = NET_DEVICE_ID;

    return ESUCCESS;

} // NetArcOpen


ARC_STATUS
NetClose (
    IN ULONG FileId
    )
{
    PBL_FILE_TABLE fileTableEntry;
    DPRINT( TRACE, ("NetClose FileId = %d\n", FileId) );

    fileTableEntry = &BlFileTable[FileId];

    {
        DPRINT( REAL_LOUD, ("NetClose: id %d, freeing memory at 0x%08x, %d bytes\n",
            FileId,
            fileTableEntry->u.NetFileContext.InMemoryCopy,
            fileTableEntry->u.NetFileContext.FileSize) );
        BlFreeDescriptor( (ULONG)((ULONG_PTR)fileTableEntry->u.NetFileContext.InMemoryCopy & ~KSEG0_BASE) >> PAGE_SHIFT );        

        //
        // If the data read for this specific open was what was cached,
        // then mark the cache empty.
        //
        if (fileTableEntry->u.NetFileContext.InMemoryCopy == CachedFileData) {
            CachedFileData = NULL;
            CachedFilePath[0] = '\0';
        }
    }

    fileTableEntry->Flags.Open = 0;

    return EROFS;

} // NetClose


ARC_STATUS
NetMount (
    IN CHAR * FIRMWARE_PTR MountPath,
    IN MOUNT_OPERATION Operation
    )
{
    UNREFERENCED_PARAMETER( MountPath );
    UNREFERENCED_PARAMETER( Operation );

    DPRINT( TRACE, ("NetMount\n") );

    return EROFS;

} // NetMount


ARC_STATUS
NetOpen (
    IN CHAR * FIRMWARE_PTR OpenPath,
    IN OPEN_MODE OpenMode,
    OUT ULONG * FIRMWARE_PTR FileId
    )
{
    NTSTATUS ntStatus;
    ARC_STATUS arcStatus; // holds temp values, not the function return value
    PBL_FILE_TABLE fileTableEntry;
    TFTP_REQUEST request;
    ULONG oldBase;
    ULONG oldLimit;
#if defined(REMOTE_BOOT_SECURITY)
    static BOOLEAN NetBootTryTftpSecurity = FALSE;
#endif // defined(REMOTE_BOOT_SECURITY)

    DPRINT( TRACE, ("NetOpen FileId = %d\n", *FileId) );

    DPRINT( LOUD, ("NetOpen: opening %s, id %d, mode %d\n", OpenPath, *FileId, OpenMode) );
    fileTableEntry = &BlFileTable[*FileId];

    if ( OpenMode != ArcOpenReadOnly ) {
        DPRINT( LOUD, ("NetOpen: invalid OpenMode\n") );
        return EROFS;
    }

    fileTableEntry->Flags.Open = 1; // Prevent GetCSCFileNameFromUNCPath using our entry

#if defined(REMOTE_BOOT_SECURITY)
    //
    // Login if we don't have a valid handle, using the on-disk secret.
    //

    if ((TftpSecurityHandle == 0) &&
        NetBootTryTftpSecurity) {

        ULONG FileId;
        RI_SECRET Secret;
        UCHAR Domain[RI_SECRET_DOMAIN_SIZE + 1];
        UCHAR User[RI_SECRET_USER_SIZE + 1];
        struct {
            UCHAR Owf[LM_OWF_PASSWORD_SIZE+NT_OWF_PASSWORD_SIZE];
        } Passwords[2];
        UCHAR Sid[RI_SECRET_SID_SIZE];

        arcStatus = BlOpenRawDisk(&FileId);

        if (arcStatus == ESUCCESS) {

            arcStatus = BlReadSecret(FileId, &Secret);
            if (arcStatus == ESUCCESS) {
                BlParseSecret(
                    Domain,
                    User,
                    Passwords[0].Owf,
                    Passwords[0].Owf + LM_OWF_PASSWORD_SIZE,
                    Passwords[1].Owf,
                    Passwords[1].Owf + LM_OWF_PASSWORD_SIZE,
                    Sid,
                    &Secret);
                DPRINT(LOUD, ("Logging on to <%s><%s>\n", Domain, User));

                //
                // Try logging on with the first password, if that fails
                // then try the second.
                //

                ntStatus = TftpLogin(
                             Domain,
                             User,
                             Passwords[0].Owf,
                             NetServerIpAddress,
                             &TftpSecurityHandle);
                if (!NT_SUCCESS(ntStatus)) {
                    DPRINT(LOUD, ("TftpLogin using password 2\n"));
                    ntStatus = TftpLogin(
                                 Domain,
                                 User,
                                 Passwords[1].Owf,
                                 NetServerIpAddress,
                                 &TftpSecurityHandle);
                    if (NT_SUCCESS(ntStatus)) {
                        NetBootTftpUsedPassword2 = TRUE;
                    }
                }

            } else {

                ntStatus = STATUS_OBJECT_PATH_NOT_FOUND;
            }

            arcStatus = BlCloseRawDisk(FileId);

            //
            // We are inside the if() for successfully opening the raw
            // disk, so we are not diskless. On these machines we must
            // fail the open at this point.
            //

            if (!NT_SUCCESS(ntStatus)) {
                DPRINT( ERROR, ("TftpLogin failed %lx\n", ntStatus) );
                return EACCES;
            }

        } else {

            NetBootTryTftpSecurity = FALSE;  // so we don't try to open it again
        }

    }
#endif // defined(REMOTE_BOOT_SECURITY)

    DPRINT( LOUD, ("NetOpen: opening %s\n", OpenPath) );

    oldBase = BlUsableBase;
    oldLimit = BlUsableLimit;
    BlUsableBase = BL_DRIVER_RANGE_LOW;
    BlUsableLimit = BL_DRIVER_RANGE_HIGH;

    //
    // If this request matches the cached file, then just copy that data.
    //

    if ((fileTableEntry->DeviceId == CachedFileDeviceId) &&
        (strcmp(OpenPath, CachedFilePath) == 0) &&
        (CachedFileData != NULL)) {

        ULONG basePage;

        arcStatus = BlAllocateAlignedDescriptor(
                        LoaderFirmwareTemporary,
                        0,
                        BYTES_TO_PAGES(CachedFileSize),
                        0,
                        &basePage
                        );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if ( arcStatus != ESUCCESS ) {
            fileTableEntry->Flags.Open = 0; // Free entry we didn't use

            return EROFS;
        }

        DPRINT( REAL_LOUD, ("NetOpen: Using cache for file %s\n", CachedFilePath) );

        fileTableEntry->u.NetFileContext.InMemoryCopy = (PUCHAR)(KSEG0_BASE | (basePage << PAGE_SHIFT) );
        memcpy(fileTableEntry->u.NetFileContext.InMemoryCopy, CachedFileData, CachedFileSize);
        fileTableEntry->u.NetFileContext.FileSize = CachedFileSize;

    } else {

        request.RemoteFileName = (PUCHAR)OpenPath;
        request.ServerIpAddress = NetServerIpAddress;
        request.MemoryAddress = NULL;
        request.MaximumLength = 0;
        request.BytesTransferred = 0xbadf00d;
        request.Operation = TFTP_RRQ;
        request.MemoryType = LoaderFirmwareTemporary;
#if defined(REMOTE_BOOT_SECURITY)
        request.SecurityHandle = TftpSecurityHandle;
#endif // defined(REMOTE_BOOT_SECURITY)
        request.ShowProgress = FALSE;

        ntStatus = TftpGetPut( &request );
        DPRINT( REAL_LOUD, ("NetOpen: TftpGetPut(get) status: %x, bytes: %x\n", ntStatus, request.BytesTransferred) );

        BlUsableBase = oldBase;
        BlUsableLimit = oldLimit;

        if ( !NT_SUCCESS(ntStatus) ) {
            if ( request.MemoryAddress != NULL ) {
                DPRINT( REAL_LOUD, ("NetOpen: freeing memory at 0x%08x, %d bytes\n",
                        request.MemoryAddress, request.MaximumLength) );
                BlFreeDescriptor( (ULONG) ((ULONG_PTR)request.MemoryAddress & ~KSEG0_BASE) >> PAGE_SHIFT );
            }
            fileTableEntry->Flags.Open = 0; // Free entry we didn't use

            if ( ntStatus == STATUS_INSUFFICIENT_RESOURCES ) {
                return ENOMEM;
            }
            return EROFS;
        }

        fileTableEntry->u.NetFileContext.FileSize = request.BytesTransferred;
        fileTableEntry->u.NetFileContext.InMemoryCopy = request.MemoryAddress;

        //
        // We always cache the last file that was actually read from
        // the network.
        //

        strncpy(CachedFilePath, OpenPath, MAX_PATH);
        CachedFilePath[MAX_PATH-1] = '\0';
        CachedFileDeviceId = fileTableEntry->DeviceId;
        CachedFileSize = request.BytesTransferred;
        CachedFileData = request.MemoryAddress;

    }

    fileTableEntry->Position.QuadPart = 0;

    fileTableEntry->Flags.Read = 1;

    return ESUCCESS;

} // NetOpen


ARC_STATUS
NetRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
{
    PBL_FILE_TABLE fileTableEntry;
    PNET_FILE_CONTEXT context;
    PUCHAR source;

    fileTableEntry = &BlFileTable[FileId];
    context = &fileTableEntry->u.NetFileContext;

    {
        source = context->InMemoryCopy + fileTableEntry->Position.LowPart;
        if ( (fileTableEntry->Position.LowPart + Length) > context->FileSize ) {
            Length = context->FileSize - fileTableEntry->Position.LowPart;
        }

        RtlCopyMemory( Buffer, source, Length );
        *Count = Length;

        fileTableEntry->Position.LowPart += Length;
    }

    DPRINT( REAL_LOUD, ("NetRead: id %d, length %d, count %d, new pos %x\n",
                    FileId, Length, *Count, fileTableEntry->Position.LowPart) );

    return ESUCCESS;

} // NetRead


ARC_STATUS
NetGetReadStatus (
    IN ULONG FileId
    )
{
    UNREFERENCED_PARAMETER( FileId );

    DPRINT( TRACE, ("NetGetReadStatus\n") );

    return ESUCCESS;

} // NetGetReadStatus


ARC_STATUS
NetSeek (
    IN ULONG FileId,
    IN LARGE_INTEGER * FIRMWARE_PTR Offset,
    IN SEEK_MODE SeekMode
    )
{
    PBL_FILE_TABLE fileTableEntry;
    LARGE_INTEGER newPosition;

    //DPRINT( TRACE, ("NetSeek\n") );

    fileTableEntry = &BlFileTable[FileId];

    {
        if ( SeekMode == SeekAbsolute ) {
            newPosition = *Offset;
        } else if ( SeekMode == SeekRelative ) {
            newPosition.QuadPart =
                fileTableEntry->Position.QuadPart + Offset->QuadPart;
        } else {
            return EROFS;
        }

        DPRINT( REAL_LOUD, ("NetSeek: id %d, mode %d, offset %x, new pos %x\n",
                        FileId, SeekMode, Offset->LowPart, newPosition.LowPart) );

        if ( newPosition.QuadPart > fileTableEntry->u.NetFileContext.FileSize ) {
            return EROFS;
        }

        fileTableEntry->Position = newPosition;
    }

    return ESUCCESS;

} // NetSeek


ARC_STATUS
NetWrite (
    IN ULONG FileId,
    IN VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Count
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( Buffer );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Count );

    DPRINT( TRACE, ("NetWrite\n") );

    return EROFS;

} // NetWrite


ARC_STATUS
NetGetFileInformation (
    IN ULONG FileId,
    OUT FILE_INFORMATION * FIRMWARE_PTR Buffer
    )
{
    PBL_FILE_TABLE fileTableEntry;
    //DPRINT( TRACE, ("NetGetFileInformation\n") );

    fileTableEntry = &BlFileTable[FileId];

    {
        Buffer->EndingAddress.QuadPart = fileTableEntry->u.NetFileContext.FileSize;
        Buffer->CurrentPosition.QuadPart = fileTableEntry->Position.QuadPart;
        DPRINT( REAL_LOUD, ("NetGetFileInformation returning size %x, position %x\n",
                Buffer->EndingAddress.LowPart, Buffer->CurrentPosition.LowPart) );

        return ESUCCESS;
    }

} // NetGetFileInformation


ARC_STATUS
NetSetFileInformation (
    IN ULONG FileId,
    IN ULONG AttributeFlags,
    IN ULONG AttributeMask
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( AttributeFlags );
    UNREFERENCED_PARAMETER( AttributeMask );

    DPRINT( TRACE, ("NetSetFileInformation\n") );

    return EROFS;

} // NetSetFileInformation


ARC_STATUS
NetRename (
    IN ULONG FileId,
    IN CHAR * FIRMWARE_PTR NewFileName
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( NewFileName );

    DPRINT( TRACE, ("NetRename\n") );

    return EROFS;

} // NetRename


ARC_STATUS
NetGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    )
{
    UNREFERENCED_PARAMETER( FileId );
    UNREFERENCED_PARAMETER( DirEntry );
    UNREFERENCED_PARAMETER( NumberDir );
    UNREFERENCED_PARAMETER( CountDir );

    DPRINT( TRACE, ("NetGetDirectoryEntry\n") );

    return EROFS;

} // NetGetDirectoryEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\boot\lib\fatboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    fatboot.c

Abstract:

    This module implements the FAT boot file system used by the operating
    system loader.

Author:

    Gary Kimura (garyki) 29-Aug-1989

Revision History:

--*/

#include "bootlib.h"
#include "stdio.h"
#include "blcache.h"

BOOTFS_INFO FatBootFsInfo={L"fastfat"};

//
//  Conditional debug print routine
//

#ifdef FATBOOTDBG

#define FatDebugOutput(X,Y,Z) {                                      \
    if (BlConsoleOutDeviceId) {                                      \
        CHAR _b[128];                                                \
        ULONG _c;                                                    \
        sprintf(&_b[0], X, Y, Z);                                    \
        ArcWrite(BlConsoleOutDeviceId, &_b[0], strlen(&_b[0]), &_c); \
    }                                                                \
}

#define CharOrSpace(C) ((C) < 0x20 ? 0x20: (C))

#define FatDebugOutput83(X,N,Y,Z) {                                  \
    if (BlConsoleOutDeviceId) {                                      \
        CHAR _b[128];                                                \
        CHAR _n[13];                                                 \
        ULONG _c;                                                    \
        sprintf(&_n[0], "> %c%c%c%c%c%c%c%c.%c%c%c <",               \
                        CharOrSpace(*((PCHAR)N +0)),                 \
                        CharOrSpace(*((PCHAR)N +1)),                 \
                        CharOrSpace(*((PCHAR)N +2)),                 \
                        CharOrSpace(*((PCHAR)N +3)),                 \
                        CharOrSpace(*((PCHAR)N +4)),                 \
                        CharOrSpace(*((PCHAR)N +5)),                 \
                        CharOrSpace(*((PCHAR)N +6)),                 \
                        CharOrSpace(*((PCHAR)N +7)),                 \
                        CharOrSpace(*((PCHAR)N +8)),                 \
                        CharOrSpace(*((PCHAR)N +9)),                 \
                        CharOrSpace(*((PCHAR)N +10)));               \
        sprintf(&_b[0], X, _n, Y, Z);                                \
        ArcWrite(BlConsoleOutDeviceId, &_b[0], strlen(&_b[0]), &_c); \
    }                                                                \
}

#else

#define FatDebugOutput(X,Y,Z)        {NOTHING;}
#define FatDebugOutput83(X,N,Y,Z)    {NOTHING;}
#endif // FATBOOTDBG


//
//  Low level disk I/O procedure prototypes
//

ARC_STATUS
FatDiskRead (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer,
    IN BOOLEAN CacheNewData
    );

ARC_STATUS
FatDiskWrite (
    IN ULONG DeviceId,
    IN LBO Lbo,
    IN ULONG ByteCount,
    IN PVOID Buffer
    );

//
//  VOID
//  DiskRead (
//      IN ULONG DeviceId,
//      IN LBO Lbo,
//      IN ULONG ByteCount,
//      IN PVOID Buffer,
//      IN BOOLEAN CacheNewData,
//      IN BOOLEAN IsDoubleSpace
//      );
//

#define DiskRead(A,B,C,D,E,ignored) { ARC_STATUS _s;               \
    if ((_s = FatDiskRead(A,B,C,D,E)) != ESUCCESS) { return _s; }  \
}

#define DiskWrite(A,B,C,D) { ARC_STATUS _s;                      \
    if ((_s = FatDiskWrite(A,B,C,D)) != ESUCCESS) { return _s; } \
}


//
//  Cluster/Index routines
//

typedef enum _CLUSTER_TYPE {
    FatClusterAvailable,
    FatClusterReserved,
    FatClusterBad,
    FatClusterLast,
    FatClusterNext
} CLUSTER_TYPE;

CLUSTER_TYPE
FatInterpretClusterType (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY Entry
    );

ARC_STATUS
FatLookupFatEntry (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG FatIndex,
    OUT PULONG FatEntry,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatSetFatEntry (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY FatIndex,
    IN FAT_ENTRY FatEntry
    );

ARC_STATUS
FatFlushFatEntries (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId
    );

LBO
FatIndexToLbo (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN FAT_ENTRY FatIndex
    );

#define LookupFatEntry(A,B,C,D,E) { ARC_STATUS _s;                      \
    if ((_s = FatLookupFatEntry(A,B,C,D,E)) != ESUCCESS) { return _s; } \
}

#define SetFatEntry(A,B,C,D) { ARC_STATUS _s;                      \
    if ((_s = FatSetFatEntry(A,B,C,D)) != ESUCCESS) { return _s; } \
}

#define FlushFatEntries(A,B) { ARC_STATUS _s;                      \
    if ((_s = FatFlushFatEntries(A,B)) != ESUCCESS) { return _s; } \
}


//
//  Directory routines
//

ARC_STATUS
FatSearchForDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PFAT8DOT3 FileName,
    OUT PDIRENT Dirent,
    OUT PLBO Lbo,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatCreateDirent (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN FAT_ENTRY DirectoriesStartingIndex,
    IN PDIRENT Dirent,
    OUT PLBO Lbo
    );

VOID
FatSetDirent (
    IN PFAT8DOT3 FileName,
    IN OUT PDIRENT Dirent,
    IN UCHAR Attributes
    );

#define SearchForDirent(A,B,C,D,E,F,G) { ARC_STATUS _s;                      \
    if ((_s = FatSearchForDirent(A,B,C,D,E,F,G)) != ESUCCESS) { return _s; } \
}

#define CreateDirent(A,B,C,D,E) { ARC_STATUS _s;                      \
    if ((_s = FatCreateDirent(A,B,C,D,E)) != ESUCCESS) { return _s; } \
}


//
//  Allocation and mcb routines
//

ARC_STATUS
FatLoadMcb (
    IN ULONG FileId,
    IN VBO StartingVbo,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatVboToLbo (
    IN ULONG FileId,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    IN BOOLEAN IsDoubleSpace
    );

ARC_STATUS
FatIncreaseFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    );

ARC_STATUS
FatTruncateFileAllocation (
    IN ULONG FileId,
    IN ULONG ByteSize
    );

ARC_STATUS
FatAllocateClusters (
    IN PFAT_STRUCTURE_CONTEXT FatStructureContext,
    IN ULONG DeviceId,
    IN ULONG ClusterCount,
    IN ULONG Hint,
    OUT PULONG AllocatedEntry
    );

#define LoadMcb(A,B,C) { ARC_STATUS _s;                      \
    if ((_s = FatLoadMcb(A,B,C)) != ESUCCESS) { return _s; } \
}

#define VboToLbo(A,B,C,D) { ARC_STATUS _s;                            \
    if ((_s = FatVboToLbo(A,B,C,D,FALSE)) != ESUCCESS) { return _s; } \
}

#define IncreaseFileAllocation(A,B) { ARC_STATUS _s;                      \
    if ((_s = FatIncreaseFileAllocation(A,B)) != ESUCCESS) { return _s; } \
}

#define TruncateFileAllocation(A,B) { ARC_STATUS _s;                      \
    if ((_s = FatTruncateFileAllocation(A,B)) != ESUCCESS) { return _s; } \
}

#define AllocateClusters(A,B,C,D,E) { ARC_STATUS _s;                      \
    if ((_s = FatAllocateClusters(A,B,C,D,E)) != ESUCCESS) { return _s; } \
}


//
//  Miscellaneous routines
//

VOID
FatFirstComponent (
    IN OUT PSTRING String,
    OUT PFAT8DOT3 FirstComponent
    );

#define AreNamesEqual(X,Y) (                                                      \
    ((*(X))[0]==(*(Y))[0]) && ((*(X))[1]==(*(Y))[1]) && ((*(X))[2]==(*(Y))[2]) && \
    ((*(X))[3]==(*(Y))[3]) && ((*(X))[4]==(*(Y))[4]) && ((*(X))[5]==(*(Y))[5]) && \
    ((*(X))[6]==(*(Y))[6]) && ((*(X))[7]==(*(Y))[7]) && ((*(X))[8]==(*(Y))[8]) && \
    ((*(X))[9]==(*(Y))[9]) && ((*(X))[10]==(*(Y))[10])                            \
)

#define ToUpper(C) ((((C) >= 'a') && ((C) <= 'z')) ? (C) - 'a' + 'A' : (C))

#define FlagOn(Flags,SingleFlag)        ((Flags) & (SingleFlag))
#define BooleanFlagOn(Flags,SingleFlag) ((BOOLEAN)(((Flags) & (SingleFlag)) != 0))
#define SetFlag(Flags,SingleFlag)       { (Flags) |= (SingleFlag); }
#define ClearFlag(Flags,SingleFlag)     { (Flags) &= ~(SingleFlag); }

#define FatFirstFatAreaLbo(B) ( (B)->ReservedSectors * (B)->BytesPerSector )

#define Minimum(X,Y) ((X) < (Y) ? (X) : (Y))
#define Maximum(X,Y) ((X) < (Y) ? (Y) : (X))

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 { UCHAR  Uchar[1]; UCHAR  ForceAlignment; } UCHAR1, *PUCHAR1;
typedef union _UCHAR2 { UCHAR  Uchar[2]; USHORT ForceAlignment; } UCHAR2, *PUCHAR2;
typedef union _UCHAR4 { UCHAR  Uchar[4]; ULONG  ForceAlignment; } UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

//
// DirectoryEntry routines
//

VOID
FatDirToArcDir (
    IN PDIRENT FatDirent,
    OUT PDIRECTORY_ENTRY ArcDirent
    );


//
// Define global data.
//

//
// File entry table - This is a structure that provides entry to the FAT
//      file system procedures. It is exported when a FAT file structure
//      is recognized.
//

BL_DEVICE_ENTRY_TABLE FatDeviceEntryTable;


PBL_DEVICE_ENTRY_TABLE
IsFatFileStructure (
    IN ULONG DeviceId,
    IN PVOID StructureContext
    )

/*++

Routine Description:

    This routine determines if the partition on the specified channel
    contains a FAT file system volume.

Arguments:

    DeviceId - Supplies the file table index for the device on which
        read operations are to be performed.

    StructureContext - Supplies a pointer to a FAT file structure context.

Return Value:

    A pointer to the FAT entry table is returned if the partition is
    recognized as containing a FAT volume.  Otherwise, NULL is returned.

--*/

{
    PPACKED_BOOT_SECTOR BootSector;
    UCHAR Buffer[sizeof(PACKED_BOOT_SECTOR)+256];

    PFAT_STRUCTURE_CONTEXT FatStructureContext;

    FatDebugOutput("IsFatFileStructure\r\n", 0, 0);

    //
    //  Clear the file system context block for the specified channel and
    //  establish a pointer to the context structure that can be used by other
    //  routines
    //

    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)StructureContext;
    RtlZeroMemory(FatStructureContext, sizeof(FAT_STRUCTURE_CONTEXT));

    //
    //  Setup and read in the boot sector for the potential fat partition
    //

    BootSector = (PPACKED_BOOT_SECTOR)ALIGN_BUFFER( &Buffer[0] );

    if (FatDiskRead(DeviceId, 0, sizeof(PACKED_BOOT_SECTOR), BootSector, CACHE_NEW_DATA) != ESUCCESS) {

        return NULL;
    }

    //
    //  Unpack the Bios parameter block
    //

    FatUnpackBios(&FatStructureContext->Bpb, &BootSector->PackedBpb);

    //
    //  Check if it is fat
    //
    if ((BootSector->Jump[0] != 0xeb) &&
        (BootSector->Jump[0] != 0xe9)) {

        return NULL;

    } else if ((FatStructureContext->Bpb.BytesPerSector !=  128) &&
               (FatStructureContext->Bpb.BytesPerSector !=  256) &&
               (FatStructureContext->Bpb.BytesPerSector !=  512) &&
               (FatStructureContext->Bpb.BytesPerSector != 1024)) {

        return NULL;

    } else if ((FatStructureContext->Bpb.SectorsPerCluster !=  1) &&
               (FatStructureContext->Bpb.SectorsPerCluster !=  2) &&
               (FatStructureContext->Bpb.SectorsPerCluster !=  4) &&
               (FatStructureContext->Bpb.SectorsPerCluster !=  8) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 16) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 32) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 64) &&
               (FatStructureContext->Bpb.SectorsPerCluster != 128)) {

        return NULL;

    } else if (FatStructureContext->Bpb.ReservedSectors == 0) {

        return NULL;

    } else if (((FatStructureContext->Bpb.Sectors == 0) && (FatStructureContext->Bpb.LargeSectors == 0)) ||
               ((FatStructureContext->Bpb.Sectors != 0) && (FatStructureContext->Bpb.LargeSectors != 0))) {

        return NULL;

    } else if (FatStructureContext->Bpb.Fats == 0) {

        return NULL;

    } else if ((FatStructureContext->Bpb.Media != 0xf0) &&
               (FatStructureContext->Bpb.Media != 0xf8) &&
               (FatStructureContext->Bpb.Media != 0xf9) &&
               (FatStructureContext->Bpb.Media != 0xfc) &&
               (FatStructureContext->Bpb.Media != 0xfd) &&
               (FatStructureContext->Bpb.Media != 0xfe) &&
               (FatStructureContext->Bpb.Media != 0xff)) {

        return NULL;

    } else if (FatStructureContext->Bpb.SectorsPerFat == 0) {

        if (!IsBpbFat32(&BootSector->PackedBpb)) {
            return NULL;
        }

    } else if (FatStructureContext->Bpb.RootEntries == 0) {

        return NULL;

    }

    //
    //  Initialize the file entry table and return the address of the table.
    //

    FatDeviceEntryTable.Open  = FatOpen;
    FatDeviceEntryTable.Close = FatClose;
    FatDeviceEntryTable.Read  = FatRead;
    FatDeviceEntryTable.Seek  = FatSeek;
    FatDeviceEntryTable.Write = FatWrite;
    FatDeviceEntryTable.GetFileInformation = FatGetFileInformation;
    FatDeviceEntryTable.SetFileInformation = FatSetFileInformation;
    FatDeviceEntryTable.Rename = FatRename;
    FatDeviceEntryTable.GetDirectoryEntry   = FatGetDirectoryEntry;
    FatDeviceEntryTable.BootFsInfo = &FatBootFsInfo;


    return &FatDeviceEntryTable;
}

ARC_STATUS
FatClose (
    IN ULONG FileId
    )

/*++

Routine Description:

    This routine closes the file specified by the file id.

Arguments:

    FileId - Supplies the file table index.

Return Value:

    ESUCCESS if returned as the function value.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;

    FatDebugOutput("FatClose\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Mark the file closed
    //

    BlFileTable[FileId].Flags.Open = 0;

    //
    //  Check if the fat is dirty and flush it out if it is.
    //

    if (FatStructureContext->CachedFatDirty) {

        FlushFatEntries( FatStructureContext, DeviceId );
    }

    //
    //  Check if the current mcb is for this file and if it is then zero it out.
    //  By setting the file id for the mcb to be the table size we guarantee that
    //  we've just set it to an invalid file id.
    //

    if (FatStructureContext->FileId == FileId) {

        FatStructureContext->FileId = BL_FILE_TABLE_SIZE;
        FatStructureContext->Mcb.InUse = 0;
    }

    return ESUCCESS;
}


ARC_STATUS
FatGetDirectoryEntry (
    IN ULONG FileId,
    IN DIRECTORY_ENTRY * FIRMWARE_PTR DirEntry,
    IN ULONG NumberDir,
    OUT ULONG * FIRMWARE_PTR CountDir
    )

/*++

Routine Description:

    This routine implements the GetDirectoryEntry operation for the
    FAT file system.

Arguments:

    FileId - Supplies the file table index.

    DirEntry - Supplies a pointer to a directory entry structure.

    NumberDir - Supplies the number of directory entries to read.

    Count - Supplies a pointer to a variable to receive the number
            of entries read.

Return Value:

    ESUCCESS is returned if the read was successful, otherwise
    an error code is returned.

--*/

{
    //
    // define local variables
    //

    ARC_STATUS Status;                 // ARC status
    ULONG Position;                    // file position
    PFAT_FILE_CONTEXT pContext;        // FAT file context
    ULONG RunByteCount = 0;            // max sequential bytes
    ULONG RunDirCount;                 // max dir entries to read per time
    ULONG i;                           // general index
    PDIRENT FatDirEnt;                 // directory entry pointer
    UCHAR Buffer[ 16 * sizeof(DIRENT) + 32 ];
    LBO Lbo = 0;
    BOOLEAN EofDir = FALSE;            // not end of file

    //
    // initialize local variables
    //

    pContext = &BlFileTable[ FileId ].u.FatFileContext;
    FatDirEnt = (PDIRENT)ALIGN_BUFFER( &Buffer[0] );

    //
    // if not directory entry, exit with error
    //

    if ( !FlagOn(pContext->Dirent.Attributes, FAT_DIRENT_ATTR_DIRECTORY) ) {

        return EBADF;
    }

    //
    // Initialize the output count to zero
    //

    *CountDir = 0;

    //
    // if NumberDir is zero, return ESUCCESS.
    //

    if ( !NumberDir ) {

        return ESUCCESS;
    }

    //
    // read one directory at a time.
    //

    do {

        //
        // save position
        //

        Position = BlFileTable[ FileId ].Position.LowPart;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //

        if ( !RunByteCount ) {

            if ((Status = FatVboToLbo( FileId, Position, &Lbo, &RunByteCount, FALSE )) != 0) {

                if ( Status == EINVAL ) {

                    break;                      // eof has been reached

                } else {

                    return Status;              // I/O error
                }
            }
        }

        //
        // validate the # of bytes readable in sequance (exit loop if eof)
        // the block is always multiple of a directory entry size.
        //

        if ( (RunDirCount = Minimum( RunByteCount/sizeof(DIRENT), 16)) == 0 ) {

            break;
        }

        //
        //  issue the read
        //

        if ( (Status = FatDiskRead( BlFileTable[ FileId ].DeviceId,
                                    Lbo,
                                    RunDirCount * sizeof(DIRENT),
                                    (PVOID)FatDirEnt,
                                    CACHE_NEW_DATA)) != 0 ) {

            BlFileTable[ FileId ].Position.LowPart = Position;
            return Status;
        }

        for ( i=0; i<RunDirCount; i++ ) {

            //
            // exit from loop if logical end of directory
            //

            if ( FatDirEnt[i].FileName[0] == FAT_DIRENT_NEVER_USED ) {

                EofDir = TRUE;
                break;
            }

            //
            // update the current position and the number of bytes transfered
            //

            BlFileTable[ FileId ].Position.LowPart += sizeof(DIRENT);
            Lbo += sizeof(DIRENT);
            RunByteCount -= sizeof(DIRENT);

            //
            // skip this entry if the file or directory has been erased
            //

            if ( FatDirEnt[i].FileName[0] == FAT_DIRENT_DELETED ) {

                continue;
            }

            //
            // skip this entry if this is a valume label
            //

            if (FlagOn( FatDirEnt[i].Attributes, FAT_DIRENT_ATTR_VOLUME_ID )) {

                continue;
            }

            //
            // convert FAT directory entry in ARC directory entry
            //

            FatDirToArcDir( &FatDirEnt[i], DirEntry++ );

            //
            // update pointers
            //

            if ( ++*CountDir >= NumberDir ) {

                break;
            }
        }

    } while ( !EofDir  &&  *CountDir < NumberDir );

    //
    // all done
    //

    return *CountDir ? ESUCCESS : ENOTDIR;
}


ARC_STATUS
FatGetFileInformation (
    IN ULONG FileId,
    OUT PFILE_INFORMATION Buffer
    )

/*++

Routine Description:

    This procedure returns to the user a buffer filled with file information

Arguments:

    FileId - Supplies the File id for the operation

    Buffer - Supplies the buffer to receive the file information.  Note that
        it must be large enough to hold the full file name

Return Value:

    ESUCCESS is returned if the open operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    UCHAR Attributes;
    ULONG i;

    FatDebugOutput("FatGetFileInformation\r\n", 0, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    Attributes = FileTableEntry->u.FatFileContext.Dirent.Attributes;

    //
    //  Zero out the buffer, and fill in its non-zero values.
    //

    RtlZeroMemory(Buffer, sizeof(FILE_INFORMATION));

    Buffer->EndingAddress.LowPart = FileTableEntry->u.FatFileContext.Dirent.FileSize;

    Buffer->CurrentPosition.LowPart = FileTableEntry->Position.LowPart;
    Buffer->CurrentPosition.HighPart = 0;

    if (FlagOn(Attributes, FAT_DIRENT_ATTR_READ_ONLY)) { SetFlag(Buffer->Attributes, ArcReadOnlyFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_HIDDEN))    { SetFlag(Buffer->Attributes, ArcHiddenFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_SYSTEM))    { SetFlag(Buffer->Attributes, ArcSystemFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_ARCHIVE))   { SetFlag(Buffer->Attributes, ArcArchiveFile) };
    if (FlagOn(Attributes, FAT_DIRENT_ATTR_DIRECTORY)) { SetFlag(Buffer->Attributes, ArcDirectoryFile) };

    Buffer->FileNameLength = FileTableEntry->FileNameLength;

    for (i = 0; i < FileTableEntry->FileNameLength; i += 1) {

        Buffer->FileName[i] = FileTableEntry->FileName[i];
    }

    return ESUCCESS;
}


ARC_STATUS
FatOpen (
    IN CHAR * FIRMWARE_PTR FileName,
    IN OPEN_MODE OpenMode,
    IN ULONG * FIRMWARE_PTR FileId
    )

/*++

Routine Description:

    This routine searches the device for a file matching FileName.
    If a match is found the dirent for the file is saved and the file is
    opened.

Arguments:

    FileName - Supplies a pointer to a zero terminated file name.

    OpenMode - Supplies the mode of the open.

    FileId - Supplies a pointer to a variable that specifies the file
        table entry that is to be filled in if the open is successful.

Return Value:

    ESUCCESS is returned if the open operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;

    FAT_ENTRY CurrentDirectoryIndex;
    BOOLEAN SearchSucceeded;
    BOOLEAN IsDirectory;
    BOOLEAN IsReadOnly;

    STRING PathName;
    FAT8DOT3 Name;

    FatDebugOutput("FatOpen: %s\r\n", FileName, 0);

    //
    //  Load our local variables
    //

    FileTableEntry = &BlFileTable[*FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Construct a file name descriptor from the input file name
    //

    RtlInitString( &PathName, FileName );

    //
    //  While the path name has some characters in it we'll go through our loop
    //  which extracts the first part of the path name and searches the current
    //  directory for an entry.  If what we find is a directory then we have to
    //  continue looping until we're done with the path name.
    //

    FileTableEntry->u.FatFileContext.DirentLbo = 0;
    FileTableEntry->Position.LowPart = 0;
    FileTableEntry->Position.HighPart = 0;

    CurrentDirectoryIndex = 0;
    SearchSucceeded = TRUE;
    IsDirectory = TRUE;
    IsReadOnly = TRUE;

    if ((PathName.Buffer[0] == '\\') && (PathName.Length == 1)) {

        //
        // We are opening the root directory.
        //
        // N.B.: IsDirectory and SearchSucceeded are already TRUE.
        //

        PathName.Length = 0;

        FileTableEntry->FileNameLength = 1;
        FileTableEntry->FileName[0] = PathName.Buffer[0];

        //
        // Root dirent is all zeroes with a directory attribute.
        //

        RtlZeroMemory(&FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FileTableEntry->u.FatFileContext.Dirent.Attributes = FAT_DIRENT_ATTR_DIRECTORY;

        FileTableEntry->u.FatFileContext.DirentLbo = 0;

        IsReadOnly = FALSE;

        CurrentDirectoryIndex = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

    } else {

        //
        // We are not opening the root directory.
        //

        //
        //  If the search begins in a FAT32 root, set up the starting point
        //  for the  search.
        //

        if (IsBpbFat32(&FatStructureContext->Bpb)) {

            CurrentDirectoryIndex = FatStructureContext->Bpb.RootDirFirstCluster;
        }

        while ((PathName.Length > 0) && IsDirectory) {

            ARC_STATUS Status;

            //
            //  Extract the first component and search the directory for a match, but
            //  first copy the first part to the file name buffer in the file table entry
            //

            if (PathName.Buffer[0] == '\\') {
                PathName.Buffer +=1;
                PathName.Length -=1;
            }

            for (FileTableEntry->FileNameLength = 0;
                 (((USHORT)FileTableEntry->FileNameLength < PathName.Length) &&
                  (PathName.Buffer[FileTableEntry->FileNameLength] != '\\'));
                 FileTableEntry->FileNameLength += 1) {

                FileTableEntry->FileName[FileTableEntry->FileNameLength] =
                                             PathName.Buffer[FileTableEntry->FileNameLength];
            }

            FatFirstComponent( &PathName, (PFAT8DOT3) Name );

            Status = FatSearchForDirent( FatStructureContext,
                                         DeviceId,
                                         CurrentDirectoryIndex,
                                         (PFAT8DOT3) Name,
                                         &FileTableEntry->u.FatFileContext.Dirent,
                                         &FileTableEntry->u.FatFileContext.DirentLbo,
                                         FALSE );

            if (Status == ENOENT) {

                SearchSucceeded = FALSE;
                break;
            }

            if (Status != ESUCCESS) {

                return Status;
            }

            //
            //  We have a match now check to see if it is a directory, and also
            //  if it is readonly
            //

            IsDirectory = BooleanFlagOn( FileTableEntry->u.FatFileContext.Dirent.Attributes,
                                         FAT_DIRENT_ATTR_DIRECTORY );

            IsReadOnly = BooleanFlagOn( FileTableEntry->u.FatFileContext.Dirent.Attributes,
                                        FAT_DIRENT_ATTR_READ_ONLY );

            if (IsDirectory) {

                CurrentDirectoryIndex = FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;

                if (IsBpbFat32(&FatStructureContext->Bpb)) {

                    CurrentDirectoryIndex += 0x10000 *
                         FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi;
                }
            }
        }
    }

    //
    //  If the path name length is not zero then we were trying to crack a path
    //  with an nonexistent (or non directory) name in it.  For example, we tried
    //  to crack a\b\c\d and b is not a directory or does not exist (then the path
    //  name will still contain c\d).
    //

    if (PathName.Length != 0) {

        return ENOTDIR;
    }

    //
    //  At this point we've cracked the name up to (an maybe including the last
    //  component).  We located the last component if the SearchSucceeded flag is
    //  true, otherwise the last component does not exist.  If we located the last
    //  component then this is like an open or a supersede, but not a create.
    //

    if (SearchSucceeded) {

        //
        //  Check if the last component is a directory
        //

        if (IsDirectory) {

            //
            //  For an existing directory the only valid open mode is OpenDirectory
            //  all other modes return an error
            //

            switch (OpenMode) {

            case ArcOpenReadOnly:
            case ArcOpenWriteOnly:
            case ArcOpenReadWrite:
            case ArcCreateWriteOnly:
            case ArcCreateReadWrite:
            case ArcSupersedeWriteOnly:
            case ArcSupersedeReadWrite:

                //
                //  If we reach here then the caller got a directory but didn't
                //  want to open a directory
                //

                return EISDIR;

            case ArcOpenDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to open a directory.
                //

                FileTableEntry->Flags.Open = 1;
                FileTableEntry->Flags.Read = 1;

                return ESUCCESS;

            case ArcCreateDirectory:

                //
                //  If we reach here then the caller got a directory and wanted
                //  to create a new directory
                //

                return EACCES;
            }
        }

        //
        //  If we get there then we have an existing file that is being opened.
        //  We can open existing files through a lot of different open modes in
        //  some cases we need to check the read only part of file and/or truncate
        //  the file.
        //

        switch (OpenMode) {

        case ArcOpenReadOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read only
            //

            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;

            return ESUCCESS;

        case ArcOpenWriteOnly:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file write only
            //

            if (IsReadOnly) { return EROFS; }
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcOpenReadWrite:

            //
            //  If we reach here then the user got a file and wanted to open the
            //  file read/write
            //

            if (IsReadOnly) { return EROFS; }
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcCreateWriteOnly:
        case ArcCreateReadWrite:

            //
            //  If we reach here then the user got a file and wanted to create a new
            //  file
            //

            return EACCES;

        case ArcSupersedeWriteOnly:

            //
            //  If we reach here then the user got a file and wanted to supersede a
            //  file
            //

            if (IsReadOnly) { return EROFS; }
            TruncateFileAllocation( *FileId, 0 );
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcSupersedeReadWrite:

            //
            //  If we reach here then the user got a file and wanted to supersede a
            //  file
            //

            if (IsReadOnly) { return EROFS; }
            TruncateFileAllocation( *FileId, 0 );
            FileTableEntry->Flags.Open = 1;
            FileTableEntry->Flags.Read = 1;
            FileTableEntry->Flags.Write = 1;

            return ESUCCESS;

        case ArcOpenDirectory:
        case ArcCreateDirectory:

            //
            //  If we reach here then the user got a file and wanted a directory
            //

            return ENOTDIR;
        }
    }

    //
    //  If we get here the last component does not exist so we are trying to create
    //  either a new file or a directory.
    //

    switch (OpenMode) {

    case ArcOpenReadOnly:
    case ArcOpenWriteOnly:
    case ArcOpenReadWrite:

        //
        //  If we reach here then the user did not get a file but wanted a file
        //

        return ENOENT;

    case ArcCreateWriteOnly:
    case ArcSupersedeWriteOnly:

        //
        //  If we reach here then the user did not get a file and wanted to create
        //  or supersede a file write only
        //

        RtlZeroMemory( &FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FatSetDirent( (PFAT8DOT3) Name, &FileTableEntry->u.FatFileContext.Dirent, 0 );

        CreateDirent( FatStructureContext,
                      DeviceId,
                      CurrentDirectoryIndex,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      &FileTableEntry->u.FatFileContext.DirentLbo );

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Write = 1;

        return ESUCCESS;

    case ArcCreateReadWrite:
    case ArcSupersedeReadWrite:

        //
        //  If we reach here then the user did not get a file and wanted to create
        //  or supersede a file read/write
        //

        RtlZeroMemory( &FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FatSetDirent( (PFAT8DOT3) Name, &FileTableEntry->u.FatFileContext.Dirent, 0 );

        CreateDirent( FatStructureContext,
                      DeviceId,
                      CurrentDirectoryIndex,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      &FileTableEntry->u.FatFileContext.DirentLbo );

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;
        FileTableEntry->Flags.Write = 1;

        return ESUCCESS;

    case ArcOpenDirectory:

        //
        //  If we reach here then the user did not get a file and wanted to open
        //  an existing directory
        //

        return ENOENT;

    case ArcCreateDirectory:

        //
        //  If we reach here then the user did not get a file and wanted to create
        //  a new directory.
        //

        RtlZeroMemory( &FileTableEntry->u.FatFileContext.Dirent, sizeof(DIRENT));

        FatSetDirent( (PFAT8DOT3) Name,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      FAT_DIRENT_ATTR_DIRECTORY );

        CreateDirent( FatStructureContext,
                      DeviceId,
                      CurrentDirectoryIndex,
                      &FileTableEntry->u.FatFileContext.Dirent,
                      &FileTableEntry->u.FatFileContext.DirentLbo );

        IncreaseFileAllocation( *FileId, sizeof(DIRENT) * 2 );

        {
            DIRENT Buffer;
            LBO Lbo;
            ULONG Count;
            ULONG i;

            RtlZeroMemory((PVOID)&Buffer.FileName[0], sizeof(DIRENT) );

            for (i = 0; i < 11; i += 1) {
                Buffer.FileName[i] = ' ';
            }
            Buffer.Attributes = FAT_DIRENT_ATTR_DIRECTORY;

            VboToLbo( *FileId, 0, &Lbo, &Count );
            Buffer.FileName[0] = FAT_DIRENT_DIRECTORY_ALIAS;

            Buffer.FirstClusterOfFile =
                FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFile;
            Buffer.FirstClusterOfFileHi =
                FileTableEntry->u.FatFileContext.Dirent.FirstClusterOfFileHi;

            DiskWrite( DeviceId, Lbo, sizeof(DIRENT), (PVOID)&Buffer.FileName[0] );

            VboToLbo( *FileId, sizeof(DIRENT), &Lbo, &Count );
            Buffer.FileName[1] = FAT_DIRENT_DIRECTORY_ALIAS;

            Buffer.FirstClusterOfFile = (USHORT)CurrentDirectoryIndex;
            Buffer.FirstClusterOfFileHi = (USHORT)(CurrentDirectoryIndex >> 16);

            DiskWrite( DeviceId, Lbo, sizeof(DIRENT), (PVOID)&Buffer.FileName[0] );
        }

        FileTableEntry->Flags.Open = 1;
        FileTableEntry->Flags.Read = 1;

        return ESUCCESS;
    }

    return( EINVAL );
}


ARC_STATUS
FatRead (
    IN ULONG FileId,
    OUT VOID * FIRMWARE_PTR Buffer,
    IN ULONG Length,
    OUT ULONG * FIRMWARE_PTR Transfer
    )

/*++

Routine Description:

    This routine reads data from the specified file.

Arguments:

    FileId - Supplies the file table index.

    Buffer - Supplies a pointer to the buffer that receives the data
        read.

    Length - Supplies the number of bytes that are to be read.

    Transfer - Supplies a pointer to a variable that receives the number
        of bytes actually transfered.

Return Value:

    ESUCCESS is returned if the read operation is successful.  Otherwise,
    an unsuccessful status is returned that describes the reason for failure.

--*/

{
    PBL_FILE_TABLE FileTableEntry;
    PFAT_STRUCTURE_CONTEXT FatStructureContext;
    ULONG DeviceId;

    FatDebugOutput("FatRead\r\n", 0, 0);

    //
    //  Load out local variables
    //

    FileTableEntry = &BlFileTable[FileId];
    FatStructureContext = (PFAT_STRUCTURE_CONTEXT)FileTableEntry->StructureContext;
    DeviceId = FileTableEntry->DeviceId;

    //
    //  Clear the transfer count
    //

    *Transfer = 0;

    //
    //  Read in runs (i.e., bytes) until the byte count goes to zero
    //

    while (Length > 0) {

        LBO Lbo;

        ULONG CurrentRunByteCount;

        //
        //  Lookup the corresponding Lbo and run length for the current position
        //  (i.e., Vbo).
        //

        if (FatVboToLbo( FileId, FileTableEntry->Position.LowPart, &Lbo, &CurrentRunByteCount, FALSE ) != ESUCCESS) {

            return ESUCCESS;
        }

        //
        //  while there are bytes to be read in from the current run
        //  length and we haven't exhausted the request we loop reading
        //  in bytes.  The biggest request we'll handle is only 32KB
        //  contiguous bytes per physical read.  So we might need to loop
        //  through the run.
        //

        while ((Length > 0) && (CurrentRunByteCount > 0)) {

            LONG SingleReadSize;

            //
            //  Compute the size of the next physical read
    