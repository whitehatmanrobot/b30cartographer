AS_RID_ADMINS, &fIsAdmin) || 
        !SearchGroupForSID(DOMAIN_ALIAS_RID_POWER_USERS, &fIsPowerUser) ||
        !SearchGroupForSID(DOMAIN_ALIAS_RID_GUESTS, &fIsGuest))
    {
        //
        // Don't do anything if we are not sure.
        //
        return FALSE;
    }

    return (fIsUser && !fIsPowerUser && !fIsAdmin && !fIsGuest);
}


// The GENERIC_MAPPING from generic file access rights to specific and standard
// access types.
static GENERIC_MAPPING s_gmFile =
{
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE
};

/*++

 Function Description:

    Given the creation dispositon and the desired access when calling 
    CreateFile, we determine if the caller is requesting write access. 

    This is specific for files.

 Arguments:

    IN pszObject - name of the file or directory.
    OUT pam - points to the access mask of the user to this object.

 Return Value:

    TRUE - successfully got the access mask.
    FALSE otherwise.

 DevNote:

    UNDONE - This might not be a complete list...can add as we debug more apps.

 History:

    02/12/2001 maonis  Created

--*/

BOOL 
RequestWriteAccess(
    IN DWORD dwCreationDisposition, 
    IN DWORD dwDesiredAccess
    )
{
    MapGenericMask(&dwDesiredAccess, &s_gmFile);

    if ((dwCreationDisposition != OPEN_EXISTING) ||
        (dwDesiredAccess & DELETE) || 
        // Generally, app would not specify FILE_WRITE_DATA directly, and if
        // it specifies GENERIC_WRITE, it will get mapped to FILE_WRITE_DATA
        // OR other things so checking FILE_WRITE_DATA is sufficient.
        (dwDesiredAccess & FILE_WRITE_DATA))
    {
        return TRUE;
    }

    return FALSE;
}

/*++

 Function Description:

    Add or remove the SE_PRIVILEGE_ENABLED from the current process.


 Arguments:

    IN pwszPrivilege    Name of the priv. to modify.
    IN fEnable          Add or remove SE_PRIVILEGE_ENABLED

 Return Value:

    TRUE - if SE_PRIVILEGE_ENABLED was successfully added or removed.
    FALSE otherwise.

    04/03/2001 maonis  Created

--*/

BOOL 
AdjustPrivilege(
    LPCWSTR pwszPrivilege, 
    BOOL fEnable
    )
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    BOOL fRes = FALSE;

    // Obtain the process token.
    if (OpenProcessToken(
        GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
        &hToken))
    {
        // Get the LUID.
        if (LookupPrivilegeValueW(NULL, pwszPrivilege, &tp.Privileges[0].Luid))
        {        
            tp.PrivilegeCount = 1;

            tp.Privileges[0].Attributes = (fEnable ? SE_PRIVILEGE_ENABLED : 0);

            // Enable or disable the privilege.
            if (AdjustTokenPrivileges(
                hToken, 
                FALSE, 
                &tp, 
                0,
                (PTOKEN_PRIVILEGES)NULL, 
                0))
            {
                fRes = TRUE;
            }
        }

        CloseHandle(hToken);
    }

    return fRes;
}



};  // end of namespace ShimLib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\lua.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   lua.h

 Abstract:

   Exports used by ntvdm.

 Created:

   05/31/2001 maonis

 Modified:

--*/

#ifndef _LUA__H_
#define _LUA__H_

#ifndef EXTERN_C
#if defined(__cplusplus)
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif
#endif

EXTERN_C BOOL      LuaShouldApplyShim();
EXTERN_C BOOL      LuaFSInit(LPCSTR pszCommandLine);
EXTERN_C BOOL      LuaRegInit();
EXTERN_C BOOL      LuacFSInit(LPCSTR pszCommandLine);
EXTERN_C VOID      LuacFSCleanup();
EXTERN_C BOOL      LuacRegInit();
EXTERN_C VOID      LuacRegCleanup();
EXTERN_C BOOL      LuatFSInit();
EXTERN_C VOID      LuatFSCleanup();

//
// Redirect routines.
//

EXTERN_C HANDLE    LuaCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
EXTERN_C BOOL      LuaDeleteFileW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuaRemoveDirectoryW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuaCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
EXTERN_C BOOL      LuaCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
EXTERN_C BOOL      LuaMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
EXTERN_C DWORD     LuaGetFileAttributesW(LPCWSTR wcsFileName);
EXTERN_C BOOL      LuaSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
EXTERN_C UINT      LuaGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);

EXTERN_C UINT      LuaGetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);
EXTERN_C DWORD     LuaGetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);
EXTERN_C DWORD     LuaGetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);
EXTERN_C DWORD     LuaGetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR  lpReturnedString, DWORD  nSize, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaGetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaWritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuaWritePrivateProfileStructW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);

EXTERN_C LONG      LuaRegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
EXTERN_C LONG      LuaRegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
EXTERN_C LONG      LuaRegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult); 
EXTERN_C LONG      LuaRegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
EXTERN_C LONG      LuaRegCloseKey(HKEY hkey);
EXTERN_C LONG      LuaRegQueryValueW(HKEY hkey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);
EXTERN_C LONG      LuaRegQueryValueExW(HKEY hkey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
EXTERN_C LONG      LuaRegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);
EXTERN_C LONG      LuaRegSetValueExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE * lpData, DWORD cbData);
EXTERN_C LONG      LuaRegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
EXTERN_C LONG      LuaRegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
EXTERN_C LONG      LuaRegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
EXTERN_C LONG      LuaRegDeleteKeyW(HKEY hKey,LPCWSTR lpSubKey);

//
// Cleanup routines.
//

EXTERN_C HANDLE    LuacFindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
EXTERN_C DWORD     LuacGetFileAttributesW(LPCWSTR wcsFileName);
EXTERN_C HANDLE    LuacCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
EXTERN_C BOOL      LuacDeleteFileW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuacRemoveDirectoryW(LPCWSTR lpFileName);

EXTERN_C LONG      LuacRegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);
EXTERN_C LONG      LuacRegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
EXTERN_C LONG      LuacRegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cbName);
EXTERN_C LONG      LuacRegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
EXTERN_C LONG      LuacRegCloseKey(HKEY hkey);
EXTERN_C LONG      LuacRegDeleteKeyW(HKEY hKey,LPCWSTR lpSubKey);

//
// Tracking routines.
//

EXTERN_C HANDLE    LuatCreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
EXTERN_C BOOL      LuatCopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);
EXTERN_C BOOL      LuatCreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
EXTERN_C BOOL      LuatSetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);
EXTERN_C BOOL      LuatDeleteFileW(LPCWSTR lpFileName);
EXTERN_C BOOL      LuatMoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);
EXTERN_C BOOL      LuatRemoveDirectoryW(LPCWSTR lpFileName);
EXTERN_C UINT      LuatGetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);

EXTERN_C BOOL      LuatWritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuatWritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);
EXTERN_C BOOL      LuatWritePrivateProfileStructW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR lpFileName);

#endif // _LUA__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\precomp.h ===
#ifndef _LUA_PRECOMP_H_
#define _LUA_PRECOMP_H_

#include "ShimHook.h"
using namespace ShimLib;

#include "lua.h"

#endif // _LUA_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\main.cpp ===
#include "precomp.h"
#include "ShimHookMacro.h"

DECLARE_SHIM(LUARedirectFS)
DECLARE_SHIM(LUARedirectReg)
DECLARE_SHIM(LUARedirectFS_Cleanup)
DECLARE_SHIM(LUARedirectReg_Cleanup)
DECLARE_SHIM(LUATrackFS)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcLua", eDbgLevelSpew, "LUA Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("AcLua", eDbgLevelSpew, "LUA Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(LUARedirectFS)
    MULTISHIM_ENTRY(LUARedirectReg)
    MULTISHIM_ENTRY(LUARedirectFS_Cleanup)
    MULTISHIM_ENTRY(LUARedirectReg_Cleanup)
    MULTISHIM_ENTRY(LUATrackFS)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\lua_redirectreg.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_RedirectReg.cpp

 Abstract:
    Redirect the reg keys to current user hive when the app needs to 
    write to them but doesn't have enough access rights.

 Notes:

    This is a general purpose shim.

 History:

    02/14/2001 maonis  Created
    05/30/2001 maonis  Moved the bulk into lua.dll.

--*/

#include "precomp.h"
#include "utils.h"

LONG LuaRegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
LONG LuaRegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult); 
LONG LuaRegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult); 
LONG LuaRegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
LONG LuaRegQueryValueA(HKEY hkey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData);
LONG LuaRegQueryValueExA(HKEY hkey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG LuaRegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
LONG LuaRegSetValueExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, DWORD dwType, CONST BYTE *lpData, DWORD cbData);
LONG LuaRegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LONG LuaRegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cbName);
LONG LuaRegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcbName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcbClass, PFILETIME lpftLastWriteTime);
LONG LuaRegDeleteKeyA(HKEY hKey,LPCSTR lpSubKey);

IMPLEMENT_SHIM_BEGIN(LUARedirectReg)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegEnumValueA)
    APIHOOK_ENUM_ENTRY(RegEnumValueW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyA(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyW(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyExA(
        hKey, 
        lpSubKey,
        ulOptions,
        samDesired, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    return LuaRegOpenKeyExW(
        hKey, 
        lpSubKey, 
        ulOptions,
        samDesired, 
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyA)(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    return LuaRegCreateKeyA(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    return LuaRegCreateKeyW(
        hKey, 
        lpSubKey, 
        phkResult);
}

LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD Reserved,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    return LuaRegCreateKeyExA(
        hKey, 
        lpSubKey,
        Reserved,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition);
}

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD Reserved,           
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    return LuaRegCreateKeyExW(
        hKey, 
        lpSubKey,
        Reserved,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition);
}

LONG 
APIHOOK(RegQueryValueA)(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPSTR lpValue,
    PLONG lpcbValue
    )
{
    return LuaRegQueryValueA(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPWSTR  lpValue,
    PLONG lpcbValue
    )
{
    return LuaRegQueryValueW(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPCSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegQueryValueExA(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG 
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegQueryValueExW(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG      
APIHOOK(RegSetValueA)(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD dwType, 
    LPCSTR lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueA(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueW)(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD dwType, 
    LPCWSTR lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueW(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExA)(
    HKEY hKey, 
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueExA(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG      
APIHOOK(RegSetValueExW)(
    HKEY hKey, 
    LPCTSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    return LuaRegSetValueExW(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG 
APIHOOK(RegEnumValueA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegEnumValueA(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
APIHOOK(RegEnumValueW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    return LuaRegEnumValueW(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    return LuaRegEnumKeyA(
        hKey,
        dwIndex,
        lpName,
        cbName);
}

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    return LuaRegEnumKeyW(
        hKey,
        dwIndex,
        lpName,
        cbName);
}

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    return LuaRegEnumKeyExA(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    return LuaRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    return LuaRegCloseKey(hKey);
}

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    return LuaRegDeleteKeyA(hKey, lpSubKey);
}

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    return LuaRegDeleteKeyW(hKey, lpSubKey);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return LuaRegInit();
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    if (LuaShouldApplyShim())
    {
        CALL_NOTIFY_FUNCTION

        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
        APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW)
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\lua_redirectfs_cleanup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LUA_RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   03/30/2001 maonis

 Modified:


--*/
#include "precomp.h"
#include "utils.h"

IMPLEMENT_SHIM_BEGIN(LUARedirectFS_Cleanup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)

APIHOOK_ENUM_END

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR lpFileName,               
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    return LuacFindFirstFileW(lpFileName, lpFindFileData);
}

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,               
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    STRINGA2W wstrFileName(lpFileName);

    if (wstrFileName.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(FindFirstFileA)(
            lpFileName,
            lpFindFileData);
    }

    HANDLE hFind;
    WIN32_FIND_DATAW fdw;
    
    if ((hFind = LuacFindFirstFileW(wstrFileName, &fdw)) != INVALID_HANDLE_VALUE)
    {
        FindDataW2A(&fdw, lpFindFileData);
    }

    return hFind;
}

DWORD 
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName
    )
{
    return LuacGetFileAttributesW(lpFileName);
}

DWORD 
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(GetFileAttributesA)(lpFileName) :
        LuacGetFileAttributesW(wstrFileName));
}

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return LuacCreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
    
        ORIGINAL_API(CreateFileA)(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile) :

        LuacCreateFileW(
            wstrFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile));
}

BOOL 
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    return LuacDeleteFileW(lpFileName);
}

BOOL 
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ? 
        ORIGINAL_API(DeleteFileA)(lpFileName) :
        LuacDeleteFileW(wstrFileName));
}

BOOL 
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName
    )
{
    return LuacRemoveDirectoryW(lpPathName);
}

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(RemoveDirectoryA)(lpPathName) :
        LuacRemoveDirectoryW(wstrPathName));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        return LuacFSInit(COMMAND_LINE);
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        LuacFSCleanup();
    }

    return TRUE;
}

/*++

  Register hooked functions

--*/
HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\lua_trackfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_TrackFS.cpp

 Abstract:
    Track the directories the app looks at and record them into a file.

 Notes:

    This is a general purpose shim.

 History:

    04/04/2001 maonis  Created

--*/

#include "precomp.h"
#include "utils.h"

HFILE LuatOpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);
HFILE Luat_lopen(LPCSTR, int);
HFILE Luat_lcreat(LPCSTR, int);

class CTrackObject;
extern CTrackObject g_td;

IMPLEMENT_SHIM_BEGIN(LUATrackFS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(GetTempFileNameA)
    APIHOOK_ENUM_ENTRY(GetTempFileNameW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)
    
APIHOOK_ENUM_END

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return LuatCreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
    
        ORIGINAL_API(CreateFileA)(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile) :

        LuatCreateFileW(
            wstrFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile));
}

BOOL 
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{    
    return LuatCopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
}

BOOL 
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(CopyFileA)(lpExistingFileName, lpNewFileName, bFailIfExists) :
        LuatCopyFileW(wstrExistingFileName, wstrNewFileName, bFailIfExists));
}

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{
    return LuatOpenFile(lpFileName, lpReOpenBuff, uStyle);
}

HFILE 
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    return Luat_lopen(lpPathName, iReadWrite);
}

HFILE 
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    return Luat_lcreat(lpPathName, iAttribute);
}

BOOL 
APIHOOK(CreateDirectoryW)(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    return LuatCreateDirectoryW(lpPathName, lpSecurityAttributes);
}

BOOL 
APIHOOK(CreateDirectoryA)(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(CreateDirectoryA)(lpPathName, lpSecurityAttributes) :
        LuatCreateDirectoryW(wstrPathName, lpSecurityAttributes));
}

BOOL 
APIHOOK(SetFileAttributesW)(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    return LuatSetFileAttributesW(lpFileName, dwFileAttributes);
}

BOOL 
APIHOOK(SetFileAttributesA)(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(SetFileAttributesA)(lpFileName, dwFileAttributes) :
        LuatSetFileAttributesW(wstrFileName, dwFileAttributes));
}

BOOL 
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    return LuatDeleteFileW(lpFileName);
}


BOOL 
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ? 
        ORIGINAL_API(DeleteFileA)(lpFileName) :
        LuatDeleteFileW(wstrFileName));
}

BOOL 
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    return LuatMoveFileW(lpExistingFileName, lpNewFileName);
}

BOOL 
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(MoveFileA)(lpExistingFileName, lpNewFileName) :
        LuatMoveFileW(wstrExistingFileName, wstrNewFileName));
}

BOOL 
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName
    )
{
    return LuatRemoveDirectoryW(lpPathName);
}


BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(RemoveDirectoryA)(lpPathName) :
        LuatRemoveDirectoryW(wstrPathName));
}

UINT 
APIHOOK(GetTempFileNameW)(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
)
{
    return LuatGetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
}

UINT 
APIHOOK(GetTempFileNameA)(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
)
{
    STRINGA2W wstrPathName(lpPathName);
    STRINGA2W wstrPrefixString(lpPrefixString);

    if (wstrPathName.m_fIsOutOfMemory || wstrPrefixString.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(GetTempFileNameA)(
            lpPathName,
            lpPrefixString,
            uUnique,
            lpTempFileName);
    }

    WCHAR wstrTempFileName[MAX_PATH];
    UINT uiRes;
    
    if (uiRes = LuatGetTempFileNameW(
        wstrPathName,
        wstrPrefixString,
        uUnique,
        wstrTempFileName))
    {
        UnicodeToAnsi(wstrTempFileName, lpTempFileName);
    }

    return uiRes;
}

BOOL 
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuatWritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory ||
        wstrKeyName.m_fIsOutOfMemory ||
        wstrString.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStringA)(
            lpAppName,
            lpKeyName,
            lpString,
            lpFileName) :

        LuatWritePrivateProfileStringW(
            wstrAppName,
            wstrKeyName,
            wstrString,
            wstrFileName));
}

BOOL 
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuatWritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory || 
        wstrString.m_fIsOutOfMemory || 
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileSectionA)(
            lpAppName,
            lpString,
            lpFileName) :

        LuatWritePrivateProfileSectionW(
            wstrAppName,
            wstrString,
            wstrFileName));
}

BOOL 
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    return LuatWritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);
}

BOOL 
APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    )
{
    STRINGA2W wstrSection(lpszSection);
    STRINGA2W wstrKey(lpszKey);
    STRINGA2W wstrFile(szFile);

    return ((wstrSection.m_fIsOutOfMemory ||
        wstrKey.m_fIsOutOfMemory ||
        wstrFile.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStructA)(
            lpszSection,
            lpszKey,
            lpStruct,
            uSizeStruct,
            szFile) :

        LuatWritePrivateProfileStructW(
            wstrSection,
            wstrKey,
            lpStruct,
            uSizeStruct,
            wstrFile));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return LuatFSInit();
    }
    else if (fdwReason == DLL_PROCESS_DETACH)
    {
        LuatFSCleanup();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
    APIHOOK_ENTRY(KERNEL32.DLL, _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL, _lcreat)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, MoveFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, MoveFileW)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameW)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\lua_redirectreg_cleanup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   LUA_RedirectReg_Cleanup.cpp

 Abstract:

   Delete the redirected keys from the original location and every user's 
   hive.

 Created:

   03/21/2001 maonis

 Modified:


--*/
#include "precomp.h"
#include "utils.h"

IMPLEMENT_SHIM_BEGIN(LUARedirectReg_Cleanup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END

LONG 
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    return LuacRegOpenKeyExW(
        hKey,         
        lpSubKey,  
        ulOptions,   
        samDesired, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    WCHAR wszSubKey[MAX_PATH] = L"";
    AnsiToUnicode(lpSubKey, wszSubKey);

    return LuacRegOpenKeyExW(
        hKey,
        wszSubKey,
        ulOptions,
        samDesired,
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuacRegOpenKeyExW(
        hKey,
        lpSubKey,
        0, 
        MAXIMUM_ALLOWED, 
        phkResult);
}

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return APIHOOK(RegOpenKeyExA)(
        hKey,
        lpSubKey,
        0, 
        MAXIMUM_ALLOWED, 
        phkResult);
}

LONG 
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{   
    return LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    WCHAR wszName[MAX_PATH];
    DWORD dwName = MAX_PATH;

    LONG lRes = LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        wszName,
        &dwName,
        lpReserved,
        NULL,
        NULL,
        lpftLastWriteTime);

    if (lRes == ERROR_SUCCESS)
    {
        // Convert the values back to ansi.
        DWORD dwByte = WideCharToMultiByte(
            CP_ACP, 
            0, 
            wszName, 
            dwName, 
            lpName, 
            *lpcbName, 
            0, 
            0);
        
        lpName[dwByte] = '\0'; 
        *lpcbName = dwByte;
        if (!dwByte)
        {
            lRes = GetLastError();
            
            // Generate a registry error code.
            if (lRes == ERROR_INSUFFICIENT_BUFFER)
            {
                lRes = ERROR_MORE_DATA;
            }
        }        
    }

    return lRes;   
}

LONG 
APIHOOK(RegEnumKeyW)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    return LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
APIHOOK(RegEnumKeyA)(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    return APIHOOK(RegEnumKeyExA)(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
APIHOOK(RegCloseKey)(HKEY hKey)
{
    return LuacRegCloseKey(hKey);
}

LONG      
APIHOOK(RegDeleteKeyW)(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    return LuacRegDeleteKeyW(hKey, lpSubKey);
}

LONG      
APIHOOK(RegDeleteKeyA)(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    WCHAR wszSubKey[MAX_PATH] = L"";
    AnsiToUnicode(lpSubKey, wszSubKey);

    return LuacRegDeleteKeyW(hKey, wszSubKey);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        return LuacRegInit();
    }

    if (fdwReason == DLL_PROCESS_DETACH)
    {
        LuacRegCleanup();
    }

    return TRUE;
}

/*++

  Register hooked functions

--*/
HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\lua_redirectfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_RedirectFS.cpp

 Abstract:

    When the app gets access denied when trying to modify a file because 
    it doesn't have sufficient access rights, we redirect the file to a 
    location where the app does have enough access rights to do so. 
    
    This file mostly contains stubs. For implementation details on how the
    redirection is done see RedirectFS.cpp.
    
 Notes:

    This is a general purpose shim.

 History:

    02/12/2001 maonis  Created
    05/21/2001 maonis  Moved the bulk work into RedirectFS.cpp.

--*/

#include "precomp.h"
#include "utils.h"
#include "RedirectFS.h"

IMPLEMENT_SHIM_BEGIN(LUARedirectFS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindNextFileA)
    APIHOOK_ENUM_ENTRY(FindNextFileW)
    APIHOOK_ENUM_ENTRY(FindClose)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(GetTempFileNameA)
    APIHOOK_ENUM_ENTRY(GetTempFileNameW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)

APIHOOK_ENUM_END

HANDLE 
APIHOOK(CreateFileW)(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    return LuaCreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

HANDLE 
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    STRINGA2W wstrFileName(lpFileName);
    return (wstrFileName.m_fIsOutOfMemory ?
    
        ORIGINAL_API(CreateFileA)(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile) :

        LuaCreateFileW(
            wstrFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile));
}

BOOL 
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    return LuaCopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
}

BOOL 
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(CopyFileA)(lpExistingFileName, lpNewFileName, bFailIfExists) :
        LuaCopyFileW(wstrExistingFileName, wstrNewFileName, bFailIfExists));
}

DWORD 
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName
    )
{
    return LuaGetFileAttributesW(lpFileName);
}

DWORD 
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(GetFileAttributesA)(lpFileName) :
        LuaGetFileAttributesW(wstrFileName));
}

BOOL 
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    return LuaDeleteFileW(lpFileName);
}

BOOL 
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ? 
        ORIGINAL_API(DeleteFileA)(lpFileName) :
        LuaDeleteFileW(wstrFileName));
}

//
// ----- Begin out-of-date API hooks -----
// This is taken from the nt base code with modifications to do the redirection.
// 

#ifndef BASE_OF_SHARE_MASK
#define BASE_OF_SHARE_MASK 0x00000070
#endif 

ULONG
BasepOfShareToWin32Share(
    IN ULONG OfShare
    )
{
    DWORD ShareMode;

    if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_READ ) {
        ShareMode = FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_WRITE ) {
        ShareMode = FILE_SHARE_READ;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_DENY_NONE ) {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
        }
    else if ( (OfShare & BASE_OF_SHARE_MASK) == OF_SHARE_EXCLUSIVE ) {
        ShareMode = 0;
        }
    else {
        ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;
        }
    return ShareMode;
}

ULONG BaseSetLastNTError(IN NTSTATUS Status)
{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}

UINT GetErrorMode()
{
    UINT PreviousMode;
    NTSTATUS Status;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDefaultHardErrorMode,
                (PVOID) &PreviousMode,
                sizeof(PreviousMode),
                NULL
                );
    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return 0;
        }

    if (PreviousMode & 1) {
        PreviousMode &= ~SEM_FAILCRITICALERRORS;
        }
    else {
        PreviousMode |= SEM_FAILCRITICALERRORS;
        }
    return PreviousMode;
}

BOOL
CheckAlternateLocation(
    LPCSTR pFileName,
    LPSTR pszPathName,
    DWORD* pdwPathLength
    )
{
    *pdwPathLength = 0;

    STRINGA2W wstrFileName(pFileName);
    if (wstrFileName.m_fIsOutOfMemory)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    REDIRECTFILE rf(wstrFileName);

    if (rf.m_pwszAlternateName)
    {
        DWORD cRedirectRoot = 
            (rf.m_fAllUser ? g_cRedirectRootAllUser : g_cRedirectRootPerUser);

        //
        // We need to convert the alternate path back to a normal path.
        //
        WCHAR chDrive = rf.m_pwszAlternateName[cRedirectRoot];
        LPWSTR pwszTempPathName = rf.m_pwszAlternateName + cRedirectRoot - 1;
        *pwszTempPathName = chDrive;
        *(pwszTempPathName + 1) = L':';

        DPF("RedirectFS", eDbgLevelInfo, 
            "[CheckAlternateLocation] Converted back to %S", pwszTempPathName);

        //
        // Convert back to ansi.
        //
        DWORD cLen = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszTempPathName, 
            -1, 
            NULL, 
            0, 
            0, 
            0);

        if (cLen > OFS_MAXPATHNAME)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[CheckAlternateLocation] File name requires %d bytes which is "
                "more than OFS_MAXPATHNAME", 
                cLen);

            return FALSE;
        }

        *pdwPathLength = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszTempPathName, 
            -1, 
            pszPathName, 
            OFS_MAXPATHNAME, 
            0, 
            0);
    }

    return TRUE;
}

HFILE 
APIHOOK(OpenFile)(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[OpenFile] lpFileName=%s", lpFileName);

    BOOL b;
    FILETIME LastWriteTime;
    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;
    DWORD PathLength;
    LPSTR FilePart;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_FS_DEVICE_INFORMATION DeviceInfo;
    NTSTATUS Status;
    OFSTRUCT OriginalReOpenBuff;
    BOOL SearchFailed;

    SearchFailed = FALSE;
    OriginalReOpenBuff = *lpReOpenBuff;
    hFile = (HANDLE)-1;
    __try {
        SetLastError(0);

        if ( uStyle & OF_PARSE ) {
            PathLength = GetFullPathNameA(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            lpReOpenBuff->fFixedDisk = 1;
            lpReOpenBuff->nErrCode = 0;
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            hFile = (HANDLE)0;
            goto finally_exit;
            }
        //
        // Compute Desired Access
        //

        if ( uStyle & OF_WRITE ) {
            DesiredAccess = GENERIC_WRITE;
            }
        else {
            DesiredAccess = GENERIC_READ;
            }
        if ( uStyle & OF_READWRITE ) {
            DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
            }

        //
        // Compute ShareMode
        //

        ShareMode = BasepOfShareToWin32Share(uStyle);

        //
        // Compute Create Disposition
        //

        CreateDisposition = OPEN_EXISTING;
        if ( uStyle & OF_CREATE ) {
            CreateDisposition = CREATE_ALWAYS;
            DesiredAccess = (GENERIC_READ | GENERIC_WRITE);
            }

        DPF("RedirectFS", eDbgLevelInfo,
            "[OpenFile] ShareMode=0x%08x; CreateDisposition=%d; DesiredAccess=0x%08x",
            ShareMode, CreateDisposition, DesiredAccess);

        //
        // if this is anything other than a re-open, fill the re-open buffer
        // with the full pathname for the file
        //

        if ( !(uStyle & OF_REOPEN) ) {
            PathLength = SearchPathA(NULL,lpFileName,NULL,OFS_MAXPATHNAME-1,lpReOpenBuff->szPathName,&FilePart);
  
            //
            // If we are trying to open an existing file we should also check the alternate location.
            //
            if ( (uStyle & OF_EXIST) && (PathLength == 0) && lpFileName)
            {
                if (!CheckAlternateLocation(lpFileName, lpReOpenBuff->szPathName, &PathLength)) 
                {
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                }
            }

            if ( PathLength > (OFS_MAXPATHNAME - 1) ) {
                SetLastError(ERROR_INVALID_DATA);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            if ( PathLength == 0 ) {
                SearchFailed = TRUE;
                PathLength = GetFullPathNameA(lpFileName,(OFS_MAXPATHNAME - 1),lpReOpenBuff->szPathName,&FilePart);
                if ( !PathLength || PathLength > (OFS_MAXPATHNAME - 1) ) {
                    SetLastError(ERROR_INVALID_DATA);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                }
            }

        //
        // Special case, Delete, Exist, and Parse
        //

        if ( uStyle & OF_EXIST ) {
            if ( !(uStyle & OF_CREATE) ) {
                DWORD FileAttributes;

                if (SearchFailed) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }

                FileAttributes = APIHOOK(GetFileAttributesA)(lpReOpenBuff->szPathName);
                if ( FileAttributes == 0xffffffff ) {
                    SetLastError(ERROR_FILE_NOT_FOUND);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {
                    SetLastError(ERROR_ACCESS_DENIED);
                    hFile = (HANDLE)-1;
                    goto finally_exit;
                    }
                else {
                    hFile = (HANDLE)1;
                    lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                    goto finally_exit;
                    }
                }
            }

        if ( uStyle & OF_DELETE ) {
            if ( APIHOOK(DeleteFileA)(lpReOpenBuff->szPathName) ) {
                lpReOpenBuff->nErrCode = 0;
                lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
                hFile = (HANDLE)1;
                goto finally_exit;
                }
            else {
                lpReOpenBuff->nErrCode = ERROR_FILE_NOT_FOUND;
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }


        //
        // Open the file
        //

retry_open:
        hFile = APIHOOK(CreateFileA)(
                    lpReOpenBuff->szPathName,
                    DesiredAccess,
                    ShareMode,
                    NULL,
                    CreateDisposition,
                    0,
                    NULL
                    );

        if ( hFile == INVALID_HANDLE_VALUE ) {

            if ( uStyle & OF_PROMPT && !(GetErrorMode() & SEM_NOOPENFILEERRORBOX) ) {
                {
                    DWORD WinErrorStatus;
                    NTSTATUS st,HardErrorStatus;
                    ULONG_PTR ErrorParameter;
                    ULONG ErrorResponse;
                    ANSI_STRING AnsiString;
                    UNICODE_STRING UnicodeString;

                    WinErrorStatus = GetLastError();
                    if ( WinErrorStatus == ERROR_FILE_NOT_FOUND ) {
                        HardErrorStatus = STATUS_NO_SUCH_FILE;
                        }
                    else if ( WinErrorStatus == ERROR_PATH_NOT_FOUND ) {
                        HardErrorStatus = STATUS_OBJECT_PATH_NOT_FOUND;
                        }
                    else {
                        goto finally_exit;
                        }

                    //
                    // Hard error time
                    //

                    RtlInitAnsiString(&AnsiString,lpReOpenBuff->szPathName);
                    st = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
                    if ( !NT_SUCCESS(st) ) {
                        goto finally_exit;
                        }
                    ErrorParameter = (ULONG_PTR)&UnicodeString;

                    HardErrorStatus = NtRaiseHardError(
                                        HardErrorStatus | HARDERROR_OVERRIDE_ERRORMODE,
                                        1,
                                        1,
                                        &ErrorParameter,
                                        OptionRetryCancel,
                                        &ErrorResponse
                                        );
                    RtlFreeUnicodeString(&UnicodeString);
                    if ( NT_SUCCESS(HardErrorStatus) && ErrorResponse == ResponseRetry ) {
                        goto retry_open;
                        }
                    }
                }
            goto finally_exit;
            }

        if ( uStyle & OF_EXIST ) {
            CloseHandle(hFile);
            hFile = (HANDLE)1;
            lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);
            goto finally_exit;
            }

        //
        // Determine if this is a hard disk.
        //

        Status = NtQueryVolumeInformationFile(
                    hFile,
                    &IoStatusBlock,
                    &DeviceInfo,
                    sizeof(DeviceInfo),
                    FileFsDeviceInformation
                    );
        if ( !NT_SUCCESS(Status) ) {
            CloseHandle(hFile);
            BaseSetLastNTError(Status);
            hFile = (HANDLE)-1;
            goto finally_exit;
            }
        switch ( DeviceInfo.DeviceType ) {

            case FILE_DEVICE_DISK:
            case FILE_DEVICE_DISK_FILE_SYSTEM:
                if ( DeviceInfo.Characteristics & FILE_REMOVABLE_MEDIA ) {
                    lpReOpenBuff->fFixedDisk = 0;
                    }
                else {
                    lpReOpenBuff->fFixedDisk = 1;
                    }
                break;

            default:
                lpReOpenBuff->fFixedDisk = 0;
                break;
            }

        //
        // Capture the last write time and save in the open struct.
        //

        b = GetFileTime(hFile,NULL,NULL,&LastWriteTime);

        if ( !b ) {
            lpReOpenBuff->Reserved1 = 0;
            lpReOpenBuff->Reserved2 = 0;
            }
        else {
            b = FileTimeToDosDateTime(
                    &LastWriteTime,
                    &lpReOpenBuff->Reserved1,
                    &lpReOpenBuff->Reserved2
                    );
            if ( !b ) {
                lpReOpenBuff->Reserved1 = 0;
                lpReOpenBuff->Reserved2 = 0;
                }
            }

        lpReOpenBuff->cBytes = sizeof(*lpReOpenBuff);

        //
        // The re-open buffer is completely filled in. Now
        // see if we are quitting (parsing), verifying, or
        // just returning with the file opened.
        //

        if ( uStyle & OF_VERIFY ) {
            if ( OriginalReOpenBuff.Reserved1 == lpReOpenBuff->Reserved1 &&
                 OriginalReOpenBuff.Reserved2 == lpReOpenBuff->Reserved2 &&
                 !strcmp(OriginalReOpenBuff.szPathName,lpReOpenBuff->szPathName) ) {
                goto finally_exit;
                }
            else {
                *lpReOpenBuff = OriginalReOpenBuff;
                CloseHandle(hFile);
                hFile = (HANDLE)-1;
                goto finally_exit;
                }
            }
finally_exit:;
        }
    __finally {
        lpReOpenBuff->nErrCode = (WORD)GetLastError();
        }

    return (HFILE)(ULONG_PTR)(hFile);
}

HFILE 
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[_lopen] lpPathName=%s", lpPathName);

    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);
    //
    // Compute Desired Access
    //

    if ( iReadWrite & OF_WRITE ) {
        DesiredAccess = GENERIC_WRITE;
        }
    else {
        DesiredAccess = GENERIC_READ;
        }
    if ( iReadWrite & OF_READWRITE ) {
        DesiredAccess |= (GENERIC_READ | GENERIC_WRITE);
        }

    //
    // Compute ShareMode
    //

    ShareMode = BasepOfShareToWin32Share((DWORD)iReadWrite);

    CreateDisposition = OPEN_EXISTING;

    //
    // Open the file
    //

    hFile = APIHOOK(CreateFileA)(
                lpPathName,
                DesiredAccess,
                ShareMode,
                NULL,
                CreateDisposition,
                0,
                NULL
                );

    return (HFILE)(ULONG_PTR)(hFile);
}

#ifndef FILE_ATTRIBUTE_VALID_FLAGS
#define FILE_ATTRIBUTE_VALID_FLAGS      0x00003fb7
#endif

HFILE 
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[_lcreat] lpPathName=%s", lpPathName);

    HANDLE hFile;
    DWORD DesiredAccess;
    DWORD ShareMode;
    DWORD CreateDisposition;

    SetLastError(0);

    //
    // Compute Desired Access
    //

    DesiredAccess = (GENERIC_READ | GENERIC_WRITE);

    ShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;;

    //
    // Compute Create Disposition
    //

    CreateDisposition = CREATE_ALWAYS;

    //
    // Open the file
    //

    hFile = APIHOOK(CreateFileA)(
                lpPathName,
                DesiredAccess,
                ShareMode,
                NULL,
                CreateDisposition,
                iAttribute & FILE_ATTRIBUTE_VALID_FLAGS,
                NULL
                );

    return (HFILE)(ULONG_PTR)(hFile);
}

//
// ----- End out-of-date API hooks -----
// 

BOOL 
APIHOOK(CreateDirectoryW)(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    return LuaCreateDirectoryW(lpPathName, lpSecurityAttributes);
}

BOOL 
APIHOOK(CreateDirectoryA)(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(CreateDirectoryA)(lpPathName, lpSecurityAttributes) :
        LuaCreateDirectoryW(wstrPathName, lpSecurityAttributes));
}

BOOL 
APIHOOK(SetFileAttributesW)(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    return LuaSetFileAttributesW(lpFileName, dwFileAttributes);
}

DWORD 
APIHOOK(SetFileAttributesA)(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    STRINGA2W wstrFileName(lpFileName);

    return (wstrFileName.m_fIsOutOfMemory ?
        ORIGINAL_API(SetFileAttributesA)(lpFileName, dwFileAttributes) :
        LuaSetFileAttributesW(wstrFileName, dwFileAttributes));
}

//
// Find*File stuff.
//

// This version is for FindFirstFile, we search for the last back slash
// to get the file name, then search for wildcards in the file name.
BOOL 
HasWildCards(
    LPCWSTR pwszName
    )
{
    LPWSTR pwszLastSlash = wcsrchr(pwszName, L'\\');

    LPCWSTR pwszStartSearching = pwszName;
    
    if (pwszLastSlash)
    {
        pwszStartSearching += pwszLastSlash - pwszName + 1;
    }

    for (; *pwszStartSearching; ++pwszStartSearching)
    {
        if (*pwszStartSearching == L'*' || *pwszStartSearching == L'?')
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID GetFullPath(
    LPCWSTR pwszFileName,
    LPWSTR pwszFullPath
    )
{
    wcscpy(pwszFullPath, pwszFileName);
    LPWSTR pwszLastSlash = wcsrchr(pwszFullPath, L'\\');

    if (pwszLastSlash)
    {
        *pwszLastSlash = L'\\';
        *++pwszLastSlash = L'\0';
    }
}

// This is for Find*File APIs.
BOOL IsFoundFileInRedirectList(
    LPCWSTR pwszFullPath,
    LPCWSTR pwszFileName
    )
{
    WCHAR wszFileName[MAX_PATH] = L"";
    
    DWORD cPathLen = wcslen(pwszFullPath);
    DWORD cFileLen = wcslen(pwszFileName);

    //
    // Make sure we don't overflow.
    //
    if (cPathLen + cFileLen + 1 > MAX_PATH)
    {
        return FALSE;
    }

    wcsncpy(wszFileName, pwszFullPath, cPathLen);
    wcsncpy(wszFileName + cPathLen, pwszFileName, cFileLen);
    wszFileName[cPathLen + cFileLen] = L'\0';

    return IsInRedirectList(wszFileName);
}

struct FINDFILE 
{
    FINDFILE* next;
    WCHAR wszFileName[MAX_PATH];
};

struct FINDFILEINFO 
{
    FINDFILEINFO() 
    { 
        InitializeCriticalSection(&m_Lock);
        files = NULL; 
        fCheckRedirectList = TRUE;
        fCheckDuplicate = FALSE;
    }

    ~FINDFILEINFO() 
    {
        Free(); 
        DeleteCriticalSection(&m_Lock);
    }

    void Lock()
    {
        EnterCriticalSection(&m_Lock);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_Lock);
    }

    VOID Free();
    BOOL AddFile(LPCWSTR pwszFileName, LPCWSTR pwszPerUserFileName = NULL);
    BOOL FindFile(LPCWSTR pwszFileName);
    VOID AddNewHandle(HANDLE hNew);

    FINDFILE* files;
    HANDLE hFirstFind; // The first handle,this is what the app will be using.
    HANDLE hCurrentFind;
    WCHAR wszFindName[MAX_PATH];
    WCHAR wszFullPath[MAX_PATH];
    LPWSTR pwszPerUserFileName;
    BOOL fCheckRedirectList;
    BOOL fCheckDuplicate;

    FINDFILEINFO* next;

private:

    CRITICAL_SECTION m_Lock;
};

class FINDFILELIST
{
public:
    
    VOID Init()
    {
        InitializeCriticalSection(&m_Lock);
    }

    void Lock()
    {
        EnterCriticalSection(&m_Lock);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_Lock);
    }

    BOOL Add(
        HANDLE hFind,
        LPCWSTR pwszFindName,
        LPCWSTR pwszFullPath,
        LPCWSTR pwszFirstFile,
        LPCWSTR pwszPerUserFileName);

    BOOL Release(HANDLE hFind);
    BOOL FindHandle(HANDLE hFind, FINDFILEINFO** ppFileInfo);

private:

    CRITICAL_SECTION m_Lock;
    FINDFILEINFO* fflist;
};

VOID FINDFILEINFO::Free()
{
    Lock();
    FINDFILE* pFile = files;

    while (pFile)
    {
        files = files->next;
        delete pFile;
        pFile = files;
    }

    Unlock();
}

// We add the new file to the end of the list.
BOOL 
FINDFILEINFO::AddFile(
    LPCWSTR pwszFileName,
    LPCWSTR pwszPerUserFileName
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILE* pNewFile = new FINDFILE;

    if (pNewFile)
    {
        wcsncpy(pNewFile->wszFileName, pwszFileName, MAX_PATH - 1);
        pNewFile->wszFileName[MAX_PATH - 1] = L'\0';
        
        if (pwszPerUserFileName)
        {
            DWORD cLen = wcslen(pwszPerUserFileName) + 1;
            this->pwszPerUserFileName = new WCHAR [cLen];

            if (this->pwszPerUserFileName)
            {
                ZeroMemory(this->pwszPerUserFileName, sizeof(WCHAR) * cLen);
                wcscpy(this->pwszPerUserFileName, pwszPerUserFileName);
            }
            else
            {
                goto CLEANUP;
            }
        }

        pNewFile->next = NULL;

        if (files)
        {
            for (FINDFILE* pFile = files; pFile->next; pFile = pFile->next);
            pFile->next = pNewFile;
        }
        else
        {
            files = pNewFile;
        }

        fRes = TRUE;
    }

CLEANUP: 

    if (!fRes)
    {
        delete pNewFile;
    }

    Unlock();
    return fRes;
}

BOOL 
FINDFILEINFO::FindFile(
    LPCWSTR pwszFileName
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILE* pFile = files;

    while (pFile)
    {
        if (!_wcsicmp(pFile->wszFileName, pwszFileName))
        {
            fRes = TRUE;
            break;
        }

        pFile = pFile->next;
    }

    Unlock();
    return fRes;
}

// If this is called, it means we have finished searching at the alternate
// location and started to search at the original location. hNew is the handle
// return by FindFirstFile at the original location.
VOID 
FINDFILEINFO::AddNewHandle(
    HANDLE hNew)
{
    Lock();
    ORIGINAL_API(FindClose)(hCurrentFind);
    hCurrentFind = hNew;

    //
    // If pwszPerUserFileName is not NULL, when we add a new handle, 
    // it means we are searching at the orignal location so we can
    // free pwszPerUserFileName.
    // 
    delete [] pwszPerUserFileName;
    pwszPerUserFileName = NULL;

    Unlock();
}

// We add the newest handle to the beginning of the list.
BOOL 
FINDFILELIST::Add(
    HANDLE hFind,
    LPCWSTR pwszFindName,
    LPCWSTR pwszFullPath,
    LPCWSTR pwszFirstFile,
    LPCWSTR pwszPerUserFileName
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILEINFO* pFileInfo = new FINDFILEINFO;

    if (pFileInfo)
    {
        pFileInfo->hFirstFind = hFind;
        pFileInfo->hCurrentFind = hFind; 

        wcsncpy(pFileInfo->wszFindName, pwszFindName, MAX_PATH - 1);
        pFileInfo->wszFindName[MAX_PATH - 1] = L'\0';
        wcsncpy(pFileInfo->wszFullPath, pwszFullPath, MAX_PATH - 1);
        pFileInfo->wszFullPath[MAX_PATH - 1] = L'\0';

        pFileInfo->files = NULL;
        pFileInfo->AddFile(pwszFirstFile, pwszPerUserFileName);
        pFileInfo->next = fflist;
        fflist = pFileInfo;
        fRes = TRUE;
    }

    Unlock();
    return fRes;
}

// Remove the info with this handle value from the list.
BOOL
FINDFILELIST::Release(
    HANDLE hFind
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILEINFO* pFileInfo = fflist;
    FINDFILEINFO* last = NULL;

    while (pFileInfo)
    {
        if (pFileInfo->hFirstFind == hFind)
        {
            if (last)
            {
                last->next = pFileInfo->next;
            }
            else
            {
                fflist = pFileInfo->next;
            }

            delete [] pFileInfo->pwszPerUserFileName;
            delete pFileInfo;
            fRes = TRUE;
            break;
        }

        last = pFileInfo;
        pFileInfo = pFileInfo->next;
    }

    Unlock();
    return fRes;
}

// Returns FALSE if hFind can't be found in the list.
BOOL 
FINDFILELIST::FindHandle(
    HANDLE hFind, 
    FINDFILEINFO** ppFileInfo
    )
{
    Lock();
    BOOL fRes = FALSE;
    FINDFILEINFO* pFileInfo = fflist;

    while (pFileInfo)
    {
        if (pFileInfo->hFirstFind == hFind)
        {
            fRes = TRUE;
            *ppFileInfo = pFileInfo;
            break;
        }

        pFileInfo = pFileInfo->next;
    }

    Unlock();
    return fRes;
}

FINDFILELIST g_fflist;

BOOL
FindFirstValidFile(
    BOOL fHasWildCards,
    BOOL fCheckRedirectList,
    LPCWSTR pwszFileName,
    LPCWSTR pwszFullPath,
    LPWIN32_FIND_DATAW lpFindFileData,
    HANDLE* phFind
    )
{
    BOOL fFound = FALSE;

    if ((*phFind = FindFirstFileW(pwszFileName, lpFindFileData)) != INVALID_HANDLE_VALUE)
    {
        if (fHasWildCards)
        {
            // If the file name does have wildcards, we need to check if the file 
            // found is in the redirect lists; if not, we need to discard it and 
            // search for the next file.
            do 
            {
                if (!fCheckRedirectList || 
                    IsFoundFileInRedirectList(pwszFullPath, lpFindFileData->cFileName))
                {             
                    fFound = TRUE;
                    break;
                }
            }
            while (FindNextFileW(*phFind, lpFindFileData));
        }
        else
        {
            fFound = TRUE;
        }
    }

    return fFound;
}
    

//
// Algorithm for finding files:
// We merge the info from the alternate directories and the original directory.
// We keep a list of the files in the alternate directory and when we search in 
// the original directory we exclude the files that are in the alternate directory.
//
// The behavior of FindFirstFile: 
// If the file name has a trailing slash, it'll return error 2.
// If you want to look for a directory, use c:\somedir;
// If you want to look at the contents of a dir, use c:\somedir\*
//

HANDLE 
APIHOOK(FindFirstFileW)(
    LPCWSTR lpFileName,               
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[FindFirstFileW] lpFileName=%S", lpFileName);

    if (!lpFileName || !*lpFileName || (lpFileName && lpFileName[0] && lpFileName[wcslen(lpFileName) - 1] == L'\\'))
    {
        return FindFirstFileW(lpFileName, lpFindFileData);
    }
 
    HANDLE hFind = INVALID_HANDLE_VALUE;
    BOOL fHasWildCards = HasWildCards(lpFileName);
    BOOL fFoundAtAlternate = FALSE;
    BOOL fHasSearchedAllUser = FALSE;
    
    REDIRECTFILE rf(lpFileName, OBJ_FILE_OR_DIR, !fHasWildCards);
    WCHAR wszFullPath[MAX_PATH];
    
    if (rf.m_wszOriginalName[0])
    {
        if (fHasWildCards) 
        {
            rf.GetAlternateAllUser();
        }

        GetFullPath(rf.m_wszOriginalName, wszFullPath);

        // Try the all user redirect dir first.
        fFoundAtAlternate = FindFirstValidFile(
            fHasWildCards, 
            TRUE, // Check in the redirect list.
            rf.m_pwszAlternateName, 
            wszFullPath, 
            lpFindFileData, 
            &hFind);
        
        rf.GetAlternatePerUser();

        if (fHasWildCards && !fFoundAtAlternate)
        {
            fHasSearchedAllUser = TRUE;

            //
            // Now try the per user redirect dir if the file name has wildcards.
            //
            fFoundAtAlternate = FindFirstValidFile(
                fHasWildCards, 
                TRUE, // Check in the redirect list
                rf.m_pwszAlternateName, 
                wszFullPath, 
                lpFindFileData, 
                &hFind);
        }
    }
    
    if (fHasWildCards && fFoundAtAlternate)
    {
        // If the filename doesn't have wildcards, FindNextFile will return 
        // ERROR_NO_MORE_FILES, no need to add the info to the list.
        g_fflist.Add(
            hFind, 
            lpFileName, 
            wszFullPath, 
            lpFindFileData->cFileName, 
            (fHasSearchedAllUser ? NULL : rf.m_pwszAlternateName));
    }

    if (!fFoundAtAlternate)
    {
        hFind = FindFirstFileW(lpFileName, lpFindFileData);
    }

    if (hFind != INVALID_HANDLE_VALUE)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[FindFirstFileW] Found %S", lpFindFileData->cFileName);
    }

    return hFind;
}

HANDLE 
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,               
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    STRINGA2W wstrFileName(lpFileName);
    if (wstrFileName.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);
    }

    HANDLE hFind;
    WIN32_FIND_DATAW fdw;
    
    if ((hFind = APIHOOK(FindFirstFileW)(wstrFileName, &fdw)) != INVALID_HANDLE_VALUE)
    {
        FindDataW2A(&fdw, lpFindFileData);
    }

    return hFind;
}

BOOL 
APIHOOK(FindNextFileW)(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[FindNextFileW] hFindFile=%d", hFindFile);

    BOOL fRes = FALSE;
    BOOL fHasNewHandle = FALSE;
    FINDFILEINFO* pFindInfo;

    if (g_fflist.FindHandle(hFindFile, &pFindInfo))
    {
        //
        // We need to use the current handle instead of the handle passed in
        // if they are different.
        //
        while (TRUE) 
        {
            fRes = FindNextFileW(pFindInfo->hCurrentFind, lpFindFileData);
            
            if (fRes)
            {
                //
                // Check to see if this file is valid.
                //
                if ((pFindInfo->fCheckRedirectList &&
                    !IsFoundFileInRedirectList(pFindInfo->wszFullPath, lpFindFileData->cFileName)) ||
                    (pFindInfo->fCheckDuplicate && 
                    pFindInfo->FindFile(lpFindFileData->cFileName)))
                {
                    continue;
                }

                //
                // If we get here, it means we got a valid file name, return.
                //
                pFindInfo->AddFile(lpFindFileData->cFileName);
                fRes = TRUE;
                break;
            }
            else
            {
                if (!pFindInfo->fCheckRedirectList)
                {
                    //
                    // If fCheckRedirectList is FALSE, it means we have been searching
                    // at the original location, bail out now.
                    //
                    break;
                }

                //
                // If pwszPerUserFileName is not NULL it means we haven't searched 
                // there yet, so search there.
                //
            retry:

                LPWSTR pwszFindName;
                
                if (pFindInfo->fCheckRedirectList && pFindInfo->pwszPerUserFileName)
                {
                    pwszFindName = pFindInfo->pwszPerUserFileName;
                }
                else
                {
                    pwszFindName = pFindInfo->wszFindName;
                    pFindInfo->fCheckRedirectList = FALSE;
                }

                pFindInfo->fCheckDuplicate = TRUE;

                HANDLE hNewFind;

                if (FindFirstValidFile(
                    TRUE, 
                    pFindInfo->fCheckRedirectList,
                    pwszFindName,
                    pFindInfo->wszFullPath,
                    lpFindFileData,
                    &hNewFind))
                {
                    //
                    // If we get a valid handle, we need to add this to the fileinfo.
                    //
                    pFindInfo->AddNewHandle(hNewFind);
                    pFindInfo->AddFile(lpFindFileData->cFileName);
                    fRes = TRUE;
                    break;
                }
                else
                {
                    if (pFindInfo->fCheckRedirectList)
                    {
                        pFindInfo->fCheckRedirectList = FALSE;
                        goto retry;
                    }

                    //
                    // If fCheckRedirect is FALSE, it means we ran out of
                    // options - we already searched at the original location.
                    // so nothing left to do.
                    //
                }
            }
        }
    }
    else
    {
        // If we can't find the handle in the list, it means we have been searching
        // at the original location so don't need to do anything special.
        fRes = FindNextFileW(hFindFile, lpFindFileData);
    }

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[FindNextFileW] Found %S", lpFindFileData->cFileName);
    }
    return fRes;
}

BOOL 
APIHOOK(FindNextFileA)(
    HANDLE hFindFile,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    BOOL fRes;
    WIN32_FIND_DATAW fdw;
    
    if (fRes = APIHOOK(FindNextFileW)(hFindFile, &fdw))
    {
        FindDataW2A(&fdw, lpFindFileData);
    }

    return fRes;;
}

BOOL 
APIHOOK(FindClose)(
    HANDLE hFindFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[FindClose] hFindFile=%d", hFindFile);

    // If we have a new handle, we need to close both handles.
    FINDFILEINFO* pFindInfo;

    if (g_fflist.FindHandle(hFindFile, &pFindInfo))
    {
        g_fflist.Release(hFindFile);
    }

    return FindClose(hFindFile);
}

BOOL 
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    return LuaMoveFileW(lpExistingFileName, lpNewFileName);
}

BOOL 
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    STRINGA2W wstrExistingFileName(lpExistingFileName);
    STRINGA2W wstrNewFileName(lpNewFileName);

    return ((wstrExistingFileName.m_fIsOutOfMemory || wstrNewFileName.m_fIsOutOfMemory) ?
        ORIGINAL_API(MoveFileA)(lpExistingFileName, lpNewFileName) :
        LuaMoveFileW(wstrExistingFileName, wstrNewFileName));
}

BOOL 
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName
    )
{
    return LuaRemoveDirectoryW(lpPathName);
}

BOOL 
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName
    )
{
    STRINGA2W wstrPathName(lpPathName);

    return (wstrPathName.m_fIsOutOfMemory ?
        ORIGINAL_API(RemoveDirectoryA)(lpPathName) :
        LuaRemoveDirectoryW(wstrPathName));
}

UINT 
APIHOOK(GetTempFileNameW)(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
)
{
    return LuaGetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);
}

UINT 
APIHOOK(GetTempFileNameA)(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
)
{
    STRINGA2W wstrPathName(lpPathName);
    STRINGA2W wstrPrefixString(lpPrefixString);
    
    if (wstrPathName.m_fIsOutOfMemory || wstrPrefixString.m_fIsOutOfMemory)
    {
        return ORIGINAL_API(GetTempFileNameA)(
            lpPathName,
            lpPrefixString,
            uUnique,
            lpTempFileName);
    }

    WCHAR wstrTempFileName[MAX_PATH];
    UINT uiRes;
    
    if (uiRes = LuaGetTempFileNameW(
        wstrPathName,
        wstrPrefixString,
        uUnique,
        wstrTempFileName))
    {
        UnicodeToAnsi(wstrTempFileName, lpTempFileName);
    }

    return uiRes;
}

DWORD 
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpDefault,
        lpReturnedString,
        nSize,
        lpFileName);
}

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrDefault(lpDefault);
    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszReturnedString = new WCHAR [nSize];

    if (wstrAppName.m_fIsOutOfMemory || 
        wstrKeyName.m_fIsOutOfMemory || 
        wstrDefault.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory ||
        !pwszReturnedString)
    {
        if (pwszReturnedString) 
        {
            delete [] pwszReturnedString;
        }

        return ORIGINAL_API(GetPrivateProfileStringA)(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName);
    }

    DWORD dwRes = LuaGetPrivateProfileStringW(
        wstrAppName,
        wstrKeyName,
        wstrDefault,
        pwszReturnedString,
        nSize,
        wstrFileName);

    //
    // Note, there is a bug in GetPrivateProfileString when either lpAppName or
    // lpKeyName is NULL - if you pass in a buffer that's just the right size,
    // ie, it has just enough space for the string with one NULL in between each
    // name and 2 NULLs at the end, the returned string is not double NULL terminated.
    // It only has one NULL. This is #589524.
    // This ANSI version hook implementation fixes that.
    //
    if (dwRes > 0)
    {
        //
        // Some apps lie - they pass in an nSize that's larger than their actual 
        // buffer size. We only convert at most the string length of characters 
        // in hoping that we don't overwrite their stack. Global Dialer does this.
        //
        int cCharsToAdd = 1;

        //
        // It's a special case when either lpAppName or lpKeyName is NULL, and
        // the buffer was not big enough. nSize must be greater than 2 or dwRes
        // would be 0.
        //
        if (!lpAppName || !lpKeyName)
        {
            if (pwszReturnedString[dwRes - 1] != L'\0' && 
                pwszReturnedString[dwRes] == L'\0' && 
                pwszReturnedString[dwRes + 1] == L'\0')
            {
                ++cCharsToAdd;
            }
        }

        int cBytesToConvert = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszReturnedString, 
            dwRes + cCharsToAdd, 
            0, 
            0, 
            0, 
            0);

        //
        // If the buffer passed in was not big enough, convert as much as we can
        // to simulate the original API behavior - we don't want WideCharToMultiByte 
        // fail with ERROR_INSUFFICIENT_BUFFER.
        // 
        BOOL fBufferNotBigEnough = FALSE;

        if (cBytesToConvert > (int)nSize)
        {
            cBytesToConvert = nSize; 
            fBufferNotBigEnough = TRUE;
        }

        int cBytesConverted = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszReturnedString, 
            dwRes + cCharsToAdd, 
            lpReturnedString, 
            cBytesToConvert, 
            0, 
            0);

        //
        // Fix up the return value/buffer.
        //
        if (fBufferNotBigEnough)
        {
            dwRes = nSize - 2;
            lpReturnedString[dwRes] = '\0';
            lpReturnedString[dwRes + 1] = '\0';
        }
        else
        {
            dwRes = cBytesConverted - cCharsToAdd;
        }
    }
    else if (dwRes == 0 && nSize > 0)
    {
        lpReturnedString[0] = '\0';

        if (dwRes == nSize - 2)
        {
            //
            // This means either lpAppName or lpKeyName is NULL and the buffer
            // was not big enough, so we need to add another terminating NULL.
            //
            lpReturnedString[1] = '\0';
        }
    }

    delete [] pwszReturnedString;

    return dwRes;
}

BOOL 
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuaWritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrString(lpString);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory ||
        wstrKeyName.m_fIsOutOfMemory ||
        wstrString.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStringA)(
            lpAppName,
            lpKeyName,
            lpString,
            lpFileName) :

        LuaWritePrivateProfileStringW(
            wstrAppName,
            wstrKeyName,
            wstrString,
            wstrFileName));
}

DWORD 
APIHOOK(GetPrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileSectionW(
        lpAppName,
        lpReturnedString,
        nSize,
        lpFileName);
}

DWORD 
APIHOOK(GetPrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszReturnedString = new WCHAR [nSize];

    if (wstrAppName.m_fIsOutOfMemory || wstrFileName.m_fIsOutOfMemory || !pwszReturnedString)
    {
        if (pwszReturnedString)
        {
            delete [] pwszReturnedString;
        }

        return ORIGINAL_API(GetPrivateProfileSectionA)(
            lpAppName,
            lpReturnedString,
            nSize,
            lpFileName);
    }

    DWORD dwRes = LuaGetPrivateProfileSectionW(
        wstrAppName,
        pwszReturnedString,
        nSize,
        wstrFileName);

    if (dwRes > 0)
    {
        int cCharsToAdd = 1;

        if (!(pwszReturnedString[dwRes - 1] == L'\0' && 
            pwszReturnedString[dwRes] == L'\0'))
        {
            //
            // This means the buffer was big enough, and dwRes doesn't include
            // the last terminating null.
            //
            ++cCharsToAdd;
        }

        int cBytesToConvert = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszReturnedString, 
            dwRes + cCharsToAdd, 
            0, 
            0, 
            0, 
            0);

        //
        // If the buffer passed in was not big enough, convert as much as we can
        // to simulate the original API behavior - we don't want WideCharToMultiByte 
        // fail with ERROR_INSUFFICIENT_BUFFER.
        // 
        BOOL fBufferNotBigEnough = FALSE;

        if (cBytesToConvert > (int)nSize)
        {
            cBytesToConvert = nSize; 
            fBufferNotBigEnough = TRUE;
        }

        int cBytesConverted = WideCharToMultiByte(
            CP_ACP, 
            0, 
            pwszReturnedString, 
            dwRes + cCharsToAdd, 
            lpReturnedString, 
            cBytesToConvert, 
            0, 
            0);

        //
        // Fix up the return value/buffer.
        //
        if (fBufferNotBigEnough)
        {
            dwRes = nSize - 2;
            lpReturnedString[dwRes] = '\0';
            lpReturnedString[dwRes + 1] = '\0';
        }
        else
        {
            dwRes = cBytesConverted - cCharsToAdd;
        }
    }
    else if (dwRes == 0 && nSize > 0)
    {
        lpReturnedString[0] = '\0';

        if (dwRes == nSize - 2)
        {
            //
            // This means either lpAppName or lpKeyName is NULL and the buffer
            // was not big enough, so we need to add another terminating NULL.
            //
            lpReturnedString[1] = '\0';
        }
    }

    delete [] pwszReturnedString;

    return dwRes;
}

BOOL 
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    return LuaWritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);
}

BOOL 
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    if (!lpAppName || !lpString || !lpFileName)
    {
        return ORIGINAL_API(WritePrivateProfileSectionA)(
            lpAppName,
            lpString,
            lpFileName);
    }

    BOOL fRes; // only valid if fIsProcessed is TRUE.
    BOOL fIsProcessed = FALSE;
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszString = NULL;
    DWORD cStringLen = 0;
    int cRequiredSize = 0;
    LPCSTR pszString = lpString;

    if (wstrAppName.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory)
    {
        goto EXIT;
    }

    //
    // The lpString is double-NULL terminated. So we need to convert it specially.
    // First find where the string ends.
    //
    while (*pszString)
    {
        while (*pszString++);
    }

    cStringLen = (DWORD)(pszString - lpString) + 1;

    //
    // Now find out how much space we need to convert this special string.
    //
    cRequiredSize = MultiByteToWideChar(
        CP_ACP,
        0,
        lpString,
        cStringLen,
        NULL,
        0);

    if (cRequiredSize)
    {
        //
        // Allocate the buffer for the unicode string and convert.
        //
        pwszString = new WCHAR [cRequiredSize];

        if (pwszString)
        {
            if (MultiByteToWideChar(
                CP_ACP,
                0,
                lpString,
                cStringLen,
                pwszString,
                cRequiredSize))
            {
                fRes = LuaWritePrivateProfileSectionW(
                    wstrAppName,
                    pwszString,
                    wstrFileName);

                fIsProcessed = TRUE;
            }
        }
        else
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[WritePrivateProfileSectionA] Failed to allocate %d WCHARs to convert "
                "the string", 
                cRequiredSize);
        }
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[WritePrivateProfileSectionA] Failed to get the required number of WCHARs "
            "to convert the string: %d", 
            GetLastError());
    }

EXIT:

    if (pwszString) 
    {
        delete [] pwszString;
    }

    if (fIsProcessed)
    {
        return fRes;
    }
    else
    {
        return ORIGINAL_API(WritePrivateProfileSectionA)(
            lpAppName,
            lpString,
            lpFileName);
    }
}

UINT 
APIHOOK(GetPrivateProfileIntW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    )
{
    return LuaGetPrivateProfileIntW(
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName);
}

UINT 
APIHOOK(GetPrivateProfileIntA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    )
{
    STRINGA2W wstrAppName(lpAppName);
    STRINGA2W wstrKeyName(lpKeyName);
    STRINGA2W wstrFileName(lpFileName);

    return ((wstrAppName.m_fIsOutOfMemory ||
        wstrKeyName.m_fIsOutOfMemory ||
        wstrFileName.m_fIsOutOfMemory) ?

        ORIGINAL_API(GetPrivateProfileIntA)(
            lpAppName,
            lpKeyName,
            nDefault,
            lpFileName) :

        LuaGetPrivateProfileIntW(
            wstrAppName,
            wstrKeyName,
            nDefault,
            wstrFileName));
}

DWORD 
APIHOOK(GetPrivateProfileSectionNamesW)(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    return APIHOOK(GetPrivateProfileStringW)(
        NULL,
        NULL,
        L"",
        lpszReturnBuffer,
        nSize,
        lpFileName);
}

DWORD 
APIHOOK(GetPrivateProfileSectionNamesA)(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    return APIHOOK(GetPrivateProfileStringA)(
        NULL,
        NULL,
        "",
        lpszReturnBuffer,
        nSize,
        lpFileName);
}

BOOL 
APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    return LuaGetPrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);
}

BOOL 
APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    )
{
    STRINGA2W wstrSection(lpszSection);
    STRINGA2W wstrKey(lpszKey);
    STRINGA2W wstrFile(szFile);

    return ((wstrSection.m_fIsOutOfMemory ||
        wstrKey.m_fIsOutOfMemory ||
        wstrFile.m_fIsOutOfMemory) ?

        ORIGINAL_API(GetPrivateProfileStructA)(
            lpszSection,
            lpszKey,
            lpStruct,
            uSizeStruct,
            szFile) :

        LuaGetPrivateProfileStructW(
            wstrSection,
            wstrKey,
            lpStruct,
            uSizeStruct,
            wstrFile));
}

BOOL 
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    return LuaWritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);
}

BOOL 
APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCSTR szFile
    )
{
    STRINGA2W wstrSection(lpszSection);
    STRINGA2W wstrKey(lpszKey);
    STRINGA2W wstrFile(szFile);

    return ((wstrSection.m_fIsOutOfMemory ||
        wstrKey.m_fIsOutOfMemory ||
        wstrFile.m_fIsOutOfMemory) ?

        ORIGINAL_API(WritePrivateProfileStructA)(
            lpszSection,
            lpszKey,
            lpStruct,
            uSizeStruct,
            szFile) :

        LuaWritePrivateProfileStructW(
            wstrSection,
            wstrKey,
            lpStruct,
            uSizeStruct,
            wstrFile));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_fflist.Init();

        return LuaFSInit(COMMAND_LINE);
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    if (LuaShouldApplyShim())
    {
        CALL_NOTIFY_FUNCTION

        APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, CopyFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
        APIHOOK_ENTRY(KERNEL32.DLL, _lopen)
        APIHOOK_ENTRY(KERNEL32.DLL, _lcreat)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL, CreateDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetFileAttributesW)
        APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesA)
        APIHOOK_ENTRY(KERNEL32.DLL, SetFileAttributesW)
        APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, FindClose)
        APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, MoveFileA)
        APIHOOK_ENTRY(KERNEL32.DLL, MoveFileW)
        APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
        APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringA)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStringW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionA)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileSectionW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileIntA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileIntW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionNamesA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileSectionNamesW)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStructW)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructA)
        APIHOOK_ENTRY(KERNEL32.DLL, WritePrivateProfileStructW)
    }

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

INCLUDES=$(INCLUDES);                       \
         ..;                                \
         $(SHELL_INC_PATH);                 \
         $(BASE_INC_PATH);                  \
         $(WINDOWS_INC_PATH)

TARGETNAME=AcLua

TARGETTYPE=DYNLINK

SOURCES=..\ver.rc                          \
        ..\utils.cpp                       \
        ..\RedirectFS.cpp                  \
        ..\LUA_RedirectFS.cpp              \
        ..\RedirectReg.cpp                 \
        ..\LUA_RedirectReg.cpp             \
        ..\RedirectFS_Cleanup.cpp          \
        ..\LUA_RedirectFS_Cleanup.cpp      \
        ..\RedirectReg_Cleanup.cpp         \
        ..\LUA_RedirectReg_Cleanup.cpp     \
        ..\TrackFS.cpp                     \
        ..\LUA_TrackFS.cpp                 \
        ..\main.cpp 

DLLDEF=..\lua.def

C_DEFINES=$(C_DEFINES) -D_UNICODE -DUNICODE -D___TARGETNAME=#$(TARGETNAME).DLL -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(TARGETLIBS)                        \
           $(SDK_LIB_PATH)\ntdll.lib            \
           $(SDK_LIB_PATH)\kernel32.lib         \
           $(SDK_LIB_PATH)\advapi32.lib         \
           $(SDK_LIB_PATH)\userenv.lib          \
           $(SDK_LIB_PATH)\uuid.lib             \
           $(SDK_LIB_PATH)\version.lib          \
           $(SDBAPI_PATH)\lib\$(O)\sdbapil.lib


DLLBASE=0x24000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\redirectfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RedirectFS.cpp

 Abstract:

    When app gets access denied when trying to modify files due to insufficient
    access rights we copy the file to a location where the app does have enough
    access rights to do so. By default we redirect files to 
    
    %ALLUSERSPROFILE\Application Data\Redirected\drive\filepath

    to simulate the Win9x behavior.

    If you use the LUA wizard in CompatAdmin to customize LUA settings, you can
    choose to redirect files to either an all-user location

    %ALLUSERSPROFILE\Application Data\AppName\drive\filepath

    or a per-user location

    %USERPROFILE\Application Data\AppName\drive\filepath

    For example, you would want to redirect the file that stores the highscore 
    table to a dir that other users can access so you specify to redirect it to
    the all-user location but redirect everything else into your user directory.

 Notes:

    This does the bulk work for the LUARedirectFS shim.

    The 16-bit APIs (OpenFile, _lcreat and _lopen) are not here because we
    redirect the 32-bit APIs that are used to implement those.

    FindFirstFile, FindNextFile and FindClose are also not included because
    these are specially implemented using the ntdll functions in ntvdm.

    We don't handle filenames that are longer than MAX_PATH. So it's a really
    long path we revert to the original API. I have never seem an app that uses
    paths longer than MAX_PATH.

 History:

    02/12/2001 maonis  Created

    05/31/2001 maonis  Exported the APIs that ntvdm needs to implement LUA 
                       stuff.

    10/24/2001 maonis  Added support to have some files redirect to an all-user dir
                       and others to a per-user dir.
                       Changed the commandline format to utilize the <DATA> section
                       in the shim.

    11/15/2001 maonis  Added support to exclude file extensions. Changed to use the
                       ntdll functions in init.

    11/30/2001 maonis  Added support to redirect everything in a directory.

    01/11/2002 maonis  Added support for an in-memory deletion list.

    02/14/2002 maonis  Security fixes including 
                       - prefix bugs 
                       - don't use dangerous APIs
                       - more checks to avoid buffer overrun.

--*/

#include "precomp.h"
#include "utils.h"
#include "secutils.h"
#include "RedirectFS.h"
#include <ntioapi.h>

// The all-user redirect directory.
WCHAR g_wszRedirectRootAllUser[MAX_PATH] = L"";
DWORD g_cRedirectRootAllUser = 0; // Doesn't include the terminating NULL.

// The per-user redirect directory
WCHAR g_wszRedirectRootPerUser[MAX_PATH] = L"";
DWORD g_cRedirectRootPerUser = 0; // Doesn't include the terminating NULL.

// Store the filesystem type for all possible drives.
EFSTYPE g_eVolumnFS[26];

// If the user used the LUA wizard which is indicated by the commandline, we
// redirect everything to per-user by default unless the user specifically
// asked to redirect something to all-user.
// If the shim doesn't have a commandline, we redirect everything to all-user.
BOOL g_fIsConfigured = FALSE;

// Did the user specify a redirect list (via the LUA wizard)?
BOOL g_fHasRedirectList = FALSE;

// The list that stores the file we tried to delete but got access denied.
LIST_ENTRY g_DeletedFileList; 

EXCLUDED_EXTENSIONS g_ExcludedExtensions;
CString             g_strDefaultExclusionList;
BOOL                g_fHasSetExclusionList = FALSE;

// The lists for files we'll consider for redirection.
RITEM* g_pRItemsFile = NULL;
DWORD g_cRItemsFile  = 0;

// The lists for directories we'll consider for redirection.
RITEM* g_pRItemsDir = NULL;
DWORD g_cRItemsDir  = 0;

PLIST_ENTRY 
FindDeletedFile(
    LPCWSTR pwszFile
    )
{
    DELETEDFILE* pItem;
    DWORD cLen = wcslen(pwszFile);

    for (PLIST_ENTRY pEntry = g_DeletedFileList.Flink; 
        pEntry != &g_DeletedFileList; 
        pEntry = pEntry->Flink) 
    {
        pItem = CONTAINING_RECORD(pEntry, DELETEDFILE, entry);

        if (!_wcsicmp(pItem->pwszName, pwszFile))
        {
            DPF("RedirectFS", eDbgLevelInfo,
                "[FindDeletedFile] Found %S in the deletion list",
                pwszFile);

            return pEntry;
        }
    }

    return NULL;
}

BOOL 
AddDeletedFile(
    LPCWSTR pwszFile
    )
{
    PLIST_ENTRY pEntry = FindDeletedFile(pwszFile);

    if (pEntry == NULL)
    {
        DELETEDFILE* pNewFile = new DELETEDFILE;

        if (pNewFile)
        {
            DWORD cLen = wcslen(pwszFile);
            pNewFile->pwszName = new WCHAR [cLen + 1];

            if (pNewFile->pwszName)
            {
                wcsncpy(pNewFile->pwszName, pwszFile, cLen);
                pNewFile->pwszName[cLen] = L'\0';

                InsertHeadList(&g_DeletedFileList, &pNewFile->entry);

                DPF("RedirectFS", eDbgLevelInfo,
                    "[AddDeletedFile] Added %S to the deletion list",
                    pwszFile);

                return TRUE;
            }
            else
            {
                DPF("RedirectFS", eDbgLevelError,
                    "[AddDeletedFile] Failed to allocate %d WCHARs",
                    cLen);

                delete pNewFile;
            }
        }
        else
        {
            DPF("RedirectFS", eDbgLevelError,
                "[AddDeletedFile] Failed to allocate a DELETEFILE");
        }
    }

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return FALSE;
}



/*++

 Function Description:

    We convert as many components into the long path as possible and
    convert the whole string to lower case.

 Arguments:

    IN pwszFullPath - The name got from GetFullPathName.

 Return Value:

    pointer to the massaged string.

 History:

    05/16/2001 maonis  Created

--*/

LPWSTR 
MassageName(
    LPWSTR pwszFullPath
    )
{
    DWORD dwRes;
    DWORD cLen = wcslen(pwszFullPath);

    if (cLen >= MAX_PATH)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[MassageName] File name has %d chars - we don't handle file name "
            "that long",
            cLen);

        return NULL;
    }

    //
    // BUGBUG: This is taking a bit too much stack space.
    //
    WCHAR wszTempPath[MAX_PATH] = L"";
    WCHAR wszLongPath[MAX_PATH] = L"";
    wcsncpy(wszTempPath, pwszFullPath, cLen);
    wszTempPath[cLen] = L'\0';

    LPWSTR pwszStartSearching = wszTempPath + cLen;
    
    while (!(dwRes = GetLongPathNameW(wszTempPath, wszLongPath, MAX_PATH)))
    {
        while (--pwszStartSearching >= wszTempPath && *pwszStartSearching != L'\\');

        if (pwszStartSearching < wszTempPath)
        {
            break;
        }

        *pwszStartSearching = L'\0';
    }

    //
    // Check we are not exceeding MAX_PATH chars.
    //
    DWORD cLenLongPath = dwRes; // The length of the part we converted to the long path.
    DWORD cLenLongPathEnd = (DWORD)(pwszStartSearching - wszTempPath);
    DWORD cNewLen = cLenLongPath + cLen - cLenLongPathEnd + 1;

    if (dwRes > MAX_PATH || cNewLen > MAX_PATH)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[MassageName] The converted path is more than MAX_PATH chars - "
            "We don't handle it");

        return NULL;
    }

    if (dwRes)
    {
        if (cLenLongPath != cLenLongPathEnd)
        {
            memmove(
                (void*)(pwszFullPath + cLenLongPath), 
                (const void*)(pwszFullPath + cLenLongPathEnd), 
                (cLen - cLenLongPathEnd + 1) * sizeof(WCHAR));

            *(pwszFullPath + cNewLen) = L'\0';
        }

        //
        // Yes we know we have enough space to do the memmove.
        //
        memcpy((void*)pwszFullPath, (const void*)wszLongPath, cLenLongPath * sizeof(WCHAR));
    }

    _wcslwr(pwszFullPath);
    
    //
    // Remove the trailing slash if any.
    //
    DWORD dwLastChar = wcslen(pwszFullPath) - 1;
    if (pwszFullPath[dwLastChar] == L'\\')
    {
        pwszFullPath[dwLastChar] = L'\0';
    }

    return pwszFullPath;
}

BOOL 
AllocateList(
    DWORD cItems,
    RITEM** ppRItems
    )
{
    RITEM* pRItems = new RITEM [cItems];

    if (!pRItems)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[AllocateList] Error allocating %d RITEMs", cItems);

        return FALSE;
    }

    *ppRItems = pRItems;

    return TRUE;
}

BOOL 
HasWildCards(
    LPCWSTR pwszName, 
    DWORD cLen
    )
{
    WCHAR ch;

    for (DWORD dw = 0; dw < cLen; ++dw)
    {
        if ((ch = *(pwszName + dw)) == L'*' || ch == L'?')
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*++

 Function Description:

    Every file that needs redirection will be redirected unless the file extension
    is in the exclusion list and the file is not in the redirect list. For example,
    we have a redirect list:
    
    c:\a\*.txt

    and the exclusion list looks like:
    
    bmp txt

    in which case (we assume those files all need redirection),

    c:\a\b.txt will be redirected because it's in the redirect list;

    c:\b\b.txt will NOT be redirected because it's not in the redirect list and
    the "txt" extension is excluded.

    c:\b\b.ini will be redirected because the extension is not excluded.

    ------------------------------------------------------------------------

    We allow wildcards '*' and '?' in the lists so we need to
    match on those. For performance reasons we'd only call 
    DoNamesMatchWC when comparing the object name with a string
    that has wildcards in it.

 Arguments:

    IN pwszObject - file/dir name.
    OUT pfAllUser - should this file be redirected to the all user dir?

 Return Value:

    TRUE - should be considered for redirection.
    FALSE - shouldn't be considered for redirection.
    
 History:

    05/08/2001 maonis  Created

--*/

BOOL 
IsInRedirectList(
    LPCWSTR pwszObject,
    BOOL* pfAllUser
    )
{
    BOOL fAllUser;

    if (g_fHasRedirectList)
    {
        DWORD dw;

        for (dw = 0; dw < g_cRItemsFile; ++dw)
        {
            if (DoesItemMatchRedirect(pwszObject, &g_pRItemsFile[dw], FALSE))
            {
                if (pfAllUser)
                {
                    *pfAllUser = g_pRItemsFile[dw].fAllUser;
                }

                //
                // If we can find it in the redirect list, we are done, return now.
                //
                return TRUE;
            }
        }

        //
        // If we didn't find the match in the file redirect list, check the directory
        // redirect list.
        //
        for (dw = 0; dw < g_cRItemsDir; ++dw)
        {
            if (DoesItemMatchRedirect(pwszObject, &g_pRItemsDir[dw], TRUE))
            {
                if (pfAllUser)
                {
                    *pfAllUser = g_pRItemsDir[dw].fAllUser;
                }

                //
                // If we can find it in the redirect list, we are done, return now.
                //

                return TRUE;
            }
        }
    }

    //
    // We've looked through the redirect list and didn't find the object there.
    // Now look into the exclusion list and return FALSE if we can find the extension
    // there.
    //
    if (g_ExcludedExtensions.pwszExtensions) 
    {
        if (g_ExcludedExtensions.IsExtensionExcluded(pwszObject))
        {
            DPF("RedirectFS", eDbgLevelInfo,
                "[IsInRedirectList] %S is excluded because of its extension.",
                pwszObject);

            return FALSE;
        }
    }

    //
    // If we get here it means the object should be redirected.
    //
    if (pfAllUser)
    {
        *pfAllUser = !g_fIsConfigured;
    }

    return TRUE;
}

/*++

 Function Description:

    Check if the file is on an NTFS partition. We have to
    check this for every file because they don't necessarily
    locate on one partition.
    
 Arguments:

    IN pwszFile - file name.

 Return Value:

    TRUE - it's NTFS.
    FALSE - it's not.
    
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
IsNTFSW(
    LPCWSTR pwszFile
    )
{
    WCHAR wszRoot[4];
    wcsncpy(wszRoot, pwszFile, 3);
    wszRoot[3] = L'\0';

    DWORD dwFSFlags;
    DWORD dwIndex = towlower(wszRoot[0]) - L'a';
    if (g_eVolumnFS[dwIndex] == FS_UNINIT)
    {
        if (GetVolumeInformationW(
            wszRoot,
            NULL,
            0,
            NULL,
            NULL,
            &dwFSFlags,
            NULL,
            0))
        {
            if (dwFSFlags & FS_PERSISTENT_ACLS)
            {
                g_eVolumnFS[dwIndex] = FS_NTFS;
            }
        }
        else
        {
            g_eVolumnFS[dwIndex] = FS_NON_NTFS;
        }
    }

    return (g_eVolumnFS[dwIndex] == FS_NTFS);
}

BOOL 
DoesFileExist(
    LPCWSTR lpFileName
    )
{
    DWORD dwAttrib = GetFileAttributesW(lpFileName);

    return (dwAttrib != -1);
}

BOOL 
IsDirectoryValid(
    LPCWSTR lpFileName
    )
{
    BOOL fRes = TRUE;

    LPWSTR pwszPathEnd = wcsrchr(lpFileName, L'\\');

    if (pwszPathEnd)
    {
        // Make a copy of the string.
        LPWSTR pwszPath = new WCHAR [wcslen(lpFileName) + 1];

        if (pwszPath)
        {
            wcscpy(pwszPath, lpFileName);
            pwszPath[pwszPathEnd - lpFileName] = L'\0';

            DWORD dwAttrib = GetFileAttributesW(pwszPath);

            fRes = ((dwAttrib != -1) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY));

            delete [] pwszPath;
        }
        else
        {
            fRes = FALSE;
        }
    }

    return fRes;
}

/*++

 Function Description:

    Construct the alternate file name.
    
    Converts drive:\path\file to
    \\?\Redirect_Dir\drive\path\file. If there's no Redirect Dir specified
    on the commandline, we use the default:
    \\?\LocalAppData_Directory\Redirected\drive\path\file.

 Arguments:

    None.

 Return Value:

    None.
    
 History:

    02/12/2001 maonis  Created
    10/24/2001 maonis  Modified

--*/

VOID
REDIRECTFILE::MakeAlternateName()
{
    m_pwszAlternateName = NULL;

    DWORD cRedirectRoot;
    LPWSTR pwszRedirectRoot;

    if (m_fAllUser)
    {
        cRedirectRoot = g_cRedirectRootAllUser;
        pwszRedirectRoot = g_wszRedirectRootAllUser;
    }
    else
    {
        cRedirectRoot = g_cRedirectRootPerUser;
        pwszRedirectRoot = g_wszRedirectRootPerUser;
    }

    DWORD cLen = wcslen(m_wszOriginalName) + cRedirectRoot + 1;
    m_pwszAlternateName = new WCHAR [cLen];

    if (m_pwszAlternateName)
    {
        ZeroMemory(m_pwszAlternateName, cLen * sizeof(WCHAR));

        //
        // We know we have enough space.
        //
        wcscpy(m_pwszAlternateName, pwszRedirectRoot);
        m_pwszAlternateName[cRedirectRoot] = m_wszOriginalName[0];
        wcscpy(m_pwszAlternateName + (cRedirectRoot + 1), m_wszOriginalName + 2);
    }
}

VOID 
REDIRECTFILE::GetAlternateAllUser()
{
    m_fAllUser = TRUE;

    if (m_pwszAlternateName) 
    {
        delete [] m_pwszAlternateName;
        m_pwszAlternateName = NULL;
    }

    MakeAlternateName();
}

VOID
REDIRECTFILE::GetAlternatePerUser()
{
    m_fAllUser = FALSE;

    if (m_pwszAlternateName) 
    {
        delete [] m_pwszAlternateName;
        m_pwszAlternateName = NULL;
    }

    MakeAlternateName();
}

/*++

 Function Description:

    Create the alternate directory hidrachy if needed. If the file exists at the
    original location but not the alternate location, copy the file to the 
    alternate location.
    
 Arguments:
    
    None
    
 History:

    02/12/2001 maonis  Created

--*/

BOOL 
REDIRECTFILE::CreateAlternateCopy(
    BOOL fCopyFile
    )
{
    BOOL fRes = FALSE;
    UINT cAlternatePath = wcslen(m_pwszAlternateName);

    // If it's a directory, we want to ensure the trailing slash.
    // The only API that would pass in an OBJ_FILE_OR_DIR type is GetFileAttributes
    // which will never call this. So the object type must be known.
    if (m_eObjType == OBJ_DIR)
    {
        ++cAlternatePath;
    }

    LPWSTR pwszAlternatePath = new WCHAR [cAlternatePath + 1];

    UINT cRedirectRoot = (m_fAllUser ? g_cRedirectRootAllUser : g_cRedirectRootPerUser);

    if (pwszAlternatePath)
    {
        ZeroMemory(pwszAlternatePath, sizeof(WCHAR) * (cAlternatePath + 1));
        wcsncpy(pwszAlternatePath, m_pwszAlternateName, cAlternatePath + 1);

        // Ensure the trailing slash.
        if ((m_eObjType == OBJ_DIR) && (pwszAlternatePath[cAlternatePath - 2] != L'\\'))
        {
            pwszAlternatePath[cAlternatePath - 1] = L'\\';
            pwszAlternatePath[cAlternatePath] = L'\0';
        }

        WCHAR* pwszEndPath = wcsrchr(pwszAlternatePath, L'\\');

        if (!pwszEndPath)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[CreateAlternateCopy] We shouldn't have gotten here - "
                "couldn't find '\\'??");
            goto EXIT;
        }

        ++pwszEndPath;
        *pwszEndPath = L'\0';
        
        //
        // Create the directory hierachy.
        // First skip the part of the directory that we know exists.
        //
        WCHAR* pwszStartPath = pwszAlternatePath;
        WCHAR* pwszStartNext = pwszStartPath + cRedirectRoot;
            
        // Find the end of the next sub dir.
        WCHAR* pwszEndNext = pwszStartNext;
        DWORD dwAttrib;

        while (pwszStartNext < pwszEndPath)
        {
            pwszEndNext = wcschr(pwszStartNext, L'\\');

            if (pwszEndNext)
            {
                *pwszEndNext = L'\0';
                if ((dwAttrib = GetFileAttributesW(pwszStartPath)) != -1)
                {
                    //
                    // If the directory already exists, we probe its sub directory.
                    //
                    *pwszEndNext = L'\\';
                    pwszStartNext = pwszEndNext + 1;
                    continue;
                }

                if (!CreateDirectoryW(pwszStartPath, NULL))
                {
                    DPF("RedirectFS", eDbgLevelError, 
                        "[CreateAlternateCopy] CreateDirectory failed: %d", GetLastError());
                    goto EXIT;
                }

                *pwszEndNext = L'\\';
                pwszStartNext = pwszEndNext + 1;
            }
            else
            {
                DPF("RedirectFS", eDbgLevelError, 
                    "[CreateAlternateCopy] We shouldn't have gotten here - "
                    "couldn't find '\\' yet we are not at the end of the path");
                goto EXIT;
            }
        }

        if (m_eObjType == OBJ_FILE && 
            fCopyFile &&
            (GetFileAttributesW(m_wszOriginalName) != -1) && 
            (GetFileAttributesW(m_pwszAlternateName) == -1))
        {
            if (!CopyFileW(m_wszOriginalName, m_pwszAlternateName, TRUE))
            {
                DPF("RedirectFS", eDbgLevelError, "[CreateAlternateCopy] CopyFile failed: %d", GetLastError());
                goto EXIT;
            }
        }

        DPF("RedirectFS", eDbgLevelInfo, "[CreateAlternateCopy] Redirecting %S", m_pwszAlternateName);
        fRes = TRUE;
    }

EXIT:

    delete [] pwszAlternatePath;
    return fRes;
}

BOOL 
TryAlternateFirst(
    DWORD dwCreationDisposition,
    LPCWSTR pwszAlternate
    )
{
    DWORD dwAlternateAttrib = GetFileAttributesW(pwszAlternate);

    if (dwCreationDisposition == OPEN_EXISTING || 
        dwCreationDisposition == TRUNCATE_EXISTING ||
        (dwAlternateAttrib != -1 && 
        (dwCreationDisposition == CREATE_ALWAYS || dwCreationDisposition == OPEN_ALWAYS)))
    {
        return TRUE;
    }

    return FALSE;
}

BOOL 
IsErrorTryAlternate(
    PLIST_ENTRY pDeletedEntry = NULL
    )
{
    DWORD dwLastError = GetLastError();

    if (dwLastError == ERROR_ACCESS_DENIED || 
        dwLastError == ERROR_PATH_NOT_FOUND)
    {
        //
        // We want to try the alternate location if we get path not found
        // because the user might've created the path at the alternate location.
        //
        return TRUE;
    }

    if (pDeletedEntry)
    {
        return (dwLastError == ERROR_FILE_EXISTS);
    }

    return FALSE;
}

//
// Exported APIs.
//

HANDLE 
LuaCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[CreateFileW] lpFileName=%S; dwDesiredAccess=0x%08x; dwCreationDisposition=%d",
        lpFileName, dwDesiredAccess, dwCreationDisposition);

    DWORD dwAttrib = GetFileAttributesW(lpFileName);

    if ((dwAttrib != -1) && (dwAttrib & FILE_ATTRIBUTE_DIRECTORY))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[CreateFileW] Calling CreateFile on a directory!");

        return CreateFileW(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }
    
    HANDLE hFile = INVALID_HANDLE_VALUE;

    // Check the alternate location first unless the user wants to create a new file.
    REDIRECTFILE rf(lpFileName);
    DWORD dwLastError;

    if (rf.m_pwszAlternateName)
    {
        //
        // If the user asked to open an existing file, we need to fail the request now
        // if the file is in the deletion list.
        //
        PLIST_ENTRY pDeletedEntry = FindDeletedFile(rf.m_wszOriginalName);
        if (pDeletedEntry && 
            (dwCreationDisposition == OPEN_EXISTING || 
             dwCreationDisposition == TRUNCATE_EXISTING))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[CreateFileW] %S was already deleted, failing CreateFile call",
                rf.m_wszOriginalName);

            dwLastError = ERROR_FILE_NOT_FOUND;
            SetLastError(dwLastError);
            return hFile;
        }

        //
        // If the directory doesn't exist at the original location or alternate location,
        // fail the call now.
        //
        if (!IsDirectoryValid(rf.m_wszOriginalName) && !IsDirectoryValid(rf.m_pwszAlternateName))
        {
            dwLastError = ERROR_PATH_NOT_FOUND;
            SetLastError(dwLastError);
            return hFile;
        }

        if (!TryAlternateFirst(dwCreationDisposition, rf.m_pwszAlternateName) ||
            ((hFile = CreateFileW(
            rf.m_pwszAlternateName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile)) == INVALID_HANDLE_VALUE && IsErrorNotFound()))
        {
            // Now look at the original location.
            if ((hFile = CreateFileW(
                lpFileName,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes, 
                hTemplateFile)) == INVALID_HANDLE_VALUE &&
                IsErrorTryAlternate(pDeletedEntry))
            {
                BOOL fRequestWriteAccess = RequestWriteAccess(
                    dwCreationDisposition,
                    dwDesiredAccess);

                if (!fRequestWriteAccess)
                {
                    // We didn't want to write to the file yet we got
                    // ACCESS_DENIED, there's nothing we can do about it.
                    DPF("RedirectFS", 
                        eDbgLevelError, 
                        "[CreateFileW] Get access denied on read");
                    goto EXIT;
                }

                // If we are trying to write to a read only file, we
                // will get ACCESS_DENIED whether we are a normal user 
                // or an admin, so simply return.
                if (fRequestWriteAccess && 
                    ((dwAttrib != -1) && (dwAttrib & FILE_ATTRIBUTE_READONLY)))
                {
                    DPF("RedirectFS", 
                        eDbgLevelError, 
                        "[CreateFileW] Get access denied on write to read only file");
                    goto EXIT;
                }

                if (IsFileSFPedW(rf.m_wszOriginalName))
                {
                    // If it's an SFP-ed executable, we simply return success.
                    // NOTE: this might cause problems because the app might expect
                    // to use the handle.
                    DPF("RedirectFS", 
                        eDbgLevelWarning, 
                        "[CreateFileW] Trying to write to an SFPed file");
                    hFile = (HANDLE)1;
                    goto EXIT;
                }

                // If we get this far, we need to make a copy at the alternate location.
                if (rf.CreateAlternateCopy(pDeletedEntry ? FALSE : TRUE))
                {
                    DPF("RedirectFS", 
                        eDbgLevelInfo, 
                        "[CreateFileW] We made a copy of the file at the alternate location");

                    // Open the file again.
                    hFile = CreateFileW(
                        rf.m_pwszAlternateName,
                        dwDesiredAccess,
                        dwShareMode,
                        lpSecurityAttributes,
                        dwCreationDisposition,
                        dwFlagsAndAttributes,
                        hTemplateFile);
                }
            }
        }

        if (hFile != INVALID_HANDLE_VALUE && pDeletedEntry)
        {
            DPF("RedirectFS", eDbgLevelInfo, 
                "[CreateFileW] Removed %S "
                "from the deletion list because we just created it",
                rf.m_wszOriginalName);

            RemoveEntryList(pDeletedEntry);
        }
    }
    else
    {
        return CreateFileW(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }

EXIT:

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[CreateFileW] Createfile %S failed: %d",
            lpFileName,
            GetLastError());
    }
    else
    {
        DPF("RedirectFS", eDbgLevelInfo, 
            "[CreateFileW] Createfile succeeded");
    }

    return hFile;
}

BOOL 
LuaCopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[CopyFileW] lpExistingFileName=%S; lpNewFileName=%S; bFailIfExists=%d",
        lpExistingFileName, lpNewFileName, bFailIfExists);

    BOOL fRes;
    REDIRECTFILE rfSource(lpExistingFileName);
    REDIRECTFILE rfDest(lpNewFileName);

    if (rfSource.m_pwszAlternateName || rfDest.m_pwszAlternateName)
    {
        //
        // If the user asked to open an existing file, we need to fail the request now
        // if the file is in the deletion list.
        //
        if (rfSource.m_pwszAlternateName)
        {
            PLIST_ENTRY pDeletedEntry = FindDeletedFile(rfSource.m_wszOriginalName);
            if (pDeletedEntry)
            {
                DPF("RedirectFS", eDbgLevelError, 
                    "[CopyFileW] %S was already deleted, failing CopyFile call",
                    rfSource.m_wszOriginalName);

                SetLastError(ERROR_FILE_NOT_FOUND);
                return FALSE;
            }
        }

        //
        // First we need to make sure that both the source file and the destination
        // directory exist. For the source file, if it doesn't exist at the original
        // location, it has to exist at the alternate location.
        //
        if ((DoesFileExist(lpExistingFileName) || DoesFileExist(rfSource.m_pwszAlternateName)) &&
            IsDirectoryValid(lpNewFileName))
        {
            LPWSTR pwszExistingFileName = (LPWSTR)lpExistingFileName;
            LPWSTR pwszNewFileName = (LPWSTR)lpNewFileName;

            if (rfSource.m_pwszAlternateName)
            {
                //
                // If the file exists at the alternate location, we need to use it instead
                // of the one at the original location.
                //
                DWORD dwSourceAttrib = GetFileAttributesW(rfSource.m_pwszAlternateName);

                if (dwSourceAttrib != -1)
                {
                    pwszExistingFileName = rfSource.m_pwszAlternateName;
                }
            }
            
            //
            // Attempt to copy to the original location first. If we can write to the file
            // it means the file shouldn't exist at the alternate location anyway so
            // we can be sure that we are copying to a location where the app will check
            // first when they read from this file.
            //
            if (!(fRes = CopyFileW(pwszExistingFileName, lpNewFileName, bFailIfExists)) && 
                rfDest.m_pwszAlternateName)
            {
                //
                // We try the alternate location under these situations:
                // 1) We got access denied or file/path not found or
                // 2) We got ERROR_FILE_EXISTS and the dest file exists in the deletion list.
                //
                DWORD dwLastError = GetLastError();
                PLIST_ENTRY pDeletedDestEntry = FindDeletedFile(rfDest.m_wszOriginalName);

                if (dwLastError == ERROR_ACCESS_DENIED ||
                    dwLastError == ERROR_FILE_NOT_FOUND ||
                    dwLastError == ERROR_PATH_NOT_FOUND ||
                    (dwLastError == ERROR_FILE_EXISTS && pDeletedDestEntry))
                {
                    pwszNewFileName = rfDest.m_pwszAlternateName;

                    if (!DoesFileExist(pwszNewFileName))
                    {
                        //
                        // If the dest file exists at the original location but not the alternate
                        // location, we should copy the original file to the alternate location 
                        // first because if the user specifies TRUE for bFailIfExists we 
                        // need to return error if it already exists. Also we need to create the 
                        // directory at the alternate location if it doesn't exist yet or CopyFile
                        // will fail.
                        //
                        if (rfDest.CreateAlternateCopy())
                        {
                            DPF("RedirectFS", eDbgLevelInfo, 
                                "[CopyFileW] Created an alternate copy for dest");

                            //
                            // If we successfully created an alternate copy it means the dest
                            // file must exist at the original location and has been added
                            // to the deletion list - we want to delete the file we create to
                            // make it look like the original location.
                            //
                            if (DoesFileExist(rfDest.m_pwszAlternateName) && 
                                !DeleteFileW(rfDest.m_pwszAlternateName))
                            {
                                DPF("RedirectFS", eDbgLevelInfo,
                                    "[CopyFileW] Deleting the alternate dest file failed?! %d",
                                    GetLastError());
                                return FALSE;
                            }
                        }
                        else
                        {
                            DPF("RedirectFS", eDbgLevelError, 
                                "[CopyFileW] Error copying dest file from original location to alternate location");

                            // If errors occur we revert back to the original location.
                            pwszNewFileName = (LPWSTR)lpNewFileName;
                        }
                    }
                }

                fRes = CopyFileW(pwszExistingFileName, pwszNewFileName, bFailIfExists);

                if (fRes && pDeletedDestEntry)
                {
                    DPF("RedirectFS", eDbgLevelInfo, 
                        "[CopyFileW] Removed %S "
                        "from the deletion list because we just created it",
                        rfDest.m_wszOriginalName);

                    RemoveEntryList(pDeletedDestEntry);
                }
            }

            return fRes;
        }
    }

    return CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
}

DWORD 
LuaGetFileAttributesW(
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetFileAttributesW] lpFileName=%S", lpFileName);

    DWORD dwRes;

    // Check the alternate location first.
    REDIRECTFILE rf(lpFileName, OBJ_FILE_OR_DIR);

    if (rf.m_pwszAlternateName)
    {
        //
        // If the user asked to get the attributes of a file that has been deleted, 
        // we need to fail the request now.
        //
        if (FindDeletedFile(rf.m_wszOriginalName))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[GetFileAttributesW] %S was already deleted, failing CreateFile call",
                rf.m_wszOriginalName);

            SetLastError(ERROR_FILE_NOT_FOUND);
            return -1;
        }

        if ((dwRes = GetFileAttributesW(rf.m_pwszAlternateName)) == -1)
        {
            // Now try the original location.
            dwRes = GetFileAttributesW(lpFileName);
        }
    }
    else
    {
        return GetFileAttributesW(lpFileName);
    }

    return dwRes;
}

/*++

 Function Description:

    If we were an admin user, would we get access denied when deleting this file?

 History:

    01/14/2002 maonis  Modified

--*/

BOOL
DeleteAccessDeniedAsAdmin(
    LPCWSTR pwszFileName
    )
{
    DWORD dwAttrib = GetFileAttributesW(pwszFileName);

    return ((dwAttrib != -1) && 
        ((dwAttrib & FILE_ATTRIBUTE_READONLY) || 
            (dwAttrib & FILE_ATTRIBUTE_DIRECTORY)));
}

/*++

 Function Description:

    First try to delete it at the redirect location; then try to delete it
    at the original location and only add it to the deletion list if it 
    returns ERROR_ACCESS_DENIDED.

    Note that calling DeleteFile on a directory or a file that's read only 
    returns ERROR_ACCESS_DENIED.
    
 History:

    02/12/2001 maonis  Created
    01/14/2002 maonis  Modified

--*/

BOOL 
LuaDeleteFileW(
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[DeleteFileW] lpFileName=%S", lpFileName);

    BOOL fRes, fResTemp;
    DWORD dwLastError;

    // Check the alternate location first.
    REDIRECTFILE rf(lpFileName);

    if (rf.m_pwszAlternateName)
    {
        //
        // Fail the call now if the file exists in the deletion list.
        //
        if (FindDeletedFile(rf.m_wszOriginalName))
        {
            SetLastError(ERROR_FILE_NOT_FOUND);
            return FALSE;
        }

        if (!(fResTemp = DeleteFileW(rf.m_pwszAlternateName)))
        {
            if (GetLastError() == ERROR_ACCESS_DENIED && 
                DeleteAccessDeniedAsAdmin(rf.m_pwszAlternateName))
            {
                //
                // If we get access denied because of reasons that would
                // make admin users get access denied too, we return now.
                //
                return fResTemp;
            }
        }

        //
        // Try the original location now.
        //
        fRes = DeleteFileW(lpFileName);
        dwLastError = GetLastError();

        if (lpFileName && 
            !fRes && 
            GetLastError() == ERROR_ACCESS_DENIED && 
            !DeleteAccessDeniedAsAdmin(lpFileName))
        {
            fRes = AddDeletedFile(rf.m_wszOriginalName);

            if (fRes)
            {
                SetLastError(0);
            }
        }

        if (fResTemp && 
            (dwLastError == ERROR_FILE_NOT_FOUND || 
                dwLastError == ERROR_PATH_NOT_FOUND))
        {
            //
            // If we successfully deleted it at the alternate location and the
            // file does not exist at the original location, we have successfully
            // deleted this file so set the return to success.
            //
            fRes = TRUE;
            SetLastError(0);
        }
    }
    else
    {
        fRes = DeleteFile(lpFileName);
    }

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[DeleteFileW] Successfully deleted %S",
            lpFileName);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[DeleteFileW] Failed to delete %S: %d",
            lpFileName,
            GetLastError()); 
    }

    return fRes;
}

BOOL 
LuaCreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[CreateDirectoryW] lpPathName=%S", lpPathName);

    BOOL fRes;

    // Check the alternate location first.
    REDIRECTFILE rf(lpPathName, OBJ_DIR);
    DWORD dwLastError;
    DWORD dwAttrib;

    if (rf.m_pwszAlternateName)
    {
        dwAttrib = GetFileAttributesW(rf.m_pwszAlternateName);

        if (dwAttrib != -1 && dwAttrib & FILE_ATTRIBUTE_DIRECTORY)
        {
            // If the directory already exists, return now.
            SetLastError(ERROR_ALREADY_EXISTS);
            return FALSE;
        }

        // If the directory doesn't already exist at the alternate location,
        // we need to try to create it at the original location first.
        if (!(fRes = CreateDirectoryW(lpPathName, lpSecurityAttributes)))
        {
            dwLastError = GetLastError();

            if (dwLastError == ERROR_ACCESS_DENIED)
            {
                // Create the directory in the alternate location.
                fRes = rf.CreateAlternateCopy();
                DPF("RedirectFS", eDbgLevelInfo, 
                    "[CreateDirectoryW] Redirecting %S", lpPathName);                
            }
            else if (dwLastError == ERROR_PATH_NOT_FOUND)
            {
                // If the path doesn't exist, there's a possiblity that
                // the path has been created at the alternate location
                // so try there.
                fRes = CreateDirectoryW(rf.m_pwszAlternateName, lpSecurityAttributes);
            }
        }
    }
    else
    {
        return CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }

    return fRes;
}

BOOL 
LuaSetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[SetFileAttributesW] lpFileName=%S", lpFileName);

    BOOL fRes;
    DWORD dwAttrib = LuaGetFileAttributesW(lpFileName);
    
    if (dwAttrib == -1)
    {
        //
        // If we can't get the attributes, we can't set them. So return now.
        // The last error is set by LuaGetFileAttributesW.
        //
        return FALSE;
    }

    EOBJTYPE eObjType = (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) ? OBJ_DIR : OBJ_FILE;

    // Check the alternate location first.
    REDIRECTFILE rf(lpFileName, eObjType);

    if (rf.m_pwszAlternateName)
    {
        //
        // If the user asked to set the attributes of a file that has been deleted, 
        // we need to fail the request now.
        //
        if (FindDeletedFile(rf.m_wszOriginalName))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[SetFileAttributesW] %S was already deleted, failing CreateFile call",
                rf.m_wszOriginalName);

            SetLastError(ERROR_FILE_NOT_FOUND);
            return -1;
        }

        if (!(fRes = SetFileAttributesW(rf.m_pwszAlternateName, dwFileAttributes)))
        {
            // Now try the original location.
            if (!(fRes = SetFileAttributesW(lpFileName, dwFileAttributes)) &&
                IsErrorTryAlternate())
            {
                // Make a copy at the alternate location and the set the attributes there.
                if (rf.CreateAlternateCopy())
                {
                    fRes = SetFileAttributesW(rf.m_pwszAlternateName, dwFileAttributes);
                }
            }
        }
    }
    else
    {
        return SetFileAttributesW(lpFileName, dwFileAttributes);
    }

    return fRes;
}

/*++

    We simulate MoveFile by doing CopyFile and not caring about the result of 
    DeleteFile because if we don't have enough access rights we simply have to
    leave the file there.

--*/

BOOL 
LuaMoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[MoveFileW] lpExistingFileName=%S; lpNewFileName=%S", lpExistingFileName, lpNewFileName);

    BOOL fRes = TRUE;
    DWORD dwLastError = 0;

    if (!(fRes = MoveFileW(lpExistingFileName, lpNewFileName)))
    {
        fRes = LuaCopyFileW(lpExistingFileName, lpNewFileName, TRUE);

        if (fRes)
        {
            fRes = LuaDeleteFileW(lpExistingFileName);
        }
    }

    return fRes;
}

/*++

  If we get access denied we still return TRUE - this is not totally correct
  of course but serves the purpose so far. We might change this to make it 
  correct in the future.

  If the directory is not empty, it'll return ERROR_DIR_NOT_EMPTY.

  Calling RemoveDirectory on a file returns ERROR_DIRECTORY.

--*/

BOOL 
LuaRemoveDirectoryW(
    LPCWSTR lpPathName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[RemoveDirectoryW] lpPathName=%S", lpPathName);

    BOOL fRes;

    // Check the alternate location first.
    REDIRECTFILE rf(lpPathName, OBJ_DIR);

    if (rf.m_pwszAlternateName)
    {
        if (!(fRes = RemoveDirectoryW(rf.m_pwszAlternateName)))
        {
            if (IsErrorNotFound())
            {
                // Now try the original location.
                fRes = RemoveDirectoryW(lpPathName);

                if (!fRes && IsErrorTryAlternate())
                {
                    DWORD dwAttrib = GetFileAttributesW(lpPathName);
                    if ((dwAttrib != -1) && !(dwAttrib & FILE_ATTRIBUTE_READONLY))
                    {
                        fRes = TRUE;
                        SetLastError(0);
                    }
                }
            }
        }
    }
    else
    {
        return RemoveDirectoryW(lpPathName);
    }

    return fRes;
}

/*++

 Function Description:

    It's the caller's responsibility to have lpTempFileName big enough to 
    hold the file name including the terminating NULL or GetTempFileName AVs.

    GetTempFileName returns ERROR_DIRECTORY if lpPathName is invalid.

 History:

    05/16/2001 maonis  Created

--*/

UINT 
LuaGetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    DWORD dwLastError;
    LPWSTR pwszPathName = (LPWSTR)lpPathName;
    WCHAR wszTemp[4] = L"1:\\"; // '1' is just a place holder for the drive letter.

    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetTempFileNameW] lpPathName=%S", lpPathName);

    //
    // Try the original location first.
    //
    UINT uiRes = GetTempFileNameW(
        lpPathName, 
        lpPrefixString, 
        uUnique, 
        lpTempFileName);

    //
    // Now go through each scenario to see if we should attempt alternate.
    // Scenario 1: either successfully got the file name or the path is 
    // NULL/empty.
    //
    if (uiRes || !lpPathName || !*lpPathName)
    {
        return uiRes;
    }

    dwLastError = GetLastError();

    //
    // If lpPathName is drive:, we need to change it to drive:\ so when
    // we call GetFullPath we get drive: back instead of the current dir.
    //
    if ((wcslen(pwszPathName) == 2) && (pwszPathName[1] == L':'))
    {
        wszTemp[0] = pwszPathName[0];
        pwszPathName = wszTemp;
    }

    REDIRECTFILE rf(pwszPathName, OBJ_DIR);

    //
    // Scenario 2: If we need to attemp alternate but failed to get the alternate
    // path, nothing to do.
    //
    if (rf.m_pwszAlternateName)
    {
        //
        // If the original path is invalid, we should always the alternate 
        // location.
        //
        if (dwLastError == ERROR_DIRECTORY)
        {
            if (IsDirectoryValid(rf.m_pwszAlternateName))
            {
                //
                // If we only wanted to get the file name, and the alternate 
                // path does exist, we can attemp to get the temp file name there.
                //
                goto TryAlternate;
            }

            //
            // Scenario 3: if neither original path nor alternate path exists,
            // nothing to do.
            //
        }
        else
        {
            if (!uUnique && dwLastError == ERROR_ACCESS_DENIED)
            {
                //
                // uUnique being zero means create the temp file. We should try 
                // alternate if we didn't have permission to create the file, or
                // the original path is invalid.
                //
                goto TryAlternate;
            }

            //
            // Scenario 4: if we got some error other than access denied when trying
            // to create the file, nothing to do.
            //
        }
    }

    SetLastError(dwLastError);

    return uiRes;

TryAlternate:

    if (rf.CreateAlternateCopy())
    {
        DWORD cTempFileName = wcslen(rf.m_pwszAlternateName) + MAX_PATH + 1;

        LPWSTR pwszTempFileName = new WCHAR [cTempFileName];

        if (pwszTempFileName)
        {
            if (uiRes = GetTempFileNameW(
                rf.m_pwszAlternateName, 
                lpPrefixString, 
                uUnique, 
                pwszTempFileName))
            {
                //
                // We need to convert the alternate path back to a normal path
                // because our redirection should be transparent to the app.
                //
                DWORD dwFileStart = (rf.m_fAllUser ? g_cRedirectRootAllUser : g_cRedirectRootPerUser) - 1;

                //
                // We know we have a big enough buffer.
                //
                wcscpy(lpTempFileName, pwszTempFileName + dwFileStart);

                //
                // Convert \c\somedir\some012.tmp back to c:\somedir\some012.tmp
                //
                lpTempFileName[0] = lpTempFileName[1];
                lpTempFileName[1] = L':';
                
                DPF("RedirectFS", eDbgLevelInfo, 
                    "[GetTempFileNameW] temp file %S created at the alternate location", lpTempFileName);
            }

            delete [] pwszTempFileName;
        }
        else
        {
            DPF("RedirectFS", eDbgLevelError,
                "[GetTempFileNameW] Failed to allocate %d WCHARs",
                cTempFileName);

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }
    
    return uiRes;
}

DWORD 
LuaGetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileStringW] AppName=%S; KeyName=%S; FileName=%S", 
        lpAppName,
        lpKeyName,
        lpFileName);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        //
        // GetPrivateProfileString returns the default string if the file
        // doesn't exist so we need to check that first.
        //
        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileStringW(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileStringW] Reading from alternate location");

            goto EXIT;
        }
    }

    dwRes = GetPrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpDefault,
        lpReturnedString,
        nSize,
        lpFileName);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileStringW] Successfully got string: %S",
            lpReturnedString);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileStringW] AppName=%S; KeyName=%S; FileName=%S; "
            "Failed: returned %d",
            lpAppName,
            lpKeyName,
            lpFileName,
            dwRes);
    }

    return dwRes;
}

BOOL 
LuaWritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[WritePrivateProfileStringW] AppName=%S; KeyName=%S; String=%S; FileName=%S", 
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);

    BOOL fRes = FALSE;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName)
        {
            //
            // WritePrivateProfileString creates the file so we want to
            // check if the file exists first. If it exists at the alternate
            // location we set it there; else we need to try the original
            // location first.
            //
            if ((GetFileAttributesW(rf.m_pwszAlternateName) != -1) ||
                (!(fRes = WritePrivateProfileStringW(
                    lpAppName,
                    lpKeyName,
                    lpString,
                    lpFileName)) && IsErrorTryAlternate()))
            {
                if (GetLastError() == ERROR_PATH_NOT_FOUND && 
                    !IsDirectoryValid(rf.m_pwszAlternateName))
                {
                    //
                    // If the alternate path doesn't exist, then we should indicate
                    // the error here.
                    //
                    DPF("RedirectFS", eDbgLevelWarning, 
                        "[WritePrivateProfileStringW] Path doesn't exist at original "
                        "or alternate location, returning ERROR_PATH_NOT_FOUND");

                    SetLastError(ERROR_PATH_NOT_FOUND);
                }
                else
                {
                    if (rf.CreateAlternateCopy())
                    {
                        DPF("RedirectFS", eDbgLevelInfo, 
                            "[WritePrivateProfileStringW] Redirecting %S", lpFileName);

                        fRes = WritePrivateProfileStringW(
                            lpAppName,
                            lpKeyName,
                            lpString,
                            rf.m_pwszAlternateName);
                    }
                }
            }

            goto EXIT;
        }
    }

    fRes = WritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);

EXIT:

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[WritePrivateProfileStringW] Successfully wrote the string");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[WritePrivateProfileStringW] Failed to write the string: %d",
            GetLastError());
    }

    return fRes;
}

DWORD 
LuaGetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileSectionW] AppName=%S; FileName=%S", 
        lpAppName,
        lpFileName);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileSectionW(
                lpAppName,
                lpReturnedString,
                nSize,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileSectionW] Reading from alternate location");

            goto EXIT;
        } 
    }

    dwRes = GetPrivateProfileSectionW(
        lpAppName,
        lpReturnedString,
        nSize,
        lpFileName);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileSectionW] Successfully got section");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileSectionW] Failed: returned %d",
            dwRes);
    }

    return dwRes;
}

BOOL 
LuaWritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[WritePrivateProfileSectionW] AppName=%S; String=%S; FileName=%S", 
        lpAppName,
        lpString,
        lpFileName);

    BOOL fRes = FALSE;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        if (rf.m_pwszAlternateName)
        {
            //
            // WritePrivateProfileSection creates the file so we want to
            // check if the file exists first. If it exists at the alternate
            // location we set it there; else we need to try the original
            // location first.
            //
            if ((GetFileAttributesW(rf.m_pwszAlternateName) != -1) ||
                (!(fRes = WritePrivateProfileSectionW(
                    lpAppName,
                    lpString,
                    lpFileName)) && IsErrorTryAlternate()))
            {
                if (GetLastError() == ERROR_PATH_NOT_FOUND && 
                    !IsDirectoryValid(rf.m_pwszAlternateName))
                {
                    //
                    // If the alternate path doesn't exist, then we should indicate
                    // the error here.
                    //
                    DPF("RedirectFS", eDbgLevelWarning, 
                        "[WritePrivateProfileSectionW] Path doesn't exist at original "
                        "or alternate location, returning ERROR_PATH_NOT_FOUND");

                    SetLastError(ERROR_PATH_NOT_FOUND);
                }
                else
                {
                    if (rf.CreateAlternateCopy())
                    {
                        DPF("RedirectFS", eDbgLevelInfo, 
                            "[WritePrivateProfileSectionW] Redirecting %S", lpFileName);

                        fRes = WritePrivateProfileSectionW(
                            lpAppName,
                            lpString,
                            rf.m_pwszAlternateName);
                    }
                }
            }

            goto EXIT;
        }
    }

    fRes = WritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);

EXIT:

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[WritePrivateProfileSectionW] Successfully wrote section");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[WritePrivateProfileSectionW] Failed to write section: %d",
            GetLastError());
    }

    return fRes;
}

UINT 
LuaGetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileIntW] AppName=%S; KeyName=%S; FileName=%S", 
        lpAppName,
        lpKeyName,
        lpFileName);

    UINT uiRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(lpFileName, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);

        //
        // GetPrivateProfileInt returns the default int if the file
        // doesn't exist so we need to check that first.
        //
        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            uiRes = GetPrivateProfileIntW(
                lpAppName,
                lpKeyName,
                nDefault,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileIntW] Reading from alternate location");

            goto EXIT;
        }
    }

    uiRes = GetPrivateProfileIntW(
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName);

EXIT:

    if (uiRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileIntW] Successfully got int: %d",
            uiRes);
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileIntW] AppName=%S; KeyName=%S; FileName=%S; returned 0",
            lpAppName,
            lpKeyName,
            lpFileName);
    }

    return uiRes;
}

BOOL 
LuaGetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[GetPrivateProfileStructW] Section=%S; KeyName=%S; FileName=%S", 
        lpszSection,
        lpszKey,
        szFile);

    DWORD dwRes = 0;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(szFile, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);
     
        if (rf.m_pwszAlternateName && 
            (GetFileAttributesW(rf.m_pwszAlternateName) != -1))
        {
            dwRes = GetPrivateProfileStructW(
                lpszSection,
                lpszKey,
                lpStruct,
                uSizeStruct,
                rf.m_pwszAlternateName);

            DPF("RedirectFS", eDbgLevelInfo,
                "[GetPrivateProfileStructW] Reading from alternate location");

            goto EXIT;
        } 
    }

    dwRes = GetPrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);

EXIT:

    if (dwRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[GetPrivateProfileStructW] Successfully got struct");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetPrivateProfileStructW] Failed: returned 0");
    }

    return dwRes;
}

BOOL 
LuaWritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    DPF("RedirectFS", eDbgLevelInfo, 
        "[WritePrivateProfileStructW] Section=%S; KeyName=%S; FileName=%S", 
        lpszSection,
        lpszKey,
        szFile);

    BOOL fRes = FALSE;
    WCHAR wszFileName[MAX_PATH] = L"";

    if (MakeFileNameForProfileAPIsW(szFile, wszFileName))
    {
        REDIRECTFILE rf(wszFileName);
    
        if (rf.m_pwszAlternateName)
        {
            //
            // WritePrivateProfileStruct creates the file so we want to
            // check if the file exists first. If it exists at the alternate
            // location we set it there; else we need to try the original
            // location first.
            //
            if ((GetFileAttributesW(rf.m_pwszAlternateName) != -1) ||
                (!(fRes = WritePrivateProfileStructW(
                    lpszSection,
                    lpszKey,
                    lpStruct,
                    uSizeStruct,
                    szFile)) && IsErrorTryAlternate()))
            {
                if (GetLastError() == ERROR_PATH_NOT_FOUND && 
                    !IsDirectoryValid(rf.m_pwszAlternateName))
                {
                    //
                    // If the alternate path doesn't exist, then we should indicate
                    // the error here.
                    //
                    DPF("RedirectFS", eDbgLevelWarning, 
                        "[WritePrivateProfileStructW] Path doesn't exist at original "
                        "or alternate location, returning ERROR_PATH_NOT_FOUND");

                    SetLastError(ERROR_PATH_NOT_FOUND);
                }
                else
                {
                    if (rf.CreateAlternateCopy())
                    {
                        DPF("RedirectFS", eDbgLevelInfo, 
                            "[WritePrivateProfileStructW] Redirecting %S", szFile);

                        fRes = WritePrivateProfileStructW(
                            lpszSection,
                            lpszKey,
                            lpStruct,
                            uSizeStruct,
                            rf.m_pwszAlternateName);
                    }
                }
            }

            goto EXIT;
        }
    }

    fRes = WritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);

EXIT:

    if (fRes)
    {
        DPF("RedirectFS", eDbgLevelInfo,
            "[WritePrivateProfileStructW] Successfully wrote struct");
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[WritePrivateProfileStructW] Failed to write struct: %d",
            GetLastError());
    }

    return fRes;
}

//----------------------------------------
// Processing the command line parameters.
//----------------------------------------

BOOL
GetListItemCount(
    LPCWSTR pwsz,
    DWORD* pcFiles,
    DWORD* pcDirs
    )
{
    if (!pwsz)
    {
        return TRUE;
    }

    DWORD cLen = wcslen(pwsz);
    LPWSTR pwszTemp = new WCHAR [cLen + 1];

    if (!pwszTemp)
    {
        DPF("RedirectFS", eDbgLevelError, "[GetListItemCount] failed to allocate %d WCHARs",
            cLen + 1);

        return FALSE;
    }

    wcsncpy(pwszTemp, pwsz, cLen);
    pwszTemp[cLen] = L'\0';

    LPWSTR pwszToken = wcstok(pwszTemp, L";");
    while (pwszToken)
    {
        SkipBlanksW(pwszToken);
        TrimTrailingSpaces(pwszToken);
        
        DWORD cTokenLen = wcslen(pwszToken);

        if (cTokenLen >= 6)
        {
            if (pwszToken[1] == L'C') 
            {
                if (pwszToken[cTokenLen - 1] == L'\\')
                {
                    *pcDirs += 1;
                }
                else
                {
                    *pcFiles += 1;
                }
            }
        }

        pwszToken = wcstok(NULL, L";");
    }

    delete [] pwszTemp;
    return TRUE;
}

/*++

 Function Description:

    Since the user specifies both files and dirs in the list, we allocate
    a single array for all of them and fill the directories in the beginning
    and the files at the end.
    
    Format of the list: 
    AC-%APPDRIVE%\a\;PU-%APPPATH%\b.txt
    A means to redirect to the all-user directory.
    P means to redirect to the per-user directory.
    C means the item is checked.
    U means the item is not checked.

 Arguments:

    IN pwszList - The redirect list.
    IN fStatic - is this the static list?

 Return Value:

    TRUE - successfully processed the list.
    FALSE - otherwise.

 History:

    05/16/2001 maonis  Created
    10/24/2001 maonis  Modified

--*/
BOOL
ProcessRedirectionList(
    LPCWSTR pwszList
    )
{
    if (!pwszList || !*pwszList)
    {
        return TRUE;
    }

    DPF("RedirectFS", eDbgLevelInfo,
        "[ProcessRedirectionList] The list is %S", pwszList);

    DWORD cList = 0;
    LPWSTR pwszExpandList = ExpandItem(
        pwszList, 
        &cList, 
        FALSE,  // Don't need to ensure the trailing slash.
        FALSE,  // Not applicable.
        FALSE); // Not applicable.

    if (!pwszExpandList)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectionList] Error expanding %S", pwszList);

        return FALSE;
    }

    g_fHasRedirectList = TRUE;

    LPWSTR pwsz = (LPWSTR)pwszExpandList;    
    LPWSTR pwszToken = pwsz;
    DWORD cLen, dwIndex;
    BOOL fIsDirectory;
    WCHAR ch;

    RITEM* pRItems;

    while (TRUE)
    {
        if (*pwsz == L';' || *pwsz == L'\0')
        {
            ch = *pwsz;
            *pwsz = L'\0';
 
            SkipBlanksW(pwszToken);
            TrimTrailingSpaces(pwszToken);

            cLen = wcslen(pwszToken);
            
            //
            // each item should at least have XX-X:\ at the beginning.
            // 
            if (cLen >= 6)
            {
                //
                // Check if we should use this item or not.
                //
                if (pwszToken[1] == L'U')
                {
                    goto NEXT;
                }

                if (cLen - 3 >= MAX_PATH)
                {
                    DPF("RedirectFS", eDbgLevelError,
                        "[ProcessRedirectionList] File name has %d chars - we don't "
                        "handle filenames that long", 
                        cLen - 3);

                    delete [] pwszExpandList;

                    return FALSE;
                }

                //
                // Check if it's a file or dir.
                //
                if (pwszToken[cLen - 1] == L'\\')
                {
                    dwIndex = g_cRItemsDir;
                    pRItems = g_pRItemsDir;
                    ++g_cRItemsDir;
                    fIsDirectory = TRUE;
                }
                else
                {
                    dwIndex = g_cRItemsFile;
                    pRItems = g_pRItemsFile;
                    ++g_cRItemsFile;
                    fIsDirectory = FALSE;
                }

                pRItems[dwIndex].fAllUser = (pwszToken[0] == L'A');
                wcscpy(pRItems[dwIndex].wszName, pwszToken + 3);
                pRItems[dwIndex].fHasWC = HasWildCards(pwszToken + 3, cLen - 3);
                MassageName(pRItems[dwIndex].wszName);
                pRItems[dwIndex].cLen = wcslen(pRItems[dwIndex].wszName);

                DPF("RedirectFS", eDbgLevelInfo,
                    "[ProcessRedirectionList] Added %s %d in list: --%S--", 
                    fIsDirectory ? "DIR" : "FILE", dwIndex, pRItems[dwIndex].wszName);
            }

        NEXT:

            pwszToken = pwsz + 1;

            if (ch == L'\0')
            {
                break;
            }
        }

        ++pwsz;
    }

    delete [] pwszExpandList;

    return TRUE;
}

/*++

 Function Description:

    The path can use enviorment variables plus %APPPATH% and %APPDRIVE%.

 Arguments:

    IN pwszDir - The redirect dir.
    IN fAllUser - is this dir for redirecting all user files?

 Return Value:

    TRUE - successfully processed the dir.
    FALSE - otherwise.

 History:

    05/16/2001 maonis  Created
    10/24/2001 maonis  Modified

--*/
BOOL 
ProcessRedirectDir(
    LPCWSTR pwszDir,
    BOOL fAllUser
    )
{
    if (!pwszDir || !*pwszDir)
    {
        //
        // If the redirect dir is empty nothing left to do so return now.
        //
        return TRUE;
    }

    DWORD cRedirectRoot = 0;
    LPWSTR pwszExpandDir = ExpandItem(
        pwszDir, 
        &cRedirectRoot, 
        TRUE,   // It's a directory.
        TRUE,   // Create the dir if it doesn't exist.
        TRUE);  // Add the \\?\ prefix.
    if (pwszExpandDir)
    {
        LPWSTR pwszRedirectRoot = (fAllUser ? g_wszRedirectRootAllUser : g_wszRedirectRootPerUser);

        //
        // The return length includes the terminating NULL.
        //
        if (cRedirectRoot > MAX_PATH)
        {
            DPF("RedirectFS", eDbgLevelInfo, 
                "[ProcessRedirectDir] Expand dir %S has %d chars - we don't "
                "handle path that long",
                pwszExpandDir,
                cRedirectRoot - 1);
        }

        wcscpy(pwszRedirectRoot, pwszExpandDir);

        --cRedirectRoot;

        if (fAllUser) 
        {
            g_cRedirectRootAllUser = cRedirectRoot;
        }
        else
        {
            g_cRedirectRootPerUser = cRedirectRoot;
        }

        delete [] pwszExpandDir;
        DPF("RedirectFS", eDbgLevelInfo, 
            "[ProcessRedirectDir] Files will be redirected to %S for %s instead of "
            "the default redirect directory",
            (fAllUser ? g_wszRedirectRootAllUser : g_wszRedirectRootPerUser),
            (fAllUser ? "All User files" : "Per User files"));

        return TRUE;
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectDir] Error expanding %S", pwszDir);

        return FALSE;
    }
}

extern "C" {
DWORD
SdbQueryDataExTagID(
    IN     PDB     pdb,               // database handle
    IN     TAGID   tiShim,            // tagid  of the shim
    IN     LPCTSTR lpszDataName,      // if this is null, will try to return all the data tag names
    OUT    LPDWORD lpdwDataType,      // pointer to data type (REG_SZ, REG_BINARY, etc)
    OUT    LPVOID  lpBuffer,          // buffer to fill with information
    IN OUT LPDWORD lpdwBufferSize,    // pointer to buffer size
    OUT    TAGID*  ptiData            // optional pointer to the retrieved data tag
    );
};

BOOL
GetDBStringData(
    const PDB pdb,
    const TAGID tiFix,
    LPCWSTR pwszName,
    CString& strValue
    )
{
    DWORD dwError, dwDataType, cSize = 0;

    if ((dwError = SdbQueryDataExTagID(
        pdb, 
        tiFix, 
        pwszName, 
        &dwDataType, 
        NULL, 
        &cSize, 
        NULL)) != ERROR_INSUFFICIENT_BUFFER) {
    
        DPF("RedirectFS", eDbgLevelError, "[GetDBStringData] Cannot get the size for DATA named %S", pwszName);

        //
        // If the data doesn't exist, there's nothing left to do.
        //
        return (dwError == ERROR_NOT_FOUND);
    }

    LPWSTR pwszValue = new WCHAR [cSize / sizeof(WCHAR)];

    if (pwszValue == NULL) {
        DPF("RedirectFS", eDbgLevelError, "[GetDBStringData] Failed to allocate %d bytes", cSize);
        return FALSE;
    }

    if ((dwError = SdbQueryDataExTagID(
        pdb, 
        tiFix, 
        pwszName, 
        &dwDataType, 
        pwszValue, 
        &cSize, 
        NULL)) != ERROR_SUCCESS) {

        DPF("RedirectFS", eDbgLevelError, "[GetDBStringData] Cannot read the VALUE of DATA named %S", pwszName);
        return FALSE;
    }
 
    strValue = pwszValue;
    delete [] pwszValue;

    return TRUE;
}

/*++

 Function Description:

    The xml looks like:

    <SHIM NAME="LUARedirectFS" COMMAND_LINE="%DbInfo%">

        <DATA NAME="AllUserDir" VALUETYPE="STRING"
                VALUE="%ALLUSERSPROFILE%\AllUserRedirect"/>

        <DATA NAME="PerUserDir" VALUETYPE="STRING"
                VALUE="%USERSPROFILE%\Redirect"/>

        <DATA NAME="StaticList" VALUETYPE="STRING"
                VALUE="AC-%APPDRIVE%\a\;PU-%APPPATH%\b.txt"/>

        <DATA NAME="DynamicList" VALUETYPE="STRING"
                VALUE="AC-%APPPATH%\b\;PU-c:\b\b.txt;AU-c:\c\"/>

    </SHIM>

    and the compiler will replace %DbInfo% with the actual db info, something like:

    -d{40DEBB3B-E9BF-4129-B4D8-A7F7017F3B45} -t0xf2

    We use the guid following -d to obtain the pdb and the tagid following -t to obtain
    the tagid for the shim.

 Arguments:

    IN pwszCommandLine - the command line that contains the database guid and the shim tagid.

 Return Value:

    TRUE - successfully read the <DATA> sections for the shim if any.
    FALSE - otherwise.

 History:

    10/25/2001 maonis  Created

--*/
BOOL
ReadLuaDataFromDB(
    LPWSTR pwszCommandLine
    )
{
    LPWSTR pwszGUID = wcsstr(pwszCommandLine, L"-d");

    if (!pwszGUID) 
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Something is really wrong!! "
            "Invalid commandline: %S", pwszCommandLine); 
        return FALSE;        
    }

    pwszGUID += 2;

    LPWSTR pwszTagId = wcsstr(pwszGUID, L"-t");

    if (!pwszTagId)
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Something is really wrong!! "
            "Invalid commandline: %S", pwszCommandLine); 
        return FALSE;        
    }

    *(pwszTagId - 1) = L'\0';
    pwszTagId += 2;
    
    //
    // Get the GUID for this database.
    //
    GUID guidDB;
    if (!SdbGUIDFromString(pwszGUID, &guidDB))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error converting %S to a guid", pwszGUID); 
        return FALSE;
    }

    WCHAR wszDatabasePath[MAX_PATH];
    PDB pdb;

    if (SdbResolveDatabase(NULL, &guidDB, NULL, wszDatabasePath, MAX_PATH))
    {
        //
        // now szDatabasePath contains the path to the database, open it 
        //
        if (!(pdb = SdbOpenDatabase(wszDatabasePath, DOS_PATH)))
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[ReadLuaDataFromDB] Error opening the database");
            return FALSE;
        }
    }
    else
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error resolving the path to the database");
        return FALSE;
    }
    
    LPWSTR pwszTagIdEnd = pwszTagId + wcslen(pwszTagId);
    TAGID tiShimRef = (TAGID)wcstoul(pwszTagId, &pwszTagIdEnd, 0);

    if (tiShimRef == TAGID_NULL) 
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] The shimref is invalid");
        return FALSE;
    }

    CString strAllUserDir, strPerUserDir, strStaticList, strDynamicList;
    
    if (!GetDBStringData(pdb, tiShimRef, L"AllUserDir", strAllUserDir) ||
        !GetDBStringData(pdb, tiShimRef, L"PerUserDir", strPerUserDir) ||
        !GetDBStringData(pdb, tiShimRef, L"StaticList", strStaticList) ||
        !GetDBStringData(pdb, tiShimRef, L"DynamicList", strDynamicList) ||
        !GetDBStringData(pdb, tiShimRef, L"ExcludedExtensions", g_strDefaultExclusionList))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error reading values from the db");
        return FALSE;
    }

    //
    // Set the APPPATH and APPDRIVE enviorment variables.
    //
    WCHAR wszModuleName[MAX_PATH + 1];

    //
    // GetModuleFileNameW is an awful API. If you don't pass in a buffer 
    // that's big enough to hold the module (including the terminating NULL), it
    // returns the passed in buffer size (NOT the required length) which means
    // it doesn't return an error - it just fills upto the passed in buffer size
    // so does NOT NULL terminate the string. So we set the last char to NULL and
    // make sure it doesn't get overwritten.
    //
    wszModuleName[MAX_PATH] = L'\0';

    DWORD dwRes = GetModuleFileNameW(NULL, wszModuleName, MAX_PATH + 1);

    if (!dwRes)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ReadLuaDataFromDB] GetModuleFileNameW failed: %d",
            GetLastError());

        return FALSE;
    }

    if (wszModuleName[MAX_PATH] != L'\0')
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ReadLuaDataFromDB] File name is longer than MAX_PATH, "
            "we don't handle file names that long");

        return FALSE;
    }

    LPWSTR pwsz = wszModuleName;
    LPWSTR pwszLastSlash = wcsrchr(pwsz, L'\\');

    if (!pwszLastSlash) 
    {
        DPF("RedirectFS", eDbgLevelError, "[ReadLuaDataFromDB] Error getting the exe path!");
        return FALSE;
    }

    *pwszLastSlash = L'\0';
    SetEnvironmentVariable(L"APPPATH", pwsz);
    *(pwsz + 2) = L'\0';
    SetEnvironmentVariable(L"APPDRIVE", pwsz);

    DWORD cFiles = 0;
    DWORD cDirs = 0;

    if (!GetListItemCount(strStaticList, &cFiles, &cDirs) || 
        !GetListItemCount(strDynamicList, &cFiles, &cDirs))
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectionList] Failed to get the count of items in list");

        return FALSE;
    }

    g_pRItemsFile = new RITEM [cFiles];
    g_pRItemsDir = new RITEM [cDirs];

    if (!g_pRItemsFile || !g_pRItemsDir)
    {
        DPF("RedirectFS", eDbgLevelError,
            "[ProcessRedirectionList] Failed to allocate the global redirect item lists");

        return FALSE;
    }

    if (!ProcessRedirectDir(strAllUserDir, TRUE) ||
        !ProcessRedirectDir(strPerUserDir, FALSE) ||
        !ProcessRedirectionList(strStaticList) ||
        !ProcessRedirectionList(strDynamicList))
    {
        DPF("RedirectFS", eDbgLevelError, 
            "[ReadLuaDataFromDB] Error processing values from the db");
        return FALSE;
    }

    DPF("RedirectFS", eDbgLevelInfo,
        "[ProcessRedirectionList] There are %d DIRs and %d FILES in the lists", 
        g_cRItemsDir, g_cRItemsFile);

    return TRUE;
}

#define LUA_DEFAULT_ALLUSER_DIR L"%ALLUSERSPROFILE%\\Application Data\\Redirected\\"
#define LUA_DEFAULT_PERUSER_DIR L"%USERPROFILE%\\Application Data\\Redirected\\"

/*++

 Function Description:
    
    The default redirect dir for per user is AppData\Redirected
    \\?\c:\Documents And Settings\user\Application Data\Redirected

    The default redirect dir for all user is AppData\Redirected
    \\?\c:\Documents And Settings\All Users\Application Data\Redirected

 Arguments:

    pwszDir - buffer for the dir.
    fAllUser - is it for all user or per user?

 Return Value:

    TRUE - successfully created the dir if necessary.
    FALSE - otherwise.

 History:

    10/24/2001 maonis  Created

--*/
BOOL
GetAppDataRedirectDir(
    LPWSTR pwszRedirectDir,
    DWORD* pcRedirectDir,
    BOOL fAllUser
    )
{
    WCHAR wszDir[MAX_PATH] = L"";
    BOOL fIsSuccess = FALSE;

    DWORD cRedirectRoot = 0;
    LPWSTR pwszExpandDir = ExpandItem(
        (fAllUser ? LUA_DEFAULT_ALLUSER_DIR : LUA_DEFAULT_PERUSER_DIR), 
        &cRedirectRoot, 
        TRUE,   // It's a directory.
        FALSE,  // The directory has to exist.
        TRUE);  // Add the \\?\ prefix.
    if (pwszExpandDir)
    {
        if (cRedirectRoot > MAX_PATH)
        {
            DPF("RedirectFS", eDbgLevelError,
                "[GetAppDataRedirectDir] expand dir is %S which is %d chars long - "
                "we don't handle path names that long",
                pwszExpandDir,
                cRedirectRoot - 1);
        }
        else
        {
            wcsncpy(pwszRedirectDir, pwszExpandDir, cRedirectRoot);
            *pcRedirectDir = cRedirectRoot - 1;

            fIsSuccess = TRUE;

            if (!fAllUser)
            {
                //
                // The all user redirect dir should have been created by
                // installing the sdb. Create the root of the per user 
                // redirect dir if need to.
                //
                fIsSuccess = CreateDirectoryOnDemand(pwszRedirectDir + FILE_NAME_PREFIX_LEN);
            }
        }

        delete [] pwszExpandDir;
    }

    return fIsSuccess;
}

/*++

 Function Description:

    If the all-user and/or per-user redirect dirs hasn't been specified, we need to construct the
    default ones.

 Arguments:

    None.

 Return Value:

    TRUE - successfully constructed the default dirs if necessary.
    FALSE - otherwise.

 History:

    10/24/2001 maonis  Created

--*/
BOOL
ConstructDefaultRDirs()
{
    if (g_wszRedirectRootAllUser[0] == L'\0')
    {
        if (!GetAppDataRedirectDir(g_wszRedirectRootAllUser, &g_cRedirectRootAllUser, TRUE)) 
        {
            return FALSE;
        }
    }

    if (g_wszRedirectRootPerUser[0] == L'\0')
    {
        if (!GetAppDataRedirectDir(g_wszRedirectRootPerUser, &g_cRedirectRootPerUser, FALSE)) 
        {
            return FALSE;
        }
    }

    return TRUE;
}

#define LUA_APPCOMPAT_FLAGS_PATH L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"
#define LUA_DEFAULT_EXCLUSION_LIST L"LUADefaultExclusionList"

/*++

 Function Description:

    Getting the default exclusion list from the registry. It's the 
    LUADefaultExclusionList value of the 
    HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AppCompatFlags
    key.
    
    We use NT APIs so they are garanteed to be initialized during
    PROCESS_ATTACH.

 Arguments:
    
    None.

 Return Value:

    TRUE - if we successfully got the value.
    FALSE - otherwise. We don't want to blindly redirect everything because
            we failed to get the default exclusion list.

 History:

    12/08/2001 maonis  Created

--*/
BOOL
GetDefaultExclusionList()
{
    UNICODE_STRING ustrKeyPath = {0}; 
    UNICODE_STRING ustrValue;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    BYTE* KeyValueBuffer = NULL;
    ULONG KeyValueLength, KeyValueLengthRequired;
    BOOL fIsSuccess = FALSE;

    RtlInitUnicodeString(&ustrKeyPath, LUA_APPCOMPAT_FLAGS_PATH);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &ustrKeyPath,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    Status = NtOpenKey(
        &KeyHandle,
        KEY_QUERY_VALUE,
        &ObjectAttributes);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // If this key doesn't exist, nothing left to do.
        //
        return TRUE;
    }

    if (!NT_SUCCESS(Status)) 
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] ",
            "Failed to open Key %S Status 0x%x",
            LUA_APPCOMPAT_FLAGS_PATH,
            Status);
        return FALSE;
    }

    //
    // Get the length of the value.
    //
    RtlInitUnicodeString(&ustrValue, LUA_DEFAULT_EXCLUSION_LIST);

    Status = NtQueryValueKey(
        KeyHandle,
        &ustrValue,
        KeyValuePartialInformation,
        NULL,
        0,
        &KeyValueLengthRequired);

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
    {
        //
        // If this value doesn't exist, nothing left to do.
        //
        return TRUE;
    }

    if (Status != STATUS_BUFFER_OVERFLOW && 
        Status != STATUS_BUFFER_TOO_SMALL)
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] ",
            "Failed to get the length of the value named %S for key %S Status 0x%x",
            LUA_DEFAULT_EXCLUSION_LIST,
            LUA_APPCOMPAT_FLAGS_PATH,
            Status);
        return FALSE;
    }

    KeyValueBuffer = (BYTE*)RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, KeyValueLengthRequired);
    KeyValueLength = KeyValueLengthRequired;

    if (KeyValueBuffer == NULL)
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] ",
            "Failed to allocate %d bytes for value %S",
            LUA_DEFAULT_EXCLUSION_LIST);
        return FALSE;
    }

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    Status = NtQueryValueKey(
        KeyHandle,
        &ustrValue,
        KeyValuePartialInformation,
        KeyValueInformation,
        KeyValueLength,
        &KeyValueLengthRequired);

    NtClose(KeyHandle);

    if (!NT_SUCCESS(Status)) 
    {
        DPF("RedirectFS", 
            eDbgLevelError,
            "[GetDefaultExclusionList] "
            "Failed to read value info for value %S Status 0x%x",
            LUA_DEFAULT_EXCLUSION_LIST,
            Status);

        goto EXIT;
    }

    //
    // Check for the value type.
    //
    if (KeyValueInformation->Type != REG_SZ) 
    {
        DPF("RedirectFS", eDbgLevelError,
            "[GetDefaultExclusionList] "
            "Unexpected value type 0x%x for %S",
            KeyValueInformation->Type,
            LUA_DEFAULT_EXCLUSION_LIST);

        goto EXIT;
    }

    g_strDefaultExclusionList = (LPWSTR)KeyValueInformation->Data;

    fIsSuccess = TRUE;

EXIT:

    RtlFreeHeap(RtlProcessHeap(), 0, KeyValueBuffer);

    return fIsSuccess;
}

BOOL 
LuapParseCommandLine(
    LPCSTR pszCommandLine
    )
{
    BOOL fIsSuccess = TRUE;

    if (pszCommandLine && pszCommandLine[0] != '\0')
    {
        LPWSTR pwszCommandLine = AnsiToUnicode(pszCommandLine);

        if (!pwszCommandLine)
        {
            DPF("RedirectFS", eDbgLevelError,
                "[LuapParseCommandLine] Failed to convert command line to unicode");

            return FALSE;
        }
        
        fIsSuccess = ReadLuaDataFromDB(pwszCommandLine);

        if (fIsSuccess)
        {
            g_fIsConfigured = TRUE;
        }

        delete [] pwszCommandLine;
    }

    if (fIsSuccess)
    {
        //
        // If it's successful, we need to construct the redirect dirs if they haven't
        // been specified.
        // Note we don't try to construct the dirs that haven't been constructed if
        // any error occured!! Because we don't want to redirect things that the user
        // doesn't want to redirect.
        //
        fIsSuccess = ConstructDefaultRDirs();
    }

    return fIsSuccess;
}

BOOL
LuaFSInit(
    LPCSTR pszCommandLine
    )
{
    InitializeListHead(&g_DeletedFileList);

    return (
        GetDefaultExclusionList() && 
        LuapParseCommandLine(pszCommandLine) &&
        g_ExcludedExtensions.Init(g_strDefaultExclusionList));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\trackfs.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    TrackFS.cpp

 Abstract:

    Track the directories the app looks at and record them into a file.

 History:

    04/04/2001 maonis  Created

--*/

#include "precomp.h"
#include "utils.h"
#include "secutils.h"
#include <stdio.h>

#define APPPATCH_DIR L"AppPatch\\"
#define APPPATCH_DIR_LEN (sizeof(APPPATCH_DIR) / sizeof(WCHAR) - 1)

#define TRACK_LOG_SUFFIX L".LUA.log"
#define TRACK_LOG_SUFFIX_LEN (sizeof(TRACK_LOG_SUFFIX) / sizeof(WCHAR) - 1)

struct DISTINCT_OBJ
{
    DISTINCT_OBJ* next;

    LPWSTR pwszName;
};

static WCHAR g_wszProgramFiles[MAX_PATH] = L"";
static DWORD g_cProgramFiles = 0;

DWORD
LuatpGetProgramFilesDirW()
{
    if (g_cProgramFiles == 0)
    {
        WCHAR wszProgramFiles[MAX_PATH];

        if (GetEnvironmentVariableW(L"ProgramFiles", wszProgramFiles, MAX_PATH))
        {
            DWORD dwSize = GetLongPathNameW(wszProgramFiles, g_wszProgramFiles, MAX_PATH);

            if (dwSize <= MAX_PATH)
            {
                //
                // Only if we successfully got the path and it's not more
                // than MAX_PATH will we set the global values.
                //
                g_cProgramFiles = dwSize;
            }
            else
            {
                g_wszProgramFiles[0] = L'\0';
            }
        }
    }

    return g_cProgramFiles;
}

BOOL
LuatpIsProgramFilesDirectory(
    LPCWSTR pwszPath
    )
{
    LuatpGetProgramFilesDirW();

    if (g_cProgramFiles)
    {
        return !_wcsnicmp(pwszPath, g_wszProgramFiles, g_cProgramFiles);
    }
    
    return FALSE;
}

// We only record things when the file
// 1) is not in the user profile dir - in which we know we don't need to redirect;
// 2) is not in the program files dir - in which we know we will need to redirect;
// because in those cases we know what to do so the user doesn't need to make the 
// choice.
BOOL
LuatpShouldRecord(
    LPCWSTR pwszPath
    )
{
    //if (LuatpIsUserDirectory(pwszPath) || 
    //    LuatpIsProgramFilesDirectory(pwszPath))
    if (IsUserDirectory(pwszPath))
    {
        return FALSE;
    }

    return TRUE;
}

LPWSTR 
LuatpGetLongObjectName(
    LPCWSTR pwszName,
    BOOL fIsDirectory
    )
{
    BOOL fIsSuccess = FALSE;
    LPWSTR pwszLongNameObject = NULL;
    LPWSTR pwszObject = NULL;

    if (!pwszName)
    {
        return NULL;
    }

    //
    // First get the full path.
    //
    DWORD cFullPath = GetFullPathNameW(pwszName, 0, NULL, NULL);

    if (!cFullPath)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the length of full path: %d",
            GetLastError());

        return NULL;
    }

    //
    // We allocate one more char to make space for the trailing slash for dir names.
    //
    pwszObject = new WCHAR [cFullPath + 1];

    if (!pwszObject)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to allocate %d WCHARs",
            cFullPath + 1);

        return NULL;  
    }

    if (!GetFullPathNameW(pwszName, cFullPath, pwszObject, NULL))
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the full path: %d",
            GetLastError());

        goto EXIT;
    }

    //
    // If it's not a valid file name, we don't add it.
    //
    if (wcslen(pwszObject) < 2 || !iswalpha(pwszObject[0]) || (pwszObject[1] != L':'))
    {
        goto EXIT;
    }

    if (fIsDirectory)
    {
        //
        // If it's a directory we make sure there's a trailing slash.
        //
        if (pwszObject[cFullPath - 2] != L'\\')
        {
            pwszObject[cFullPath - 1] = L'\\';
            pwszObject[cFullPath] = L'\0';
        }
    }

    //
    // Convert it to all lower case.
    //
    _wcslwr(pwszObject);

    //
    // Convert it to the long names.
    //
    DWORD cLongPath = GetLongPathName(pwszObject, NULL, 0);

    if (!cLongPath)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the length of long path: %d",
            GetLastError());

        goto EXIT;
    }

    pwszLongNameObject = new WCHAR [cLongPath];

    if (!pwszLongNameObject)
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to allocate %d WCHARs",
            cLongPath);

        goto EXIT;
    }

    if (!GetLongPathName(pwszObject, pwszLongNameObject, cLongPath))
    {
        DPF("TrackFS", eDbgLevelError,
            "[LuatpGetLongObjectName] Failed to get the long path: %d",
            GetLastError());

        goto EXIT;
    }

    if (LuatpShouldRecord(pwszLongNameObject))
    {
        //
        // We only record the objects that are not in the user profile directory.
        //
        fIsSuccess = TRUE;
    }

EXIT:

    delete [] pwszObject;

    if (!fIsSuccess)
    {
        delete [] pwszLongNameObject;
        pwszLongNameObject = NULL;
    }

    return pwszLongNameObject;
}

/*++

    The tracking class for the file system.
    
 History:

    04/04/2001 maonis  Created

--*/

class CTrackObject
{
public:
    BOOL Init();
    VOID Free();

    // If the object name needs to be processed, eg, it's not the full path
    // or not the long name, call this method to process it first before
    // adding to the list.
    VOID AddObject(LPCWSTR pwszName, BOOL fIsDirectory);

    // If the caller already processed the file name, call this method
    // to add it directly.
    VOID AddObjectDirect(LPWSTR pwszName, BOOL fIsDirectory);
    
    // This is specially for GetTempFileName - we add
    // *.tmp after the path.
    VOID AddObjectGetTempFileName(LPCWSTR pwszPath);

    VOID Record();

private:

    BOOL AddObjectToList(LPWSTR pwszName, BOOL fIsDirectory);

    VOID WriteToLog(LPCWSTR pwszDir);

    HANDLE m_hLog;
    WCHAR m_wszLog[MAX_PATH];

    DISTINCT_OBJ* m_pDistinctDirs;
    DISTINCT_OBJ* m_pDistinctFiles;

    DWORD m_cDistinctDirs;
    DWORD m_cDistinctFiles;
};

BOOL 
CTrackObject::AddObjectToList(
    LPWSTR pwszName,
    BOOL fIsDirectory
    )
{
    BOOL fIsSuccess = FALSE;

    DISTINCT_OBJ* pDistinctObjs = fIsDirectory ? m_pDistinctDirs : m_pDistinctFiles;
    DISTINCT_OBJ* pObj = pDistinctObjs;

    // Check to see if this file already exists in the list.
    while (pObj)
    {
        if (!wcscmp(pObj->pwszName, pwszName))
        {
            break;
        }

        pObj = pObj->next;
    }

    if (!pObj)
    {
        pObj = new DISTINCT_OBJ;
        if (pObj)
        {
            DWORD cLen = wcslen(pwszName);

            pObj->pwszName = new WCHAR [cLen + 1];
            
            if (pObj->pwszName)
            {
                wcscpy(pObj->pwszName, pwszName);
                pObj->next = pDistinctObjs;

                if (fIsDirectory)
                {
                    ++m_cDistinctDirs;
                    m_pDistinctDirs = pObj;
                }
                else
                {
                    ++m_cDistinctFiles;
                    m_pDistinctFiles = pObj;
                }

                fIsSuccess = TRUE;
            }
            else
            {
                DPF("TrackFS", eDbgLevelError, 
                    "[CTrackObject::AddObjectToList] Error allocating %d WCHARs",
                    cLen + 1);
            }
        }
        else
        {
            DPF("TrackFS", eDbgLevelError, 
                "[CTrackObject::AddObjectToList] Error allocating memory for new node");
        }
    }
    
    return fIsSuccess;
}

/*++

 Function Description:

    For files it's simple - we just store the file name in a list and search
    through the list to see if it's already in the list. If it is we are done;
    else we add it to the beginning of the list.
    We don't expect there are too many calls to modify files so a linked list
    is fine.
    
 Arguments:
    
    IN pwszFileName - file name.

 Return Value:

    none.

 History:

    05/08/2001 maonis  Created

--*/

VOID 
CTrackObject::AddObject(
    LPCWSTR pwszName,
    BOOL fIsDirectory
    )
{
    BOOL fIsSuccess = FALSE;

    LPWSTR pwszLongNameObject = LuatpGetLongObjectName(pwszName, fIsDirectory);

    if (pwszLongNameObject)
    {
        AddObjectToList(pwszLongNameObject, fIsDirectory);

        delete [] pwszLongNameObject;
    }
}

VOID 
CTrackObject::AddObjectDirect(
    LPWSTR pwszName,
    BOOL fIsDirectory
    )
{
    if (pwszName)
    {
        AddObjectToList(pwszName, fIsDirectory);
    }
}

/*++

 Function Description:

    Write the directory to the log as ANSI characters.
    Note this method uses 2 str* routines and it IS DBCS aware.
    
 Arguments:
    
    IN pwszDir - the directory to write to the log.

 Return Value:

    None.
    
 History:

    04/04/2001 maonis  Created

--*/

VOID 
CTrackObject::WriteToLog(
    LPCWSTR pwsz)
{
    if (!pwsz || !*pwsz)
    {
        return;
    }

    //
    // Get the number of bytes required to convert the string to ansi.
    //
    DWORD dwSize = WideCharToMultiByte(CP_ACP, 0, pwsz, -1, NULL, 0, NULL, NULL);

    LPSTR psz = new CHAR [dwSize + 2];
    if (psz)
    {
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, dwSize, 0, 0);
        psz[dwSize - 1] = '\r';
        psz[dwSize] = '\n';
        psz[dwSize + 1] = '\0';

        DWORD dwBytesWritten = 0;

        WriteFile(
            m_hLog, 
            psz, 
            dwSize + 1,
            &dwBytesWritten,
            NULL);

        delete [] psz;
    }
    else
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::WriteToLog] Failed to allocate %d CHARs", 
            dwSize);        
    }
}

/*++

 Function Description:

    Create the log file in %windir%\apppatch directory. We want to make sure
    we can create this file so we don't run the app to the end only to find
    that we can't record the results into a file.
    
 Arguments:
    
    None

 Return Value:

    TRUE - if log created successfully.
    FALSE otherwise.
    
 History:

    04/04/2001 maonis  Created

--*/

BOOL 
CTrackObject::Init()
{
    m_pDistinctDirs = NULL;
    m_pDistinctFiles = NULL;
    m_cDistinctDirs = 0;
    m_cDistinctFiles = 0;

    WCHAR  szModuleName[MAX_PATH + 1] = L"";
    LPWSTR pwszModuleNameStart = NULL;
    LPWSTR pwszModuleNameExtStart = NULL;
    DWORD  cAppPatchLen = 0;
    DWORD  cModuleNameLen = 0;
    DWORD  cTotalLen = 0;
    DWORD  dwRes = 0;

    GetSystemRootDirW();

    //
    // GetModuleFileNameW is an awful API. If you don't pass in a buffer 
    // that's big enough to hold the module (including the terminating NULL), it
    // returns the passed in buffer size (NOT the required length) which means
    // it doesn't return an error - it just fills upto the passed in buffer size
    // so does NOT NULL terminate the string. So we set the last char to NULL and
    // make sure it doesn't get overwritten.
    //
    szModuleName[MAX_PATH] = L'\0';

    dwRes = GetModuleFileNameW(NULL, szModuleName, MAX_PATH + 1); 

    if (!dwRes || szModuleName[MAX_PATH] != L'\0')
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] Error getting the module name: %d",
            GetLastError());

        return FALSE;
    }

    pwszModuleNameStart = wcsrchr(szModuleName, L'\\');

    if (!pwszModuleNameStart)
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] We can't find where the file name starts??? %S",
            szModuleName);

        return FALSE;
    }

    ++pwszModuleNameStart;
    cModuleNameLen = wcslen(pwszModuleNameStart);

    //
    // We don't need the path anymore.
    //
    memmove(szModuleName, pwszModuleNameStart, cModuleNameLen * sizeof(WCHAR));
    szModuleName[cModuleNameLen] = L'\0';

    //
    // Get rid of the extension.
    //
    pwszModuleNameExtStart = wcsrchr(szModuleName, L'.');

    //
    // If there's no extension we just use the whole file name.
    //
    if (pwszModuleNameExtStart)
    {
        *pwszModuleNameExtStart = L'\0';
    }

    cModuleNameLen = wcslen(szModuleName);

    //
    // Make sure we don't have a buffer overflow.
    //
    cTotalLen = 
        g_cSystemRoot + APPPATCH_DIR_LEN + // %windir%\AppPatch\ dir
        cModuleNameLen + // module name without extension
        TRACK_LOG_SUFFIX_LEN + // .LUA.log suffix
        1; // terminating NULL

    if (cTotalLen > MAX_PATH)
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] The file name is %d chars - "
            "we don't handle names longer than MAX_PATH",
            cTotalLen);

        return FALSE;
    }

    //
    // Construct the file name.
    //
    wcsncpy(m_wszLog, g_wszSystemRoot, g_cSystemRoot);
    wcsncpy(m_wszLog + g_cSystemRoot, APPPATCH_DIR, APPPATCH_DIR_LEN);
    wcsncpy(m_wszLog + (g_cSystemRoot + APPPATCH_DIR_LEN), szModuleName, cModuleNameLen);
    wcsncpy(m_wszLog + (g_cSystemRoot + APPPATCH_DIR_LEN + cModuleNameLen), TRACK_LOG_SUFFIX, TRACK_LOG_SUFFIX_LEN);
    m_wszLog[cTotalLen - 1] = L'\0';

    //
    // Delete the file first if it exists.
    //
    DeleteFileW(m_wszLog);

    if ((m_hLog = CreateFileW(
        m_wszLog,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_ALWAYS,
        0,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        DPF("TrackFS",  eDbgLevelError, 
            "[CTrackObject::Init] Error creating log %S: %d", m_wszLog, GetLastError());

        return FALSE;
    }
    else
    {
        DPF("TrackFS",  eDbgLevelInfo, "[CTrackObject::Init] Created the log %S", m_wszLog);
        CloseHandle(m_hLog);
        return TRUE;
    }
}

/*++

 Function Description:

    Free the linked list.
    
 Arguments:
    
    None

 Return Value:

    None
    
 History:

    04/04/2001 maonis  Created

--*/

VOID 
CTrackObject::Free()
{
    DISTINCT_OBJ* pDir = m_pDistinctDirs;
    DISTINCT_OBJ* pTempDir;

    while (pDir)
    {
        pTempDir = pDir;
        pDir = pDir->next;

        delete [] pTempDir->pwszName;
        delete pTempDir;
    }
}

/*++

 Function Description:

    Write the list of directories to the log.
    
 Arguments:
    
    None

 Return Value:

    None
    
 History:

    04/04/2001 maonis  Created

--*/

VOID 
CTrackObject::Record()
{
    if ((m_hLog = CreateFileW(
        m_wszLog,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        0,
        NULL)) != INVALID_HANDLE_VALUE)
    {
        // Empty the old log.
        SetFilePointer(m_hLog, 0, 0, FILE_BEGIN);
        SetEndOfFile(m_hLog);

        WCHAR wszHeader[32];
        if (_snwprintf(wszHeader, 31, L"D%d", m_cDistinctDirs) < 0)
        {
            DPF("TrackFS", eDbgLevelError,
                "[CTrackObject::Record] Too many dirs??? %d",
                m_cDistinctDirs);

            return;
        }

        wszHeader[31] = L'\0'; 
        WriteToLog(wszHeader);

        //
        // Dump the directories to the log - each dir is on its own line.
        //
        DISTINCT_OBJ* pDir = m_pDistinctDirs;

        while (pDir)
        {
            WriteToLog(pDir->pwszName);
            pDir = pDir->next;
        }

        if (_snwprintf(wszHeader, 31, L"F%d", m_cDistinctFiles) < 0)
        {
            DPF("TrackFS", eDbgLevelError,
                "[CTrackObject::Record] Too many files??? %d",
                m_cDistinctFiles);

            return;
        }

        wszHeader[31] = L'\0'; 
        WriteToLog(wszHeader);

        //
        // Dump the files to the log - each file is on its own line.
        //
        DISTINCT_OBJ* pFile = m_pDistinctFiles;

        while (pFile)
        {
            WriteToLog(pFile->pwszName);
            pFile = pFile->next;
        }

        CloseHandle(m_hLog);
    }

    // Make the file hidden so people don't accidently mess it up.
    DWORD dwAttrib = GetFileAttributes(m_wszLog);
    SetFileAttributes(m_wszLog, dwAttrib | FILE_ATTRIBUTE_HIDDEN);
}

CTrackObject g_td;

/*++

 Custom exception handler.

--*/

LONG 
ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    // Whenever we get an unhandled exception, we dump the stuff to the log.
    g_td.Record();

    return EXCEPTION_CONTINUE_SEARCH;
}


//
// Exported APIs.
//

HANDLE 
LuatCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[CreateFileW] lpFileName=%S; dwDesiredAccess=0x%08x; dwCreationDisposition=%d",
        lpFileName, dwDesiredAccess, dwCreationDisposition);

    HANDLE hFile = CreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);

    if (hFile != INVALID_HANDLE_VALUE) 
    {
        LUA_GET_API_ERROR;

        if (RequestWriteAccess(dwCreationDisposition, dwDesiredAccess))
        {
            g_td.AddObject(lpFileName, FALSE);
        }        

        LUA_SET_API_ERROR;
    }

    return hFile;
}

BOOL 
LuatCopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[CopyFileW] lpExistingFileName=%S; lpNewFileName=%S; bFailIfExists=%d",
        lpExistingFileName, lpNewFileName, bFailIfExists);
    
    BOOL bRet = CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObject(lpNewFileName, FALSE);
        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatCreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[CreateDirectoryW] lpPathName=%S", lpPathName);

    BOOL bRet = CreateDirectoryW(lpPathName, lpSecurityAttributes);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObject(lpPathName, TRUE);
        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatSetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
  )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[SetFileAttributesW] lpFileName=%S", lpFileName);

    BOOL bRet = SetFileAttributesW(lpFileName, dwFileAttributes);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        DWORD dwAttrib = GetFileAttributesW(lpFileName);
        if (dwAttrib != -1)
        {
            g_td.AddObject(lpFileName, dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
        }

        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatDeleteFileW(
    LPCWSTR lpFileName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[DeleteFileW] lpFileName=%S", lpFileName);

    LPWSTR pwszTempFile = LuatpGetLongObjectName(lpFileName, FALSE);

    BOOL bRet = DeleteFileW(lpFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObjectDirect(pwszTempFile, FALSE);
        LUA_SET_API_ERROR;
    }

    delete [] pwszTempFile;

    return bRet;
}

BOOL 
LuatMoveFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[MoveFileW] lpExistingFileName=%S; lpNewFileName=%S", lpExistingFileName, lpNewFileName);

    LPWSTR pwszTempFile = LuatpGetLongObjectName(lpExistingFileName, FALSE);

    BOOL bRet = MoveFileW(lpExistingFileName, lpNewFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObjectDirect(pwszTempFile, FALSE);
        g_td.AddObject(lpNewFileName, FALSE);
        LUA_SET_API_ERROR;
    }

    delete [] pwszTempFile;

    return bRet;
}

BOOL 
LuatRemoveDirectoryW(
    LPCWSTR lpPathName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[RemoveDirectoryW] lpPathName=%S", lpPathName);

    LPWSTR pwszTempDir = LuatpGetLongObjectName(lpPathName, TRUE);

    BOOL bRet = RemoveDirectoryW(lpPathName);

    if (bRet)
    {
        LUA_GET_API_ERROR;
        g_td.AddObjectDirect(pwszTempDir, TRUE);
        LUA_SET_API_ERROR;
    }

    delete [] pwszTempDir;

    return bRet;
}

UINT 
LuatGetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    )
{
    DPF("TrackFS",  eDbgLevelInfo, 
        "[GetTempFileNameW] lpPathName=%S", lpPathName);

    UINT uiRet = GetTempFileNameW(lpPathName, lpPrefixString, uUnique, lpTempFileName);

    if (uiRet && !uUnique)
    {
        LUA_GET_API_ERROR;
        g_td.AddObject(lpTempFileName, FALSE);
        LUA_SET_API_ERROR;
    }

    return uiRet;
}

BOOL 
LuatWritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[WritePrivateProfileStringW] lpAppName=%S; lpKeyName=%S; lpString=%S; lpFileName=%S", 
        lpAppName, lpKeyName, lpString, lpFileName);

    BOOL bRet = WritePrivateProfileStringW(
        lpAppName,
        lpKeyName,
        lpString,
        lpFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        WCHAR wszFileName[MAX_PATH] = L"";
        MakeFileNameForProfileAPIsW(lpFileName, wszFileName);
        g_td.AddObject(wszFileName, FALSE);

        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatWritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[WritePrivateProfileSectionW] lpAppName=%S; lpString=%S; lpFileName=%S", 
        lpAppName, lpString, lpFileName);

    BOOL bRet = WritePrivateProfileSectionW(
        lpAppName,
        lpString,
        lpFileName);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        WCHAR wszFileName[MAX_PATH] = L"";
        MakeFileNameForProfileAPIsW(lpFileName, wszFileName);

        g_td.AddObject(wszFileName, FALSE);

        LUA_SET_API_ERROR;
    }

    return bRet;
}

BOOL 
LuatWritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID lpStruct,
    UINT uSizeStruct,
    LPCWSTR szFile
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[WritePrivateProfileStructW] lpszKey=%S; szFile=%S", 
        lpszKey, szFile);

    BOOL bRet = WritePrivateProfileStructW(
        lpszSection,
        lpszKey,
        lpStruct,
        uSizeStruct,
        szFile);

    if (bRet)
    {
        LUA_GET_API_ERROR;

        WCHAR wszFileName[MAX_PATH] = L"";
        MakeFileNameForProfileAPIsW(szFile, wszFileName);

        g_td.AddObject(wszFileName, FALSE);

        LUA_SET_API_ERROR;
    }

    return bRet;
}

HFILE 
LuatOpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[OpenFile] lpFileName=%s", lpFileName);

    STRINGA2W wstrFileName(lpFileName);
    LPWSTR pwszTempFile = LuatpGetLongObjectName(wstrFileName, FALSE);

    HFILE hFile = OpenFile(lpFileName, lpReOpenBuff, uStyle);

    if (hFile != HFILE_ERROR)
    {
        if (uStyle & OF_CREATE || 
            uStyle & OF_DELETE ||
            uStyle & OF_READWRITE ||
            uStyle & OF_WRITE)
        {
            LUA_GET_API_ERROR;

            g_td.AddObjectDirect(pwszTempFile, FALSE);

            LUA_SET_API_ERROR;
        }
    }

    delete [] pwszTempFile;

    return hFile;
}

HFILE 
Luat_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[_lopen] lpPathName=%s", lpPathName);

    HFILE hFile = _lopen(lpPathName, iReadWrite);

    if (hFile != HFILE_ERROR)
    {
        if (iReadWrite & OF_READWRITE || iReadWrite & OF_WRITE)
        {
            LUA_GET_API_ERROR;

            STRINGA2W wstrPathName(lpPathName);
            g_td.AddObject(wstrPathName, FALSE);

            LUA_SET_API_ERROR;
        }

    }

    return hFile;
}

HFILE 
Luat_lcreat(
    LPCSTR lpPathName,
    int iAttribute
    )
{
    DPF("TrackFS", eDbgLevelInfo, 
        "[_lcreat] lpPathName=%s", lpPathName);

    HFILE hFile = _lcreat(lpPathName, iAttribute);

    if (hFile != HFILE_ERROR)
    {
        LUA_GET_API_ERROR;

        STRINGA2W wstrPathName(lpPathName);
        g_td.AddObject(wstrPathName, FALSE);

        LUA_SET_API_ERROR;
    }

    return hFile;
}

BOOL
LuatFSInit()
{
    SetUnhandledExceptionFilter(ExceptionFilter);

    return g_td.Init();
}

VOID 
LuatFSCleanup()
{
    g_td.Record();
    g_td.Free();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\redirectreg_cleanup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   RedirectReg_Cleanup.cpp

 Abstract:

    What apps usually do in their uninstall is they always enum a key with
    index 0; if the key has subkeys, they keep enuming until they find a child
    key that doesn't have subkeys; then perform the deletion.

   Delete the original key and all the present redirected keys in 
   every user's hive.
   
 Created:

    03/21/2001 maonis
    
 Modified:
    
    01/10/2002 maonis   Updated because of the changes we made in RedirectReg.cpp

--*/
#include "precomp.h"
#include "utils.h"

// Stores the open key HKEY_USERS\SID and HKEY_USER\SID_Classes for each user.
static USER_HIVE_KEY* g_hUserKeys = NULL;

// Number of users that have a Redirected directory.
static DWORD g_cUsers = 0;

struct COPENKEY
{
    COPENKEY* next;

    HKEY hKey;
    HKEY hkBase;
    LPWSTR pwszPath;
    DWORD cPathLen;
};

static COPENKEY* g_openkeys = NULL;

struct CLEANUPKEY
{
    CLEANUPKEY(
        COPENKEY* keyParent,
        HKEY hKey,
        LPCWSTR lpSubKey)
    {
        pwszPath = NULL;
        pwszRedirectPath = NULL;
        hkBase = 0;
        cPathLen = 0;
        fIsClasses = FALSE;

        //
        // Calculate the length of the key path so we know how much space to allocate.
        //
        LPWSTR pwszParentPath = NULL;
        DWORD cLen = 0;
        DWORD cLenRedirect = 0;
        DWORD cLenParent = 0;
        DWORD cLenSubKey = 0;
        DWORD cLenTrace = 0;

        if (keyParent)
        {
            hkBase = keyParent->hkBase;

            pwszParentPath = keyParent->pwszPath;

            if (pwszParentPath && *pwszParentPath)
            {
                cLenParent = keyParent->cPathLen;
            }
        }
        else if (IsPredefinedKey(hKey))
        {
            hkBase = hKey;
        }
        else
        {
    #ifdef DBG
            DPF("RedirectReg", eDbgLevelError,
                "[CLEANUPKEY::CLEANUPKEY] 0x%08x is an invalid open key handle",
                hKey);
    #endif 
            return;
        }

        //
        // Add the length of the redirect key portion.
        //
        if (hkBase == HKEY_LOCAL_MACHINE)
        {
            cLenRedirect = LUA_REG_REDIRECT_KEY_LEN;
            cLen += LUA_REG_REDIRECT_KEY_LEN; // Software\Redirected
        }
        else if (hkBase == HKEY_CLASSES_ROOT)
        {
            fIsClasses = TRUE;
        }
        else if (hkBase != HKEY_CURRENT_USER)
        {
            return;
        }

        //
        // Add the length of the parent key portion.
        //
        if (cLenParent)
        {
            if (cLenRedirect)
            {
                //
                // count the '\' that concatenate redirect and parent.
                //
                ++cLen;
            }

            cLen += cLenParent; 
        }

        //
        // Add the length of the subkey portion.
        //
        if (lpSubKey)
        {
            cLenSubKey = wcslen(lpSubKey);

            if (cLenSubKey)
            {
                if (cLen)
                {
                    //
                    // Make room for the '\' before the subkey.
                    //
                    ++cLen;
                }

                cLen += cLenSubKey;
            }
        }

        //
        // Allocate memory for the redirected path.
        //
        pwszRedirectPath = new WCHAR [cLen + 1];

        if (!pwszRedirectPath)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[CLEANUPKEY::CLEANUPKEY] Failed to allocate %d WCHARs for key path",
                cLen + 1);

            return;
        }

        ZeroMemory(pwszRedirectPath, (cLen + 1) * sizeof(WCHAR));

        if (hkBase == HKEY_LOCAL_MACHINE)
        {
            wcscpy(pwszRedirectPath, LUA_REG_REDIRECT_KEY);
        }

        cLenTrace += cLenRedirect;

        if (cLenParent)
        {
            if (cLenTrace)
            {
                pwszRedirectPath[cLenTrace] = L'\\';

                ++cLenTrace;
            }

            wcscpy(pwszRedirectPath + cLenTrace, pwszParentPath);
        }

        cLenTrace += cLenParent;

        if (cLenSubKey)
        {
            if (cLenTrace)
            {
                pwszRedirectPath[cLenTrace] = L'\\';

                ++cLenTrace;
            }

            wcscpy(pwszRedirectPath + cLenTrace, lpSubKey);
        }

        cLenTrace += cLenSubKey;

        if (cLenRedirect)
        {
            if (cLenTrace != cLenRedirect)
            {
                ++cLenRedirect;
            }
        }

        pwszPath = pwszRedirectPath + cLenRedirect;
        cPathLen = cLen - cLenRedirect;
    }

    ~CLEANUPKEY()
    {
        delete [] pwszRedirectPath;
        pwszRedirectPath = NULL;
        pwszPath = NULL;
        hkBase = 0;
        cPathLen = 0;
    }

    //
    // For each type of key, what those values look like:
    //
    //                     HKCU\a  HKLM\a                  HKCR\a
    // pwszRedirectPath    a       Software\Redirected\a   a
    // hkBase              0       HKLM                    HKCR
    // pwszPath            a       a                       a
    //

    LPWSTR pwszRedirectPath;

    HKEY hkBase;
    LPWSTR pwszPath;
    DWORD cPathLen;
    BOOL fIsClasses;
};

LONG 
AddKey(
    HKEY hKey,
    CLEANUPKEY* ck
    )
{
    COPENKEY* key = new COPENKEY;
    if (!key)
    {
        DPF("REGC", eDbgLevelError, 
            "Error allocating memory for a new COPENKEY");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    key->hKey = hKey;
    key->hkBase = ck->hkBase;

    //
    // If rk->pwszPath is NULL, it means it was either one of the
    // keys we don't handle or a bad handle.
    // In any of those cases, we won't be needing the path anyway.
    //
    if (ck->pwszPath)
    {
        key->pwszPath = new WCHAR [ck->cPathLen + 1];

        if (key->pwszPath)
        {
            if (ck->pwszPath)
            {
                wcscpy(key->pwszPath, ck->pwszPath);
                key->cPathLen = ck->cPathLen;
            }
        }
        else
        {
            delete key;

            DPF("REGC", eDbgLevelError, 
                "Error allocating memory for %d WCHARs",
                ck->cPathLen + 1);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
 
    key->next = g_openkeys;
    g_openkeys = key;

    return ERROR_SUCCESS;
}

COPENKEY* 
FindKey(
    HKEY hKey
    )
{
    COPENKEY* key = g_openkeys;

    while (key)
    {
        if (key->hKey == hKey)
        {
            return key;
        }

        key = key->next;
    }

    return NULL;
}

//
// locking stuff.
//

static BOOL g_bInitialized = FALSE;

static CRITICAL_SECTION g_csRegCleanup;

class CRRegCleanupLock
{
public:
    CRRegCleanupLock()
    {
        if (!g_bInitialized)
        {
            InitializeCriticalSection(&g_csRegCleanup);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csRegCleanup);
    }
    ~CRRegCleanupLock()
    {
        LeaveCriticalSection(&g_csRegCleanup);
    }
};

//
// Exported APIs.
//

/*++

 Function Description:

    We open the key at the first location we can find, ie, if we
    can't find it at the original location we try in redirected locations.

 History:

    02/16/2001 maonis  Created
    01/10/2002 maonis  Modified

--*/

LONG 
LuacRegOpenKeyExW(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegCleanupLock Lock;

    DPF("REGC", eDbgLevelInfo,
        "[LuacRegOpenKeyExW] hKey=0x%08x, lpSubKey=%S, samDesired=0x%08x",
        hKey, lpSubKey, samDesired);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    CLEANUPKEY ck(FindKey(hKey), hKey, lpSubKey);

    if (ck.pwszPath)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegOpenKeyExW] hkBase=0x%08x, path=%S",
            ck.hkBase,
            ck.pwszPath);

        if (ck.hkBase)
        {
            lRes = RegOpenKeyExW(
                ck.hkBase,         
                ck.pwszPath,  
                ulOptions,
                samDesired, 
                phkResult);
        }

        if (lRes == ERROR_FILE_NOT_FOUND)
        {
            for (DWORD dw = 0; dw < g_cUsers; ++dw)
            {
                if ((lRes = RegOpenKeyExW(
                    (ck.fIsClasses ? g_hUserKeys[dw].hkUserClasses : g_hUserKeys[dw].hkUser),
                    ck.pwszRedirectPath,
                    ulOptions,
                    samDesired,
                    phkResult)) == ERROR_SUCCESS)
                {
                    break;
                }
            }
        }
    }
    else
    {
        lRes = RegOpenKeyExW(
            hKey,         
            lpSubKey,  
            ulOptions,   
            samDesired, 
            phkResult);
    }
    
    if (lRes == ERROR_SUCCESS)
    {
        lRes = AddKey(*phkResult, &ck);

        DPF("REGC", eDbgLevelInfo,
            "[LuacRegOpenKeyExW] openkey=0x%08x",
            *phkResult);
    }

    return lRes;
}

LONG 
LuacRegOpenKeyW(
    HKEY hKey,         
    LPWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    return LuacRegOpenKeyExW(
        hKey,
        lpSubKey,
        0, 
        MAXIMUM_ALLOWED, 
        phkResult);
}

/*++

 Function Description:

    We enum the key at the first location we can find, ie, if we
    can't find it at the original location we try in redirected locations.

 History:

    02/16/2001 maonis  Created
    01/10/2002 maonis  Modified

--*/

LONG 
LuacRegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegCleanupLock Lock;
    DPF("REGC", eDbgLevelInfo,
        "[LuacRegEnumKeyExW] hKey=0x%08x, dwIndex=%d",
        hKey, dwIndex);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    LONG lTempRes;
    CLEANUPKEY ck(FindKey(hKey), hKey, NULL);
    HKEY hEnumKey;

    if (ck.pwszPath)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegEnumKeyExW] hkBase=0x%08x, path=%S",
            ck.hkBase,
            ck.pwszPath);

        if (ck.hkBase)
        {
            //
            // Open the original key.
            //
            lRes = RegOpenKeyW(ck.hkBase, ck.pwszPath, &hEnumKey);

            if (lRes == ERROR_SUCCESS)
            {
                lRes = RegEnumKeyExW(
                    hEnumKey,
                    dwIndex,
                    lpName,
                    lpcbName,
                    lpReserved,
                    lpClass,
                    lpcbClass,
                    lpftLastWriteTime);

                RegCloseKey(hEnumKey);
            }
        }

        //
        // If we can't find it or the key at the original location doesn't
        // have any more keys, we need to check the redirected locations -
        // the key might exist at one of those locations and/or have more keys.
        //
        if (lRes == ERROR_FILE_NOT_FOUND || lRes == ERROR_NO_MORE_ITEMS)
        {
            lTempRes = lRes;

            for (DWORD dw = 0; dw < g_cUsers; ++dw)
            {
                HKEY hKeyOriginal;

                if ((lRes = RegOpenKeyW(
                    (ck.fIsClasses ? g_hUserKeys[dw].hkUserClasses : g_hUserKeys[dw].hkUser), 
                    ck.pwszRedirectPath, 
                    &hEnumKey)) 
                    == ERROR_SUCCESS)
                {
                    lRes = RegEnumKeyExW(
                        hEnumKey,
                        dwIndex,
                        lpName,
                        lpcbName,
                        lpReserved,
                        lpClass,
                        lpcbClass,
                        lpftLastWriteTime);

                    RegCloseKey(hEnumKey);

                    if (lRes == ERROR_SUCCESS)
                    {
                        return lRes;
                    }

                    if (lRes == ERROR_NO_MORE_ITEMS)
                    {
                        lTempRes = lRes;
                    }
                }
            }

            if (lTempRes == ERROR_NO_MORE_ITEMS)
            {
                //
                // If it was originally not found now it's found and has no subkeys, 
                // we need to set the return value to ERROR_NO_MORE_ITEMS so the app
                // will delete it.
                //
                lRes = lTempRes;
            }
        }
    }
    else
    {
        return RegEnumKeyExW(
            hKey,
            dwIndex,
            lpName,
            lpcbName,
            lpReserved,
            lpClass,
            lpcbClass,
            lpftLastWriteTime);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegEnumKeyExW] sukey is %S",
            lpName);
    }

    return lRes;
}

LONG 
LuacRegEnumKeyW(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    return LuacRegEnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
LuacRegCloseKey(HKEY hKey)
{
    CRRegCleanupLock Lock;
    DPF("REGC", eDbgLevelInfo,
        "[LuacRegCloseKey] closing key 0x%08x",
        hKey);

    COPENKEY* key = g_openkeys;
    COPENKEY* last = NULL;

    while (key)
    {
        if (key->hKey == hKey)
        {
            if (last)
            {
                last->next = key->next; 
            }
            else
            {
                g_openkeys = key->next;
            }

            delete key;
            break;
        }

        last = key;
        key = key->next;
    }

    return RegCloseKey(hKey);
}

/*++

 Function Description:

    We only handle HKCU, HKLM and HKCR keys:

    For HKLM keys, we need to delete at HKLM and each user's redirect location.
    For HKCU keys, we need to delete it in each user's hive.
    For HKCR keys, we need to delete at HKLM\Software\Classes and at each user's
    HKCU\Software\Classes.

 Arguments:

    IN hKey - the handle value of this key.
    IN lpSubKey - path of the subkey that this key opened.

 Return Value:
    
    If we succeed in deleting anykey, we return success.

 History:

    02/16/2001 maonis  Created
    01/10/2002 maonis  Modified

--*/

LONG      
LuacRegDeleteKeyW(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRRegCleanupLock Lock;
    DPF("REGC", eDbgLevelInfo,
        "[LuacRegDeleteKeyW] hKey=0x%08x, lpSubKey=%S",
        hKey, lpSubKey);

    LONG lFinalRes = ERROR_FILE_NOT_FOUND;
    CLEANUPKEY ck(FindKey(hKey), hKey, lpSubKey);

    if (ck.pwszPath)
    {
        DPF("REGC", eDbgLevelInfo,
            "[LuacRegDeleteKeyW] hkBase=0x%08x, path=%S",
            ck.hkBase,
            ck.pwszPath);

        if (ck.hkBase)
        {
            if (RegDeleteKeyW(ck.hkBase, ck.pwszPath) == ERROR_SUCCESS)
            {
                lFinalRes = ERROR_SUCCESS;
            }
        }

        for (DWORD dw = 0; dw < g_cUsers; ++dw)
        {
            if (RegDeleteKeyW((
                ck.fIsClasses ? g_hUserKeys[dw].hkUserClasses : g_hUserKeys[dw].hkUser), 
                ck.pwszRedirectPath) 
                == ERROR_SUCCESS)
            {
                lFinalRes = ERROR_SUCCESS;
            }
        }
    }
    else
    {
        return RegDeleteKeyW(hKey, lpSubKey);
    }

    return lFinalRes;
}

BOOL
LuacRegInit()
{
    return GetUsersReg(&g_hUserKeys, &g_cUsers);
}

VOID
LuacRegCleanup()
{
    FreeUsersReg(g_hUserKeys, g_cUsers);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\redirectfs.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RedirectFS.h

 Notes:

    This is a general purpose shim.

 History:

    02/12/2001 maonis  Created

--*/

#ifndef _LUA_REDIRECT_FS_H_
#define _LUA_REDIRECT_FS_H_

#include <sfc.h>

extern DWORD g_cRedirectRootAllUser;
extern DWORD g_cRedirectRootPerUser;

//
// Helper functions.
// 

// Object type
enum EOBJTYPE
{
    OBJ_FILE = 1,
    OBJ_DIR = 2,
    // When GetFileAttributes/SetFileAttributes or FindFirstFile 
    // is called, we are not sure if the object is a file or a directory
    // so we need to search in both lists.
    OBJ_FILE_OR_DIR = 3
};

// File system type
enum EFSTYPE
{
    FS_UNINIT = 0,
    FS_NTFS,
    FS_NON_NTFS
};

BOOL IsInRedirectList(LPCWSTR pwszObject, BOOL* pfAllUser = NULL);
BOOL IsNTFSW(LPCWSTR pwszFile);
LPWSTR MassageName(LPWSTR pwszFullPath);

inline BOOL
IsNotFileW(LPCWSTR pwszName)
{
    UINT cLen = wcslen(pwszName);
    
    // If the user specify a trailing slash, we never need to do anything.
    // because it'll never return ACCESS_DENIED.
    if (pwszName[cLen - 1] == L'\\')
    {
        return TRUE;
    }

    return FALSE;
}

// Check if a file is under SFP.
inline BOOL 
IsFileSFPedW(LPCWSTR pszFile)
{
    return SfcIsFileProtected(NULL, pszFile);
}

// Some apps (actually one so far) use the \\?\ notation when they call
// CreateFile for the file name. For now we simply ignore that part.
// When the app uses this notation they could pass in a file name that's 
// longer than MAX_PATH - we might need to handle this later.
inline LPCWSTR 
ConvertToNormalPath(LPCWSTR pwszPath)
{
    if (pwszPath)
    {
        if (!wcsncmp(pwszPath, FILE_NAME_PREFIX, FILE_NAME_PREFIX_LEN))
        {
            //
            // When you use the \\?\ prefix to open a disk file you must pass in 
            // the full path so we check if the 2nd char after the prefix is ':'.
            //
            DWORD cLen = wcslen(pwszPath);
            
            if (cLen >= (FILE_NAME_PREFIX_LEN + 2) && 
                pwszPath[FILE_NAME_PREFIX_LEN + 1] == L':')
            {
                pwszPath = pwszPath + FILE_NAME_PREFIX_LEN;
            }
            else 
            {
                //
                // Otherwise we treat it like a non disk file in which case we
                // just let the original API to handle it.
                //
                return NULL;
            }
        }
    }

    return pwszPath;
}

struct REDIRECTFILE
{
    REDIRECTFILE(LPCWSTR pwszOriginalName, EOBJTYPE eObjType = OBJ_FILE, BOOL fCheckRedirectList = TRUE)
    {
        // Before we get the full path there's a special case to check for.
        // If we have a console handle say CONIN$, we are going to get 
        // currentdirectory\CONIN$ back if we call GetFullPathName on it.
        // For other special cases like com ports, GetFullPathName returns
        // something like \\.\com1 which will be handled by IsNotFile.
        WCHAR wszFullPath[MAX_PATH] = L"";
        DWORD cFullPath = 0;

        pwszOriginalName = ConvertToNormalPath(pwszOriginalName);
        m_pwszAlternateName = NULL;
        ZeroMemory(m_wszOriginalName, sizeof(m_wszOriginalName));

        //
        // Do the easy checks first.
        //
        if (!pwszOriginalName ||
            !_wcsicmp(pwszOriginalName, L"conin$") || 
            !_wcsicmp(pwszOriginalName, L"conout$"))
        {
            return;
        }

        cFullPath = GetFullPathNameW(pwszOriginalName, MAX_PATH, wszFullPath, NULL);

        //
        // Make sure we can get the full path and within the range we handle.
        //
        if (!cFullPath || cFullPath < 2 || cFullPath > MAX_PATH)
        {
            return;
        }

        //
        // Verify it's the kind of file we handle, ie, it must start with x: and not
        // contain any of the following chars.
        //
        WCHAR chDrive = (WCHAR)tolower(wszFullPath[0]);

        if (wszFullPath[1] != L':' || !(chDrive >= L'a' && chDrive <= L'z') ||
            ((eObjType == OBJ_FILE) && IsNotFileW(wszFullPath)))
        {
            return;
        }

        //
        // Do the more complicated checks.
        //
        if (!IsNTFSW(wszFullPath) ||
            !MassageName(wszFullPath) ||
            IsUserDirectory(wszFullPath) ||
            (fCheckRedirectList && !IsInRedirectList(wszFullPath, &m_fAllUser)))
        {
            return;
        }

        m_eObjType = eObjType;

        wcsncpy(m_wszOriginalName, wszFullPath, MAX_PATH);

        //
        // if fCheckRedirectList is FALSE, it means it could be in either per user or
        // all user dir, the caller should then call separated methods to retrieve each
        // redirected file name.
        //
        if (fCheckRedirectList) 
        {
            // Construct the alternate file name.
            MakeAlternateName();
        }
    }

    ~REDIRECTFILE()
    {
        delete [] m_pwszAlternateName;
    }

    BOOL CreateAlternateCopy(BOOL fCopyFile = TRUE);

    VOID GetAlternateAllUser();
    VOID GetAlternatePerUser();

    WCHAR m_wszOriginalName[MAX_PATH];
    LPWSTR m_pwszAlternateName;
    BOOL m_fAllUser;

private:

    VOID MakeAlternateName();

    EOBJTYPE m_eObjType;
};

// We give the users an option to exclude files with extensions they specify.
// This is mostly useful when you want to redirect everything except user
// created files.

#define EXCLUDED_EXTENSIONS_DELIMITER L' '

struct EXCLUDED_EXTENSIONS
{
    // We store all extensions in one string, using '/' as the delimiter.
    LPWSTR pwszExtensions;
    DWORD cExtensions;
    DWORD* pdwIndices;
    DWORD cIndices;

    EXCLUDED_EXTENSIONS()
    {
        pwszExtensions = NULL;
        cExtensions = 0;
        pdwIndices = NULL;
        cIndices = 0;
    }

    ~EXCLUDED_EXTENSIONS()
    {
        //
        // Let the process clean up the memory for us.
        //
    }

    BOOL Init(LPCWSTR pwszExcludedExtensions)
    {
        if (!pwszExcludedExtensions || !*pwszExcludedExtensions)
        {
            //
            // Nothing to do.
            //
            return TRUE;
        }

        cExtensions = wcslen(pwszExcludedExtensions);

        pwszExtensions = new WCHAR [cExtensions + 2];

        if (!pwszExtensions)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[EXCLUDED_EXTENSIONS::Init] Error allocating %d WCHARs",
                cExtensions + 1);

            return FALSE;
        }

        ZeroMemory(pwszExtensions, (cExtensions + 1) * sizeof(WCHAR));
        NormalizeExtensions(pwszExcludedExtensions);
        ++cIndices;

        pdwIndices = new DWORD [cIndices];

        if (!pdwIndices)
        {
            DPF("RedirectFS", eDbgLevelError, 
                "[EXCLUDED_EXTENSIONS::Init] Error allocating %d DWORDs",
                cIndices);

            delete [] pwszExtensions;
            pwszExtensions = NULL;
            return FALSE;
        }

        ZeroMemory(pdwIndices, cIndices * sizeof(DWORD));

        DWORD dwIndex = 1;
        LPWSTR pwszTemp = pwszExtensions;

        while (*pwszTemp)
        {
            if (*pwszTemp == EXCLUDED_EXTENSIONS_DELIMITER)
            {
                pdwIndices[dwIndex] = (DWORD)(pwszTemp - pwszExtensions + 1);

                if (++dwIndex == cIndices - 1)
                {
                    break;
                }
            }

            ++pwszTemp;
        }

        pdwIndices[cIndices - 1] = cExtensions + 1;

        return TRUE;
    }

    BOOL IsExtensionExcluded(LPCWSTR pwszName)
    {
        DWORD cItemLen = wcslen(pwszName);
        DWORD cExtensionLen, cExtensionLenItem;
        LPWSTR pwszExtensionItem;

        if ((pwszExtensionItem = wcschr(pwszName, L'.')) == NULL)
        {
            //
            // If the file has no extension, it will not be excluded.
            //
            return FALSE;
        }
        else
        {
            cExtensionLenItem = (DWORD)(cItemLen - (pwszExtensionItem - pwszName) - 1);
        }

        for (DWORD dwIndex = 0; dwIndex < cIndices - 1; ++dwIndex)
        {
            cExtensionLen = pdwIndices[dwIndex + 1] - pdwIndices[dwIndex] - 1;

            if (cExtensionLen == cExtensionLenItem)
            {
                if (!_wcsnicmp(
                    pwszName + cItemLen - cExtensionLen, 
                    pwszExtensions + pdwIndices[dwIndex],
                    cExtensionLen))
                {
                    return TRUE;
                }
            }
        }

        return FALSE;
    }

private:

    //
    // We want to "normalize" the extension list to
    // "xxx xxx xxx" without any extra spaces.
    //
    void NormalizeExtensions(LPCWSTR pwszExcludedExtensions)
    {
        LPWSTR pwsz = (LPWSTR)pwszExcludedExtensions;
        LPCWSTR pwszToken = wcstok(pwsz, L" \t");

        while (pwszToken)
        {
            wcscat(pwszExtensions, pwszToken);
            wcscat(pwszExtensions, L" ");
            ++cIndices;
            pwszToken = wcstok(NULL, L" \t");
        }

        cExtensions = wcslen(pwszExtensions);
        if (cExtensions > 1)
        {
            pwszExtensions[cExtensions - 1] = L'\0';
            --cExtensions;
        }
    }
};

// We keep the deleted files in an in-memory lists.
struct DELETEDFILE
{
    LIST_ENTRY entry;
    LPWSTR pwszName;
};

//
// If we can find this file in the deletion list, return the entry.
//
PLIST_ENTRY 
FindDeletedFile(
    LPCWSTR pwszFile
    );

//
// Check if the file exists in the deletion list, if not, add it to
// the beginning of the list.
//
BOOL
AddDeletedFile(
    LPCWSTR pwszPath
    );

#endif // _LUA_REDIRECT_FS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\redirectfs_cleanup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   03/30/2001 maonis

 Modified:

--*/

#include "precomp.h"
#include "utils.h"

// Stores the redirected path for each user.
// eg, d:\documents and settings\someuser\Local Settings\Application Data\Redirected\.
static REDIRECTED_USER_PATH* g_rup = NULL;

// Number of users that have a Redirected directory.
static DWORD g_cUsers = 0;

static BOOL g_fDefaultRedirect = TRUE;

static WCHAR g_wszRedirectRootAllUser[MAX_PATH] = L"";
static DWORD g_cRedirectRootAllUser = 0; // Doesn't include the terminating NULL.

#define ALLUSERS_APPDATA L"%ALLUSERSPROFILE%\\Application Data\\"
#define REDIRECTED_DIR L"Redirected\\"
#define REDIRECTED_DIR_LEN (sizeof(REDIRECTED_DIR) / sizeof(WCHAR) - 1)

// This struct has a unicode buffer of MAX_PATH length. We only allocate memory
// on the heap if the path is longer than MAX_PATH.
struct MAKEREDIRECT
{
    MAKEREDIRECT() 
    {
        pwszRedirectedPath = NULL;
    }

    ~MAKEREDIRECT() 
    {
        delete [] pwszRedirectedPath;
    }

    LPWSTR 
    ConvertToRedirect(
        LPCWSTR pwszOriginal
        )
    {
        if (pwszOriginal)
        {
            LPWSTR pwszNew = wszRedirectedPath;
            DWORD cFileNameSize = wcslen(pwszOriginal);
            DWORD cSize = g_cRedirectRootAllUser + cFileNameSize;

            if (cSize > MAX_PATH)
            {
                if (pwszRedirectedPath)
                {
                    delete [] pwszRedirectedPath;
                }

                // Need to allocate memory for this long file name.
                pwszRedirectedPath = new WCHAR [cSize];
                if (!pwszRedirectedPath)
                {
                    return NULL;
                }
            }

            // Now we have a big enough buffer, convert to redirected path.
            wcsncpy(pwszNew, g_wszRedirectRootAllUser, g_cRedirectRootAllUser);
            // Get the drive letter.
            pwszNew[g_cRedirectRootAllUser] = *pwszOriginal;
            wcsncpy(pwszNew + g_cRedirectRootAllUser + 1, pwszOriginal + 2, cFileNameSize - 2);
            pwszNew[g_cRedirectRootAllUser + (cSize - 1)] = L'\0';
            
            return pwszNew;
        }

        return NULL;
    }

private:

    WCHAR wszRedirectedPath[MAX_PATH];
    WCHAR* pwszRedirectedPath;
};

// For APIs that probe if the file is there, we return TRUE if 
// it exists at the original location or ANY user's redirected location.
// Normally an uninstall program doesn't call FindNextFile - it keeps a list
// of files it installed and uses FindFirstFile to verify if the file 
// exists then call FindClose.
HANDLE 
LuacFindFirstFileW(
    LPCWSTR lpFileName,               
    LPWIN32_FIND_DATAW lpFindFileData
    )
{
    if (!g_fDefaultRedirect)
    {
        return FindFirstFileW(lpFileName, lpFindFileData);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[FindFirstFileW] lpFileName=%S", lpFileName);

    HANDLE hFind;

    if ((hFind = FindFirstFileW(lpFileName, lpFindFileData)) == INVALID_HANDLE_VALUE &&
        IsErrorNotFound())
    {
        // If we can't find the file at the original location, we try to find it at 
        // an alternate location.
        MAKEREDIRECT md;
        LPWSTR pwszRedirected;

        pwszRedirected = md.ConvertToRedirect(lpFileName);

        if (pwszRedirected)
        {
            hFind = FindFirstFileW(pwszRedirected, lpFindFileData);
        }
    }

    return hFind;
}

DWORD 
LuacGetFileAttributesW(
    LPCWSTR lpFileName
    )
{
    if (!g_fDefaultRedirect)
    {
        return GetFileAttributesW(lpFileName);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[GetFileAttributesW] lpFileName=%S", lpFileName);

    DWORD dwRes;

    if ((dwRes = GetFileAttributesW(lpFileName)) == -1 && IsErrorNotFound())
    {
        // If we can't find the file at the original location, we try to find it at 
        // an alternate location.
        MAKEREDIRECT md;
        LPWSTR pwszRedirected;

        pwszRedirected = md.ConvertToRedirect(lpFileName);

        if (pwszRedirected)
        {
            dwRes = GetFileAttributesW(pwszRedirected);
        }
    }

    return dwRes;
}

// Some uninstallers use CreateFile to probe that the file is there and can be written to.
HANDLE 
LuacCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    if (!g_fDefaultRedirect)
    {
        return CreateFileW(
            lpFileName,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[GetFileAttributesW] lpFileName=%S", lpFileName);

    HANDLE hFile;

    if ((hFile = CreateFileW(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile)) == INVALID_HANDLE_VALUE && 
        IsErrorNotFound())
    {
        // If we can't find the file at the original location, we try to find it at 
        // an alternate location.
        MAKEREDIRECT md;
        LPWSTR pwszRedirected;

        pwszRedirected = md.ConvertToRedirect(lpFileName);

        if (pwszRedirected)
        {
            hFile = CreateFileW(
                pwszRedirected,
                dwDesiredAccess,
                dwShareMode,
                lpSecurityAttributes,
                dwCreationDisposition,
                dwFlagsAndAttributes,
                hTemplateFile);
        }
    }

    return hFile;
}

// If we can delete the file at either the original location or any user's redireted path,
// we return TRUE.
BOOL 
LuacDeleteFileW(
    LPCWSTR lpFileName
    )
{
    if (!g_fDefaultRedirect)
    {
        return DeleteFileW(lpFileName);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[DeleteFileW] lpFileName=%S", lpFileName);

    BOOL fFinalRes = FALSE;

    if (DeleteFileW(lpFileName))
    {
        fFinalRes = TRUE;
    }

    MAKEREDIRECT md;
    LPWSTR pwszRedirected;

    pwszRedirected = md.ConvertToRedirect(lpFileName);

    if (pwszRedirected && DeleteFileW(pwszRedirected))
    {
        fFinalRes = TRUE;
    }

    return fFinalRes;
}

BOOL 
LuacRemoveDirectoryW(
    LPCWSTR lpPathName
    )
{
    if (!g_fDefaultRedirect)
    {
        return RemoveDirectoryW(lpPathName);
    }

    DPF("RedirectFS_Cleanup", eDbgLevelInfo, 
        "[RemoveDirectoryW] lpPathName=%S", lpPathName);

    BOOL fFinalRes = FALSE;

    if (RemoveDirectoryW(lpPathName))
    {
        fFinalRes = TRUE;
    }

    MAKEREDIRECT md;
    LPWSTR pwszRedirected;

    pwszRedirected = md.ConvertToRedirect(lpPathName);
    
    if (pwszRedirected && RemoveDirectoryW(pwszRedirected))
    {
        fFinalRes = TRUE;
    }

    return fFinalRes;
}

VOID 
DeleteObject(
    LPCWSTR pwsz
    )
{
    //
    // If the object is read-only we need to unset that attribute.
    //
    DWORD dw = GetFileAttributesW(pwsz);

    if (dw != -1)
    {
        if (dw & FILE_ATTRIBUTE_READONLY)
        {
            dw &= ~FILE_ATTRIBUTE_READONLY;
            SetFileAttributesW(pwsz, dw);
        }

        if (dw & FILE_ATTRIBUTE_DIRECTORY)
        {
            RemoveDirectoryW(pwsz);
        }
        else
        {
            DeleteFileW(pwsz);
        }
    }
}

VOID 
DeleteFolder(
    CString& strFolder
    )
{
    DPF("RedirectFS_Cleanup", eDbgLevelSpew, 
        "[DeleteFolder] Deleting %S", (LPCWSTR)strFolder);
    CString strPattern(strFolder); 
    strPattern += L"*";

    WIN32_FIND_DATAW fd;
    HANDLE hFind = FindFirstFileW(strPattern, &fd);

    if (hFind == INVALID_HANDLE_VALUE)
    {
        return;
    }

    do
    {
        if (!wcscmp(fd.cFileName, L".") || !wcscmp(fd.cFileName, L".."))
        {
            continue;
        }
        else if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            CString strTmpDir = strFolder + fd.cFileName + L"\\";
            DeleteFolder(strTmpDir);
        }
        else
        {
            CString strTmpFile = strFolder + fd.cFileName;
            DeleteObject(strTmpFile);
        }
    }
    while (FindNextFileW(hFind, &fd));

    FindClose(hFind);

    DeleteObject(strFolder);
}

VOID
DeleteAllRedirectedDirs(
    REDIRECTED_USER_PATH* pRedirectUserPaths, 
    DWORD cUsers,
    LPCWSTR pwszAppName
    )
{
    //
    // Delete the redirect dir for each user.
    //
    for (DWORD i = 0; i < cUsers; ++i)
    {
        CString strRedirectDir = pRedirectUserPaths[i].pwszPath;
        strRedirectDir += L"\\Application Data\\";
        strRedirectDir += pwszAppName;
        strRedirectDir += L"\\";

        DeleteFolder(strRedirectDir);
    }

    //
    // Delete the redirect dir for all users.
    //
    CString strAllUserRedirectDir = g_wszRedirectRootAllUser;
    strAllUserRedirectDir += pwszAppName;
    DeleteFolder(strAllUserRedirectDir);
}

BOOL
LuacFSInit(
    LPCSTR pszCommandLine
    )
{
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "===================================\n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "        LUA FS Cleanup Shim        \n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "===================================\n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "appname                            \n");
    DPF("RedirectFS_Cleanup", eDbgLevelInfo, "-----------------------------------");

    //
    // We need to get the ALLUSERSPROFILE dir in any case.
    //
    ZeroMemory(g_wszRedirectRootAllUser, MAX_PATH * sizeof(WCHAR));

    DWORD cRedirectRoot = 0;
    LPWSTR pwszExpandDir = ExpandItem(
        ALLUSERS_APPDATA,
        &cRedirectRoot,
        TRUE,   // It's a directory.
        FALSE,  // The directory has to exist.
        TRUE);  // Add the \\?\ prefix.
    if (pwszExpandDir)
    {
        if (cRedirectRoot + REDIRECTED_DIR_LEN > MAX_PATH)
        {
            DPF("RedirectFS_Cleanup", eDbgLevelError,
                "[LuacFSInit] The redirect path %S is too long - we don't handle it",
                pwszExpandDir);

            delete [] pwszExpandDir;
            return FALSE;
        }

        wcscpy(g_wszRedirectRootAllUser, pwszExpandDir);
        g_cRedirectRootAllUser = cRedirectRoot - 1;

        delete [] pwszExpandDir;
    }

    if (pszCommandLine && pszCommandLine[0] != '\0')
    {
        LPWSTR pwszCommandLine = AnsiToUnicode(pszCommandLine);

        if (pwszCommandLine)
        {
            //
            // If the user specified an appname on the commandline, it means all the
            // redirected files will be either in SomeUserProfile\Application Data\appname
            // or AllUsersProfile\Application Data\appname. We just need to delete those
            // directories.
            //
            GetUsersFS(&g_rup, &g_cUsers);
            
            DeleteAllRedirectedDirs(g_rup, g_cUsers, pwszCommandLine);

            FreeUsersFS(g_rup);

            delete [] pwszCommandLine;
        }
        else
        {
            DPF("RedirectFS_Cleanup", eDbgLevelError, 
                "[LuapParseCommandLine] Failed to allocate memory for commandline");
        }

        g_fDefaultRedirect = FALSE;
    }
    else
    {
        //
        // If the user didn't specify anything on the commandline, it means the files
        // were redirected to the default location - %ALLUSERSPROFILE%\Application Data\Redirected.
        //
        wcsncpy(g_wszRedirectRootAllUser + g_cRedirectRootAllUser, REDIRECTED_DIR, REDIRECTED_DIR_LEN);
        g_cRedirectRootAllUser += REDIRECTED_DIR_LEN;
    }

    return TRUE;
}

VOID
LuacFSCleanup(
    )
{   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\redirectreg.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LUA_RedirectReg.cpp

 Abstract:

    Redirect the reg keys to current user hive when the app needs to 
    write to them but doesn't have enough access rights.

 Notes:

    This is a general purpose shim.

 History:

    02/14/2001 maonis  Created

    05/30/2001 maonis  Exported the APIs that ntvdm needs to implement LUA 
                       stuff. Added RegQueryInfoKey hook because WOWRegDeleteKey
                       calls it.

    12/13/2001 maonis  BIG changes:
                       1) Changed to redirect keys to HKCU\Software\Redirected.
                          HKCR keys are a special case.
                       2) Merge keys at the redirect location and the original
                          location for enum.
                       3) Added an in-memory deletion list to record keys being
                          deleted.
--*/

#include "precomp.h"
#include "utils.h"
#include "RedirectReg.h"

extern HKEY g_hkRedirectRoot;
extern HKEY g_hkCurrentUserClasses;
LIST_ENTRY g_DeletedKeyList;

LONG
AddDeletedKey(
    LPCWSTR pwszPath
    )
{
    PLIST_ENTRY pEntry = FindDeletedKey(pwszPath);

    if (pEntry == NULL)
    {
        DELETEDKEY* pNewKey = new DELETEDKEY;

        if (pNewKey)
        {
            DWORD cLen = wcslen(pwszPath);
            pNewKey->pwszPath = new WCHAR [cLen + 1];

            if (pNewKey->pwszPath)
            {
                ZeroMemory(pNewKey->pwszPath, sizeof(WCHAR) * (cLen + 1));

                wcscpy(pNewKey->pwszPath, pwszPath);
                pNewKey->cLen = cLen;
                InsertHeadList(&g_DeletedKeyList, &pNewKey->entry);

                DPF("RedirectReg", eDbgLevelInfo,
                    "[AddDeletedKey] Added %S to the deletion list",
                    pwszPath);

                return ERROR_SUCCESS;
            }
            else
            {
                DPF("RedirectReg", eDbgLevelError,
                    "[AddDeletedKey] Failed to allocate %d WCHARs",
                    cLen);

                delete pNewKey;
            }
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError,
                "[AddDeletedKey] Failed to allocate a DELETEKEY");
        }
    }

    return ERROR_NOT_ENOUGH_MEMORY;
}

/*++

 Function Description:
    
    Find out if the key is supposed to be deleted.

 Arguments:

    IN pwszPath - path to the key

 Return Value:

    TRUE - The key itself or its parent key is in the deletion list.
    FALSE - Otherwise.

 History:

    12/14/2001 maonis  Created

--*/

PLIST_ENTRY 
FindDeletedKey(
    LPCWSTR pwszPath,
    BOOL* pfIsSubKey
    )
{
    DELETEDKEY* pItem;
    WCHAR ch;
    DWORD cLen = wcslen(pwszPath);

    for (PLIST_ENTRY pEntry = g_DeletedKeyList.Flink; 
        pEntry != &g_DeletedKeyList; 
        pEntry = pEntry->Flink) 
    {
        pItem = CONTAINING_RECORD(pEntry, DELETEDKEY, entry);

        if (cLen >= pItem->cLen)
        {
            ch = pwszPath[pItem->cLen];

            if (!_wcsnicmp(pItem->pwszPath, pwszPath, pItem->cLen) && 
                (ch == L'\0' || ch == L'\\')) 
            {
                DPF("RedirectReg", eDbgLevelInfo,
                    "[FindDeletedKey] Found %S in the deletion list",
                    pwszPath);

                if (pfIsSubKey)
                {
                    *pfIsSubKey = (ch == L'\\');
                }

                return pEntry;
            }
        }
    }

    return NULL;
}

VOID
MakePathForPredefinedKey(
    LPWSTR pwszPath, // is garanteed to have room for at least 4 characters.
    HKEY hKey
    )
{
    if (hKey == HKEY_CLASSES_ROOT)
    {
        wcscpy(pwszPath, L"HKCR");
    }
    else if (hKey == HKEY_CURRENT_USER)
    {
        wcscpy(pwszPath, L"HKCU");
    }
    else if (hKey == HKEY_LOCAL_MACHINE)
    {
        wcscpy(pwszPath, L"HKLM");
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError,
            "[MakePathForPredefinedKey] We shouldn't get here!!! "
            "Something is really wrong.");

#ifdef DBG
        DebugBreak();
#endif 
    }
}

/*++

 Function Description:

    Given either the OPENKEY* or the handle for the parent key and the
    subkey path, construct the redirect location for this subkey.

    We construct the redirect location for HKCR keys specially - we
    need to redirect the key to the normal redirect location and 
    HKCU\Software\Classes.

    We don't store the base key for HKCR keys as HKCR because we want 
    to make the redirection work when the app specifically asks for
    HKLM\Software\Classes keys. So we always convert HKCR to 
    HKLM\Software\Classes.

 Arguments:

    IN keyParent - the parent key info.
    IN hKey - the handle value of this key.
    IN lpSubKey - path of the subkey that this key opened.

 Return Value:

    None.

 History:

    12/13/2001 maonis  Created

--*/

CRedirectedRegistry::REDIRECTKEY::REDIRECTKEY(
    OPENKEY* keyParent,
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    pwszPath = NULL;
    pwszFullPath = NULL;
    hkBase = NULL;
    fIsRedirected = FALSE;
    hkRedirectRoot = 0;

    //
    // First make sure the redirect location is there.
    //
    if (g_hkRedirectRoot == NULL)
    {
        if (GetRegRedirectKeys() != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] Failed to open/create the root keys??!! "
                "something is really wrong");
#ifdef DBG
            DebugBreak();
#endif
            return;
        }
    }

    //
    // Calculate the length of the key path so we know how much space to allocate.
    //
    LPWSTR pwszParentPath = NULL;
    DWORD cLen = 4; // 4 chars for the predefined key.
    DWORD cLenSubKey = 0;

    if (keyParent)
    {
        hkBase = keyParent->hkBase;

        if (hkBase != HKEY_LOCAL_MACHINE && hkBase != HKEY_CLASSES_ROOT)
        {
            return;
        }

        pwszParentPath = keyParent->pwszPath;

        if (pwszParentPath && *pwszParentPath)
        {
            cLen += keyParent->cPathLen + 1; // Need to count the '\'
        }

        fIsRedirected = keyParent->fIsRedirected;
    }
    else if (IsPredefinedKey(hKey))
    {
        hkBase = hKey;

        if (hkBase == HKEY_CURRENT_USER)
        {
            return;
        }
    }
    else
    {
#ifdef DBG
        if (hKey == HKEY_PERFORMANCE_DATA )
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] We don't handle performance data keys");
        }
        else if (hKey == HKEY_USERS)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] We don't handle HKUS keys",
                hKey);
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError,
                "[REDIRECTKEY::REDIRECTKEY] 0x%08x is an invalid open key handle",
                hKey);
        }
#endif 
        return;
    }

    //
    // Add the length of the subkey.
    //
    if (lpSubKey)
    {
        cLenSubKey = wcslen(lpSubKey);

        if (cLenSubKey)
        {
            //
            // Make room for the '\' before the subkey.
            //
            cLen += cLenSubKey + 1;
        }
    }
    
    if (cLen < 5)
    {
        //
        // We are opening a top level key.
        //
        return;
    }

    //
    // Allocate memory for the key path.
    //
    pwszFullPath = new WCHAR [cLen + 1];

    if (!pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelError,
            "[REDIRECTKEY::REDIRECTKEY] Failed to allocate %d WCHARs for redirect path",
            cLen + 1);

        return;
    }

    ZeroMemory(pwszFullPath, sizeof(WCHAR) * (cLen + 1));

    MakePathForPredefinedKey(pwszFullPath, hkBase);

    if (keyParent)
    {
        if (pwszParentPath && *pwszParentPath)
        {
            pwszFullPath[4] = L'\\';
            wcscpy(pwszFullPath + 5, pwszParentPath);
        }
    }

    if (cLenSubKey)
    {
        wcscat(pwszFullPath, L"\\");
        wcscat(pwszFullPath, lpSubKey);
    }

    cFullPathLen = cLen;
    cPathLen = cLen - 5;
    pwszPath = pwszFullPath + 5;

    hkRedirectRoot = (hkBase == HKEY_CLASSES_ROOT ? 
                        g_hkCurrentUserClasses : 
                        g_hkRedirectRoot);
}

VOID 
CRedirectedRegistry::OPENKEY::AddSubKey(
    REDIRECTKEY* pKey,
    LPWSTR pwszFullPath,
    ENUMENTRY& entry
    )
{
    //
    // Form the full path of the subkey.
    //
    wcsncpy(pwszFullPath, pKey->pwszFullPath, pKey->cFullPathLen);
    pwszFullPath[pKey->cFullPathLen] = L'\\';
    wcscpy(pwszFullPath + pKey->cFullPathLen + 1, entry.wszName);

    //
    // Check if this key is in the deletion list. If not, we'll add it.
    //
    PLIST_ENTRY pDeletedEntry = FindDeletedKey(pwszFullPath);
    if (pDeletedEntry)
    {
        return;
    }

    DWORD cLen = wcslen(entry.wszName);
    if (cLen > cMaxSubKeyLen)
    {
        cMaxSubKeyLen = cLen;
    }

    subkeys.SetAtGrow(cSubKeys, entry);
    ++cSubKeys;
}

VOID 
CRedirectedRegistry::OPENKEY::AddValue(
    ENUMENTRY& entry
    )
{
    DWORD cLen = wcslen(entry.wszName);
    if (cLen > cMaxValueLen)
    {
        cMaxValueLen = cLen;
    }

    values.SetAtGrow(cValues, entry);
    ++cValues;
}

LONG 
CRedirectedRegistry::OPENKEY::BuildEnumList(
    REDIRECTKEY* pKey,
    BOOL fEnumKeys
    )
{
    CLUAArray<ENUMENTRY>* pHead = (fEnumKeys ? &subkeys : &values);

    PLIST_ENTRY pDeletedEntry = FindDeletedKey(pKey->pwszFullPath);
    if (pDeletedEntry)
    {
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // We allocate a big enough buffer for our subkey so we can check if 
    // it's in the deletion list.
    //
    LPWSTR pwszSubKey = new WCHAR [pKey->cFullPathLen + MAX_PATH + 1];

    if (!pwszSubKey)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(pwszSubKey, sizeof(WCHAR) * (pKey->cFullPathLen + MAX_PATH + 1));

    DWORD cMaxLen = 0;

    //
    // First find out which keys/values exist at the redirected location.
    // If we are calling this it means the key has to be redirected.
    //
    DWORD dwIndex = 0;
    DWORD i, cArraySize, cLen;
    LONG lRes;
    HKEY hKeyAlternate = 0;
    HKEY hKeyOriginal = 0;
    ENUMENTRY entry;
    entry.fIsRedirected = TRUE;
    DWORD dwSize = MAX_PATH + 1;

    //
    // First opend the key with KEY_READ access.
    //
    lRes = RegOpenKeyEx(
        pKey->hkRedirectRoot,
        pKey->pwszPath,
        0,
        KEY_READ,
        &hKeyAlternate);

    if (lRes == ERROR_SUCCESS)
    {
        while (TRUE)
        {
            if (fEnumKeys)
            {
                lRes = RegEnumKeyW(
                    hKeyAlternate,
                    dwIndex,
                    entry.wszName,
                    dwSize);
            }
            else
            {
                dwSize = MAX_PATH + 1;

                lRes = RegEnumValueW(
                    hKeyAlternate,
                    dwIndex,
                    entry.wszName,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            }

            if (lRes == ERROR_SUCCESS)
            {
                if (fEnumKeys)
                {
                    AddSubKey(pKey, pwszSubKey, entry);
                }
                else
                {
                    AddValue(entry);
                }
            }
            else if (lRes != ERROR_NO_MORE_ITEMS)
            {
                goto EXIT;
            }
            else
            {
                //
                // No more items at the redirected location. We need to look
                // at the original location now.
                //
                break;
            }

            ++dwIndex;
        }
    }

    dwIndex = 0;
    entry.fIsRedirected = FALSE;

    //
    // First opend the key with KEY_READ access.
    //
    if ((lRes = RegOpenKeyEx(
        pKey->hkBase,
        pKey->pwszPath,
        0,
        KEY_READ,
        &hKeyOriginal)) == ERROR_SUCCESS)
    {
        while (TRUE)
        {
            if (fEnumKeys)
            {
                lRes = RegEnumKeyW(
                    hKeyOriginal,
                    dwIndex,
                    entry.wszName,
                    dwSize);
            }
            else
            {
                dwSize = MAX_PATH + 1;

                lRes = RegEnumValueW(
                    hKeyOriginal,
                    dwIndex,
                    entry.wszName,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            }

            if (lRes == ERROR_SUCCESS)
            {
                //
                // Check if this key/value already exists at the redirected location.
                //
                cArraySize = (fEnumKeys ? cSubKeys : cValues);
                for (i = 0; i < cArraySize; ++i)
                {
                    if (!_wcsnicmp(entry.wszName, pHead->GetAt(i).wszName, MAX_PATH + 1))
                    {
                        break;
                    }
                }

                if (i == cArraySize)
                {
                    if (fEnumKeys)
                    {
                        AddSubKey(pKey, pwszSubKey, entry);
                    }
                    else
                    {
                        AddValue(entry);
                    }
                }
            }
            else if (lRes != ERROR_NO_MORE_ITEMS)
            {
                goto EXIT;
            }
            else
            {
                //
                // No more items at the redirected location. We need to look
                // at the original location now.
                //
                break;
            }

            ++dwIndex;
        }
    }
    else
    {
        //
        // If any other errors occured(eg, ERROR_FILE_NOT_FOUND), we just don't 
        // enum at the original location - it's still a success.
        //
        lRes = ERROR_SUCCESS;
    }

EXIT:

    if (hKeyAlternate)
    {
        RegCloseKey(hKeyAlternate);
    }

    if (hKeyOriginal)
    {
        RegCloseKey(hKeyOriginal);
    }

    if (lRes == ERROR_NO_MORE_ITEMS)
    {
        lRes = ERROR_SUCCESS;
    }

    delete [] pwszSubKey;

    return lRes;
}

LONG
CRedirectedRegistry::OPENKEY::BuildEnumLists(REDIRECTKEY* pKey)
{
    DeleteEnumLists();

    cSubKeys = 0;
    cValues = 0;
    cMaxSubKeyLen = 0;
    cMaxValueLen = 0;
    subkeys.SetSize(10);
    values.SetSize(10);

    LONG lRes;

    if ((lRes = BuildEnumList(pKey, TRUE)) == ERROR_SUCCESS)
    {
        if ((lRes = BuildEnumList(pKey, FALSE)) == ERROR_SUCCESS)
        {
            fNeedRebuild = FALSE;
        }
    }

    return lRes;
}

VOID 
CRedirectedRegistry::OPENKEY::DeleteEnumLists()
{
    subkeys.SetSize(0);
    values.SetSize(0);
}

/*++

 Function Description:
    
    When you call RegCreateKeyEx, it's supposed to tell you if the key was created
    or already existed in lpdwDisposition. Unfortunately this is not reliable - 
    it always returns REG_OPENED_EXISTING_KEY even when the key was created. 
    So we are checking the existence using RegOpenKeyEx. If we can't even read 
    a value off it, we treat it as not existing.

 Arguments:

    IN hKey - the key handle.
    IN lpSubKey - subkey to check.

 Return Value:

    TRUE - This key exists.
    FALSE - This key doesn't exist.

 History:

    03/27/2001 maonis  Created

--*/

BOOL
DoesKeyExist(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    )
{
    HKEY hkProbe;

    if (RegOpenKeyExW(
        hKey, 
        lpSubKey,
        0,
        KEY_QUERY_VALUE,
        &hkProbe) == ERROR_SUCCESS)
    {
        RegCloseKey(hkProbe);
        return TRUE;
    }

    return FALSE;
}

//
// locking stuff.
//

static BOOL g_bInitialized = FALSE;

CRITICAL_SECTION g_csRegRedirect;

class CRRegLock
{
public:
    CRRegLock()
    {
        if (!g_bInitialized)
        {
            InitializeCriticalSection(&g_csRegRedirect);
            g_bInitialized = TRUE;            
        }

        EnterCriticalSection(&g_csRegRedirect);
    }
    ~CRRegLock()
    {
        LeaveCriticalSection(&g_csRegRedirect);
    }
};

// ------------------------------------------------
// Implementation of the CRedirectedRegistry class.
// ------------------------------------------------

CRedirectedRegistry::OPENKEY* 
CRedirectedRegistry::FindOpenKey(
    HKEY hKey
    )
{
    OPENKEY* key = m_OpenKeyList;

    while (key)
    {
        if (key->hKey == hKey)
        {
            return key;
        }

        key = key->next;
    }

    return NULL;
}

BOOL 
CRedirectedRegistry::HandleDeleted(
    OPENKEY* pOpenKey
    )
{
    if (pOpenKey && pOpenKey->pwszFullPath)
    {
        if (FindDeletedKey(pOpenKey->pwszFullPath))
        {
            DPF("RedirectReg", eDbgLevelError,
                "%S (0x%08x) has been deleted",
                pOpenKey->pwszFullPath,
                pOpenKey->hKey);

            return TRUE;
        }
    }

    return FALSE;
}


// We add the key to the front of the list because the most
// recently added keys are usually used first.
LONG 
CRedirectedRegistry::AddOpenKey(
    HKEY hKey,
    REDIRECTKEY* rk,
    BOOL fIsRedirected
    )
{
    OPENKEY* key = new OPENKEY;
    if (!key)
    {
        DPF("RedirectReg", eDbgLevelError, 
            "Error allocating memory for a new OPENKEY");

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    key->hKey = hKey;
    key->hkBase = rk->hkBase;
    key->fIsRedirected = fIsRedirected;
    key->fNeedRebuild = TRUE;

    //
    // If rk->pwszPath is NULL, it means it was either one of the
    // keys we don't handle, HKCU, or a bad handle.
    // In any of those cases, we won't be needing the path anyway.
    //
    if (rk->pwszPath)
    {
        key->pwszFullPath = new WCHAR [rk->cFullPathLen + 1];

        if (key->pwszFullPath)
        {
            wcscpy(key->pwszFullPath, rk->pwszFullPath);
            key->pwszPath = key->pwszFullPath + 5;
            key->cPathLen = rk->cPathLen;
        }
        else
        {
            delete key;

            DPF("RedirectReg", eDbgLevelError, 
                "Error allocating memory for %d WCHARs",
                rk->cPathLen + 1);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    key->next = m_OpenKeyList;
    m_OpenKeyList = key;

    return ERROR_SUCCESS;
}

LONG 
CRedirectedRegistry::OpenKeyOriginalW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    if (bCreate)
    {
        return RegCreateKeyExW(
            hKey, 
            lpSubKey,
            0,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition);
    }
    else
    {
        return RegOpenKeyExW(
            hKey, 
            lpSubKey, 
            0, 
            samDesired, 
            phkResult);
    }
}

LONG 
CRedirectedRegistry::OpenKeyA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL fCreate,
    BOOL fForceRedirect
    )
{
    LPWSTR pwszSubKey = NULL; 
    LPWSTR pwszClass = NULL;

    if (lpSubKey)
    {
        if (!(pwszSubKey = AnsiToUnicode(lpSubKey)))
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::OpenKeyExA] "
                "Failed to convert lpSubKey to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpClass)
    {
        if (!(pwszClass = AnsiToUnicode(lpClass)))
        {
            delete [] pwszSubKey;
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::OpenKeyExA] "
                "Failed to convert lpClass to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    LONG lRes = OpenKeyW(
        hKey,
        pwszSubKey,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        fCreate,
        fForceRedirect);

    delete [] pwszSubKey;
    delete [] pwszClass;

    return lRes;
}

/*++

 Function Description:

    Algorithm:
    
    Only create a redirected key under 2 conditions:
    
    1. fForceRedirect is TRUE.
    or 
    2. fCreate is TRUE and the key doesn't exist at the original location.

    The reason we do this is to avoid creating extra keys that
    are not going to be cleaned up by the uninstaller. In any 
    other case we open the key with the desired access.

 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to open or create.
    IN lpClass - address of a class string.
    IN DWORD dwOptions - special options flag.
    IN samDesired - desired access.
    OUT phkResult - handle to open key if successful
    OUT lpdwDisposition - address of disposition value buffer
    IN fCreate - TRUE if it's RegCreate*; FALSE if RegOpen*.
    IN fForceRedirect - this key should be redirected.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created
    01/08/2002 maonis  Updated

--*/

LONG 
CRedirectedRegistry::OpenKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL fCreate,
    BOOL fForceRedirect
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[OpenKeyW] %s key: hKey=0x%08x; lpSubKey=%S", 
        (fCreate ? "Creating" : "Opening"),
        hKey, 
        lpSubKey);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    BOOL fIsRedirected = FALSE;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, lpSubKey);

    if (rk.pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[OpenKeyW] key path is %S", rk.pwszFullPath);

        // 
        // Find if this key has been "deleted". If so we can fail the open 
        // requests now.
        // 
        PLIST_ENTRY pDeletedEntry = FindDeletedKey(rk.pwszFullPath);
        if (pDeletedEntry && !fCreate)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[OpenKeyW] %S was already deleted, failing open call",
                rk.pwszFullPath);

            return ERROR_FILE_NOT_FOUND;
        }

        if (fCreate)
        {
            if (DoesKeyExist(rk.hkRedirectRoot, rk.pwszPath))
            {
                // If it already exists at the redirect location, we open it.
                lRes = RegCreateKeyExW(
                    rk.hkRedirectRoot, 
                    rk.pwszPath,
                    0,
                    lpClass,
                    dwOptions,
                    samDesired,
                    lpSecurityAttributes,
                    phkResult,
                    lpdwDisposition);

                fIsRedirected = TRUE;
            }
        }
        else
        {
            if ((lRes = RegOpenKeyExW(
                rk.hkRedirectRoot,
                rk.pwszPath,
                0,
                samDesired,
                phkResult)) == ERROR_SUCCESS)
            {
                fIsRedirected = TRUE;
            }
        }

        if (lRes == ERROR_FILE_NOT_FOUND)
        {
            lRes = OpenKeyOriginalW(
                rk.hkBase,
                rk.pwszPath,
                lpClass,
                dwOptions,
                samDesired,
                lpSecurityAttributes,
                phkResult,
                lpdwDisposition,
                fCreate);

            //if (fForceRedirect || (fCreate && !DoesKeyExist(rk.hkBase, rk.pwszPath)))

            {
                if (lRes == ERROR_ACCESS_DENIED)
                {
                    // Create the redirect key.
                    lRes = RegCreateKeyExW(
                        rk.hkRedirectRoot, 
                        rk.pwszPath, 
                        0,
                        NULL,
                        dwOptions,
                        samDesired,
                        NULL,
                        phkResult,
                        lpdwDisposition);

                    if (lRes == ERROR_SUCCESS)
                    {
                        fIsRedirected = TRUE;
                    }
                }
            }

            //
            // We need to remove this key from the deletion list if it was 
            // succesfully created.
            //
            if (lRes == ERROR_SUCCESS && pDeletedEntry)
            {
                DPF("RedirectReg", eDbgLevelInfo, 
                    "[CRedirectedRegistry::OpenKeyW] Removed %S "
                    "from the deletion list because we just created it",
                    rk.pwszFullPath);

                RemoveEntryList(pDeletedEntry);
            }
        }
    }
    else
    {
        lRes = OpenKeyOriginalW(
            hKey,
            lpSubKey,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition,
            fCreate);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[OpenKeyW] Successfully created key 0x%08x", *phkResult);

        if ((lRes = AddOpenKey(*phkResult, &rk, fIsRedirected)) != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError, "[OpenKeyW] Failed to add key 0x%08x", *phkResult);
        }
    }
    else
    {
        if (rk.pwszFullPath)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[OpenKeyW] Failed to %s key %S: %d", 
                (fCreate ? "Creating" : "Opening"),
                rk.pwszFullPath,
                lRes);
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[OpenKeyW] Failed to %s key: %d", 
                (fCreate ? "Creating" : "Opening"),
                lRes);
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::QueryValueOriginalW(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    fIsVersionEx
    )
{
    if (fIsVersionEx)
    {
        HKEY hSubKey;

        LONG lRes = RegOpenKeyExW(hKey, lpSubKey, 0, KEY_QUERY_VALUE, &hSubKey);

        if (lRes == ERROR_SUCCESS)
        {
            lRes = RegQueryValueExW(
                hSubKey, 
                lpValueName, 
                lpReserved,
                lpType, 
                lpData, 
                lpcbData);

            RegCloseKey(hSubKey);
        }

        return lRes;
    }
    else
    {
        if (lpType)
        {
            *lpType = REG_SZ;
        }

        return RegQueryValue(hKey, lpSubKey, (LPWSTR)lpData, (PLONG)lpcbData);
    }
}

LONG 
CRedirectedRegistry::QueryValueW(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    fIsVersionEx
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[QueryValueW] Querying value: hKey=0x%08x; lpSubKey=%S; lpValueName=%S", 
        hKey, lpSubKey, lpValueName);

    LONG lRes = ERROR_FILE_NOT_FOUND;
    OPENKEY* key = FindOpenKey(hKey);

    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, lpSubKey);

    if (rk.pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[QueryValueW] key path is %S", rk.pwszFullPath);

        HKEY hKeyRedirect = 0;

        //
        // For RegQueryValue we need to remember if the subkey exists at the
        // redirect location.
        //
        BOOL fRedirectKeyExist = FALSE;

        if (lpSubKey && *lpSubKey)
        {
            //
            // If it's from RegQueryValue we need to check if this key has been 
            // deleted; Else we should have already checked its existence when we 
            // obtained the handle.
            //
            if (FindDeletedKey(rk.pwszFullPath))
            {
                DPF("RedirectReg", eDbgLevelError, 
                    "[QueryValueW] %S was already deleted, failing query value call",
                    rk.pwszFullPath);

                return ERROR_FILE_NOT_FOUND;
            }
        }

        if ((lRes = RegOpenKeyExW(
            rk.hkRedirectRoot,
            rk.pwszPath,
            0,
            KEY_QUERY_VALUE,
            &hKeyRedirect)) == ERROR_FILE_NOT_FOUND)
        {
            goto CHECKORIGINAL;
        }
        else if (lRes != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[QueryValueW] Querying value failed: %d", lRes);

            return lRes;
        }

        fRedirectKeyExist = TRUE;

        lRes = RegQueryValueExW(
            hKeyRedirect,
            lpValueName,
            lpReserved,
            lpType,
            lpData, 
            lpcbData);

        if (hKeyRedirect)
        {
            RegCloseKey(hKeyRedirect);
        }
        
CHECKORIGINAL:

        if (lRes == ERROR_FILE_NOT_FOUND)
        {
            //
            // We'd only goto the original location if it failed with file not found.
            //            
            lRes = QueryValueOriginalW(
                rk.hkBase,
                rk.pwszPath,
                lpValueName,
                lpReserved,
                lpType,
                lpData,
                lpcbData,
                fIsVersionEx);

            if (!fIsVersionEx && (lRes != ERROR_SUCCESS) && fRedirectKeyExist)
            {
                //
                // If it is RegQueryValue we need to fix up the return values.
                //
                lRes = ERROR_SUCCESS;

                if (lpData)
                {
                    *lpData = 0;
                }

                if (lpcbData)
                {
                    //
                    // RegQueryValue only querys strings so set the length to 2 for
                    // a unicode empty string.
                    //
                    *lpcbData = 2;
                }
            }
        }
    }
    else
    {
        return QueryValueOriginalW(
            hKey,
            lpSubKey,
            lpValueName,
            lpReserved,
            lpType,
            lpData,
            lpcbData,
            fIsVersionEx);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[QueryValueW] Querying value succeeded: data is %S", (lpData ? (LPCWSTR)lpData : L""));
    }
    else
    {
        if (rk.pwszFullPath)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[QueryValueW] Querying value %S at %S failed: %d", 
                lpValueName,
                rk.pwszFullPath,
                lRes);
        }
        else
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[QueryValueW] Querying value failed: %d", lRes);
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::QueryValueA(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPCSTR  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData,
    BOOL    fIsVersionEx
    )
{
    if (lpData && !lpcbData)
    {
        return ERROR_INVALID_PARAMETER;
    }

    LPWSTR pwszSubKey = NULL;
    LPWSTR pwszValueName = NULL;
    DWORD dwSize = 0;
    DWORD dwType = 0;
    LPBYTE pbData = NULL;
    LONG lRes = ERROR_FILE_NOT_FOUND;

    //
    // App might call this without passing in the type so we just double the buffer 
    //
    if (lpcbData)
    {
        dwSize = *lpcbData * 2;
        pbData = new BYTE [dwSize];

        if (!pbData)
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::QueryValueA] Failed to allocated %d bytes",
                dwSize);

            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        pbData = NULL;
    }

    if (lpSubKey)
    {
        if (!(pwszSubKey = AnsiToUnicode(lpSubKey)))
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::QueryValueA] "
                "Failed to convert lpSubKey to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpValueName)
    {
        if (!(pwszValueName = AnsiToUnicode(lpValueName)))
        {
            delete [] pwszSubKey;
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::QueryValueA] "
                "Failed to convert lpValueName to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ((lRes = QueryValueW(
        hKey,
        pwszSubKey,
        pwszValueName,
        lpReserved,
        &dwType,
        pbData,
        &dwSize,
        fIsVersionEx)) == ERROR_SUCCESS || lRes == ERROR_MORE_DATA)
    {
        BOOL fIsString = FALSE;

        //
        // Convert the out values out.
        //
        if (dwType == REG_SZ || 
            dwType == REG_EXPAND_SZ || 
            dwType == REG_MULTI_SZ)
        {
            fIsString = TRUE;

            //
            // See how many bytes the ANSI value would take.
            //
            dwSize = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)pbData, -1, NULL, 0, NULL, NULL);
        }

        if (lpData)
        {
            if (dwSize > *lpcbData)
            {
                *lpcbData = dwSize;
                lRes = ERROR_MORE_DATA;
                goto EXIT;
            }
            else
            {
                if (fIsString)
                {
                    WideCharToMultiByte(
                        CP_ACP, 
                        0, 
                        (LPWSTR)pbData, 
                        -1, 
                        (LPSTR)lpData, 
                        *lpcbData,
                        0, 
                        0);
                }
                else
                {
                    MoveMemory(lpData, pbData, dwSize);
                }
            }
        }

        //
        // If lpData is NULL, we should return ERROR_SUCCESS while storing 
        // the required size in lpcbData.
        //
        if (pbData && lRes == ERROR_MORE_DATA && lpData)
        {
            lRes = ERROR_SUCCESS;
        }

        if (lpcbData)
        {
            *lpcbData = dwSize;
        }

        if (lpType)
        {
            *lpType = dwType;
        }
    }

EXIT:

    delete [] pwszSubKey;
    delete [] pwszValueName;
    delete [] pbData;
    
    return lRes;
}

/*++

 Function Description:

    Algorithm:
    
    We call our internal OpenKey function which will create a redirected
    key if the key doesn't exist at the original location, with the 
    KEY_SET_VALUE access. Then we can set the value there.

 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to set the default value of - this is for RegSetValue.
    IN lpValueName - value to set - this is for RegSetValueEx.
    IN Reserved - reserved.
    IN dwType - type of data.
    OUT lpData - contains the default value of the subkey if successful.
    IN cbData - size of input buffer.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::SetValueA(
    HKEY hKey, 
    LPCSTR lpSubKey,
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData,
    BOOL  fIsVersionEx
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[SetValueA] Setting value: hKey=0x%08x; lpValueName=%s; lpData=%s", hKey, lpValueName, (CHAR*)lpData);

    if (HandleDeleted(FindOpenKey(hKey)))
    {
        return ERROR_KEY_DELETED;
    }

    HKEY hSubKey;
    LONG lRes;

    //
    // First we create the subkey.
    // Note this is the only place where we call OpenKeyExA with TRUE for fForceRedirect.
    //
    if ((lRes = OpenKeyA(
        hKey, 
        (lpSubKey ? lpSubKey : ""), 
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hSubKey,
        NULL,
        TRUE,
        TRUE)) == ERROR_SUCCESS)
    {
        if (!fIsVersionEx)
        {
            //
            // If it's RegSetValue we need to calculate the correct size to pass into
            // RegSetvalueEx.
            //
            cbData = strlen((LPCSTR)lpData) + 1;
        }

        lRes = RegSetValueExA(
            hSubKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData);

        CloseKey(hSubKey);
    }

    return lRes;
}

/*++

 Function Description:

    The W version of SetValue.

 Arguments:

    IN hKey - handle to open key or HKLM etc
    IN lpSubKey - subkey to set the default value of - this is for RegSetValue.
    IN lpValueName - value to set - this is for RegSetValueEx.
    IN Reserved - reserved.
    IN dwType - type of data.
    OUT lpData - contains the default value of the subkey if successful.
    IN cbData - size of input buffer.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::SetValueW(
    HKEY hKey, 
    LPCWSTR lpSubKey,
    LPCWSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData,
    BOOL  fIsVersionEx
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[SetValueW] Setting value: hKey=0x%08x; lpValueName=%S; lpData=%S", hKey, lpValueName, (WCHAR*)lpData);

    if (HandleDeleted(FindOpenKey(hKey)))
    {
        return ERROR_KEY_DELETED;
    }

    HKEY hSubKey;
    LONG lRes;

    //
    // We create the subkey. From MSDN: "If the key specified by the lpSubKey 
    // parameter does not exist, the RegSetValue function creates it."
    // Note this is the only place where we call OpenKeyA with TRUE for fForceRedirect.
    //
    if ((lRes = OpenKeyW(
        hKey, 
        (lpSubKey ? lpSubKey : L""), 
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE,
        NULL,
        &hSubKey,
        NULL,
        TRUE,
        TRUE)) == ERROR_SUCCESS)
    {
        if (!fIsVersionEx)
        {
            //
            // If it's RegSetValue we need to calculate the correct size to pass into
            // RegSetvalueEx.
            //
            cbData = wcslen((LPCWSTR)lpData) + 1;
        }

        lRes = RegSetValueExW(
            hSubKey,
            lpValueName,
            Reserved,
            dwType,
            lpData,
            cbData);

        CloseKey(hSubKey);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[SetValueW] Setting value succeeded");
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[SetValueW] Setting value failed: %d", 
            lRes);
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumValueA] Enuming value: hKey=0x%08x; index=%d; lpValueName=%s", hKey, dwIndex, lpValueName);

    LONG lRes;
    WCHAR wszName[MAX_PATH + 1];
    DWORD dwSize = MAX_PATH + 1;

    if ((lRes = EnumValueW(
        hKey,
        dwIndex,
        wszName,
        &dwSize,
        lpReserved,
        NULL,
        NULL,
        NULL)) == ERROR_SUCCESS)
    {

        dwSize = WideCharToMultiByte(
            CP_ACP,
            0,
            wszName,
            -1,
            lpValueName,
            *lpcbValueName,
            NULL,
            NULL);

        if (dwSize)
        {
            if (!lpType || !lpData || !lpcbData)
            {
                lRes = QueryValueA(
                    hKey, 
                    NULL,
                    lpValueName,
                    NULL,
                    lpType,
                    lpData,
                    lpcbData,
                    TRUE);
            }
        }
        else
        {
            DWORD dwLastError = GetLastError();

            if (dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
                lRes = ERROR_MORE_DATA;
                *lpcbValueName = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    wszName,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            }
            else
            {
                lRes = dwLastError;
            }
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumValueW] Enuming value: hKey=0x%08x; index=%d", hKey, dwIndex);

    LONG lRes = ERROR_SUCCESS;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, NULL);

    if (rk.pwszFullPath && lpValueName && lpcbValueName && ShouldCheckEnumAlternate(hKey, &rk))
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumValueW] key path is %S", rk.pwszFullPath);

        if (key->fNeedRebuild)
        {
            if ((lRes = key->BuildEnumLists(&rk)) != ERROR_SUCCESS)
            {
                DPF("RedirectReg", eDbgLevelError,
                    "[EnumValueW] Failed to build the enum list: %d", lRes);
                return lRes;
            }
        }

        if (dwIndex >= key->cValues)
        {
            DPF("RedirectReg", eDbgLevelInfo, 
                "[EnumValueW] asked to enum value %d when there are only %d values total", 
                dwIndex, 
                key->cValues);

            return ERROR_NO_MORE_ITEMS;
        }

        ENUMENTRY entry = key->values[dwIndex];
        DWORD cValueLen = wcslen(entry.wszName);
        if (*lpcbValueName > cValueLen)
        {
            wcscpy(lpValueName, entry.wszName);
            *lpcbValueName = cValueLen;

            if (!lpType || !lpData || !lpcbData)
            {
                lRes = QueryValueW(
                    hKey, 
                    NULL,
                    entry.wszName,
                    NULL,
                    lpType,
                    lpData,
                    lpcbData,
                    TRUE);
            }
        }
        else
        {
            lRes = ERROR_MORE_DATA;
        }
    }
    else
    {
        lRes = RegEnumValueW(
            hKey,
            dwIndex,
            lpValueName,
            lpcbValueName,
            lpReserved,
            lpType,
            lpData,
            lpcbData);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumValueW] enum value succeeded: value %d is %S",
            dwIndex,
            lpValueName);
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[EnumValueW] enum value failed: %d",
            lRes);
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumKeyA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumKeyA] Enuming key: hKey=0x%08x; index=%d", hKey, dwIndex);

    WCHAR wszName[MAX_PATH + 1];
    DWORD dwName = MAX_PATH + 1;

    LONG lRes = EnumKeyW(
        hKey,
        dwIndex,
        wszName,
        &dwName,
        lpReserved,
        NULL,
        NULL,
        lpftLastWriteTime);

    if (lRes == ERROR_SUCCESS && lpName)
    {
        //
        // If lpName is not NULL then lpcbName must not be NULL or it wouldn't
        // have returned ERROR_SUCCESS.
        //
        // The behavior of RegEnumKeyEx is if *lpcbName is not big enough, it  
        // always returns ERROR_MORE_DATA and *lpcbName is unchanged. So first
        // we get the required bytes for the ansi string.
        //
        DWORD dwByte = WideCharToMultiByte(
            CP_ACP, 
            0, 
            wszName, 
            dwName, 
            NULL, 
            0, 
            0, 
            0);

        if (!dwByte)
        {
            //
            // Failed to convert.
            //
            DPF("RedirectFS", eDbgLevelError,
                "[EnumKeyA] Failed to get the required length for the ansi "
                "string: %d",
                GetLastError());

            lRes = GetLastError();

        } 
        else if (*lpcbName < (dwByte + 1)) // dwByte doesn't include terminating NULL.
        {
            lRes = ERROR_MORE_DATA;
        } 
        else
        {
            //
            // We have a big enough buffer. We can convert now.
            //
            if (WideCharToMultiByte(
                CP_ACP, 
                0, 
                wszName, 
                dwName, 
                lpName, 
                *lpcbName, 
                0, 
                0))
            {
                lpName[dwByte] = '\0';
                *lpcbName = dwByte;
            }
            else
            {
                lRes = GetLastError();

                if (lRes == ERROR_INSUFFICIENT_BUFFER)
                {
                    lRes = ERROR_MORE_DATA;
                }
            }
        }
    }

    return lRes;
}

LONG 
CRedirectedRegistry::EnumKeyW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[EnumKeyW] Enuming key: hKey=0x%08x; index=%d", hKey, dwIndex);

    LONG lRes = ERROR_SUCCESS;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, NULL);

    if (rk.pwszFullPath && lpName && lpcbName && ShouldCheckEnumAlternate(hKey, &rk))
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumKeyW] key path is %S", 
            rk.pwszFullPath);

        if (key->fNeedRebuild)
        {
            if ((lRes = key->BuildEnumLists(&rk)) != ERROR_SUCCESS)
            {
                DPF("RedirectReg", eDbgLevelError,
                    "[EnumKeyW] Failed to build the enum list: %d", lRes);
                return lRes;
            }
        }

        if (dwIndex >= key->cSubKeys)
        {
            DPF("RedirectReg", eDbgLevelInfo, 
                "[EnumKeyW] asked to enum key %d when there are only %d keys total", 
                dwIndex, 
                key->cSubKeys);

            return ERROR_NO_MORE_ITEMS;
        }

        ENUMENTRY entry = key->subkeys[dwIndex];
        DWORD cSubKeyLen = wcslen(entry.wszName);
        if (*lpcbName > cSubKeyLen)
        {
            wcscpy(lpName, entry.wszName);
            *lpcbName = cSubKeyLen;

            //
            // TODO: We are not returning info for the last 3rd parameters.....
            //
        }
        else
        {
            lRes = ERROR_MORE_DATA;
        }
    }
    else
    {
        lRes = RegEnumKeyExW(
            hKey,
            dwIndex,
            lpName,
            lpcbName,
            lpReserved,
            lpClass,
            lpcbClass,
            lpftLastWriteTime);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[EnumKeyW] enum key succeeded: key %d is %S",
            dwIndex,
            lpName);
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[EnumKeyW] enum key failed: %d",
            lRes);
    }

    return lRes;
}

/*++

 Function Description:

    Close the key and remove it from the list.
    
 Arguments:

    IN hKey - handle to close

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::CloseKey(
    HKEY hKey
    )
{
    OPENKEY* key = m_OpenKeyList;
    OPENKEY* last = NULL;

    //
    // NOTE! We don't check if this handle corresponds to a deleted key -
    // RegCloseKey return ERROR_SUCCESS in that case.
    //
    while (key)
    {
        if (key->hKey == hKey)
        {
            if (last)
            {
                last->next = key->next; 
            }
            else
            {
                m_OpenKeyList = key->next;
            }

            delete key;
            break;
        }

        last = key;
        key = key->next;
    }

    DPF("RedirectReg", eDbgLevelInfo, "[CloseKey] closing key 0x%08x", hKey);

    return RegCloseKey(hKey);
}

/*++

 Function Description:

    Delete a key.
    
 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to close.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::DeleteKeyA(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{
    LPWSTR pwszSubKey = NULL;

    if (lpSubKey)
    {
        if (!(pwszSubKey = AnsiToUnicode(lpSubKey)))
        {
            DPF("RedirectReg", eDbgLevelError, 
                "[CRedirectedRegistry::DeleteKeyA] "
                "Failed to convert lpSubKey to unicode");
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    LONG lRes = DeleteKeyW(hKey, pwszSubKey);

    delete [] pwszSubKey;

    return lRes;
}

BOOL 
CRedirectedRegistry::HasSubkeys(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    //
    // First open the key.
    //
    LONG lRes;
    HKEY hSubKey;
    DWORD cSubKeys;

    //
    // Even though we only need the number of subkeys, we can't only pass in
    // KEY_ENUMERATE_SUB_KEYS or RegQueryInfoKey will get access denied.
    //
    if ((lRes = RegOpenKeyExW(hKey, lpSubKey, 0, KEY_READ, &hSubKey))
        != ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelError,
            "[HasSubkeys] Failed to open the subkey: %d",
            lRes);

        return FALSE;
    }

    if ((lRes = QueryInfoKey(
        hSubKey, 
        NULL,
        &cSubKeys,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        TRUE)) != ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelError,
            "[HasSubkeys] Query key info failed: %d",
            lRes);

        return FALSE;
    }

    return (cSubKeys != 0);
}

/*++

 Function Description:

    The W version of DeleteKey.

    We keep an in-memory list of keys being deleted. This method adds the key
    to this list if the RegDeleteKey call succeeds.
    
 Arguments:

    IN hKey - key handle.
    IN lpSubKey - subkey to close.

 Return Value:

    Error code or ERROR_SUCCESS

 History:

    02/16/2001 maonis  Created

--*/

LONG 
CRedirectedRegistry::DeleteKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[DeleteKeyW] Deleting key: hKey=0x%08x; lpSubKey=%S", hKey, lpSubKey);

    if (lpSubKey == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, lpSubKey);

    LONG lRes = RegDeleteKeyW(hKey, lpSubKey);

    if (key)
    {
        key->fNeedRebuild = TRUE;
    }

    if (rk.pwszFullPath)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[DeleteKeyW] key path is %S",
            rk.pwszFullPath);

        if (lRes == ERROR_ACCESS_DENIED && HasSubkeys(hKey, lpSubKey))
        {
            //
            // RegDeleteKey returns access denied if the key has subkeys. If that's the case
            // we should return now.
            //
            DPF("RedirectReg", eDbgLevelInfo, 
                "[DeleteKeyW] the key has subkeys so return now");

            return lRes;
        }

        if (rk.fIsRedirected)
        {
            //
            // If the key was redirected, we need to check the original location.
            //
            lRes = RegDeleteKeyW(rk.hkBase, rk.pwszPath);
        }
        else
        {
            //
            // If the key was not redirected, we need to check the redirect location.
            // We should be able to delete it if it exists so I am not checking the 
            // return value here.
            //
            LONG lResTemp = RegDeleteKeyW(rk.hkRedirectRoot, rk.pwszPath);

            if (lResTemp == ERROR_SUCCESS && lRes == ERROR_FILE_NOT_FOUND)
            {
                //
                // If the key only existed at the redirected location, now since we deleted
                // it there, we can set the return value to success.
                //
                lRes = ERROR_SUCCESS;
            }
            else if (lResTemp == ERROR_ACCESS_DENIED)
            {
                //
                // If we get here, it means this key has subkeys, we should just return.
                //
                DPF("RedirectReg", eDbgLevelInfo, 
                    "[DeleteKeyW] the redirected key has subkeys so return now");

                return lResTemp;
            }
        }
    
        if (lRes == ERROR_ACCESS_DENIED)
        {
            //
            // We only add the path to the deletion list if we get access
            // denied.
            //
            lRes = AddDeletedKey(rk.pwszFullPath);
        }    
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[DeleteKeyW] delete key succeeded");
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError, 
            "[DeleteKeyW] delete key failed: %d", lRes);
    }

    return lRes;
}

LONG 
CRedirectedRegistry::QueryInfoKey(
    HKEY hKey,               
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    BOOL    fIsW // Do you want the W or the A version?
    )
{
    DPF("RedirectReg", eDbgLevelInfo, 
        "[QueryInfoKey] Querying key info: hKey=0x%08x", hKey);

    LONG lRes;
    DWORD i;
    OPENKEY* key = FindOpenKey(hKey);
    if (HandleDeleted(key))
    {
        return ERROR_KEY_DELETED;
    }

    REDIRECTKEY rk(key, hKey, NULL);
    DWORD dwMaxValueLen = 0;

    if (rk.pwszFullPath && ShouldCheckEnumAlternate(hKey, &rk))
    {
        DPF("RedirectReg", eDbgLevelInfo, 
            "[QueryInfoKey] key path is %S",
            rk.pwszFullPath);

        if ((lRes = key->BuildEnumLists(&rk)) != ERROR_SUCCESS)
        {
            DPF("RedirectReg", eDbgLevelError,
                "[QueryInfoKeyW] Failed to build the enum list: %d", lRes);

            return lRes;
        }

        if (lpcSubKeys)
        {
            *lpcSubKeys = key->cSubKeys;
        }

        if (lpcbMaxSubKeyLen)
        {
            *lpcbMaxSubKeyLen = key->cMaxSubKeyLen;
        }

        if (lpcValues)
        {
            *lpcValues = key->cValues;
        }

        if (lpcbMaxValueNameLen)
        {
            *lpcbMaxValueNameLen = key->cMaxValueLen;
        }

        if (lpcbMaxValueLen)
        {
            for (i = 0; i < key->cValues; ++i)
            {
                DWORD dwData;

                if (fIsW)
                {
                    lRes = QueryValueW(
                        hKey, 
                        NULL,
                        key->values[i].wszName,
                        NULL,
                        NULL,
                        NULL,
                        &dwData,
                        TRUE);
                }
                else
                {
                    LPSTR pszValueName = UnicodeToAnsi(key->values[i].wszName);

                    if (pszValueName)
                    {
                        lRes = QueryValueA(
                            hKey, 
                            NULL,
                            pszValueName,
                            NULL,
                            NULL,
                            NULL,
                            &dwData,
                            TRUE);

                        delete [] pszValueName;
                    }
                    else
                    {
                        DPF("RedirectReg", eDbgLevelError,
                            "[QueryInfoKey] Failed to convert %S to ansi",
                            key->values[i].wszName);

                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                }

                if (lRes == ERROR_SUCCESS)
                {
                    dwMaxValueLen = max(dwMaxValueLen, dwData);
                }
                else
                {
                    DPF("RedirectReg", eDbgLevelError, 
                        "[QueryInfoW] failed to query the data length for value %S: %d",
                        key->values[i].wszName,
                        lRes);
                    return lRes;
                }
            }
        }

        //
        // TODO: we are not returning info for those other parameters....
        //
    }
    else
    {
        lRes = RegQueryInfoKeyW(
            hKey,
            NULL,
            NULL,
            lpReserved,
            lpcSubKeys,
            lpcbMaxSubKeyLen,
            lpcbMaxClassLen, 
            lpcValues,
            lpcbMaxValueNameLen,
            lpcbMaxValueLen,
            NULL,
            NULL);
    }

    if (lRes == ERROR_SUCCESS)
    {
        DPF("RedirectReg", eDbgLevelInfo,
            "[QueryInfoKeyW] succeeded");

        if (lpcSubKeys)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] # of subkeys is %d",
                *lpcSubKeys);
        }

        if (lpcbMaxSubKeyLen)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] max len of subkeys is %d",
                *lpcbMaxSubKeyLen);
        }

        if (lpcValues)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] # of values is %d",
                *lpcValues);
        }

        if (lpcbMaxValueNameLen)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] max len of value names is %d",
                *lpcbMaxValueNameLen);
        }

        if (lpcbMaxValueLen)
        {
            DPF("RedirectReg", eDbgLevelInfo,
                "[QueryInfoKeyW] max len of values is %d",
                *lpcbMaxValueLen);
        }
    }
    else
    {
        DPF("RedirectReg", eDbgLevelError,
            "[QueryInfoKeyW] failed %d", 
            lRes);
    }

    return lRes;
}

CRedirectedRegistry RRegistry;

//
// Exported APIs.
//

LONG 
LuaRegOpenKeyA(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegOpenKeyW(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegOpenKeyExA(
    HKEY hKey,         
    LPCSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        samDesired, 
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegOpenKeyExW(
    HKEY hKey,         
    LPCWSTR lpSubKey,  
    DWORD ulOptions,   
    REGSAM samDesired, 
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0, 
        REG_OPTION_NON_VOLATILE,
        samDesired, 
        NULL,
        phkResult,
        NULL,
        FALSE,
        FALSE);
}

LONG 
LuaRegCreateKeyA(
    HKEY hKey,         
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey, 
        0,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult, 
        NULL,
        TRUE,
        FALSE);
}

LONG 
LuaRegCreateKeyW(
    HKEY hKey,         
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey, 
        0,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phkResult, 
        NULL,
        TRUE,
        FALSE);
}

LONG 
LuaRegCreateKeyExA(
    HKEY hKey,                
    LPCSTR lpSubKey,         
    DWORD Reserved,           
    LPSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyA(
        hKey, 
        lpSubKey,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE,
        FALSE);
}

LONG 
LuaRegCreateKeyExW(
    HKEY hKey,                
    LPCWSTR lpSubKey,         
    DWORD Reserved,           
    LPWSTR lpClass,           
    DWORD dwOptions,          
    REGSAM samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,          
    LPDWORD lpdwDisposition   
    )
{
    CRRegLock Lock;

    return RRegistry.OpenKeyW(
        hKey, 
        lpSubKey,
        lpClass, 
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult, 
        lpdwDisposition,
        TRUE,
        FALSE);
}

LONG 
LuaRegQueryValueA(
    HKEY   hKey,
    LPCSTR lpSubKey,
    LPSTR  lpValue,
    PLONG  lpcbValue
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueA(
        hKey,
        lpSubKey,
        NULL, // value name
        NULL, // reserved
        NULL, // type
        (LPBYTE)lpValue,
        (LPDWORD)lpcbValue,
        FALSE);
}

LONG 
LuaRegQueryValueW(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPWSTR  lpValue,
    PLONG lpcbValue
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueW(
        hKey,
        lpSubKey,
        NULL, // value name
        NULL, // reserved
        NULL, // type
        (LPBYTE)lpValue,
        (LPDWORD)lpcbValue,
        FALSE);
}

LONG 
LuaRegQueryValueExA(
    HKEY    hKey,
    LPCSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueA(
        hKey,
        NULL, // subkey
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData,
        TRUE);
}

LONG 
LuaRegQueryValueExW(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.QueryValueW(
        hKey,
        NULL, // subkey
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData,
        TRUE);
}

LONG      
LuaRegSetValueA(
    HKEY hKey, 
    LPCSTR lpSubKey, 
    DWORD dwType, 
    LPCSTR lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueA(
        hKey,
        lpSubKey,
        "",
        0,
        dwType,
        (CONST BYTE*)lpData,
        cbData,
        FALSE);
}

LONG      
LuaRegSetValueW(
    HKEY hKey, 
    LPCWSTR lpSubKey, 
    DWORD dwType, 
    LPCWSTR lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueW(
        hKey,
        lpSubKey,
        L"",
        0,
        dwType,
        (CONST BYTE*)lpData,
        cbData,
        FALSE);
}

LONG      
LuaRegSetValueExA(
    HKEY hKey, 
    LPCSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueA(
        hKey,
        NULL,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData,
        TRUE);
}

LONG      
LuaRegSetValueExW(
    HKEY hKey, 
    LPCTSTR lpValueName, 
    DWORD Reserved, 
    DWORD dwType, 
    CONST BYTE * lpData, 
    DWORD cbData
    )
{
    CRRegLock Lock;

    return RRegistry.SetValueW(
        hKey,
        NULL,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData,
        TRUE);
}

LONG 
LuaRegEnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.EnumValueA(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
LuaRegEnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CRRegLock Lock;

    return RRegistry.EnumValueW(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,      
        lpcbData);
}

LONG 
LuaRegEnumKeyA(
    HKEY hKey,     
    DWORD dwIndex, 
    LPSTR lpName, 
    DWORD cbName  
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyA(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL); 
}

LONG 
LuaRegEnumKeyW(
    HKEY hKey,     
    DWORD dwIndex, 
    LPWSTR lpName, 
    DWORD cbName  
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG 
LuaRegEnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyA(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
LuaRegEnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime 
    )
{
    CRRegLock Lock;

    return RRegistry.EnumKeyW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG 
LuaRegCloseKey(HKEY hKey)
{
    CRRegLock Lock;

    return RRegistry.CloseKey(hKey);
}

LONG      
LuaRegDeleteKeyA(
    HKEY hKey, 
    LPCSTR lpSubKey
    )
{
    CRRegLock Lock;

    return RRegistry.DeleteKeyA(hKey, lpSubKey);
}

LONG      
LuaRegDeleteKeyW(
    HKEY hKey, 
    LPCWSTR lpSubKey
    )
{
    CRRegLock Lock;

    return RRegistry.DeleteKeyW(hKey, lpSubKey);
}

LONG 
LuaRegQueryInfoKeyW(
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
{
    CRRegLock Lock;

    return RRegistry.QueryInfoKey(
        hKey,
        lpReserved, 
        lpcSubKeys,
        lpcbMaxSubKeyLen,
        lpcbMaxClassLen, 
        lpcValues,  
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        TRUE);
}

LONG 
LuaRegQueryInfoKeyA(
    HKEY hKey,                
    LPSTR lpClass,           
    LPDWORD lpcbClass,        
    LPDWORD lpReserved,       
    LPDWORD lpcSubKeys,       
    LPDWORD lpcbMaxSubKeyLen, 
    LPDWORD lpcbMaxClassLen,  
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,  
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime   
    )
{
    CRRegLock Lock;

    return RRegistry.QueryInfoKey(
        hKey,
        lpReserved,       
        lpcSubKeys,       
        lpcbMaxSubKeyLen, 
        lpcbMaxClassLen,  
        lpcValues,        
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        FALSE);
}

BOOL
LuaRegInit()
{
    RRegistry.Init();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\redirectreg.h ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LUA_RedirectReg.h

 Notes:

    This is a general purpose shim.

 History:

    02/14/2001 maonis  Created

--*/

#ifndef _LUA_REDIRECT_REG_H_
#define _LUA_REDIRECT_REG_H_

BOOL
DoesKeyExist(
    IN HKEY hKey,
    IN LPCWSTR lpSubKey
    );

struct DELETEDKEY
{
    LIST_ENTRY entry;

    // This is something like HKLM\Software\Company\Key.
    LPWSTR pwszPath;
    DWORD cLen;
};

PLIST_ENTRY FindDeletedKey(
    LPCWSTR pwszPath,
    BOOL* pfIsSubKey = NULL
    );

//
// Check if the path exists in the deletion list, if not, add it to
// the beginning of the list.
//
LONG AddDeletedKey(
    LPCWSTR pwszPath
    );

extern LIST_ENTRY g_DeletedKeyList; 

//
// The reg class that does all the real work.
//

class CRedirectedRegistry
{
public:

    VOID Init()
    {
        InitializeListHead(&g_DeletedKeyList);
    }

    //
    // (The explanation of the merged view of HKCR in MSDN is very wrong - 
    // see NT #507506)
    // As a limited user, you'll always get access denied if you try to 
    // create a key under HKCR even when its immediate parent exists in HKCU.
    // You can, however, create or modify values in HKCR which will be reflected
    // in HKCU\Software\Classes, not HKLM\Softeware\Classes.
    //
    LONG OpenKeyA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL fCreate,
        BOOL fForceRedirect = FALSE
        );

    LONG OpenKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL fCreate,
        BOOL fForceRedirect = FALSE
        );

    //
    // RegQueryValue and RegQueryValueEx can and should share the same
    // method because we can use RegQueryValueEx to find out if a value
    // has never been set or has been specifically set to an empty string.
    //
    // RegQueryValue can't tell the difference between the former and the 
    // latter - it will return ERROR_SUCCESS in both cases and set the value
    // to an empty sring.
    //
    // On the other hand, RegQueryValueEx returns ERROR_FILE_NOT_FOUND 
    // if the default value has never been set. 
    //
    // We should always use RegQueryValueEx so we know if we should look at 
    // the original location.
    //
    // For RegQueryValue we also need to open the subkey with KEY_QUERY_VALUE
    // if it's not NULL or an empty string.
    //
    LONG 
    QueryValueW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData,
        BOOL    fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    LONG 
    QueryValueA(
        HKEY    hKey,
        LPCSTR  lpSubKey,
        LPCSTR  lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData,
        BOOL    fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    //
    // RegSetValue and RegSetValueEx also share the same implementation but
    // we have to do something special for RegSetValue:
    // 1) ignore the cbData and pass in the string length including terminating
    //    NULL (note that RegQueryValue doesn't have the same behavior).
    // 2) create/open the subkey with KEY_SET_VALUE if it's not NULL or an 
    //    empty string.
    //
    LONG SetValueA(
        HKEY hKey, 
        LPCSTR lpSubKey,
        LPCSTR lpValueName, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE * lpData, 
        DWORD cbData,
        BOOL fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    LONG SetValueW(
        HKEY hKey, 
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName, 
        DWORD Reserved, 
        DWORD dwType, 
        CONST BYTE * lpData, 
        DWORD cbData,
        BOOL fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    //
    // Notes of enum API hooks:
    //
    // We need to enum at the redirected location first then enum the keys/values
    // at the original location that don't exist at the redirected location *unless*:
    //
    // 1) It's not redirected (HKCU keys are not redirected for example);
    // 2) It's a predefined key, in which case we won't find it in the openkey list;
    //
    // Note we also merge the HKCR keys by ourselves so we can check if the key is 
    // in the deletion list.
    //

    LONG EnumValueA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumValueW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumKeyA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime 
        );

    LONG EnumKeyW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime 
        );

    LONG CloseKey(
        HKEY hKey
        );

    //
    // Notes of delete key:
    //
    // We only add the key to the deletion list if we get access denied. If we get,
    // file not found, we don't need to add because as an admin it won't succeed 
    // anyway.
    // 
    // HKCR keys are a special case. The only case that I've seen is with Corel 
    // draw 10 where it enums a key, then deletes it. So the first time it'll delete
    // the key in HKCU, the 2nd time it'll try to delete the one in HKLM - and we'll
    // add it to the deletion list. So next time enum won't include it.
    // 

    LONG DeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey
        );

    LONG DeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

    LONG QueryInfoKey(
        HKEY hKey,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        BOOL    fIsW // Do you want the W or the A version?
        );

private:

    struct ENUMENTRY
    {
        WCHAR wszName[MAX_PATH + 1];
        BOOL fIsRedirected;
    };

    struct REDIRECTKEY;
    struct OPENKEY
    {
        OPENKEY *next;
        
        HKEY hKey;
        HKEY hkBase;

        // Was this key redirected?
        BOOL fIsRedirected;

        LPWSTR pwszFullPath;

        // This is the same as pwszPath in REDIRECTKEY
        LPWSTR pwszPath;
        DWORD cPathLen;

        CLUAArray<ENUMENTRY> subkeys;
        CLUAArray<ENUMENTRY> values;
        DWORD cMaxSubKeyLen;
        DWORD cMaxValueLen;
        DWORD cSubKeys;
        DWORD cValues;
        BOOL fNeedRebuild;

        LONG BuildEnumLists(REDIRECTKEY* pKey);

        //
        // From MSDN:
        //
        // "While an application is using the RegEnumKey function, it should not 
        // make calls to any registration functions that might change the key 
        // being queried."
        //
        // Nonetheless, some apps do. So if we detect a key/value change we 
        // delete the enum list so it gets rebuilt next time.
        // 
        // The more efficient way would be to only change keys/values that get
        // modified but it adds very much complexity to the code - you could
        // create multiple keys at a time by one RegCreateKey call if the 
        // intermediate keys don't exist - we'd have to check things like that.
        // 
        VOID DeleteEnumLists();

    private:

        VOID AddSubKey(
            REDIRECTKEY* pKey,
            LPWSTR pwszFullPath,
            ENUMENTRY& entry
            );

        VOID AddValue(
            ENUMENTRY& entry
            );

        LONG BuildEnumList(
            REDIRECTKEY* pKey,
            BOOL fEnumKeys
            );
    };

    struct REDIRECTKEY
    {
        REDIRECTKEY(
            OPENKEY* keyParent,
            HKEY hKey,
            LPCWSTR lpSubKey);

        ~REDIRECTKEY()
        {
            delete [] pwszFullPath;
            pwszPath = NULL;
            pwszFullPath = NULL;
            hkBase = NULL;
            fIsRedirected = FALSE;
            hkRedirectRoot = 0;
        }

        //
        // This is something like HKLM\Software\Company\KeyNeedRedirect or
        // HKCR\appid\something.
        // When we add the key to the deletion list, we use this path.
        //
        LPWSTR pwszFullPath;
        DWORD cFullPathLen; // Doesn't include the terminating NULL.

        //
        // For classes root keys this is g_hkCurrentUserClasses; for other keys 
        // this is g_hkRedirectRoot.
        // 
        HKEY hkRedirectRoot;

        //
        // This is the path without the top level key. So it's like
        // Software\Company\KeyNeedRedirect. 
        // When we want to create a key, we use this path. eg, creating the key
        // at the redirected location.
        //
        LPWSTR pwszPath;
        DWORD cPathLen; // Doesn't include the terminating NULL.

        HKEY hkBase;

        BOOL fIsRedirected;
    };

    OPENKEY* FindOpenKey(
        HKEY hKey
        );

    BOOL HandleDeleted(
        OPENKEY* pOpenKey
        );

    LONG AddOpenKey(
        HKEY hKey,
        REDIRECTKEY* rk,
        BOOL fIsRedirected
        );

    LONG OpenKeyOriginalW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG QueryValueOriginalW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData,
        BOOL    fIsVersionEx // Is this a RegQueryValue or RegQueryValueEx?
        );

    LONG DeleteLMCRKeyNotRedirected(
        REDIRECTKEY* pKey
        );

    BOOL HasSubkeys(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

    BOOL
    ShouldCheckEnumAlternate(
        HKEY hKey,
        REDIRECTKEY* pKey
        )
    {
        return ((!IsPredefinedKey(hKey)) || (pKey && pKey->fIsRedirected));
    }

    OPENKEY* m_OpenKeyList;
};

#endif // _LUA_REDIRECT_REG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\utils.inl ===
//
// CLUAArray implementation.
//
template <typename TYPE>
CLUAArray<TYPE>::CLUAArray() 
: 
m_cElements(0),
m_cMax(0),
m_pData(NULL)
{
}

template <typename TYPE>
CLUAArray<TYPE>::~CLUAArray()
{
    SetSize(0);
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::GetSize() const
{
    return m_cElements;
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::GetAllocSize() const
{
    return m_cMax;
}

template <typename TYPE>
bool CLUAArray<TYPE>::IsEmpty() const
{
    return (m_cElements ? false : true);
}

template <typename TYPE>
VOID CLUAArray<TYPE>::SetSize(DWORD iNewSize)
{
    ASSERT(iNewSize >= 0, "Size cannot be negative");

    if (iNewSize)
    {
        if (m_pData)
        {
            // we already allocated enough space.
            if (iNewSize <= m_cMax)
            {
                if (iNewSize < m_cElements)
                {
                    DestructElements(m_pData + iNewSize, m_cElements - iNewSize);
                }
                else
                {
                    ConstructElements(m_pData + m_cElements, iNewSize - m_cElements);
                }

                m_cElements = iNewSize;
            }
            else // we don't have enough space.
            {
                // we allocate double of the requested size.
                m_cMax = iNewSize * 2;
                TYPE* pNewData = (TYPE*) new BYTE [m_cMax * sizeof(TYPE)];
                memcpy(pNewData, m_pData, m_cElements * sizeof(TYPE));

                ConstructElements(pNewData + m_cElements, iNewSize - m_cElements);

                delete [] (BYTE*)m_pData;
                m_pData = pNewData;

                m_cElements = iNewSize;
            }
        }
        else // it's an empty array, we need to allocate spaces for iNewSize elements.
        {
            m_pData = (TYPE*) new BYTE [iNewSize * sizeof(TYPE)];
            ConstructElements(m_pData, iNewSize);
            m_cElements = m_cMax = iNewSize;
        }
    }
    else // if it's 0, we should destroy all the Elements in the array.
    {
        if (m_pData)
        {
            DestructElements(m_pData, m_cElements);
            delete [] (BYTE*)m_pData;
            m_pData = NULL;
        }

        m_cElements = 0;
    }
}

template <typename TYPE>
VOID CLUAArray<TYPE>::SetAtGrow(DWORD iIndex, TYPE newElement)
{
    ASSERT(iIndex >= 0, "Index cannot be negative");

    if (iIndex >= m_cElements)
    {
        SetSize(iIndex + 1);
    }

    m_pData[iIndex] = newElement;
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::Add(TYPE newElement)
{
    SetAtGrow(m_cElements, newElement);

    return m_cElements;
}

template <typename TYPE>
DWORD CLUAArray<TYPE>::Append(const CLUAArray& src)
{
    ASSERT(this != &src, "Cannot append to itself");

    DWORD nOldSize = m_cElements;
    SetSize(m_cElements + src.m_cElements);
    CopyElements(m_pData + nOldSize, src.m_pData, src.m_cElements);
    return nOldSize;
}

template <typename TYPE>
VOID CLUAArray<TYPE>::Copy(const CLUAArray& src)
{
    ASSERT(this != &src, "Cannot copy to itself");

    SetSize(src.m_cElements);
    CopyElements(m_pData, src.m_pData, src.m_cElements);
}

template <typename TYPE>
VOID CLUAArray<TYPE>::RemoveAt(DWORD iIndex, DWORD nCount)
{
    ASSERT(iIndex >= 0, "Index cannot be negative");
    ASSERT(nCount >= 0, "Count cannot be negative");
    ASSERT(iIndex + nCount <= m_nSize, "Requested to remove too many items");

    // just remove a range
    int nMoveCount = m_nSize - (iIndex + nCount);

    if (nMoveCount)
    {
        memcpy(&m_pData[iIndex], &m_pData[iIndex + nCount],
            nMoveCount * sizeof(BYTE));
    }

    m_nSize -= nCount;
}

template <typename TYPE>
const TYPE& CLUAArray<TYPE>::operator[](DWORD iIndex) const
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex];
}

template <typename TYPE>
TYPE& CLUAArray<TYPE>::operator[](DWORD iIndex)
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex]; 
}

template <typename TYPE>
const TYPE& CLUAArray<TYPE>::GetAt(DWORD iIndex) const
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex];
}

template <typename TYPE>
TYPE& CLUAArray<TYPE>::GetAt(DWORD iIndex)
{
    ASSERT(iIndex >= 0 && iIndex < m_cElements, "Index out of bound");

    return m_pData[iIndex]; 
}

template <typename TYPE>
VOID CLUAArray<TYPE>::DestructElements(TYPE* pElements, DWORD nCount)
{
    for (; nCount--; pElements++)
    {
        pElements->~TYPE();
    }
}

//
// define placement new and delete.
//
inline void *__cdecl operator new(size_t, void *P)
{
    return (P);
}

inline void __cdecl operator delete(void *, void *)
{
    return; 
}

template <typename TYPE>
VOID CLUAArray<TYPE>::ConstructElements(TYPE* pElements, DWORD nCount)
{
    // we zero memory first here.
    memset(pElements, 0, nCount * sizeof(TYPE));

    for (; nCount--; pElements++)
    {
        new (pElements) TYPE;
    }
}

template <typename TYPE>
VOID CLUAArray<TYPE>::CopyElements(TYPE* pDest, const TYPE* pSrc, DWORD nCount)
{
    while (nCount--)
    {
        *pDest++ = *pSrc++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\utils.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LUA_RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   02/12/2001 maonis

 Modified:


--*/
#ifndef _LUA_UTILS_H_
#define _LUA_UTILS_H_

//
// Preserve the last error of the original API call.
//
#define LUA_GET_API_ERROR DWORD LUA_LAST_ERROR = GetLastError()
#define LUA_SET_API_ERROR SetLastError(LUA_LAST_ERROR)

//
// Long file names need this prefix.
//
#define FILE_NAME_PREFIX L"\\\\?\\"
// length doesn't include the terminating NULL.
#define FILE_NAME_PREFIX_LEN (sizeof(FILE_NAME_PREFIX) / sizeof(WCHAR) - 1)

//----------------
// Dynamic array.
//----------------
template <typename TYPE>
class CLUAArray
{
public:
    CLUAArray();
    ~CLUAArray();

    bool IsEmpty() const;
    DWORD GetSize() const;
    DWORD GetAllocSize() const;
    VOID SetSize(DWORD iNewSize);

    // Potentially growing the array
    VOID SetAtGrow(DWORD iIndex, TYPE newElement);
    // return the index of the new element.
    DWORD Add(TYPE newElement);
    DWORD Append(const CLUAArray& src);
    VOID RemoveAt(DWORD iIndex, DWORD nCount = 1);
    VOID Copy(const CLUAArray& src);

    const TYPE& operator[](DWORD iIndex) const;
    TYPE& operator[](DWORD iIndex);

    const TYPE& GetAt(DWORD iIndex) const;
    TYPE& GetAt(DWORD iIndex);

private:
    
    VOID DestructElements(TYPE* pElements, DWORD nCount);
    VOID ConstructElements(TYPE* pElements, DWORD nCount);
    VOID CopyElements(TYPE* pDest, const TYPE* pSrc, DWORD nCount);

    TYPE* m_pData;

    DWORD m_cElements;
    DWORD m_cMax; // the max allocated.
};

#include "utils.inl"

//
// If the file is already in the user's directory, we don't 
// redirect or track it.
//
extern WCHAR g_wszUserProfile[MAX_PATH];
extern DWORD g_cUserProfile;

//
// The PrivateProfile APIs look into the windows directory if 
// the filename doesn't contain a path.
//
extern WCHAR g_wszSystemRoot[MAX_PATH];
extern DWORD g_cSystemRoot;

BOOL 
IsUserDirectory(LPCWSTR pwszPath);

DWORD
GetSystemRootDirW();

BOOL
MakeFileNameForProfileAPIsW(LPCWSTR lpFileName, LPWSTR pwszFullPath);

//----------------------------------
// Unicode/ANSI conversion routines.
//----------------------------------

struct STRINGA2W
{
    STRINGA2W(LPCSTR psz, BOOL fCopy = TRUE)
    {
        m_pwsz = NULL;
        m_fIsOutOfMemory = FALSE;

        if (psz)
        {
            // I realize I am using strlen here but this would only allocate enough or more
            // spaces than we need. And a STRINGA2W object only lives for a very short time.
            UINT cLen = strlen(psz) + 1;

            m_pwsz = new WCHAR [cLen];
            if (m_pwsz)
            {
                if (fCopy)
                {
                    MultiByteToWideChar(CP_ACP, 0, psz, -1, m_pwsz, cLen);
                }
            }
            else
            {
                m_fIsOutOfMemory = TRUE;
            }
        }
    }

    ~STRINGA2W()
    {
        delete [] m_pwsz;
    }

    operator LPWSTR() const { return m_pwsz; }

    BOOL m_fIsOutOfMemory;

private:

    LPWSTR m_pwsz;
};

// If we need to allocate buffer for the ansi string.
inline LPSTR 
UnicodeToAnsi(LPCWSTR pwsz)
{
    LPSTR psz = NULL;

    if (pwsz)
    {
        // Taking DBCS into consideration.
        UINT cLen = wcslen(pwsz) * 2 + 1;

        psz = new CHAR [cLen];

        if (psz)
        {
            WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cLen, 0, 0);
        }
    }

    return psz;
}

// If we need to allocate buffer for the unicode string.
inline LPWSTR 
AnsiToUnicode(LPCSTR psz)
{
    LPWSTR pwsz = NULL;

    if (psz)
    {
        UINT cLen = strlen(psz) + 1;

        pwsz = new WCHAR [cLen];

        if (pwsz)
        {
            MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cLen);
        }
    }

    return pwsz;
}

// If we already have buffer allocated for the ansi string.
inline VOID 
UnicodeToAnsi(LPCWSTR pwsz, LPSTR psz)
{
    if (pwsz && psz)
    {
        WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, wcslen(pwsz) * 2 + 1, 0, 0);
    }    
}

// If we already have buffer allocated for the ansi string.
inline VOID 
AnsiToUnicode(LPCSTR psz, LPWSTR pwsz)
{
    if (pwsz && psz)
    {
        MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, strlen(psz) + 1);
    }    
}

//----------------
// File utilities.
//----------------

inline VOID 
FindDataW2A(WIN32_FIND_DATAW* pfdw, WIN32_FIND_DATAA* pfda)
{
    memcpy(pfda, pfdw, sizeof(WIN32_FIND_DATAA) - (MAX_PATH + 14) * sizeof(CHAR));
    
    UnicodeToAnsi(pfdw->cFileName, pfda->cFileName);
    UnicodeToAnsi(pfdw->cAlternateFileName, pfda->cAlternateFileName);
}

inline BOOL 
IsErrorNotFound()
{
    DWORD dwLastError = GetLastError();
    return (dwLastError == ERROR_FILE_NOT_FOUND || dwLastError == ERROR_PATH_NOT_FOUND);
}

// Each RITEM represents a file or a directory that the user wants to redirect.
struct RITEM
{
    WCHAR wszName[MAX_PATH];
    DWORD cLen;
    BOOL fHasWC;   // Does this item have wildcards in it?
    BOOL fAllUser; // Should this item be redirected to the All User dir?
};

//---------------------
// Registry utilities.
//---------------------


// This is where we store all the redirected registry keys.
#define LUA_REG_REDIRECT_KEY L"Software\\Redirected"
#define LUA_REG_REDIRECT_KEY_LEN (sizeof("Software\\Redirected") / sizeof(CHAR) - 1)

#define LUA_SOFTWARE_CLASSES L"Software\\Classes"
#define LUA_SOFTWARE_CLASSES_LEN (sizeof("Software\\Classes") / sizeof(CHAR) - 1)

extern HKEY g_hkRedirectRoot;
extern HKEY g_hkCurrentUserClasses;

LONG
GetRegRedirectKeys();

BOOL 
IsPredefinedKey(
    IN HKEY hKey
    );

//
// Name matching utilities.
//

BOOL DoNamesMatch(
    IN LPCWSTR pwszNameL, 
    IN LPCWSTR pwszName
    );

BOOL DoNamesMatchWC(
    IN LPCWSTR pwszNameWC, 
    IN LPCWSTR pwszName
    );

BOOL 
DoesItemMatchRedirect(
    LPCWSTR pwszItem,
    const RITEM* pItem,
    BOOL fIsDirectory
    );

//
// Commandline utilities.
// We only deal with file/dir names so we don't need to consider anything that
// has invalid characters for filenames.
//

LPWSTR GetNextToken(LPWSTR pwsz);

VOID TrimTrailingSpaces(LPWSTR pwsz);

BOOL 
CreateDirectoryOnDemand(
    LPWSTR pwszDir
    );

LPWSTR  
ExpandItem(
    LPCWSTR pwszItem,
    DWORD* pcItemExpand,
    BOOL fEnsureTrailingSlash,
    BOOL fCreateDirectory,
    BOOL fAddPrefix
    );

DWORD 
GetItemsCount(
    LPCWSTR pwsz,
    WCHAR chDelimiter
    );

BOOL LuaShouldApplyShim();

// 
// Cleanup utilities.
// Get the users on the local machine. So we can delete all the redirected stuff.
//

struct REDIRECTED_USER_PATH
{
    LPWSTR pwszPath;
    DWORD cLen;
};

struct USER_HIVE_KEY
{
    HKEY hkUser;
    HKEY hkUserClasses;
};

BOOL GetUsersFS(REDIRECTED_USER_PATH** ppRedirectUserPaths, DWORD* pcUsers);
VOID FreeUsersFS(REDIRECTED_USER_PATH* pRedirectUserPaths);

BOOL GetUsersReg(USER_HIVE_KEY** pphkUsers, DWORD* pcUsers);
VOID FreeUsersReg(USER_HIVE_KEY* phkUsers, DWORD cUsers);

#endif // _LUA_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\lua\utils.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   LUA_RedirectFS_Cleanup.cpp

 Abstract:

   Delete the redirected copies in every user's directory.

 Created:

   02/12/2001 maonis

 Modified:


--*/
#include "precomp.h"
#include "secutils.h"
#include "utils.h"
#include <userenv.h>

WCHAR g_wszUserProfile[MAX_PATH] = L"";
DWORD g_cUserProfile = 0;
WCHAR g_wszSystemRoot[MAX_PATH] = L"";
DWORD g_cSystemRoot = 0;

DWORD
GetUserProfileDirW()
{
    if (g_cUserProfile == 0)
    {
        HANDLE hToken;
        if (OpenProcessToken(
                GetCurrentProcess(),
		TOKEN_QUERY,
		&hToken))
        {
            WCHAR wszProfileDir[MAX_PATH] = L"";
            DWORD dwSize = MAX_PATH;

            if (GetUserProfileDirectoryW(hToken, wszProfileDir, &dwSize))
            {
                dwSize = GetLongPathNameW(wszProfileDir, g_wszUserProfile, MAX_PATH);

                if (dwSize <= MAX_PATH)
                {
                    //
                    // Only if we successfully got the path and it's not more
                    // than MAX_PATH will we set the global values.
                    //
                    g_cUserProfile = dwSize;
                }
                else
                {
                    g_wszUserProfile[0] = L'\0';
                }
            }

            CloseHandle(hToken);
        }
    }

    return g_cUserProfile;
}

BOOL 
IsUserDirectory(LPCWSTR pwszPath)
{
    GetUserProfileDirW();

    if (g_cUserProfile)
    {
        return !_wcsnicmp(pwszPath, g_wszUserProfile, g_cUserProfile);
    }

    return FALSE;
}

DWORD
GetSystemRootDirW()
{
    if (g_cSystemRoot == 0)
    {
        if (g_cSystemRoot = GetSystemWindowsDirectoryW(g_wszSystemRoot, MAX_PATH))
        {
            //
            // Just to be cautious - if we really have a system directory that's
            // longer than MAX_PATH, most likely something suspicious is going on
            // here, so we bail out.
            //
            if (g_cSystemRoot >= MAX_PATH)
            {
                g_wszSystemRoot[0] = L'\0';
                g_cSystemRoot = 0;
            }
            else if (g_cSystemRoot > 3)
            {
                g_wszSystemRoot[g_cSystemRoot] = L'\\';
                g_wszSystemRoot[g_cSystemRoot + 1] = L'\0';
                ++g_cSystemRoot;
            }
            else
            {
                g_wszSystemRoot[g_cSystemRoot] = L'\0';
            }
        }
    }

    return g_cSystemRoot;
}

/*++

 Function Description:

    For the GetPrivateProfile* and WritePrivateProfile* APIs,
    if the app didn't specify the path, we append the windows dir
    in the front as that's where it'll be looking for and creating
    the file it doesn't already exist.

 Arguments:

    IN lpFileName - The file name specified by the profile API.
    IN/OUT pwszFullPath - Pointer to the buffer to receive the full path.
                          This buffer is at least MAX_PATH WCHARs long.

 Return Value:

    TRUE - Successfully got the path.
    FALSE - We don't handle this filename, either because an error
            occured or the file name is longer than MAX_PATH.

 History:

    05/16/2001 maonis  Created
    02/13/2002 maonis  Modified to signal errors.

--*/

BOOL
MakeFileNameForProfileAPIsW(
    IN      LPCWSTR lpFileName,
    IN OUT  LPWSTR  pwszFullPath // at least MAX_PATH in length
    )
{
    BOOL fIsSuccess = FALSE;

    if (lpFileName)
    {
        DWORD cFileNameLen = wcslen(lpFileName);

        if (wcschr(lpFileName, L'\\'))
        {
            if (cFileNameLen < MAX_PATH)
            {
                //
                // The filename already contains the path, just copy it over.
                //
                wcsncpy(pwszFullPath, lpFileName, cFileNameLen);
                fIsSuccess = TRUE;
            }
        }
        else if (GetSystemRootDirW() && g_cSystemRoot)
        {
            DWORD cLen = g_cSystemRoot + cFileNameLen;

            //
            // Only copy when we know the buffer is big enough.
            //
            if (cLen < MAX_PATH)
            {
                wcsncpy(pwszFullPath, g_wszSystemRoot, g_cSystemRoot);
                wcsncpy(pwszFullPath + g_cSystemRoot, lpFileName, cFileNameLen);
                pwszFullPath[cLen - 1] = L'\0';

                fIsSuccess = TRUE;
            }
        }
    }

    return fIsSuccess;
}

//
// If the .exe name is *setup*, *install* or _INS*._MP, we consider
// them a setup program and won't shim them.
//
BOOL IsSetup(
    )
{
    WCHAR wszModuleName[MAX_PATH + 1];
    ZeroMemory(wszModuleName, (MAX_PATH + 1) * sizeof(WCHAR));

    GetModuleFileNameW(NULL, wszModuleName, MAX_PATH + 1);

    wszModuleName[MAX_PATH] = 0;
    _wcslwr(wszModuleName);

    if (wcsstr(wszModuleName, L"setup") || wcsstr(wszModuleName, L"install"))
    {
        return TRUE;
    }

    LPWSTR pwsz;
    if (pwsz = wcsstr(wszModuleName, L"_ins"))
    {
        if (wcsstr(pwsz + 4, L"_mp"))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL LuaShouldApplyShim(
    )
{
    return (!IsSetup() && ShouldApplyShim());
}

#define REDIRECT_DIR L"\\Local Settings\\Application Data\\Redirected\\"
// We look at HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList for the users.
#define PROFILELIST_STR L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"

#define CLASSES_HIVE_SUFFIX L"_Classes"
#define CLASSES_HIVE_SUFFIX_LEN (sizeof(CLASSES_HIVE_SUFFIX) / sizeof(WCHAR) - 1)

#define USER_HIVE_NAME L"\\NtUser.dat"
#define USER_HIVE_NAME_LEN (sizeof(USER_HIVE_NAME) / sizeof(WCHAR) - 1)
#define USER_CLASSES_HIVE_NAME L"\\Local Settings\\Application Data\\Microsoft\\Windows\\UsrClass.dat"
#define USER_CLASSES_HIVE_NAME_LEN (sizeof(USER_CLASSES_HIVE_NAME) / sizeof(WCHAR) - 1)

// Total number of users which is the number of subkeys of 
// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList
static DWORD g_cUsers = 0;

// We need to keep a list of keys we had to load under HKEY_USERS and unload them 
// when the process exits.
static WCHAR** g_wszLoadedKeys = NULL;
static DWORD g_cLoadedKeys = 0;

// The number of users is the number of subkeys under 
// HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList
LONG 
InitGetUsers(
    OUT DWORD* pcUsers, 
    OUT HKEY* phKey
    )
{
    LONG lRes;

    if ((lRes = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE,
        PROFILELIST_STR,
        0,
        KEY_READ,
        phKey)) == ERROR_SUCCESS)
    {
        lRes = RegQueryInfoKeyW(*phKey, NULL, NULL, NULL, pcUsers,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        RegCloseKey(*phKey);
    }

    return lRes;
}

// In case of failure we need to clean up our array.
VOID 
FreeUserDirectoryArray(
    REDIRECTED_USER_PATH* pRedirectUserPaths
    )
{
    for (DWORD ui = 0; ui < g_cUsers; ++ui)
    {
        delete [] pRedirectUserPaths[ui].pwszPath;
    }

    delete [] pRedirectUserPaths;
}

BOOL 
IsDirectory(
    WCHAR* pwszName
    )
{
    DWORD dwAttrib = GetFileAttributesW(pwszName);

    return (dwAttrib != -1 && dwAttrib & FILE_ATTRIBUTE_DIRECTORY);
}

LONG GetProfilePath(
    HKEY hkProfileList,
    LPCWSTR pwszUserSID,
    LPWSTR pwszUserDirectory
    )
{
    LONG lRes;
    HKEY hkUserSID;
    DWORD dwFlags;

    // Open the user SID key.
    if ((lRes = RegOpenKeyExW(
        hkProfileList,
        pwszUserSID,
        0,
        KEY_QUERY_VALUE,
        &hkUserSID)) == ERROR_SUCCESS)
    {
        DWORD dwSize = sizeof(DWORD);
        if ((lRes = RegQueryValueExW(
            hkUserSID,
            L"Flags",
            NULL,
            NULL,
            (LPBYTE)&dwFlags,
            &dwSize)) == ERROR_SUCCESS)
        {
            // Check if the value of Flag is 0, if so it's the user we care about.
            if (dwFlags == 0)
            {
                DWORD cTemp = MAX_PATH;
                WCHAR wszTemp[MAX_PATH] = L"";

                if ((lRes = RegQueryValueExW(
                    hkUserSID,
                    L"ProfileImagePath",
                    NULL,
                    NULL,
                    (LPBYTE)wszTemp,
                    &cTemp)) == ERROR_SUCCESS)
                {
                    DWORD cExpandLen = ExpandEnvironmentStringsW(wszTemp, pwszUserDirectory, MAX_PATH);

                    if (cExpandLen > MAX_PATH)
                    {
                        lRes = ERROR_MORE_DATA;
                    }
                }
            }
            else
            {
                lRes = ERROR_INVALID_HANDLE;
            }
        }

        RegCloseKey(hkUserSID);
    }

    return lRes;
}

BOOL 
GetUsersFS(
    REDIRECTED_USER_PATH** ppRedirectUserPaths,
    DWORD* pcUsers
    )
{
    WCHAR wszRedirectDir[MAX_PATH] = L"";
    DWORD cUsers;
    HKEY hkProfileList;
    if (InitGetUsers(&cUsers, &hkProfileList) != ERROR_SUCCESS)
    {
        DPF("LUAUtils", eDbgLevelError, "[GetUsersFS] Error initializing");
        return FALSE;
    }

    *ppRedirectUserPaths = new REDIRECTED_USER_PATH [cUsers];
    if (!*ppRedirectUserPaths)
    {
        DPF("LUAUtils", eDbgLevelError, "[GetUsersFS] Error allocating memory");
        return FALSE;
    }

    REDIRECTED_USER_PATH* pRedirectUserPaths = *ppRedirectUserPaths;

    ZeroMemory((PVOID)pRedirectUserPaths, cUsers * sizeof(REDIRECTED_USER_PATH));

    WCHAR wszSubKey[MAX_PATH] = L"";
    DWORD cSubKey = 0;
    HKEY hkUserSID;
    LONG lRes;
    // The number of users we care about.
    DWORD cLUAUsers = 0;
    DWORD dwIndex = 0;
    
    while (TRUE)
    {
        cSubKey = MAX_PATH;

        lRes = RegEnumKeyExW(hkProfileList, dwIndex, wszSubKey, &cSubKey, 
            NULL, NULL, NULL, NULL);
        
        if (lRes == ERROR_SUCCESS)
        {
            WCHAR wszUserDirectory[MAX_PATH] = L"";

            if ((lRes = GetProfilePath(hkProfileList, wszSubKey, wszUserDirectory))
                == ERROR_SUCCESS)
            {
                //
                // If the directory doesn't exist, it means either the user
                // never logged on, or there are no redirected files for that
                // user. We simply skip it.
                //
                if (IsDirectory(wszUserDirectory))
                {
                    DWORD cPath = wcslen(wszUserDirectory) + 1;
                    LPWSTR pwszPath = new WCHAR [cPath];

                    if (pwszPath)
                    {
                        wcscpy(pwszPath, wszUserDirectory);
                        pRedirectUserPaths[cLUAUsers].pwszPath = pwszPath;
                        pRedirectUserPaths[cLUAUsers].cLen = cPath;
                        ++cLUAUsers;
                    }
                    else
                    {
                        DPF("LUAUtils", eDbgLevelError, 
                            "[GetUsersFS] Error allocating memory");
                        lRes = ERROR_NOT_ENOUGH_MEMORY;
                        goto EXIT;
                    }
                }
            }
        }
        else if (lRes == ERROR_NO_MORE_ITEMS)
        {
            *pcUsers = cLUAUsers;
            lRes = ERROR_SUCCESS;
            goto EXIT;
        }
        else
        {
            break;
        }

        ++dwIndex;
    }

EXIT:

    RegCloseKey(hkProfileList);

    if (lRes == ERROR_SUCCESS)
    {
        return TRUE;
    }

    FreeUserDirectoryArray(pRedirectUserPaths);
    return FALSE;
}

VOID 
FreeUsersFS(
    REDIRECTED_USER_PATH* pRedirectUserPaths
    )
{
    FreeUserDirectoryArray(pRedirectUserPaths);
}

LONG 
LoadHive(
    LPCWSTR pwszHiveName,
    LPCWSTR pwszHiveFile,
    HKEY* phKey
    )
{
    LONG lRes;

    // If the hive is already loaded, we'll get a sharing violation so 
    // check that as well.
    if ((lRes = RegLoadKeyW(HKEY_USERS, pwszHiveName, pwszHiveFile))
        == ERROR_SUCCESS || lRes == ERROR_SHARING_VIOLATION)
    {
        if (lRes == ERROR_SUCCESS)
        {
            DWORD cLen = wcslen(pwszHiveName) + 1;
            g_wszLoadedKeys[g_cLoadedKeys] = new WCHAR [cLen];
            if (!(g_wszLoadedKeys[g_cLoadedKeys]))
            {
                DPF("LUAUtils", eDbgLevelError, 
                    "[LoadHive] Error allocating %d WCHARs",
                    cLen);

                return ERROR_NOT_ENOUGH_MEMORY;
            }

            // Store the hive name so later on we can unload this hive.
            wcscpy(g_wszLoadedKeys[g_cLoadedKeys++], pwszHiveName);
        }

        lRes = RegOpenKeyExW(
            HKEY_USERS,
            pwszHiveName,
            0,
            KEY_ALL_ACCESS,
            phKey);
    }

    return lRes;
}

BOOL 
GetUsersReg(
    USER_HIVE_KEY** pphkUsers, 
    DWORD* pcUsers
    )
{
    // We have to enable the "Restore files and directories" privilege to 
    // load each user's hive.
    if (!AdjustPrivilege(SE_RESTORE_NAME, TRUE))
    {
        DPF("LUAUtils", eDbgLevelError, 
            "[GetUsersReg] Error enabling the SE_RESTORE_NAME privilege");
        return FALSE;        
    }

    DWORD cUsers;
    HKEY hkProfileList;
    if (InitGetUsers(&cUsers, &hkProfileList) != ERROR_SUCCESS)
    {
        DPF("LUAUtils", eDbgLevelError, "[GetUsersReg] Error initializing");
        return FALSE;
    }

    *pphkUsers = new USER_HIVE_KEY [cUsers];
    if (!*pphkUsers)
    {
        DPF("LUAUtils", eDbgLevelError, 
            "[GetUsersReg] Error allocating memory for %d USER_HIVE_KEYs",
            cUsers);
        return FALSE;
    }

    g_wszLoadedKeys = new WCHAR* [cUsers * 2];
    if (!g_wszLoadedKeys)
    {
        DPF("LUAUtils", eDbgLevelError, 
            "[GetUsersReg] Error allocating memory for %d WCHARs",
            cUsers * 2);

        delete [] *pphkUsers;
        return FALSE;
    }

    USER_HIVE_KEY* phkUsers = *pphkUsers;
    
    ZeroMemory((PVOID)phkUsers, cUsers * sizeof(USER_HIVE_KEY));
    ZeroMemory((PVOID)g_wszLoadedKeys, cUsers * 2 * sizeof (WCHAR*));

    WCHAR wszSubKey[MAX_PATH] = L"";
    WCHAR wszUserHive[MAX_PATH] = L"";
    WCHAR wszUserClassesHive[MAX_PATH] = L"";
    DWORD cSubKey = 0;
    HKEY hkSubKey;
    LONG lRes;
    // The number of users we care about.
    DWORD cLUAUsers = 0;
    DWORD dwIndex = 0;
    DWORD cUserHive = 0;

    while (TRUE)
    {
        cSubKey = MAX_PATH;

        lRes = RegEnumKeyExW(hkProfileList, dwIndex, wszSubKey, &cSubKey,
            NULL, NULL, NULL, NULL);
        
        if (lRes == ERROR_SUCCESS)
        {
            if ((lRes = GetProfilePath(hkProfileList, wszSubKey, wszUserHive))
                == ERROR_SUCCESS)
            {
                //
                // Make sure we don't buffer overflow.
                //
                cUserHive = wcslen(wszUserHive);
                if ((cUserHive + USER_CLASSES_HIVE_NAME_LEN + 1) > MAX_PATH ||
                    (cUserHive + USER_HIVE_NAME_LEN + 1) > MAX_PATH)
                {
                    DPF("LUAUtils", eDbgLevelError, 
                        "[GetUsersReg] The hive key names are too long - we don't handle them");
                    goto EXIT;
                }

                //
                // Construct the locations for the user hive and user classes data hive.
                //
                wcsncpy(wszUserClassesHive, wszUserHive, cUserHive);
                wcsncpy(
                    wszUserClassesHive + cUserHive, 
                    USER_CLASSES_HIVE_NAME, 
                    USER_CLASSES_HIVE_NAME_LEN);
                wszUserClassesHive[cUserHive + USER_CLASSES_HIVE_NAME_LEN] = L'\0';

                wcsncpy(wszUserHive + cUserHive, USER_HIVE_NAME, USER_HIVE_NAME_LEN);
                wszUserHive[cUserHive + USER_HIVE_NAME_LEN] = L'\0';

                //
                // Load the HKCU for this user.
                //
                if ((lRes = LoadHive(
                    wszSubKey, 
                    wszUserHive, 
                    &phkUsers[cLUAUsers].hkUser)) == ERROR_SUCCESS)
                {
                    //
                    // We can't necessarily load the HKCR for this user - it might
                    // contain no data so we only attemp to load it.
                    //

                    if ((cSubKey + CLASSES_HIVE_SUFFIX_LEN + 1) > MAX_PATH)
                    {
                        DPF("LUAUtils", eDbgLevelError, 
                            "[GetUsersReg] The CR key name is too long - we don't handle it");
                        goto EXIT;
                    }

                    wcsncpy(wszSubKey + cSubKey, CLASSES_HIVE_SUFFIX, CLASSES_HIVE_SUFFIX_LEN);
                    wszSubKey[cSubKey + CLASSES_HIVE_SUFFIX_LEN] = L'\0';

                    LoadHive(
                        wszSubKey, 
                        wszUserClassesHive, 
                        &phkUsers[cLUAUsers].hkUserClasses);

                    ++cLUAUsers;
                }
            }
        }
        else if (lRes == ERROR_NO_MORE_ITEMS)
        {
            *pcUsers = cLUAUsers;
            lRes = ERROR_SUCCESS;
            goto EXIT;
        }
        else
        {
            break;
        }

        ++dwIndex;
    }

EXIT:

    RegCloseKey(hkProfileList);

    if (lRes == ERROR_SUCCESS)
    {
        return TRUE;
    }

    FreeUsersReg(phkUsers, cUsers);
    return FALSE;
}

VOID 
FreeUsersReg(
    USER_HIVE_KEY* phkUsers,
    DWORD cUsers
    )
{
    DWORD dw;

    // Close all the open keys.
    for (dw = 0; dw < cUsers; ++dw)
    {
        RegCloseKey(phkUsers[dw].hkUser);
        RegCloseKey(phkUsers[dw].hkUserClasses);
    }

    delete [] phkUsers;

    for (dw = 0; dw < g_cLoadedKeys; ++dw)
    {
        // Unloaded the keys we had to load under HKEY_USERS.
        RegUnLoadKey(HKEY_USERS, g_wszLoadedKeys[dw]);

        delete [] g_wszLoadedKeys[dw];
    }

    delete [] g_wszLoadedKeys;

    // Disable the "Restore files and directories" privilege.
    AdjustPrivilege(SE_RESTORE_NAME, FALSE);
}

//
// Registry utilies.
//

HKEY g_hkRedirectRoot = NULL;
HKEY g_hkCurrentUserClasses = NULL;

/*++

 Function Description:
    
    We only return TRUE if it's one of the predefined keys we are interested in.
    We don't redirect the HKEY_USERS and HKEY_PERFORMANCE_DATA keys.

 Arguments:

    IN hKey - the key handle.
    IN lpSubKey - subkey to check.

 Return Value:

    TRUE - It's one of our predefined keys.
    FALSE - It's either a non-predefined key or a predefined key that we are not
            interested in.

 History:

    03/27/2001 maonis  Created

--*/

BOOL 
IsPredefinedKey(
    IN HKEY hKey
    )
{
    return (
        hKey == HKEY_CLASSES_ROOT ||
        hKey == HKEY_CURRENT_USER ||
        hKey == HKEY_LOCAL_MACHINE);
}

LONG
GetRegRedirectKeys()
{
    LONG lRet;

    if (lRet = RegCreateKeyExW(
        HKEY_CURRENT_USER,
        LUA_REG_REDIRECT_KEY,
        0,
        0,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &g_hkRedirectRoot,
        NULL) == ERROR_SUCCESS)
    {
        lRet = RegCreateKeyExW(
            HKEY_CURRENT_USER,
            LUA_SOFTWARE_CLASSES,
            0,
            0,
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,
            &g_hkCurrentUserClasses,
            NULL);
    }

    return lRet;
}

#define IS_END_OF_COMPONENT(x) (*x == L'\\' || *x == L'\0')

/*++

 Function Description:

    Determines if 2 components match - one with wildcards and the other
    without.

    Note: this function is specialized for the LUA shims - the pattern
    is all lowercase. If the components match, we advance the string
    to the end of the component so when we do the whole path/file name
    matching we don't need to go through the string twice.

 Arguments:

    IN ppPattern - component with wildcards.
    IN ppString - component without wildcards.

 Return Value:
    
    TRUE - the components match.
    FALSE - the components don't match.

 History:

    05/10/2001 maonis  Created

--*/

BOOL
DoComponentsMatch(
    LPCWSTR* ppwszPattern,
    LPCWSTR* ppwszString)
{
    LPCWSTR pwszPattern = *ppwszPattern;
    LPCWSTR pwszString = *ppwszString;
    LPCWSTR pwszSearch = NULL;
    LPCWSTR pwszSearchPattern = NULL;

    BOOL fIsSuccess = TRUE;

    do
    {
        if (*pwszPattern == L'*')
        {
            while (*++pwszPattern == L'*');

            if (IS_END_OF_COMPONENT(pwszPattern))
            {
                // Advanced the string to the end.
                while (!IS_END_OF_COMPONENT(pwszString))
                {
                    ++pwszString;
                }

                goto EXIT;
            }

            pwszSearch = pwszString;
            pwszSearchPattern = pwszPattern;
        }

        if (IS_END_OF_COMPONENT(pwszString))
        {
            break;
        }

        if ((*pwszPattern == L'?') ||
            (*pwszPattern == *pwszString))
        {
            pwszPattern++;
        }
        else if (pwszSearch == NULL)
        {
            return FALSE;
        }
        else
        {
            pwszString = pwszSearch++;
            pwszPattern = pwszSearchPattern;
        }

        ++pwszString;

    } while (!IS_END_OF_COMPONENT(pwszString));

    if (*pwszPattern == L'*')
    {
        fIsSuccess = TRUE;
        ++pwszPattern;
    }
    else
    {
        fIsSuccess = IS_END_OF_COMPONENT(pwszPattern);
    }

EXIT:

    *ppwszPattern = pwszPattern;
    *ppwszString = pwszString;
    return fIsSuccess;
}

/*++

 Function Description:

    Determines if the item is in the redirect list.

 Arguments:

    IN pwszDirectory - All lowercase name.
    IN cDirectory - The length of the directory.
    IN pwszFile - The file name.

 Return Value:
    
    TRUE - the names match.
    FALSE - the names don't match.

 History:

    11/30/2001 maonis  Created

--*/

BOOL 
DoesItemMatchRedirect(
    LPCWSTR pwszItem,
    const RITEM* pItem,
    BOOL fIsDirectory
    )
{
    LPCWSTR pwszName = &(pItem->wszName[0]);
    BOOL fMatchComponents;

    if (pItem->fHasWC)
    {
        while (*pwszItem && *pwszName)
        {
            if (!DoComponentsMatch(&pwszName, &pwszItem))
            {
                return FALSE;
            }

            if (fIsDirectory)
            {
                if (!*pwszName)
                {
                    //
                    // directory has exhausted. It's a match.
                    //
                    return TRUE;
                }

                if (!*pwszItem)
                {
                    //
                    // directory hasn't exhausted but item has, no match.
                    //
                    return FALSE;
                }
            }
            else
            {
                if (!*pwszItem)
                {
                    //
                    // item has exhausted. It's a match.
                    //
                    return TRUE;
                }

                if (!*pwszName)
                {
                    //
                    // item hasn't exhausted but file has, no match.
                    //
                    return FALSE;
                }
            }

            ++pwszName;
            ++pwszItem;
        }

        if (fIsDirectory)
        {
            return (!*pwszName);
        }
        else
        {
            return (!*pwszItem);
        }
    }
    else
    {
        while (*pwszItem && *pwszName && *pwszItem == *pwszName)
        {
            ++pwszItem;
            ++pwszName;
        }

        if (fIsDirectory)
        {
            return (!*pwszName && (!*pwszItem || *pwszItem == L'\\'));
        }
        else
        {
            return (!*pwszItem && (!*pwszName || *pwszName == L'\\'));
        }
    }
}

/*++

 Function Description:

    Parse the commandline argument for the LUA shims using ' ' as the delimiter.
    If a token has spaces, use double quotes around it. Use this function the 
    same way you use wcstok except you don't have to specify the delimiter.

 Arguments:

    IN/OUT pwsz - the string to parse.

 Return Value:
    
    pointer to the next token.

 History:

    05/17/2001 maonis  Created

--*/

LPWSTR GetNextToken(
    LPWSTR pwsz
    )
{
    static LPWSTR pwszToken;
    static LPWSTR pwszEndOfLastToken;

    if (!pwsz)
    {
        pwsz = pwszEndOfLastToken;
    }

    // Skip the white space.
    while (*pwsz && *pwsz == ' ')
    {
        ++pwsz;
    }

    pwszToken = pwsz;

    BOOL fInsideQuotes = 0;

    while (*pwsz)
    {
        switch(*pwsz)
        {
        case L'"':
            fInsideQuotes ^= 1;

            if (fInsideQuotes)
            {
                ++pwszToken;
            }

        case L' ':
            if (!fInsideQuotes)
            {
                goto EXIT;
            }

        default:
            ++pwsz;
        }
    }

EXIT:
    if (*pwsz)
    {
        *pwsz = L'\0';
        pwszEndOfLastToken = ++pwsz;
    }
    else
    {
        pwszEndOfLastToken = pwsz;
    }
    
    return pwszToken;
}

/*++

 Function Description:

    Starting from the end going backward and find the first non whitespace
    char. Set the whitespace char after it to '\0'.

 Arguments:

    IN pwsz - Beginning pointer.

 Return Value:

    None.

 History:

    06/27/2001 maonis  Created

--*/

VOID TrimTrailingSpaces(
    LPWSTR pwsz
    )
{
    if (pwsz)
    {
        DWORD   cLen = wcslen(pwsz);
        LPWSTR  pwszEnd = pwsz + cLen - 1;

        while (pwszEnd >= pwsz && (*pwszEnd == L' ' || *pwszEnd == L'\t'))
        {
            --pwszEnd;
        }

        *(++pwszEnd) = L'\0';
    }
}

/*++

 Function Description:

    If the directory doesn't exist, we create it.

 Arguments:

    IN pwszDir - The name of the directory to create. The directory should NOT 
    start with \\?\ and it should haved a trailing slash.

 Return Value:

    TRUE - the directory was created.
    FALSE - otherwise.

 History:

    05/17/2001 maonis  Created

--*/

BOOL 
CreateDirectoryOnDemand(
    LPWSTR pwszDir
    )
{
    if (!pwszDir || !*pwszDir)
    {
        DPF("LUAUtils", eDbgLevelSpew, 
            "[CreateDirectoryOnDemand] Empty directory name - nothing to do");
        return TRUE;
    }

    WCHAR* pwszStartPath = pwszDir;
    WCHAR* pwszEndPath = pwszDir + wcslen(pwszDir);
    WCHAR* pwszStartNext = pwszStartPath;
       
    // Find the end of the next sub dir.
    WCHAR* pwszEndNext;
    DWORD dwAttrib;

    while (pwszStartNext < pwszEndPath)
    {
        pwszEndNext = wcschr(pwszStartNext, L'\\');
        if (pwszEndNext)
        {
            *pwszEndNext = L'\0';
            if ((dwAttrib = GetFileAttributesW(pwszStartPath)) != -1)
            {
                // If the directory already exists, we probe its sub directory.
                *pwszEndNext = L'\\';
                pwszStartNext = pwszEndNext + 1;
                continue;
            }

            if (!CreateDirectoryW(pwszStartPath, NULL))
            {
                DPF("LUAUtils", eDbgLevelError, 
                    "[CreateDirectoryOnDemand] CreateDirectory %S failed: %d", 
                    pwszStartPath, 
                    GetLastError());
                return FALSE;
            }

            *pwszEndNext = L'\\';
            pwszStartNext = pwszEndNext + 1;
        }
        else
        {
            DPF("LUAUtils", eDbgLevelError, 
                "[CreateDirectoryOnDemand] Invalid directory name: %S", pwszStartPath);
            return FALSE;
        }
    }

    return TRUE;
}

/*++

 Function Description:

    Expand a string which might have enviorment variables embedded in it.
    It gives you options to
    1) Add a trailing slash if there's not one;
    2) Create the directory if it doesn't exist;
    3) Add the \\?\ prefix;

    NOTE: The caller is responsible of free the memory using delete [].

 Arguments:

    IN pwszItem - string to expand.
    OUT pcItemExpand - number of characters in the resulting string.
                       NOTE: this *includes* the terminating NULL.
    IN fEnsureTrailingSlash - option 1.
    IN fCreateDirectory - option 2.
    IN fAddPrefix - option 3.

 Return Value:

    The expanded string or NULL if error occured.

 History:

    05/17/2001 maonis  Created

--*/

LPWSTR  
ExpandItem(
    LPCWSTR pwszItem,
    DWORD* pcItemExpand,
    BOOL fEnsureTrailingSlash,
    BOOL fCreateDirectory,
    BOOL fAddPrefix
    )
{
    BOOL fIsSuccess = FALSE;

    //
    // Get the required length.
    //
    DWORD cLenExpand = ExpandEnvironmentStringsW(pwszItem, NULL, 0);

    if (!cLenExpand)
    {
        DPF("LUAUtils", eDbgLevelError,
            "[ExpandItem] Failed to get the required buffer size "
            "when expanding %S: %d", 
            pwszItem, GetLastError());
        return NULL;
    }

    if (fEnsureTrailingSlash) 
    {
        ++cLenExpand;
    }

    if (fAddPrefix)
    {
        cLenExpand += FILE_NAME_PREFIX_LEN;
    }

    LPWSTR pwszItemExpand = new WCHAR [cLenExpand];
    if (!pwszItemExpand)
    {
        DPF("LUAUtils", eDbgLevelError,
            "[ExpandItem] Error allocating %d WCHARs", cLenExpand);
        return NULL;
    }

    LPWSTR pwszTemp = pwszItemExpand;
    DWORD cTemp = cLenExpand;

    if (fAddPrefix)
    {
        wcscpy(pwszItemExpand, FILE_NAME_PREFIX);
        pwszTemp += FILE_NAME_PREFIX_LEN;
        cTemp -= FILE_NAME_PREFIX_LEN;
    }

    if (!ExpandEnvironmentStringsW(pwszItem, pwszTemp, cTemp))
    {
        DPF("LUAUtils", eDbgLevelError,
            "[ExpandItem] Failed to expand %S: %d", 
            pwszItem, GetLastError());

        goto Cleanup;
    }
    
    // Ensure the trailing slash.
    if (fEnsureTrailingSlash)
    {
        if (pwszItemExpand[cLenExpand - 3] != L'\\')
        {
            pwszItemExpand[cLenExpand - 2] = L'\\';
            pwszItemExpand[cLenExpand - 1] = L'\0';
        }
        else
        {
            --cLenExpand;
        }

        if (fCreateDirectory && 
            !CreateDirectoryOnDemand(pwszItemExpand + (fAddPrefix ? 4 : 0)))
        {
            DPF("LUAUtils", eDbgLevelError,
                "[ExpandItem] Failed to create %S", 
                pwszItemExpand);
            goto Cleanup;
        }
    }

    *pcItemExpand = cLenExpand;

    fIsSuccess = TRUE;

Cleanup:

    if (!fIsSuccess)
    {
        delete [] pwszItemExpand;
        pwszItemExpand = NULL;
    }

    return pwszItemExpand;
}

/*++

 Function Description:

    Given a delimiter character, returns the number of items in the string.

 Return Value:

    Number of items in the string.

 History:

    11/13/2001 maonis  Created

--*/

DWORD 
GetItemsCount(
    LPCWSTR pwsz,
    WCHAR chDelimiter
    )
{
    DWORD cItems = 0;

    while (*pwsz) {

        if (*pwsz == chDelimiter) {
            ++cItems;
        }
        ++pwsz;
    }

    return (cItems + 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\3dfrogfrenzy.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    3DFrogFrenzy.cpp

 Abstract:

    Workaround for a USER bug (or by design behaviour) where if you call 
    SetCursor(NULL) and the cursor is over somebody elses window, the 
    cursor stays visible. 

    We don't normally see this because most apps that want the cursor to 
    be invisible are full-screen: so the cursor is always over their window.

 Notes:

    This is an app-specific shim.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(3DFrogFrenzy)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetCursor)
APIHOOK_ENUM_END

/*++

 Move the cursor to the middle of their window, so that SetCursor works.

--*/

HCURSOR
APIHOOK(SetCursor)( 
    HCURSOR hCursor
    )
{
    HWND hWndFrog = FindWindowW(L"3DFrog", L"3D Frog Frenzy");
    BOOL bRet = FALSE;
    
    if (hWndFrog) {
        RECT r;
        if (GetWindowRect(hWndFrog, &r)) {
            SetCursorPos(r.left + (r.right - r.left) / 2, r.top + (r.bottom - r.top) / 2);
        }
    }
    
    return ORIGINAL_API(SetCursor)(hCursor);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetCursor)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\sample\sampleshim.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   SampleShim.cpp

 Abstract:

   This DLL serves as a template for the creation of shim DLLs. Follow
   the commenting/coding style of this source file wherever possible.
   Never use tabs, configure your editor to insert spaces instead of
   tab characters.
   
 Notes:

   Hooking COM functions is also possible but is not covered in this
   sample for simplicity sake. Contact markder or linstev for more
   information on COM hooking.

 History:

    02/02/2000  markder     Created
    11/14/2000  markder     Converted to framework version 2
    02/13/2001  mnikkel     Changed notify to handle new DLL_PROCESS
                            capabilities
    03/31/2001  robkenny    Changed to use CString
    04/10/2002  robkenny    Updated to compile.

--*/


#include "ShimHook.h"
#include "StrSafe.h"

using namespace ShimLib;

//
// You must declare the type of shim this is at the top. If your shim 
// coexists with other shims in the same DLL,
// use IMPLEMENT_SHIM_BEGIN(SampleShim)
// otherwise use IMPLEMENT_SHIM_STANDALONE(SampleShim)
//
IMPLEMENT_SHIM_STANDALONE(SampleShim)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MessageBoxA) 
    APIHOOK_ENUM_ENTRY(MessageBoxW) 
APIHOOK_ENUM_END

/*++

 This stub function intercepts all calls to MessageBoxA
 and prefixes the output string with "SampleShim says:".
 
--*/

int
APIHOOK(MessageBoxA)(
    HWND hWnd,          // handle to owner window
    LPCSTR lpText,      // text in message box
    LPCSTR lpCaption,   // message box title
    UINT uType          // message box style
    )
{
    //
    // Use Hungarian notation for local variables:
    //
    //      Type                        Scope
    //      -----------------------     ------------------
    //      Pointers            p       Global          g_
    //      DWORD               dw      Class member    m_
    //      LONG                l       Static          s_
    //      ANSI strings        sz
    //      Wide-char strings   wsz
    //      Arrays              rg
    //      CString             cs
    //

    int iReturnValue;
    
    //
    // We use the CString class to perform all string operations in UNICODE
    // to prevent any problems with DBCS characters.
    //
    // Place all CString operations inside a CSTRING_TRY/CSTRING_CATCH
    // exception handler.  CString will throw an exception if it encounters
    // any memory allocation failures.
    //
    // Performing all string operations by using the CString class also prevents
    // us from accidentally modifying the original string.
    //
    
    CSTRING_TRY
    {
        CString csNewOutputString(lpText);
        csNewOutputString.Insert(0, L"SampleShim says: ");

        //
        // Use the DPF macro to print debug strings. See Hooks\inc\ShimDebug.h
        // for debug level values. Use eDbgLevelError if an unexpected error
        // occurs in your shim code. For informational output, use eDbgLevelInfo.
        //
        // Make sure you don't end the message with '\n' in this case because
        // the macro will do it by default.
        //
        // Note that when printing CString, use %S and you must call the Get() method,
        // to explicitly return a WCHAR *.
        //
        DPFN( eDbgLevelInfo,
            "MessageBoxA called with lpText = \"%s\".", lpText);
    
        //
        // Use the ORIGINAL_API macro to call the original API. You must use
        // this so that API chaining and inclusion/exclusion information is
        // preserved.
        //
        // CString will perform automatic type conversion to const WCHAR * (LPCWSTR)
        // It will not, however, automatically convert to char *, you must call GetAnsi()
        // (or GetAnsiNIE() if you wish a NULL pointer be returned when the string is empty)
        //
        iReturnValue = ORIGINAL_API(MessageBoxA)(hWnd, csNewOutputString.GetAnsi(), lpCaption, uType);
    
        //
        // Use the LOG macro to print messages to the log file. This macro should
        // be used to indicate that the shim had affected execution of the program
        // in some way. Use eDbgLevelError to indicate that the shim has
        // consciously fixed something that would have caused problems. Use
        // eDbgLevelWarning if the shim has affected execution, but it is unclear
        // whether it actually helped the program.
        //
        LOGN( eDbgLevelWarning,
            "MessageBoxA converted lpText from \"%s\" to \"%S\".", lpText, csNewOutputString.Get());
    }
    CSTRING_CATCH
    {
        //
        // We had a CString failure, call the original API with the original args
        //
        iReturnValue = ORIGINAL_API(MessageBoxA)(hWnd, lpText, lpCaption, uType);
    }
    
    return iReturnValue;
}

/*++

 This stub function intercepts all calls to MessageBoxW and prefixes the
 output string with "SampleShim says:".

 Note that to make your shim generally applicable in an NT environment,
 you should include both ANSI and wide-character versions of your stub
 function. However, if your shim emulates Win9x behaviour, it is
 redundant to include wide-character versions because Win9x did not
 support them.

--*/

int
APIHOOK(MessageBoxW)(
    HWND hWnd,          // handle to owner window
    LPCWSTR lpText,     // text in message box
    LPCWSTR lpCaption,  // message box title
    UINT uType          // message box style
    )
{
    int iReturnValue;
    
    CSTRING_TRY
    {
        CString csNewOutputString(lpText);
        csNewOutputString.Insert(0, L"SampleShim says: ");

        DPFN( eDbgLevelInfo,
            "MessageBoxW called with lpText = \"%S\".", lpText);
    
        iReturnValue = ORIGINAL_API(MessageBoxW)(
                                hWnd,
                                csNewOutputString,
                                lpCaption,
                                uType);
    
        LOGN( eDbgLevelWarning,
            "MessageBoxW converted lpText from \"%S\" to \"%S\".",
            lpText, csNewOutputString.Get());
    }
    CSTRING_CATCH
    {
        iReturnValue = ORIGINAL_API(MessageBoxW)(
                                hWnd,
                                lpText,
                                lpCaption,
                                uType);
    }
    
    return iReturnValue;

}

/*++

 Handle DLL_PROCESS_ATTACH, SHIM_STATIC_DLLS_INITIALIZED
 and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL and KERNEL32 APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 SHIM_STATIC_DLLS_INITIALIZED is called after all of the application's
 DLLs have been initialized.
 
 If your shim cannot initialize properly (during DLL_PROCESS_ATTACH),
 return FALSE and none of the APIs specified will be hooked.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    //
    // Note that there are further cases besides attach and detach.
    //
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPFN( eDbgLevelSpew, "Sample Shim initialized.");
            break;
    
        case SHIM_STATIC_DLLS_INITIALIZED:
            DPFN( eDbgLevelSpew,
                "Sample Shim notification: All DLLs have been loaded.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPFN( eDbgLevelSpew, "Sample Shim uninitialized.");
            break;

        default:
            break;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    //
    // If you have any initialization to do, you must include this line.
    // Then you must implement the NOTIFY_FUNCTION as above.
    //
    CALL_NOTIFY_FUNCTION

    //
    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    //
    APIHOOK_ENTRY(USER32.DLL, MessageBoxA)
    APIHOOK_ENTRY(USER32.DLL, MessageBoxW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\acmsg.h ===
/*++

  Copyright (c) Microsoft Corporation. All rights resereved.

  Module Name:

    acmsg.mc

  Abstract:

    Contains message definitions for event logging.

  Notes:

    DO NOT change the order of the MessageIds.
    The event log service uses these numbers to determine which strings
    to pull from the library. If a later version of the library is installed
    and the messages are ordered differently, previous event log entries
    will be incorrect.

  History:

    02/04/03   rparsons        Created

--*/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ID_SQL_PORTS_DISABLED
//
// MessageText:
//
//  The version of Microsoft SQL Server 2000 or Microsoft SQL Server 2000 Desktop
//  Engine (MSDE) you are running has known security vulnerabilities when used
//  in conjunction with Microsoft Windows Server 2003.  To reduce virus and worm
//  attacks, the TCP/IP and UDP network ports of Microsoft SQL Server 2000 or
//  Microsoft MSDE are disabled.  Please install a patch or upgrade your service
//  pack for Microsoft SQL Server 2000 or Microsoft MSDE from
//  http://www.microsoft.com/sql/downloads/default.asp
//
#define ID_SQL_PORTS_DISABLED            ((DWORD)0x40000001L)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\acrobat5.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Acrobat5.cpp

 Abstract:

   Blow off calls to SetWindowPos() w/ bogus coordinates to 
   prevent the app from erronously turning its window into a
   small sasauge in the upper left-hand corner of the screen.

 Notes:

    This is an app specific shim.

 History:

    07/9/2001  reinerf    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Acrobat5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowPos) 
APIHOOK_ENUM_END


BOOL
APIHOOK(SetWindowPos)(
  HWND hWnd,             // handle to window
  HWND hWndInsertAfter,  // placement-order handle
  int X,                 // horizontal position
  int Y,                 // vertical position
  int cx,                // width
  int cy,                // height
  UINT uFlags            // window-positioning options
)
{
    if (!(uFlags & (SWP_NOSIZE | SWP_NOMOVE)))
    {
        HWND hWndParent = GetParent(hWnd);
        
        if ((hWndParent == NULL) ||
            (hWndParent == GetDesktopWindow()))
        {
            if ((X < -3200) || 
                (Y < -3200))
            {
                // a toplevel window is being poorly positioned, ignore the call.
                DPFN( eDbgLevelInfo, "SetWindowPos passed bogus coordinates (X = %d, Y = %d), failing the call\n", X, Y);
                return FALSE;
            }
        }
    }

    return ORIGINAL_API(SetWindowPos)(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowPos)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\adobelivemotion.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    AdobeLiveMotion.cpp

 Abstract:

    This installation has a version problem that is corrected
    by the MSI transform but later has a problem with it's custom action
    DLL.It calls one of the MSI API's with invalid parameters.

 Notes:

    This is specific to this app.

 History:

    05/15/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AdobeLiveMotion)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MsiGetPropertyA)  
    APIHOOK_ENUM_ENTRY(MsiGetPropertyW)  
APIHOOK_ENUM_END

/*++

    Pass valid parameters to the API.

--*/

UINT
APIHOOK(MsiGetPropertyA)(
    MSIHANDLE hInstall,
    LPCSTR szName,
    LPSTR szValueBuf,
    DWORD *pchValueBuf)
{
    char szTempBuf[] = "";

    int len = (*pchValueBuf) ?(int)(*pchValueBuf) : MAX_PATH;
    if ((szValueBuf == NULL) || IsBadStringPtrA(szValueBuf,(UINT_PTR)len))
    {
        // If the string pointer is bad, send our empty string in
        szValueBuf = szTempBuf;
        *pchValueBuf = 0;
    }
    
    return ORIGINAL_API(MsiGetPropertyA)(hInstall,szName,szValueBuf,pchValueBuf);

}

/*++



--*/

UINT
APIHOOK(MsiGetPropertyW)(
    MSIHANDLE hInstall,
    LPCWSTR szName,
    LPWSTR szValueBuf,
    DWORD *pchValueBuf)
{
    WCHAR szTempBuf[] = L"";

    int len = (*pchValueBuf) ?(int)(*pchValueBuf) : MAX_PATH;
    if ((szValueBuf == NULL) || IsBadStringPtr(szValueBuf,(UINT_PTR)len))
    {
        // If the string pointer is bad, send our empty string in
        szValueBuf = szTempBuf;
        *pchValueBuf = 0;
    }
    
    return ORIGINAL_API(MsiGetPropertyW)(hInstall,szName,szValueBuf,pchValueBuf);

}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSI.DLL, MsiGetPropertyA)
    APIHOOK_ENTRY(MSI.DLL, MsiGetPropertyW)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\aliensvspredator.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AliensVsPredator.cpp

 Abstract:

    The app calls a Bink API to outside of a BinkOpen/BinkClose call. This is 
    a synchronization issue fixed by delaying the BinkClose call.

 Notes:

    This is an app specific shim.


 History:
        
    01/12/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AliensVsPredator)
#include "ShimHookMacro.h"

typedef DWORD (WINAPI *_pfn_BinkOpen)(DWORD dw1, DWORD dw2);
typedef BOOL  (WINAPI *_pfn_BinkClose)(DWORD dw1);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(BinkOpen) 
    APIHOOK_ENUM_ENTRY(BinkClose) 
APIHOOK_ENUM_END

DWORD g_dwLast = 0;
BOOL g_bReal = FALSE;

/*++

 Close the last handle.

--*/

DWORD
APIHOOK(BinkOpen)(
    DWORD dw1,              
    DWORD dw2
    )
{
    if (g_dwLast)
    {
        DPFN( eDbgLevelInfo, "Closing most recent Bink handle");
        g_bReal = TRUE;
        ORIGINAL_API(BinkClose)(g_dwLast);
        g_bReal = FALSE;
        g_dwLast = 0;
    }

    return ORIGINAL_API(BinkOpen)(dw1, dw2);
}

/*++

 Cache the handle

--*/

BOOL
APIHOOK(BinkClose)(
    DWORD dw1
    )
{
    if (g_bReal)
    {
        return ORIGINAL_API(BinkClose)(dw1);
    }
    else
    {
        DPFN( eDbgLevelInfo, "Delaying BinkClose");
        g_dwLast = dw1;
        return 1;
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_NAME(BINKW32.DLL, BinkOpen, _BinkOpen@8)
    APIHOOK_ENTRY_NAME(BINKW32.DLL, BinkClose, _BinkClose@4)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\afterdark.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AfterDark.cpp

 Abstract:

    This shim hooks SystemParametersInfo and when SPI_SETSCREENSAVEACTIVE is
    passed in with FALSE as its argument, the shim only deletes the 
    SCRNSAVE.EXE value which sets the "None" screen saver option instead of 
    setting ScreenSaverActive to 0 as well, which completely disables 
    screen savers (with no recovery UI).

 History:

    08/07/2000 t-adams   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AfterDark)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SystemParametersInfoA) 
APIHOOK_ENUM_END

/*++

  Abstract:

    This shim hooks SystemParametersInfoA and when SPI_SETSCREENSAVEACTIVE is
    passed in with FALSE as its argument, the shim only deletes the 
    SCRNSAVE.EXE value which sets the "None" screen saver option instead of 
    setting ScreenSaverActive to 0 as well, which completely disables 
    screen savers (with no recovery UI).

  History:

    08/07/2000    t-adams     Created

--*/

BOOL
APIHOOK(SystemParametersInfoA)(
    UINT uiAction,
    UINT uiParam, 
    PVOID pvParam,
    UINT fWinIni
    )  
{
    HKEY hKey = 0;
    BOOL bRet = FALSE;
    
    if (SPI_SETSCREENSAVEACTIVE == uiAction && FALSE == uiParam) 
    {
        LOGN( eDbgLevelError, "[APIHook_SystemParametersInfo] Attempt to disable screen savers - correcting");

        if (RegOpenKeyExW(HKEY_CURRENT_USER, L"Control Panel\\Desktop", 0, KEY_WRITE, &hKey)
                == ERROR_SUCCESS) 
        {
            RegDeleteValueW(hKey, L"SCRNSAVE.EXE");
            RegCloseKey(hKey);
            bRet = TRUE;
            goto exit;
        } 
        else 
        {
            goto exit;
        }
    } 
    else 
    {
        bRet = ORIGINAL_API(SystemParametersInfoA)(uiAction, uiParam, pvParam, fWinIni);
        goto exit;
    }

exit:
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SystemParametersInfoA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\aolfindbundledinstaller_aolcode.cpp ===
//-----------------------------------------------------------------------------
//                         America Online for Windows
//-----------------------------------------------------------------------------
// Copyright (c) 1987-2001 America Online, Inc.  All rights reserved.  This
// software contains valuable confidential and proprietary information of
// America Online and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission, or distribution of this file and
// its contents is a violation of applicable laws.
//-----------------------------------------------------------------------------
// $Workfile: AOLInstall.cpp $ $Author: RobrtLarson $
// $Date: 05/02/01 $
//-----------------------------------------------------------------------------

#include "precomp.h"

#include <Softpub.h>
#include <WinCrypt.h>
#include <WinTrust.h>
#include <ImageHlp.h>

#include "AOLFindBundledInstaller_AOLCode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  SWAPWORDS(x)   (((x) << 16) | ((x) >> 16))

// define encoding method
#define ENCODING (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING)

#define INSTALLER      0x0001
#define CLIENT         0x0002
#define COUNTRY_PICKER 0x0004
#define SERVICE_AOL    0x0010
#define SERVICE_CS     0x0020

// Local function prototypes
BOOL GetExeType(LPSTR lpszExePath, WORD &wExeType);
BOOL ExtractCertificateInfo(LPSTR lpszFileName, HCERTSTORE *hCertStore);
PCCERT_CONTEXT WINAPI CryptGetSignerCertificateCallback(void *pvGetArg,
        DWORD dwCertEncodingType, PCERT_INFO pSignerId, HCERTSTORE hCertStore);
BOOL CheckCertificateName(HCERTSTORE hCertStore);
LPSTR GetCommonName(CERT_NAME_BLOB pCertNameBlob);
BOOL VerifyFileInfo(WORD &ExeType, LPSTR lpszInstaller, PBOOL pbOldClient);
BOOL VerifyCertificate(LPSTR lpszInstaller);

_pfn_CertCloseStore g_pfn_CertCloseStore = NULL;
_pfn_CryptVerifyMessageSignature g_pfn_CryptVerifyMessageSignature = NULL;
_pfn_ImageGetCertificateData g_pfn_ImageGetCertificateData = NULL;
_pfn_ImageGetCertificateHeader g_pfn_ImageGetCertificateHeader = NULL;
_pfn_CertGetSubjectCertificateFromStore g_pfn_CertGetSubjectCertificateFromStore = NULL;
_pfn_CertDuplicateStore g_pfn_CertDuplicateStore = NULL;
_pfn_CertEnumCertificatesInStore g_pfn_CertEnumCertificatesInStore = NULL;
_pfn_CertRDNValueToStrA g_pfn_CertRDNValueToStrA = NULL;
_pfn_CertFindRDNAttr g_pfn_CertFindRDNAttr = NULL;
_pfn_CryptDecodeObject g_pfn_CryptDecodeObject = NULL;
_pfn_VerQueryValueA g_pfn_VerQueryValueA = NULL;
_pfn_GetFileVersionInfoA g_pfn_GetFileVersionInfoA = NULL;
_pfn_GetFileVersionInfoSizeA g_pfn_GetFileVersionInfoSizeA = NULL;
_pfn_WinVerifyTrust g_pfn_WinVerifyTrust = NULL;

HMODULE g_hCRYPT32    = NULL;
HMODULE g_hWINTRUST   = NULL;
HMODULE g_hVERSION    = NULL;
HMODULE g_hIMAGEHLP   = NULL;

void UnloadDependencies()
{
    g_pfn_CertCloseStore = NULL;
    g_pfn_CryptVerifyMessageSignature = NULL;
    g_pfn_ImageGetCertificateData = NULL;
    g_pfn_ImageGetCertificateHeader = NULL;
    g_pfn_CertGetSubjectCertificateFromStore = NULL;
    g_pfn_CertDuplicateStore = NULL;
    g_pfn_CertEnumCertificatesInStore = NULL;
    g_pfn_CertRDNValueToStrA = NULL;
    g_pfn_CertFindRDNAttr = NULL;
    g_pfn_CryptDecodeObject = NULL;
    g_pfn_VerQueryValueA = NULL;
    g_pfn_GetFileVersionInfoA = NULL;
    g_pfn_GetFileVersionInfoSizeA = NULL;
    g_pfn_WinVerifyTrust = NULL;

    if (g_hCRYPT32) {
        FreeLibrary(g_hCRYPT32);
        g_hCRYPT32 = NULL;
    }

    if (g_hWINTRUST) {
        FreeLibrary(g_hWINTRUST);
        g_hWINTRUST = NULL;
    }

    if (g_hVERSION) {
        FreeLibrary(g_hVERSION);
        g_hVERSION = NULL;
    }

    if (g_hIMAGEHLP) {
        FreeLibrary(g_hIMAGEHLP);
        g_hIMAGEHLP = NULL;
    }
}

BOOL LoadDependencies()
{
    BOOL bSuccess = FALSE;

    if (!(g_hCRYPT32 = LoadLibraryA("CRYPT32.DLL"))) {
        goto eh;
    }

    if (!(g_hWINTRUST = LoadLibraryA("WINTRUST.DLL"))) {
        goto eh;
    }

    if (!(g_hVERSION = LoadLibraryA("VERSION.DLL"))) {
        goto eh;
    }

    if (!(g_hIMAGEHLP = LoadLibraryA("IMAGEHLP.DLL"))) {
        goto eh;
    }

    if (!(g_pfn_CertCloseStore = (_pfn_CertCloseStore) GetProcAddress(g_hCRYPT32, "CertCloseStore"))) { goto eh; }
    if (!(g_pfn_CryptVerifyMessageSignature = (_pfn_CryptVerifyMessageSignature) GetProcAddress(g_hCRYPT32, "CryptVerifyMessageSignature"))) { goto eh; }
    if (!(g_pfn_ImageGetCertificateData = (_pfn_ImageGetCertificateData) GetProcAddress(g_hIMAGEHLP, "ImageGetCertificateData"))) { goto eh; }
    if (!(g_pfn_ImageGetCertificateHeader = (_pfn_ImageGetCertificateHeader) GetProcAddress(g_hIMAGEHLP, "ImageGetCertificateHeader"))) { goto eh; }
    if (!(g_pfn_CertGetSubjectCertificateFromStore = (_pfn_CertGetSubjectCertificateFromStore) GetProcAddress(g_hCRYPT32, "CertGetSubjectCertificateFromStore"))) { goto eh; }
    if (!(g_pfn_CertDuplicateStore = (_pfn_CertDuplicateStore) GetProcAddress(g_hCRYPT32, "CertDuplicateStore"))) { goto eh; }
    if (!(g_pfn_CertEnumCertificatesInStore = (_pfn_CertEnumCertificatesInStore) GetProcAddress(g_hCRYPT32, "CertEnumCertificatesInStore"))) { goto eh; }
    if (!(g_pfn_CertRDNValueToStrA = (_pfn_CertRDNValueToStrA) GetProcAddress(g_hCRYPT32, "CertRDNValueToStrA"))) { goto eh; }
    if (!(g_pfn_CertFindRDNAttr = (_pfn_CertFindRDNAttr) GetProcAddress(g_hCRYPT32, "CertFindRDNAttr"))) { goto eh; }
    if (!(g_pfn_CryptDecodeObject = (_pfn_CryptDecodeObject) GetProcAddress(g_hCRYPT32, "CryptDecodeObject"))) { goto eh; }
    if (!(g_pfn_VerQueryValueA = (_pfn_VerQueryValueA) GetProcAddress(g_hVERSION, "VerQueryValueA"))) { goto eh; }
    if (!(g_pfn_GetFileVersionInfoA = (_pfn_GetFileVersionInfoA) GetProcAddress(g_hVERSION, "GetFileVersionInfoA"))) { goto eh; }
    if (!(g_pfn_GetFileVersionInfoSizeA = (_pfn_GetFileVersionInfoSizeA) GetProcAddress(g_hVERSION, "GetFileVersionInfoSizeA"))) { goto eh; }
    if (!(g_pfn_WinVerifyTrust = (_pfn_WinVerifyTrust) GetProcAddress(g_hWINTRUST, "WinVerifyTrust"))) { goto eh; }

    bSuccess = TRUE;

eh:
    if (!bSuccess) {
        UnloadDependencies();
    }

    return bSuccess;
}   

//-----------------------------------------------------------------------------
// LocateInstaller
//    This functions searches for a valid AOL or CompuServe install program
//    based on the default value found in a registry key. This install program
//    is then validated by checking the Certificates and verifying that the
//    program file has not been modified since being signed by America Online.
//
//    AOL Registry Key:
//       HKLM\Software\America Online\Installers
//
//    CompuServe Registry Key:
//       HKLM\Software\CompuServe\Installers
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR lpszInstaller            Returned installer command line,
//                                   NULL if no valid installer located
//                                   Note: allowance should be made in the
//                                   length of this string for an optional
//                                   parameter on the command line of MAX_PATH
//                                   length.
//    UINT uiPathSize                Length of lpszInstaller parameter
//    BOOL *pbMessage                TRUE - display App Compat message
//                                   FALSE - do not display App Compat message
//-----------------------------------------------------------------------------
BOOL LocateInstaller_Internal(LPSTR lpszInstaller, UINT uiPathSize, BOOL *pbMessage)
{
    BOOL  bResult = FALSE,
          bCheckCert = TRUE,
          bOldClient = FALSE;
    HKEY  hKey;
    LONG  lRet;
    CHAR  szModuleName[MAX_PATH];
    WORD  wExeType = 0;

    // Default to no App Compat message
    *pbMessage = FALSE;

    // Get the name of the file that is executing
    DWORD dwLen = GetModuleFileNameA(NULL, szModuleName, sizeof(szModuleName));
    if (0 == dwLen)
    { return FALSE; }

    // Determine the type of exe this is
    bResult = GetExeType(szModuleName, wExeType);
    if (bResult)
    {
        // Check if this is the uninstaller calling the client
        if ((CLIENT & wExeType) && (NULL != strstr(_strlwr(GetCommandLineA()), "regall")))
        { return FALSE; }

        // If the program we are running is valid, then let it run
        if (VerifyFileInfo(wExeType, szModuleName, &bOldClient))
        { return FALSE; }

        // If this is an client <= 4.0 then display message if not bundled installer found
        if (bOldClient)
        { *pbMessage = TRUE; }

        // Open registry key
        if (SERVICE_AOL & wExeType)
        {
            lRet = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                    "Software\\America Online\\Installers", &hKey);
        }
        else if (SERVICE_CS & wExeType)
        {
            lRet = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                    "Software\\CompuServe\\Installers", &hKey);
        }
        else
        { return FALSE; }    // Don't know what this is

        if (ERROR_SUCCESS != lRet)
        { return FALSE; }        // No bundled version of AOL/CS located in registry

        // Get size of registry key data
        ULONG  cbSize;
        DWORD  dwType;
        lRet = RegQueryValueExA(hKey, NULL, NULL, &dwType, NULL, &cbSize);
        if ((ERROR_SUCCESS != lRet) ||
             (cbSize > uiPathSize)  ||
             (REG_SZ != dwType))
        {
           RegCloseKey(hKey);
           return FALSE;
        }

        // See if we need to check the certificate for the installer
        lRet = RegQueryValueExA(hKey, "CC", NULL, &dwType, NULL, &cbSize);
        if ((ERROR_SUCCESS == lRet) && (cbSize > 0))
        { bCheckCert = FALSE; }

        lpszInstaller[0] = '\"';
        // Get registry key data
        cbSize = uiPathSize - 1;
        lRet = RegQueryValueExA(hKey, NULL, NULL, NULL, (UCHAR *)&lpszInstaller[1], &cbSize);

        RegCloseKey(hKey);
        if (ERROR_SUCCESS == lRet)
        {
            // Check for correct installer version
            bResult = VerifyFileInfo(wExeType, &lpszInstaller[1], NULL);
            if (bResult && bCheckCert)
            {
                // Get certificate store
                HCERTSTORE  hCertStore = NULL;
                bResult = ExtractCertificateInfo(&lpszInstaller[1], &hCertStore);
                if (bResult)
                {
                    // Check certificates for AOL/CS signature
                    bResult = CheckCertificateName(hCertStore);
                    if (bResult)
                    {
                        // Check that file has not been modified
                        bResult = VerifyCertificate(&lpszInstaller[1]);
                    }
                }

                // Close the certificate store
                if (NULL != hCertStore)
                { (*g_pfn_CertCloseStore)(hCertStore, CERT_CLOSE_STORE_FORCE_FLAG); }
            }
        }
    }

    if (bResult)
    {
        StringCchCatA(lpszInstaller, uiPathSize, "\"");
        // Check if Message should be displayed to user
        if (CLIENT & wExeType)
        { *pbMessage = TRUE; }
        else
        {
            // Add command line parameter
            if (COUNTRY_PICKER & wExeType)
            {
                StringCchPrintfA(lpszInstaller, uiPathSize, "%s -p \"%s\"", lpszInstaller, szModuleName);                
            }
        }
    }
    else
    { lpszInstaller[0] = '\0'; }

    return bResult;
}

BOOL LocateInstaller(LPSTR lpszInstaller, UINT uiPathSize, BOOL *pbMessage)
{
    BOOL bSuccess = FALSE;
    if (!LoadDependencies()) {
        goto eh;
    }

    if (!LocateInstaller_Internal(lpszInstaller, uiPathSize, pbMessage)) {
        goto eh;
    }

    bSuccess = TRUE;
eh:
    UnloadDependencies();    

    return bSuccess;
}

//-----------------------------------------------------------------------------
// GetExeType
//    This functions determines whether the executible is an AOL/CS client or
//    and AOL/CS installer.
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR lpszExePath         Fully qualified path to executible
//    WORD &wExeType            Returned executible type
//                                  AOL or CS
//                                  Client or Installer
//-----------------------------------------------------------------------------
BOOL GetExeType(LPSTR lpszExePath, WORD &wExeType)
{
    // Set string to lower case for comparisons
    _strlwr(lpszExePath);

    BOOL bSuccess = FALSE;
    LPSTR pszTemp = strrchr(lpszExePath, '\\');
    if (NULL == pszTemp)
    { return FALSE; }

    pszTemp++;        // Get to beginning of exe name

    // Determine if this is an AOL/CS client
    if (0 == _stricmp(pszTemp, "waol.exe"))
    {
        wExeType = SERVICE_AOL | CLIENT;
        return TRUE;
    }
    else if ((0 == _stricmp(pszTemp, "wcs2000.exe")) || 
            (0 == _stricmp(pszTemp, "cs3.exe"))) 
    {
        wExeType = SERVICE_CS | CLIENT;
        return TRUE;
    }
    else if ((NULL != strstr(pszTemp, "cs2000"))      ||
             (NULL != strstr(pszTemp, "setupcs2k"))   ||
             (NULL != strstr(pszTemp, "setupcs2000")) ||
             (0 == _stricmp(pszTemp, "d41000b.exe"))  ||
             (0 == _stricmp(pszTemp, "d41510b.exe"))  ||
             (0 == _stricmp(pszTemp, "d41540b.exe")))
    {
        // These are CS installers w/ "America Online, Inc." in version info.
        wExeType = SERVICE_CS | INSTALLER;
        return TRUE; 
    } 
    else if (0 == _stricmp(pszTemp, "wgw.exe"))
    { return FALSE; }       // There is no bundled installer for Gateway
    else if (0 == _stricmp(pszTemp, "wwm.exe"))
    { return FALSE; }       // There is no bundled installer for Wal-Mart

    // Determine AOL/CS installer

    // Get size of version info in file
    DWORD  dwHandle = 0;
    DWORD  dwVerInfoSize = (*g_pfn_GetFileVersionInfoSizeA)(lpszExePath, &dwHandle);

    // Allocate memory for version info
    BYTE *lpVerInfo = NULL;
    __try
    {
        lpVerInfo = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwVerInfoSize);
        if (NULL == lpVerInfo)
        { __leave; }

        // Get version info from file
        BOOL bResult = (*g_pfn_GetFileVersionInfoA)(lpszExePath, NULL, dwVerInfoSize, lpVerInfo);
        if (!bResult)
        { __leave; }

        // Get Language code page
        DWORD  *pdwTrans;
        UINT    uiBytes;
        DWORD dwLangCodepage = 0;

        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, "\\VarFileInfo\\Translation", (VOID **)&pdwTrans, &uiBytes);
        if (bResult)
        { dwLangCodepage = SWAPWORDS(*pdwTrans); }  // Translate language code page to something we can use
        else
        { dwLangCodepage = 0x040904e4; }     // Try English multilanguage code page

        // Obtain the "CompanyName" from the version info
        CHAR   szQuery[MAX_PATH];
        PCHAR  pszVerInfo;
        StringCchPrintfA(szQuery, MAX_PATH,"\\StringFileInfo\\%08X\\CompanyName", dwLangCodepage);
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, szQuery, (VOID **)&pszVerInfo, &uiBytes);
        if (!bResult)
        { __leave; }

        // Check "CompanyName"
        if ((NULL != strstr(pszVerInfo, "America Online")) ||
             (NULL != strstr(pszVerInfo, "AOL")))
        {
            wExeType = SERVICE_AOL | INSTALLER;
            bSuccess = TRUE;
            __leave;
        }
        if (0 == strcmp("CompuServe Interactive Services, Inc.", pszVerInfo))
        {
            wExeType = SERVICE_CS | INSTALLER;
            bSuccess = TRUE;
            __leave;
        }
    }
    __finally
    {
        if (NULL != lpVerInfo)
        { HeapFree(GetProcessHeap(), 0, lpVerInfo); }
    }

    return bSuccess;
}

//-----------------------------------------------------------------------------
// ExtractCertificateInfo
//    This functions obtains and verifies the certificate store for the
//    installer.
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR  lpszFileName       Fully qualified path to installer
//    HCERTSTORE  *hCertStore   Handle to the certificate store
//-----------------------------------------------------------------------------
BOOL ExtractCertificateInfo(LPSTR lpszFileName, HCERTSTORE *hCertStore)
{
    WIN_CERTIFICATE CertificateHeader;
    LPWIN_CERTIFICATE pbCertificate = NULL;
    BOOL bResult = FALSE;
    HANDLE hFile = NULL;
    DWORD dwSize;
    CRYPT_VERIFY_MESSAGE_PARA CryptVerifyMessagePara;

    __try
    {
        // Open file
        hFile = CreateFileA(lpszFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE)
        { __leave; }

        // Get Certificate Header
        bResult = (*g_pfn_ImageGetCertificateHeader)(hFile, 0, &CertificateHeader);
        if (!bResult)
        { __leave; }

        // Allocate Memory for Certificate Blob
        pbCertificate = (LPWIN_CERTIFICATE)HeapAlloc(GetProcessHeap(), 0,
                CertificateHeader.dwLength);
        if (NULL == pbCertificate)
        {
            bResult = FALSE;
            __leave;
        }

        // Get Certificate Blob
        dwSize = CertificateHeader.dwLength;
        bResult = (*g_pfn_ImageGetCertificateData)(hFile, 0, pbCertificate, &dwSize);
        if (!bResult)
        { __leave; }

        // Zero out CRYPT_VERIFY_MESSAGE_PARA structure
        ZeroMemory(&CryptVerifyMessagePara, sizeof(CryptVerifyMessagePara));

        CryptVerifyMessagePara.cbSize = sizeof(CryptVerifyMessagePara);
        CryptVerifyMessagePara.dwMsgAndCertEncodingType = ENCODING;
        CryptVerifyMessagePara.pfnGetSignerCertificate = CryptGetSignerCertificateCallback;

        // Pass Address of certificate store to callback
        CryptVerifyMessagePara.pvGetArg = (LPVOID)hCertStore;

        // Verify the message and call callback
        bResult = (*g_pfn_CryptVerifyMessageSignature)(&CryptVerifyMessagePara, 0,
                pbCertificate->bCertificate, dwSize, NULL, NULL, NULL);
    }
    __finally
    {
        if (NULL != pbCertificate)
        { HeapFree(GetProcessHeap(), 0, pbCertificate); }

        if (NULL != hFile)
        { CloseHandle(hFile); }
    }

    return bResult;
}

//-----------------------------------------------------------------------------
// CryptGetSignerCertificateCallback
//    This functions is the callback function for CryptVerifyMessageSignature.
//-----------------------------------------------------------------------------
// Function parameters:
//    See MicroSoft documentation for details.
//-----------------------------------------------------------------------------
PCCERT_CONTEXT WINAPI CryptGetSignerCertificateCallback(void *pvGetArg,
        DWORD dwCertEncodingType, PCERT_INFO pSignerId, HCERTSTORE hCertStore)
{
    if (NULL == hCertStore)
    { return FALSE; }

    *((HCERTSTORE *)pvGetArg) = (*g_pfn_CertDuplicateStore)(hCertStore);

    return (*g_pfn_CertGetSubjectCertificateFromStore)(hCertStore, dwCertEncodingType,
            pSignerId);
}

//-----------------------------------------------------------------------------
// CheckCertificateName
//    This functions checks the certificate name to verify that it is signed by
//    America Online.
//-----------------------------------------------------------------------------
// Function parameters:
//    HCERTSTORE hCertStore   Handle to the certificate store
//-----------------------------------------------------------------------------
BOOL CheckCertificateName(HCERTSTORE hCertStore)
{
    BOOL bReturn = FALSE;
    PCCERT_CONTEXT pCertContext = NULL;
    PCCERT_CONTEXT pPrevContext = NULL;
    LPSTR szSubject = NULL;

    if (NULL != hCertStore)
    {
        do
        {
            pCertContext = (*g_pfn_CertEnumCertificatesInStore)(hCertStore, pPrevContext);

            if (NULL != pCertContext)
            {
                // Get Subject common name, if not then get organization name
                szSubject = GetCommonName(pCertContext->pCertInfo->Subject);
                if (NULL != szSubject)
                {
                    // Check name of certificate signer
                    if (0 == strcmp(szSubject, "America Online, Inc."))
                    { bReturn = TRUE; }

                    HeapFree(GetProcessHeap(), 0, szSubject);
                }

                pPrevContext = pCertContext;
            }
        } while (pCertContext);
    }

    return bReturn;
}

//-----------------------------------------------------------------------------
// GetCommonName
//    This functions obtains the common name from the certificate store
//-----------------------------------------------------------------------------
// Function parameters:
//    CERT_NAME_BLOB pCertNameBlob   Pointer to the blob that contains the name
//-----------------------------------------------------------------------------
LPSTR GetCommonName(CERT_NAME_BLOB pCertNameBlob)
{
    BOOL bReturn = FALSE;
    BOOL bResult;
    PCERT_NAME_INFO pCertName = NULL;
    PCERT_RDN_ATTR pCertAttr;
    LPSTR szName = NULL;
    DWORD dwSize;

    __try
    {
        // Find out size of decrypted blob
        (*g_pfn_CryptDecodeObject)(ENCODING, X509_NAME, pCertNameBlob.pbData,
                pCertNameBlob.cbData, 0, NULL, &dwSize);

        // Allocate memory for decrypted blob
        pCertName = (PCERT_NAME_INFO)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (NULL == pCertName)
        { __leave; }

        // Decode the certificate blob
        bResult = (*g_pfn_CryptDecodeObject)(ENCODING, X509_NAME, pCertNameBlob.pbData,
                pCertNameBlob.cbData, 0, pCertName, &dwSize);
        if (!bResult)
        { __leave; }

        // Get common name
        pCertAttr = (*g_pfn_CertFindRDNAttr)(szOID_COMMON_NAME, pCertName);
        if (NULL == pCertAttr)
        {
            // Get organization name if no common name found
            pCertAttr = (*g_pfn_CertFindRDNAttr)(szOID_ORGANIZATION_NAME, pCertName);
            if (NULL == pCertAttr)
            { __leave; }
        }

        // Find out size of name
        dwSize = (*g_pfn_CertRDNValueToStrA)(pCertAttr->dwValueType, &pCertAttr->Value, NULL, 0);

        // Allocate memory for name
        szName = (LPSTR)HeapAlloc(GetProcessHeap(), 0, dwSize);
        if (NULL == szName)
        { __leave; }

        // Obtain name from decrypted blob
        (*g_pfn_CertRDNValueToStrA)(pCertAttr->dwValueType, &pCertAttr->Value, szName, dwSize);
        bReturn = TRUE;
    }
    __finally
    {
        if (NULL != pCertName)
        { HeapFree(GetProcessHeap(), 0, pCertName); }

        if (!bReturn)
        {
            if (NULL != szName)
            { HeapFree(GetProcessHeap(), 0, szName); }
        }
    }

    if (bReturn)
    { return szName; }
    else
    { return NULL; }
}

//-----------------------------------------------------------------------------
// VerifyFileInfo
//    This functions verifies that the installer is valid based on the version
//    information stored in the file.
//-----------------------------------------------------------------------------
// Function parameters:
//    INSTALLER_TYPE InstallerType   Specifies whether to look for AOL or CS
//    LPSTR lpszInstaller            Fully qualified path to installer
//    PBOOL pbOldClient              Is is a client older then 5.0
//-----------------------------------------------------------------------------
BOOL VerifyFileInfo(WORD &wExeType, LPSTR lpszInstaller, PBOOL pbOldClient)
{
    BOOL  bReturn = FALSE;
    BOOL  bResult;
    BYTE *lpVerInfo = NULL;

    __try
    {
        // Get size of version info in file
        DWORD  dwHandle = 0;
        DWORD  dwVerInfoSize = (*g_pfn_GetFileVersionInfoSizeA)(lpszInstaller, &dwHandle);

        // Allocate memory for version info
        lpVerInfo = (BYTE *)HeapAlloc(GetProcessHeap(), 0, dwVerInfoSize);
        if (NULL == lpVerInfo)
        { __leave; }

        // Get version info from file
        bResult = (*g_pfn_GetFileVersionInfoA)(lpszInstaller, NULL, dwVerInfoSize, lpVerInfo);
        if (!bResult)
        { __leave; }

        // Get Language code page
        DWORD  *pdwTrans;
        UINT    uiBytes;
        DWORD dwLangCodepage = 0;

        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, "\\VarFileInfo\\Translation", (VOID **)&pdwTrans, &uiBytes);
        if (bResult)
        { dwLangCodepage = SWAPWORDS(*pdwTrans); }  // Translate language code page to something we can use
        else
        { dwLangCodepage = 0x040904e4; }     // Try English multilanguage code page

        // Obtain the "CompanyName" from the version info
        CHAR   szQuery[MAX_PATH];
        PCHAR  pszVerInfo;
        StringCchPrintfA(szQuery, MAX_PATH, "\\StringFileInfo\\%08X\\CompanyName", dwLangCodepage);
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, szQuery, (VOID **)&pszVerInfo, &uiBytes);
        if (!bResult)
        { __leave; }

        // Check "CompanyName"
        if (SERVICE_AOL & wExeType)
        {
            if ((NULL == strstr(pszVerInfo, "America Online")) && 
               (NULL == strstr(pszVerInfo, "AOL"))) 
            { __leave; }
        }
        else if (SERVICE_CS & wExeType)
        {
            if (0 != strcmp("CompuServe Interactive Services, Inc.", pszVerInfo))
            { __leave; }
        }
        else
        { __leave; }

        // Get fixed file info
        VS_FIXEDFILEINFO* pVS_FFI;
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, "\\", (VOID **)&pVS_FFI, &uiBytes);
        if (!bResult)
        { __leave; }

        // Check if this is the Country Picker
        StringCchPrintfA(szQuery, MAX_PATH, "\\StringFileInfo\\%08X\\ProductName", dwLangCodepage);
        bResult = (*g_pfn_VerQueryValueA)(lpVerInfo, szQuery, (VOID **)&pszVerInfo, &uiBytes);
        if ((bResult) && (NULL != strstr(pszVerInfo, "Country Picker")))
        {
            wExeType |= COUNTRY_PICKER;
            if (0x00010005 > pVS_FFI->dwProductVersionMS)
            { __leave; }
        }
        else
        {
            if ((0x00060000 > pVS_FFI->dwProductVersionMS)   ||
                ((0x00060000 >= pVS_FFI->dwProductVersionMS) &&
                 (0x00020000 > pVS_FFI->dwProductVersionLS)))
            {
                if ((NULL != pbOldClient) &&
                    (CLIENT & wExeType) &&
                    (0x00050000 > pVS_FFI->dwProductVersionMS))
                { *pbOldClient = TRUE; }

                __leave;
            }
        }

        bReturn = TRUE;
    }
    __finally
    {
        if (NULL != lpVerInfo)
        { HeapFree(GetProcessHeap(), 0, lpVerInfo); }
    }

    return bReturn;
}

//-----------------------------------------------------------------------------
// VerifyCertificate
//    This functions verifies that the install has not been modified since
//    being signed by America Online.
//-----------------------------------------------------------------------------
// Function parameters:
//    LPSTR lpszInstaller            Fully qualified path to installer
//-----------------------------------------------------------------------------
BOOL VerifyCertificate(LPSTR lpszInstaller) 
{
    GUID ActionGUID = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID SubjectPeImage = WIN_TRUST_SUBJTYPE_PE_IMAGE;

    WIN_TRUST_SUBJECT_FILE Subject;

    // Subject.lpPath is a WCHAR string, must convert
    LPWSTR  lpwszInstaller = NULL;
    int     cchUnicodeSize = 0;
    cchUnicodeSize = MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS,
            lpszInstaller, -1, NULL, 0);

    lpwszInstaller = (LPWSTR)malloc(cchUnicodeSize * sizeof(WCHAR));

    if (0 == MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, lpszInstaller,
            -1, lpwszInstaller, cchUnicodeSize))
    {
        if (lpwszInstaller)
        { free(lpwszInstaller); }

        return FALSE;
    }

    Subject.lpPath = lpwszInstaller;
    Subject.hFile = INVALID_HANDLE_VALUE;      // Open the using the lpPath field

    WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ActionData;

    ActionData.Subject = &Subject;
    ActionData.hClientToken = NULL; 
                                    
    ActionData.SubjectType = &SubjectPeImage;

    // Verify the file has not be changed since being signed
    HRESULT hr = (*g_pfn_WinVerifyTrust)((HWND)INVALID_HANDLE_VALUE, &ActionGUID, (WINTRUST_DATA *) &ActionData);

    if (lpwszInstaller)
    { free(lpwszInstaller); }

    if (S_OK == hr)
    { return TRUE; }
    else
    { return FALSE; }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\aolfindbundledinstaller_aolcode.h ===
//-----------------------------------------------------------------------------
//                         America Online for Windows
//-----------------------------------------------------------------------------
// Copyright (c) 1987-2001 America Online, Inc.  All rights reserved.  This
// software contains valuable confidential and proprietary information of
// America Online and is subject to applicable licensing agreements.
// Unauthorized reproduction, transmission, or distribution of this file and
// its contents is a violation of applicable laws.
//-----------------------------------------------------------------------------
// $Workfile: AOLInstall.h $ $Author: RobrtLarson $
// $Date: 05/02/01 $
//-----------------------------------------------------------------------------

#if !defined(_AOLINSTALL_H__INCLUDED_)
#define _AOLINSTALL_H__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

BOOL LocateInstaller(PCHAR lpszAOLInstaller, UINT uiPathSize, BOOL *pbMessage);

#endif // !defined(_AOLINSTALL_H__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\aolrassetentryproperties.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AOLRasSetEntryProperties.cpp

 Abstract:

 History:
 
    05/03/2001 markder  Created

--*/

#include "precomp.h"
#include "ras.h"

IMPLEMENT_SHIM_BEGIN(AOLRasSetEntryProperties)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RasSetEntryPropertiesA)
    APIHOOK_ENUM_ENTRY(RasSetEntryPropertiesW)
APIHOOK_ENUM_END

#define RASENTRYW_V500 struct tagRASENTRYW_V500
RASENTRYW_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    WCHAR       szAreaCode[ RAS_MaxAreaCode + 1 ];
    WCHAR       szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    WCHAR       szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    WCHAR       szAutodialDll[ MAX_PATH ];
    WCHAR       szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    WCHAR       szDeviceType[ RAS_MaxDeviceType + 1 ];
    WCHAR       szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    WCHAR       szX25PadType[ RAS_MaxPadType + 1 ];
    WCHAR       szX25Address[ RAS_MaxX25Address + 1 ];
    WCHAR       szX25Facilities[ RAS_MaxFacilities + 1 ];
    WCHAR       szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)
    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // EncryptionType
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    WCHAR       szCustomDialDll[MAX_PATH];

    //
    // Vpn Strategy
    //
    DWORD       dwVpnStrategy;
#endif
};

#define RASENTRYA_V500 struct tagRASENTRYA_V500
RASENTRYA_V500
{
    DWORD       dwSize;
    DWORD       dwfOptions;
    //
    // Location/phone number.
    //
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    CHAR        szAreaCode[ RAS_MaxAreaCode + 1 ];
    CHAR        szLocalPhoneNumber[ RAS_MaxPhoneNumber + 1 ];
    DWORD       dwAlternateOffset;
    //
    // PPP/Ip
    //
    RASIPADDR   ipaddr;
    RASIPADDR   ipaddrDns;
    RASIPADDR   ipaddrDnsAlt;
    RASIPADDR   ipaddrWins;
    RASIPADDR   ipaddrWinsAlt;
    //
    // Framing
    //
    DWORD       dwFrameSize;
    DWORD       dwfNetProtocols;
    DWORD       dwFramingProtocol;
    //
    // Scripting
    //
    CHAR        szScript[ MAX_PATH ];
    //
    // AutoDial
    //
    CHAR        szAutodialDll[ MAX_PATH ];
    CHAR        szAutodialFunc[ MAX_PATH ];
    //
    // Device
    //
    CHAR        szDeviceType[ RAS_MaxDeviceType + 1 ];
    CHAR        szDeviceName[ RAS_MaxDeviceName + 1 ];
    //
    // X.25
    //
    CHAR        szX25PadType[ RAS_MaxPadType + 1 ];
    CHAR        szX25Address[ RAS_MaxX25Address + 1 ];
    CHAR        szX25Facilities[ RAS_MaxFacilities + 1 ];
    CHAR        szX25UserData[ RAS_MaxUserData + 1 ];
    DWORD       dwChannels;
    //
    // Reserved
    //
    DWORD       dwReserved1;
    DWORD       dwReserved2;
#if (WINVER >= 0x401)
    //
    // Multilink
    //
    DWORD       dwSubEntries;
    DWORD       dwDialMode;
    DWORD       dwDialExtraPercent;
    DWORD       dwDialExtraSampleSeconds;
    DWORD       dwHangUpExtraPercent;
    DWORD       dwHangUpExtraSampleSeconds;
    //
    // Idle timeout
    //
    DWORD       dwIdleDisconnectSeconds;
#endif

#if (WINVER >= 0x500)

    //
    // Entry Type
    //
    DWORD       dwType;

    //
    // Encryption type
    //
    DWORD       dwEncryptionType;

    //
    // CustomAuthKey to be used for EAP
    //
    DWORD       dwCustomAuthKey;

    //
    // Guid of the connection
    //
    GUID        guidId;

    //
    // Custom Dial Dll
    //
    CHAR        szCustomDialDll[MAX_PATH];

    //
    // DwVpnStrategy
    //
    DWORD       dwVpnStrategy;
#endif

};


DWORD APIHOOK(RasSetEntryPropertiesA)(
   LPCSTR lpszPhoneBook, 
   LPCSTR szEntry , 
   LPRASENTRYA lpbEntry, 
   DWORD dwEntrySize, 
   LPBYTE lpb, 
   DWORD dwSize )
{
    lpbEntry->dwSize = sizeof(RASENTRYA_V500);  // win2k version struct size

    return ORIGINAL_API(RasSetEntryPropertiesA)(
              lpszPhoneBook,
              szEntry,
              lpbEntry,
              dwEntrySize,
              lpb,
              dwSize);
}


DWORD APIHOOK(RasSetEntryPropertiesW)(
   LPCWSTR lpszPhoneBook, 
   LPCWSTR szEntry , 
   LPRASENTRYW lpbEntry, 
   DWORD dwEntrySize, 
   LPBYTE lpb, 
   DWORD dwSize )
{
    lpbEntry->dwSize = sizeof(RASENTRYW_V500);  // win2k version struct size

    return ORIGINAL_API(RasSetEntryPropertiesW)(
              lpszPhoneBook,
              szEntry,
              lpbEntry,
              dwEntrySize,
              lpb,
              dwSize);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(RASAPI32.DLL, RasSetEntryPropertiesA)    
    APIHOOK_ENTRY(RASAPI32.DLL, RasSetEntryPropertiesW)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\attune.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Attune.cpp

 Abstract:

    App uses counters that are obsolete since Win2k.
    
    App uses \System\% Total Processor Time counter instead of
    \Processor(_Total)\% Processor Time counter.
    
    This shim corrects the counter name before making a 
    call to PdhAddCounterA.
    
 Notes:

    This is an app specific shim.

 History:

    03/16/2001 a-leelat Created

--*/

#include "precomp.h"




IMPLEMENT_SHIM_BEGIN(Attune)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PdhAddCounterA)
APIHOOK_ENUM_END

/*++

 Hook PdhAddCounterA 

--*/
PDH_FUNCTION
APIHOOK(PdhAddCounterA)(
    IN      HQUERY      hQuery,
    IN      LPCSTR      szFullCounterPath,
    IN      DWORD_PTR   dwUserData,
    IN      HCOUNTER    *phCounter
)
{
    
    PDH_STATUS  ReturnStatus = ERROR_SUCCESS;
    BOOL        bCorrectedPath = false;
    CHAR        szCorrectCounterPath[] = "\\Processor(_Total)\\% Processor Time";
    
    CSTRING_TRY 
    {
        //Obsolete counter Path to check for
        CString szObsoleteCounterPath = "\\System\\% Total Processor Time";

        //Passed in counter Path
        CString szCounterPath(szFullCounterPath);

        //Check to see if we have the obolsete counter passed in
        if (szObsoleteCounterPath.CompareNoCase(szCounterPath.Get()) == 0)
            bCorrectedPath = true;
    }
    CSTRING_CATCH
    {
    }

    //Call the original API
    ReturnStatus = ORIGINAL_API(PdhAddCounterA)(
                   hQuery,
                   bCorrectedPath ? szCorrectCounterPath : szFullCounterPath,
                   dwUserData,
                   phCounter);

    return ReturnStatus;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(PDH.DLL, PdhAddCounterA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\aolsysteminfo.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    AOLSystemInfo.cpp

 Abstract:
    AOL looks to enumerate the registry key 
    HKLM\System\CurrentControlSet\Control\Class
    but passes a fixed size buffer. The number 
    of keys under 'Class' have changed in XP 
    causing unexpected behaviour.
   
 Notes:

    This is specific to this app.

 History:

    05/17/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AOLSystemInfo)
#include "ShimHookMacro.h"

#define ALLOC_SIZE 50

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA) 
APIHOOK_ENUM_END

/*++

    The idea here is to check for the buffer sizes and wait till it is 
    one size close to it and then allocate a buffer and pass it onto the
    API.

--*/

LONG
APIHOOK(RegEnumKeyExA)(
    HKEY hkey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcClass,
    PFILETIME lpftLastWriteTime
    )
{  
    LONG lRet = 0;
    static BOOL bSet = FALSE;    
    DWORD dwNameSize = *(lpcName) ? *(lpcName) : ALLOC_SIZE;

    // Get the difference in the passed buffer gap
    DWORD dwSize = (DWORD)((LPSTR)lpcName - lpName);
    if (!bSet && (dwSize <= dwNameSize))
    {
        bSet = TRUE;
    }

    if (bSet)
    {
        lpName = (LPSTR)HeapAlloc(GetProcessHeap(), 
                    HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY,
                    ALLOC_SIZE
                    );
        if (!lpName)
        {
            return ERROR_NO_MORE_ITEMS;
        }   
        *(lpcName) = dwNameSize;
    }


    lRet = ORIGINAL_API(RegEnumKeyExA)(hkey, dwIndex, lpName,lpcName,
                            lpReserved, lpClass, lpcClass, lpftLastWriteTime);        

    if (lRet == ERROR_NO_MORE_ITEMS)
    {
        bSet = FALSE;
    }
    return lRet;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\autocad.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    AutoCad.cpp

 Abstract:

    Prevent AV when IsEmptyRect is called with a bad pointer. This fixes a hard to 
    repro Watson bug.
    
 Notes:

    This is an app specific shim.

 History:

    02/13/2002 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(AutoCad)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(IsRectEmpty)
APIHOOK_ENUM_END

/*++

 IsEmptyRect 

--*/

BOOL
APIHOOK(IsRectEmpty)(
    CONST RECT *lprc
    )
{
    if (IsBadReadPtr(lprc, sizeof(RECT))) {
        LOGN(eDbgLevelInfo, "[IsRectEmpty] invalid lprc pointer, returning TRUE");
        return TRUE;
    }

    return ORIGINAL_API(IsRectEmpty)(lprc);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, IsRectEmpty)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\baanerp5.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    BaanERP5.cpp

 Abstract:

    Set 'lpstrInitialDir' in the OPENFILENAMEA structure passed to
    GetSaveFileNameA to be the directory the app is installed to.
    This information is read from the registry.
    
    No idea why this worked in Win9x.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created
    03/07/2002 robkenny Security changes

--*/

#include "precomp.h"
#include <commdlg.h>

IMPLEMENT_SHIM_BEGIN(BaanERP5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSaveFileNameA) 
APIHOOK_ENUM_END

const char gszLibUser[] = "\\LIB\\USER";
char gszBaanDir[MAX_PATH];

/*++

 Set the initial directory to be the directory the app was installed to. This 
 information is read from the registry.

--*/

BOOL
APIHOOK(GetSaveFileNameA)(
    LPOPENFILENAMEA lpofn
    )
{
    if (lpofn->lpstrInitialDir == NULL) {

        HKEY    hkey = NULL;
        DWORD   ret;
        DWORD   cbSize;

        /*
         * Get the directory only once
         */
        if (gszBaanDir[0] == 0) {

            ret = RegOpenKeyA(HKEY_LOCAL_MACHINE,
                              "SOFTWARE\\Baan\\bse",
                              &hkey);

            if (ret != ERROR_SUCCESS) {
                DPFN( eDbgLevelInfo, "Failed to open key 'SOFTWARE\\Baan\\bse'");
                goto Cont;
            }

            cbSize = MAX_PATH;

            ret = (DWORD)RegQueryValueExA(hkey,
                                          "BSE",
                                          NULL,
                                          NULL,
                                          (LPBYTE)gszBaanDir,
                                          &cbSize);
            
            if (ret != ERROR_SUCCESS) {
                DPFN( eDbgLevelInfo, "Failed to query value BSE");
                goto Cont;
            }
            
            StringCchCatA(gszBaanDir, MAX_PATH, gszLibUser);

Cont:
            if (hkey != NULL) {
                RegCloseKey(hkey);
            }
        }

        lpofn->lpstrInitialDir = gszBaanDir;

        DPFN( eDbgLevelInfo, "BaanERP5.dll, Changing lpstrInitialDir to '%s'", gszBaanDir);
    }

    // Call the Initial function
    return ORIGINAL_API(GetSaveFileNameA)(lpofn);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(COMDLG32.DLL, GetSaveFileNameA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\aolfindbundledinstaller_shim.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    AOLFindBundledInstaller_Shim.cpp

 Abstract:
    This shim is to provide a way to verify existance of
    America Online bundled in OEM machines when user runs older
    version of AOL/CS program (waol.exe or wcs2000.exe) or setup.

    If it exists, it will provide Apphelp dialog to tell user that
    there is newer America Online installer available.
    If user chose "Run this program", shim will launch the bundled installer.
    If user chose "Cancel", then shim will continue with current process.

    Apphelp dialog only get displayed if LocateInstaller function says to do so.

 History:

   04/30/2001 markder   Created
   05/16/2001 andyseti  Implemented LocateInstaller and ApphelpShowDialog.
   03/07/2002 robkenny  Security changes

--*/


#include "precomp.h"

#include <Softpub.h>
#include <WinCrypt.h>
#include <WinTrust.h>


#include "AOLFindBundledInstaller_AOLCode.h"


IMPLEMENT_SHIM_BEGIN(AOLFindBundledInstaller)
#include "ShimHookMacro.h"

#include "shimdb.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetStartupInfoA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
APIHOOK_ENUM_END



#define MAX_PARAM   4

BOOL            g_bDoneIt = FALSE;
CString         g_csHTMLHelpID_BundledFound;
CString         g_csHTMLHelpID_Incompatible;
DWORD           g_dwHTMLHelpID_BundledFound = 0;
DWORD           g_dwHTMLHelpID_Incompatible = 0;
CString         g_csAppName;
CString         g_csGUID;


#define APPHELP_DIALOG_FAILED ((DWORD)-1)

// from sdbapi\shimdb.w

/*
typedef struct _APPHELP_INFO {

//
//  html help id mode
//
    DWORD   dwHtmlHelpID; // html help id
    DWORD   dwSeverity;   // must have
    LPCTSTR lpszAppName;
    GUID    guidID;       // entry guid

//
//  Conventional mode
//
    TAGID   tiExe;              // the TAGID of the exe entry within the DB
    GUID    guidDB;             // the guid of the DB that has the EXE entry

    BOOL    bOfflineContent;
    BOOL    bUseHTMLHelp;
    LPCTSTR lpszChmFile;
    LPCTSTR lpszDetailsFile;

} APPHELP_INFO, *PAPPHELP_INFO;

*/

typedef BOOL (*_pfn_ApphelpShowDialog)(
    IN  PAPPHELP_INFO   pAHInfo,    // the info necessary to find the apphelp data
    IN  PHANDLE         phProcess   // [optional] returns the process handle of
                                    // the process displaying the apphelp.
                                    // When the process completes, the return value
                                    // (from GetExitCodeProcess()) will be zero
                                    // if the app should not run, or non-zero
                                    // if it should run.

    );


/*++

 Parse the command line.

 The format of the command line is:

 MODE:AOL|CS;APPNAME:xxxxxx;HTMLHELPID:99999;GUID:xxxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxx

--*/



BOOL
ParseCommandLine(
    LPCSTR lpCommandLine
    )
{
    int iTotalParam = 0;

    CSTRING_TRY
    {
        CStringToken csTok(lpCommandLine, L" ;");

        CString token;

        while (csTok.GetToken(token))
        {
            CStringToken csSingleTok(token, L":");

            CString csParam;
            CString csValue;

            csSingleTok.GetToken(csParam);
            csSingleTok.GetToken(csValue);

            if (csParam.CompareNoCase(L"APPNAME") == 0)
            {
                g_csAppName = csValue;
                ++iTotalParam;
            }

            if (csParam.CompareNoCase(L"HTMLHELPID_BUNDLED") == 0)
            {
                g_csHTMLHelpID_BundledFound = csValue;
                g_dwHTMLHelpID_BundledFound = _wtol(csValue.Get());
                ++iTotalParam;
            }

            if (csParam.CompareNoCase(L"HTMLHELPID_INCOMPAT") == 0)
            {
                g_csHTMLHelpID_Incompatible = csValue;
                g_dwHTMLHelpID_Incompatible = _wtol(csValue.Get());
                ++iTotalParam;
            }

            if (csParam.CompareNoCase(L"GUID") == 0)
            {
                g_csGUID = csValue;
                ++iTotalParam;
            }
        }
    }
    CSTRING_CATCH
    {
        DPF("FindAOL", eDbgLevelInfo, "Error in CString.Exiting\n");
        return FALSE;
    }

    if (iTotalParam < MAX_PARAM)
    {
        DPF("FindAOL", eDbgLevelInfo, "Total Parameter = %d is less than = %d\n",iTotalParam, MAX_PARAM);
        return FALSE;
    }


    //
    // Dump results of command line parse
    //

    DPF("FindAOL", eDbgLevelInfo, "===================================\n");
    DPF("FindAOL", eDbgLevelInfo, "              FindAOL              \n");
    DPF("FindAOL", eDbgLevelInfo, "===================================\n");
    DPF("FindAOL", eDbgLevelInfo, "COMMAND_LINE(%s)", lpCommandLine);
    DPF("FindAOL", eDbgLevelInfo, "-----------------------------------\n");

    DPF("FindAOL", eDbgLevelInfo, "APPNAME              = %S\n", g_csAppName);
    DPF("FindAOL", eDbgLevelInfo, "HTMLHELPID_BUNDLED   = %S\n", g_csHTMLHelpID_BundledFound);
    DPF("FindAOL", eDbgLevelInfo, "HTMLHELPID_INCOMPAT  = %S\n", g_csHTMLHelpID_Incompatible);
    DPF("FindAOL", eDbgLevelInfo, "GUID                 = %S\n", g_csGUID);

    DPF("FindAOL", eDbgLevelInfo, "-----------------------------------\n");

    return TRUE;
}


BOOL InvokeApphelpShowDialog(DWORD dwHTMLHelpID)
{
    _pfn_ApphelpShowDialog  pfnApphelpShowDialog = NULL;
    APPHELP_INFO            AHInfo = { 0 };
    HMODULE                 hAppHelpDLL = NULL;

    hAppHelpDLL = LoadLibrary(L"APPHELP.DLL");

    DPF("FindAOL", eDbgLevelWarning, "Apphelp:%d\n",hAppHelpDLL );

    if (hAppHelpDLL)
    {

        pfnApphelpShowDialog = (_pfn_ApphelpShowDialog) GetProcAddress(hAppHelpDLL, "ApphelpShowDialog");

        if (pfnApphelpShowDialog == NULL)
        {
            DPF("FindAOL", eDbgLevelInfo, "Unable to get APPHELP!ApphelpShowDialog procedure address.\n");
            return FALSE;
        }

        AHInfo.dwHtmlHelpID = dwHTMLHelpID;
        AHInfo.dwSeverity = APPHELP_NOBLOCK;
        AHInfo.lpszAppName = g_csAppName.Get();
        AHInfo.bPreserveChoice = TRUE;

        UNICODE_STRING  ustrGuid;
        NTSTATUS        ntstatus;

        RtlInitUnicodeString(&ustrGuid, g_csGUID.Get());

        ntstatus = RtlGUIDFromString(&ustrGuid, &AHInfo.guidID);

        if (NT_SUCCESS(ntstatus)==FALSE)
        {
            DPF("FindAOL", eDbgLevelInfo, "RtlGUIDFromString failed!\n");
            return FALSE;
        }

        if (pfnApphelpShowDialog(&AHInfo,NULL))
        {
            DPF("FindAOL", eDbgLevelInfo, "!\n");
        }
        else
        {
            DPF("FindAOL", eDbgLevelInfo, "RtlGUIDFromString FAILED!\n");
            return FALSE;
        }
    }
    else
    {
        DPF("FindAOL", eDbgLevelInfo, "LoadLibrary FAILED!\n");
        return FALSE;
    }
    return TRUE;
}

void DoIt()
{
    CHAR    lpszInstaller[MAX_PATH];
    BOOL    bBundledInstallerFound = FALSE;
    BOOL    bDisplayAppHelpDialog = FALSE;
    BOOL    bKillCurrentProcess = FALSE;
    BOOL    bLaunchBundledInstaller = FALSE;
    BOOL    bReturnValue = FALSE;
    UINT    uiWinExecReturned = 0;

    if (!g_bDoneIt) {
        if (!ParseCommandLine(COMMAND_LINE)) {
            goto eh;
        }
        bBundledInstallerFound = LocateInstaller(lpszInstaller, MAX_PATH, &bDisplayAppHelpDialog);

        if (bBundledInstallerFound) {
            DPF("FindAOL", eDbgLevelWarning, "Bundled installer found in %s.\n",lpszInstaller);
        }

        if (bBundledInstallerFound == FALSE && bDisplayAppHelpDialog == FALSE) {
            DPF("FindAOL", eDbgLevelWarning, "Bundled installer not found. Let client run normally.\n");
            goto eh;
        }

        if (bBundledInstallerFound == FALSE && bDisplayAppHelpDialog == TRUE) {
            bReturnValue = InvokeApphelpShowDialog(g_dwHTMLHelpID_Incompatible);

            // if user chose Cancel button, then just kill current process.
            if (FALSE == bReturnValue) {
                bKillCurrentProcess = TRUE;
            }
        }

        if (bBundledInstallerFound == TRUE && bDisplayAppHelpDialog == TRUE) {
            bReturnValue = InvokeApphelpShowDialog(g_dwHTMLHelpID_BundledFound);

            // if user chose Continue button, then launch bundled installer.
            if (TRUE == bReturnValue) {
                bKillCurrentProcess = TRUE;
                bLaunchBundledInstaller = TRUE;
            }
        }

        if (bBundledInstallerFound == TRUE && bDisplayAppHelpDialog == FALSE) {

            // Launch bundled installer.
            bKillCurrentProcess = TRUE;
            bLaunchBundledInstaller = TRUE;
        }

        if (bLaunchBundledInstaller) {
            // launch bundled installer instead
            uiWinExecReturned = WinExec(lpszInstaller, SW_SHOW);

            if (uiWinExecReturned <= 31) {
                DPF("FindAOL", eDbgLevelError, "Can not launch program. Error: %d\n",GetLastError());
                goto eh;
            }
        }

        if (bKillCurrentProcess) {
            ExitProcess(0);
        }
    }

eh:

    g_bDoneIt = TRUE;
}

LPSTR
APIHOOK(GetCommandLineA)()
{
    DoIt();

    return ORIGINAL_API(GetCommandLineA)();
}

VOID
APIHOOK(GetStartupInfoA)(
    LPSTARTUPINFOA lpStartupInfo)
{
    DoIt();

    ORIGINAL_API(GetStartupInfoA)(lpStartupInfo);
}

DWORD
APIHOOK(GetModuleFileNameA)(
  HMODULE hModule,    // handle to module
  LPSTR lpFilename,  // file name of module
  DWORD nSize         // size of buffer
  )
{
    DoIt();

    return ORIGINAL_API(GetModuleFileNameA)(hModule, lpFilename, nSize);
}

HWND
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,
    LPCSTR lpClassName,
    LPCSTR lpWindowName,
    DWORD dwStyle,
    int x,
    int y,
    int nWidth,
    int nHeight,
    HWND hWndParent,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam
    )
{
    DoIt();

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,
        lpWindowName,
        dwStyle,
        x,
        y,
        nWidth,
        nHeight,
        hWndParent,
        hMenu,
        hInstance,
        lpParam );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetStartupInfoA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetModuleFileNameA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\autodeskworld2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AutoDeskWorld2.cpp

 Abstract:

    Set LPMODULEENTRY32->GlblcntUsage to 1 if the call to Module32First was 
    successful.
    
    No idea why this works on NT4 on Win9x.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"
#include <tlhelp32.h>

IMPLEMENT_SHIM_BEGIN(AutoDeskWorld2)
#include "ShimHookMacro.h"

// Undefine this here!! Otherwise, in a unicode build
// environment, Module32First is #defined as Module32FirstW.
#ifdef Module32First
#undef Module32First
#endif

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(Module32First) 
APIHOOK_ENUM_END

/*++

 Set LPMODULEENTRY32->GlblcntUsage to 1 if the call to Module32First was 
 successful.

--*/

BOOL
APIHOOK(Module32First)(
    HANDLE SnapSection,
    LPMODULEENTRY32 lpme
    )
{
    BOOL bRet;

    bRet = ORIGINAL_API(Module32First)(SnapSection, lpme);

    if (bRet) {
        DPFN( eDbgLevelInfo, "setting lpme->GlblcntUsage to 1");
        
        lpme->GlblcntUsage = 1;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, Module32First)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\baanerp5c.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    BaanERP5c.cpp

 Abstract:

    The app sets the SharedSection in Windows Value under the key
    HKLM\System\CCS\Control\Session Manger\SubSystems to 4096
    from the one that is exisiting in registry. But this is resulting
    in failure of the BannLogicService and BaanSharedMemroy 
    services when they are started. 

    This shim hooks the RegSetValueExA and returns SUCCESS 
    without setting the value in registry if the app is trying to set the 
    HKLM\\System\CCS\Control\Session Manager\SubSystems\Windows 
    value from *SharedSection=####,####,512,* to *SharedSection=####,####,4096,*
    
 Notes:

    This is an app specific shim.

 History:

    02/09/2001 a-leelat Created

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(BaanERP5c)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegSetValueExA)

APIHOOK_ENUM_END



LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,
    LPCSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    CSTRING_TRY
    {
        CString csValueName(lpValueName);
        if (csValueName.CompareNoCase(L"Windows") == 0 )
        {
            LPSTR lpszData = (LPSTR)lpData;
            CString csData(lpszData);
            if (csData.Find(L"4096") >= 0)
            {
                return ERROR_SUCCESS;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    return ORIGINAL_API(RegSetValueExA)(hKey,       
                                      lpValueName,  
                                      Reserved,     
                                      dwType,    
                                      lpData,       
                                      cbData);      
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA);


HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\backoffice45suite.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    BackOffice45Suite.cpp

 Abstract:

    Ignore msvcrt!exit. No idea why it worked just fine in NT4.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created
    03/07/2002 robkenny Security changes

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BackOffice45Suite)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(exit) 
APIHOOK_ENUM_END

/*++

 Ignore msvcrt!exit

--*/

void
APIHOOK(exit)(
    int /*status*/
    )
{
    DPFN( eDbgLevelInfo, "BackOffice45Suite.dll, Ignoring msvcrt!exit...");
    return;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MSVCRT.DLL, exit)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\backupexec.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    BackupExec.cpp

 Abstract:

    BackupExec is calling SendMessageW with a TVM_GETITEM message but has an
	uninitialized lParam at one point.  We detect this and initalize the values.

 Notes:

    This is an app specific shim.

 History:

    09/25/2002  mnikkel    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BackupExec)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageW) 
APIHOOK_ENUM_END


/*++

  Make sure the lParam is correct.

--*/
BOOL
APIHOOK(SendMessageW)(
        HWND hWnd,
        UINT uMsg,    // TVM_GETITEM
        WPARAM wParam,
        LPARAM lParam 
        )
{
    if (uMsg == TVM_GETITEM)
	{
		if (lParam != NULL)
		{
			LPTVITEMEX lpItem = (LPTVITEMEX)lParam;

			// On TVIF_TEXT, the size in cchTextMax should be reasonable, if not then init.
			if ((lpItem->mask & TVIF_TEXT) &&
				((lpItem->cchTextMax > 300) || lpItem->cchTextMax <= 0))
			{
				LOGN(eDbgLevelError, "Correcting invalid TVITEMEX struct, max text %d.", lpItem->cchTextMax);
				lpItem->mask &= !TVIF_TEXT;
				lpItem->pszText = NULL;
				lpItem->cchTextMax = 0;
			}
		}
	}

    return ORIGINAL_API(SendMessageW)(hWnd, uMsg, wParam, lParam);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SendMessageW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\baaniv.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BaanIV.cpp

 Abstract:

    Ignore WM_STYLECHANGED on the app's subclassed listbox. This is needed 
    because the app subclasses the listbox and Win2k changed a bit the 
    behavior of the listbox window proc with regards to handling 
    WM_STYLECHANGED.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"
#include <commdlg.h>

IMPLEMENT_SHIM_BEGIN(BaanIV)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(CallWindowProcA) 
APIHOOK_ENUM_END

WNDPROC gpfnOrgListBoxWndProc;
WNDPROC gpfnAppListBoxWndProc;

/*++

 Ignore WM_STYLECHANGED.

--*/

LRESULT
Modified_ListBoxWndProcA(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    if (message == WM_STYLECHANGED) {
        return 0;
    }

    return (*gpfnAppListBoxWndProc)(hwnd, message, wParam, lParam);
}

/*++

    When the app calls CallWindowProc passing our modified listbox
    proc call the original window proc instead

--*/
LRESULT
APIHOOK(CallWindowProcA)(
    WNDPROC pfn,
    HWND    hwnd,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam)
{
    if (pfn == Modified_ListBoxWndProcA) {
        pfn = gpfnOrgListBoxWndProc;
    }

    return ORIGINAL_API(CallWindowProcA)(pfn, hwnd, message, wParam, lParam);
}

/*++

 When the app subclasses the listbox of a combobox grab the original listbox 
 proc, grab the pointer that the app is trying to set, set the new pointer to 
 be our modified version of the listbox proc and return to the app our pointer.

--*/

ULONG_PTR
APIHOOK(SetWindowLongA)(
    HWND hwnd,
    int nIndex,
    ULONG_PTR newLong
    )
{
    if (nIndex == GWLP_WNDPROC) {
        WNDCLASSA wndClass;
        WNDPROC pfnOrg;

        GetClassInfoA((HINSTANCE)GetWindowLong(hwnd, GWLP_HINSTANCE),
                      "ComboLBox",
                      &wndClass);

        pfnOrg = (WNDPROC)GetWindowLong(hwnd, GWLP_WNDPROC);

        if (pfnOrg == wndClass.lpfnWndProc) {

            gpfnOrgListBoxWndProc = pfnOrg;

            DPFN( eDbgLevelInfo, "Fix up subclassing of ComboLBox");

            gpfnAppListBoxWndProc = (WNDPROC)newLong;

            newLong = (ULONG_PTR)Modified_ListBoxWndProcA;

            ORIGINAL_API(SetWindowLongA)(hwnd, nIndex, newLong);

            return newLong;
        }
    }

    // Call the Initial function
    return ORIGINAL_API(SetWindowLongA)(hwnd, nIndex, newLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, CallWindowProcA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\beyondatlantis.cpp ===
/*

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    BeyondAtlantis.cpp

 Abstract:

    Fix disk space error caused by bad string passed to 
    GetDiskFreeSpace. This root path is also bad on Win9x. No idea
    why that doesn't affect it.

 History:

    05/31/2002  linstev    Created

*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BeyondAtlantis)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA)
APIHOOK_ENUM_END

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
    if (lpRootPathName && (strncmp(lpRootPathName, "tla", 3) == 0)) {
        CSTRING_TRY
        {        
            CString csPath;
            csPath.GetCurrentDirectoryW();
            CString csDrive;
            csPath.SplitPath(&csDrive, NULL, NULL, NULL);
        
            return ORIGINAL_API(GetDiskFreeSpaceA)(csDrive.GetAnsi(), lpSectorsPerCluster, 
                lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        }
        CSTRING_CATCH
        {
        }
    }
        
    return ORIGINAL_API(GetDiskFreeSpaceA)(lpRootPathName, lpSectorsPerCluster, 
        lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
}

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\battlezone.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    BattleZone.cpp

 Abstract:
    
    This app is a really good example of things not to do:

    1. Infinite loop on mciSendString('play...'). In order to fix this we 
       return a failure case if the same play string is sent twice and the
       device is playing already. Note that the behaviour of the 
       mciSendString API is consistent with win9x. Someone managed to repro
       this hang on win9x, but it's more difficult. 

    2. They call SetCooperativeLevel(DDSCL_NORMAL) between a Begin/End 
       Scene. On NT, this causes the Z-Buffer to be lost which means that 
       when EndScene is called, it returns D3DERR_SURFACESLOST which causes 
       the app to AV.
        
 Notes:

    This is an app specific shim.

 History:

    02/10/2000 linstev  Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(BattleZone)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
    APIHOOK_ENUM_ENTRY(mciSendCommandA)
    APIHOOK_ENUM_ENTRY(mciSendStringA)
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

CString *           g_csLastCommand = NULL;
MCIDEVICEID         g_wDeviceID     = 0;
LPDIRECTDRAWSURFACE g_lpZBuffer     = NULL;

/*++

 Store the DeviceId.

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    MCIERROR mErr = ORIGINAL_API(mciSendCommandA)(
        IDDevice,
        uMsg,
        fdwCommand,
        dwParam);

    if ((mErr == 0) && (uMsg == MCI_OPEN))
    {
        g_wDeviceID = ((LPMCI_OPEN_PARMS)dwParam)->wDeviceID;
    }

    return mErr;
}

/*++

 Prevent looping.

--*/

MCIERROR 
APIHOOK(mciSendStringA)(
    LPCSTR lpszCommand,  
    LPSTR lpszReturnString,  
    UINT cchReturn,       
    HANDLE hwndCallback   
    )
{
    DPFN( eDbgLevelInfo, "mciSendStringA: %s", lpszCommand);

    CSTRING_TRY
    {
        CString csCommand(lpszCommand);
        if (csCommand.Compare(*g_csLastCommand) == 0)
        {
            MCI_STATUS_PARMS mciStatus;
            ZeroMemory(&mciStatus, sizeof(mciStatus));
            mciStatus.dwItem = MCI_STATUS_MODE;
            
            if (0 == ORIGINAL_API(mciSendCommandA)(
                g_wDeviceID,
                MCI_STATUS,
                MCI_STATUS_ITEM,
                (DWORD_PTR)&mciStatus))
            {
                if (mciStatus.dwReturn == MCI_MODE_PLAY)
                {
                    DPFN( eDbgLevelWarning, "Device still playing, returning busy");
                    return MCIERR_DEVICE_NOT_READY;
                }
            }
        }
        else
        {
            *g_csLastCommand = csCommand;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(mciSendStringA)(
        lpszCommand,  
        lpszReturnString,  
        cchReturn,       
        hwndCallback);
}

/*++

 Hook create surface to find the zbuffer we'll need to restore later. Note that
 we use HookObject to get the surface release notification.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)( 
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE *lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        if (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)
        {
            g_lpZBuffer = *lplpDDSurface;
            DPFN( eDbgLevelInfo, "Found ZBuffer", g_lpZBuffer);
        } 
    }

    return hReturn;
}

/*++

 Use SetCooperativeLevel to keep track of who the exclusive mode owner is.
 
--*/

HRESULT
COMHOOK(IDirectDraw, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd,
    DWORD dwFlags
    )
{
    HRESULT hReturn;

    // Original SetCooperativeLevel
    _pfn_IDirectDraw_SetCooperativeLevel pfnOld = 
        ORIGINAL_COM(IDirectDraw, SetCooperativeLevel, pThis);

    hReturn = (*pfnOld)(pThis, hWnd, dwFlags);

    __try
    {
        if (g_lpZBuffer && (g_lpZBuffer->IsLost() == DDERR_SURFACELOST))
        {
            g_lpZBuffer->Restore();
            DPFN( eDbgLevelInfo, "Restoring lost ZBuffer");
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return hReturn;
}

/*++

 Allocate global variables.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CSTRING_TRY
        {
            g_csLastCommand = new CString;
            return g_csLastCommand != NULL;
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, SetCooperativeLevel, 20)

    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)
    APIHOOK_ENTRY(WINMM.DLL, mciSendStringA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\bigactionconstruction.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BigActionConstruction.cpp
 Abstract:
    The uninstall was not uninstalling the .lnk files on
    the ALLUSER start Menu. This was because the uninstaller
    script was not getting the right path. 

    This is an app specific shim.

 History:
 
    03/12/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BigActionConstruction)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)    
    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
APIHOOK_ENUM_END


WCHAR g_szAllUsersStartMenu[MAX_PATH];

WCHAR* g_pszFilePath = L"\\Programs\\Big Action Construction";
WCHAR* g_pszReplacementFilePath = L"\\Programs\\Fisher~1\\Big Action Construction";


/*++
    This hook replaces the wrong path with the right replacement path.
    
--*/

HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR lpFileName,
    LPWIN32_FIND_DATAA lpFindFileData
    )
{
    CSTRING_TRY
    {
        CString AllUserPath(g_szAllUsersStartMenu);
        CString FileName(lpFileName);
        // Or D:\Documents And Settings\All Users\Start Menu\g_pszFilePath\*.*
        AllUserPath.AppendPath(g_pszFilePath);
        AllUserPath.AppendPath(L"*.*");
    
        // If any of the above constructed path match
        if (AllUserPath.CompareNoCase(FileName) == 0)
        {
            // Fill in the replacement path 
            AllUserPath = g_szAllUsersStartMenu;
            AllUserPath.AppendPath(g_szAllUsersStartMenu);
            AllUserPath.AppendPath(L"*.*");
       
            DPFN( eDbgLevelInfo, "[Notify] FindFirstFileA \
                modified %s to %S",lpFileName, AllUserPath.Get());

            return ORIGINAL_API(FindFirstFileA)(AllUserPath.GetAnsi(),lpFindFileData);
        }
    }
    CSTRING_CATCH
    {
        //do nothing
    }

   return ORIGINAL_API(FindFirstFileA)(lpFileName,lpFindFileData);
}

/*++
    This hook replaces the wrong path with the right replacement path.
    
--*/

BOOL
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpFileName    
    )
{
    CSTRING_TRY
    {
        CString AllUserPath(g_szAllUsersStartMenu);
        CString FileName(lpFileName);
        // Or D:\Documents And Settings\All Users\Start Menu\g_pszFilePath    
        AllUserPath.AppendPath(g_pszFilePath);

        if (AllUserPath.CompareNoCase(FileName) == 0)
        {
            // Fill in the replacement path       
            AllUserPath = g_szAllUsersStartMenu;
            AllUserPath.AppendPath(g_szAllUsersStartMenu);

            DPFN( eDbgLevelInfo, "[Notify] RemoveDirectoryA \
                modified %s to %S", lpFileName, AllUserPath.Get());     

            return ORIGINAL_API(RemoveDirectoryA)(AllUserPath.GetAnsi());
        }
    }
    CSTRING_CATCH
    {
        //do nothing
    }

    return ORIGINAL_API(RemoveDirectoryA)(lpFileName);
}

/*++
    This hook replaces the wrong path with the right replacement path.
    
--*/

BOOL
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName    
    )
{
    CSTRING_TRY
    {
        CString AllUserPath(g_szAllUsersStartMenu);            
        AllUserPath += g_pszFilePath;

        CString csFileName(lpFileName);
        int nIndex = AllUserPath.Find(csFileName);
        
        if (nIndex >= 0)
        {
            // Seperate the title from the path.
            char szTitle[MAX_PATH];
            GetFileTitleA(lpFileName, szTitle, MAX_PATH);
            CString csTitle(szTitle);
            csTitle += L".lnk";

            // Fill in the replacement path with the title.     
            AllUserPath = g_szAllUsersStartMenu;
            AllUserPath.AppendPath(g_pszReplacementFilePath);
            AllUserPath.AppendPath(csTitle);       

            DPFN( eDbgLevelInfo, "[Notify] DeleteFileA \
                modified %s to %S", lpFileName, AllUserPath.Get());   
       
            return ORIGINAL_API(DeleteFileA)(AllUserPath.GetAnsi());
        }
    }
    CSTRING_CATCH
    {
        //do nothing
    }

   return ORIGINAL_API(DeleteFileA)(lpFileName);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        // Get the %AllUserStartMenu% from SHELL
        HRESULT result = SHGetFolderPath(NULL, CSIDL_COMMON_STARTMENU, NULL,
                            SHGFP_TYPE_DEFAULT, g_szAllUsersStartMenu);

        if ((result == S_FALSE) || (result == E_INVALIDARG))
        {
            return FALSE;
        }      
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)    
    APIHOOK_ENTRY(KERNEL32.DLL, RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL, DeleteFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\biggamehunter3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BigGameHunter3.cpp

 Abstract:

    BGH calls GetWindowLong() to get a window procedure and subsequently 
    does not call CallWindowProc() with the value returned from 
    GetWindowLong(). This patch calls GetWindowLongW( ), which returns the 
    window procedure. 
   
 Notes:

    This is an app specific shim. Making it general will require generating 
    a stub function that just uses CallWindowProc for every returned handle. 
    Too much work, not enough gain.

 History:

    03/16/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BigGameHunter3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowLongA) 
APIHOOK_ENUM_END

/*++

 This function intercepts GetWindowLong( ), checks the nIndex for GWL_WNDPROC 
 and if it is,calls GetWindowLongW( ). Otherwise, it calls GetWindowLongA( )

--*/

LONG
APIHOOK(GetWindowLongA)(
    HWND hwnd,
    int  nIndex )
{
    LONG lRet;

    // Apply the modification only if the App wants a WindowProc.
    if (nIndex == GWL_WNDPROC) 
    {
        lRet = GetWindowLongW(hwnd, nIndex);
    }
    else
    {
        lRet = ORIGINAL_API(GetWindowLongA)(hwnd, nIndex);
    }

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetWindowLongA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\bizplanbuilder.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BizPlanBuilder.cpp

 Abstract:

    App does not repaint after a WM_SETTEXT message.

 Notes:
    
    This is an app specific shim.

 History:

    01/03/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BizPlanBuilder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowTextA) 
APIHOOK_ENUM_END

/*++

 Subclass the windowproc for this call and fix the pointer that comes out in 
 the WM_SETTEXT message that is generated by SetWindowTextA.

--*/

BOOL 
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    BOOL bRet = ORIGINAL_API(SetWindowTextA)(hWnd, lpString);

    //
    // Redraw the window
    //

    InvalidateRect(hWnd, NULL, TRUE);

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\canvas6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Canvas6.cpp

 Abstract:

    This app. deletes HKEY\CLASSES_ROOT \ .HTC key during uninstall. This 
    breaks the ControlPanel -> Add/Remove programs
   
 Notes:

    This is specific to this app.

 History:

    11/17/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Canvas6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA) 
    APIHOOK_ENUM_ENTRY(RegCloseKey) 
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA) 
APIHOOK_ENUM_END

HKEY g_hOpenKey = 0;

/*++

 Store the key for .htc

--*/

LONG
APIHOOK(RegOpenKeyA)(
    HKEY hkey,
    LPCSTR lpSubKey,
    PHKEY phkResult)
{
    LONG lRet = 0;

    lRet = ORIGINAL_API(RegOpenKeyA)(hkey,lpSubKey,phkResult);

    DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

    if ((hkey == HKEY_CLASSES_ROOT)
        && lpSubKey 
        && (CompareStringA(lcid, NORM_IGNORECASE, lpSubKey, -1, ".htc", -1) == CSTR_EQUAL))
    {
        if (phkResult)
        {
            g_hOpenKey = *(phkResult);
        }
    }
    
    return lRet;
}

/*++

 Ignore the close if required.

--*/

LONG
APIHOOK(RegCloseKey)(
    HKEY hkey)
{
    if (g_hOpenKey && (g_hOpenKey == hkey))
    {
        return ERROR_SUCCESS;
    }
    else
    {
        return (ORIGINAL_API(RegCloseKey)(hkey));
    }
}

/*++

 Ignore the delete.

--*/

LONG
APIHOOK(RegDeleteKeyA)(
    HKEY hkey,
    LPCSTR lpSubKey)
{
    LONG lRet = 0;

    DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

    if ((hkey == HKEY_CLASSES_ROOT)
        && lpSubKey 
        && (CompareStringA(lcid, NORM_IGNORECASE, lpSubKey, -1, ".htc", -1) == CSTR_EQUAL))
    {
        if (g_hOpenKey)
        {
            if(RegDeleteValueA(g_hOpenKey,NULL))
            {
                // Add DPF to indicate an error during deletion of the value installed by the app.
                   DPFN( eDbgLevelError,
                            "Could not delete the value in the key= \"%s\".", lpSubKey);
            }
            RegCloseKey(g_hOpenKey);
            g_hOpenKey = 0;
        }
        lRet = ERROR_SUCCESS;
    }
    else
    {
        lRet = ORIGINAL_API(RegDeleteKeyA)(hkey,lpSubKey);
    }  

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\boeingfix.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    BoeingFix.cpp

 Abstract:

    This modified version of kernel32!CreateFile* adds the 
    FILE_FLAG_NO_BUFFERING flag if the app is openning a specific name that is 
    a UNIX pipe advertised as a file.

 Notes:

    This is an app specific shim.

 History:
 
    10/16/2000 garretb  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(BoeingFix)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
APIHOOK_ENUM_END

static const WCHAR g_lpszPipeName[] = L"msg_in\\message.pip";
static const int   g_lpszPipeNameLen = (sizeof(g_lpszPipeName) / sizeof(g_lpszPipeName[0])) - sizeof(g_lpszPipeName[0]);


// Return FILE_FLAG_NO_BUFFERING if this filename is the special pipe.
DWORD NoBufferFlag(const CString & csFileName)
{
    if (csFileName.GetLength() >= g_lpszPipeNameLen)
    {
        CString csRight;
        csFileName.Right(g_lpszPipeNameLen, csRight);
        if (csRight.CompareNoCase(g_lpszPipeName))
        {
            return FILE_FLAG_NO_BUFFERING;
        }
    }

    return 0;
}


/*++

 Conditionally add FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    CString csFileName(lpFileName);
    dwFlagsAndAttributes |= NoBufferFlag(csFileName);

    return ORIGINAL_API(CreateFileA)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

/*++

    Conditionally add FILE_FLAG_NO_BUFFERING

--*/

HANDLE
APIHOOK(CreateFileW)(
    LPWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    CString csFileName(lpFileName);
    dwFlagsAndAttributes |= NoBufferFlag(csFileName);

    return ORIGINAL_API(CreateFileW)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\britannica2001.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Britannica2001.cpp

 Abstract:

    Britannica expects IE 5 install to install msjavx86.exe
    which doesn't happen if a newer version of IE is already there.

 Notes:

    This is an app specific shim.

 History:

    05/31/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Britannica2001)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END



/*++

  Check CreateProcessA for execution of ie5wzdex.exe, when this
  occurs, run msjavx86.exe.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)", lpApplicationName, lpCommandLine );

    //
    // Call the original API
    //
    BOOL bRet= ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                            lpCommandLine,
                                            lpProcessAttributes,
                                            lpThreadAttributes, 
                                            bInheritHandles,                     
                                            dwCreationFlags,                    
                                            lpEnvironment,                     
                                            lpCurrentDirectory,                
                                            lpStartupInfo,             
                                            lpProcessInformation);

    // wait for original API to finish
    if (bRet)
    {
        WaitForSingleObject( lpProcessInformation->hProcess, INFINITE);
    }


    // Check for <ie5wzd /S:\"> and if found run msjavx86.exe in quiet mode
    if (lpCommandLine)
    {
        CSTRING_TRY
        {
            CString csCL(lpCommandLine);

            int nLoc = csCL.Find(L"ie5wzd /S:\"");
            if ( nLoc > -1 )
            {
                PROCESS_INFORMATION     processInfo;

                CString csNew = csCL.Mid(nLoc+11, 3);
                csNew += L"javavm\\msjavx86.exe /Q:A /R:N";

                DPFN( eDbgLevelError, "[CreateProcessA] starting %S", csNew.Get() );

                BOOL bRet2= CreateProcessA(NULL,
                               csNew.GetAnsi(),
                               NULL,
                               NULL, 
                               FALSE,                     
                               0,                    
                               NULL,                     
                               NULL,                
                               lpStartupInfo,
                               &processInfo);

                if (bRet2)
                {
                    WaitForSingleObject( processInfo.hProcess, INFINITE);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    return bRet;
}

    
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\chemoffice.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ChemOffice.cpp

 Abstract:

    This shim fixes a problem where a dialog box comes up after
    selecting Gaussian Run.  The dialog box warns of a windows
    error that only occurs because we are shim'ing the app with
    EmulateHeap.  We are unable to remove EmulateHeap since this
    causes the app to AV so the only solution at this time is to
    ignore the invalid paramater windows error message that occurs.

  Notes:

    This is a specific shim.

 History:

    03/06/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ChemOffice)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetLastError) 
APIHOOK_ENUM_END

/*++

 Hook GetLastError 

--*/

DWORD 
APIHOOK(GetLastError)(VOID)
{
    DWORD dwResult;

    dwResult = ORIGINAL_API(GetLastError)();

    if ( dwResult == ERROR_INVALID_PARAMETER )
        dwResult = 0;

    return dwResult;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetLastError)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\canvascheckedbuttons.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FakeThemeMetrics.cpp

 Abstract:

  This Shim will allow the Skemers group to shim applications that do not behave 
  well with "Themed" system metrics

 History:

  11/30/2000 a-brienw Converted to shim frame work version 2.

--*/

#include "precomp.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

IMPLEMENT_SHIM_BEGIN(CanvasCheckedButtons)
#include "ShimHookMacro.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSysColor) 
APIHOOK_ENUM_END

#define CLRMAX(x) {if (x > 227) x = 227;}
DWORD APIHOOK(GetSysColor)(int nIndex)
{
    if (nIndex == COLOR_BTNFACE)
    {
        COLORREF crOld = (COLORREF)ORIGINAL_API(GetSysColor)(nIndex);
        BYTE r = GetRValue(crOld);
        BYTE g = GetGValue(crOld);
        BYTE b = GetBValue(crOld);

        CLRMAX(r);
        CLRMAX(g);
        CLRMAX(b);

        return RGB(r,g,b);
    }

    return ORIGINAL_API(GetSysColor)(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetSysColor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\battleship.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:
    
    Battleship.cpp

 Abstract:

    This game is divided into 3 programs:
      1. The launcher (bshipl.exe)
      2. Classic (bship.exe)
      3. Ultimate (bs.exe)
    
    The launcher is the only shortcut exposed to the user and runs the other 2. 
    However, the launcher and Classic both have a ton of problems that aren't 
    easily fixed with a shim.

    Ultimate, is a complete superset of all the features of Classic and doesn't 
    appear to have any issues.

    Therefore, the fix is to redirect the launcher to Ultimate and prevent 
    Ultimate from spawning the launcher on quit.

 Notes:

    This is a specific shim.

 History:

    08/03/2000  a-vales     Created
    03/13/2001  robkenny    Converted to CString
    05/05/2001  linstev     Rewrote 
    03/07/2002 robkenny Security changes

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Battleship)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++
 
 Don't allow this program to spawn the launcher.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    if (lpCommandLine && (stristr(lpCommandLine, "bshipl.exe") != 0)) {
        //
        // This is the launcher, so do nothing
        //

        return TRUE;
    } 

    return ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Set the current working directory for the launcher so 
        // the redirectexe shim works with a relative path
        //
        WCHAR szName[MAX_PATH];
        if (GetModuleFileNameW(0, szName, MAX_PATH)) {
            WCHAR *p = wcsistr(szName, L"\\bshipl.exe");
            if (p) {
                *p = L'\0';
                SetCurrentDirectoryW(szName);
            }
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\baseball2000.cpp ===
/*++

 Copyright (c) 2001-2002 Microsoft Corporation

 Module Name:

    BaseBall2000.cpp

 Abstract:

    If you use a video card that supports more than 10 texture formats the
    app will AV writing passed the end of their SURFACEDESC array.
    
 History:
        
    01/04/2001 maonis Created
    03/07/2002 robkenny Security changes

--*/

#include "precomp.h"
#include "d3d.h"

IMPLEMENT_SHIM_BEGIN(BaseBall2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

typedef HRESULT (*_pfn_IDirect3D3_CreateDevice)(PVOID pThis, REFCLSID rclsid, LPDIRECTDRAWSURFACE4, LPDIRECT3DDEVICE3*, LPUNKNOWN);
typedef HRESULT (*_pfn_IDirect3DDevice3_EnumTextureFormats)(PVOID pThis, LPD3DENUMPIXELFORMATSCALLBACK, LPVOID);

typedef HRESULT (*_pfn_EnumPixelFormatsCallback)(LPDDPIXELFORMAT lpDDPixFmt, LPVOID lpContext);

_pfn_EnumPixelFormatsCallback g_pfnEnumPixelFormatsCallback = NULL;
int g_cD3DEnumPixelFormatsCallbacks = 0;

/*++

    Hook this call so we can make sure that calling methods on the 
    IDirect3DDevice3 interface is hooked.

--*/

HRESULT 
COMHOOK(IDirect3D3, CreateDevice)(
    PVOID pThis, 
    REFCLSID rclsid,
    LPDIRECTDRAWSURFACE4 lpDDS,
    LPDIRECT3DDEVICE3* lplpD3DDevice,
    LPUNKNOWN /*lpUnkOuter*/
    )
{
    HRESULT hReturn;
    
    _pfn_IDirect3D3_CreateDevice pfnOld = 
        ORIGINAL_COM(IDirect3D3, CreateDevice, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            rclsid, 
            lpDDS, 
            lplpD3DDevice,
            NULL)))
    {
        HookObject(
            NULL, 
            IID_IDirect3DDevice3, 
            (PVOID*)lplpD3DDevice, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

    Restrict to returning at most 10 texture formats.

--*/

HRESULT 
CALLBACK 
EnumPixelFormatsCallback(
    LPDDPIXELFORMAT lpDDPixFmt,  
    LPVOID lpContext    
    )
{
    // The app only supports up to 10 texture formats.
    if (++g_cD3DEnumPixelFormatsCallbacks >= 11)
    {
        return D3DENUMRET_CANCEL;
    }
    else
    {
        return g_pfnEnumPixelFormatsCallback(lpDDPixFmt, lpContext);
    }
}

/*++

    Call our private callback instead.

--*/

HRESULT 
COMHOOK(IDirect3DDevice3, EnumTextureFormats)( 
    PVOID pThis, 
    LPD3DENUMPIXELFORMATSCALLBACK lpd3dEnumPixelProc,  
    LPVOID lpArg                                           
  )
{
    DPFN( eDbgLevelError, "it IS getting called");

    g_pfnEnumPixelFormatsCallback = lpd3dEnumPixelProc;

    _pfn_IDirect3DDevice3_EnumTextureFormats EnumTextureFormats =  ORIGINAL_COM(IDirect3DDevice3, EnumTextureFormats, pThis);

    return EnumTextureFormats(pThis, EnumPixelFormatsCallback, lpArg);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirect3D3, CreateDevice, 8)

    COMHOOK_ENTRY(DirectDraw, IDirect3DDevice3, EnumTextureFormats, 8)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\chollian2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   Chollian2000.cpp

 Abstract:

   The application has two problems.
   1. it is expecting metric value 1. it is ok in win9x and win2k but it's not the
       case in winXP.
   2. the application calls CreateIpForwardEntry with MIB_IPPROTO_LOCAL. 
       it will fail in winXP. the application should use MIB_IPPROTO_NETMGMT.
   The GetIpForwardTable and CreateIpForwardEntry are shimed to fix this problem.
   In GetIpForwardTable, I changed the metric value to 1. In CreateIpForwardEntry, 
   I changed MIB_IPPROTO_LOCAL to MIB_IPPROTO_NETMGMT.
   
 History:

    06/12/2001  zhongyl     Created

--*/

#include "precomp.h"
#include "iphlpapi.h"

IMPLEMENT_SHIM_BEGIN(Chollian2000)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateIpForwardEntry) 
    APIHOOK_ENUM_ENTRY(GetIpForwardTable) 
APIHOOK_ENUM_END


BOOL
APIHOOK(CreateIpForwardEntry)(
    PMIB_IPFORWARDROW pRoute
    )
{
        DWORD dwReturn;
        if (pRoute != NULL)
            if (pRoute->dwForwardProto == MIB_IPPROTO_LOCAL)
                pRoute->dwForwardProto = MIB_IPPROTO_NETMGMT;
                // The application used MIB_IPPROTO_LOCAL. It was ok for Win2k but it fails on WinXP. Change it to MIB_IPPROTO_NETMGMT
        dwReturn = ORIGINAL_API(CreateIpForwardEntry)(pRoute);
        return dwReturn;
}

BOOL
APIHOOK(GetIpForwardTable)(
    PMIB_IPFORWARDTABLE pIpForwardTable,
    PULONG pdwSize,
    BOOL bOrder
    )
{
        DWORD dwReturn;
        dwReturn = ORIGINAL_API(GetIpForwardTable)(pIpForwardTable, pdwSize, bOrder);
        if (pIpForwardTable != NULL)
            if (pIpForwardTable->dwNumEntries > 0)
                pIpForwardTable->table[0].dwForwardMetric1 = 1;
                // The application expects the Metric value to be one. In WinXP, the value is changed to 30. Application should not expect a fixed value here.
        return dwReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    //
    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    //
    APIHOOK_ENTRY(iphlpapi.dll,GetIpForwardTable)
    APIHOOK_ENTRY(iphlpapi.dll,CreateIpForwardEntry)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\casper.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Casper.cpp

 Abstract:

    Casper copies a LNK file into %windir%\desktop.  This file is hardcoded to 
    point to c:\program files. The EXE that actually places the file into the 
    wrong place is 16-bit, so we cannot use CorrectFilePaths to fix the problem.  
    We hook IPersistFile::Save to accomplish the fixup of the incorrect link, 
    IPersistFile::Save is not modified in any way.

    App uses some 16-bit stuff when showing the intro video (see #200495) which 
    we have yet to fix (probably will never fix). After it calls CreateWindowEx
    to create the "Full-screen animation" window it assigns the return value
    to a variable. Later on the app plays videos in SmackWin windows. And it 
    checks this var to see if it's 0 - if it is, it calls DestroyWindow on the 
    SmackWin window. Now if the intro video were shown successfully it would 
    have set this var to 0 when the video exits but since in this case the 
    video is not shown, the variable still has the value equal to the 
    "Full-screen animation" window handle. We fix this by setting the return
    value of the "Full-screen animation" window creation to 0.

 History:

    1/21/1999    robkenny
    03/15/2000   robkenny   converted to use the CorrectPathChangesAllUser class
    11/07/2000   maonis     added hooks for CreateWindowExA and SetFocus (this is 
                            for the actual casper.exe)
    01/04/2001   maonis     tester found more problem with the smackwin windows. 
                            rewrote the fix to fix all of them.

--*/

#include "precomp.h"
#include "ClassCFP.h"

IMPLEMENT_SHIM_BEGIN(Casper)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)
APIHOOK_ENUM_END

/*++

 We return 0 when creating the "Full-screen animation" window.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      // extended window style
    LPCSTR lpClassName,  // registered class name
    LPCSTR lpWindowName, // window name
    DWORD dwStyle,        // window style
    int x,                // horizontal position of window
    int y,                // vertical position of window
    int nWidth,           // window width
    int nHeight,          // window height
    HWND hWndParent,      // handle to parent or owner window
    HMENU hMenu,          // menu handle or child identifier
    HINSTANCE hInstance,  // handle to application instance
    LPVOID lpParam        // window-creation data
    )
{
    HWND hWnd = ORIGINAL_API(CreateWindowExA)(
        dwExStyle, 
        lpClassName, 
        lpWindowName, 
        dwStyle, 
        x, 
        y, 
        nWidth, 
        nHeight, 
        hWndParent, 
        hMenu, 
        hInstance,
        lpParam);

    if (lpWindowName)
    {
        CSTRING_TRY
        {
            CString csWindowName(lpWindowName);
            if (csWindowName.Compare(L"Full-screen animation") == 0)
            {
                hWnd = 0;
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return hWnd;
}

/*++

 Our path changing class.  We want to convert paths to All User

--*/

CorrectPathChangesAllUser * g_PathCorrector    = NULL;

static bool g_bLinkCorrected = false;

/*++

 Return a pointer to the PathCorrecting object

--*/

inline CorrectPathChangesBase * GetPathcorrecter()
{
    if (g_PathCorrector == NULL)
    {
        // Create our correct file path object
        g_PathCorrector = new CorrectPathChangesAllUser;
        g_PathCorrector->AddPathChangeW(L"\\MsM\\", L"\\MorningStar\\" );
    }

    return g_PathCorrector;
}

/*++

 Call CorrectPathAllocA and print a debug message if the two strings differ

--*/

WCHAR * CorrectPathAllocDebugW(const WCHAR * uncorrect, const char * debugMsg)
{
    if (uncorrect == NULL)
        return NULL;

    WCHAR * strCorrectFile = GetPathcorrecter()->CorrectPathAllocW(uncorrect);

    if (strCorrectFile && uncorrect && _wcsicmp(strCorrectFile, uncorrect) != 0)
    {
        DPFN( eDbgLevelInfo, "%s corrected path:\n    %S\n    %S\n",
            debugMsg, uncorrect, strCorrectFile);
    }
    else // Massive Spew:
    {
        DPFN( eDbgLevelSpew, "%s unchanged %S\n", debugMsg, uncorrect);
    }

    return strCorrectFile;
}

/*++

 Casper *copies* a link to %windir%\Desktop; it contains hardcoded paths to incorrect places.
 Move the link to the proper desktop directory.
 Correct the Path, Working Directory, and Icon values--all which are wrong.

--*/

void CorrectCasperLink()
{
    if (!g_bLinkCorrected)
    {
        // The path to the incorrect desktop link
        WCHAR * lpIncorrectCasperPath = GetPathcorrecter()->ExpandEnvironmentValueW(L"%windir%\\Desktop\\casper.lnk");

        // Correct the bad desktop link path
        WCHAR * lpCorrectCasperPath = GetPathcorrecter()->CorrectPathAllocW(lpIncorrectCasperPath);

        DPFN( eDbgLevelInfo, "CorrectCasperLink MoveFileW(%S, %S)\n", lpIncorrectCasperPath, lpCorrectCasperPath);
        // Move the file to the correct location.
        MoveFileW(lpIncorrectCasperPath, lpCorrectCasperPath);

        // All finished with the bad path, I never want to see it again.
        free(lpIncorrectCasperPath);

        HRESULT hres = CoInitialize(NULL);
        if (SUCCEEDED(hres))
        {
            // Get a pointer to the IShellLink interface.
            IShellLinkW *psl;
            hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLinkW, (void **)&psl);
            if (SUCCEEDED(hres))
            {
                // Get a pointer to the IPersistFile interface.
                IPersistFile *ppf;
                hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);

                if (SUCCEEDED(hres))
                {
                    // Load the shortcut.
                    hres = ppf->Load(lpCorrectCasperPath, STGM_READ);
                    if (SUCCEEDED(hres))
                    {
                        // We have successfully loaded the link
                        g_bLinkCorrected = true;

                        DPFN( eDbgLevelInfo, "CorrectCasperLink %S\n", lpCorrectCasperPath);

                        // Correct the path to the shortcut target.
                        WCHAR szBadPath[MAX_PATH];
                        WCHAR * szCorrectPath;

                        WIN32_FIND_DATAW wfd;
                        hres = psl->GetPath(szBadPath, MAX_PATH, &wfd, SLGP_UNCPRIORITY);
                        if (SUCCEEDED(hres))
                        {
                            szCorrectPath = CorrectPathAllocDebugW(szBadPath, "CorrectCasperLink, SetPath");
                            psl->SetPath(szCorrectPath);
                            free(szCorrectPath);
                        }

                        // Correct the working directory
                        hres = psl->GetWorkingDirectory(szBadPath, MAX_PATH);
                        if (SUCCEEDED(hres))
                        {
                            szCorrectPath = CorrectPathAllocDebugW(szBadPath, "CorrectCasperLink, SetWorkingDirectory");
                            psl->SetWorkingDirectory(szCorrectPath);
                            free(szCorrectPath);
                        }

                        // Correct the icon
                        int iIcon;
                        hres = psl->GetIconLocation(szBadPath, MAX_PATH, &iIcon);
                        if (SUCCEEDED(hres))
                        {
                            szCorrectPath = CorrectPathAllocDebugW(szBadPath, "CorrectCasperLink, SetIconLocation");
                            psl->SetIconLocation(szCorrectPath, iIcon);
                            free(szCorrectPath);
                        }

                        // Save the shortcut.
                        ppf->Save(NULL, TRUE);
                    }
                }
                // Release the pointer to IShellLink.
                ppf->Release();
            }
            // Release the pointer to IPersistFile.
            psl->Release();
        }
        CoUninitialize();
        free(lpCorrectCasperPath);
    }
}

/*++

  Do nothing to the CreateDialogParamA call, just an opportunity to correct the casper link

--*/

HWND 
APIHOOK(CreateDialogParamA)(
  HINSTANCE hInstance,     // handle to module
  LPCSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
)
{
    CorrectCasperLink();

    HWND returnValue = ORIGINAL_API(CreateDialogParamA)(
        hInstance, 
        lpTemplateName, 
        hWndParent, 
        lpDialogFunc, 
        dwInitParam);

    return returnValue;
}


/*++

    Create the appropriate g_PathCorrector
    Return TRUE if we were successful in creating and initializing.

--*/
BOOL InitPathcorrectorClass()
{
    g_PathCorrector = new CorrectPathChangesAllUser;

    if (g_PathCorrector)
    {
        return g_PathCorrector->ClassInit();
    }

    return FALSE;
}


/*++

    Add all the path corrections to the path corrector.
    Call after SHIM_STATIC_DLLS_INITIALIZED

--*/
void InitializePathCorrections()
{
    g_PathCorrector->AddPathChangeW(L"\\MsM\\", L"\\MorningStar\\" );
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    BOOL bSuccess = TRUE;

    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        return InitPathcorrectorClass();
    }
    else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) 
    {
        InitializePathCorrections();
    }
    return bSuccess;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\cluefinders3rdgrade.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ClueFinders3rdGrade.cpp

 Abstract:

    This shim simulates the behaviour of Win9x wrt static controls and 
    Get/SetWindowText. Basically, Win9x stored the resource id for a static
    control in it's name. On NT, this isn't stored.

    We used to set a low-level window hook that catches the CreateWindow calls,
    but gave up because it kept regressing and it would be too expensive for 
    the layer.

 Notes:
    
    This is an app specific shim.

 History:

    06/19/2000 linstev  Created
    11/17/2000 linstev  Made app specific

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ClueFinders3rdGrade)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowTextA) 
    APIHOOK_ENUM_ENTRY(SetWindowTextA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
APIHOOK_ENUM_END

typedef HMODULE (*_pfn_GetModuleHandleA)(LPCSTR lpModuleName);
 
//
// List of static handles
//

struct HWNDITEM
{
    HWND hWnd;
    DWORD dwRsrcId;
    HWNDITEM *next;
};
HWNDITEM *g_hWndList = NULL;

//
// Handle to use for CallNextHook
//

HHOOK g_hHookCbt = 0;

//
// Critical section for list access
//

CRITICAL_SECTION g_csList;

/*++

 Search the window list for a resource id if GetWindowTextA fails.

--*/

int 
APIHOOK(GetWindowTextA)(
    HWND hWnd,        
    LPSTR lpString,  
    int nMaxCount     
    )
{
    int iRet = ORIGINAL_API(GetWindowTextA)(
        hWnd,
        lpString,
        nMaxCount);

    if (iRet == 0) {
        //
        // Check for Resource Id
        //
    
        EnterCriticalSection(&g_csList);

        HWNDITEM *hitem = g_hWndList;
        while (hitem) {
            if (hitem->hWnd == hWnd) {
                //
                // Copy the resource id into the buffer
                //
                
                if ((hitem->dwRsrcId != (DWORD)-1) && (nMaxCount >= 3)) {
                    MoveMemory(lpString, (LPBYTE) &hitem->dwRsrcId + 1, 3);
                    iRet = 2;
                
                    DPFN( eDbgLevelError, "Returning ResourceId: %08lx for HWND=%08lx", *(LPDWORD)lpString, hWnd);
                }

                break;
            }
            hitem = hitem->next;
        }

        LeaveCriticalSection(&g_csList);
    }

    return iRet;
}
 
/*++

 Hook SetWindowText so the list is kept in sync.

--*/

BOOL 
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    //
    // Set the text for this window if it's in our list
    //

    EnterCriticalSection(&g_csList);
    
    HWNDITEM *hitem = g_hWndList;
    while (hitem) {
        if (hitem->hWnd == hWnd) {
            if (lpString && (*(LPBYTE) lpString == 0xFF)) {
                hitem->dwRsrcId = *(LPDWORD) lpString;
            }

            break;
        }

        hitem = hitem->next;
    }
    
    LeaveCriticalSection(&g_csList);

    return ORIGINAL_API(SetWindowTextA)(hWnd, lpString);
}

/*++

 Hook to find CreateWindow calls and get the attached resource id.

--*/

LRESULT 
CALLBACK 
CBTProcW(
    int nCode,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    HWND hWnd = (HWND) wParam;
    LPCBT_CREATEWNDW pCbtWnd;

    switch (nCode) {
    case HCBT_CREATEWND:

        //
        // Add to our list of windows if it's a static - or we don't know 
        //
        
        pCbtWnd = (LPCBT_CREATEWNDW) lParam;

        if (pCbtWnd && pCbtWnd->lpcs && pCbtWnd->lpcs->lpszClass && 
            (IsBadReadPtr(pCbtWnd->lpcs->lpszClass, 4) || 
             (_wcsicmp(pCbtWnd->lpcs->lpszClass, L"static") == 0))) {
            HWNDITEM *hitem = (HWNDITEM *) malloc(sizeof(HWNDITEM));

            if (hitem) {
                hitem->hWnd = hWnd;

                //
                // Check for a resource id in the name
                //
                
                if (pCbtWnd->lpcs->lpszName && 
                    (*(LPBYTE) pCbtWnd->lpcs->lpszName == 0xFF)) {
                    hitem->dwRsrcId = *(LPDWORD) pCbtWnd->lpcs->lpszName;
                } else {
                    hitem->dwRsrcId = (DWORD)-1;
                }

                //
                // Update our list
                // 
                
                EnterCriticalSection(&g_csList);
                
                hitem->next = g_hWndList;
                g_hWndList = hitem;
       
                LeaveCriticalSection(&g_csList);

                DPFN( eDbgLevelError, "CreateWindow HWND=%08lx, ResourceId=%08lx", hitem->hWnd, hitem->dwRsrcId);
            } else {
                DPFN( eDbgLevelError, "Failed to allocate list item");
            }
        }
        
        break;

    case HCBT_DESTROYWND:
        
        //
        // Remove the window from our list
        //
        
        EnterCriticalSection(&g_csList);

        HWNDITEM *hitem = g_hWndList, *hprev = NULL;
        
        while (hitem) {
            if (hitem->hWnd == hWnd) {
                if (hprev) {
                    hprev->next = hitem->next;
                } else {
                    g_hWndList = hitem->next;
                }

                free(hitem);

                DPFN( eDbgLevelError, "DestroyWindow %08lx", hWnd);

                break;
            }
            hprev = hitem;
            hitem = hitem->next;
        }

        LeaveCriticalSection(&g_csList);

        break;
    }

    return CallNextHookEx(g_hHookCbt, nCode, wParam, lParam);
}

/*++

 Hook CreateDialog which is where the problem occurs

--*/

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    if (!g_hHookCbt) {
        g_hHookCbt = SetWindowsHookExW(WH_CBT, CBTProcW, GetModuleHandleW(0), 0);
        DPFN( eDbgLevelInfo, "[CreateDialogIndirectParamA] Hook added");
    }

    HWND hRet = ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);

    if (g_hHookCbt) {
        UnhookWindowsHookEx(g_hHookCbt);
        g_hHookCbt = 0;
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Initialize our critical section here
        //
        
        if (!InitializeCriticalSectionAndSpinCount(&g_csList, 0x80000000))
        {
            return FALSE;
        }

    } else if (fdwReason == DLL_PROCESS_DETACH) {
        //
        // Clear the hook
        //

        if (g_hHookCbt) {
            UnhookWindowsHookEx(g_hHookCbt);
        }
    }


    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, GetWindowTextA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\commandos.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    Commandos.cpp

 Abstract:

    A hack for Commandos (EIDOS). The game caches a pointer to the ddraw
    primary surface. On NT, after a mode change, the memory can be mapped 
    into a different location - so when they try to write to it, it access
    violates.

    We know from debugging the app where they keep the cached pointer, so
    when they restore the surface, we relock it, and patch the new pointer 
    into their store.

 Notes:

    This is an app specific hack.

 History:

    10/29/1999 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Commandos)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

static LPVOID pLastPrimary = NULL;
static LPDWORD pAppPrimary = NULL;

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)( 
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Find out where they store the pointer.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Lock)( 
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPRECT lpDestRect,
    LPDDSURFACEDESC lpDDSurfaceDesc,
    DWORD dwFlags,
    HANDLE hEvent
    )
{
    DDSURFACEDESC ddsd = {sizeof(ddsd)};
    HRESULT hReturn, hr;

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Lock pfnOld = ORIGINAL_COM(IDirectDrawSurface, Lock, lpDDSurface);
        
    // Call the old API
    if (FAILED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lpDestRect, 
            lpDDSurfaceDesc, 
            dwFlags, 
            hEvent)))
    {
        return hReturn;
    }

    // Make sure it's a primary
    hr = lpDDSurface->GetSurfaceDesc(&ddsd);
    if (SUCCEEDED(hr) && 
       (ddsd.ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)))
    {

        // We know:
        //   1. They cache the primary address in [esi+0x20]
        //   2. They lock the primary more than once 
        //
        // We assume:
        //   1. When they lock the primary, esi+0x20 is a valid pointer

        if ((pLastPrimary) && (!pAppPrimary))
        {
            __asm
            {
                pop edi
                pop esi
                mov eax,pLastPrimary
                
                cmp [esi+0x20],eax
                jne WrongESI

                // [esi+0x20] does contain the cached pointer

                lea eax,[esi+0x20]
                mov pAppPrimary,eax
            
            WrongESI:

                push esi
                push edi
            }
        }

        pLastPrimary = lpDDSurfaceDesc->lpSurface;
    }
    
    return hReturn;
}

/*++

 Patch the new pointer directly into their data segment. 

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Restore)( 
    LPDIRECTDRAWSURFACE lpDDSurface
    )
{
    DDSURFACEDESC ddsd = {sizeof(ddsd)};
    HRESULT hReturn, hr, hrt;
    
    // Retrieve the old function
    _pfn_IDirectDrawSurface_Restore pfnOld = ORIGINAL_COM(IDirectDrawSurface, Restore, lpDDSurface);

    // Call the old API
    if (FAILED(hReturn = (*pfnOld)(lpDDSurface)))
    {
        return hReturn;
    }

    // Make sure it's a primary
    hr = lpDDSurface->GetSurfaceDesc(&ddsd);
    if (SUCCEEDED(hr) && 
       (ddsd.ddsCaps.dwCaps & (DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE)))
    {
        // Check if we've been set up
        if (!((pLastPrimary) && (pAppPrimary)))
        {
            return hReturn;
        }

        // We must get a pointer here, so keep trying  
        do
        {
            hr = lpDDSurface->Lock(
                NULL, 
                &ddsd, 
                DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, 
                NULL);

            if (hr == DDERR_SURFACELOST)
            {
                // Don't care about result
                (*pfnOld)(lpDDSurface);     
            }
        } while (hr == DDERR_SURFACELOST);

        // Patch the new pointer into their memory
        pLastPrimary = ddsd.lpSurface;
        if ((pLastPrimary) && (pAppPrimary))
        {
            *pAppPrimary = (DWORD_PTR)pLastPrimary;
        }

        // Unlock the surface
        lpDDSurface->Unlock(NULL);
    }

    return hReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Lock, 25)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Restore, 27)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\chollian2000plus.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Chollian2000Plus.cpp

 Abstract:

    The app has a binary logon.ocx which uses sub-classed editbox as password 
    editbox. It does not hook all messages (whistler seems has more message 
    than win2k's), so when the mouse drags through it, the password typed will 
    be shown as plain text, the fix is to apply ES_PASSWORD to this specific 
    EditBox.

 Notes: 
  
    This is an app specific shim.

 History:

    05/15/2001 xiaoz    Created

--*/

#include "precomp.h"
#include "psapi.h"

IMPLEMENT_SHIM_BEGIN(Chollian2000Plus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
APIHOOK_ENUM_END

/*++

 Correct Window Style if Necessary

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle, 
    LPCSTR lpClassName, 
    LPCSTR lpWindowName, 
    DWORD dwStyle, 
    int x, 
    int y, 
    int nWidth, 
    int nHeight, 
    HWND hWndParent, 
    HMENU hMenu, 
    HINSTANCE hInstance, 
    LPVOID lpParam 
    )
{
    WCHAR szBaseName[MAX_PATH];
    CString cstrClassname;
    CString cstrBaseName;


    
    // If dwExStyle is not zero, goto original call
    if (dwExStyle)
    {
        goto Original;
    }

    // If dwStyle is not 0x50010000, goto original call
    if (0x50010000 != dwStyle)
    {
        goto Original;
    }

    if (!GetModuleBaseName(GetCurrentProcess(), hInstance, szBaseName, MAX_PATH))
    {
        goto Original;
    }
    
    // If the call is not from login.ocx ,goto original call
    cstrBaseName = szBaseName;
    if (cstrBaseName.CompareNoCase(L"login.ocx"))
    {
        goto Original;
    }

    // If it's not an EditBox , goto original call
    cstrClassname = lpClassName;
    if (cstrClassname.CompareNoCase(L"Edit"))
    {
        goto Original;
    }

    // If it has window's name , goto original call
    if (lpWindowName)
    {
        goto Original;
    }

    
    
    LOGN(eDbgLevelWarning, "Window style corrected");
    dwStyle = dwStyle | 0x0020;

Original:

    return ORIGINAL_API(CreateWindowExA)(dwExStyle, lpClassName, lpWindowName, 
        dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)        

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\corelappsregistration.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CorelAppsRegistration.cpp

 Abstract:


 Notes:

    This is an app specific shim.

 History:

    11/13/2001 prashkud     Created

--*/

#include "precomp.h"
IMPLEMENT_SHIM_BEGIN(CorelAppsRegistration)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShowWindow)
    APIHOOK_ENUM_ENTRY(CreateWindowExA)   
APIHOOK_ENUM_END

/*++

 Calls SetForegroundWindow directly after a ShowWindow call with SW_SHOW as
 the operation. The mouse_event call allows the SetForegroundWindow call to 
 succeed. This is a hack borrowed from the DirectX sources.

--*/

BOOL 
APIHOOK(ShowWindow)(
    HWND hWnd, 
    INT nCmdShow
    )
{
    BOOL bReturn;
 
    bReturn = ORIGINAL_API(ShowWindow)(hWnd, nCmdShow | SW_SHOW);

    mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
    SetForegroundWindow(hWnd);
    LOGN( eDbgLevelWarning, 
          "Forcing to foreground.");

    return bReturn;
}

/*++

 Calls SetForegroundWindow directly after a CreateWindowEx call with 
 WS_VISIBLE as a style. The mouse_event call allows the
 SetForegroundWindow call to succeed. This is a hack borrowed from
 the DirectX sources.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  
    LPCSTR lpWindowName, 
    DWORD dwStyle,       
    int x,               
    int y,               
    int nWidth,          
    int nHeight,         
    HWND hWndParent,     
    HMENU hMenu,         
    HINSTANCE hInstance, 
    LPVOID lpParam       
    )
{
    HWND hReturn;

    dwStyle |= WS_VISIBLE;
    hReturn = ORIGINAL_API(CreateWindowExA)(
        dwExStyle,
        lpClassName,      
        lpWindowName,     
        dwStyle,          
        x,                
        y,                
        nWidth,           
        nHeight,          
        hWndParent,       
        hMenu,            
        hInstance,        
        lpParam);

   mouse_event(MOUSEEVENTF_WHEEL, 0, 0, 0, 0);
   SetForegroundWindow(hReturn);
   LOGN( eDbgLevelWarning, 
         "Forcing to foreground.");

    return hReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ShowWindow)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\coffeecuphtmleditor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CoffeeCupHTMLEditor.cpp

 Abstract:

    This app implicitly loads a DLL whose linkage is not found and the loader 
    comes up with a message box.

 Notes:

    This is specific to this app.

 History:

    11/21/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CoffeeCupHTMLEditor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

 This function hooks CreateProcessA and checks the COMMAND_LINE. If the commandline has 
 %systemdir%\lftif90n.dll.

--*/

BOOL
APIHOOK(CreateProcessA)(    
    LPCSTR lpApplicationName,                  // name of executable module
    LPSTR lpCommandLine,                       // command line string
    LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
    BOOL bInheritHandles,                      // handle inheritance option
    DWORD dwCreationFlags,                     // creation flags
    LPVOID lpEnvironment,                      // new environment block
    LPCSTR lpCurrentDirectory,                 // current directory name
    LPSTARTUPINFOA lpStartupInfo,              // startup information
    LPPROCESS_INFORMATION lpProcessInformation // process information
    )
{
    CSTRING_TRY
    {
        CString csIgnoreDLL;
        csIgnoreDLL.GetSystemDirectoryW();
        csIgnoreDLL.AppendPath(L"lftif90n.dll");
        
        CString csCl(lpCommandLine);
        
        if (csCl.Find(csIgnoreDLL) >= 0)
        {
            return TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(CreateProcessA)(
            lpApplicationName,                 
            lpCommandLine,                     
            lpProcessAttributes, 
            lpThreadAttributes,  
            bInheritHandles,     
            dwCreationFlags,     
            lpEnvironment,       
            lpCurrentDirectory,  
            lpStartupInfo,       
            lpProcessInformation);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\coreldraw9jpn.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    CorelDraw9JPN.cpp

 Abstract:

    The App has some RTF files, seems the font and charset specified not correct 
    in it. When later on riched20 do ANSI-Unicode Code conversion, it used 
    English code-page. Fix this by checking the 1st parameter passed to 
    MultiByteToWideChar by richedit, if it's English, try to use CP_ACP, which 
    is always safe.

 Notes: 
  
    This is an app specific shim.

 History:

    05/10/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorelDraw9JPN)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MultiByteToWideChar) 
APIHOOK_ENUM_END

/*++

 Correct the code page if required.

--*/

int
APIHOOK(MultiByteToWideChar)(
    UINT CodePage,
    DWORD dwFlags,
    LPCSTR lpMultiByteStr,
    int cbMultiByte,
    LPWSTR lpWideCharStr,
    int cchWideChar
    )
{
    if (1252 == CodePage) {
        //
        // Change the code page
        //
        CodePage = CP_ACP;

        LOGN(eDbgLevelWarning, "Code page corrected");
    }

    return ORIGINAL_API(MultiByteToWideChar)(CodePage, dwFlags, lpMultiByteStr,
        cbMultiByte, lpWideCharStr, cchWideChar);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, MultiByteToWideChar)        

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\comptonsbible.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ComptonsBible.cpp

 Abstract:
    
    This shim checks to see if Compton's Interactive Bible is calling DdeClientTransaction to create 
    a program group in the Start Menu for America Online.  If so, NULL is passed as pData to prevent 
    the application from doing anything with the program group, i.e. CreateGroup or ShowGroup. 
    
 Notes:

    This is an app specific shim.

 History:

    12/14/2000 jdoherty  Created

--*/

#include "precomp.h"
#include <ParseDde.h>

IMPLEMENT_SHIM_BEGIN(ComptonsBible)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DdeClientTransaction)
APIHOOK_ENUM_END

/*++

 Hook ShellExecuteA so we can check the return value.

--*/

HDDEDATA
APIHOOK(DdeClientTransaction)(
    IN LPBYTE pData,       // pointer to data to pass to server
    IN DWORD cbData,       // length of data
    IN HCONV hConv,        // handle to conversation
    IN HSZ hszItem,        // handle to item name string
    IN UINT wFmt,          // clipboard data format
    IN UINT wType,         // transaction type
    IN DWORD dwTimeout,    // time-out duration
    OUT LPDWORD pdwResult   // pointer to transaction result    
    )
{
    //
    //  Checking to see if pData contains America Online.
    //
    DPFN( eDbgLevelInfo, "[DdeClientTransaction] Checking pData parameter: %s, for calls including America Online.", pData);
    
    if (pData)
    {
        CSTRING_TRY
        {
            CString csData((LPSTR)pData);
            if (csData.Find(L"America Online") >= 0)
            {
                DPFN( eDbgLevelInfo, "[DdeClientTransaction] They are trying to create or show the "
                    "America Online Group calling DdeClientTransaction with NULL pData.");
                //
                //  The application is trying to create or show the America Online Group recalling API with 
                //  NULL as pData.
                //
                return ORIGINAL_API(DdeClientTransaction)(
                                 NULL,
                                 cbData,
                                 hConv, 
                                 hszItem, 
                                 wFmt,   
                                 wType,  
                                 dwTimeout,
                                 pdwResult
                                );
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return ORIGINAL_API(DdeClientTransaction)(
                         pData,
                         cbData,
                         hConv, 
                         hszItem, 
                         wFmt,   
                         wType,  
                         dwTimeout,
                         pdwResult
                        );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, DdeClientTransaction)

HOOK_END
IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\corelsitebuilder.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CorelSiteBuilder.cpp

 Abstract:

    App repeatedly calls SetWindowTextA with the same title causing 
    flickering. This repros on some machines and not others: we don't know why.

 Notes:

    This is an app specific shim.

 History:

    01/31/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CorelSiteBuilder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowTextA) 
APIHOOK_ENUM_END

HWND g_hLast = NULL;
CString * g_csLastWindowText = NULL;

CRITICAL_SECTION g_csGlobals;

/*++

 Only send the message if the text has changed.

--*/

BOOL
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    EnterCriticalSection(&g_csGlobals);

    if (lpString)
    {
        CSTRING_TRY
        {
            CString csString(lpString);

            if ((g_hLast == hWnd) && g_csLastWindowText->Compare(csString) == 0) {
                //
                // We have the same window and title, don't bother setting it again
                //

                LeaveCriticalSection(&g_csGlobals);

                return TRUE;
            }

            //
            // Store the current settings as the last known values
            //
            g_hLast = hWnd;
            *g_csLastWindowText = csString;
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    LeaveCriticalSection(&g_csGlobals);

    return ORIGINAL_API(SetWindowTextA)(hWnd, lpString);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CSTRING_TRY
        {
            if (!InitializeCriticalSectionAndSpinCount(&g_csGlobals, 0x80000000))
            {
                return FALSE;
            }
            g_csLastWindowText = new CString;
            if (g_csLastWindowText == NULL)
            {
                return FALSE;
            }
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\cossacks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Cossacks.cpp

 Abstract:

    This is a workaround for a problem created by SafeDisc 2.0. The application 
    uses the WM_ACTIVATEAPP message to determine if it has focus or not. The 
    Safedisc wrapper prevents this message from hitting their main window on 
    NT, because it goes to the SafeDisc window before everything has been 
    unwrapped. So the app never thinks it has focus.

    The fix is to send an activate message after the window has been created.

 Notes:

    This is an app specific shim.

 History:

    06/16/2001 linstev   Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(Cossacks)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Hook mciSendCommand and try to find the window we need to activate.

--*/

BOOL g_bFirst = TRUE;

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    if (g_bFirst) {
        //
        // Only need to hit this code once
        //
        HWND hWnd = FindWindowW(L"Kernel", L"Game");
        if (hWnd) {
            //
            // We've found the window, send the message
            //
            g_bFirst = FALSE;
            LOGN(eDbgLevelError, "Sent a WM_ACTIVATEAPP to the window");
            SendMessageW(hWnd, WM_ACTIVATEAPP, 1, 0);
        }
    }

    return ORIGINAL_API(mciSendCommandA)(IDDevice, uMsg, fdwCommand, dwParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\createresumesquickandeasy.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CreateResumesQuickandEasy.cpp

 Abstract:

    Hooks all application-defined window procedures and filters out an illegal
    OCM notification code which causes the application to beep annoyingly.

 Notes:


 History:

    03/22/2000 mnikkel  Created
    01/10/2001 mnikkel  Corrected to prevent a recursion problem.
    01/11/2001 mnikkel  Trimmed down to only necessary routines.

--*/

#include "precomp.h"
#include "olectl.h"

IMPLEMENT_SHIM_BEGIN(CreateResumesQuickandEasy)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
APIHOOK_ENUM_END

/*++
 Change OCM_NOTIFY behaviour
--*/

LRESULT CALLBACK 
CreateResumesQuickandEasy_WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{

    if (uMsg == OCM_NOTIFY)
    {
        NMHDR *pNmhdr = (LPNMHDR) lParam;

        // For OCM Notification check for the illegal code and toss it
        // (App Create Resumes Quick and Easy)
        if (pNmhdr && pNmhdr->idFrom == 0 && pNmhdr->code == 0x704)
            return 0;
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}


/*++
 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)
--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, CreateResumesQuickandEasy_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}


/*++
 Register hooked functions
--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA);
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\creativeonscreendisplay.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    CreativeOnScreenDisplay.cpp

 Abstract:

    App crashes with low resolution display changes.

 Notes:
 
    This is an app specific shim.

 History:

    06/25/2002 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CreativeOnScreenDisplay)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
APIHOOK_ENUM_END

/*++

 Handle display change messages

--*/

LRESULT 
CALLBACK 
Creative_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    if (uMsg == WM_DISPLAYCHANGE)
    {
        // Ignore this message if the resolution is too low
        if ((LOWORD(lParam) < 512) || (HIWORD(lParam) < 384))
        {
            LOGN(eDbgLevelError, "[WndProc] Hiding WM_DISPLAYCHANGE for low resolution mode");
            return 0;
        }
    }
        
    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Creative_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Creative_WindowProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\descent2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Descent2.cpp

 Abstract:

    Hooks all application-defined window procedures and forcefully clears the 
    background to white. For some reason the EraseBackground that normally 
    comes through on win9x does not always work.

 Notes:

    This shim can be reused for other shims that need to forcefully clear the 
    background.

 History:

    03/28/2000 a-michni  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Descent2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(RegisterClassW) 
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(RegisterClassExW) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongW) 
APIHOOK_ENUM_END

/*++

 Change WM_ERASEBKGND behaviour

--*/


LRESULT CALLBACK 
Descent2_WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    HDC     hdc;
    RECT    rc;

    /* Retrieve the size info and fill with a standard White */
    switch( uMsg )
    {
        case WM_ERASEBKGND: 
            hdc = (HDC) wParam; 
            GetClientRect(hwnd, &rc); 
            SetMapMode(hdc, MM_ANISOTROPIC); 
            SetWindowExtEx(hdc, 100, 100, NULL); 
            SetViewportExtEx(hdc, rc.right, rc.bottom, NULL); 
            FillRect(hdc, &rc, (HBRUSH)GetStockObject(WHITE_BRUSH)); 
            break;

        default: break;
    }
    
    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

INT_PTR CALLBACK 
Descent2_DialogProcHook(
    DLGPROC   pfnOld,   // address of old DialogProc
    HWND      hwndDlg,  // handle to dialog box
    UINT      uMsg,     // message
    WPARAM    wParam,   // first message parameter
    LPARAM    lParam    // second message parameter
    )
{
    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}



ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
)
{
    WNDCLASSA   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  // class data
)
{
    WNDCLASSW   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
)
{
    WNDCLASSEXA   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  // class data
)
{
    WNDCLASSEXW   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Descent2_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(hWnd, nIndex, dwNewLong );
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Descent2_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(hWnd, nIndex, dwNewLong );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\dinosauractivitycenter.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DinosaurActivityCenter.cpp

 Abstract:
    The app doesn't handle the WM_PAINT messages so when you drag the "Save As"
    dialog box, the main window doesn't redraw. 
    We fix this by capturing the static image of the main window into a 
    memory DC and blit from it when the WM_PAINT messages arrive (the 
    image under the dialog doesn't change).

 Notes:

    This is an app specific shim.

 History:

    09/21/2000 maonis  Created
    11/29/2000 andyseti Converted into AppSpecific shim.

--*/

#include "precomp.h"

static HWND g_hwndOwner;
static HDC g_hdcMemory;
static RECT g_rect;

IMPLEMENT_SHIM_BEGIN(DinosaurActivityCenter)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(GetSaveFileNameA) 
APIHOOK_ENUM_END

BOOL
APIHOOK(GetSaveFileNameA)(
    LPOPENFILENAMEA lpofn
    )
{
    BOOL fRet;

    HDC hdcWindow = NULL;
    HBITMAP hbmMemory = NULL;
    HBITMAP hbmOld = NULL;
    HWND hwndOwner = lpofn->hwndOwner;

    DPFN( eDbgLevelInfo, "GetSaveFileNameA called with hwnd = 0x%x.", hwndOwner);
    
    if (hdcWindow = GetDC(hwndOwner))
    {
        if ((g_hdcMemory = CreateCompatibleDC(hdcWindow)) &&
            GetWindowRect(hwndOwner, &g_rect) &&
            (hbmMemory = CreateCompatibleBitmap(hdcWindow, g_rect.right, g_rect.bottom)) &&
            (hbmOld = (HBITMAP)SelectObject(g_hdcMemory, hbmMemory)) &&
            BitBlt(g_hdcMemory, 0, 0, g_rect.right, g_rect.bottom, hdcWindow, 0, 0, SRCCOPY))
        {
            g_hwndOwner = hwndOwner;
        }
        else
        {
            DPFN( eDbgLevelError, "GetSaveFileName(hwnd = 0x%x): Error creating bitmap", hwndOwner);
        }

        ReleaseDC(hwndOwner, hdcWindow);
    }
    
    fRet = ORIGINAL_API(GetSaveFileNameA)(lpofn);

    g_hwndOwner = NULL;

    if (g_hdcMemory)
    {
        if (hbmMemory)
        {
            if (hbmOld)
            {
                SelectObject(g_hdcMemory, hbmOld);
            }

            DeleteObject(hbmMemory);
        }
        
        DeleteDC(g_hdcMemory);
    }

    return fRet;
}

/*++

 Validate after paint and filter syskey messages.

--*/

LRESULT 
CALLBACK 
DinosaurActivityCenter_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    if (hwnd == g_hwndOwner)
    {
        if (uMsg == WM_PAINT)
        {
            PAINTSTRUCT ps;
            HDC hdcWindow;
        
            if (hdcWindow = BeginPaint(hwnd, &ps))
            {
                BitBlt(hdcWindow, 0, 0, g_rect.right, g_rect.bottom, g_hdcMemory, 0, 0, SRCCOPY);

                EndPaint(hwnd, &ps);
            }
        
            LOGN( eDbgLevelError, "hwnd = 0x%x: Paint to the screen", hwnd);
        }
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  
    )
{
    CSTRING_TRY
    {
        CString csClassName(lpwcx->lpszClassName);
        if (csClassName.CompareNoCase(L"GAMEAPP") == 0)
        {
            WNDCLASSEXA wcNewWndClass = *lpwcx;

            wcNewWndClass.lpfnWndProc = 
                (WNDPROC) HookCallback(lpwcx->lpfnWndProc, DinosaurActivityCenter_WindowProcHook);

            return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }
    return ORIGINAL_API(RegisterClassExA)(lpwcx);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(COMDLG32.DLL, GetSaveFileNameA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\crystalwebpageserver.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CrystalWebPageServer.cpp

 Abstract:

    The app calls GetEnhMetaFileHeader passing
    nSize of 1000. We need to change it to 100 to make the app not crash.
    If we don't do it this will cause memory corruption. Win9x seems to
    be fine with it. Maybe it will crash the app less often in Win9x than
    it does in Win2k.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(CrystalWebPageServer)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetEnhMetaFileHeader)
APIHOOK_ENUM_END


/*++

    The app calls GetEnhMetaFileHeader passing
    nSize of 1000. We need to change it to 100 to make the app work

--*/

UINT
APIHOOK(GetEnhMetaFileHeader)(
    HENHMETAFILE    hemf,
    UINT            nSize,
    LPENHMETAHEADER lpEnhMetaHeader
    )
{
    if (nSize == 1000) {
        nSize = 100;
        
        DPFN(
            eDbgLevelInfo,
            "CrystalWebPageServer.dll, GetEnhMetaFileHeader: changed the size to 100.\n");
    }

    //
    // Call the original API
    //
    return ORIGINAL_API(GetEnhMetaFileHeader)(
                            hemf,
                            nSize,
                            lpEnhMetaHeader);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, GetEnhMetaFileHeader)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\cuseeme4.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   CUSeeMe4.cpp

 Abstract:

    This DLL fixes a profiles bug in CU-SeeMe Pro 4.0 setup where it only adds some certain
    Reg values to the per-user hive (HKCU) instead of putting them in HKLM.

    We don't actually hook any functions, instead, we just copy the regkeys after setup finishes
    when our process detach is called.

 Notes:

 History:

    08/07/2000  reinerf  Created
    11/29/2000  andyseti Renamed file from setup.cpp into CUSeeMe4.cpp.
                         Converted into AppSpecific shim.
*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(CUSeeMe4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        HKEY hkCU;
        HKEY hkLM;

        if ((RegOpenKeyExA(HKEY_CURRENT_USER,
                           "Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer",
                           0,
                           KEY_QUERY_VALUE,
                           &hkCU) == ERROR_SUCCESS))
        {
            if (RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                              "Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer",
                              0,
                              KEY_SET_VALUE,
                              &hkLM) == ERROR_SUCCESS)
            {
                // these are the values we want to migrate
                static char* aszValues[] = {"Folder",
                                            "Serial",
                                            "Help",
                                             0,
                                           };
                char** ppszValue = aszValues;

                LOGN( eDbgLevelError, 
                    "Copying values from 'HKCU\\Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer' into"
                    "'HKLM\\Software\\White Pine\\CU-SeeMe Pro\\4.0\\Installer'.");

                while (*ppszValue)
                {
                    DWORD dwType;
                    DWORD cbData;
                    char szData[MAX_PATH];

                    cbData = sizeof(szData);
                    if (RegQueryValueExA(hkCU,
                                         *ppszValue,
                                         NULL,
                                         &dwType,
                                         (LPBYTE)szData,
                                         &cbData) == ERROR_SUCCESS)
                    {
                        RegSetValueExA(hkLM, *ppszValue, 0, dwType, (LPBYTE)szData, cbData);
                    }

                    // get the next value to migrate from hkcu -> hklm
                    ppszValue++;
                }
                
                RegCloseKey(hkLM);
            }
            
            RegCloseKey(hkCU);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\dirttrackracing.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    DirtTrackRacing.cpp

 Abstract:
    
    App shows a white (or whatever your default window background color is) screen when starting up which is 
    inconsistent behavior from on 9x because on 9x it doesn't draw anything if the app's window class doesn't
    have a background brush. Use a black brush for the background.

 Notes:

    This is an app specific shim.

 History:

    10/01/2000 maonis   Created
    11/07/2000 maonis   Added checking for Dirt Track Racing Sprint Cars window class.
    11/29/2000 andyseti Converted into AppSpecific shim.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DirtTrackRacing)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(CreateWindowExA) 
APIHOOK_ENUM_END

/*++
 
   Register a black brush for the window class.

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpwcx  
    )
{
    CSTRING_TRY
    {
        CString csClassName(lpwcx->lpszClassName);
        
        if ( !csClassName.CompareNoCase(L"DTR Class") || !csClassName.CompareNoCase(L"DTRSC Class"))
        {
            WNDCLASSA wcNewWndClass = *lpwcx;
            wcNewWndClass.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH);

            LOGN( 
                eDbgLevelError, 
                "RegisterClassA called. Register a black brush for the window class=%s.",
                lpwcx->lpszClassName);

            return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(RegisterClassA)(lpwcx);
}

/*++

 We need to hide the window at first so after you choose the mode and start the app it won't flicker.
 DDraw will automatically unhide the window.

--*/

HWND 
APIHOOK(CreateWindowExA)(
    DWORD dwExStyle,      
    LPCSTR lpClassName,  // registered class name
    LPCSTR lpWindowName, // window name
    DWORD dwStyle,        // window style
    int x,                // horizontal position of window
    int y,                // vertical position of window
    int nWidth,           // window width
    int nHeight,          // window height
    HWND hWndParent,      // handle to parent or owner window
    HMENU hMenu,          // menu handle or child identifier
    HINSTANCE hInstance,  // handle to application instance
    LPVOID lpParam        // window-creation data
    )
{
    CSTRING_TRY
    {
        CString csClassName(lpClassName);
        
        if ( !csClassName.CompareNoCase(L"DTR Class") || !csClassName.CompareNoCase(L"DTRSC Class"))
        {
            dwStyle &= ~WS_VISIBLE;
            LOGN( eDbgLevelError, 
                "CreateWindowExA called. Hide the window at first for the window class=%s.",
                lpClassName);
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(CreateWindowExA)(
        dwExStyle, 
        lpClassName, 
        lpWindowName, 
        dwStyle, 
        x, y, 
        nWidth, nHeight, 
        hWndParent, 
        hMenu, 
        hInstance, 
        lpParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, CreateWindowExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\dongfangyingdu.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DongFangYingDu.cpp

 Abstract:

    The app installs its own wmpui.dll (which I believe it is from Windows
    Media Play's 6.0) and then register it during installation and un-register
    it during un-installation. This makes WMP AV since this old DLL got loaded
    (through CoCreateInstance) the fix is make the app not bother to register / 
    unregister during the installation process.

 Notes: 
  
    This is an app specific shim.

 History:

    06/02/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DongFangYingDu)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(DllRegisterServer)
    APIHOOK_ENUM_ENTRY(DllUnregisterServer)
APIHOOK_ENUM_END

STDAPI 
APIHOOK(DllRegisterServer)(
    void
    )
{
    return S_OK;
}

STDAPI 
APIHOOK(DllUnregisterServer)(
    void
    )
{
    return S_OK;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WMPUI.DLL, DllRegisterServer)
    APIHOOK_ENTRY(WMPUI.DLL, DllUnregisterServer)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\dreye.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    DrEye.cpp

 Abstract:

    The App calls GetFocus Which returned NULL. This value was passed onto CWnd::FromHandle.
    CWnd::FromHandle returned NULL. App checked for this return value & threw AV.

    The fix is to return a valid handle when GetFocus is called.

 Notes:

    This is an app specific shim.

 History:

    01/07/2002 mamathas   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DrEye)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFocus)
APIHOOK_ENUM_END

/*++

 Hook GetFocus and try to return a valid handle.

--*/

HWND
APIHOOK(GetFocus)()
{
       HWND hWnd = ORIGINAL_API(GetFocus)();

       if (hWnd) {
           return hWnd;
       }
       else {
           return GetDesktopWindow();
       }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetFocus)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\easycdcreator4.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EasyCDCreator4.cpp

 Abstract:

    Prevent the uninstall program from deleting the whole 
    HKCR\Drive\ShellEx\ContextMenuHandlers key.

 Notes:

    This is an app specific shim.

 History:

    06/10/2001 maonis   Created

--*/

#include "precomp.h"
#include "strsafe.h"

IMPLEMENT_SHIM_BEGIN(EasyCDCreator4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA) 
APIHOOK_ENUM_END

/*++

 Return failure to this call so it doesn't attempt to delete the subkeys.

--*/

LONG
APIHOOK(RegOpenKeyA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    if (hKey == HKEY_CLASSES_ROOT && !strcmp(lpSubKey, "Drive"))
    {
        // We delete the key that the app created manually.
        RegDeleteKeyA(
            HKEY_CLASSES_ROOT, 
            "Drive\\shellex\\ContextMenuHandlers\\{df987040-eac5-11cf-bc30-444553540000}");

        return 1;
    }
    else
    {
        return ORIGINAL_API(RegOpenKeyA)(hKey, lpSubKey, phkResult);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ea3dsetup.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    EA3dSetup.cpp

 Abstract:

    EA Sports titles use something called a "Thrash driver", which is just a 
    graphics wrapper library. They currently appear to have at least 2 types, 
    one for DX and one for Voodoo. The Voodoo version is not supported on NT,
    because it uses Glide.

    The fix is to modify the registry to prevent the voodoo driver from 
    being used. The DirectX fallback works fine.

 Notes:

    This is a application specific shim.

 History:

    01/29/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EA3dSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++
 
 Cleanup voodoo thrash drivers if they're there.

--*/

void CleanupVoodoo()
{
#define EA_SPORTS_KEY L"SOFTWARE\\EA SPORTS"
#define THRASH_DRIVER L"Thrash Driver"
#define VOODOOX       L"voodoo"
#define DIRECTX       L"dx"

    HKEY hKey;
    
    if (RegOpenKeyW(HKEY_LOCAL_MACHINE, EA_SPORTS_KEY, &hKey) == ERROR_SUCCESS) {
        //
        // At least 1 EA Sports title exists, so enumerate through them
        //

        for (int i=0;; i++) { 
            WCHAR wzSubKey[MAX_PATH + 1];
            if (RegEnumKeyW(hKey, i, wzSubKey, MAX_PATH + 1) == ERROR_SUCCESS) {
                //
                // Check the THRASH_DRIVER key for voodoo*
                //

                HKEY hSubKey;

                if (RegOpenKeyW(hKey, wzSubKey, &hSubKey) == ERROR_SUCCESS) {
                    //
                    // Set the value to "dx" if it's voodoo
                    //

                    DWORD dwType;
                    WCHAR wzValue[MAX_PATH + 1] = L"\0";
                    DWORD cbData = sizeof(wzValue);
                    LONG lRet = RegQueryValueExW(hSubKey, THRASH_DRIVER, NULL, &dwType, (LPBYTE) wzValue, &cbData);

                    if ((lRet == ERROR_SUCCESS) &&
                        (dwType == REG_SZ) &&
                        (_wcsnicmp(wzValue, VOODOOX, wcslen(VOODOOX)) == 0)) {

                            cbData = (wcslen(DIRECTX) + 1) * sizeof(WCHAR);
                            lRet = RegSetValueExW(hSubKey, THRASH_DRIVER, 0, REG_SZ, (LPBYTE) DIRECTX, cbData);

                            if (lRet == ERROR_SUCCESS) {
                                LOGN(eDbgLevelError, "Modified VOODOO Thrash driver to DX");
                            } else {
                                LOGN(eDbgLevelError, "Failed to set VOODOO Thrash driver to DX");
                            }
                    }

                    RegCloseKey(hSubKey);
                }
            } else {
                // Done
                break;
            }
        }

        RegCloseKey(hKey);
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        CleanupVoodoo();
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\easycdcreator5.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    EasyCDCreator5.cpp

 Abstract:

    Clean up the filter drivers on the uninstaller on process termination.

 Notes:

    This is an app specific shim.

 History:

    08/09/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EasyCDCreator5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL 
StripStringFromValue(HKEY hKey, const WCHAR *lpValue, const WCHAR *lpStrip)
{
    DWORD dwType, dwSize;
    BOOL bRet = FALSE;
    WCHAR *lpString = NULL;

    //
    // Build the %systemdir%\drivers\filename.sys to see if it's available
    //
    CString csSystem;
    CSTRING_TRY
    {
        csSystem.GetSystemDirectoryW();
        csSystem += L"\\Drivers\\";
        csSystem += lpStrip;
        csSystem += L".sys";
    }
    CSTRING_CATCH
    {
        goto Exit;
    }

    //
    // Check to see if the file exists - if it does, we don't touch the registry
    //
    if (GetFileAttributesW(csSystem) != 0xFFFFFFFF) {
        DPFN(eDbgLevelError, "%S found so leave registry value alone", lpStrip);
        goto Exit;
    }

    //
    // Checking the registry for the bad state now
    //
    
    // Get the size
    if (ERROR_SUCCESS != RegQueryValueExW(hKey, lpValue, NULL, &dwType, NULL, &dwSize)) {
        DPFN(eDbgLevelError, "%S value not found", lpValue);
        goto Exit;
    }

    // Make sure it's a MULTI_STRING
    if (dwType != REG_MULTI_SZ) {
        DPFN(eDbgLevelError, "%S not correct type, expecting a multi-string", lpStrip);
        goto Exit;
    }

    // Allocate memory for it and clear it
    lpString = (WCHAR *) malloc(dwSize);
    if (!lpString) {
        DPFN(eDbgLevelError, "Out of memory");
        goto Exit;
    }
    ZeroMemory(lpString, dwSize);

    // Get the actual data
    if (ERROR_SUCCESS != RegQueryValueExW(hKey, lpValue, NULL, &dwType, (LPBYTE)lpString, &dwSize)) {
        DPFN(eDbgLevelError, "%S QueryValue failed unexpectedly", lpStrip);
        goto Exit;
    }

    // Allocate an output buffer
    WCHAR * lpNewString = (WCHAR *) malloc(dwSize);
    if (!lpNewString) {
        DPFN(eDbgLevelError, "Out of memory");
        goto Exit;
    }
    ZeroMemory(lpNewString, dwSize);

    // Run the input buffer looking for lpStrip
    WCHAR *lpCurr    = lpString;
    WCHAR *lpCurrOut = lpNewString;
    BOOL bStripped   = FALSE;
    while (*lpCurr) {
        if (_wcsicmp(lpCurr, lpStrip) != 0) {
            // Keep this entry
            if (StringCchCopyW(lpCurrOut, dwSize, lpCurr) != S_OK)
            {
                goto Exit;
            }
            lpCurrOut += wcslen(lpCurrOut) + 1;
            dwSize    -= wcslen(lpCurrOut) + 1;
        } else {
            // Remove this entry
            bStripped = TRUE;
        }

        lpCurr += wcslen(lpCurr) + 1;
    }

    if (bStripped) {
        //
        // Fix up the registry with the new value. If there's nothing left, then kill the 
        // value.
        // 
        LOGN(eDbgLevelError, "Removing filter driver - Value: %S, Name: %S", lpValue, lpStrip);

        dwSize = (lpCurrOut - lpNewString) * sizeof(WCHAR);
        if (dwSize == 0) {
            RegDeleteValueW(hKey, lpValue);
        } else {
            RegSetValueExW(hKey, lpValue, NULL, dwType, (LPBYTE) lpNewString, dwSize + sizeof(WCHAR));
        }
    }

    bRet = TRUE;

Exit:

    if (lpString) {
        free(lpString);
    }

    if (lpNewString) {
        free(lpNewString);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
   if (fdwReason == DLL_PROCESS_DETACH) {

       HKEY hKey;

       if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E965-E325-11CE-BFC1-08002BE10318}", &hKey)) {
           StripStringFromValue(hKey, L"UpperFilters", L"Cdralw2k");
           StripStringFromValue(hKey, L"LowerFilters", L"Cdr4_2K");

           RegCloseKey(hKey);
       }
   }

   return TRUE;
}

HOOK_BEGIN

   CALL_NOTIFY_FUNCTION   

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\dongfangkuaiche3000setup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DongFangKuaiChe3000Setup.cpp

 Abstract:

    At the end of setup, the app is calling CreateProcessA with following 
        
        "rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 \Z:\act\DongFangKuaiChe3000Pro\dfkc3000\MultiLanguage\Chinese\cn.inf"  
 
    there are altogether 4 calls to install Japanese/Chinese/Korean languagepack 
    (lagacy IE's langpack). The '\' before Z:\act\DongFang... is an extra one 
    and caused rundll32.exe fails in NT.

 Notes:

    This shim is to disable calls to install lagacy IE langpack, since NT has 
    already it's own.

 History:

    07/09/2001  xiaoz        Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DongFangKuaiChe3000Setup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


BOOL
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,                  // name of executable module
    LPSTR  lpCommandLine,                      // command line string
    LPSECURITY_ATTRIBUTES lpProcessAttributes, // SD
    LPSECURITY_ATTRIBUTES lpThreadAttributes,  // SD
    BOOL bInheritHandles,                      // handle inheritance option
    DWORD dwCreationFlags,                     // creation flags
    LPVOID lpEnvironment,                      // new environment block
    LPCSTR lpCurrentDirectory,                 // current directory name
    LPSTARTUPINFOA lpStartupInfo,              // startup information
    LPPROCESS_INFORMATION lpProcessInformation // process information
    )
{
    CSTRING_TRY
    {
        CString cstrPattern = L"rundll32.exe setupapi,InstallHinfSection DefaultInstall 132 \\";
        CString cstrCmdLine(lpCommandLine);
        int nIndex;
    
        nIndex = cstrCmdLine.Find(cstrPattern);
    
        if ( nIndex >=0 )
        {
            return TRUE;
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(CreateProcessA)(lpApplicationName, lpCommandLine, 
        lpProcessAttributes, lpThreadAttributes, bInheritHandles, 
        dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, 
        lpProcessInformation);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\encartaencyclopediadeluxe2k.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
    EncartaEncyclopediaDeluxe2K.cpp

 Abstract:

    This shim fixes a problem with Encarta Encyclopedia Deluxe 2000.

  Notes:

    This is an app specific shim.

 History:

    01/04/2001 a-brienw  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EncartaEncyclopediaDeluxe2K)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinExec) 
APIHOOK_ENUM_END

/*++

 Hook WinExec to see if Encarta is calling for MSINFO32.
 If so then direct it to the version that comes with the OS.

--*/

UINT
APIHOOK(WinExec)(
  LPSTR lpCmdLine,   // command line
  UINT uCmdShow      // window style
  )
{
    CSTRING_TRY
    {
        CString csCmdLine(lpCmdLine);
        
        int nMsinfoIndex = csCmdLine.Find(L"MSINFO32.EXE");
        if (nMsinfoIndex)
        {
            CString csCmdLine;
            SHGetSpecialFolderPathW(csCmdLine, CSIDL_PROGRAM_FILES_COMMON);
            csCmdLine += L"\\Microsoft Shared\\MSInfo\\msinfo32.exe";

            // Test for existance of the corrected path of msinfo32.exe
            HANDLE hFile = CreateFileW(csCmdLine, GENERIC_READ, FILE_SHARE_READ, 
                NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
            if( hFile != INVALID_HANDLE_VALUE )
            {
                CloseHandle( hFile );

                return ORIGINAL_API(WinExec)(csCmdLine.GetAnsi(), uCmdShow); 
            }
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    
    APIHOOK_ENTRY(KERNEL32.DLL, WinExec)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\dominantspecies.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    DominantSpecies.cpp

 Abstract:

    See Force21 shim - almost exactly the same problem.

    DominantSpecies contains an invalid check code that looks like the following:

        mov  esi,A
        mov  eax,B
        sub  eax,esi
        cmp  eax,ebp
        jle  @@Loc
        mov  eax,ebp
    @@Loc:

    In a particular case: B=-1 and A<0x80000000 this jump will be incorrectly 
    taken. The reason this works on Win9x is that A>0x80000000 because it's a 
    memory mapped file. On NT, no user mode address can normally be >2GB.

    This shim patches the app with a 'cli' instruction so that it can perform 
    some logic when the exception gets hit. This is admittedly slow.

    Note we didn't use the in memory patching facility of the shim because we
    still needed logic. It didn't make sense to split the shim from the patch.

    Also, we can't have a general shim which makes all memory addresses high and 
    catches the fallout, because game performance suffers too much. 

 Notes:

    This is an app specific shim.

 History:

    06/30/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DominantSpecies)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


/*++

 In memory patch the executable with a cli instruction. This patch works 
 for both the release version and a patch.

--*/

VOID
ExecutePatch()
{
    BYTE bPatchMatch[] = { 
        0x2b, 0xc6, 0x3b, 0xc5, 0x7c, 0x02, 0x8b, 0xc5, 0x85, 0xc0 };

    LPBYTE pPatchAddress[] = {
        (LPBYTE)0x53f543,       // the shipping version
        (LPBYTE)0x000000};      // placeholder for a vendor patch in case they get it wrong again
        
    BYTE bPatch = 0xFA;         // cli - to cause an exception

    //
    // Run through the patches and see which one matches
    //

    for (UINT j=0; j<sizeof(pPatchAddress)/sizeof(LPBYTE); j++)
    {
        LPBYTE pb = pPatchAddress[j];

        // Make sure it's an OK address.
        if (!IsBadReadPtr(pb, sizeof(bPatchMatch)))
        {
            // Check the bytes match
            for (UINT i=0; i < sizeof(bPatchMatch); i++)
            {
                if (*pb != bPatchMatch[i])
                {
                   break;
                }
                pb++;
            }

            // In memory patch
            if (i == sizeof(bPatchMatch))
            {
                DWORD dwOldProtect;
                if (VirtualProtect(
                      (PVOID)pPatchAddress[j],
                      1,
                      PAGE_READWRITE,
                      &dwOldProtect))
                {
                    *pPatchAddress[j] = bPatch;
                    LOGN(
                        eDbgLevelError,
                        "Successfully patched\n");
                    return;
                }
            }
        }
    }
}

/*++

 Handle the cli in such a way that the correct logic is performed.

--*/

LONG 
ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    CONTEXT *lpContext = ExceptionInfo->ContextRecord;

    if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_PRIV_INSTRUCTION)
    {
        // Looks like we've hit our cli instruction

        if ((LONG)lpContext->Eax < 0)   // Boundary condition, EDI<0
        {
            // Jump past the invalid check
            lpContext->Eip = lpContext->Eip + 6;
        }
        else
        {
            // Replace the 'sub edi,eax' and continue
            lpContext->Eax = lpContext->Eax - lpContext->Esi; 
            lpContext->Eip = lpContext->Eip + 2;
        }
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ExecutePatch();

        // Try to find new exception handler
        _pfn_RtlAddVectoredExceptionHandler pfnExcept;
        pfnExcept = (_pfn_RtlAddVectoredExceptionHandler)
            GetProcAddress(
                GetModuleHandle(L"NTDLL.DLL"), 
                "RtlAddVectoredExceptionHandler");

        if (pfnExcept)
        {
            (_pfn_RtlAddVectoredExceptionHandler) pfnExcept(
                0, 
                (PVOID)ExceptionFilter);
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\encompassmonitor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   EncompassMonitor.cpp  

 Abstract:

    Filters messages from the apps CBT WindowsHook.

 Notes:

    This is a general purpose shim. 
    
 History:

    01/30/2001  a-larrsh        Created
    02/18/2002  robkenny        Properly check the return value from GetTempPathA

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EncompassMonitor)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowsHookExA)
APIHOOK_ENUM_END


// Local Hook Information
HHOOK g_hCBTHook = NULL;
HOOKPROC g_OriginalEncompassMonitorCBTProc = NULL;

// Shared Data Infomation

#define SHARED_SECTION_NAME   "EncompassMonitor_SharedMemoryData"
typedef struct
{
   char     szModuleFileName[MAX_PATH];
   HANDLE   hModule;
   HOOKPROC pfnHookProc;

} SHARED_HOOK_INFO, *PSHARED_HOOK_INFO;

HANDLE g_hSharedMapping = NULL;
PSHARED_HOOK_INFO g_pSharedHookInfo = NULL;


// Creates Shared memory.  Only called by the originial SHIM
void CreateSharedMemory(HMODULE hModule, HOOKPROC pfnHookProc)
{
    HANDLE hSharedFile;
    char   szTempPath[MAX_PATH];
    char   szTempFileName[MAX_PATH];

    // create the memory mapped file necessary to communicate between the original Instanace of SHIM
    // and the following instances of SHIMS
    DWORD dwTemp = GetTempPathA(sizeof(szTempPath), szTempPath);
    if (dwTemp == 0 ||
        dwTemp > sizeof(szTempPath))
    {
        DPFN( eDbgLevelError, "GetTempPath failed\n");
        goto errCreateSharedSection;
    }

    if (GetTempFileNameA(szTempPath, "mem", NULL, szTempFileName) == 0) 
    {
        DPFN( eDbgLevelError, "GetTempFileName failed\n");
        goto errCreateSharedSection;
    }

    hSharedFile = CreateFileA(   szTempFileName,
                                 GENERIC_READ | GENERIC_WRITE,
                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                 NULL,
                                 CREATE_ALWAYS,
                                 FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                                 NULL);

    if (hSharedFile == NULL) 
    {
        DPFN( eDbgLevelError, "CreateFile failed to create '%s'\n", szTempFileName);
        goto errCreateSharedSection;
    }

    // Increase size of file (create the mapping)
    g_hSharedMapping = CreateFileMappingA(   hSharedFile,
                                             NULL,
                                             PAGE_READWRITE,
                                             NULL,
                                             sizeof(SHARED_HOOK_INFO),
                                             SHARED_SECTION_NAME);

    if (g_hSharedMapping == NULL) 
    {
        DPFN( eDbgLevelError, "CreateFileMapping failed\n");
        goto errCreateSharedSection;
    }

    g_pSharedHookInfo = (PSHARED_HOOK_INFO)MapViewOfFile(g_hSharedMapping,
                                                         FILE_MAP_ALL_ACCESS,
                                                         0,
                                                         0,
                                                         sizeof(SHARED_HOOK_INFO));

    if (g_pSharedHookInfo == NULL) 
    {
       DWORD dwErr = GetLastError();
       DPFN( eDbgLevelError, "MapViewOfFile failed [%d]", (int)dwErr);
       goto errCreateSharedSection;
    }

    CloseHandle(hSharedFile);

    g_pSharedHookInfo->hModule = hModule;
    g_pSharedHookInfo->pfnHookProc = pfnHookProc;
    if (0 == GetModuleFileNameA(hModule, g_pSharedHookInfo->szModuleFileName, MAX_PATH))
    {
        DPFN( eDbgLevelError, "GetModuleFileNameA failed\n");
        goto errCreateSharedSection;
    }
    
    if (!FlushViewOfFile(g_pSharedHookInfo, sizeof(SHARED_HOOK_INFO))) 
    {
        DPFN( eDbgLevelError, "FlushViewOfFile failed\n");
        goto errCreateSharedSection;
    }

    DPFN( eDbgLevelInfo, "WRITE::Shared Section Successful");
    DPFN( eDbgLevelInfo, "WRITE::g_pSharedHookInfo->hModule=%x", g_pSharedHookInfo->hModule);    
    DPFN( eDbgLevelInfo, "WRITE::g_pSharedHookInfo->pfnHookProc=%x", g_pSharedHookInfo->pfnHookProc);    
    DPFN( eDbgLevelInfo, "WRITE::g_pSharedHookInfo->szModuleFileName=%s", g_pSharedHookInfo->szModuleFileName);    
    
    return;

errCreateSharedSection:
    DPFN( eDbgLevelError, "WRITE::Shared Section FAILED");
   return;
}

// Gets Shared Memory - Only called by injected versions of hook function
void GetSharedMemory()
{
   HANDLE hSharedFileMapping = NULL;

   hSharedFileMapping = OpenFileMappingA( FILE_MAP_ALL_ACCESS,
                                         FALSE,
                                         SHARED_SECTION_NAME);   

   if (hSharedFileMapping != NULL) 
   {
      PSHARED_HOOK_INFO pSharedHookInfo = (PSHARED_HOOK_INFO)MapViewOfFile(  hSharedFileMapping,
                                                            FILE_MAP_ALL_ACCESS,
                                                            0,
                                                            0,
                                                            0);

      if (pSharedHookInfo)
      {      
         DPFN( eDbgLevelInfo, "READ::pSharedHookInfo->hModule=%x", pSharedHookInfo->hModule);    
         DPFN( eDbgLevelInfo, "READ::pSharedHookInfo->pfnHookProc=%x", pSharedHookInfo->pfnHookProc);    
         DPFN( eDbgLevelInfo, "READ::pSharedHookInfo->szModuleFileName=%s", pSharedHookInfo->szModuleFileName);    

         // Load DLL with original CBT Proc in it.
         HANDLE hMod = LoadLibraryA(pSharedHookInfo->szModuleFileName);

         if (!hMod)
         {
            DPFN( eDbgLevelError, "LoadLibrary(\"%s\") - FAILED", pSharedHookInfo->szModuleFileName);
         }

         g_OriginalEncompassMonitorCBTProc = (HOOKPROC)((DWORD)hMod + ((DWORD)pSharedHookInfo->pfnHookProc) - (DWORD)pSharedHookInfo->hModule);      
         DPFN( eDbgLevelInfo, "READ::Shared Section Successful - Original Hook at %x", g_OriginalEncompassMonitorCBTProc);

         CloseHandle(hSharedFileMapping);
         UnmapViewOfFile(pSharedHookInfo);
      }
      else
      {
         DPFN( eDbgLevelError, "MapViewOfFile() Failed");
      }
   }   
   else
   {
      DPFN( eDbgLevelError, "READ::Shared Section Failed");
   }
}

// Replacement CBT Hook function
LRESULT CALLBACK Filtered_EncompassMonitorCBTProc(
  int nCode,      // hook code
  WPARAM wParam,  // depends on hook code
  LPARAM lParam   // depends on hook code
)
{
   LRESULT lResult = 0; // Allow operation to continue
   bool bFilterMessage = false;   

   if (g_OriginalEncompassMonitorCBTProc == NULL)
   {
      GetSharedMemory();
   }

   if (nCode == HCBT_CREATEWND)
   {
      CBT_CREATEWNDA *pccw = (CBT_CREATEWNDA*)lParam;

      if ( (IS_INTRESOURCE(pccw->lpcs->lpszClass)) )
      {
         char szBuf[256];
         GetClassNameA((HWND)wParam, szBuf, 255);

         bFilterMessage=true;
         DPFN( eDbgLevelInfo, "[%x] - Filtered_EncompassMonitorCBTProc::HCBT_CREATEWND %s [ATOM CLASS FILTERED]", g_OriginalEncompassMonitorCBTProc, szBuf);
      }
      else
      {
         DPFN( eDbgLevelInfo, "[%x] - Filtered_EncompassMonitorCBTProc::HCBT_CREATEWND %s ", g_OriginalEncompassMonitorCBTProc, pccw->lpcs->lpszClass);
      }
   }

   if ( g_OriginalEncompassMonitorCBTProc )
   {
      if (bFilterMessage)
      {
         lResult = CallNextHookEx(g_hCBTHook, nCode, wParam, lParam);
      }
      else
      {
         lResult = g_OriginalEncompassMonitorCBTProc(nCode, wParam, lParam);      
      }
   }
   else
   {
      DPFN( eDbgLevelError, "Filtered_EncompassMonitorCBTProc:: ** BAD g_OriginalEncompassMonitorCBTProc2 **");

      lResult = CallNextHookEx(g_hCBTHook, nCode, wParam, lParam);      
   }

   return lResult;
}


// SHIMMED API
HHOOK APIHOOK(SetWindowsHookExA)(
  int idHook,        // hook type
  HOOKPROC lpfn,     // hook procedure
  HINSTANCE hMod,    // handle to application instance
  DWORD dwThreadId   // thread identifier
)
{ 
   static int nNumCBThooks = 0;
   
   HHOOK hHook;

   if (idHook == WH_CBT)
   {      
      nNumCBThooks++;

      switch(nNumCBThooks)
      {
      case 1:
         hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, lpfn, hMod, dwThreadId);
         DPFN( eDbgLevelInfo, "%x=SetWindowsHookEx(%d, %x, %x, %x) - Ignoring First Hook Call", hHook, idHook, lpfn, hMod, dwThreadId);
         break;

      case 2:
         g_OriginalEncompassMonitorCBTProc = lpfn;
         g_hCBTHook = hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, Filtered_EncompassMonitorCBTProc, g_hinstDll, dwThreadId);

         DPFN( eDbgLevelInfo, "%x=SetWindowsHookEx(%d, %x, %x, %x) - Replacing Hook with Filtered_EncompassMonitorCBTProc", hHook, idHook, lpfn, hMod, dwThreadId);

         CreateSharedMemory(hMod, lpfn);
         break;

      default:         
         hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, lpfn, hMod, dwThreadId);
         DPFN( eDbgLevelError, "SetWindowsHookEx -- More then 2  WH_CBT hooks [%d]", nNumCBThooks);
         break;
      }
   }
   else
   {
      hHook = ORIGINAL_API(SetWindowsHookExA)(idHook, lpfn, hMod, dwThreadId);         
   }

   return hHook;
}


BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
   if (fdwReason == DLL_PROCESS_DETACH)
   {
      if (g_hSharedMapping)
      {
         CloseHandle(g_hSharedMapping);
         g_hSharedMapping = NULL;
      }

      if (g_pSharedHookInfo)
      {
         UnmapViewOfFile(g_pSharedHookInfo);
         g_pSharedHookInfo = NULL;
      }
   }

   return TRUE;
}
   

/*++

 Register hooked functions

--*/

HOOK_BEGIN
   CALL_NOTIFY_FUNCTION   

   APIHOOK_ENTRY(USER32.DLL, SetWindowsHookExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\exchangeserversetup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ExchangeServerSetup.cpp

 Abstract:

    This is a non-reusable patch for Exchange Server Setup 5.5 for SP2 and SP3
    to change the parameters passed to xcopy. The reason for that is that
    Win2k's xcopy doesn't have the /y parameter a default parameter.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ExchangeServerSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessW)
APIHOOK_ENUM_END

/*++

 Change the parameters passed to xcopy.

--*/

BOOL
APIHOOK(CreateProcessW)(
    LPWSTR                lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPWSTR                lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    BOOL bRet;

    if (lpCommandLine != NULL) {

        int   cchSize = lstrlenW(lpCommandLine);
        WCHAR ch;

        if (cchSize > 12) {

            DPFN(
                eDbgLevelInfo,
                "[CreateProcessW] for \"%ws\".\n",
                lpCommandLine);

            ch = lpCommandLine[11];
            lpCommandLine[11] = 0;

            if (CompareStringW(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), 
                               NORM_IGNORECASE, 
                               lpCommandLine, 
                               -1, 
                               L"xcopy /s /e",
                               -1
                               ) == CSTR_EQUAL) {

                StringCchCopyW(lpCommandLine, cchSize + 1, L"xcopy /sye ");
                lpCommandLine[11] = ch;

                DPFN(
                    eDbgLevelInfo,
                    "[CreateProcessW] changed to \"%ws\".\n",
                    lpCommandLine);
                
            } else {
                lpCommandLine[11] = ch;
            }
        }
    }

    bRet = ORIGINAL_API(CreateProcessW)(
                            lpApplicationName,
                            lpCommandLine,
                            lpProcessAttributes,
                            lpThreadAttributes,
                            bInheritHandles,
                            dwCreationFlags,
                            lpEnvironment,
                            lpCurrentDirectory,
                            lpStartupInfo,
                            lpProcessInformation);
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\firefighters.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    FireFighters.cpp

 Abstract:

    This game stores the filenames it calls CreateFile on in a block of memory and
    occasionally it gets the offsets wrong and it's always off by 9 bytes.
    
 History:
        
    09/03/2000 maonis Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FireFighters)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
APIHOOK_ENUM_END


/*++

 Remove write attributes for read-only devices.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR                   lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    // if the 1st char is not '.' or an alphabetical char, we add 9 bytes to the filename pointer.
    char chFirst = *lpFileName;

    if (!isalpha(chFirst) && chFirst != '.')
    {
        lpFileName += 9;

        DPFN(
            eDbgLevelError,
            "[CreateFileA] filename is now %s", lpFileName);
    }

    HANDLE hRet = ORIGINAL_API(CreateFileA)(
                        lpFileName, 
                        dwDesiredAccess, 
                        dwShareMode, 
                        lpSecurityAttributes, 
                        dwCreationDisposition, 
                        dwFlagsAndAttributes, 
                        hTemplateFile);
    
    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\failsocket.cpp ===
/*++

 Copyright (c) 2003 Microsoft Corporation. All rights reserved.

 Module Name:

    FailSocket.cpp

 Abstract:

    This shim fails the socket call. (Goodnight Gracie...)
    Writes a message to the event log.

 Notes:

    This is a general purpose shim.

 History:

    01/30/2003  mnikkel, rparsons   Created
    02/21/2003  robkenny            Second attempt, fail WSAStartup

--*/
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(FailSocket)
#include "ShimHookMacro.h"
#include "acmsg.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WSAStartup)
    APIHOOK_ENUM_ENTRY(WSACleanup)
    APIHOOK_ENUM_ENTRY(WSAEnumProtocolsA)
    APIHOOK_ENUM_ENTRY(socket)
APIHOOK_ENUM_END

//
// Contains the name of the source from the registry.
// This is passed on the command-line from the XML.
// It appears in the 'Source' column in the Event Viewer.
//
CString* g_pcsEventSourceName = NULL;

/*++

 Responsible for making the actual entry in the event log.

--*/
void
MakeEventLogEntry(
    void
    )
{
    HANDLE  hEventLog = NULL;
    BOOL    bResult;

    //
    // Get a handle to the event log on the local computer.
    //
    hEventLog = RegisterEventSource(NULL, g_pcsEventSourceName->Get());

    if (NULL == hEventLog) {
        LOGN(eDbgLevelError,
            "[MakeEventLogEntry] 0x%08X Failed to register event source",
            GetLastError());
        goto cleanup;
    }

    //
    // Write the event to the event log.
    //
    bResult = ReportEvent(hEventLog,
                          EVENTLOG_INFORMATION_TYPE,
                          0,
                          ID_SQL_PORTS_DISABLED,
                          NULL,
                          0,
                          0,
                          NULL,
                          NULL);

    if (!bResult) {
        LOGN(eDbgLevelError,
            "[MakeEventLogEntry] 0x%08X Failed to make event log entry",
            GetLastError());
        goto cleanup;
    }

cleanup:
    if (hEventLog) {
        DeregisterEventSource(hEventLog);
        hEventLog = NULL;
    }
}

// Tell the app that there are no protocols available.
int
APIHOOK(WSAEnumProtocolsA)(
  LPINT lpiProtocols,
  LPWSAPROTOCOL_INFO lpProtocolBuffer,
  LPDWORD lpdwBufferLength
)
{
    if (lpProtocolBuffer == NULL && lpiProtocols == NULL)
    {
        *lpdwBufferLength = 1; // SSnetlib.dll will allocate this much data for the struct
    }
    else
    {
        MakeEventLogEntry();
    }

    // There are not protocols available.
    LOGN(eDbgLevelError, "WSAEnumProtocolsA returning 0");
    return 0;
}


// Noop the call to WSAStartup, but return success
int
APIHOOK(WSAStartup)(
  WORD wVersionRequested,
  LPWSADATA lpWSAData
)
{
    MakeEventLogEntry();
    LOGN(eDbgLevelError, "WSAStartup call has been prevented");
    return 0;
}

// Since we noop WSAStartup, we must noop WSACleanup
int
APIHOOK(WSACleanup) (void)
{
    return 0;
}


SOCKET
APIHOOK(socket)(
    int af,
    int type,
    int protocol
    )
{
    LOGN(eDbgLevelError,
         "Failing socket call: af = %d  type = %d  protocol = %d",
         af,
         type,
         protocol);

    MakeEventLogEntry();
    WSASetLastError(WSAENETDOWN);
    return INVALID_SOCKET;
}


/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            g_pcsEventSourceName = new CString(COMMAND_LINE);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(WSOCK32.DLL, socket)
    APIHOOK_ENTRY(Wsock32.DLL, WSAStartup)
    APIHOOK_ENTRY(Wsock32.DLL, WSACleanup)
    APIHOOK_ENTRY(Ws2_32.DLL,  WSAEnumProtocolsA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\europeanairwar.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    EuropeanAirWar.cpp

 Abstract:
    
    European Air War takes advantage of the fact GDI and DDRAW affect separate 
    palettes in win98. This causes a problem on win2k when EAW calls
    GetSystemPaletteEntries and expects the original GDI palette, but in win2k 
    it has be faded to black by DDRAW.  This fix restores the system palette at
    a convienient spot in SetSystemPaletteUse.  It also sets SYSPAL_STATIC 
    before creating dialog boxes.

    In addition this corrects an install problem that occurs when setting the 
    path for the readme file in a start->programs shortcut.

 Notes:

    This is an app specific shim and should NOT be
    included in the layer.

 History:

    10/23/2000 linstev  Created
    10/23/2000 mnikkel  Modified

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(EuropeanAirWar)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetSystemPaletteUse) 
    APIHOOK_ENUM_ENTRY(DialogBoxParamA)
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELL32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(SHELL32)

CString *   g_csArgBuffer = NULL;

/*++

 Retrieve the system palette and set the palette entries flag so the palette is 
 updated correctly.

--*/

UINT 
APIHOOK(SetSystemPaletteUse)(
    HDC hdc,      
    UINT uUsage   
    )
{
    UINT iRet = ORIGINAL_API(SetSystemPaletteUse)(hdc, uUsage);

    int i;
    HDC hdcnew;
    HPALETTE hpal, hpalold;
    LPLOGPALETTE plogpal;

    // Create a palette we can realize
    plogpal = (LPLOGPALETTE) malloc(sizeof(LOGPALETTE) + sizeof(PALETTEENTRY)*256);
    if ( plogpal )
    {
        LOGN( eDbgLevelError, "[EuropeanAirWar] APIHook_SetSystemPaletteUse reseting palette");

        plogpal->palVersion = 0x0300;
        plogpal->palNumEntries = 256;

        hdcnew = GetDC(0);

        GetSystemPaletteEntries(hdcnew, 0, 256, &plogpal->palPalEntry[0]);

        for (i=0; i<256; i++)
        { 
            plogpal->palPalEntry[i].peFlags = PC_RESERVED | PC_NOCOLLAPSE;
        }
        
        // Realize the palette
        hpal = CreatePalette(plogpal);
        hpalold = SelectPalette(hdcnew, hpal, FALSE);
        RealizePalette(hdcnew);
        SelectPalette(hdcnew, hpalold, FALSE);
        DeleteObject(hpal);

        ReleaseDC(0, hdcnew);

        free(plogpal);
    }
    else
    {
        LOGN( eDbgLevelError, "[EuropeanAirWar] APIHook_SetSystemPaletteUse failed to allocate memory");
    }

    return iRet;
}

/*++

 Set the Palette Use to static before creating a dialog box.

--*/

int 
APIHOOK(DialogBoxParamA)(
    HINSTANCE hInstance,  
    LPCSTR lpTemplateName,
    HWND hWndParent,      
    DLGPROC lpDialogFunc, 
    LPARAM dwInitParam    
    )
{
    int iRet;
    HDC hdc;

    LOGN( eDbgLevelError, "[EuropeanAirWar] APIHook_DialogBoxParamA setting palette static for dialog box");

    // Set the palette use to static to prevent
    // any color changes in the dialog box.
    if (hdc = GetDC(0))
    {
        SetSystemPaletteUse(hdc, SYSPAL_STATIC);
        ReleaseDC(0, hdc);
    }

    iRet = ORIGINAL_API(DialogBoxParamA)(
        hInstance,
        lpTemplateName,
        hWndParent,
        lpDialogFunc,
        dwInitParam);

    // Reset the palette use to NoStatic256
    // after dialog box has been displayed.
    // use 256 to prevent white dot artifacts.
    if (hdc = GetDC(0))
    {
        SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC256);
        ReleaseDC(0, hdc);
    }

    return iRet;
}

/*++

 Catch IShellLink::SetPathA and correct the wordpad path

--*/

HRESULT 
COMHOOK(IShellLinkA, SetPath)(
    PVOID pThis,
    LPCSTR pszFile 
    )
{
    HRESULT hrReturn = E_FAIL;
    PCHAR  pStr= NULL;
    CHAR   szBuffer[MAX_PATH];

    _pfn_IShellLinkA_SetPath pfnOld = ORIGINAL_COM(IShellLinkA, SetPath, pThis);

    if ( pfnOld )
    {
        CSTRING_TRY
        {
            // pszFile = "c:\windows\wordpad.exe command line arguments"
            // Strip off the arguments and save them for when they call IShellLinkA::SetArguments
            CString csFile(pszFile);

            int nWordpadIndex = csFile.Find(L"wordpad.exe");
            if (nWordpadIndex >= 0)
            {
                // Find the first space after wordpad.exe
                int nSpaceIndex = csFile.Find(L' ', nWordpadIndex);
                if (nSpaceIndex >= 0)
                {
                    // Save the cl args in g_csArgBuffer
                    g_csArgBuffer = new CString;
                    if (g_csArgBuffer)
                    {
                        csFile.Mid(nSpaceIndex, *g_csArgBuffer); // includes the space

                        csFile.Truncate(nSpaceIndex);
                    }
                }

                hrReturn = (*pfnOld)( pThis, csFile.GetAnsi() );
                return hrReturn;
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }

        hrReturn = (*pfnOld)( pThis, pszFile );
    }

    return hrReturn;
}


/*++

 Catch IShellLink::SetArguments and correct the readme path.

--*/

HRESULT 
COMHOOK(IShellLinkA, SetArguments)(
    PVOID pThis,
    LPCSTR pszArgs 
    )
{
    HRESULT hrReturn = E_FAIL;

    _pfn_IShellLinkA_SetArguments pfnOld = ORIGINAL_COM(IShellLinkA, SetArguments, pThis);
    if (pfnOld)
    {
        if (g_csArgBuffer && !g_csArgBuffer->IsEmpty())
        {
            CSTRING_TRY
            {
                CString csArgs(pszArgs);
                *g_csArgBuffer += L" ";
                *g_csArgBuffer += csArgs;

                hrReturn = (*pfnOld)( pThis, g_csArgBuffer->GetAnsi() );
                                
                // Delete the buffer so we don't add these args to everthing
                delete g_csArgBuffer;
                g_csArgBuffer = NULL;

                return hrReturn;
            }
            CSTRING_CATCH
            {
                // Do Nothing
            }
        }

        hrReturn = (*pfnOld)( pThis, pszArgs );
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, SetSystemPaletteUse)
    APIHOOK_ENTRY(USER32.DLL, DialogBoxParamA)

    APIHOOK_ENTRY_COMSERVER(SHELL32)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetPath, 20)
    COMHOOK_ENTRY(ShellLink, IShellLinkA, SetArguments, 11)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\f18carrier.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    F18Carrier.cpp

 Abstract:

    This fixes 2 problems:
        
      1. In the Officers quarters, while reading the flight manual, pressing 
         escape minimizes the app. This happens on win9x as well, but since 
         the app does not recover well from task switching, we ignore the
         syskey messages that caused the switch.

      2. The dialogs are cleared after drawing by a paint message that goes to
         the parent window after the dialog is drawn. Since they use a 
         DirectDraw Blt to draw, they are not aware of that they're drawing 
         over the dialog. On win9x, this extra paint message does not come 
         through, but it's not clear why.

         We fix this by validating the drawing rect after after the paint 
         message has come through.

    The window handling of the app is really weird, they have 2 main windows
    at any one time and switch focus between them. Then they have Screen*.dll 
    files which each contain WndProcs which handle individual parts of the UI.

 Notes:

    This is an app specific shim.

 History:

    07/12/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(F18Carrier)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(RegisterClassW) 
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(RegisterClassExW) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongW) 
APIHOOK_ENUM_END

/*++

 Validate after paint and filter syskey messages.

--*/

LRESULT 
CALLBACK 
F18Carrier_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    LRESULT lRet;
    RECT r;

    if ((uMsg == WM_PAINT) && (GetUpdateRect(hwnd, &r, FALSE)))
    {
        lRet = (*pfnOld)(hwnd, uMsg, wParam, lParam);    
    
        //
        // Only do this for certain window classes, to prevent side-effects
        //
        WCHAR szName[MAX_PATH];
        if (GetClassNameW(hwnd, szName, MAX_PATH))
        {
            if (!wcsistr(szName, L"UI Class")) 
            {
                return lRet;
            }
        }

        LOGN(
            eDbgLevelSpew,
            "Validating after paint");

        ValidateRect(hwnd, &r);
    }
    else if ((uMsg == WM_SYSKEYDOWN) || (uMsg == WM_SYSKEYUP))
    { 
        LOGN(
            eDbgLevelSpew,
            "Removing syskey messages");

        return 0;
    }
    else
    {
        lRet = (*pfnOld)(hwnd, uMsg, wParam, lParam);    
    }

    return lRet;
}

/*++

 The dialogproc hook

--*/

INT_PTR 
CALLBACK 
F18Carrier_DialogProcHook(
    DLGPROC   pfnOld,   
    HWND      hwndDlg,  
    UINT      uMsg,     
    WPARAM    wParam,   
    LPARAM    lParam    
    )
{
    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  
    )
{
    WNDCLASSW wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  
    )
{
    WNDCLASSEXA wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  
    )
{
    WNDCLASSEXW wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, F18Carrier_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    { 
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, F18Carrier_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\gangsters.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Gangsters.cpp

 Abstract:

    This shim hooks FindFirstFileA and FindNextFileA to simulate the
    finding of files named "$$$$$$$$.$$$" 8 times in total.  Gangsters
    apparently changed the FAT on their CD to make it appear to Win9x
    as if there were 8 of these files on the CD.

    It also hooks mciSendCommand to return 10 as the number of tracks
    on the CD instead of 11.

 History:

 07/12/2000 t-adams    Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(Gangsters)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindNextFileA)
    APIHOOK_ENUM_ENTRY(mciSendCommandA)
APIHOOK_ENUM_END


int g_iTimesFound = 0;
HANDLE g_hIntercept = INVALID_HANDLE_VALUE;

/*++

  Abstract:
    Pass the FindFirstFile call through, but if it was trying to find a file
    named "$$$$$$$$.$$$" then remember the handle to be returned so that we
    can intercept subsequent attempts to find more files with the same name.

  History:

  07/12/2000    t-adams     Created

--*/

HANDLE APIHOOK(FindFirstFileA)(
            LPCSTR lpFileName,
            LPWIN32_FIND_DATAA lpFindFileData) {

    HANDLE hRval;

    hRval = ORIGINAL_API(FindFirstFileA)(lpFileName, lpFindFileData);

    if( strcmp(&lpFileName[3], "$$$$$$$$.$$$") == 0 ) {
        DPFN( eDbgLevelSpew, "FindFirstFileA: Beginning spoof of \"$$$$$$$$.$$$\"");
        g_hIntercept = hRval;
        g_iTimesFound = 1;
    }

    return hRval;
}


/*++

  Abstract:
     If the handle is of the search that we are intercepting, then report
     that a match has been found up to eight times.  Don't bother changing
     lpFindFileData because Gangsters only checks for the existance of the
     files, not for any information about them.
       Otherwise, just pass the call through.

  History:
  
    07/12/2000  t-adams     Created

--*/

BOOL APIHOOK(FindNextFileA)(
            HANDLE hFindFile, 
            LPWIN32_FIND_DATAA lpFindFileData) {

    BOOL bRval;

    if( hFindFile == g_hIntercept ) {
        if( 8 == g_iTimesFound ) {
            g_hIntercept = INVALID_HANDLE_VALUE;
            SetLastError(ERROR_NO_MORE_FILES);
            bRval = FALSE;
        } else {
            g_iTimesFound++;
            DPFN( eDbgLevelSpew, "FindNextFileA: Spoofing \"$$$$$$$$.$$$\" occurrence %d", g_iTimesFound);
            bRval = TRUE;
        }
    } else {
        bRval = ORIGINAL_API(FindNextFileA)(hFindFile, lpFindFileData);
    }

    return bRval;
}


/*++

  Abstract:
    If the app is trying to find the number of tracks on the CD, return 10.
    Otherwise, pass through.

  History:
  
    07/13/2000  t-adams     Created

--*/

MCIERROR APIHOOK(mciSendCommandA)(
                MCIDEVICEID IDDevice, 
                UINT uMsg,             
                DWORD fdwCommand, 
                DWORD dwParam) {

    MCIERROR rval;
    
    rval = ORIGINAL_API(mciSendCommandA)(IDDevice, uMsg, fdwCommand, dwParam);

    if( uMsg==MCI_STATUS && fdwCommand==MCI_STATUS_ITEM && 
        ((LPMCI_STATUS_PARMS)dwParam)->dwItem==MCI_STATUS_NUMBER_OF_TRACKS) 
    {
        DPFN( eDbgLevelSpew, "MCI_STATUS_NUMBER_OF_TRACKS -> 10");
        ((LPMCI_STATUS_PARMS)dwParam)->dwReturn = 10;
    }

    return rval;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, FindNextFileA)
    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\gizmos.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Gizmos.cpp

 Abstract:

    The Shredder and Vault Explorer extensions both call
    SetWindowLong(GWL_STYLE) with improper style values.

 Notes:

    This is an app specific shim.

 History:

    04/12/2001  robkenny    Created

--*/

#include "precomp.h"
#include <shlguid.h>

IMPLEMENT_SHIM_BEGIN(Gizmos)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_COMSERVER(SHELLX98)
APIHOOK_ENUM_END


// This is the CLSID the application placed in the registry:
// c500687e 11ceab3b 00006884 6b2768b4

// Can't use the DEFINE_GUID macro, since INITGUID was not defined in the PCH.
//DEFINE_GUID(CLSID_Gizmos, 0xc500687d, 0xab3b, 0x11ce, 0x84, 0x68, 0x00, 0x00, 0xb4, 0x68, 0x27, 0x6b);
const GUID CLSID_Vault      = { 0xc500687d, 0xab3b, 0x11ce, { 0x84, 0x68, 0x00, 0x00, 0xb4, 0x68, 0x27, 0x6b } };
const GUID CLSID_Shredder   = { 0xc500687e, 0xab3b, 0x11ce, { 0x84, 0x68, 0x00, 0x00, 0xb4, 0x68, 0x27, 0x6b } };



typedef HRESULT     (*_pfn_IShellFolder_CreateViewObject)(PVOID pThis, HWND hwndOwner, REFIID riid, VOID **ppv);
typedef HRESULT     (*_pfn_IShellView_CreateViewWindow)(PVOID pThis, IShellView *psvPrevious, LPCFOLDERSETTINGS pfs, IShellBrowser *psb, RECT *prcView, HWND *phWnd );

IMPLEMENT_COMSERVER_HOOK(SHELLX98)

/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetPath

--*/
HRESULT COMHOOK(IShellFolder, CreateViewObject)(
    PVOID pThis,
    HWND hwndOwner,
    REFIID riid,
    VOID **ppv )
{
    HRESULT hReturn = ORIGINAL_COM(IShellFolder, CreateViewObject, pThis)(pThis, hwndOwner, riid, ppv);

    if (hReturn == NOERROR)
    {
        // Only hook IShellView objects
        if (IsEqualGUID(riid,  IID_IShellView))
        {

            // We don't know the CLSID, but since this routine is only called
            // for IShellFolder's that were created by ShellX98.dll;
            // we really don't need to know: it can only be one of the two
            // IShellFolder CLSID that we hooked.
            HookObject(
                NULL,  
                riid, 
                ppv,
                NULL, 
                FALSE);
        }
    }

    return hReturn;
}


/*++

    Convert Win9x paths to WinNT paths for IShellLinkW::SetPath

--*/
HRESULT COMHOOK(IShellView, CreateViewWindow)(
    PVOID pThis,
    IShellView *psvPrevious,
    LPCFOLDERSETTINGS pfs,
    IShellBrowser *psb,
    RECT *prcView,
    HWND *phWnd
)
{
    LPFOLDERSETTINGS lpFolderSettings = const_cast<LPFOLDERSETTINGS>(pfs);

    // ShellX98.dll only handles ViewModes FVM_ICON to FVM_THUMBNAIL
    if (lpFolderSettings->ViewMode > FVM_THUMBNAIL)
    {
        LOGN( eDbgLevelError, "[IShellView::CreateViewWindow] forced FOLDERSETTINGS->ViewMode from %d to %d", lpFolderSettings->ViewMode, FVM_ICON);
        lpFolderSettings->ViewMode = FVM_ICON;
    }

    HRESULT hReturn = ORIGINAL_COM(IShellView, CreateViewWindow, pThis)(pThis, psvPrevious, lpFolderSettings, psb, prcView, phWnd);
    return hReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_COMSERVER(SHELLX98)

    // Explorer creates an IShellFolder via ShellX98.dll's class factory.
    // Eventually it calls IShellFolder::CreateViewObject to create an 
    // IShellView object.  We want to shim IShellView::CreateViewWindow.

    COMHOOK_ENTRY(Vault,    IShellFolder, CreateViewObject, 8)
    COMHOOK_ENTRY(Shredder, IShellFolder, CreateViewObject, 8)

    COMHOOK_ENTRY(Vault,    IShellView,   CreateViewWindow, 9)
    COMHOOK_ENTRY(Shredder, IShellView,   CreateViewWindow, 9)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\force21.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Force21.cpp

 Abstract:

    Force21 contains an invalid check code that looks like the following:

        mov  ebx,A
        mov  edi,B
        mov  eax,C
        sub  edi,eax
        cmp  edi,ebx
        jle  @@Loc
        mov  edi,ebx
    @@Loc:

    In a particular case: B=-1 and C<0x80000000 this jump will be incorrectly 
    taken. The reason this works on Win9x is that C>0x80000000 because it's a 
    memory mapped file. On NT, no user mode address can be >2GB.

    This shim patches the app with a 'cli' instruction so that it can perform 
    some logic when the exception gets hit. This is admittedly slow.

    Note we didn't use the in memory patching facility of the shim because we
    still needed logic. It didn't make sense to split the shim from the patch.

 History:

    04/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Force21)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


/*++

 In memory patch the executable with a cli instruction. This patch works 
 for both the release version and a patch.

--*/

VOID
Force21_ExecutePatch()
{
    BYTE bPatchMatch[] = { 
        0x2b, 0xf8, 0x3b, 0xfb, 0x7c, 
        0x02, 0x8b, 0xfb, 0x85, 0xff };

    LPBYTE pPatchAddress[] = {
        (LPBYTE)0x5aa1f3,       // the shipping version
        (LPBYTE)0x5ac4a0 };     // with patch 1 applied
        
    BYTE bPatch = 0xFA;         // cli - to cause an exception

    //
    // Run through the patches and see which one matches
    //

    for (UINT j=0; j<sizeof(pPatchAddress)/sizeof(LPBYTE); j++)
    {
        LPBYTE pb = pPatchAddress[j];

        // Make sure it's an OK address.
        if (!IsBadReadPtr(pb, sizeof(bPatchMatch)))
        {
            // Check the bytes match
            for (UINT i=0; i < sizeof(bPatchMatch); i++)
            {
                if (*pb != bPatchMatch[i])
                {
                   break;
                }
                pb++;
            }

            // In memory patch
            if (i == sizeof(bPatchMatch))
            {
                DWORD dwOldProtect;
                if (VirtualProtect(
                      (PVOID)pPatchAddress[j],
                      1,
                      PAGE_READWRITE,
                      &dwOldProtect))
                {
                    *pPatchAddress[j] = bPatch;
                    LOGN(
                        eDbgLevelError,
                        "Successfully patched\n");
                    return;
                }
            }
        }
    }
}

/*++

 Handle the cli in such a way that the correct logic is performed.

--*/

LONG 
Force21_ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    CONTEXT *lpContext = ExceptionInfo->ContextRecord;

    if (ExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_PRIV_INSTRUCTION)
    {
        // Looks like we've hit our cli instruction

        if ((LONG)lpContext->Edi < 0)   // Boundary condition, EDI<0
        {
            // Jump past the invalid check
            lpContext->Eip = lpContext->Eip + 6;
        }
        else
        {
            // Replace the 'sub edi,eax' and continue
            lpContext->Edi = lpContext->Edi - lpContext->Eax; 
            lpContext->Eip = lpContext->Eip + 2;
        }
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        Force21_ExecutePatch();
        SetUnhandledExceptionFilter(Force21_ExceptionFilter);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\herosdvd.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HeroSDVD.cpp

 Abstract:
    Background: clicking the nonclient close button when a movie clip is playing causes the app 
    to hang and then AV when themes are active.   The DisableThemes shim has no effect.
 
    This is related to the app's repeated calls to SetClassLong(hwnd, GCL_HICON) in order to produce 
    the effect of an animated window icon.   This generates frequent requests to redraw the window's icon, 
    which in turn generates the NCUAHDRAWCAPTION.   This is a huge perf hit to the app in any case, 
    but particularly if the SetClassLong call makes an extra round trip to user mode and back as a 
    result of the SendMessage.    
 
    When the user hits the Close button, the app's WM_SYSCOMMAND handler resets an event that is waited 
    on by the icon-transitioning thread, and then puts himself (the UI thread) to sleep.    
    Then he calls SetClassLong(..., GCL_ICON) one last time from the icon-switching thread, 
    which hangs the app because the message-pumping thread is sleeping. This does not repro when win32k 
    doesn't send the NCUAHDRAWCAPTION message; i.e., when user API hooks are not active.
 
    The DisableTheme does not work because this shim operates in user mode on a per-process basis.
    This shim has no effect on win32k, which does special processing on a session-wide basis when themes are enabled.
 
    To address this, we shim this app to nop on SetClassLong(..., GCL_HICON), which means the app at 
    best loses animation of the icon and at worst display a bogus icon when themes are active, 


 Notes:
    
    This is an app specific shim.

 History:

    05/11/2001 scotthan  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HeroSDVD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetClassLongA) 
APIHOOK_ENUM_END

typedef BOOL (STDAPICALLTYPE * PFNTHEMEACTIVE)(void);
PFNTHEMEACTIVE g_pfnThemeActive;
HINSTANCE      g_hinstUxtheme;

HINSTANCE LoadUxTheme()
{
    if( NULL == g_hinstUxtheme )
    {
        HINSTANCE hinst = LoadLibrary(TEXT("UxTheme.dll"));
        if( NULL != hinst )
        {
            if( InterlockedCompareExchangePointer( (PVOID*)&g_hinstUxtheme, hinst, NULL ) )
            {
                FreeLibrary(hinst); // already loaded.
            }
        }
    }
    return g_hinstUxtheme;
}

DWORD 
APIHOOK(SetClassLongA)(
    IN HWND hwnd,
    IN int nIndex,
    IN LONG dwNewLong 
    )
{
    if( GCL_HICON == nIndex )
    {
        if( NULL == g_pfnThemeActive )
        {
            HINSTANCE hinst = LoadUxTheme();
            if( hinst )
            {
                g_pfnThemeActive = (PFNTHEMEACTIVE)GetProcAddress( hinst, "IsThemeActive" );
            }
        }

        if( g_pfnThemeActive && g_pfnThemeActive() )
        {
            //  no-op the request to change icon, and return the current one.
            return GetClassLongA(hwnd, nIndex);
        }
    }

    return ORIGINAL_API(SetClassLongA)(hwnd, nIndex, dwNewLong);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if( DLL_PROCESS_ATTACH == fdwReason )
    {
        g_hinstUxtheme   = NULL;
        g_pfnThemeActive = NULL;
    }
    else if( DLL_PROCESS_DETACH == fdwReason )
    {
        if( g_hinstUxtheme )
        {
            FreeLibrary(g_hinstUxtheme);
            g_hinstUxtheme = NULL;
        }
        g_pfnThemeActive = NULL;
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, SetClassLongA )
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\hotfaxmessagecenter4.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HotFaxMessageCenter4.cpp
 Abstract:
    The app was AV'ing as it was passing a NULL handle
    ontained from GetDlgItem() to another call.
    This appspecific SHIM prevents that from happening.

    This is an app specific shim.

 History:
 
    03/13/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HotFaxMessageCenter4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDlgItem)    
APIHOOK_ENUM_END


/*++
    Correct the returned HANDLE if it is NULL by passsing the previous valid    
    HANDLE
--*/

HWND
APIHOOK(GetDlgItem)(
    HWND hDlg,
    int nIDDlgItem
    )
{
    static HWND hDlgItem = 0;
    HWND hCurDlgItem = 0;

    hCurDlgItem = ORIGINAL_API(GetDlgItem)(hDlg, nIDDlgItem);

    if (hCurDlgItem != NULL)
    {
        hDlgItem = hCurDlgItem;
    }

    return hDlgItem;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetDlgItem)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\hptourguide.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    HPTourGuide.cpp

 Abstract:

    The application causes Explorer to crash when
    a tour is selected. To fix we are eating LVM_GETITEMA
    messages if the window handle matches the ListView
    that the app was sending to.
    Fix for Whistler bug #177103
    
 Notes:

    This is an app specific shim.

 History:

    03/28/2001  robdoyle    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HPTourGuide)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
APIHOOK_ENUM_END

/*++

  Eat LVM_GETITEMA messages for a specific hWnd

--*/

BOOL
APIHOOK(SendMessageA)(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{

    LRESULT lRet;


    HWND hWnd_TARGET, hWnd_temp;

    hWnd_temp = FindWindowExA (NULL, NULL, "Progman", "Program Manager");    
    hWnd_temp = FindWindowExA (hWnd_temp, NULL, "SHELLDLL_DefView", NULL);
    hWnd_TARGET = FindWindowExA (hWnd_temp, NULL, "SysListView32", NULL);


    if ((hWnd == hWnd_TARGET) && (uMsg == LVM_GETITEMA))
    {
        /* Uncomment to aid debugging
        DPFN( eDbgLevelError, "bypassing SendMessage of LVM_GETITEMA");
        */

        lRet = TRUE;
    }

    else
    {
    lRet = ORIGINAL_API(SendMessageA)(
        hWnd,
        uMsg,
        wParam,
        lParam);
    }
    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SendMessageA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\hoylegames.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    HoyleGames.cpp

 Abstract:
   
     All Hoyle apps have one common problem and that is a hard
     coded "C:\" in its data section of the image.The apps crash
     because of this if installed and run from any other drive
     other than C:\.
        This shim goes through the image of the app searching
     for the hardcoded string and replaces them if found. This 
     shim replaces all the existing app specific shims for
     Hoyle Games.

     This is an app specific shim.


 History:

    04/17/2001  Prashkud    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HoyleGames)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA) 
APIHOOK_ENUM_END

// Max Virtual address replacements in all sections
#define MAX_VA          50

// Global array to hold the replacement VA 
DWORD g_ReplaceVA[MAX_VA];

// Replacement count
int g_ReplaceCnt;

/*++

    Parse the Section and fill in the location index into the 
    SECTION structure. This function also fills in the number
    of occurences of the hard-coded "C:\" string in this section.

--*/

BOOL
GetReplacementLocations(
    DWORD dwSecPtr,
    DWORD dwSize
    )
{
    BYTE *pbFilePtr = (BYTE*)dwSecPtr;
    BOOL bRet = FALSE;


    for (DWORD i = 0; i < dwSize - 2 && g_ReplaceCnt < MAX_VA; i++)
    {
        if ((BYTE)*(pbFilePtr + i) == 'c')
        {
            if((BYTE)*(pbFilePtr + i + 1) == ':' &&
               (BYTE)*(pbFilePtr + i + 2) == '\\')
            {
                g_ReplaceVA[g_ReplaceCnt++] = dwSecPtr + i;
                bRet = TRUE;                
            }
        }
    }
    return bRet;
}

/*++

    This function loops through each section looking for a Initialized Data
    section. Once it gets the Initialized Data section, it calls the helper
    function GetReplacementLocations() to get the offset from the base of the 
    section. It then calculates the Virtual Address at which the replacement
    should occur.

--*/

BOOL
GetInitializedDataSection()
{
    PIMAGE_NT_HEADERS NtHeader;
    PIMAGE_FILE_HEADER FileHeader;
    PIMAGE_OPTIONAL_HEADER OptionalHeader;
    PIMAGE_SECTION_HEADER NtSection;
    DWORD dwSectionVA = 0, dwSize = 0;    
    BOOL bRet = FALSE;

    // Get the module base address
    PUCHAR Base = (PUCHAR)GetModuleHandle(NULL);

    if ((ULONG_PTR)Base & 0x00000001) 
    {
        Base = (PUCHAR)((ULONG_PTR)Base & ~0x1);        
     }

    NtHeader = RtlpImageNtHeader(Base);

    if (NtHeader) 
    {
        FileHeader = &NtHeader->FileHeader;
        OptionalHeader = &NtHeader->OptionalHeader;
    } 
    else 
    {
        // Handle case where Image passed in doesn't have a dos stub (ROM images for instance);
        FileHeader = (PIMAGE_FILE_HEADER)Base;
        OptionalHeader = (PIMAGE_OPTIONAL_HEADER) ((ULONG_PTR)Base + IMAGE_SIZEOF_FILE_HEADER);
    }

    NtSection = (PIMAGE_SECTION_HEADER)((ULONG_PTR)OptionalHeader +
                FileHeader->SizeOfOptionalHeader);


    for (DWORD i=0; i<FileHeader->NumberOfSections; i++) 
    {
        // Check whether the section is a Initialized Data Section
        if (NtSection->Characteristics & IMAGE_SCN_CNT_INITIALIZED_DATA) 
        {
            // Size of the Section to search         
            dwSize = NtSection->SizeOfRawData;

            // Get the Section's Virtual address
            dwSectionVA = (DWORD)(Base + NtSection->VirtualAddress);

            __try
            {               
                if(GetReplacementLocations(dwSectionVA, dwSize))
                {
                    bRet = TRUE;
                }
                DPFN( eDbgLevelError, "Replacing was successful");
                
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                DPFN( eDbgLevelError, "Replacing crashed");
                goto Exit;
            }

        }

        ++NtSection;
    }
    return bRet;


Exit:
    return FALSE;
}

/*++

 This function hooks GetVersion (called early on by Hoyle Board Games)
 and replaces the hard coded 'c's with the correct install drive letter
 that it looks up in the registry.
    
 It uses g_HoyleWordGames_bPatched to patch only once.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        CHAR szProgFilesDir[MAX_PATH];      // Added by Noah Young on 1/26/01
        DWORD cch          = ARRAYSIZE(szProgFilesDir);
        HKEY hKey          = 0;
        DWORD dwOldProtect = 0;    

        
     
        // Fix problem where Program Files dir isn't on same drive as BOARD3.EXE
        if( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                              "SOFTWARE\\Microsoft\\Windows\\CurrentVersion",
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKey) ) 
        {
            if( ERROR_SUCCESS == RegQueryValueExA(hKey,
                "ProgramFilesDir",
                NULL,
                NULL,  // REG_SZ
                (LPBYTE)szProgFilesDir,
                &cch) ) 
            {
                // Scan the image's initialized data section....    
                char szModule[MAX_PATH];

                cch = GetModuleFileNameA(NULL, szModule, ARRAYSIZE(szModule));
                if( cch > 0 && cch < ARRAYSIZE(szModule) )
                {
                    // Get the Virtual adresses that need to be replaced
                    if(GetInitializedDataSection())
                    {
                        long PATCH_LENGTH = g_ReplaceVA[ g_ReplaceCnt - 1] - g_ReplaceVA[0] + 1;

                        // Make the memory page writable
                        if( VirtualProtect( (PVOID) g_ReplaceVA[0],
                            PATCH_LENGTH,
                            PAGE_READWRITE,
                            &dwOldProtect ) ) 
                        {
                            for (int i=0; i< g_ReplaceCnt; i++)
                            {
                                // Make sure it's what we expect
                                if( 'c' == *((CHAR*) g_ReplaceVA[i]) )
                                {
                                    if (i==0)
                                    {
                                        *((CHAR*) g_ReplaceVA[i]) = szProgFilesDir[0];  
                                    }
                                    else
                                    {
                                        *((CHAR*) g_ReplaceVA[i]) = szModule[0];
                                    }
                                }
                            }
                        }
                    } else {
                        DPFN( eDbgLevelError, "No patching done!");
                    }
                } else {
                    DPFN( eDbgLevelError, "GetModuleFileNameA failed!");
                }
            } else {
                DPFN( eDbgLevelError, "Failed to query \"ProgramFilesDir\"!");
            }
            RegCloseKey(hKey);
        } else {
            DPFN( eDbgLevelError, "Failed to open key \"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\"!");
        }
    }

    return TRUE;
}

/*++

 Very specific hack to return a good FaceMaker path, so the app doesn't fail
 when it is installed on the wrong drive.

--*/

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    CSTRING_TRY
    {
        CString csApp = lpAppName;
        CString csKey = lpKeyName;
        CString csFile = lpFileName;

        if ((csApp.Compare(L"Settings") == 0) && 
            (csKey.Compare(L"FaceMakerPath") == 0) && 
            (csFile.Find(L"CARDGAME.INI") > -1)) {

            DWORD dwRet = ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, 
                lpDefault, lpReturnedString, nSize, lpFileName);

            if (!dwRet) {
                // Substitute the right path
                CString csPath = L"%ProgramFiles%\\WON\\FaceMaker";
                csPath.ExpandEnvironmentStringsW();
                if (lpReturnedString && ((int)nSize > csPath.GetLength())) {
                    LOGN(eDbgLevelError, "[GetPrivateProfileStringA] Forced correct FaceMaker path");
                    strncpy(lpReturnedString, csPath.GetAnsi(), nSize);
                    dwRet = csPath.GetLength();
                }
            }

            return dwRet;
        }
    }
    CSTRING_CATCH
    {
        // fall through
    }

    
    return ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, 
                lpDefault, lpReturnedString, nSize, lpFileName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION    
    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\htmleditor8587.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    HTMLEditor8587.cpp

 Abstract:

     HTML Editor 8.5/8.7 Call CreateFileA without closing the
     handle that was opened with the first call to CreateFileA.
     This SHIM hooks CreateFileA and CloseHandle and ensures
     that the temporary file is deleted and the handle closed
     before the next call to CreateFileA with the same filename.

    This is an app specific shim.

 History:
 
    02/06/2001 prashkud  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
#include "strsafe.h"

IMPLEMENT_SHIM_BEGIN(HTMLEditor8587)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN  
    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CloseHandle)
APIHOOK_ENUM_END


HANDLE g_FileHandle = 0;

/*++

 Hook CreateFileA so that we can monitor the filename
 and the handle and ensure that the previous handle that
 was opened is closed before this call to the same file.

--*/

HANDLE
APIHOOK(CreateFileA)(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpsa,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTempFile
    )
{
    if (g_FileHandle && (stristr(lpFileName, "\\working\\~tm") != NULL))
    {
        DeleteFileA(lpFileName);
        CloseHandle(g_FileHandle);
        g_FileHandle = 0;
    }

    if (stristr(lpFileName, "\\working\\~tm") != NULL)
    {
        g_FileHandle = ORIGINAL_API(CreateFileA)(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpsa,
                    dwCreationDisposition,
                    dwFlagsAndAttributes,
                    hTempFile
                    );
        return g_FileHandle;
    }
    else
    {
        return ORIGINAL_API(CreateFileA)(
                    lpFileName,
                    dwDesiredAccess,
                    dwShareMode,
                    lpsa,
                    dwCreationDisposition,
                    dwFlagsAndAttributes,
                    hTempFile
                    );

    }
    

    
}
/*++

 Hook CloseHandle to ensure that the global handle that we maintain 
 is set to '0'.

--*/

BOOL
APIHOOK(CloseHandle)(
    HANDLE hObject
    )
{
    BOOL bRet = FALSE;

    bRet = ORIGINAL_API(CloseHandle)(hObject);
    if (hObject == g_FileHandle)
    {
        g_FileHandle = 0;
    }
    return bRet;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN    
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\imagecast.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    ImageCast.cpp

 Abstract:

    This app tries placing its license DLL 'LicDLL.DLL' in the 
    %windir%\system32 folder. This was ok on Win2K as there was no duplicate 
    file in sytem32 but on XP, we have the OS license DLL with the same name. 
    So, the app cannot place it's dll in the system32 directory as it is 
    protected.

    During registration, the app loads the system registration DLL 'LicDLL.DLL' 
    and tries to get a proc address that does not obviously exist in the system 
    DLL and the call fails. So, the app displays all greyed out options.

    The solution is to redirect the app's DLL to some other folder and pick it 
    up from there. This Shim picks up the LicDLL.DLL that was redirected to 
    %windir% folder.
   
 Notes:

    This is an app specific shim.

 History:

    01/23/2002  prashkud    Created
    02/27/2002  robkenny    Security review.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ImageCast)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END


/*++

 Hooks LoadLibraryA and redirects if the filename is 'LicDLL.DLL' to  
 %windir%\LicDLL.DLL. The file 'LicDLL.DLL' would be redirected during 
 the setup to %windir%\system.

--*/

HMODULE
APIHOOK(LoadLibraryA)(
    LPCSTR lpFileName
    )
{
    CSTRING_TRY
    {
        // Bad string pointers can cause failures in CString.
        if (!IsBadStringPtrA(lpFileName, MAX_PATH))
        {
            //
            // We have found 'LicDLL.dll' in the path. Replace with "%windir%\LicDLL.DLL"                        
            //

            CString csFileName(lpFileName);            
            if (csFileName == L"LicDLL.DLL")
            {
                CString csNewFileName;
                csNewFileName.GetWindowsDirectoryW();
                csNewFileName.AppendPath(csFileName);

                LOGN(eDbgLevelInfo, "[ImageCast] changed %s to (%s)", lpFileName, csNewFileName.GetAnsi());
 
                return ORIGINAL_API(LoadLibraryA)(csNewFileName.GetAnsi());
            }
        }
    }
    CSTRING_CATCH
    {
    }

    return ORIGINAL_API(LoadLibraryA)(lpFileName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ie5domsetup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IE5DOMSetup.cpp

 Abstract:

    This DLL fixes a problem with Internet Explorer's IE5DOM.EXE package. If 
    the command line contains /n:v, the package will replace the 128-bit 
    encryption modules that shipped with Win2K, which can cause serious harm -
    no one can log on to the machine.

    This shim simply removes /n:v from the command line so that the package 
    does not replace the encryption DLLs.

 History:

    02/01/2000 jarbats  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IE5DOMSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

VOID 
StartSecondProcess(LPWSTR lpCommandLine)
{
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFOW StartupInfo;
    LPWSTR FileName;
    LPWSTR CurrentDir;
    DWORD Size;
        
    Size=GetCurrentDirectoryW(0,NULL);

    CurrentDir=(LPWSTR)ShimMalloc(Size*sizeof(WCHAR));

    if(NULL == CurrentDir)
    {
        //it is better to fail now then go on and bomb the system
        ExitProcess(0);
    }

    GetCurrentDirectoryW(Size,CurrentDir);

    FileName=(LPWSTR)ShimMalloc((MAX_PATH+2)*sizeof(WCHAR));

    if(NULL == FileName)
    {
        ExitProcess(0);
    }

    GetModuleFileNameW(NULL, FileName, MAX_PATH+2);

    StartupInfo.cb=sizeof(STARTUPINFO);
    StartupInfo.lpReserved=NULL;
    StartupInfo.lpDesktop=NULL;
    StartupInfo.lpTitle=NULL;
    StartupInfo.dwFlags=0;
    StartupInfo.cbReserved2=0;
    StartupInfo.lpReserved2=NULL;

    CreateProcessW(
        FileName,
        lpCommandLine,
        NULL,
        NULL,
        FALSE,
        NORMAL_PRIORITY_CLASS,
        NULL,
        CurrentDir,
        &StartupInfo,
        &ProcessInfo
        );

    ExitProcess(0);
}


VOID CheckCommandLine()
{
LPWSTR lpCommandLine,lpNewCommandLine;
LPWSTR *lpArgV;
LPWSTR lpSwitch={L"/n:v"};
BOOL   b;
INT    nArgC=0;
INT    i, cch;

       lpCommandLine=GetCommandLineW();
       if(NULL == lpCommandLine)
       {
           //without arguments this exe is harmless
           return;
       }
       
       cch = lstrlenW(lpCommandLine)+2;

       lpNewCommandLine=(LPWSTR)ShimMalloc( cch*sizeof(WCHAR) );

       if(NULL == lpNewCommandLine)
       {
            ExitProcess(0);
       }

       lpArgV = _CommandLineToArgvW(lpCommandLine,&nArgC);

       if(NULL == lpArgV)
       {
           //better to fail now
           ExitProcess(0);
       }
       else
       {
           if( nArgC < 2)
           {
              //there isn't any chance for /n:v
              ShimFree(lpNewCommandLine);
              GlobalFree(lpArgV);
              return;
           }
       }
       
       b = FALSE;
       
       for ( i=1; i<nArgC; i++ )
       {     
           if(lstrcmpiW(lpArgV[i],lpSwitch))
           {
               StringCchCatW(lpNewCommandLine, cch, lpArgV[i]);
           }
           else
           {
               b = TRUE;
           }
       }
       
       if (TRUE == b)
       {
           StartSecondProcess(lpNewCommandLine);
       }
       
       //never gets here because startsecondprocess doesn't return
}

/*++

 Handle DLL_PROCESS_ATTACH and DLL_PROCESS_DETACH in your notify function
 to do initialization and uninitialization.

 IMPORTANT: Make sure you ONLY call NTDLL, KERNEL32 and MSVCRT APIs during
 DLL_PROCESS_ATTACH notification. No other DLLs are initialized at that
 point.
 
 If your shim cannot initialize properly, return FALSE and none of the
 APIs specified will be hooked.
 
--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) 
    {
        CheckCommandLine();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\iconfig.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    IConfig.cpp

 Abstract:

    Remove iconfig.exe from \\HKLM\Software\Microsoft\Windows\CurrentVersion\Run.
    Delete iconfig.exe and iconfig.dll.
    
 Notes:

    This is an app specific shim.

 History:

    09/17/2001  astritz     Created

--*/

 
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IConfig)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    // Not hooking an API
APIHOOK_ENUM_END

/*++
    Notify Function
--*/    
BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
    HKEY hKey = 0;
    WCHAR wszFileName[MAX_PATH];
    DWORD dwLen = 0;

    if( SHIM_STATIC_DLLS_INITIALIZED == fdwReason ) {

        if( RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                0,
                KEY_ALL_ACCESS,
                &hKey
                ) != ERROR_SUCCESS ) {

            goto EXIT_PROCESS;
        }

        DPFN(eDbgLevelError, "Removing ICONFIG.EXE from \\HKLM\\Software\\Microsoft\\Windows\\CurrentVerion\\Run");
        RegDeleteValueW(hKey, L"ICONFIG");
        RegCloseKey(hKey);


        dwLen = GetModuleFileNameW(NULL, wszFileName, ARRAYSIZE(wszFileName));

        if( 0 == dwLen || ARRAYSIZE(wszFileName) == dwLen ) {
            goto EXIT_PROCESS;
        }

        DPFN(eDbgLevelError, "Deleting %S.", wszFileName);
        MoveFileExW(wszFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        
        if( dwLen < 3 ) {
            goto EXIT_PROCESS;
        }

        StringCchCopyW(&wszFileName[dwLen-3], ARRAYSIZE(wszFileName)-dwLen+3, L"DLL");
        DPFN(eDbgLevelError, "Deleting %S.", wszFileName);
        MoveFileExW(wszFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);


EXIT_PROCESS:
        ExitProcess(0);

    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\installshield6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    InstallShield6.cpp

 Abstract:

    - InstallShield6 is using IKernel.exe. The problem is IKernel.exe is an out-of-process
      OLE server that is spawned by svchost. IKernel.exe is located in InstallShield common
      folder and it's known as InstallShield engine.
    - In order to enable us to do matching against app that is using IKernel, we catch 
      first call to CreateFileA that has "data1.hdr" filename on the path.
      We should be able to use matching info available in the path of this data1.hdr.
      (which is located in temp folder in current user setting).
      Then we call apphelp!ApphelpCheckExe to verify whether there is a match.
      If there is a match, it will call shimeng!SE_DynamicShim to dynamically load additional shim 
      available for this application.
          

 History:
        
    04/11/2001 andyseti Created
    06/27/2001 andyseti Added code to prevent multiple Dynamic Shimming

--*/

#include "precomp.h"

typedef BOOL    (WINAPI *_pfn_CheckExe)(LPCWSTR, BOOL, BOOL, BOOL);

IMPLEMENT_SHIM_BEGIN(InstallShield6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA)
APIHOOK_ENUM_END



HANDLE 
APIHOOK(CreateFileA)(
    LPSTR                   lpFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
    DWORD                   dwCreationDisposition,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile
    )
{
    static  _pfn_CheckExe             pfnCheckExe = NULL;
    
    static  const char  Apphelp_ModuleName[]            = "Apphelp.dll";
    static  const char  CheckExeProcedureName[]         = "ApphelpCheckExe";
    
    HMODULE         hmodApphelp = 0;

    if (pfnCheckExe != NULL)
    {
        goto Done;
    }

    CSTRING_TRY
    {
        CString csFileName(lpFileName);
        csFileName.MakeLower();
    
        if (-1 == csFileName.Find(L"data1.hdr"))
        {
            // not the one that we are looking for.
            goto Done;
        }

        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Accessing %S", csFileName.Get());

        // load apphelp & shimengine modules

        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Loading Apphelp");

        hmodApphelp = LoadLibraryA(Apphelp_ModuleName);

        if (0 == hmodApphelp)
        {
            DPFN(
                eDbgLevelError,
                "[CreateFileA] Failed to get apphelp module handle");
            goto Done;
        }

        // Get procedure addresses
        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Getting ApphelpCheckExe proc address");

        pfnCheckExe = (_pfn_CheckExe) GetProcAddress(hmodApphelp, CheckExeProcedureName);

        if (NULL == pfnCheckExe)
        {
            DPFN(
                eDbgLevelError,
                "[CreateFileA] Failed to get %s procedure from %s module",
                CheckExeProcedureName,Apphelp_ModuleName);
            goto Done;        
        }

        DPFN(
            eDbgLevelInfo,
            "[CreateFileA] Calling CheckExe");

        if (FALSE == (*pfnCheckExe)(
            (WCHAR *)csFileName.Get(),
            FALSE,
            TRUE,
            FALSE
            ))

        {
            DPFN(
                eDbgLevelError,
                "[CreateFileA] There is no match for %S",
                csFileName.Get());
            goto Done;
        }

    }
    CSTRING_CATCH
    {
        // Do nothing
    }

Done:
    HANDLE hRet = ORIGINAL_API(CreateFileA)(
        lpFileName,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\instantcddvd.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    InstantCDDVD.cpp

 Abstract:

    Clean up the filter drivers on the uninstaller on process termination.

 Notes:

    This is an app specific shim.

 History:

    08/20/2002 mnikkel Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(InstantCDDVD)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL 
StripStringFromValue(HKEY hKey, const WCHAR *lpValue, const WCHAR *lpStrip)
{
    DWORD dwType, dwSize;
    BOOL bRet = FALSE;
    WCHAR *lpString = NULL;

    //
    // Build the %systemdir%\drivers\filename.sys to see if it's available
    //
    CString csSystem;
    CSTRING_TRY
    {
        csSystem.GetSystemDirectoryW();
        csSystem += L"\\Drivers\\";
        csSystem += lpStrip;
        csSystem += L".sys";
    }
    CSTRING_CATCH
    {
        goto Exit;
    }

    //
    // Check to see if the file exists - if it does, we don't touch the registry
    //
    if (GetFileAttributesW(csSystem) != 0xFFFFFFFF) {
        DPFN(eDbgLevelError, "%S found so leave registry value alone", lpStrip);
        goto Exit;
    }

    //
    // Checking the registry for the bad state now
    //
    
    // Get the size
    if (ERROR_SUCCESS != RegQueryValueExW(hKey, lpValue, NULL, &dwType, NULL, &dwSize)) {
        DPFN(eDbgLevelError, "%S value not found", lpValue);
        goto Exit;
    }

    // Make sure it's a MULTI_STRING
    if (dwType != REG_MULTI_SZ) {
        DPFN(eDbgLevelError, "%S not correct type, expecting a multi-string", lpStrip);
        goto Exit;
    }

    // Allocate memory for it and clear it
    lpString = (WCHAR *) malloc(dwSize);
    if (!lpString) {
        DPFN(eDbgLevelError, "Out of memory");
        goto Exit;
    }
    ZeroMemory(lpString, dwSize);

    // Get the actual data
    if (ERROR_SUCCESS != RegQueryValueExW(hKey, lpValue, NULL, &dwType, (LPBYTE)lpString, &dwSize)) {
        DPFN(eDbgLevelError, "%S QueryValue failed unexpectedly", lpStrip);
        goto Exit;
    }

    // Allocate an output buffer
    WCHAR * lpNewString = (WCHAR *) malloc(dwSize);
    if (!lpNewString) {
        DPFN(eDbgLevelError, "Out of memory");
        goto Exit;
    }
    ZeroMemory(lpNewString, dwSize);

    // Run the input buffer looking for lpStrip
    WCHAR *lpCurr    = lpString;
    WCHAR *lpCurrOut = lpNewString;
    BOOL bStripped   = FALSE;
    while (*lpCurr) {
        if (_wcsicmp(lpCurr, lpStrip) != 0) {
            // Keep this entry
            if (StringCchCopyW(lpCurrOut, dwSize, lpCurr) != S_OK)
            {
                goto Exit;
            }
            lpCurrOut += wcslen(lpCurrOut) + 1;
            dwSize    -= wcslen(lpCurrOut) + 1;
        } else {
            // Remove this entry
            bStripped = TRUE;
        }

        lpCurr += wcslen(lpCurr) + 1;
    }

    if (bStripped) {
        //
        // Fix up the registry with the new value. If there's nothing left, then kill the 
        // value.
        // 
        LOGN(eDbgLevelError, "Removing filter driver - Value: %S, Name: %S", lpValue, lpStrip);

        dwSize = (lpCurrOut - lpNewString) * sizeof(WCHAR);
        if (dwSize == 0) {
            RegDeleteValueW(hKey, lpValue);
        } else {
            RegSetValueExW(hKey, lpValue, NULL, dwType, (LPBYTE) lpNewString, dwSize + sizeof(WCHAR));
        }
    }

    bRet = TRUE;

Exit:

    if (lpString) {
        free(lpString);
    }

    if (lpNewString) {
        free(lpNewString);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(DWORD fdwReason)
{
   if (fdwReason == DLL_PROCESS_DETACH) {

       HKEY hKey;

       if (ERROR_SUCCESS == RegOpenKeyW(HKEY_LOCAL_MACHINE, L"SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E965-E325-11CE-BFC1-08002BE10318}", &hKey)) {

           StripStringFromValue(hKey, L"UpperFilters", L"ASAPI");           
           StripStringFromValue(hKey, L"UpperFilters", L"CDRDRV");
         
           RegCloseKey(hKey);
       }
   }

   return TRUE;
}

HOOK_BEGIN

   CALL_NOTIFY_FUNCTION   

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\intelvideophone.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    IntelVideoPhone.cpp

 Abstract:

    Hooks all dialog procs and make the window handles on WM_COMMAND messages 16 bit.

 Notes:

    This is an app specific shim.

 History:

    11/08/2000 linstev  Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(IntelVideoPhone)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
APIHOOK_ENUM_END

INT_PTR CALLBACK 
DialogProcHook_IntelVideoPhone(
    DLGPROC pfnOld, 
    HWND hwndDlg,  
    UINT uMsg,     
    WPARAM wParam,   
    LPARAM lParam    
    )
{
    if (uMsg == WM_COMMAND) {
        lParam = 0;
    }

    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

HWND
APIHOOK(CreateDialogIndirectParamA)(
    HINSTANCE hInstance,        
    LPCDLGTEMPLATE lpTemplate,  
    HWND hWndParent,            
    DLGPROC lpDialogFunc,       
    LPARAM lParamInit           
    )
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, DialogProcHook_IntelVideoPhone);

    return ORIGINAL_API(CreateDialogIndirectParamA)(  
        hInstance,
        lpTemplate,
        hWndParent,
        lpDialogFunc,
        lParamInit);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\isa.cpp ===
/*++

 Copyright (c) 2001-2002 Microsoft Corporation

 Module Name:

    ISA.cpp

 Abstract:

    The ISA setup needs to successfully open the SharedAccess service and get the
    its status in order to succeed. But on whistler we remove this from advanced
    server since it's a consumer feature so the ISA setup bails out. 

    We fake the service API call return values to make the ISA setup happy.

 History:

    04/24/2001  maonis      Created
    02/15/2002  robkenny    Conversion to CompareString was incorrect
                            Security review.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ISA)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenServiceA) 
    APIHOOK_ENUM_ENTRY(OpenServiceW) 
    APIHOOK_ENUM_ENTRY(QueryServiceStatus) 
    APIHOOK_ENUM_ENTRY(QueryServiceConfigA) 
    APIHOOK_ENUM_ENTRY(ChangeServiceConfigA)
    APIHOOK_ENUM_ENTRY(CloseServiceHandle) 
APIHOOK_ENUM_END


SC_HANDLE BogusSharedAccessHandle = (SC_HANDLE)0xBAADF00D;

/*++

  Abstract:

    This checks to see if the service is being opened is SharedAccess.
    If so we simply return a fake handle.

  History:

    04/24/2001    maonis     Created

--*/

SC_HANDLE 
APIHOOK(OpenServiceA)(
    SC_HANDLE hSCManager,  // handle to SCM database
    LPCSTR lpServiceName, // service name
    DWORD dwDesiredAccess  // access
    )
{
    DPFN(eDbgLevelInfo, "Calling OpenServiceA on %s", lpServiceName);

    SC_HANDLE hService = ORIGINAL_API(OpenServiceA)(hSCManager, lpServiceName, dwDesiredAccess);
    if (hService == NULL)
    {
        if (lpServiceName)
        {
            // Check to see if the app is attempting to open the SharedAccess service,
            // if it is, fake success by returning a bogus (non-NULL) handle

            DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
            if ((CompareStringA(lcid, NORM_IGNORECASE, lpServiceName, -1, "SharedAccess", -1) == CSTR_EQUAL))
            {
                LOGN(eDbgLevelError, "App is attempting to open the SharedAccess server, faking success");
                return BogusSharedAccessHandle;
            }
        }
    }

    return hService;
}

SC_HANDLE 
APIHOOK(OpenServiceW)(
    SC_HANDLE hSCManager,  // handle to SCM database
    LPCWSTR lpServiceName, // service name
    DWORD dwDesiredAccess  // access
    )
{
    DPFN(eDbgLevelInfo, "Calling OpenServiceW on %S", lpServiceName);

    SC_HANDLE hService = ORIGINAL_API(OpenServiceW)(hSCManager, lpServiceName, dwDesiredAccess);
    if (hService == NULL)
    {
        // Check to see if the app is attempting to open the SharedAccess service,
        // if it is, fake success by returning a bogus (non-NULL) handle

        DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
        if ((CompareStringW(lcid, NORM_IGNORECASE, lpServiceName, -1, L"SharedAccess", -1) == CSTR_EQUAL))
        {
            LOGN(eDbgLevelError, "App is attempting to open the SharedAccess server, faking success");
            return BogusSharedAccessHandle;
        }
    }

    return hService;
}

/*++

  Abstract:

    This checks to see if the service handle is 0xBAADF00D, if so just sets
    the service status to SERVICE_STOPPED.

  History:

    04/24/2001    maonis     Created

--*/

BOOL 
APIHOOK(QueryServiceStatus)(
    SC_HANDLE hService,               // handle to service
    LPSERVICE_STATUS lpServiceStatus  // service status
    )
{
    if (hService == BogusSharedAccessHandle)
    {
        lpServiceStatus->dwCurrentState = SERVICE_STOPPED;
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(QueryServiceStatus)(hService, lpServiceStatus);
    }
}

/*++

  Abstract:

    ISA calls this API first with a NULL lpServiceConfig to get the size
    of the buffer needs to be allocated for the structure; then it calls
    the API again with the pointer to the structure.

  History:

    05/07/2001    maonis     Created

--*/

BOOL 
APIHOOK(QueryServiceConfigA)(
    SC_HANDLE hService,                     // handle to service
    LPQUERY_SERVICE_CONFIGA lpServiceConfig, // buffer
    DWORD cbBufSize,                        // size of buffer
    LPDWORD pcbBytesNeeded                  // bytes needed
    )
{
    if (hService == BogusSharedAccessHandle)
    {
        if (lpServiceConfig)
        {
            lpServiceConfig->lpDependencies = NULL;
            return TRUE;
        }
        else
        {
            *pcbBytesNeeded = sizeof(QUERY_SERVICE_CONFIGA);
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return TRUE;
        }
    }
    else
    {
        return ORIGINAL_API(QueryServiceConfigA)(hService, lpServiceConfig, cbBufSize, pcbBytesNeeded);
    }
}

/*++

  Abstract:

    We simply make this API succeed when hService is 0xBAADF00D.

  History:

    05/07/2001    maonis     Created

--*/

BOOL 
APIHOOK(ChangeServiceConfigA)(
    SC_HANDLE hService,          // handle to service
    DWORD dwServiceType,        // type of service
    DWORD dwStartType,          // when to start service
    DWORD dwErrorControl,       // severity of start failure
    LPCSTR lpBinaryPathName,   // service binary file name
    LPCSTR lpLoadOrderGroup,   // load ordering group name
    LPDWORD lpdwTagId,          // tag identifier
    LPCSTR lpDependencies,     // array of dependency names
    LPCSTR lpServiceStartName, // account name
    LPCSTR lpPassword,         // account password
    LPCSTR lpDisplayName       // display name
    )
{
    if (hService == BogusSharedAccessHandle)
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(ChangeServiceConfigA)(
            hService,
            dwServiceType,
            dwStartType,
            dwErrorControl,
            lpBinaryPathName,
            lpLoadOrderGroup,
            lpdwTagId,
            lpDependencies,
            lpServiceStartName,
            lpPassword,
            lpDisplayName);
    }
}

/*++

  Abstract:

    This checks to see if the service handle is 0xBAADF00D, if so simply return

  History:

    04/24/2001    maonis     Created

--*/

BOOL 
APIHOOK(CloseServiceHandle)(
    SC_HANDLE hSCObject   // handle to service or SCM object
    )
{
    if (hSCObject == BogusSharedAccessHandle)
    {
        return TRUE;
    }
    else
    {
        return ORIGINAL_API(CloseServiceHandle)(hSCObject);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(Advapi32.DLL, OpenServiceA)
    APIHOOK_ENTRY(Advapi32.DLL, OpenServiceW)
    APIHOOK_ENTRY(Advapi32.DLL, QueryServiceStatus)
    APIHOOK_ENTRY(Advapi32.DLL, QueryServiceConfigA)
    APIHOOK_ENTRY(Advapi32.DLL, ChangeServiceConfigA)
    APIHOOK_ENTRY(Advapi32.DLL, CloseServiceHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\isa2.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    ISA2.cpp

 Abstract:

    The ISA setup needs to successfully open the SharedAccess service and get the
    its status in order to succeed. But on whistler we remove this from advanced
    server since it's a consumer feature so the ISA setup bails out. 

    We fake the service API call return values to make the ISA setup happy.

 History:

    06/20/2002  linstev    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ISA2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WSAGetLastError) 
APIHOOK_ENUM_END

typedef int (WINAPI *_pfn_WSAGetLastError)();

/*++

 Return WSAEADDRINUSE instead of WSAEACCES.
  
--*/

int 
APIHOOK(WSAGetLastError)()
{
    int iRet = ORIGINAL_API(WSAGetLastError)();


    if (iRet == WSAEACCES) {
        iRet = WSAEADDRINUSE;
    }

    return iRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WS2_32.DLL, WSAGetLastError)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\isa2000sp1.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:
    
    ISA2000SP1.cpp

 Abstract:

    Changes HKLM\System\CurrentControlSet\Services\mspfltex\start from 4 to 2 to
    re-enable ISA services.

 Notes:

    This is a specific shim.

 History:

    11/19/2002 astritz      Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ISA2000SP1)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        HKEY hKey = 0;
        if( ERROR_SUCCESS == RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\mspfltex",
            0,
            KEY_ALL_ACCESS,
            &hKey
            ))
        {
            DWORD dwOldValue    = 0;
            DWORD dwType        = 0;
            DWORD dwSize        = sizeof(dwOldValue);
            if( ERROR_SUCCESS == RegQueryValueExW(
                hKey,
                L"start",
                0,
                &dwType,
                (LPBYTE)&dwOldValue,
                &dwSize
                ))
            {
                if ( REG_DWORD == dwType && dwOldValue == 4 )
                {
                    DWORD dwNewValue = 2;
                    if( ERROR_SUCCESS == RegSetValueExW(
                        hKey,
                        L"start",
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwNewValue,
                        sizeof(dwNewValue)
                        ))
                    {
                        LOGN( eDbgLevelError, "[INIT] Changed HKLM\\System\\CurrentControlSet\\Services\\mspfltex\\start from 4 to 2.");
                    } else {
                        LOGN( eDbgLevelError, "[INIT] Failed to change HKLM\\System\\CurrentControlSet\\Services\\mspfltex\\start from 4 to 2.");
                    }
                } else {
                    LOGN( eDbgLevelError, "[INIT] HKLM\\System\\CurrentControlSet\\Services\\mspfltex\\start was not 4 so not changing.");
                }
            } else {
                LOGN( eDbgLevelError, "[INIT] Failed to query HKLM\\System\\CurrentControlSet\\Services\\mspfltex\\start.");
            }
            
            RegCloseKey(hKey);
        
        } else {
            LOGN( eDbgLevelError, "[INIT] Failed to open HKLM\\System\\CurrentControlSet\\Services\\mspfltex.");
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ispeed.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    ISpeed.cpp

 Abstract:

    The app doesn't handle directory/file names with spaces.

 Notes:

    This is an app specific shim.

 History:

    11/15/2000 maonis   Created

--*/

#include "precomp.h"
#include "strsafe.h"

IMPLEMENT_SHIM_BEGIN(ISpeed)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDlgItemTextA) 
APIHOOK_ENUM_END

/*++

 After we call GetDlgItemTextA we convert the long path name to the short path name.

--*/

UINT
APIHOOK(GetDlgItemTextA)(
    HWND hDlg,
    int nIDDlgItem,
    LPSTR lpString,
    int nMaxCount    
    )
{
    UINT uiRet = ORIGINAL_API(GetDlgItemTextA)(hDlg, nIDDlgItem, lpString, nMaxCount);

    if (uiRet)
    {
        CSTRING_TRY
        {
            // Check if the title is "iSpeed"
            CString csTitle;
            WCHAR * lpwszBuffer = csTitle.GetBuffer(7);
            int nTitle = GetWindowTextW(hDlg, lpwszBuffer, 7);
            csTitle.ReleaseBuffer(nTitle);

            if (csTitle.CompareNoCase(L"iSpeed") == 0)
            {
                int nIndexSpace = csTitle.Find(L" ");
                if (nIndexSpace >= 0)
                {
                    CString csString(lpString);
                    
                    // If the directory doesn't already exist, we create it so we can get the short path name.
                    if ((GetFileAttributesW(csString) == -1) && (GetLastError() == ERROR_FILE_NOT_FOUND))
                    {
                        if (!CreateDirectoryW(csString, NULL))
                        {
                            return 0;
                        }
                    }

                    csString.GetShortPathNameW();

                    StringCchCopyA(lpString,nMaxCount, csString.GetAnsi());                    
                    StringCchLengthA(lpString, nMaxCount, &uiRet);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    return uiRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetDlgItemTextA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\jetfighter4.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    JetFighter4.cpp

 Abstract:

    The app has a malformed ICON in it's resource.

 Notes:

    This is an app specific shim.

 History:

    01/30/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(JetFighter4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadIconA) 
APIHOOK_ENUM_END

/*++

 Check for the bad icon.

--*/

HICON
APIHOOK(LoadIconA)(
    HINSTANCE hInstance, 
    LPCSTR lpIconName
    )
{
    if ((DWORD) lpIconName == 103) {
        lpIconName = (LPCSTR) 8;
    }

    return ORIGINAL_API(LoadIconA)(hInstance, lpIconName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, LoadIconA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\keisoku7.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Keisoku7.cpp

 Abstract:

    The app has an executable bplayer.exe to launch its virtual CD driver. The 
    problem is bplayer.exe is put in start-group and will be launched by 
    explorer.exe, at the time the virtual CD driver is launched, explorer.exe 
    has already finished initialization and cached all local drive info. Fixing 
    this by broadcasting a WM_DEVICECHANGE message.

 Notes: 
  
    This is an app specific shim.

 History:

    06/20/2001 xiaoz    Created

--*/

#include "precomp.h"
#include "Dbt.h"

IMPLEMENT_SHIM_BEGIN(Keisoku7)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(StartServiceA) 
APIHOOK_ENUM_END

/*++

 Hook StartServiceA to broadcast a WM_DEVICECHANGE message 

--*/

BOOL  
APIHOOK(StartServiceA)( 
    SC_HANDLE hService,
    DWORD dwNumServiceArgs,
    LPCSTR *lpServiceArgVectors
    )
{
    BOOL bRet;
    DEV_BROADCAST_VOLUME devbVol;
    
    bRet = ORIGINAL_API(StartServiceA)(hService, dwNumServiceArgs, 
        lpServiceArgVectors);    

    //
    // If succeed, we will broadcast WM_DEVICECHANGE message
    //
    if (bRet)
    {
        devbVol.dbcv_size = sizeof(DEV_BROADCAST_VOLUME);
        devbVol.dbcv_devicetype = DBT_DEVTYP_VOLUME; 
        devbVol.dbcv_reserved = 0; 
        devbVol.dbcv_unitmask = 0x3FFFFF8; // All drives except A: B: C:
        devbVol.dbcv_flags = 0;
        SendMessageTimeout(HWND_BROADCAST, WM_DEVICECHANGE, DBT_DEVICEARRIVAL,
            (LPARAM) &devbVol, SMTO_NOTIMEOUTIFNOTHUNG, 1000, NULL);

        LOGN(eDbgLevelWarning, "WM_DEVICECHANGE broadcasted");        
    }    
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\javavm2.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    JavaVM2.cpp

 Abstract:

    For versions of msjavx86.exe >= 06.00.3229.0000 we need to
    append /nowin2kcheck to the execution of javatrig.exe.

 Notes:

    This is an app specific shim.

 History:

    05/31/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(JavaVM2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END



/*++

  Check CreateProcessA for execution of javatrig, if found
  append /nowin2kcheck to the command line.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)", lpApplicationName, lpCommandLine );

    if (lpCommandLine)
    {
        CSTRING_TRY
        {
            CString csCL(lpCommandLine);

            int nLoc = csCL.Find(L"javatrig.exe ");
            if ( nLoc > -1 )
            {
                csCL += L" /nowin2kcheck";
                DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\nNEW commandline:(%S)", lpApplicationName, csCL.Get() );

                return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                                    csCL.GetAnsi(),
                                                    lpProcessAttributes,
                                                    lpThreadAttributes, 
                                                    bInheritHandles,                     
                                                    dwCreationFlags,                    
                                                    lpEnvironment,                     
                                                    lpCurrentDirectory,                
                                                    lpStartupInfo,             
                                                    lpProcessInformation);
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    //
    // Call the original API
    //
    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes, 
                                        bInheritHandles,                     
                                        dwCreationFlags,                    
                                        lpEnvironment,                     
                                        lpCurrentDirectory,                
                                        lpStartupInfo,             
                                        lpProcessInformation);
}
    
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\javavm.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    JavaVM.cpp

 Abstract:

    Prevent the installation of cab files via rundll32 so that older versions
    of JavaVM do not install non-compatible software.

 Notes:

    This is an app specific shim.

 History:

    05/24/2001  mnikkel  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(JavaVM)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegSetValueExW) 
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

  Check Value for rundll32 JavaPkgMgr_Install string.
  Typical string we are looking to stop:
  "rundll32 E:\WINDOWS\System32\msjava.dll,JavaPkgMgr_Install E:\WINDOWS\Java\classes\xmldso.cab,0,0,0,0,4,282"

--*/
BOOL
JavaPkgMgrInstallCheck( const CString & csInput)
{
    DPFN( eDbgLevelSpew, "[JavaPkgMgrInstallCheck] input value:\n(%S)\n", csInput.Get() );

    CSTRING_TRY
    {
        CStringToken csValue(csInput, L",");
        CString csToken;

        // get the first token
        if ( csValue.GetToken(csToken) )
        {
            if ( csToken.Find(L"rundll32 ") > -1 )
            {
                // Second token
                if ( csValue.GetToken(csToken) )
                {
                    if ( csToken.Find(L"JavaPkgMgr_Install ") > -1 )
                    {
                        // Third token
                        if ( csValue.GetToken(csToken) )
                        {
                            if ( csToken.Find(L"0") == 0 )
                            {
                                DPFN( eDbgLevelInfo, "[JavaPkgMgrInstallCheck] Match found, returning TRUE.\n" );
                                return TRUE;
                            }
                        }
                    }
                }
            }
        }             
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return FALSE;
}


/*++

  Check RegSetValueExW for JavaPkgMgr_Install of cabs.  If
  found, return successfully without setting value.

--*/

LONG
APIHOOK(RegSetValueExW)(
    HKEY   hKey,
    LPWSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    DPFN( eDbgLevelSpew, "[RegSetValueExW] dwType:(%d)\n", dwType );

    // Check to see if we are dealing with a string value.
    if (dwType == REG_SZ ||
        dwType == REG_EXPAND_SZ )
    {
        // Convert to unicode and add null terminator.
        CSTRING_TRY
        {
            CString csDest;
            int nWChars = cbData/2;

            WCHAR * lpszDestBuffer = csDest.GetBuffer(nWChars);
            memcpy(lpszDestBuffer, lpData, cbData);
            lpszDestBuffer[nWChars] = '\0';
            csDest.ReleaseBuffer(nWChars);

            DPFN( eDbgLevelSpew, "[RegSetValueExW] lpdata:(%S)\n", csDest.Get() );

            if ( JavaPkgMgrInstallCheck(csDest) )
                return ERROR_SUCCESS;
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    //
    // Call the original API
    //
    
    return ORIGINAL_API(RegSetValueExW)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

/*++

  Check CreateProcessA for JavaPkgMgr_Install of cabs.  If
  found, return successfully without running.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)\n", lpApplicationName, lpCommandLine );

    if (lpCommandLine)
    {
        CSTRING_TRY
        {
            CString csCL(lpCommandLine);

            if ( JavaPkgMgrInstallCheck(csCL) )
            {

                // find the rundll32 and truncate the commandline at that point
                int nLoc = csCL.Find(L"rundll32 ");
                if (nLoc > -1)
                {
                    csCL.Truncate(nLoc+8);

                    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                                        csCL.GetAnsi(),
                                                        lpProcessAttributes,
                                                        lpThreadAttributes, 
                                                        bInheritHandles,                     
                                                        dwCreationFlags,                    
                                                        lpEnvironment,                     
                                                        lpCurrentDirectory,                
                                                        lpStartupInfo,             
                                                        lpProcessInformation);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do Nothing
        }
    }

    //
    // Call the original API
    //
    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes, 
                                        bInheritHandles,                     
                                        dwCreationFlags,                    
                                        lpEnvironment,                     
                                        lpCurrentDirectory,                
                                        lpStartupInfo,             
                                        lpProcessInformation);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\koeisecuritycheck.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   KOEISecurityCheck.cpp

 Abstract:

   This shim sets the SID for TokenOwner at the beginning of the setup.exe. It checks 
   if the administrator group SID is enabled in current process token. If it is enabled then
   we set the TokenOwner SID to administrator group SID. If its not then it does nothing.

 History:

   04/17/2001 zhongyl   create

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(KOEISecurityCheck)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 DisableStickyKeys saves the current value for LPSTICKYKEYS and then disables the option.

--*/

VOID
SetSidForOwner()
{
    BYTE sidBuffer[50];
    PSID pSID = (PSID)sidBuffer;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL IsMember;
    HANDLE hToken;
    TOKEN_OWNER SIDforOwner;

    // Open a handle to the access token for the calling process.
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, &hToken ))
        return;      //if OpenProcessToken fails, do nothing
    
    // Create a SID for the BUILTIN\Administrators group.
    if (!AllocateAndInitializeSid(&SIDAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSID))
        return;      //if AllocateAndInitializedSid fails, do nothing

    // Check if the administrator group SID is enabled in current process token
    if (!CheckTokenMembership(NULL, pSID, &IsMember))
        return;      //if CheckTokenMembership fails, do nothing

    SIDforOwner.Owner = pSID;

    // if the administrator group SID is enabled in current process token, call SetTokenInformation to set the SID for Owner.
    if (IsMember)
        SetTokenInformation(hToken, TokenOwner, &SIDforOwner, sizeof(SIDforOwner));

    return;

}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        SetSidForOwner();
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\kingsquestmask.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    KingsQuestMask.cpp

 Abstract:

    The app calls UnmapViewOfFile with a bogus address - an address that wasn't obtained 
    from MapViewOfFile. We validate the address before calling UnmapViewOfFile.

 History:

    11/20/2000 maonis Created

--*/

#include "precomp.h"

typedef BOOL      (WINAPI *_pfn_UnmapViewOfFile)(LPCVOID lpBaseAddress);

IMPLEMENT_SHIM_BEGIN(KingsQuestMask)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MapViewOfFile)
    APIHOOK_ENUM_ENTRY(UnmapViewOfFile)
APIHOOK_ENUM_END


// Link list of base addresses
struct MAPADDRESS
{
    MAPADDRESS *next;
    LPCVOID pBaseAddress;
};
MAPADDRESS *g_pBaseAddressList;

/*++

 Function Description:

    Add a base address to the linked list of addresses. Does not add if the
    address is NULL or a duplicate.

 Arguments:

    IN  pBaseAddress - base address returned by MapViewOfFile.

 Return Value:

    None

 History:

    11/20/2000 maonis Created

--*/

VOID 
AddBaseAddress(
    IN LPCVOID pBaseAddress
    )
{
    if (pBaseAddress)
    {
        MAPADDRESS *pMapAddress = g_pBaseAddressList;
        while (pMapAddress)
        {
            if (pMapAddress->pBaseAddress == pBaseAddress)
            {
                return;
            }
            pMapAddress = pMapAddress->next;
        }

        pMapAddress = (MAPADDRESS *) malloc(sizeof MAPADDRESS);

        pMapAddress->pBaseAddress = pBaseAddress;
        pMapAddress->next = g_pBaseAddressList;
        g_pBaseAddressList = pMapAddress;
    }
}


/*++

 Function Description:

    Remove a base address if it can be found in the linked list of addresses. 

 Arguments:

    IN  pBaseAddress - the base address to remove.

 Return Value:

    TRUE if the address is found.
    FALSE if the address is not found.

 History:

    11/20/2000 maonis Created

--*/

BOOL 
RemoveBaseAddress(
    IN LPCVOID pBaseAddress
    )
{
    MAPADDRESS *pMapAddress = g_pBaseAddressList;
    MAPADDRESS *last = NULL;
    
    while (pMapAddress)
    {
        if (pMapAddress->pBaseAddress == pBaseAddress)
        {
            if (last)
            {
                last->next = pMapAddress->next;
            }
            else
            {
                g_pBaseAddressList = pMapAddress->next;
            }
            free(pMapAddress);

            return TRUE;    
        }
        last = pMapAddress;
        pMapAddress = pMapAddress->next;
    }

    return FALSE;
}

/*++

 Add the base address to our list.
 
--*/

LPVOID
APIHOOK(MapViewOfFile)(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    SIZE_T dwNumberOfBytesToMap
    )
{
    LPVOID pRet = ORIGINAL_API(MapViewOfFile)(    
        hFileMappingObject,
        dwDesiredAccess,
        dwFileOffsetHigh,
        dwFileOffsetLow,
        dwNumberOfBytesToMap);

    AddBaseAddress(pRet);

    DPFN( eDbgLevelInfo, "MapViewOfFile: added base address = 0x%x\n", pRet);

    return pRet;
}

/*++

 Remove the address from our list if it can be found; otherwise do nothing.

--*/

BOOL
APIHOOK(UnmapViewOfFile)(
    LPCVOID lpBaseAddress 
    )
{
    BOOL bRet;

    if (RemoveBaseAddress(lpBaseAddress))
    {
        bRet = ORIGINAL_API(UnmapViewOfFile)(lpBaseAddress);
        if (bRet)
        {
            DPFN( eDbgLevelInfo, "UnmapViewOfFile unmapped address 0x%x\n", lpBaseAddress);
        }

        return bRet;
    }
    else
    {
        DPFN( eDbgLevelError,"UnmapViewOfFile was passed an invalid address 0x%x\n", lpBaseAddress);
        return FALSE;
    }
}

/*++

 Free the list.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        DWORD dwCount = 0;
        MAPADDRESS *pMapAddress = g_pBaseAddressList;
        
        while (pMapAddress)
        {
            g_pBaseAddressList = pMapAddress->next;
            ORIGINAL_API(UnmapViewOfFile)(pMapAddress->pBaseAddress);
            free(pMapAddress);
            pMapAddress = g_pBaseAddressList;
            dwCount++;
        }
        
        if (dwCount > 0)
        {
            DPFN( eDbgLevelInfo,"%d addresses not unmapped.", dwCount);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, MapViewOfFile)
    APIHOOK_ENTRY(KERNEL32.DLL, UnmapViewOfFile)
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\lotusorganizer5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LotusOrganizer5.cpp
    
 Abstract:

    Yield on ResumeThread to avoid poor design and race condition is the app.

 Notes:

    This is an app specific shim.

 History:

    02/17/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LotusOrganizer5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ResumeThread)
APIHOOK_ENUM_END

/*++

 Delay ResumeThread a little bit to avoid a race condition

--*/

BOOL
APIHOOK(ResumeThread)(
    HANDLE hThread
    )
{
    DWORD dwRet;

    Sleep(0);

    dwRet = ORIGINAL_API(ResumeThread)(hThread);

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, ResumeThread)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\linksextreme.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    LinksExtreme.cpp

 Abstract:

    This app cannot recognise the MIDI technology flags properly.
    The app's internal logic cannot handle the last two technology 
    flags viz. MOD_WAVETABLE and MOD_SWSYNTH. If these flags are 
    returned by the call to MidiOutGetDevCapsA API, the app shows 
    a messagebox and restarts after playing for a while.(AV's).

 Notes:

    This is specific to this app.

 History:

    06/20/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LinksExtreme)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(midiOutGetDevCapsA)
APIHOOK_ENUM_END


/*++

 This stub function fixes the returned wTechnology flags.

--*/

MMRESULT 
APIHOOK(midiOutGetDevCapsA)(
    UINT_PTR       uDeviceID,
    LPMIDIOUTCAPSA pmoc,
    UINT           cbmoc
    )
{
    MMRESULT mRes = ORIGINAL_API(midiOutGetDevCapsA)(
                            uDeviceID, 
                            pmoc, 
                            cbmoc);

    if (mRes == MMSYSERR_NOERROR)
    {
        if ((pmoc->wTechnology & MOD_WAVETABLE) ||
            (pmoc->wTechnology & MOD_SWSYNTH))
        {
            pmoc->wTechnology &= ~MOD_WAVETABLE;
            pmoc->wTechnology &= ~MOD_SWSYNTH;
            // Use any of the first five wTechnology flags !!
            pmoc->wTechnology |= MOD_FMSYNTH;
            LOGN( eDbgLevelInfo, 
                "[midiOutGetDevCapsA] Fixed the wTechnology flags" );
        }
    }

    return mRes;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, midiOutGetDevCapsA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\lhvoicexpressplus.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    LHVoiceXPressPlus.cpp

 Abstract:

    App passes a .hlp without path. Winhlp32 can't locate the file because 
    it's not in any of the locations that winhlp32 looks at. We pass in
    the file with full path.

 History:

    01/28/2001 maonis Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LHVoiceXPressPlus)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WinHelpA) 
APIHOOK_ENUM_END

BOOL 
APIHOOK(WinHelpA)(
    HWND hWndMain,
    LPCSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    )
{
    CSTRING_TRY
    {
        CString csHelp(lpszHelp);
    
        if (csHelp.CompareNoCase(L"Correction.hlp") == 0)
        {
            // The way we get the directory for the app is we look into the 
            // registry and get the location of the inproc server ksysint.dll.
            // Coolpad.exe always loads this dll - if you don't have this dll
            // registered, you can't run the app anyway.
            HKEY hkey;
            CString csRegValue;            
            
            const WCHAR szInprocServer[] = L"CLSID\\{B9C12481-D072-11D0-9E80-0060976FD1F8}\\InprocServer32";
            
            // Call the RegQueryValueExW overloaded function for CString's.
            LONG lRet = RegQueryValueExW(csRegValue, HKEY_CLASSES_ROOT, szInprocServer, NULL);
            if (lRet == ERROR_SUCCESS)
            {
                if (csRegValue.Replace(L"ksysint.dll", L"Correction.hlp") == 1)
                {                
                   return ORIGINAL_API(WinHelpA)(hWndMain, csRegValue.GetAnsi(), uCommand, dwData);
                }
            }            
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(WinHelpA)(hWndMain, lpszHelp, uCommand, dwData); 
}

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, WinHelpA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\mahjonggmadness.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MahjonggMadness.cpp

 Abstract:

    Prevent the app from task switching - it messes with it's synchronization 
    logic.

 Notes:

    This is an app specific shim.

 History:

    11/10/2000 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MahjonggMadness)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteA) 
APIHOOK_ENUM_END

/*++

 Ignore this call.

--*/

HINSTANCE 
APIHOOK(ShellExecuteA)(
    HWND hwnd, 
    LPCTSTR lpOperation,
    LPCTSTR lpFile, 
    LPCTSTR lpParameters, 
    LPCTSTR lpDirectory,
    INT nShowCmd
    )
{
    // Return minimum error code
    return (HINSTANCE)32;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    AppSpecific.cpp

 Abstract:


 Notes:

 History:

    10/28/2000 markder Created

--*/

#include "precomp.h"

#include "ShimHookMacro.h"

DECLARE_SHIM(3DFrogFrenzy)
DECLARE_SHIM(Acrobat5)
DECLARE_SHIM(AdobeLiveMotion)
DECLARE_SHIM(AfterDark)
DECLARE_SHIM(AliensVsPredator)
DECLARE_SHIM(AOLFindBundledInstaller)
DECLARE_SHIM(AOLRasSetEntryProperties)
DECLARE_SHIM(AOLSystemInfo)
DECLARE_SHIM(Attune)
DECLARE_SHIM(AutoCad)
DECLARE_SHIM(AutoDeskWorld2)
DECLARE_SHIM(BaanERP5)
DECLARE_SHIM(BaanERP5c)
DECLARE_SHIM(BaanIV)
DECLARE_SHIM(BackOffice45Suite)
DECLARE_SHIM(BackupExec)
DECLARE_SHIM(BaseBall2000)
DECLARE_SHIM(Battleship)
DECLARE_SHIM(BattleZone)
DECLARE_SHIM(BeyondAtlantis)
DECLARE_SHIM(BigActionConstruction)
DECLARE_SHIM(BigGameHunter3)
DECLARE_SHIM(BizPlanBuilder)
DECLARE_SHIM(BoeingFix)
DECLARE_SHIM(Britannica2001)
DECLARE_SHIM(Canvas6)
DECLARE_SHIM(CanvasCheckedButtons)
DECLARE_SHIM(Casper)
DECLARE_SHIM(ChemOffice)
DECLARE_SHIM(Chollian2000)
DECLARE_SHIM(Chollian2000Plus)
DECLARE_SHIM(ClueFinders3rdGrade)
DECLARE_SHIM(CoffeeCupHTMLEditor)
DECLARE_SHIM(Commandos)
DECLARE_SHIM(Cossacks)
DECLARE_SHIM(ComptonsBible)
DECLARE_SHIM(CorelAppsRegistration)
DECLARE_SHIM(CorelDraw9JPN)
DECLARE_SHIM(CorelSiteBuilder)
DECLARE_SHIM(CreateResumesQuickandEasy)
DECLARE_SHIM(CreativeOnScreenDisplay)
DECLARE_SHIM(CrystalWebPageServer)
DECLARE_SHIM(CUSeeMe4)
DECLARE_SHIM(Descent2)
DECLARE_SHIM(DinosaurActivityCenter)
DECLARE_SHIM(DirtTrackRacing)
DECLARE_SHIM(DominantSpecies)
DECLARE_SHIM(DongFangKuaiChe3000Setup)
DECLARE_SHIM(DongFangYingDu)
DECLARE_SHIM(DrEye)
DECLARE_SHIM(EA3dSetup)
DECLARE_SHIM(EasyCDCreator4)
DECLARE_SHIM(EasyCDCreator5)
DECLARE_SHIM(EncartaEncyclopediaDeluxe2K)
DECLARE_SHIM(EncompassMonitor)
DECLARE_SHIM(EuropeanAirWar)
DECLARE_SHIM(ExchangeServerSetup)
DECLARE_SHIM(F18Carrier)
DECLARE_SHIM(FailSocket)
DECLARE_SHIM(FireFighters)
DECLARE_SHIM(Force21)
DECLARE_SHIM(Gangsters)
DECLARE_SHIM(Gizmos)
DECLARE_SHIM(HeroSDVD)
DECLARE_SHIM(HotFaxMessageCenter4)
DECLARE_SHIM(HoyleGames)
DECLARE_SHIM(HPTourGuide)
DECLARE_SHIM(HTMLEditor8587)
DECLARE_SHIM(IConfig)
DECLARE_SHIM(IE5DOMSetup)
DECLARE_SHIM(ImageCast)
DECLARE_SHIM(InstallShield6)
DECLARE_SHIM(InstantCDDVD)
DECLARE_SHIM(IntelVideoPhone)
DECLARE_SHIM(ISA)
DECLARE_SHIM(ISA2)
DECLARE_SHIM(ISA2000SP1)
DECLARE_SHIM(ISpeed)
DECLARE_SHIM(JavaVM)
DECLARE_SHIM(JavaVM2)
DECLARE_SHIM(JetFighter4)
DECLARE_SHIM(Keisoku7)
DECLARE_SHIM(KingsQuestMask)
DECLARE_SHIM(KOEISecurityCheck)
DECLARE_SHIM(LHVoiceXPressPlus)
DECLARE_SHIM(LinksExtreme)
DECLARE_SHIM(LotusOrganizer5)
DECLARE_SHIM(MahjonggMadness)
DECLARE_SHIM(MastersOfOrion2)
DECLARE_SHIM(MathBlaster9_12)
DECLARE_SHIM(MaxPayne)
DECLARE_SHIM(MECCommander)
DECLARE_SHIM(MechWarrior2)
DECLARE_SHIM(MidTownMadness2)
DECLARE_SHIM(Millionaire)
DECLARE_SHIM(MindSpring4)
DECLARE_SHIM(ModemWizard)
DECLARE_SHIM(Money2001)
DECLARE_SHIM(Money2002)
DECLARE_SHIM(MSAccess2000IME)
DECLARE_SHIM(MSDevDisabledButtons)
DECLARE_SHIM(MSWorks6)
DECLARE_SHIM(Mutek)
DECLARE_SHIM(MyPhotoCenter2)
DECLARE_SHIM(NBALive)
DECLARE_SHIM(NetBackup45)
DECLARE_SHIM(NetObjectsFusion5)
DECLARE_SHIM(NetManageViewNow)
DECLARE_SHIM(NetZip)
DECLARE_SHIM(NewShenDiaoXiaLv)
DECLARE_SHIM(NFLBlitz)
DECLARE_SHIM(NFLFever2000)
DECLARE_SHIM(NHL2001)
DECLARE_SHIM(NikonView)
DECLARE_SHIM(Office9ComplexScript)
DECLARE_SHIM(OfficeTS)
DECLARE_SHIM(Omikron)
DECLARE_SHIM(OmniPage)
DECLARE_SHIM(OmniPagePro11Uninstall)
DECLARE_SHIM(OperationsManager)
DECLARE_SHIM(Outlook2000)
DECLARE_SHIM(Outlook97)
DECLARE_SHIM(Outlook98Wizard)
DECLARE_SHIM(OverlayPro)
DECLARE_SHIM(PanzerCommander)
DECLARE_SHIM(Patrol)
DECLARE_SHIM(Petz)
DECLARE_SHIM(PickyEater)
DECLARE_SHIM(Pirch98)
DECLARE_SHIM(PlaneCrazy)
DECLARE_SHIM(PostIt2)
DECLARE_SHIM(PowerBuilder)
DECLARE_SHIM(Ppo3svrScr)
DECLARE_SHIM(PrintMaster4)
DECLARE_SHIM(ProAtlas2000)
DECLARE_SHIM(QuickBooks8)
DECLARE_SHIM(Quicken2000)
DECLARE_SHIM(Quicken2001)
DECLARE_SHIM(QuickTime5)
DECLARE_SHIM(RCenter)
DECLARE_SHIM(Resonate)
DECLARE_SHIM(ResumeWriter3)
DECLARE_SHIM(ReturnToKrondor)
DECLARE_SHIM(RiskII)
DECLARE_SHIM(Riven)
DECLARE_SHIM(RumbaOffice)
DECLARE_SHIM(SafeDisc)
DECLARE_SHIM(SchoolHouseRockMath)
DECLARE_SHIM(SevenKingdoms)
DECLARE_SHIM(Settlers3)
DECLARE_SHIM(ShockwaveLocation)
DECLARE_SHIM(SierraCartRacing)
DECLARE_SHIM(Simply3D)
DECLARE_SHIM(SirenJukebox2)
DECLARE_SHIM(SMSDeadlock)
DECLARE_SHIM(SolidWorks99Plus)
DECLARE_SHIM(SpecOps2)
DECLARE_SHIM(SpeechViewer3)
DECLARE_SHIM(StoneAge)
DECLARE_SHIM(Suda2000)
DECLARE_SHIM(Summoner)
DECLARE_SHIM(SuperBike)
DECLARE_SHIM(SuperChix76)
DECLARE_SHIM(SysAdmiral)
DECLARE_SHIM(TaskbarAndStartMenuProperty)
DECLARE_SHIM(ThreeDJungleTrain)
DECLARE_SHIM(TimeSlips)
DECLARE_SHIM(TonkaConstruction)
DECLARE_SHIM(TreasureCove)
DECLARE_SHIM(TurkeyHunter)
DECLARE_SHIM(TwinssensOdyssey)
DECLARE_SHIM(Ultima9)
DECLARE_SHIM(UltimateSoccerManager)
DECLARE_SHIM(UltraWinCleaner2002)
DECLARE_SHIM(UnInstallShield)
DECLARE_SHIM(UrbanChaos)
DECLARE_SHIM(USNF97)
DECLARE_SHIM(ViaVoice8J)
DECLARE_SHIM(ViperRacing)
DECLARE_SHIM(VJEDelta)
DECLARE_SHIM(VJEDeltaSetup)
DECLARE_SHIM(VSAnalyzerServerSetup)
DECLARE_SHIM(WebPage6)
DECLARE_SHIM(WinFaxPro9)
DECLARE_SHIM(WinStone99)
DECLARE_SHIM(WordPerfect8)
DECLARE_SHIM(WordPerfect9_1)
DECLARE_SHIM(WordPerfect9_2)
DECLARE_SHIM(WordPerfect9_3)
DECLARE_SHIM(WordPerfectPresentation10)
DECLARE_SHIM(Works99)
DECLARE_SHIM(WorksSuite2001)
DECLARE_SHIM(Worms2)
DECLARE_SHIM(WPS2000)
DECLARE_SHIM(ZenWorks)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            DPF("AcSpecfc", eDbgLevelSpew, "Application Specific Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("AcSpecfc", eDbgLevelSpew, "Application Specific Shims uninitialized.");
            break;

        default:
            break;
    }
}

MULTISHIM_BEGIN()
    MULTISHIM_ENTRY(3DFrogFrenzy)
    MULTISHIM_ENTRY(Acrobat5)
    MULTISHIM_ENTRY(AdobeLiveMotion)
    MULTISHIM_ENTRY(AfterDark)
    MULTISHIM_ENTRY(AliensVsPredator)
    MULTISHIM_ENTRY(AOLFindBundledInstaller)
    MULTISHIM_ENTRY(AOLRasSetEntryProperties)
    MULTISHIM_ENTRY(AOLSystemInfo)    
    MULTISHIM_ENTRY(Attune)
    MULTISHIM_ENTRY(AutoCad)
    MULTISHIM_ENTRY(AutoDeskWorld2)
    MULTISHIM_ENTRY(BaanERP5)
    MULTISHIM_ENTRY(BaanERP5c)
    MULTISHIM_ENTRY(BaanIV)
    MULTISHIM_ENTRY(BackOffice45Suite)
    MULTISHIM_ENTRY(BackupExec)
    MULTISHIM_ENTRY(BaseBall2000)
    MULTISHIM_ENTRY(Battleship)
    MULTISHIM_ENTRY(BattleZone)
    MULTISHIM_ENTRY(BeyondAtlantis)
    MULTISHIM_ENTRY(BigActionConstruction)
    MULTISHIM_ENTRY(BigGameHunter3)
    MULTISHIM_ENTRY(BizPlanBuilder)
    MULTISHIM_ENTRY(BoeingFix)
    MULTISHIM_ENTRY(Britannica2001)
    MULTISHIM_ENTRY(Canvas6)
    MULTISHIM_ENTRY(CanvasCheckedButtons)
    MULTISHIM_ENTRY(Casper)
    MULTISHIM_ENTRY(ChemOffice)
    MULTISHIM_ENTRY(ClueFinders3rdGrade)
    MULTISHIM_ENTRY(Chollian2000)
    MULTISHIM_ENTRY(Chollian2000Plus)
    MULTISHIM_ENTRY(CoffeeCupHTMLEditor)
    MULTISHIM_ENTRY(Commandos)
    MULTISHIM_ENTRY(Cossacks)
    MULTISHIM_ENTRY(ComptonsBible)
    MULTISHIM_ENTRY(CorelAppsRegistration)
    MULTISHIM_ENTRY(CorelDraw9JPN)
    MULTISHIM_ENTRY(CorelSiteBuilder)
    MULTISHIM_ENTRY(CreateResumesQuickandEasy)
    MULTISHIM_ENTRY(CreativeOnScreenDisplay)
    MULTISHIM_ENTRY(CrystalWebPageServer)
    MULTISHIM_ENTRY(CUSeeMe4)
    MULTISHIM_ENTRY(Descent2)    
    MULTISHIM_ENTRY(DinosaurActivityCenter)
    MULTISHIM_ENTRY(DirtTrackRacing)
    MULTISHIM_ENTRY(DominantSpecies)
    MULTISHIM_ENTRY(DongFangKuaiChe3000Setup)
    MULTISHIM_ENTRY(DongFangYingDu)
    MULTISHIM_ENTRY(DrEye)
    MULTISHIM_ENTRY(EA3dSetup)
    MULTISHIM_ENTRY(EasyCDCreator4)
    MULTISHIM_ENTRY(EasyCDCreator5)
    MULTISHIM_ENTRY(EncartaEncyclopediaDeluxe2K)
    MULTISHIM_ENTRY(EncompassMonitor)
    MULTISHIM_ENTRY(EuropeanAirWar)
    MULTISHIM_ENTRY(ExchangeServerSetup)
    MULTISHIM_ENTRY(F18Carrier)
    MULTISHIM_ENTRY(FailSocket)
    MULTISHIM_ENTRY(FireFighters)
    MULTISHIM_ENTRY(Force21)
    MULTISHIM_ENTRY(Gangsters)
    MULTISHIM_ENTRY(Gizmos)
    MULTISHIM_ENTRY(HeroSDVD)
    MULTISHIM_ENTRY(HotFaxMessageCenter4)
    MULTISHIM_ENTRY(HoyleGames)
    MULTISHIM_ENTRY(HPTourGuide)    
    MULTISHIM_ENTRY(HTMLEditor8587)
    MULTISHIM_ENTRY(IConfig)
    MULTISHIM_ENTRY(IE5DOMSetup)
    MULTISHIM_ENTRY(ImageCast)
    MULTISHIM_ENTRY(InstallShield6)
    MULTISHIM_ENTRY(InstantCDDVD)
    MULTISHIM_ENTRY(IntelVideoPhone)
    MULTISHIM_ENTRY(ISA)
    MULTISHIM_ENTRY(ISA2)
    MULTISHIM_ENTRY(ISA2000SP1)
    MULTISHIM_ENTRY(ISpeed)
    MULTISHIM_ENTRY(JavaVM)
    MULTISHIM_ENTRY(JavaVM2)
    MULTISHIM_ENTRY(JetFighter4)
    MULTISHIM_ENTRY(Keisoku7)
    MULTISHIM_ENTRY(KingsQuestMask)
    MULTISHIM_ENTRY(KOEISecurityCheck)
    MULTISHIM_ENTRY(LHVoiceXPressPlus)
    MULTISHIM_ENTRY(LinksExtreme)
    MULTISHIM_ENTRY(LotusOrganizer5)
    MULTISHIM_ENTRY(MahjonggMadness)
    MULTISHIM_ENTRY(MastersOfOrion2)
    MULTISHIM_ENTRY(MathBlaster9_12)
    MULTISHIM_ENTRY(MaxPayne)
    MULTISHIM_ENTRY(MECCommander)
    MULTISHIM_ENTRY(MechWarrior2)
    MULTISHIM_ENTRY(MidTownMadness2)
    MULTISHIM_ENTRY(Millionaire)
    MULTISHIM_ENTRY(MindSpring4)
    MULTISHIM_ENTRY(ModemWizard)
    MULTISHIM_ENTRY(Money2001)
    MULTISHIM_ENTRY(Money2002)
    MULTISHIM_ENTRY(MSAccess2000IME)
    MULTISHIM_ENTRY(MSDevDisabledButtons)
    MULTISHIM_ENTRY(MSWorks6)
    MULTISHIM_ENTRY(Mutek)
    MULTISHIM_ENTRY(MyPhotoCenter2)
    MULTISHIM_ENTRY(NBALive)
    MULTISHIM_ENTRY(NetBackup45)
    MULTISHIM_ENTRY(NetObjectsFusion5)
    MULTISHIM_ENTRY(NetManageViewNow)
    MULTISHIM_ENTRY(NetZip)
    MULTISHIM_ENTRY(NewShenDiaoXiaLv)
    MULTISHIM_ENTRY(NFLBlitz)
    MULTISHIM_ENTRY(NFLFever2000)
    MULTISHIM_ENTRY(NHL2001)
    MULTISHIM_ENTRY(NikonView)
    MULTISHIM_ENTRY(Office9ComplexScript)
    MULTISHIM_ENTRY(OfficeTS)
    MULTISHIM_ENTRY(Omikron)
    MULTISHIM_ENTRY(OmniPage)
    MULTISHIM_ENTRY(OmniPagePro11Uninstall)
    MULTISHIM_ENTRY(OperationsManager)
    MULTISHIM_ENTRY(Outlook2000)
    MULTISHIM_ENTRY(Outlook97)
    MULTISHIM_ENTRY(Outlook98Wizard)
    MULTISHIM_ENTRY(OverlayPro)
    MULTISHIM_ENTRY(PanzerCommander)
    MULTISHIM_ENTRY(Patrol)
    MULTISHIM_ENTRY(Petz)
    MULTISHIM_ENTRY(PickyEater)
    MULTISHIM_ENTRY(Pirch98)
    MULTISHIM_ENTRY(PlaneCrazy)
    MULTISHIM_ENTRY(PowerBuilder)
    MULTISHIM_ENTRY(Ppo3svrScr)
    MULTISHIM_ENTRY(PrintMaster4)
    MULTISHIM_ENTRY(ProAtlas2000)
    MULTISHIM_ENTRY(PostIt2)
    MULTISHIM_ENTRY(QuickBooks8)
    MULTISHIM_ENTRY(Quicken2000)
    MULTISHIM_ENTRY(Quicken2001)
    MULTISHIM_ENTRY(QuickTime5)
    MULTISHIM_ENTRY(RCenter)
    MULTISHIM_ENTRY(Resonate)
    MULTISHIM_ENTRY(ResumeWriter3)
    MULTISHIM_ENTRY(ReturnToKrondor)
    MULTISHIM_ENTRY(RiskII)
    MULTISHIM_ENTRY(Riven)
    MULTISHIM_ENTRY(RumbaOffice)
    MULTISHIM_ENTRY(SafeDisc)
    MULTISHIM_ENTRY(SchoolHouseRockMath)
    MULTISHIM_ENTRY(Settlers3)
    MULTISHIM_ENTRY(SevenKingdoms)
    MULTISHIM_ENTRY(ShockwaveLocation)
    MULTISHIM_ENTRY(SierraCartRacing)
    MULTISHIM_ENTRY(Simply3D)
    MULTISHIM_ENTRY(SirenJukebox2)
    MULTISHIM_ENTRY(SMSDeadlock)
    MULTISHIM_ENTRY(SolidWorks99Plus)
    MULTISHIM_ENTRY(SpecOps2)
    MULTISHIM_ENTRY(SpeechViewer3)
    MULTISHIM_ENTRY(StoneAge)
    MULTISHIM_ENTRY(Suda2000)
    MULTISHIM_ENTRY(Summoner)
    MULTISHIM_ENTRY(SuperBike)
    MULTISHIM_ENTRY(SuperChix76)
    MULTISHIM_ENTRY(SysAdmiral)
    MULTISHIM_ENTRY(TaskbarAndStartMenuProperty)
    MULTISHIM_ENTRY(ThreeDJungleTrain)
    MULTISHIM_ENTRY(TimeSlips)
    MULTISHIM_ENTRY(TonkaConstruction)
    MULTISHIM_ENTRY(TreasureCove)
    MULTISHIM_ENTRY(TurkeyHunter)
    MULTISHIM_ENTRY(TwinssensOdyssey)
    MULTISHIM_ENTRY(Ultima9)
    MULTISHIM_ENTRY(UltimateSoccerManager)
    MULTISHIM_ENTRY(UltraWinCleaner2002)
    MULTISHIM_ENTRY(UnInstallShield)
    MULTISHIM_ENTRY(UrbanChaos)
    MULTISHIM_ENTRY(USNF97)
    MULTISHIM_ENTRY(ViaVoice8J)
    MULTISHIM_ENTRY(ViperRacing)
    MULTISHIM_ENTRY(VJEDelta)
    MULTISHIM_ENTRY(VJEDeltaSetup)
    MULTISHIM_ENTRY(VSAnalyzerServerSetup)
    MULTISHIM_ENTRY(WebPage6)
    MULTISHIM_ENTRY(WinFaxPro9)
    MULTISHIM_ENTRY(WinStone99)
    MULTISHIM_ENTRY(WordPerfect8)
    MULTISHIM_ENTRY(WordPerfect9_1)
    MULTISHIM_ENTRY(WordPerfect9_2)
    MULTISHIM_ENTRY(WordPerfect9_3)
    MULTISHIM_ENTRY(WordPerfectPresentation10)
    MULTISHIM_ENTRY(Works99)
    MULTISHIM_ENTRY(WorksSuite2001)
    MULTISHIM_ENTRY(Worms2)
    MULTISHIM_ENTRY(WPS2000)
    MULTISHIM_ENTRY(ZenWorks)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\maxpayne.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    MaxPayne.cpp

 Abstract:

    They try to size their window to the entire screen and use the wrong system 
    metrics. This shim just redirects them to the ones they should be using so 
    the taskbar doesn't flicker through into the game. 

    This is not a Win9x regression, but since there is so much more activity in 
    the task bar area on XP, it's much more noticable.

 Notes:

    This is an app specific shim.

 History:

    07/31/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MaxPayne)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSystemMetrics) 
APIHOOK_ENUM_END

/*++

 Redirect SM_C?FULLSCREEN to SM_C?SCREEN.

--*/

int
APIHOOK(GetSystemMetrics)(
    int nIndex
    )
{
    if (nIndex == SM_CXFULLSCREEN) {
        nIndex = SM_CXSCREEN;
    } else if (nIndex == SM_CYFULLSCREEN) {
        nIndex = SM_CYSCREEN;
    }

    return ORIGINAL_API(GetSystemMetrics)(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetSystemMetrics)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\mastersoforion2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MastersOfOrion2.cpp

 Abstract:

    This shim is designed to fix a synchronization issue which occurs when 
    SendMessage is called on a different thread from the window proc. I've not 
    confirmed this, but it looks as if SendMessage will relinquish control to 
    the thread with the window proc on Win9x. 

    The effect on an application can be varied. In Masters of Orion II, the 
    mouse cursor stops moving.

 Notes:

    This is an app specific shim.

 History:

    04/19/2000 linstev  Created
    06/06/2001 linstev  Added fix for heap problems

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MastersOfOrion2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
    APIHOOK_ENUM_ENTRY(LocalAlloc) 
APIHOOK_ENUM_END

/*++

 Make sure we switch threads after the SendMessage.

--*/

LRESULT
APIHOOK(SendMessageA)(
    HWND hWnd,      
    UINT Msg,       
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    LRESULT lRet = ORIGINAL_API(SendMessageA)(
        hWnd,
        Msg,
        wParam,
        lParam);

    SwitchToThread();

    return lRet;
}

/*++

 Pad allocations for Ddraw surfaces so they don't trash Ddraw structures.

--*/

HLOCAL
APIHOOK(LocalAlloc)(
    UINT uFlags,
    SIZE_T uBytes
    )
{
    if (uBytes >= 640*480) {
        //
        // This is probably a screen size surface
        //
        uBytes += 4096;
    }

    return ORIGINAL_API(LocalAlloc)(uFlags, uBytes);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SendMessageA)
    APIHOOK_ENTRY(KERNEL32.DLL, LocalAlloc)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\mechwarrior2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MechWarrior2.cpp

 Abstract:
     
    This shim fixes a problem with MW2 expecting BitBlt to return a specific 
    value, contrary to the published documentation. It also fixes a situation 
    in which a thread calls "SuspendThread" on itself, killing itself.
     
 Notes:

    This shim is specific to Mechwarrior, though potentially some of this could 
    be applied to other apps that use the AIL32 libraries.

 History:
           
    05/16/2000 dmunsil  Created 
   
--*/

#include "precomp.h"
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

IMPLEMENT_SHIM_BEGIN(MechWarrior2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(BitBlt) 
    APIHOOK_ENUM_ENTRY(SuspendThread) 
    APIHOOK_ENUM_ENTRY(ResumeThread) 
APIHOOK_ENUM_END

DWORD dwGetThreadID(HANDLE hThread)
{
    THREAD_BASIC_INFORMATION ThreadBasicInfo;
    NTSTATUS Status;
    TEB teb;

    Status = NtQueryInformationThread(
                hThread,
                ThreadBasicInformation,
                &ThreadBasicInfo,
                sizeof(ThreadBasicInfo),
                NULL
                );

    if (!NT_SUCCESS(Status)) {
        DPFN( eDbgLevelError, "NtQueryInfomationThread failed\n");
        return 0;
    }

    return (DWORD)ThreadBasicInfo.ClientId.UniqueThread;
}

/*++

 Return what Mechwarrior is expecting from BitBlt

--*/

BOOL
APIHOOK(BitBlt)(
    HDC hdcDest, // handle to destination DC
    int nXDest,  // x-coord of destination upper-left corner
    int nYDest,  // y-coord of destination upper-left corner
    int nWidth,  // width of destination rectangle
    int nHeight, // height of destination rectangle
    HDC hdcSrc,  // handle to source DC
    int nXSrc,   // x-coordinate of source upper-left corner
    int nYSrc,   // y-coordinate of source upper-left corner
    DWORD dwRop  // raster operation code
    )
{
    BOOL bRet;
    
    bRet = ORIGINAL_API(BitBlt)(
        hdcDest,
        nXDest,
        nYDest,
        nWidth,
        nHeight,
        hdcSrc,
        nXSrc,
        nYSrc,
        dwRop
        );

    if (bRet) {
        bRet = 0x1e0; // this is what MechWarrior expects to be returned.
    }

    return bRet;
}

/*++

 Disallow suspending self

--*/

DWORD 
APIHOOK(SuspendThread)(
    HANDLE hThread   // handle to the thread
    )
{
    // if we're trying to suspend our own thread, refuse
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(SuspendThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Disallow resuming self, for same reason

--*/

DWORD 
APIHOOK(ResumeThread)(
    HANDLE hThread   // handle to the thread
    )
{
    // if we're trying to resume our own thread, refuse
    if (dwGetThreadID(hThread) != dwGetThreadID(GetCurrentThread())) {
        return ORIGINAL_API(SuspendThread)(hThread);
    } else {
        return 0;
    }
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, BitBlt )
    APIHOOK_ENTRY(Kernel32.DLL, SuspendThread )
    APIHOOK_ENTRY(Kernel32.DLL, ResumeThread )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\meccommander.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MECCommander.cpp

 Abstract:

    This dll prevents the MEC Commander install program from successfully
    calling the cpuid.exe. This is because the cpuid.exe can AV's with a
    divide by 0.

 Notes:

    This is an app specific shim.

 History:

    11/18/1999 philipdu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MECCommander)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


/*++

 We do not want to run this application since it AV's with a divide by zero 
 calculation. The only purpose for this exe is to time the CPU. Since the 
 final result of this calculation is a string in a dialog box we can safely 
 bypass this. The app puts a string "Pentinum 166 or Better recommented" in
 the cases where it cannot get the CPU frequency. The interesting thing 
 here is that the app will actually run better with this patch since this 
 cpuid exe also faults on 9x.

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    BOOL bRet;

    CSTRING_TRY
    {
        AppAndCommandLine acl(lpApplicationName, lpCommandLine);
        if (acl.GetApplicationName().CompareNoCase(L"cpuid.exe") == 0)
        {
            return FALSE;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    bRet = ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);

    return bRet;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(Kernel32.DLL, CreateProcessA )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\mathblaster9_12.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MathBlaster9_12.cpp

 Abstract:
     
    App requires lookaside on VirtualAllocs...
     
 Notes:

    This is an appspecific shim.

 History:
           
    10/10/2000 linstev   Created 
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MathBlaster9_12)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VirtualAlloc) 
    APIHOOK_ENUM_ENTRY(VirtualFree) 
APIHOOK_ENUM_END

LPVOID g_pLast = NULL;

/*++

 Use the cached value.

--*/

LPVOID 
APIHOOK(VirtualAlloc)(
    LPVOID lpAddress, 
    DWORD dwSize,     
    DWORD flAllocationType,
    DWORD flProtect   
    )
{
    LPVOID pRet = 0;

    if (!lpAddress && g_pLast)    
    {   
        pRet =  ORIGINAL_API(VirtualAlloc)(g_pLast, dwSize, flAllocationType, flProtect);
    }

    if (!pRet) 
    {
        pRet =  ORIGINAL_API(VirtualAlloc)(lpAddress, dwSize, flAllocationType, flProtect);
    }

    return pRet;
}

/*++

 Use the cached value.

--*/

BOOL 
APIHOOK(VirtualFree)(
    LPVOID lpAddress,
    DWORD dwSize,    
    DWORD dwFreeType )
{
    
    BOOL bRet = ORIGINAL_API(VirtualFree)(lpAddress, dwSize, dwFreeType);

    if (bRet)
    {
        g_pLast = lpAddress;
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(Kernel32.DLL, VirtualAlloc )
    APIHOOK_ENTRY(Kernel32.DLL, VirtualFree )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\midtownmadness2.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    MidTownMadness2.cpp

 Abstract:
    
    This app has a funky timing system whereby it waits for the processor that 
    it's running on to return a 'stable' speed. The calculation is especially 
    prone to problems on faster machines because there is greater uncertainty.

    Not sure why we hit this so easily on dual-procs - perhaps something about 
    the scheduler wrt sleep and timeGetTime.

 Notes:

    This is an app specific shim.

 History:

    11/15/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MidTownMadness2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(Sleep) 
    APIHOOK_ENUM_ENTRY(timeGetTime) 
APIHOOK_ENUM_END

DWORD g_dwState;
DWORD g_dwTimer;
DWORD g_dwLastTime;

/*++

 After we call GetDlgItemTextA we convert the long path name to the short path name.

--*/

DWORD
APIHOOK(timeGetTime)(VOID)
{
    DWORD dwRet = ORIGINAL_API(timeGetTime)();

    switch (g_dwState) {
        case 0:          
            // Initial state
            g_dwLastTime = dwRet;
            g_dwState++;
            break;
        case 1: 
            // Shouldn't get here, reset state
            g_dwState = 0;
            break;
        case 2:
            // We're in the known bad zone, return our precalculated value
            dwRet = g_dwLastTime + g_dwTimer;
            g_dwState = 0;
            break;
    }

    return dwRet;
}

VOID
APIHOOK(Sleep)(
    DWORD dwMilliseconds
    )
{
    //
    // Check for their specific sleep and update our state if required
    //
    if (dwMilliseconds == 100 && g_dwState == 1) {
        g_dwState = 2;
    }
    ORIGINAL_API(Sleep)(dwMilliseconds);
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        // Make the calculation that the app does

        DWORD dwTimer = timeGetTime();
        Sleep(100);
        g_dwTimer = timeGetTime() - dwTimer;

        // Set initial state to 0
        g_dwState = 0;
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(KERNEL32.DLL, Sleep)
    APIHOOK_ENTRY(WINMM.DLL, timeGetTime)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\mindspring4.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MindSpring4.cpp

 Abstract:

    Shim to register the files using regedt32.exe
    The app creates *.dcu files during installation but fails to register them
    thus leading to no entires under the HKLM/Software/MindSpring Enterprise/MID4 subkey.
    This causes the the app to AV when run after successfull installation.

 Notes:

    This is an app specific shim.

 History:

    01/29/2001  a-leelat    Created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MindSpring4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CopyFileA)
APIHOOK_ENUM_END



BOOL APIHOOK(CopyFileA)(
             LPCSTR lpExistingFileName, // name of an existing file
             LPCSTR lpNewFileName,      // name of new file
             BOOL bFailIfExists          // operation if file exists
)
{
    
    BOOL bRet = ORIGINAL_API(CopyFileA)(
                            lpExistingFileName,
                            lpNewFileName,
                            bFailIfExists); 
    if ( bRet != 0 )
    {
        CSTRING_TRY
        {
            CString csExisting(lpExistingFileName);
            CString csExt;
            csExisting.SplitPath(NULL, NULL, NULL, &csExt);
    
            //Check if the file name has .dcu in it
            //if so run regedit on it
            if (csExt.CompareNoCase(L"dcu") == 0)
            {
                CString csCl(L"regedit.exe /s ");
                csCl += lpExistingFileName;
    
                STARTUPINFOW si;
                ZeroMemory( &si, sizeof(si) );
                si.cb = sizeof(si);
    
                PROCESS_INFORMATION pi;
                ZeroMemory( &pi, sizeof(pi) );
    
                BOOL bProc = CreateProcessW(NULL,
                                            (WCHAR *)csCl.Get(), // Stupid non-const api
                                            NULL,
                                            NULL,
                                            FALSE,
                                            NORMAL_PRIORITY_CLASS,
                                            NULL,
                                            NULL,
                                            &si,
                                            &pi);
                if (bProc)
                {
                    WaitForSingleObject(pi.hProcess,INFINITE);
                }
                else
                {
                    //Fail to run the regedit
                    DPFN(eDbgLevelInfo,"Failed to run regedit on %s\n",lpExistingFileName);
                }
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return bRet;
                                    
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CopyFileA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\millionaire.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Millionaire.cpp

 Abstract:

    On Win9x, paint messages did not always cause WM_ERASEBKGND messages. This 
    is for applications that paint themselves before the WM_PAINT message and
    then pass WM_PAINT onto the default handler.

 Notes:

    This is a general purpose shim, but should not be in a layer.

 History:

    06/05/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Millionaire)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA) 
    APIHOOK_ENUM_ENTRY(RegisterClassW) 
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
    APIHOOK_ENUM_ENTRY(RegisterClassExW) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongW) 
APIHOOK_ENUM_END

/*++

 Handle paint messages

--*/

LRESULT 
CALLBACK 
Millionaire_WindowProcHook(
    WNDPROC pfnOld, 
    HWND hwnd,      
    UINT uMsg,      
    WPARAM wParam,  
    LPARAM lParam   
    )
{
    switch( uMsg )
    {
        case WM_PAINT: 
            RECT r;
            
            if (GetUpdateRect(hwnd, &r, FALSE))
            {
                DPFN( eDbgLevelSpew, "Validating on paint");

                ValidateRect(hwnd, &r);
            }

            break;

            default: break;
    }
        
    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

/*++

 The dialogproc hook

--*/

INT_PTR 
CALLBACK 
Millionaire_DialogProcHook(
    DLGPROC   pfnOld,   
    HWND      hwndDlg,  
    UINT      uMsg,     
    WPARAM    wParam,   
    LPARAM    lParam    
    )
{
    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  
    )
{
    WNDCLASSA wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  
    )
{
    WNDCLASSW wcNewWndClass = *lpWndClass;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  
    )
{
    WNDCLASSEXA wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  
    )
{
    WNDCLASSEXW wcNewWndClass = *lpwcx;

    wcNewWndClass.lpfnWndProc = 
        (WNDPROC) HookCallback(lpwcx->lpfnWndProc, Millionaire_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Hook the wndproc

--*/

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if (nIndex == GWL_WNDPROC)
    { 
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_WindowProcHook);
    }
    else if (nIndex == DWL_DLGPROC)
    {
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, Millionaire_DialogProcHook);
    }

    return ORIGINAL_API(SetWindowLongA)(
        hWnd,
        nIndex,
        dwNewLong);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\msdevdisabledbuttons.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   FakeThemeMetrics.cpp

 Abstract:

  This Shim will allow the Skemers group to shim applications that do not behave 
  well with "Themed" system metrics

 History:

  11/30/2000 a-brienw Converted to shim frame work version 2.

--*/

#include "precomp.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    sizeof(x)/sizeof((x)[0])
#endif

IMPLEMENT_SHIM_BEGIN(MSDevDisabledButtons)
#include "ShimHookMacro.h"

// Add APIs that you wish to hook to this enumeration. The first one
// must have "= USERAPIHOOKSTART", and the last one must be
// APIHOOK_Count.
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetSysColor) 
APIHOOK_ENUM_END

DWORD APIHOOK(GetSysColor)(int nIndex)
{
    if (nIndex == COLOR_MENU)
        return ORIGINAL_API(GetSysColor)(COLOR_BTNFACE);

    if (nIndex == COLOR_MENUBAR)
        return ORIGINAL_API(GetSysColor)(COLOR_BTNFACE);

    return ORIGINAL_API(GetSysColor)(nIndex);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, GetSysColor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\modemwizard.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ModemWizard.cpp

 Abstract:

    This shim hooks the RegQueryValueEx and passes in the app expected values 
    if the values are missing in the registry. 
    
 Notes:

    This is an app specific shim.

 History:

    01/18/2001 a-leelat Created

--*/

#include "precomp.h"
#include <stdio.h>
#include "strsafe.h"

IMPLEMENT_SHIM_BEGIN(ModemWizard)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
APIHOOK_ENUM_END

LONG 
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    LONG lRet;

    CSTRING_TRY
    {
        CString csValueName(lpValueName);

        int iType = 0;
        if (csValueName.Compare(L"Class") == 0)
            iType = 1;
        else if (csValueName.Compare(L"ClassGUID") == 0)
            iType = 2;
        else if (csValueName.Compare(L"Driver") == 0)
            iType = 3;
        
        const CHAR szGUID[] = "{4D36E96D-E325-11CE-BFC1-08002BE10318}";
        DWORD dwRegType = REG_SZ;

        //Save the passed in size of buffer
        DWORD oldcbData = lpcbData ? *lpcbData : 0;
        if (iType) {
    
            //
            // Query the registry to see if there is a service name for the subkey
            // If there is one then check to see if the value returned is "Modem"
            //
    
            lRet = ORIGINAL_API(RegQueryValueExA)(hKey, "Service", lpReserved, &dwRegType, lpData, lpcbData);
            if (lRet == ERROR_SUCCESS)
            {
                CString csData((LPCSTR)lpData);
                if (csData.Compare(L"Modem") == 0)
                {
                    switch (iType) {
                        case 1: 
                            //
                            // We are being queried for a class
                            //
                            return lRet;
                            break;
                        case 2: 
                            //
                            // We are being queried for a ClassGUID
                            // class GUID for modems is 
                            // {4D36E96D-E325-11CE-BFC1-08002BE10318}
                            //
        
                            if (lpData) {                                
                                StringCchCopyA((LPSTR)lpData, oldcbData, szGUID);
                                StringCchLengthA((LPSTR)lpData, oldcbData, (size_t *)lpcbData);                                
                                return lRet;
                            }
                            break;
                        case 3:
                            //
                            // we are being queried for a Driver
                            // Check for DrvInst to append to the modemGUID
                            // its like {4D36E96D-E325-11CE-BFC1-08002BE10318}\0000
                            //
        
                            dwRegType = REG_DWORD;
                            if ((lRet = ORIGINAL_API(RegQueryValueExA)(hKey, "DrvInst", lpReserved,&dwRegType,lpData,lpcbData)) == ERROR_SUCCESS) {
        
                                CString csDrv;
                                csDrv.Format(L"%s\\%04d", szGUID, (int)(LOBYTE(LOWORD((DWORD)*lpData))));                                

                                StringCchCopyA((LPSTR)lpData, oldcbData, csDrv.GetAnsi());
                                StringCchLengthA((LPSTR)lpData, oldcbData, (size_t *)lpcbData);

                                return lRet;
                            }
                            break;
                        default:
                            break;
                    }
                }
            }
        }

        if (lpcbData) {
            *lpcbData = oldcbData;
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }
    
    lRet = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, 
        lpType, lpData, lpcbData);

    return lRet;

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA);

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\mutek.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Mutek.cpp

 Abstract:

    App passes NumberOfBytesRead as inside the block of memory they're reading.

 Notes:

    This is an app specific shim.

 History:

    05/23/2002 linstev   Created

--*/

#include "precomp.h"
#include "strsafe.h"

IMPLEMENT_SHIM_BEGIN(Mutek)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ReadProcessMemory) 
APIHOOK_ENUM_END

/*++

 Buffer parameters so they don't get overwritten.

--*/

BOOL
APIHOOK(ReadProcessMemory)(
    HANDLE hProcess,              
    LPCVOID lpBaseAddress,        
    LPVOID lpBuffer,              
    DWORD nSize,                 
    LPDWORD lpNumberOfBytesRead   
    )
{
    __asm nop;

    BOOL bRet = ORIGINAL_API(ReadProcessMemory)(hProcess, lpBaseAddress, lpBuffer, 
        nSize, lpNumberOfBytesRead);

    __asm nop;

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, ReadProcessMemory)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\msaccess2000ime.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    MSAccess2000IME.cpp

 Abstract:
    
    MSAccess 2000 disable IME for the non text column but failing enable IME
    when user move the caret into text column with non IME keyboard ex.German.
    When user switch keyboard from German to IME, IME is disabled and user
    cannot input Far East language text.

    This shim disregard the attempt to disable IME.
    The problem is fixed in MSAccess 2002.

 Notes:

    This is an app specific shim.

 History:

    12/14/2001 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MSAccess2000IME)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ImmAssociateContext)
APIHOOK_ENUM_END

/*++

 Disregard disabling IME.

--*/

HIMC
APIHOOK(ImmAssociateContext)(HWND hWnd, HIMC hIMC)
{
    // enable by original
    if (hIMC != NULL)
    {
        return (ORIGINAL_API(ImmAssociateContext)(hWnd, hIMC));
    }

    // disregard disable
    // msaccess.exe saves the input context return value as static, fool this
    return (ImmGetContext(hWnd));
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(IMM32.DLL, ImmAssociateContext)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\msworks6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    MSWorks6.cpp

 Abstract:

    Due to a modification in the registry in Windows XP, this app gets the path 
    for IE as "%programfiles%\ Internet Explorer\iexplore.exe" and since the 
    env variable option flag is not set for ShellExecuteEx, it cannot expand it.
    Hooked ShellExecuteW also as the app calls this at a few places.

 Notes:

    This is an app specific shim.

 History:
 
    01/25/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MSWorks6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
APIHOOK_ENUM_END

/*++

 Hooks ShellExecuteExW and sets the flag for expanding the environment variables

--*/

BOOL
APIHOOK(ShellExecuteExW)(
    LPSHELLEXECUTEINFO lpExecInfo
    )
{
    lpExecInfo->fMask |= SEE_MASK_DOENVSUBST;    
    return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);              
}

/*++

 Hooks ShellExecuteW and expands the passed file path.

--*/

HINSTANCE
APIHOOK(ShellExecuteW)(
    HWND hWnd,
    LPCWSTR lpVerb,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT nShowCmd
    )
{
    CSTRING_TRY
    {
        CString csPassedFile(lpFile);
        csPassedFile.ExpandEnvironmentStringsW();

        return ORIGINAL_API(ShellExecuteW)(hWnd, lpVerb, csPassedFile.Get(),
                    lpParameters, lpDirectory, nShowCmd);
    }
    CSTRING_CATCH
    {
        return ORIGINAL_API(ShellExecuteW)(hWnd, lpVerb, lpFile,
                    lpParameters, lpDirectory, nShowCmd);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteExW)    
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteW) 
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\myphotocenter2.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    MyPhotoCenter2.cpp

 Abstract:

    Ignore Exception caused by the application "My Photo Center 2".

 Notes:

    This is an app specific shim.

 History:

    04/25/2002  v-bvella     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(MyPhotoCenter2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ReleaseStgMedium) 
APIHOOK_ENUM_END

/*++

 This function intercepts ReleaseStgMedium call. It will ignore exception 
 cased by ReleaseStgMedium.

--*/

void
APIHOOK(ReleaseStgMedium)(
        STGMEDIUM *pmedium //Pointer to storage medium to be freed
        )
{
    __try {
        ORIGINAL_API(ReleaseStgMedium)(pmedium);
    }
    __except (1) {
        return;
    }
    return;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLE32.DLL, ReleaseStgMedium)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\money2001.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Money2001.cpp

 Abstract:

    Retry passwords at 128-bit encryption if 40-bit fails. Most code from Money 
    team.
    
    We have to patch the API directly since it is called from within it's own 
    DLL, i.e. it doesn't go through the import table.

    The function we're patching is cdecl and is referenced by it's ordinal 
    because the name is mangled.

 Notes:

    This is an app specific shim.

 History:

    07/11/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Money2001)
#include "ShimHookMacro.h"
#include <wincrypt.h>

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(FreeLibrary) 
APIHOOK_ENUM_END

#define Assert(a)

void *crtmalloc(size_t size)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        typedef void * (__cdecl *_pfn_malloc)(size_t size);

        _pfn_malloc pfnmalloc = (_pfn_malloc) GetProcAddress(hMod, "malloc");
        if (pfnmalloc) {
            return pfnmalloc(size);
        }
    }

    return malloc(size);
}

void crtfree(void *memblock)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        _pfn_free pfnfree = (_pfn_free) GetProcAddress(hMod, "free");
        if (pfnfree) {
            pfnfree(memblock);
            return;
        }
    }

    free(memblock);
}


//
// This section from the Money team
//

#define MAXLEN (100)
#define ENCRYPT_BLOCK_SIZE (8)
#define ENCRYPT_ALGORITHM CALG_RC2
#define KEY_LENGTH          (128)
#define KEY_LENGTH40        (40)

#define LgidMain(lcid)              PRIMARYLANGID(LANGIDFROMLCID(lcid))
#define LgidSub(lcid)               SUBLANGID(LANGIDFROMLCID(lcid))

BOOL FFrenchLCID()
    {
    LCID lcidSys=::GetSystemDefaultLCID();
    if (LgidMain(lcidSys)==LANG_FRENCH && LgidSub(lcidSys)==SUBLANG_FRENCH)
        return TRUE;
    else
        return FALSE;
    }

// the smallest buffer size is 8
#define BLOCKSIZE 8

// process a block, either encrypt it or decrypt it
void ProcessBlock(BOOL fEncrypt, BYTE * buffer)
    {
    BYTE mask[BLOCKSIZE];           // mask array
    BYTE temp[BLOCKSIZE];           // temporary array
    int rgnScramble[BLOCKSIZE];     // scramble array
    int i;

    // initialized scramble array
    for (i=0; i<BLOCKSIZE; i++)
        rgnScramble[i] = i;

    // generate mask and scramble indice
    for (i=0; i<BLOCKSIZE; i++)
        mask[i] = (BYTE)rand();

    for (i=0; i<4*BLOCKSIZE; i++)
        {
        int temp;
        int ind = rand() % BLOCKSIZE;
        temp = rgnScramble[i%BLOCKSIZE];
        rgnScramble[i%BLOCKSIZE] = rgnScramble[ind];
        rgnScramble[ind] = temp;
        }

    if (fEncrypt)
        {
        // xor encryption
        for (i=0; i<BLOCKSIZE; i++)
            mask[i] ^= buffer[i];

        // scramble the data
        for (i=0; i<BLOCKSIZE; i++)
            buffer[rgnScramble[i]] = mask[i];
        }
    else
        {
        // descramble the data
        for (i=0; i<BLOCKSIZE; i++)
            temp[i] = buffer[rgnScramble[i]];

        // xor decryption
        for (i=0; i<BLOCKSIZE; i++)
            buffer[i] = (BYTE) (temp[i] ^ mask[i]);
        }
    }


BYTE * DecryptFrench(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword)
    {
    BYTE buffer[BLOCKSIZE];
    int i;
    unsigned int seed = 0;
    unsigned int seedAdd = 0;
    BYTE * pb;
    BYTE * pbResult = NULL;
    unsigned int cBlocks;
    unsigned int cbResult = 0;
    unsigned int iBlocks;

    // make sure blob is at least 1 block long
    // and it's an integral number of blocks
    Assert(cbEncryptedBlob >= BLOCKSIZE);
    Assert(cbEncryptedBlob % BLOCKSIZE == 0);
    *pcbDecryptedBlob = 0;
    if (cbEncryptedBlob < BLOCKSIZE || cbEncryptedBlob % BLOCKSIZE != 0)
        return NULL;

    // calculate initial seed
    while (*szPassword)
        seed += *szPassword++;
    srand(seed);

    // retrieve the first block
    for (i=0; i<BLOCKSIZE; i++)
        buffer[i] = *pbEncryptedBlob++;
    ProcessBlock(FALSE, buffer);

    // find out the byte count and addon seed
    cbResult = *pcbDecryptedBlob = *((DWORD*)buffer);
    seedAdd = *(((DWORD*)buffer) + 1);

    // find out how many blocks we need
    cBlocks = 1 + (*pcbDecryptedBlob-1)/BLOCKSIZE;

    // make sure we have the right number of blocks
    Assert(cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE);
    if (cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE)
        {
        // allocate output memory
        pbResult = (BYTE*)crtmalloc(*pcbDecryptedBlob);
        if (pbResult)
            {
            // re-seed
            srand(seed + seedAdd);
            pb = pbResult;

            // process all blocks of data
            for (iBlocks=0; iBlocks<cBlocks; iBlocks++)
                {
                for (i=0; i<BLOCKSIZE; i++)
                    buffer[i] = *pbEncryptedBlob++;
                ProcessBlock(FALSE, buffer);
                for (i=0; i<BLOCKSIZE && cbResult>0; i++, cbResult--)
                    *pb++ = buffer[i];
                }
            }
        }

    if (!pbResult)
        *pcbDecryptedBlob = 0;
    return pbResult;
    }


HCRYPTKEY CreateSessionKey(HCRYPTPROV hCryptProv, LPCSTR szPassword, BOOL f40bit)
    {
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwEffectiveKeyLen;
    DWORD dwPadding = PKCS5_PADDING;
    DWORD dwMode = CRYPT_MODE_CBC;
    
    if (f40bit)
        dwEffectiveKeyLen=KEY_LENGTH40;
    else
        dwEffectiveKeyLen= KEY_LENGTH;

//--------------------------------------------------------------------
// The file will be encrypted with a session key derived from a
// password.
// The session key will be recreated when the file is decrypted.

//--------------------------------------------------------------------
// Create a hash object. 

    if (!CryptCreateHash(
           hCryptProv, 
           CALG_MD5, 
           0, 
           0, 
           &hHash))
        {
        goto CLEANUP;
        }  

//--------------------------------------------------------------------
// Hash the password. 

    if (!CryptHashData(
           hHash, 
           (BYTE *)szPassword, 
           strlen(szPassword)*sizeof(CHAR), 
           0))
        {
        goto CLEANUP;
        }
//--------------------------------------------------------------------
// Derive a session key from the hash object. 

    if (!CryptDeriveKey(
           hCryptProv, 
           ENCRYPT_ALGORITHM, 
           hHash, 
           0, 
           &hKey))
        {
        goto CLEANUP;
        }

// set effective key length explicitly
    if (!CryptSetKeyParam(
        hKey,
        KP_EFFECTIVE_KEYLEN,
        (BYTE*)&dwEffectiveKeyLen,
        0))
        {
        if(hKey) 
            CryptDestroyKey(hKey);
        hKey = 0;
        goto CLEANUP;
        }

    if (!f40bit)
        {
            // set padding explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_PADDING,
            (BYTE*)&dwPadding,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }

            // set mode explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_MODE,
            (BYTE*)&dwMode,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }
        }

//--------------------------------------------------------------------
// Destroy the hash object. 

CLEANUP:
    if (hHash)
        CryptDestroyHash(hHash);

    return hKey;
    }


BYTE * DecryptWorker(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword, BOOL f40bit, BOOL* pfRet)
    {
    HCRYPTPROV      hCryptProv = NULL;          // CSP handle
    HCRYPTKEY       hKey = 0;
    DWORD           cbDecryptedMessage = 0;
    BYTE*           pbDecryptedMessage = NULL;
    DWORD           dwBlockLen;
    DWORD           dwBufferLen;
    BOOL            fCreateKeyset = FALSE;

    Assert(pfRet);
    *pfRet=TRUE;

//--------------------------------------------------------------------
//  Begin processing.

    Assert(pcbDecryptedBlob);

    *pcbDecryptedBlob = 0;

    if (!pbEncryptedBlob || cbEncryptedBlob == 0)
        return NULL;

    if (FFrenchLCID())
        return DecryptFrench(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szPassword);

//--------------------------------------------------------------------
// Get a handle to a cryptographic provider.

    while (!CryptAcquireContext(
                &hCryptProv,         // Address for handle to be returned.
                NULL,                // Container
                NULL,                // Use the default provider.
                PROV_RSA_FULL,       // Need to both encrypt and sign.
                (fCreateKeyset ? CRYPT_NEWKEYSET:0)))   // flags.
        {
        // Cryptographic context could not be acquired
        DWORD nError = GetLastError();

        if (!fCreateKeyset && (nError == NTE_BAD_KEYSET || nError == NTE_KEYSET_NOT_DEF))
            {
            fCreateKeyset = TRUE;
            continue;
            }
        Assert(FALSE);
        goto CLEANUP;
        }

//--------------------------------------------------------------------
// Create the session key.
    hKey = CreateSessionKey(hCryptProv, szPassword, f40bit);
    if (!hKey)
        {
        goto CLEANUP;
        }

    dwBlockLen = cbEncryptedBlob;
    dwBufferLen = dwBlockLen; 

//--------------------------------------------------------------------
// Allocate memory.
    pbDecryptedMessage = (BYTE *)crtmalloc(dwBufferLen);
    if (!pbDecryptedMessage)
        { 
        // Out of memory
        goto CLEANUP;
        }

    memcpy(pbDecryptedMessage, pbEncryptedBlob, cbEncryptedBlob);
    cbDecryptedMessage = cbEncryptedBlob;

//--------------------------------------------------------------------
// Decrypt data. 
    if (!CryptDecrypt(
          hKey, 
          0, 
          TRUE, 
          0,
          pbDecryptedMessage, 
          &cbDecryptedMessage))
        {
        crtfree(pbDecryptedMessage);
        pbDecryptedMessage = NULL;
        cbDecryptedMessage = 0;
        *pfRet=FALSE;       
        goto CLEANUP;
        }


//--------------------------------------------------------------------
// Clean up memory.
CLEANUP:

    if(hKey) 
        CryptDestroyKey(hKey); 

    if (hCryptProv)
        {
        CryptReleaseContext(hCryptProv,0);
        // The CSP has been released.
        }

    *pcbDecryptedBlob = cbDecryptedMessage;

    return pbDecryptedMessage;
    }

BYTE * __cdecl Decrypt(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szEncryptionPassword)
    {
    BYTE*   pbDecryptedMessage;
    BOOL fRet;
    // try 128 bit first, if we fail, try 40 bit again.
    pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, FALSE, &fRet);
    if (!fRet)
        {
        if (pbDecryptedMessage)
            crtfree(pbDecryptedMessage);
        pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, TRUE, &fRet);
        }
    return pbDecryptedMessage;
    }

//
// End section from Money team
//

/*++

 Patch the Decrypt entry point.

--*/

CRITICAL_SECTION g_csPatch;
DWORD g_dwDecrypt = (DWORD_PTR)&Decrypt;

HINSTANCE
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HMODULE hMod = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    //
    // Wrap the patch in a critical section so we know the library won't be 
    // freed underneath us
    //

    EnterCriticalSection(&g_csPatch);

    HMODULE hMoney = GetModuleHandleW(L"mnyutil.dll");
    if (hMoney) {
        // Patch the dll with a jump to our function

        LPBYTE lpProc = (LPBYTE) GetProcAddress(hMoney, (LPCSTR)274);

        if (lpProc) {
            __try {
                DWORD dwOldProtect;
                if (VirtualProtect((PVOID)lpProc, 5, PAGE_READWRITE, &dwOldProtect)) {
                    *(WORD *)lpProc = 0x25ff; lpProc += 2;
                    *(DWORD *)lpProc = (DWORD_PTR)&g_dwDecrypt;
                }
            } __except(1) {
                LOGN(eDbgLevelError, "[LoadLibraryA] Exception while patching entry point");
            }
        }
    }

    LeaveCriticalSection(&g_csPatch);

    return hMod;
}

BOOL
APIHOOK(FreeLibrary)( 
    HMODULE hModule
    )
{
    EnterCriticalSection(&g_csPatch);
    BOOL bRet = ORIGINAL_API(FreeLibrary)(hModule);
    LeaveCriticalSection(&g_csPatch);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {

        if (!InitializeCriticalSectionAndSpinCount(&g_csPatch, 0x80000000)) {
            LOGN(eDbgLevelError, "[NotifyFn] Failed to initialize critical section");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\money2002.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Money2002.cpp

 Abstract:

    Retry passwords at 128-bit encryption if 40-bit fails. Most code from Money 
    team.
    
    We have to patch the API directly since it is called from within it's own 
    DLL, i.e. it doesn't go through the import table.

    The function we're patching is cdecl and is referenced by it's ordinal 
    because the name is mangled.

 Notes:

    This is an app specific shim.

 History:

    07/11/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Money2002)
#include "ShimHookMacro.h"
#include <wincrypt.h>

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(FreeLibrary) 
APIHOOK_ENUM_END

#define Assert(a)

void *crtmalloc(size_t size)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        typedef void * (__cdecl *_pfn_malloc)(size_t size);

        _pfn_malloc pfnmalloc = (_pfn_malloc) GetProcAddress(hMod, "malloc");
        if (pfnmalloc) {
            return pfnmalloc(size);
        }
    }

    return malloc(size);
}

void crtfree(void *memblock)
{
    HMODULE hMod = GetModuleHandleW(L"msvcrt.dll");

    if (hMod) {

        _pfn_free pfnfree = (_pfn_free) GetProcAddress(hMod, "free");
        if (pfnfree) {
            pfnfree(memblock);
            return;
        }
    }

    free(memblock);
}

//
// This section from the Money team
//

#define MAXLEN (100)
#define ENCRYPT_BLOCK_SIZE  (8)
#define ENCRYPT_ALGORITHM   CALG_RC2
#define KEY_LENGTH          (128)
#define KEY_LENGTH40        (40)

#define LgidMain(lcid)              PRIMARYLANGID(LANGIDFROMLCID(lcid))
#define LgidSub(lcid)               SUBLANGID(LANGIDFROMLCID(lcid))

// this function is only used for conversion
BOOL FFrenchLCID()
    {
    LCID lcidSys=::GetSystemDefaultLCID();
    if (LgidMain(lcidSys)==LANG_FRENCH && LgidSub(lcidSys)==SUBLANG_FRENCH)
        return TRUE;
    else
        return FALSE;
    }

// the smallest buffer size is 8
#define BLOCKSIZE 8

// process a block, either encrypt it or decrypt it
// this function is only used for conversion
void ProcessBlock(BOOL fEncrypt, BYTE * buffer)
    {
    BYTE mask[BLOCKSIZE];           // mask array
    BYTE temp[BLOCKSIZE];           // temporary array
    int rgnScramble[BLOCKSIZE];     // scramble array
    int i;

    // initialized scramble array
    for (i=0; i<BLOCKSIZE; i++)
        rgnScramble[i] = i;

    // generate mask and scramble indice
    for (i=0; i<BLOCKSIZE; i++)
        mask[i] = (BYTE)rand();

    for (i=0; i<4*BLOCKSIZE; i++)
        {
        int temp;
        int ind = rand() % BLOCKSIZE;
        temp = rgnScramble[i%BLOCKSIZE];
        rgnScramble[i%BLOCKSIZE] = rgnScramble[ind];
        rgnScramble[ind] = temp;
        }

    if (fEncrypt)
        {
        // xor encryption
        for (i=0; i<BLOCKSIZE; i++)
            mask[i] ^= buffer[i];

        // scramble the data
        for (i=0; i<BLOCKSIZE; i++)
            buffer[rgnScramble[i]] = mask[i];
        }
    else
        {
        // descramble the data
        for (i=0; i<BLOCKSIZE; i++)
            temp[i] = buffer[rgnScramble[i]];

        // xor decryption
        for (i=0; i<BLOCKSIZE; i++)
            buffer[i] = (BYTE) (temp[i] ^ mask[i]);
        }
    }


// this function is only used for conversion
BYTE * DecryptFrench(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword)
    {
    BYTE buffer[BLOCKSIZE];
    int i;
    unsigned int seed = 0;
    unsigned int seedAdd = 0;
    BYTE * pb;
    BYTE * pbResult = NULL;
    unsigned int cBlocks;
    unsigned int cbResult = 0;
    unsigned int iBlocks;

    // make sure blob is at least 1 block long
    // and it's an integral number of blocks
    Assert(cbEncryptedBlob >= BLOCKSIZE);
    Assert(cbEncryptedBlob % BLOCKSIZE == 0);
    *pcbDecryptedBlob = 0;
    if (cbEncryptedBlob < BLOCKSIZE || cbEncryptedBlob % BLOCKSIZE != 0)
        return NULL;

    // calculate initial seed
    while (*szPassword)
        seed += *szPassword++;
    srand(seed);

    // retrieve the first block
    for (i=0; i<BLOCKSIZE; i++)
        buffer[i] = *pbEncryptedBlob++;
    ProcessBlock(FALSE, buffer);

    // find out the byte count and addon seed
    cbResult = *pcbDecryptedBlob = *((DWORD*)buffer);
    seedAdd = *(((DWORD*)buffer) + 1);

    // find out how many blocks we need
    cBlocks = 1 + (*pcbDecryptedBlob-1)/BLOCKSIZE;

    // make sure we have the right number of blocks
    Assert(cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE);
    if (cBlocks + 1 == cbEncryptedBlob / BLOCKSIZE)
        {
        // allocate output memory
        pbResult = (BYTE*)crtmalloc(*pcbDecryptedBlob);
        if (pbResult)
            {
            // re-seed
            srand(seed + seedAdd);
            pb = pbResult;

            // process all blocks of data
            for (iBlocks=0; iBlocks<cBlocks; iBlocks++)
                {
                for (i=0; i<BLOCKSIZE; i++)
                    buffer[i] = *pbEncryptedBlob++;
                ProcessBlock(FALSE, buffer);
                for (i=0; i<BLOCKSIZE && cbResult>0; i++, cbResult--)
                    *pb++ = buffer[i];
                }
            }
        }

    if (!pbResult)
        *pcbDecryptedBlob = 0;
    return pbResult;
    }



HCRYPTKEY CreateSessionKey(HCRYPTPROV hCryptProv, LPCSTR szPassword, BOOL fConvert, BOOL f40bit)
    {
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hKey = 0;
    DWORD dwEffectiveKeyLen;
    DWORD dwPadding = PKCS5_PADDING;
    DWORD dwMode = CRYPT_MODE_CBC;

    if (f40bit)
        dwEffectiveKeyLen=KEY_LENGTH40;
    else
        dwEffectiveKeyLen= KEY_LENGTH;
//--------------------------------------------------------------------
// The file will be encrypted with a session key derived from a
// password.
// The session key will be recreated when the file is decrypted.

//--------------------------------------------------------------------
// Create a hash object. 

    if (!CryptCreateHash(
           hCryptProv, 
           CALG_MD5, 
           0, 
           0, 
           &hHash))
        {
        goto CLEANUP;
        }  

//--------------------------------------------------------------------
// Hash the password. 

    if (!CryptHashData(
           hHash, 
           (BYTE *)szPassword, 
           strlen(szPassword)*sizeof(CHAR), 
           0))
        {
        goto CLEANUP;
        }
//--------------------------------------------------------------------
// Derive a session key from the hash object. 

    if (!CryptDeriveKey(
           hCryptProv, 
           ENCRYPT_ALGORITHM, 
           hHash, 
           (fConvert ? 0 : (KEY_LENGTH << 16) | CRYPT_EXPORTABLE), 
           &hKey))
        {
        goto CLEANUP;
        }

    // set effective key length explicitly
    if (!CryptSetKeyParam(
        hKey,
        KP_EFFECTIVE_KEYLEN,
        (BYTE*)&dwEffectiveKeyLen,
        0))
        {
        if(hKey) 
            CryptDestroyKey(hKey);
        hKey = 0;
        goto CLEANUP;
        }
    
    if (!fConvert && !f40bit)
        {
            // set padding explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_PADDING,
            (BYTE*)&dwPadding,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }

            // set mode explicitly
            if (!CryptSetKeyParam(
                hKey,
                KP_MODE,
            (BYTE*)&dwMode,
                    0))
                    {
                    if(hKey) 
                        CryptDestroyKey(hKey);
                    hKey = 0;
                    goto CLEANUP;
                }
        }


//--------------------------------------------------------------------
// Destroy the hash object. 

CLEANUP:

    if (hHash)
        CryptDestroyHash(hHash);

    return hKey;
    }


BYTE * DecryptWorker(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szPassword, BOOL fConvert, BOOL f40bit, BOOL* pfRet)
    {
    HCRYPTPROV      hCryptProv = NULL;          // CSP handle
    HCRYPTKEY       hKey = 0;
    DWORD           cbDecryptedMessage = 0;
    BYTE*           pbDecryptedMessage = NULL;
    DWORD           dwBlockLen;
    DWORD           dwBufferLen;

    Assert(pfRet);
    *pfRet=TRUE;
//--------------------------------------------------------------------
//  Begin processing.

    Assert(pcbDecryptedBlob);

    *pcbDecryptedBlob = 0;

    if (!pbEncryptedBlob || cbEncryptedBlob == 0)
        return NULL;

    if (FFrenchLCID() && fConvert)
        return DecryptFrench(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szPassword);

//--------------------------------------------------------------------
// Get a handle to a cryptographic provider.

    if (!CryptAcquireContext(
                &hCryptProv,         // Address for handle to be returned.
                NULL,                // Container
                (fConvert ? NULL : MS_ENHANCED_PROV),    // Use the default provider.
                PROV_RSA_FULL,       // Need to both encrypt and sign.
                CRYPT_VERIFYCONTEXT))   // flags.
        {
        Assert(FALSE);
        goto CLEANUP;
        }

//--------------------------------------------------------------------
// Create the session key.
    hKey = CreateSessionKey(hCryptProv, szPassword, fConvert, f40bit);
    if (!hKey)
        {
        goto CLEANUP;
        }

    dwBlockLen = cbEncryptedBlob;
    dwBufferLen = dwBlockLen; 

//--------------------------------------------------------------------
// Allocate memory.
    pbDecryptedMessage = (BYTE *)crtmalloc(dwBufferLen);
    if (!pbDecryptedMessage)
        { 
        // Out of memory
        goto CLEANUP;
        }

    memcpy(pbDecryptedMessage, pbEncryptedBlob, cbEncryptedBlob);
    cbDecryptedMessage = cbEncryptedBlob;

//--------------------------------------------------------------------
// Decrypt data. 
    if (!CryptDecrypt(
          hKey, 
          0, 
          TRUE, 
          0,
          pbDecryptedMessage, 
          &cbDecryptedMessage))
        {
        crtfree(pbDecryptedMessage);
        pbDecryptedMessage = NULL;
        cbDecryptedMessage = 0;
        *pfRet=FALSE;
        goto CLEANUP;
        }

//--------------------------------------------------------------------
// Clean up memory.
CLEANUP:

    if(hKey) 
        CryptDestroyKey(hKey); 

    if (hCryptProv)
        {
        CryptReleaseContext(hCryptProv,0);
        // The CSP has been released.
        }

    *pcbDecryptedBlob = cbDecryptedMessage;

    return pbDecryptedMessage;
    }

BYTE * __cdecl Decrypt(const BYTE * pbEncryptedBlob, DWORD cbEncryptedBlob, DWORD * pcbDecryptedBlob, LPCSTR szEncryptionPassword, BOOL fConvert)
    {
    BYTE*   pbDecryptedMessage;
    BOOL fRet;
    // try 128 bit first, if we fail, try 40 bit again.
    pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, fConvert, FALSE, &fRet);
    if (!fRet)
        {
        if (pbDecryptedMessage)
            crtfree(pbDecryptedMessage);
        pbDecryptedMessage = DecryptWorker(pbEncryptedBlob, cbEncryptedBlob, pcbDecryptedBlob, szEncryptionPassword, fConvert, TRUE, &fRet);
        }
    return pbDecryptedMessage;
    }

//
// End section from Money team
//

/*++

 Patch the Decrypt entry point.

--*/

CRITICAL_SECTION g_csPatch;
DWORD g_dwDecrypt = (DWORD_PTR)&Decrypt;

HINSTANCE
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HMODULE hMod = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    //
    // Wrap the patch in a critical section so we know the library won't be 
    // freed underneath us
    //

    EnterCriticalSection(&g_csPatch);

    HMODULE hMoney = GetModuleHandleW(L"mnyutil.dll");
    if (hMoney) {
        // Patch the dll with a jump to our function

        LPBYTE lpProc = (LPBYTE) GetProcAddress(hMoney, (LPCSTR)290);

        if (lpProc) {
            __try {
                DWORD dwOldProtect;
                if (VirtualProtect((PVOID)lpProc, 5, PAGE_READWRITE, &dwOldProtect)) {
                    *(WORD *)lpProc = 0x25ff; lpProc += 2;
                    *(DWORD *)lpProc = (DWORD_PTR)&g_dwDecrypt;
                }
            } __except(1) {
                LOGN(eDbgLevelError, "[LoadLibraryA] Exception while patching entry point");
            }
        }
    }

    LeaveCriticalSection(&g_csPatch);

    return hMod;
}

BOOL
APIHOOK(FreeLibrary)( 
    HMODULE hModule
    )
{
    EnterCriticalSection(&g_csPatch);
    BOOL bRet = ORIGINAL_API(FreeLibrary)(hModule);
    LeaveCriticalSection(&g_csPatch);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        if (!InitializeCriticalSectionAndSpinCount(&g_csPatch, 0x80000000)) {
            LOGN(eDbgLevelError, "[NotifyFn] Failed to initialize critical section");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\netbackup45.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    NetBackup45.cpp

 Abstract:

    The app calls CString::SetAt with an index > length. This API was
    modified to throw an exception in this case to prevent a buffer 
    overrun.

 Notes:

    This is an app specific shim.

 History:

    07/08/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NetBackup45)
#include "ShimHookMacro.h"

typedef VOID (WINAPI *_pfn_MFC_CString_SetAt)();

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(MFC_CString_SetAt) 
APIHOOK_ENUM_END

/*++

 Only allow the call if index < length

--*/

__declspec(naked)
VOID
APIHOOK(MFC_CString_SetAt)()
{
    __asm {
      mov  eax, [ecx]
      mov  eax, [eax - 8]       // This gets us the length
      
      cmp  [esp + 4], eax	// [esp + 4] = Index; eax = Length
      jge  Done
      
      push [esp + 8]
      push [esp + 8]
    }

    ORIGINAL_API(MFC_CString_SetAt)();

  Done:

    __asm {
      ret  8
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_ORD(MFC42.DLL, MFC_CString_SetAt, 5856)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\nbalive.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NBALive.cpp

 Abstract:

    On Win9x, SetWindowText used to pass the pointer directly to the window 
    proc in a WM_SETTEXT message. However, on NT, the string goes through the 
    standard message workers and get's converted to unicode etc. When it does 
    get to the window proc, it's not the original pointer.

    NBA Live 99 depends on the pointer being the same, since it sends more than 
    just the string. 

    The fix is to subclass the WindowProc on SetWindowText and change the 
    pointer (in lParam) to the one that was originally passed.

 Notes:
    
    This is an app specific shim.

 History:

    06/19/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NBALive)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowTextA) 
APIHOOK_ENUM_END


//
// Critical section for global variable access
//

CRITICAL_SECTION g_csGlobals;

//
// Text for window and previous windowproc
//

CHAR *g_szText; 
WNDPROC g_lpWndProc;

/*++

 The subclassed windowproc that we use to change the text pointer to the 
 original one passed to SetWindowTextA.

--*/

LRESULT
CALLBACK
WindowProcA(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    if (uMsg == WM_SETTEXT) {
        if (lParam)  {
            if (strcmp(g_szText, (CHAR *) lParam) == 0)  {
                lParam = (LPARAM) g_szText;
            }
        }
    }

    return CallWindowProcA(g_lpWndProc, hWnd, uMsg, wParam, lParam);
}

/*++

 Subclass the windowproc for this call and fix the pointer that comes out in 
 the WM_SETTEXT message that is generated by SetWindowTextA.

--*/

BOOL 
APIHOOK(SetWindowTextA)(
    HWND hWnd,         
    LPCSTR lpString   
    )
{
    BOOL bRet = FALSE;

    //
    // Set the text for this window
    //

    EnterCriticalSection(&g_csGlobals);

    //
    // Subclass the window
    //
    
    g_lpWndProc = (WNDPROC) GetWindowLongA(hWnd, GWL_WNDPROC);

    if (g_lpWndProc)  {
        SetWindowLongA(hWnd, GWL_WNDPROC, (LONG_PTR) WindowProcA);
    }

    //
    // Call the original function which generates a WM_SETTEXT message
    //
    
    g_szText = (CHAR *) lpString;
    bRet = ORIGINAL_API(SetWindowTextA)(hWnd, lpString);

    //
    // Restore the wndproc
    //

    SetWindowLongA(hWnd, GWL_WNDPROC, (LONG_PTR) g_lpWndProc);

    LeaveCriticalSection(&g_csGlobals);

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        InitializeCriticalSection(&g_csGlobals);
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(USER32.DLL, SetWindowTextA )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\netzip.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NetZip.cpp

 Abstract:

    This App. stops when it is searching for installed browsers. I found that 
    the App. tries enumerating all processes running using the API call 
    EnumProcesses(). This is OK and the App. gets the list of PID's. Now, the 
    App wants to go through each individual Process's modules using 
    EnumProcessModules. Before that it gets the handle to each process calling 
    OpenProcess() on each. On the 'System Idle Process', which has a PID of '0', 
    the call to OpenProcess() returns failure and that is handled. The App then 
    goes to the next process, which is the 'System' process. The PID is '8'. 
    The App successfully gets the process handle by a call to OpenProcess() but 
    when the App. calls EnumProcessModules(), this call returns failure and the 
    GetLastError( ) returns ERROR_PARTIAL_COPY(0x12b). The App. does not know 
    how to handle this and it fails.

    When I traced into this API, it calls ReadProcessMemory(), which in turn 
    calls NtReadVirtualMemory(). This is a Kernel call and it returns 8000000d 
    on Windows 2000. GetLastError() for this translates to 
    ERROR_PARTIAL_COPY(0x12b). On Windows NT 4.0, the EnumProcessModules() API 
    calls ReadProcessMemory(), which inturn calls NtReadVirtualMemory() which 
    returns 0xC0000005. GetLastError() for this translates to 
    ERROR_NOACCESS(0x3e6) - (Invalid access to a memory location). The App. is 
    able to handle this. So, the APP should handle both ERROR_NOACCESS and 
    ERROR_PARTIAL_COPY.
   
 Notes:

    This is an app specific shim.

 History:

    04/21/2000 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NetZip)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(EnumProcessModules) 
APIHOOK_ENUM_END

/*++

  This function intercepts EnumProcessModules( ) and and handles the return of 
  ERROR_PARTIAL_COPY.

--*/

BOOL
APIHOOK(EnumProcessModules)(
    HANDLE hProcess,         // Handle to process
    HMODULE *lphModule,      // Array of Handle modules
    DWORD   cb,              // size of array
    LPDWORD lpcbNeeded       // Number od bytes returned.
    )      
{
    BOOL fRet = FALSE;

    fRet = ORIGINAL_API(EnumProcessModules)( 
        hProcess,
        lphModule,
        cb,
        lpcbNeeded);

    if (GetLastError( ) == ERROR_PARTIAL_COPY)
    {
        SetLastError(ERROR_NOACCESS);
    }
    
    return fRet;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(PSAPI.DLL, EnumProcessModules )

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\newshendiaoxialv.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    NewShenDiaoXiaLv.cpp

 Abstract:

    On NT, when there is no CD in the CDROM, and the app sends a MCI_OPEN 
    command to the CDAUDIO device, the app has fully exclusive control of the 
    CDROM. When later on user inserts CD, the app will not receive 
    WM_DEVICECHANGE message. And this app relies on the message to know if 
    there is a new CD inserted. 
    
    The fix is check whether the CD is there when we do MCI_OPEN command, if 
    there is not CD, we will close the device.

 Notes: 
  
    This is an app specific shim.

 History:

    05/28/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NewShenDiaoXiaLv)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Close the device if we get hardware error(CD is not there).

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    MCIERROR mciErr, mciError;
    MCI_STATUS_PARMS mciStatus;
    LPMCI_OPEN_PARMSA lpmciOpenParam;
    CString cstrDeviveType;
    
    mciErr = ORIGINAL_API(mciSendCommandA)(IDDevice, uMsg, fdwCommand, dwParam);
    
    // We are only interested in a successful MCI_OPEN Message  
    if (mciErr || (uMsg != MCI_OPEN) || IsBadReadPtr((CONST VOID*)(ULONG_PTR)dwParam, 1))
    {
        goto End;
    }  

    // We are only interested in MCI message sent to CDAUDIO
    lpmciOpenParam = (LPMCI_OPEN_PARMSA) dwParam;
    if ((ULONG_PTR) lpmciOpenParam->lpstrDeviceType <= 0xffff)
    {
        if ((ULONG_PTR)lpmciOpenParam->lpstrDeviceType != MCI_DEVTYPE_CD_AUDIO)
        {
            goto End;
        }
    }
    else
    {
        CString cstrDeviveType(lpmciOpenParam->lpstrDeviceType);
        if (cstrDeviveType.CompareNoCase(L"cdaudio"))
        {
            goto End;
        }
    }
    
    // Send an MCI_STATUS 
    mciStatus.dwItem = MCI_STATUS_LENGTH ;
    mciError = mciSendCommandA(lpmciOpenParam->wDeviceID, MCI_STATUS, 
        MCI_STATUS_ITEM | MCI_TRACK | MCI_WAIT, (DWORD_PTR) &mciStatus);

    if (MCIERR_HARDWARE == mciError)
    {        
        //
        // If we get hardware error, it means CD is not there, close the device
        // and return error
        //
        mciSendCommandA(lpmciOpenParam->wDeviceID, MCI_CLOSE, 0, 0);
        mciErr = MCIERR_DEVICE_NOT_READY;
    }

End:
    return mciErr;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\nflfever2000.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NFLFever2000.cpp

 Abstract:
     
    The app reads past the end of files that it's copied into memory. 
    The shim allocates additional memory for it

    Note we included an in-memory patch for Win2k. On Whistler it's not
    required, the rest of the shim does the work.
     
 Notes:

    This is an app specific shim.

 History:
           
    01/11/2000 linstev  Created
    10/03/2000 maonis   Modified (the acm stuff is now in a general purpose shim)
   
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NFLFever2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileSize) 
    APIHOOK_ENUM_ENTRY(RtlAllocateHeap) 
    APIHOOK_ENUM_ENTRY(mmioSetInfo) 
APIHOOK_ENUM_END

DWORD g_dwFileSize = -1;
BOOL g_bPatched = FALSE;

/*++

 Hook GetFileSize to make sure we get the correct heap allocations.

--*/

DWORD 
APIHOOK(GetFileSize)(
    HANDLE hFile,
    LPDWORD lpFileSizeHigh 
    )
{
    DWORD dwRet = ORIGINAL_API(GetFileSize)(hFile, lpFileSizeHigh);

    g_dwFileSize = dwRet;

    PBYTE p;
    ULONG oldProtect;

    if (!g_bPatched)  {
        p = (PBYTE)0x10995d0;
        if (!IsBadReadPtr(p, 1) && (*p == 0x8b)) {
            VirtualProtect(p, 3, PAGE_READWRITE, &oldProtect);
            *p = 0xc2;
            *(p + 1) = 0x8;
            *(p + 2) = 0x0;
            VirtualProtect(p, 3, oldProtect, &oldProtect);
            g_bPatched = TRUE;
        }
    }

    return dwRet;
}

/*++

 Increase the heap allocation size.

--*/

PVOID 
APIHOOK(RtlAllocateHeap) (
    PVOID HeapHandle,
    ULONG Flags,
    SIZE_T Size
    )
{
    if (Size == g_dwFileSize)  {
        DPFN( eDbgLevelError, "Adjusted heap allocation from %d to %d\n", Size, Size+0x1000);
        Size += 0x1000;
    }

    return ORIGINAL_API(RtlAllocateHeap)(HeapHandle, Flags, Size);
}

/*++

 Make the buffer read/write.

--*/

MMRESULT 
APIHOOK(mmioSetInfo)(
    HMMIO hmmio,            
    LPMMIOINFO lpmmioinfo,  
    UINT wFlags             
    )
{
    //
    // BUGBUG: Not needed on XP, but still required on Win2k
    // This fix causes sound to skip, see #304678. 
    //
    // Win2k used to check if the buffer could be written to, instead of just 
    // read. We fixed this on XP. However, it's not enough to just copy the 
    // buffer, because it's used later.
    // Not clear what the actual fix is though.
    // 
    
    /*
    HPSTR p = NULL;

    if (lpmmioinfo && lpmmioinfo->pchBuffer &&
       (IsBadWritePtr(lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer) && 
        !IsBadReadPtr(lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer)))    {
            p = (HPSTR) malloc(lpmmioinfo->cchBuffer);
            if (p)  {
                DPFN( eDbgLevelError, "Fixing mmioSetInfo buffer");
                MoveMemory(p, lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer);
                lpmmioinfo->pchBuffer = p;
            } 
    }

    MMRESULT mRet = ORIGINAL_API(mmioSetInfo)(hmmio, lpmmioinfo, wFlags);

    if (p)  {
        free(p);
    }

    return mRet;
    */

    return ORIGINAL_API(mmioSetInfo)(hmmio, lpmmioinfo, wFlags);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetFileSize)
    APIHOOK_ENTRY(NTDLL.DLL, RtlAllocateHeap)
    APIHOOK_ENTRY(WINMM.DLL, mmioSetInfo)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\nflblitz.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    NFLBlitz.cpp

 Abstract:

    NFL Blitz has 2 problems:
    
      1. It keeps linked lists on it's stack and somehow the stack pointer 
         is changed to allow altered FindFirstFile to corrupt it. We don't hit 
         this on win9x because FindFirstFile doesn't use any app stack space.

      2. Autorun and the main executable are synchronized using a mutex that is 
         freed only on process termination. The sequence of events is:

            a. Autorun creates a mutex
            b. Autorun creates a new process
            c. Autorun terminates thus freeing the mutex in (a).
            d. New process checks if it's already running by examining the 
               mutex created in (a).

         This fails when (c) and (d) are exchanged which happens all the time 
         on NT, but apparently very seldom on win9x.
    
 Notes:

    This is an app specific shim.

 History:

    02/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NFLBlitz)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateMutexA) 
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

HANDLE g_hMutex = NULL;

/*++

 Store the handle to the mutex we're interested in.

--*/

HANDLE 
APIHOOK(CreateMutexA)(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,  
    LPCSTR lpName       
    )
{
    HANDLE hRet = ORIGINAL_API(CreateMutexA)(
        lpMutexAttributes, 
        bInitialOwner, 
        lpName);

    DWORD dwErrCode = GetLastError();

    if (lpName && _stricmp(lpName, "NFL BLITZ") == 0)
    {
        g_hMutex = hRet;
    }

    SetLastError(dwErrCode);

    return hRet;
}

/*++

 Close the mutex.

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,  
    LPSECURITY_ATTRIBUTES lpProcessAttributes,  
    LPSECURITY_ATTRIBUTES lpThreadAttributes,   
    BOOL bInheritHandles,  
    DWORD dwCreationFlags, 
    LPVOID lpEnvironment,  
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,  
    LPPROCESS_INFORMATION lpProcessInformation  
    )
{
    if (g_hMutex)
    {
        ReleaseMutex(g_hMutex);
        CloseHandle(g_hMutex);
        g_hMutex = NULL;
    }

    return ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,  
        lpProcessAttributes,  
        lpThreadAttributes,   
        bInheritHandles,  
        dwCreationFlags, 
        lpEnvironment,  
        lpCurrentDirectory,
        lpStartupInfo,  
        lpProcessInformation);
}
  
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateMutexA)
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\netobjectsfusion5.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    NetObjectsFusion5.cpp

 Abstract:

    This shim hooks the CreateFile/WriteFile if the file is corpwiz_loader.html
    to write in the  required javascript so as to make the appwork if the IE browser
    version is > 5.

 Notes:

    This is an app specific shim.

 History:
 
    01/24/2001  a-leelat    Created
    03/13/2001  robkenny    Converted to CString

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NetObjectsFusion5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CloseHandle)
    APIHOOK_ENUM_ENTRY(WriteFile)
    APIHOOK_ENUM_ENTRY(CreateFileA)
APIHOOK_ENUM_END



volatile HANDLE g_Handle = NULL;


HANDLE
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    
    CHAR szNameToCheck[] = "corpwiz_loader.html";

    HANDLE l_Handle =  (HANDLE)ORIGINAL_API(CreateFileA)(
                                            lpFileName,
                                            dwDesiredAccess,
                                            dwShareMode,
                                            lpSecurityAttributes,
                                            dwCreationDisposition,
                                            dwFlagsAndAttributes,
                                            hTemplateFile);
    

    if ( strstr(lpFileName,szNameToCheck) )
    {
        
        if (l_Handle != INVALID_HANDLE_VALUE ) 
            g_Handle = l_Handle;
   
    }
    else
        g_Handle = NULL;

    return l_Handle;

}


BOOL
APIHOOK(WriteFile)(
    HANDLE       hFile,              
    LPCVOID      lpBuffer,        
    DWORD        nNumberOfBytesToWrite,
    LPDWORD      lpNumberOfBytesWritten,
    LPOVERLAPPED lpOverlapped    
    )
{
    BOOL bRet = FALSE;

    
    if ( g_Handle && (hFile == g_Handle) && lpBuffer)
    {
        
        
        CHAR szStringToWrite[] = "\r\n        var IsIE6 = navigator.userAgent.indexOf(\"IE 6\") > -1;\r\n\r\n    if ( IsIE6 == true ) { IsIE5 = true; }\r\n";
        CHAR szStringToCheck[] = "var IsIE5 = navigator.userAgent.indexOf(\"IE 5\") > -1;";
        CHAR *szPtr = NULL;

        if ((szPtr = strstr((LPCSTR)lpBuffer,szStringToCheck)))
        {

                int iSize = sizeof(CHAR) * (szPtr - (LPSTR)lpBuffer + strlen(szStringToCheck));
                
                DWORD dwTotalBytesWritten;
                
                bRet = ORIGINAL_API(WriteFile)(
                        hFile,
                        lpBuffer,
                        (DWORD)iSize,
                        lpNumberOfBytesWritten,
                        lpOverlapped);
               

                dwTotalBytesWritten = *lpNumberOfBytesWritten;
                
                bRet = ORIGINAL_API(WriteFile)(
                        hFile,
                        (LPVOID)szStringToWrite,
                        (DWORD)strlen(szStringToWrite),
                        lpNumberOfBytesWritten,
                        lpOverlapped);
                

                CHAR* szrBuf = (LPSTR)lpBuffer + iSize;

                bRet = ORIGINAL_API(WriteFile)(
                        hFile,
                        (LPVOID)szrBuf,
                        (nNumberOfBytesToWrite - (DWORD)iSize),
                        lpNumberOfBytesWritten,
                        lpOverlapped);
                

                *lpNumberOfBytesWritten += dwTotalBytesWritten;

                return bRet;
            
        }//end of if
    }
    
   return ORIGINAL_API(WriteFile)(
                       hFile,
                       lpBuffer,
                       nNumberOfBytesToWrite,
                       lpNumberOfBytesWritten,
                       lpOverlapped);
        
}


BOOL
APIHOOK(CloseHandle)(
        HANDLE hObject
        )
{

    if ( g_Handle && (hObject == g_Handle) )
    {
        g_Handle = NULL;
    }
    
    return ORIGINAL_API(CloseHandle)(hObject);

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, WriteFile)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\netmanageviewnow.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    NetManageViewNow.cpp

 Abstract:


    The app doesnt follow stdcall conventions for the ServiceMain function
    it registers with SCM. This is resulting in an AV as the ServiceMain
    is not cleaning up the stack on return,  after being called by SCM. 
    We clean up the stack for the app registered ServiceMain by hooking 
    StartServiceCtrlDispatcher and registering our own ServiceMain routine, 
    which makes the actual call to the app registered servicemain and then
    pop 8 bytes of the stack before returning.

    
 Notes:

    This is an app specific shim.

 History:

    03/08/2001 a-leelat Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NetManageViewNow)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(StartServiceCtrlDispatcherA)
    APIHOOK_ENUM_ENTRY(StartServiceCtrlDispatcherW)
APIHOOK_ENUM_END



//last entry of the service table are supposed to be NULL entries
SERVICE_TABLE_ENTRYA        g_SvcTableA[] = { {NULL,NULL},{NULL,NULL} };
SERVICE_TABLE_ENTRYW        g_SvcTableW[] = { {NULL,NULL},{NULL,NULL} };

LPSERVICE_MAIN_FUNCTIONA    g_pfnActualMainA = NULL;
LPSERVICE_MAIN_FUNCTIONW    g_pfnActualMainW = NULL;




VOID WINAPI ServiceMainA(
  DWORD dwArgc,     // number of arguments
  LPSTR *lpszArgv  // array of arguments
)
{

    //call the actual routine
    (g_pfnActualMainA)(dwArgc,lpszArgv);

    //pop 8 bytes of stack to compensate for
    //the app not following stdcall convention
    __asm
    {
        add esp,8
    }
}


VOID WINAPI ServiceMainW(
  DWORD dwArgc,     // number of arguments
  LPWSTR *lpszArgv  // array of arguments
)
{

    //call the actual routine
    (g_pfnActualMainW)(dwArgc,lpszArgv);

    //pop 8 bytes of stack to compensate for
    //the app not following stdcall convention
    __asm
    {
        add esp, 8
    }

}




BOOL APIHOOK(StartServiceCtrlDispatcherA)(
  CONST LPSERVICE_TABLE_ENTRYA lpServiceTable   // service table
)
{
    BOOL bRet = false;
    
    LPSERVICE_TABLE_ENTRYA lpSvcTblToPass = lpServiceTable;

    DWORD ccbServiceName = (strlen(lpServiceTable->lpServiceName) + 1) * sizeof(*lpServiceTable->lpServiceName);
    LPSTR serviceName = (LPSTR) malloc(ccbServiceName);

    if (serviceName == NULL)
    {
        DPFN( eDbgLevelError, 
            "[StartServiceCtrlDispatcherA] Buffer allocation failure");
    }
    else
    {
        //Setup our service table to register with SCM
    
        //Copy the service name as defined by the app
        HRESULT hr = StringCbCopyA(serviceName, ccbServiceName, lpServiceTable->lpServiceName);
        if (SUCCEEDED(hr))
        {
            g_SvcTableA[0].lpServiceName = serviceName;

            //Now put our service routine
            g_SvcTableA[0].lpServiceProc = ServiceMainA;

            //Save the old servicemain func ptr
            g_pfnActualMainA = lpServiceTable->lpServiceProc;

            //Set the service table to our table
            lpSvcTblToPass = &g_SvcTableA[0];

            DPFN( eDbgLevelInfo, 
                "[StartServiceCtrlDispatcherA] Hooked ServiceMainA");
        }
    }

   //Call the Original API
   bRet =  StartServiceCtrlDispatcherA(lpSvcTblToPass); 
   
   return bRet;
 
}




BOOL APIHOOK(StartServiceCtrlDispatcherW)(
  CONST LPSERVICE_TABLE_ENTRYW lpServiceTable   // service table
)
{
    BOOL bRet = false;
    
    LPSERVICE_TABLE_ENTRYW lpSvcTblToPass = lpServiceTable;

    DWORD ccbServiceName = (wcslen(lpServiceTable->lpServiceName) + 1) * sizeof(*lpServiceTable->lpServiceName);
    LPWSTR serviceName = (LPWSTR) malloc(ccbServiceName);

    if (serviceName == NULL)
    {
        DPFN( eDbgLevelError, 
            "[StartServiceCtrlDispatcherW] Buffer allocation failure");
    }
    else
    {
        //Setup our service table to register with SCM

        //Copy the service name as defined by the app
        HRESULT hr = StringCbCopyW(serviceName, ccbServiceName, lpServiceTable->lpServiceName);
        if (SUCCEEDED(hr))
        {
            g_SvcTableW[0].lpServiceName = serviceName;

            //Now put our service routine
            g_SvcTableW[0].lpServiceProc = ServiceMainW;

            //Save the old servicemain func ptr
            g_pfnActualMainW = lpServiceTable->lpServiceProc;

            //Set the service table to our table
            lpSvcTblToPass = &g_SvcTableW[0];

            DPFN( eDbgLevelInfo, 
                "[StartServiceCtrlDispatcherW] Hooked ServiceMainW");
        }
    }


   //Call the Original API
   bRet =  StartServiceCtrlDispatcherW(lpSvcTblToPass);
   
   return bRet;
}



/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceCtrlDispatcherA)
    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceCtrlDispatcherW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\nhl2001.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   NHL2001.cpp

 Abstract:

    EA Sports' NHL 2001 has a bug where if the platform returned by
    GetVersionExA is not windows, they don't call the GetDiskFreeSpace and
    then report no free space to create a tournament season or playoff.
    Unfortunately, a generic version lie does not work because the game is
    safedisk protected, so we both apps to have the same GetVesionExA.

 History:

    06/04/2001  pierreys    Created
*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(NHL2001)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetDiskFreeSpaceA)
APIHOOK_ENUM_END

BOOL    fGetDiskFreeSpaceCalled = FALSE;

BOOL 
APIHOOK(GetDiskFreeSpaceA)(
    LPCSTR  lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    )
{
    //
    // Take notice of the call
    //
    fGetDiskFreeSpaceCalled = TRUE;

    //
    // Call the original API
    //
    return ORIGINAL_API(GetDiskFreeSpaceA)(
                    lpRootPathName, 
                    lpSectorsPerCluster, 
                    lpBytesPerSector, 
                    lpNumberOfFreeClusters, 
                    lpTotalNumberOfClusters);
}

BOOL
APIHOOK(GetVersionExA)(LPOSVERSIONINFOA lpVersionInformation)
{
    if (fGetDiskFreeSpaceCalled)
    {
        LOGN(
        eDbgLevelInfo,
        "[GetVersionExA] called after GetDiskFreeSpace. return Win98.");

        // Fixup the structure with the Win98 data
        lpVersionInformation->dwMajorVersion = 4;
        lpVersionInformation->dwMinorVersion = 10;
        lpVersionInformation->dwBuildNumber = 0x040A08AE;
        lpVersionInformation->dwPlatformId = 1;
        *lpVersionInformation->szCSDVersion = '\0';

        return TRUE;
    }
    else
    {
        return ORIGINAL_API(GetVersionExA)(lpVersionInformation);
    }
}


HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetDiskFreeSpaceA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\nikonview.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    NikonView.cpp

 Abstract:

    App crashes on exit trying to dereference a NULL. This memory is never 
    initialized, so it's not clear how this ever worked.

    Fixed by recognizing the exit sequence and killing the process before it 
    AVs.

 Notes:
 
    This is an app specific shim.

 History:

    06/25/2002 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(NikonView)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(UnregisterClassA) 
APIHOOK_ENUM_END

DWORD g_dwCount = 0;

/*++

 Kill the app on failed UnregisterClass

--*/

BOOL 
APIHOOK(UnregisterClassA)(
    LPCSTR lpClassName,  
    HINSTANCE hInstance   
    )
{
    BOOL bRet = ORIGINAL_API(UnregisterClassA)(lpClassName, hInstance);

    // Recognize termination sequence
    if (!bRet && lpClassName && (!IsBadReadPtr(lpClassName, 1)) && (*lpClassName == '\0')) {
        g_dwCount++;
        if (g_dwCount == 3) {
            ExitProcess(0); 
        }
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, UnregisterClassA)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\office9complexscript.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    RemoveComplexScriptExtraSpace.cpp

 Abstract:
    
    This shim fix regression bug from Win 2K regarding complex script showing problem.
    ex) Reversed BiDi text.

    Windows XP LPK turn off the complex script handling on the text which has extra spaces.
    'Cause extra character space with complex script doesn't make sense. (tarekms)
    This is a change from Windows 2000 and based on enabling font fallback for the FE languages.

    Then as bug 547349 for Office 2000, we may see BiDi text doesn't appear correctly.
    So far, reported problem is only for Hebrew and Arabic localized Office 2000 splash screen on .NET Server.
    This shim removes extra space set by SetTextCharacterExtra() for ExtTextOutW and Complex Script text.

 Notes:

    This is a general shim for the potential generic problem of LPK.DLL on Win XP & .NET Server.

 History:

    04/18/2002 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Office9ComplexScript)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTextCharacterExtra)
    APIHOOK_ENUM_ENTRY(ExtTextOutW)
APIHOOK_ENUM_END

CRITICAL_SECTION    g_CriticalSection;  // For multi thread safe
HDC                 g_hdc = NULL;       // Remember HDC used in SetTextCharacterExtra()
int                 g_nCharExtra = 0;   // Remember extra space value set in SetTextCharacterExtra()

/*++

 Remember HDC and extra space value.

--*/

int
APIHOOK(SetTextCharacterExtra)(HDC hdc, int nCharExtra)
{
    EnterCriticalSection(&g_CriticalSection);

    if (hdc != g_hdc)
    {
        g_hdc = hdc;                // Save hdc
    }
    g_nCharExtra = nCharExtra;      // Save nCharExtra

    LeaveCriticalSection(&g_CriticalSection);

    return (ORIGINAL_API(SetTextCharacterExtra)(hdc, nCharExtra));
}

/*++

 Function Description:
    
    Check if BiDi character is in the string.

 Arguments:

    IN lpString - Pointer to the string
    IN cbCount  - Length to check

 Return Value:

    TRUE if BiDi char exist or FALSE if not

 History:

    04/17/2002 hioh     Created

--*/

BOOL
IsBiDiString(
    LPCWSTR lpString,
    UINT    cbCount
    )
{
    while (0 < cbCount--)
    {
        // Check if character is in Hebrew or Arabic code range
        if ((0x0590 <= *lpString && *lpString <= 0x05ff) || (0x0600 <= *lpString && *lpString <= 0x06ff))
        {
            return TRUE;
        }
        lpString++;
    }
    return FALSE;
}

/*++

 Remove Extra Space when Complex Script.
 Revert Extra Space when removed and not Complex Script.

--*/

BOOL
APIHOOK(ExtTextOutW)(
    HDC hdc,
    int X,
    int Y,
    UINT fuOptions,
    CONST RECT* lprc,
    LPCWSTR lpString,
    UINT cbCount,
    CONST INT* lpDx
    )
{
    static HDC  s_hdc = NULL;
    static int  s_nCharExtra = 0;
    static BOOL s_bRemoveExtra = FALSE;

    // Do nothing for ETO_GLYPH_INDEX and ETO_IGNORELANGUAGE
    if (fuOptions & ETO_GLYPH_INDEX || fuOptions & ETO_IGNORELANGUAGE)
    {
        return (ORIGINAL_API(ExtTextOutW)(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx));
    }

    EnterCriticalSection(&g_CriticalSection);

    if (hdc == g_hdc && g_nCharExtra > 0 && hdc != s_hdc)
    {
        // New handling
        s_hdc = g_hdc;
        s_nCharExtra = g_nCharExtra;

        if (IsBiDiString(lpString, cbCount))
        {
            // Remove extra space
            ORIGINAL_API(SetTextCharacterExtra)(hdc, 0);
            s_bRemoveExtra = TRUE;
        }
        else
        {
            s_bRemoveExtra = FALSE;
        }
    }
    else if (hdc == s_hdc && s_nCharExtra > 0)
    {
        // Handled before
        if (IsBiDiString(lpString, cbCount))
        {
            // Remove extra space if not yet
            if (!s_bRemoveExtra)
            {
                ORIGINAL_API(SetTextCharacterExtra)(hdc, 0);
                s_bRemoveExtra = TRUE;
            }
        }
        else
        {
            // Revert extra space if removed
            if (s_bRemoveExtra)
            {
                ORIGINAL_API(SetTextCharacterExtra)(hdc, s_nCharExtra);
                s_bRemoveExtra = FALSE;
            }
        }
    }

    LeaveCriticalSection(&g_CriticalSection);

    return (ORIGINAL_API(ExtTextOutW)(hdc, X, Y, fuOptions, lprc, lpString, cbCount, lpDx));
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
       return (InitializeCriticalSectionAndSpinCount(&g_CriticalSection, 0x80000000));
    }
    
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(GDI32.DLL, SetTextCharacterExtra)
    APIHOOK_ENTRY(GDI32.DLL, ExtTextOutW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\officets.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    OfficeTS.cpp

 Abstract:

    Lie to office about GUI-Effects if on a TS machine.

 Notes:

    This is an app specific shim.

 History:

    08/07/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(OfficeTS)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SystemParametersInfoA) 
APIHOOK_ENUM_END

/*++

 After we call GetDlgItemTextA we convert the long path name to the short path name.

--*/

BOOL 
APIHOOK(SystemParametersInfoA)(
    UINT uiAction,  // system parameter to retrieve or set
    UINT uiParam,   // depends on action to be taken
    PVOID pvParam,  // depends on action to be taken
    UINT fWinIni    // user profile update option
    )
{
    BOOL bRet = ORIGINAL_API(SystemParametersInfoA)(uiAction, uiParam, pvParam, fWinIni);

    if (bRet && pvParam && (uiAction == SPI_GETUIEFFECTS) && GetSystemMetrics(SM_REMOTESESSION)) {
        *(BOOL *)pvParam = FALSE;
    }
    
    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SystemParametersInfoA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\omikron.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Omikron.cpp

 Abstract:

    Shims RegQueryValueExA so that when the app asks for the shell command
    for opening an rtffile, it gets what it expected to see under Win95: 
    "C:\WINDOWS\WORDPAD.EXE %1" This is, of course, wrong, but we then apply 
    CorrectFilePaths, so when it actually goes out to launch wordpad, it has 
    the right path.

    This is necessary because it can't have a path name with spaces in it

 Notes:

    This is specific to Omikron.

 History:

    3/27/2000 dmunsil  Created


--*/
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Omikron)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA) 
APIHOOK_ENUM_END

LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    LONG lReturn;

    // Remember the size of the dest buffer
    DWORD ccbData = lpcbData ? *lpcbData : 0;

    lReturn = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);

    if (lReturn != ERROR_SUCCESS)
    {
        return lReturn;
    }

    if (lpType && lpcbData && lpData && (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ))
    {
        CSTRING_TRY
        {
            LPSTR lpszData = (LPSTR)lpData;
            
            CString csData(lpszData);
            if (csData.Find(L"wordpad.exe \"%1\"") >= 0)
            {
                StringCbCopyA(lpszData, ccbData, "c:\\windows\\wordpad.exe \"%1\"");
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return lReturn;
}


HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA )

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\omnipagepro11uninstall.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    OmniPagePro11Uninstall.cpp

 Abstract:
 
    An OmniPagePro custom action returns an invalid error code.
    We cannot shim it directly, but we can shim the custom action,
    and then trap all calls to GetProcAddress() from MSIExec    

 Notes:

    This is specific to OmniPage Pro 11 Uninstaller

 History:

    5/14/2002 mikrause  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(OmniPagePro11Uninstall)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcAddress)
APIHOOK_ENUM_END

typedef UINT (WINAPI *_pfn_MsiCustomAction)(MSIHANDLE msiHandle);

_pfn_MsiCustomAction g_pfnOriginalULinkToPagis = NULL;

UINT CALLBACK
ULinkToPagisHook(
   MSIHANDLE msiHandle
   )
{
    UINT uiRet = g_pfnOriginalULinkToPagis(msiHandle);
    if (uiRet == (UINT)-1) {
        uiRet = 0;
    }

   return uiRet;
}

FARPROC
APIHOOK(GetProcAddress)(
    HMODULE hModule,    // handle to DLL module
    LPCSTR lpProcName   // function name
    )
{
    if ((HIWORD(lpProcName) != 0) && (lstrcmpA(lpProcName, "ULinkToPagis") == 0)) {
        g_pfnOriginalULinkToPagis = (_pfn_MsiCustomAction) GetProcAddress(hModule, lpProcName);
        if (g_pfnOriginalULinkToPagis) {
            return (FARPROC)ULinkToPagisHook;
        }
    }

    return ORIGINAL_API(GetProcAddress)(hModule, lpProcName);
}

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcAddress )
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\outlook2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Outlook2000.cpp

 Abstract:

    If Outlook2000 is calling to set the system date to Hebrew, while the 
    associated UserLocale is passed in the call as Arabic, the shim will 
    replace the UserLocale with DefaultUserLocale and let the call proceed;  
    this way Outlook2000 will be able to restore the date to Hebrew 
    (which was prevented by the passing of an Arabic UserLocale).

 Notes:

    This is an app specific shim.

 History:
 
    06/12/2001 geoffguo  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Outlook2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetLocaleInfoA)
APIHOOK_ENUM_END

/*++

 This hooks SetLocaleInfo.

--*/

BOOL
APIHOOK(SetLocaleInfoA)(
    LCID    Locale,
    LCTYPE  LCType,
    LPCSTR  lpLCData
    )
{
    LCID    lcid = Locale;
    LPCSTR  szCAL_HEBREW = "8";

    if (Locale == MAKELCID (LANG_ARABIC, SORT_DEFAULT) && lpLCData != NULL
        && lstrcmpA (lpLCData, szCAL_HEBREW) == 0) {
        lcid = LOCALE_USER_DEFAULT;
    }

    return SetLocaleInfoA(lcid, LCType, lpLCData);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, SetLocaleInfoA)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\outlook97.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Outlook97.cpp

 Abstract:

    Investigation by zekel.

    Outlook 97 has an untested code-path:

        where iIndex == -173 and hInstDll == hinstShell32
        ...
            else if (iIndex < 0)
            {
                pThis->m_nEnumWant = 0;
                pThis->EnumIconFunc(hInstDll, MAKEINTRESOURCE(-iIndex), &iepStuff);
            }

    which will always fault, i.e. since iIndex used to be positive, this always 
    worked. 

 Notes:

    This is an app specific shim.

 History:

    06/15/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Outlook97)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetFileInfoA) 
APIHOOK_ENUM_END

/*++

 Fix faulting case.

--*/

DWORD_PTR 
APIHOOK(SHGetFileInfoA)(
    LPCSTR pszPath, 
    DWORD dwFileAttributes, 
    SHFILEINFOA *psfi, 
    UINT cbFileInfo, 
    UINT uFlags
    )
{
    DWORD_PTR dwRet = ORIGINAL_API(SHGetFileInfoA)(pszPath, dwFileAttributes, 
        psfi, cbFileInfo, uFlags);

    if (dwRet && ((uFlags & (SHGFI_ICONLOCATION | SHGFI_PIDL)) == (SHGFI_ICONLOCATION | SHGFI_PIDL))) {
        //        
        //  Check to see if this is shell32, IDI_FAVORITES
        //  Outlook faults if we return a negative index here
        //
        if (psfi->iIcon == -173 && stristr(psfi->szDisplayName, "shell32")) {
            LOGN(eDbgLevelError, "Negative icon id detected - fixing");
            psfi->iIcon = 0;
            psfi->szDisplayName[0] = 0;
        }
    }

    return dwRet;
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, SHGetFileInfoA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\operationsmanager.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    OperationsManager.cpp

 Abstract:

    The setup for OperationsManager needs to have LoadLibraryCWD applied.
    However, the setups name is random, so we need to DeRandomizeExeName.
    But, DeRandomizeExe name calls MoveFileEx to set the file to be deleted
    upon reboot.  The setup program detects that there are pending file
    deletions, interprets them as an aborted install, and recommends that
    the user stop installation.

    This shim will shim RegQueryValueExA, watch for the 
    "PendingFileRenameOperations" key, and remove any of our de-randomized exes 
    from the return string.

 Notes:

    This is an app-specific shim.

 History:

    05/07/2002 astritz  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(OperationsManager)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
APIHOOK_ENUM_END

/*++

 Remove any of our de-randomized exe names from the PendingFileRenameOperations key.

--*/

LONG
APIHOOK(RegQueryValueExA)(
    HKEY hKey,            // handle to key
    LPCSTR lpValueName,   // value name
    LPDWORD lpReserved,   // reserved
    LPDWORD lpType,       // type buffer
    LPBYTE lpData,        // data buffer
    LPDWORD lpcbData      // size of data buffer
    )
{
    CHAR *pchBuff = NULL;

    LONG lRet = ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName, lpReserved, 
        lpType, lpData, lpcbData);

    if (ERROR_SUCCESS == lRet) {
        if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_NEUTRAL), 
            SORT_DEFAULT), NORM_IGNORECASE, lpValueName, -1, 
            "PendingFileRenameOperations", -1) == CSTR_EQUAL) {
            //
            // Since we're only removing strings from the original data, a buffer
            // of the original's size will suffice, and we won't overflow it.
            //

            CHAR *pchSrc = (CHAR *) lpData;
    
            pchBuff = new CHAR [*lpcbData];
            if (NULL != pchBuff) {
                CHAR *pchDest = pchBuff;

                //
                // We want to loop through ALL the data in case there is more than
                // one instance of our de-randomized name in the data.
                //
                while (pchSrc <= (CHAR *)lpData + *lpcbData) {
                    if (*pchSrc == NULL) {
                        break;
                    }

                    CString csSrc(pchSrc);
                    CString csFile;

                    csSrc.GetLastPathComponent(csFile);

                    if (csFile.CompareNoCase(L"MOM_SETUP_DERANDOMIZED.EXE") == 0) {
                        // Skip this Src File.
                        pchSrc += strlen(pchSrc) + 1;
                        if (pchSrc > (CHAR *)lpData + *lpcbData) {
                            goto Exit;
                        }

                        // Skip the Dest file as well (probably an empty string)
                        pchSrc += strlen(pchSrc) + 1;

                    } else {
                        
                        // Copy the src file.
                        if (FAILED(StringCchCopyExA(pchDest, 
                            *lpcbData - (pchDest - pchBuff), pchSrc, 
                            &pchDest, NULL, 0))) {
                            goto Exit;
                        }
                        pchSrc += strlen(pchSrc) + 1;
                        if (pchSrc > (CHAR *)lpData + *lpcbData) {
                            goto Exit;
                        }

                        // Copy the dest file.
                        if (FAILED(StringCchCopyExA(pchDest, 
                            *lpcbData - (pchDest - pchBuff), pchSrc, &pchDest, 
                            NULL, 0))) {
                            goto Exit;
                        }

                        pchSrc += strlen(pchSrc) + 1;
                    }
                }

                // Add the extra NULL to terminate the list of strings.
                *pchDest++ = NULL;

                // Copy our buffer to the returned buffer.
                memcpy(lpData, pchBuff, pchDest - pchBuff);
                *lpcbData = pchDest - pchBuff;
            }
        }
    }

Exit:
    if (NULL != pchBuff) {
        delete [] pchBuff;
    }

    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\omnipagepro.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    OmniPagePro.cpp

 Abstract:

    Shims ShellExecuteExA.  If the user double clicks on an image in the right 
    pane, the app will read the progID key in the registry for .BMP files 
    (HKCR, Paint.Picture\shell\open\command, "(Default)"). Previously, that 
    data had: "C:\winnt\system32\mspaint.exe" "%1". In Whistler, that changed 
    to: rundll32.exe C:\WINNT\System32\shimgvw.dll,ImageView_Fullscreen %1.
    
    The problem with Carea OmniPage Pro v10 is that on the double click, they 
    will read the regkey, remove the %1, pass the rest of the string to 
    ShellExecuteExA() lpFile.  They will put the filename into lpParameters.  
    The problem is that with the new path, "rundll32.exe" needs to be in lpFile 
    and "C:\WINNT\System32\shimgvw.dll,ImageView_Fullscreen <FileToOpen>" needs 
    to be in lpParameters.

 Notes:

    This is specific to OmniPage Pro.

 History:

    2/12/2000 bryanst  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(OmniPage)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteExA) 
APIHOOK_ENUM_END

BOOL
APIHOOK(ShellExecuteExA)(
    LPSHELLEXECUTEINFOA lpExecInfo
    )
{
    CSTRING_TRY
    {
        CString csFile(lpExecInfo->lpFile);
        int nIndexGVW       = csFile.Find(L"shimgvw.dll,");
        int nIndexRundll    = csFile.Find(L"rundll32.exe");
        int nIndexSpace     = csFile.Find(L" ");

        if (nIndexGVW    != -1 &&
            nIndexRundll != -1 &&
            nIndexSpace  >=  1)
        {
            CString csParam;
            csFile.Mid(nIndexSpace + 1, csParam);   // everything after the space
            csFile.Delete(nIndexSpace, csFile.GetLength() - nIndexSpace); // Delete the space and everything after

            csParam += " ";
            csParam += lpExecInfo->lpParameters;

            lpExecInfo->lpFile       = csFile.GetAnsi();
            lpExecInfo->lpParameters = csParam.GetAnsi();
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
}


HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteExA )
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\outlook98wizard.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Outlook98Wizard.cpp

 Abstract:

    This DLL hooks VerQueryValue, and will return English Language information
    for Japanese outlook 98 setup file.

 Notes:

    This is an app specific shim.

 History:

    01/21/2002 v-rbabu  Created

--*/

#include "precomp.h"
#include "string.h"

IMPLEMENT_SHIM_BEGIN(Outlook98Wizard)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(VerQueryValueA)
APIHOOK_ENUM_END

/*++

 The actual problem is, the outlook 98 setup is comparing the language 
 informations of the Shell32.dll and the setup file (outlwzd.exe). But 
 according to the bug scenario, the system is having English OS and Japanese 
 Locale. So, Shell32.dll have English language as its language. So, this 
 differs with the Language informaiton of Japanese Outlook setuip file.

 So, setup thorows an error that the Language of the outlook 98 going to be 
 installed differs with the system language.

 This stub function lie about the language information of the outlook setup 
 file. Though the setup file is Japanese as language informaiton, this shim 
 returns as if it is English.

--*/

BOOL
APIHOOK(VerQueryValueA)(
    const LPVOID pBlock,
    LPSTR lpSubBlock,
    LPVOID *lplpBuffer,
    PUINT puLen
    )
{
    BOOL bRet = ORIGINAL_API(VerQueryValueA)(pBlock, lpSubBlock, lplpBuffer, puLen);
    
    if (bRet) {
        CSTRING_TRY
        {
            //
            // If trying to get the \VarFileInfo\Translation, then assign English
            // Language information to the output buffer.
            //
            CString csSubBlockString(lpSubBlock);

            if (lplpBuffer && (csSubBlockString.Find(L"\\VarFileInfo\\Translation") != -1)) {
                // Adjust the version info
                LOGN(eDbgLevelInfo, "[VerQueryValueA] Return modified version info");
                *lplpBuffer = L"03a40409";  
            }
        }
        CSTRING_CATCH
        {
            // Do nothing
        }
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(VERSION.DLL, VerQueryValueA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\overlaypro.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    OverlayPro.cpp

 Abstract:

    This shim changes the return value of RegOpenKeyA from ERROR_SUCCESS
    to ERROR_FILE_NOT_FOUND if the key is "System\CurrentControlSet\Control\Print\Printers"
    
    No idea why this is needed but it seems to make the app work. Probably
    something else is the cause the app behaves differently but no one investigated
    more into the app's code to figure it out.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(OverlayPro)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegOpenKeyA) 
APIHOOK_ENUM_END


/*++

 Change the return value of RegOpenKeyA from 0 to 2 if the key is 
 "System\CurrentControlSet\Control\Print\Printers"

--*/

LONG
APIHOOK(RegOpenKeyA)(
    HKEY   hKey,
    LPSTR  lpSubKey,
    PHKEY  phkResult
    )

{
    LONG lRet;

    //
    // Call the original API
    //
    lRet = ORIGINAL_API(RegOpenKeyA)(hKey, lpSubKey, phkResult);
    
    if (lRet == 0) {
        
        if (CompareStringA(MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_NEUTRAL),SORT_DEFAULT),
                          NORM_IGNORECASE, lpSubKey, -1,
                          "System\\CurrentControlSet\\Control\\Print\\Printers",-1) == CSTR_EQUAL) {
            DPFN(
                eDbgLevelInfo,
                "OverlayPro.dll, Changing RegOpenKeyA's "
                "return from ERROR_SUCCESS to ERROR_FILE_NOT_FOUND.\n");
            lRet = 2;
        }
    }
    
    return lRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\patrol.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Patrol.cpp

 Abstract:

    Kill USER32!PostQuitMessage to prevent the control panel applet from taking 
    out explorer.

 Notes:

    This is an app specific shim.

 History:

    20/06/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Patrol)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PostQuitMessage) 
APIHOOK_ENUM_END

/*++

 Kill this API

--*/

VOID
APIHOOK(PostQuitMessage)(
    int nExitCode
    )
{
    LOGN(eDbgLevelError, "[PostQuitMessage] Ignoring quit message");
    return;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, PostQuitMessage)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\pirch98.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Pirch98.cpp

 Abstract:

   Remove the HWND_TOPMOST property on all their windows

 Notes:

    This is an app specific shim.

 History:

    04/23/2001  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Pirch98)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetWindowPos) 
APIHOOK_ENUM_END


/*++

   Remove the HWND_TOPMOST property on all their windows

--*/

BOOL
APIHOOK(SetWindowPos)(
  HWND hWnd,             // handle to window
  HWND hWndInsertAfter,  // placement-order handle
  int X,                 // horizontal position
  int Y,                 // vertical position
  int cx,                // width
  int cy,                // height
  UINT uFlags            // window-positioning options
)
{
    if (hWndInsertAfter == HWND_TOPMOST)
    {
        hWndInsertAfter = HWND_TOP;
        LOGN(eDbgLevelError, "[SetWindowPos] Replacing HWND_TOPMOST with HWND_TOP\n");
    }

    return ORIGINAL_API(SetWindowPos)(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SetWindowPos)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\panzercommander.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PanzerCommander.cpp

 Abstract:

    Panzer Commander launches its readme.txt file with Notepad.exe. 
    Unfortunately, on the readme file is > 64K so Win9x Notepad will open the 
    file with write.exe.  On Win2000, notepad will open the file just fine, 
    however the problem is that readme.txt should actually be readme.doc.

    We change %windir%\notepad.exe with %windir%\write.exe

 Notes:

    This is an app specific shim.

 History:

    12/12/2000  robkenny    Created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PanzerCommander)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

 They use notepad to open a text file that is really a DOC file. Convert 
 notepad.exe to write.exe

--*/

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,                 
    LPSTR lpCommandLine,                      
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL bInheritHandles,                     
    DWORD dwCreationFlags,                    
    LPVOID lpEnvironment,                     
    LPCSTR lpCurrentDirectory,                
    LPSTARTUPINFOA lpStartupInfo,             
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CSTRING_TRY
    {
        AppAndCommandLine acl(lpApplicationName, lpCommandLine);

        CString csAppName(acl.GetApplicationName());
        CString csCL(acl.GetCommandlineNoAppName());

        BOOL bChangedApp = FALSE;

        // If the application is notepad, change it to write
        if (!csAppName.CompareNoCase(L"notepad.exe") == 0)
        {
            csAppName = L"%windir%\\system32\\write.exe";
            csAppName.ExpandEnvironmentStringsW();

            bChangedApp = TRUE;
        }

        char * lpcl = csCL.GetAnsi();
        
        UINT uiReturn = ORIGINAL_API(CreateProcessA)(
            csAppName.GetAnsiNIE(),                 
            lpcl,
            lpProcessAttributes,
            lpThreadAttributes, 
            bInheritHandles,                     
            dwCreationFlags,                    
            lpEnvironment,                     
            lpCurrentDirectory,                
            lpStartupInfo,             
            lpProcessInformation);
        
        if (bChangedApp)
        {
            DPFN(
                eDbgLevelInfo,
                "PanzerCommander, corrected command line:\n(%s)\n(%s)\n",
                lpCommandLine, lpcl);
        }

        return uiReturn;
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    UINT uiReturn = ORIGINAL_API(CreateProcessA)(
        lpApplicationName,                 
        lpCommandLine,                      
        lpProcessAttributes,
        lpThreadAttributes, 
        bInheritHandles,                     
        dwCreationFlags,                    
        lpEnvironment,                     
        lpCurrentDirectory,                
        lpStartupInfo,             
        lpProcessInformation);

    return uiReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\planecrazy.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PlaneCrazy.cpp

 Abstract:

    Hooks all application-defined window procedures and adds a WM_PAINT 
    message upon receipt of a WM_SETFOCUS. For some reason the one that normally
    came through on win9x gets lost.

 Notes:

    This shim can be reused for other shims that require WindowProc hooking.
    Copy all APIHook_* functions and simply replace the code in PlaneCrazy_WindowProcHook
    and PlaneCrazy_DialogProcHook.

 History:

    11/01/1999 markder  Created
    02/15/1999 markder  Reworked WndProc hooking mechanism so that it generically
                        hooks all WndProcs for the process.
    02/15/1999 a-chcoff copied to here and created this shim with code base.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PlaneCrazy)
#include "ShimHookMacro.h"


APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassA)
    APIHOOK_ENUM_ENTRY(RegisterClassW)
    APIHOOK_ENUM_ENTRY(RegisterClassExA)
    APIHOOK_ENUM_ENTRY(RegisterClassExW)
    APIHOOK_ENUM_ENTRY(CreateDialogParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogParamW)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA)
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamW)    
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamAorW)
    APIHOOK_ENUM_ENTRY(SetWindowLongA)
    APIHOOK_ENUM_ENTRY(SetWindowLongW)
APIHOOK_ENUM_END

/*++

 Change WM_DRAWITEM behaviour

--*/

LRESULT CALLBACK 
PlaneCrazy_WindowProcHook(
    WNDPROC pfnOld, // address of old WindowProc
    HWND hwnd,      // handle to window
    UINT uMsg,      // message identifier
    WPARAM wParam,  // first message parameter
    LPARAM lParam   // second message parameter
    )
{
    // Check for message we're interested in
    if (uMsg == WM_SETFOCUS)
    {
        SendMessage(hwnd,WM_PAINT,NULL,NULL);
           
    }

    return (*pfnOld)(hwnd, uMsg, wParam, lParam);    
}

INT_PTR CALLBACK 
PlaneCrazy_DialogProcHook(
  DLGPROC   pfnOld,   // address of old DialogProc
  HWND      hwndDlg,  // handle to dialog box
  UINT      uMsg,     // message
  WPARAM    wParam,   // first message parameter
  LPARAM    lParam    // second message parameter
)
{
    // Check for message we're interested in
    if (uMsg == WM_SETFOCUS)
    {
        SendMessage(hwndDlg,WM_PAINT,NULL,NULL);

    }

    return (*pfnOld)(hwndDlg, uMsg, wParam, lParam);    
}





/*++

 Hook all possible calls that can initialize or change a window's
 WindowProc (or DialogProc)

--*/

ATOM
APIHOOK(RegisterClassA)(
    CONST WNDCLASSA *lpWndClass  // class data
)
{
    WNDCLASSA   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassW)(
    CONST WNDCLASSW *lpWndClass  // class data
)
{
    WNDCLASSW   wcNewWndClass   = *lpWndClass;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpWndClass->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassW)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
)
{
    WNDCLASSEXA   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassExA)(&wcNewWndClass);
}

ATOM
APIHOOK(RegisterClassExW)(
    CONST WNDCLASSEXW *lpwcx  // class data
)
{
    WNDCLASSEXW   wcNewWndClass   = *lpwcx;

    wcNewWndClass.lpfnWndProc = (WNDPROC) HookCallback(lpwcx->lpfnWndProc, PlaneCrazy_WindowProcHook);

    return ORIGINAL_API(RegisterClassExW)(&wcNewWndClass);
}

HWND
APIHOOK(CreateDialogParamA)(
    HINSTANCE hInstance,     // handle to module
    LPCSTR lpTemplateName,   // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogParamA)(  hInstance,
                                                lpTemplateName,
                                                hWndParent,
                                                lpDialogFunc,
                                                dwInitParam     );
}

HWND
APIHOOK(CreateDialogParamW)(
    HINSTANCE hInstance,     // handle to module
    LPCWSTR lpTemplateName,  // dialog box template
    HWND hWndParent,         // handle to owner window
    DLGPROC lpDialogFunc,    // dialog box procedure
    LPARAM dwInitParam       // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogParamW)(  hInstance,
                                                lpTemplateName,
                                                hWndParent,
                                                lpDialogFunc,
                                                dwInitParam     );
}

HWND
APIHOOK(CreateDialogIndirectParamA)(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogIndirectParamA)(  hInstance,
                                                        lpTemplate,
                                                        hWndParent,
                                                        lpDialogFunc,
                                                        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamW)(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogIndirectParamW)(  hInstance,
                                                        lpTemplate,
                                                        hWndParent,
                                                        lpDialogFunc,
                                                        lParamInit     );
}

HWND
APIHOOK(CreateDialogIndirectParamAorW)(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
)
{
    lpDialogFunc = (DLGPROC) HookCallback(lpDialogFunc, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(CreateDialogIndirectParamAorW)(  hInstance,
                                                           lpTemplate,
                                                           hWndParent,
                                                           lpDialogFunc,
                                                           lParamInit     );
}

LONG 
APIHOOK(SetWindowLongA)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(  hWnd,
                                            nIndex,
                                            dwNewLong );
}

LONG 
APIHOOK(SetWindowLongW)(
    HWND hWnd,
    int nIndex,           
    LONG dwNewLong    
    )
{
    if( nIndex == GWL_WNDPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_WindowProcHook);
    else if( nIndex == DWL_DLGPROC )
        dwNewLong = (LONG) HookCallback((PVOID)dwNewLong, PlaneCrazy_DialogProcHook);

    return ORIGINAL_API(SetWindowLongA)(  hWnd,
                                            nIndex,
                                            dwNewLong );
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassW)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamW)
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamAorW)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongW)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\pickyeater.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    PickyEater.cpp

 Abstract:

    The application AVs during startup.
    
    When the app receives a WM_PALETTECHANGED message,
    it should compare the wParam and the hWnd. If they
    match, it should not handle the message. If they don't,
    it should.

 Notes:

    This is an app specific shim.

 History:

    01/04/2001  rparsons    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PickyEater)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
APIHOOK_ENUM_END

/*++

  Eat the WM_PALETTECHANGED if the hWnd is NULL

--*/

BOOL
APIHOOK(SendMessageA)(
        HWND hWnd,
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam
        )
{
    if ((hWnd == NULL) && (uMsg == WM_PALETTECHANGED))
    {
        return TRUE;
    }

    return FALSE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SendMessageA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\postit2.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    PostIt2.cpp

 Abstract:

    This shim eliminates an infinite loop in 3M's Post-It Notes application
    by preventing the WM_TIMECHANGE message from reaching the Post-It
    Notes windows when the application triggers a time change using
    SetTimeZoneInformation().
 
 Notes:

    This is an application specific shim.

 History:

    06/04/2001  tonyschr    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PostIt2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTimeZoneInformation)
    APIHOOK_ENUM_ENTRY(CallWindowProcA)
APIHOOK_ENUM_END


static SYSTEMTIME g_localtime = { 0 };


BOOL
APIHOOK(SetTimeZoneInformation)(
          CONST TIME_ZONE_INFORMATION *lpTimeZoneInformation
)
{
    BOOL fReturn = ORIGINAL_API(SetTimeZoneInformation)(lpTimeZoneInformation);

    // Store off local time after this application requests timezone change.
    GetLocalTime(&g_localtime);

    return fReturn;
}


LRESULT
APIHOOK(CallWindowProcA)(
          WNDPROC pfn,
          HWND    hwnd,
          UINT    message,
          WPARAM  wParam,
          LPARAM  lParam)
{
    // Detect whether the WM_TIMECHANGE message was triggered by the app calling
    // SetTimeZoneInformation() or an external timechange by comparing the local
    // time.
    if (message == WM_TIMECHANGE)
    {
        SYSTEMTIME newtime;
        GetLocalTime(&newtime);
        
        if (newtime.wYear         == g_localtime.wYear      &&
            newtime.wMonth        == g_localtime.wMonth     &&
            newtime.wDayOfWeek    == g_localtime.wDayOfWeek &&
            newtime.wDay          == g_localtime.wDay       &&
            newtime.wHour         == g_localtime.wHour      &&
            newtime.wMinute       == g_localtime.wMinute    &&
            newtime.wSecond       == g_localtime.wSecond    &&
            newtime.wMilliseconds == g_localtime.wMilliseconds)
        {
            // Looks like this WM_TIMECHANGE was sent in response to the app
            // calling SetTimeZoneInformation(), so block it.
            // Note: Because of the asynchronous nature of window messages this
            // might let an occasional WM_TIMECHANGE slip through, but it should
            // always terminiate the infinite loop.
            return 0;
        }
    }
    
    return ORIGINAL_API(CallWindowProcA)(pfn, hwnd, message, wParam, lParam);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, SetTimeZoneInformation)
    APIHOOK_ENTRY(USER32.DLL, CallWindowProcA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\petz.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   PetzForceCritSecRelease.cpp

 Abstract:

   This DLL takes care of a Thread that is exiting without performing a
   LeaveCriticalSection on a critical section it owns. 

 Notes:

   This is a application specific shim.

 History:

   04/00/2000 a-chcoff  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Petz)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(_endthread) 
    APIHOOK_ENUM_ENTRY(ShellExecuteA) 
APIHOOK_ENUM_END

LPCRITICAL_SECTION g_pCritSectToRelease;

HINSTANCE 
APIHOOK(ShellExecuteA)(                  
    HWND hwnd,              
    LPCSTR lpVerb,          
    LPCSTR lpFile, 
    LPCSTR lpParameters, 
    LPCSTR lpDirectory,
    INT nShowCmd)
{
    CSTRING_TRY
    {
        CString csFile(lpFile);
        csFile.Replace(L"SYSTEM\\PETZ", L"SYSTEM32\\PETZ");

        return ORIGINAL_API(ShellExecuteA)(
                hwnd,
                lpVerb,      
                csFile.GetAnsi(),      
                lpParameters,
                lpDirectory, 
                nShowCmd);         
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(ShellExecuteA)(
            hwnd,
            lpVerb,      
            lpFile,      
            lpParameters,
            lpDirectory, 
            nShowCmd);         
}
                                    
VOID
APIHOOK(_endthread)(void) 
{
    //Don't let the thread orphan a critical section.
    LeaveCriticalSection(g_pCritSectToRelease);
    ORIGINAL_API(_endthread)();
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            CString csCl(COMMAND_LINE);

            WCHAR *unused;
            g_pCritSectToRelease = (LPCRITICAL_SECTION) wcstol(csCl, &unused, 10);
        }
        CSTRING_CATCH
        {
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    APIHOOK_ENTRY(MSVCRT.DLL, _endthread)
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\powerbuilder.cpp ===
/*

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   PowerBuilder.cpp

 Abstract:

    This fixes a profiles bug in PowerBuilder where it adds reg keys to HKCU
    which point to various paths in the install location, essentially by adding
    User ODBC datasources, which should've been System ODBC datasources, hence
    installed under HKLM. 
    This shim recreates the registry values expected in HKCU for other users:

    HKCU\Software\ODBC\ODBC.INI\ODBC Data Sources\Powersoft Demo DB V6 =
        "Sybase SQL Anywhere 5.0"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\DataBaseFile =
        "<install1>\demodb\psDemoDB.db"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\DataBaseName = "psDemoDB"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\Driver =
        "<install2>\WOD50T.DLL"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\PWD = "sql"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\Start =
        "<install2>\dbeng50.exe -d -c512"
    HKCU\Software\ODBC\ODBC.INI\Powersoft Demo DB V6\UID = "dba"

    where <install1> is location of PowerBuilder Install:
    The value of <install1> and <install2> can be found in
    HKLM\Software\Microsoft\Windows\CurrentVersion\App Paths\PB60.EXE\Path =
        "<install1>;...;...;<install2>;"

 History:

    03/29/2001  bklamik    Created
*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(PowerBuilder)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
APIHOOK_ENUM_END

void FixupPowerBuilder()
{
    DWORD dwPresent = REG_OPENED_EXISTING_KEY;
    HKEY hODBC;
    if( ERROR_SUCCESS == RegCreateKeyExW( HKEY_CURRENT_USER,
        L"SOFTWARE\\ODBC\\ODBC.INI\\ODBC Data Sources",
        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hODBC, &dwPresent ) )
    {
        WCHAR c;
        DWORD dwLen = 0;
        DWORD dwType;

        if( REG_CREATED_NEW_KEY == dwPresent ||
            ERROR_MORE_DATA != RegQueryValueExW( hODBC,
                L"Powersoft Demo DB V6", 0, &dwType, 
                (BYTE*)&c, &dwLen ) )
        {
            const WCHAR szVal9[] = L"Sybase SQL Anywhere 5.0";

            RegSetValueExW( hODBC, L"Powersoft Demo DB V6",
                0, REG_SZ, (const BYTE*)szVal9, sizeof(szVal9) );

            // Find <install1> and <install2>
            HKEY hAppPath;
            if( ERROR_SUCCESS == RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\PB60.EXE",
                0, KEY_READ, &hAppPath ) )
            {
                WCHAR szValue[ 4 * (MAX_PATH + 1) ] = L"";
                DWORD dwSize = sizeof( szValue );

                if( ERROR_SUCCESS == RegQueryValueExW( hAppPath, L"path", NULL,
                    &dwType, (LPBYTE)szValue, &dwSize ) )
                {
                    const WCHAR* szInstall1 = szValue;
                    const WCHAR* szInstall2;

                    WCHAR* pFindSemi = szValue;

                    INT iSemis( 4 );
                    do
                    {
                        while( *pFindSemi != ';' && *pFindSemi != 0 )
                        {
                            ++pFindSemi;
                        }
                        *pFindSemi = 0;
                        ++pFindSemi;

                        if( 2 == iSemis )
                        {
                            szInstall2 = pFindSemi;
                        }
                    } while( --iSemis != 0 );

                    HKEY hDemoDB;
                    dwPresent = REG_OPENED_EXISTING_KEY;
                    if( ERROR_SUCCESS == RegCreateKeyExW( HKEY_CURRENT_USER,
                        L"SOFTWARE\\ODBC\\ODBC.INI\\Powersoft Demo DB V6",
                        0, NULL, 0, KEY_WRITE, NULL, &hDemoDB, &dwPresent ) )
                    {
                        if( REG_CREATED_NEW_KEY == dwPresent )
                        {

                            const WCHAR szVal0[] = L"psDemoDB";
                            const WCHAR szVal1[] = L"sql";
                            const WCHAR szVal2[] = L"dba";

                            RegSetValueExW( hDemoDB, L"DataBaseName",
                                0, REG_SZ, (const BYTE*)szVal0, sizeof(szVal0) );
                            RegSetValueExW( hDemoDB, L"PWD",
                                0, REG_SZ, (const BYTE*)szVal1, sizeof(szVal1) );
                            RegSetValueExW( hDemoDB, L"UID",
                                0, REG_SZ, (const BYTE*)szVal2, sizeof(szVal2) );

                            WCHAR szTemp[ MAX_PATH + 1 ];
                            StringCchCopyW(szTemp, MAX_PATH+1, szInstall1 );
                            StringCchCatW(szTemp,  MAX_PATH+1, L"\\demodb\\psDemoDB.db" );
                            RegSetValueExW( hDemoDB, L"DataBaseFile",
                                0, REG_SZ, (const BYTE*)szTemp,
                                (lstrlen( szTemp ) + 1) * sizeof(WCHAR) );

                            StringCchCopyW(szTemp, MAX_PATH+1, szInstall2 );
                            StringCchCatW(szTemp,  MAX_PATH+1, L"\\WOD50T.DLL" );
                            RegSetValueExW( hDemoDB, L"Driver",
                                0, REG_SZ, (const BYTE*)szTemp,
                                (lstrlen( szTemp ) + 1) * sizeof(WCHAR) );

                            StringCchCopyW(szTemp, MAX_PATH+1, szInstall2 );
                            StringCchCatW(szTemp,  MAX_PATH+1,  L"\\dbeng50.exe -d -c512" );
                            RegSetValueExW( hDemoDB, L"Start",
                                0, REG_SZ, (const BYTE*)szTemp,
                                (lstrlen( szTemp ) + 1) * sizeof(WCHAR) );
                        }

                        RegCloseKey( hDemoDB );
                    }
                }

                RegCloseKey( hAppPath );
            }

        }

        RegCloseKey( hODBC );
    }
}

LONG
APIHOOK(RegQueryValueExA)(HKEY hKey, LPCSTR lpValueName, 
                          LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, 
                          LPDWORD lpcbData )
{
    FixupPowerBuilder();
    return ORIGINAL_API(RegQueryValueExA)(hKey, lpValueName,
                                            lpReserved, lpType, lpData, lpcbData);
}


LONG
APIHOOK(RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, 
                          LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, 
                          LPDWORD lpcbData )
{
    FixupPowerBuilder();
    return ORIGINAL_API(RegQueryValueExW)(hKey, lpValueName,
                                            lpReserved, lpType, lpData, lpcbData);
}



BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        OSVERSIONINFOEX osvi = {0};
        
        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        
        if (GetVersionEx((OSVERSIONINFO*)&osvi)) {
            
            if (!((VER_SUITE_TERMINAL & osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & osvi.wSuiteMask))) {
                //
                // Only install hooks if we are not on a "Terminal Server"
                // (aka "Application Server") machine.
                //
                APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
                APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)
            }
        }
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ppo3svrscr.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   Ppo3svrScr.cpp

 Abstract:

   Power Plus screensaver bundled with Lotus Super Office 2000 Japanese could not launch
   Configure dialog on Whistler. But it works on Win 2000.
   The desk.cpl behavior of launching screensaver is changed a bit on Whistler.
   This screensaver's ScreenSaverConfigureDialog ID is not DLG_SCRNSAVECONFIGURE (2003=MSDN must) and unusual.
   Assuming unusual screensaver.
   This shim is applied to screensaver and hacks GetCommandLineW/A return text to change from
      "D:\WINDOWS\System32\ppo3svr.scr /c:1769646"
   to
      "D:\WINDOWS\System32\ppo3svr.scr"
   so that configure dialog appears.

   More Info:

      From desk.cpl (rundll32.exe), Screen Saver operation and CreateProcessW lpCommandLine argument:
      (1) Initial selection of screensaver
         "D:\WINDOWS\System32\ppo3svr.scr /p 721330" -> preview only
      (2) Preview button
         1st call "D:\WINDOWS\System32\ppo3svr.scr /s" -> screen saver
         2nd call "D:\WINDOWS\System32\ppo3svr.scr /p 721330" -> return to preview
      (3) Settings button
         1st call "D:\WINDOWS\System32\ppo3svr.scr /c:1769646" -> configure dialog (not working)
         2nd call "D:\WINDOWS\System32\ppo3svr.scr /p 721330" ->  return to preview

 History:

    06/11/2001  hioh        Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Ppo3svrScr)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
APIHOOK_ENUM_END

/*++

 Cut the /c:... string in CommandLine for ppo3svr.scr.
 
--*/

LPWSTR APIHOOK(GetCommandLineW)()
{
    WCHAR   szScreenSaverConfigure[] = L"ppo3svr.scr /c:";
    WCHAR   szConfigure[] = L" /c:";
    LPWSTR  lpCommandLine = ORIGINAL_API(GetCommandLineW)();
    LPWSTR  pw = wcsstr(lpCommandLine, szScreenSaverConfigure);

    if (pw != NULL)
    {
        pw = wcsstr(pw, szConfigure);
        if (pw)
        {
            *pw = 0;    // cut from " /c:"
        }
    }

    return (lpCommandLine);
}

LPSTR APIHOOK(GetCommandLineA)()
{
    CHAR   szScreenSaverConfigure[] = "ppo3svr.scr /c:";
    CHAR   szConfigure[] = " /c:";
    LPSTR  lpCommandLine = ORIGINAL_API(GetCommandLineA)();
    LPSTR  pc = strstr(lpCommandLine, szScreenSaverConfigure);

    if (pc != NULL)
    {
        pc = strstr(pc, szConfigure);
        if (pc)
        {
            *pc = 0;    // cut from " /c:"
        }
    }

    return (lpCommandLine);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\precomp.h ===
#ifndef _APPSPECIFIC_PRECOMP_H_
#define _APPSPECIFIC_PRECOMP_H_

#include "ShimHook.h"
#include "StrSafe.h"

using namespace ShimLib;

#endif // _APPSPECIFIC_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\quicken2000.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Quicken2000.cpp

 Abstract:

    Change the value of a registry key for Quicken 2000 setup.
    This is needed to disable a kernel mode driver that
    blue-screens in Win2k.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Quicken2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegSetValueExA) 
APIHOOK_ENUM_END

/*++

 Change the value passed for "Start" from 0 to 4 to prevent a kernel mode 
 driver from blue-screening Win2k.

--*/

LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,
    LPCSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    if (lstrcmpA(lpValueName, "Start") == 0 &&
        dwType == REG_DWORD &&
        cbData == 4) {

        DPFN( eDbgLevelInfo, "[Quicken2000] RegSetValueExA changed to 4");
        
        *(DWORD*)lpData = 4;
    }

    /*
     * Call the original API
     */
    
    return ORIGINAL_API(RegSetValueExA)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\printmaster4.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    PrintMaster4.cpp

 Abstract:

    Force mfcans32.dll to not have the read-only bit. Many HP systems shipped 
    with this turned on as a kind of lightweight SFP. However, the unpleasant 
    consequence is that PrintMaster doesn't install.

 Notes:

    This is an app specific shim.

 History:

    02/20/2002 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(PrintMaster4)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Run Notify function only 

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CSTRING_TRY
        {
            CString csFileName;
            csFileName.GetSystemDirectory();
            csFileName += L"\\mfcans32.dll";

            DWORD dwAttr = GetFileAttributesW(csFileName);

            // Remove the read-only 
            if (dwAttr != 0xffffffff) {
                SetFileAttributesW(csFileName, dwAttr & ~FILE_ATTRIBUTE_READONLY);
            }
        }
        CSTRING_CATCH 
        {
            // Don't care about exception
        }
    }
    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\quicken2001.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Quicken2001.cpp

 Abstract:
    The app was passing bad string pointers to the
    lstrcmpiA() function which was causing it to crash
    during the app update.

 Notes:

    This is an app specific shim.

 History:

    05/09/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Quicken2001)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lstrcmpiA) 
APIHOOK_ENUM_END

/*++

    Checks the parameters for invalid string pointers.

--*/

LONG
APIHOOK(lstrcmpiA)(
    LPCSTR lpString1,
    LPCSTR lpString2
    )
{

    if (IsBadStringPtrA(lpString1, MAX_PATH))
    {
        lpString1 = 0;
    }

    if (IsBadStringPtrA(lpString2, MAX_PATH))
    {
        lpString2 = 0;
    }

    /*
     * Call the original API
     */   
    return ORIGINAL_API(lstrcmpiA)(lpString1, lpString2);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, lstrcmpiA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\proatlas2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   ProAtlas2000.cpp

 Abstract:

   This application has an uninstallation program, PAtls2kUninst.exe. The uninstallation
   program will generate a temp file DEL??.TMP in %temp% dircetory. It will call
   CreateProcessA to start the DEL??.TMP. The DEL??.TMP will wait for the end of
   PAtls2kUninst.exe. Due to the quick return of CreateProcessA call, the
   PAtls2kUninst.exe ends before DEL??.TMP starts to wait. The DEL??.TMP quits because
   it cannot find PAtls2kUninst.exe. The uninstallation cannot be completed. This fix is to
   hook CreateProcessA to delay the return of the function for 3 seconds.
   
 History:

    04/09/2001  zhongyl     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ProAtlas2000)
#include "ShimHookMacro.h"

//
// Add APIs that you wish to hook to this macro construction.
//
APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


BOOL
APIHOOK(CreateProcessA)(
    LPSTR lpszImageName, 
    LPSTR lpszCmdLine, 
    LPSECURITY_ATTRIBUTES lpsaProcess, 
    LPSECURITY_ATTRIBUTES lpsaThread, 
    BOOL fInheritHandles, 
    DWORD fdwCreate, 
    LPVOID lpvEnvironment, 
    LPSTR lpszCurDir, 
    LPSTARTUPINFOA lpsiStartInfo, 
    LPPROCESS_INFORMATION lppiProcInfo
    )
{
        BOOL bReturn=TRUE;
        bReturn = ORIGINAL_API(CreateProcessA)(lpszImageName, lpszCmdLine, lpsaProcess, lpsaThread, fInheritHandles, fdwCreate, lpvEnvironment, lpszCurDir, lpsiStartInfo, lppiProcInfo);
        Sleep(5000);
        return bReturn;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    //
    // Add APIs that you wish to hook here. All API prototypes
    // must be declared in Hooks\inc\ShimProto.h. Compiler errors
    // will result if you forget to add them.
    //
    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\quicktime5.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    QuickTime5.cpp

 Abstract:

    QuickTime 5 is calling Get/SetWindowLong(GWL_WNDPROC/DWL_DLGPROC) on hwnds outside its process
    and it is passing hardcoded strings within its address space (these calls will always fail on
    win9x). On 32-bit platforms this is pretty much benign, but on ia64 the call to SetWindowLong(hwnd, DWL_DLGPROC, crap)
    succeeds in trashing private window bits in explorer windows (since the window is not a dialog hwnd).

 Notes:

    This is an app specific shim.

 History:

    7/31/2001   reinerf     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(QuickTime5)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetWindowLongA) 
    APIHOOK_ENUM_ENTRY(SetWindowLongA) 
APIHOOK_ENUM_END


LONG
APIHOOK(GetWindowLongA)(HWND hwnd, int iIndex)
{
    if (hwnd)
    {
        if ((iIndex == GWL_WNDPROC) ||
            (iIndex == DWL_DLGPROC))
        {
            DWORD dwPID = 0;

            GetWindowThreadProcessId(hwnd, &dwPID);

            if (GetCurrentProcessId() != dwPID)
            {
                // we are querying an hwnd that is not in our 
                // process-- just fail the call
                return 0;
            }
        }
    }
    
    return ORIGINAL_API(GetWindowLongA)(hwnd, iIndex);
}


LONG
APIHOOK(SetWindowLongA)(HWND hwnd, int iIndex, LONG lNew)
{
    if (hwnd)
    {
        if ((iIndex == GWL_WNDPROC) ||
            (iIndex == DWL_DLGPROC))
        {

            DWORD dwPID = 0;

            GetWindowThreadProcessId(hwnd, &dwPID);

            if (GetCurrentProcessId() != dwPID)
            {
                // we are trying modify an hwnd that is not in our 
                // process-- just fail the call
                return 0;
            }
        }
    }
    
    return ORIGINAL_API(SetWindowLongA)(hwnd, iIndex, lNew);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, GetWindowLongA)
    APIHOOK_ENTRY(USER32.DLL, SetWindowLongA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\rcenter.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RCenter.cpp

 Abstract:

    RCenter attempts to compare file extensions from a CD's root against known media
	types.  When they get the file's extension, they get ".txt" and then add one to the
	pointer to leave "txt".  

	The trouble is that if a file has no extension they end up with a null pointer for
	the extension string, add one to it, and then pass it into lstrcmpiA.  lstrcmpiA
	can handle null pointers, but not "1" pointers.

	This shim treats bad pointers as the shortest possible string:
		lstrcmpi(BAD_PTR, "Hello World") == LESS_THAN
		lstrcmpi("Hello World", BAD_PTR) == GREATER_THAN
		lstrcmpi(BAD_PTR, BAD_PTR) == EQUAL
    
 Notes:

    This is an app specific shim.

 History:

    11/13/2001  astritz     Created

--*/
 
#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RCenter)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lstrcmpiA)
APIHOOK_ENUM_END

/*++

 Hook lstrcmpiA to handle NULL pointers as above.

--*/

BOOL 
APIHOOK(lstrcmpiA)(
	LPCSTR lpString1,
	LPCSTR lpString2
	)
{
	if (IsBadReadPtr(lpString1, 1)) {
		if (IsBadReadPtr(lpString2, 1)) {
			return 0;
        } else {
		    return -1;
        }
	} else if (IsBadReadPtr(lpString2, 1)) {
		return 1;
	}

	return ORIGINAL_API(lstrcmpiA)(lpString1, lpString2);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, lstrcmpiA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\quickbooks8.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    QuickBooks8.cpp

 Abstract:

    Looks like a bug in "C:\Program Files\Intuit\QuickBooks Pro\qbw32.exe". All 
    cab file are coming from this program. It's sending a TB_ADDSTRING message 
    to the toolbar control, but the lParam of the message is malformed. The 
    lParam is documented to be an array of  null-termnated string with the last 
    string in the array being double nulled. In the case  of this program, the 
    last string is not double nulled, causing comctl32 to read of the end of 
    the buffer while processing the message.

 Notes:

    This is an app specific shim.

 History:

    04/16/2002  v-ramora    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(QuickBooks8)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SendMessageA) 
APIHOOK_ENUM_END

/*++

  If the strings are well formed or double null terminated return TRUE and 
  strings length. If the strings are not well formed, return FALSE and length 
  of strings

--*/

BOOL 
AreTheStringsGood(
    LPCSTR pszStrings, 
    DWORD &dwStringsLen
    )
{
    dwStringsLen = 0;

    __try
    {
        while (*pszStrings) {
            DWORD dwOneStringLen = 0;

            // I am assuming single tooltip or string length can be at most 256
            while (*pszStrings && (dwOneStringLen < 256)) {
                pszStrings++;
                dwOneStringLen++;
            }

            if (*pszStrings == NULL) {
                // String was terminated by '\0' means good.
                DPFN( eDbgLevelInfo, "Toolbar TB_ADDSTRING = %s", (pszStrings - dwOneStringLen));
                dwStringsLen += dwOneStringLen + 1; // 1 is for end of string
                pszStrings++; // goto next string
            } else {
                return FALSE;
            }
        }   
    }
    __except (1) {
        return FALSE;
    }

    return TRUE;
}

/*++

  Make sure the last string is double null terminated.

--*/
BOOL
APIHOOK(SendMessageA)(
        HWND hWnd,
        UINT uMsg,    // TB_ADDSTRING
        WPARAM wParam,// hInst to Module which contains strings, In this case NULL since array of strings
        LPARAM lParam // points to a character array with one or more strings
        )
{

#define CLASSNAME_LENGTH  256

    WCHAR wszClassName[CLASSNAME_LENGTH] = L"";

    if (GetClassName(hWnd, wszClassName, CLASSNAME_LENGTH-1) && lParam) {
        // I care about only send message to toolbar
        if ((wcsncmp(wszClassName, L"ToolbarWindow32", CLASSNAME_LENGTH) == 0) && 
            (uMsg == TB_ADDSTRING) && (wParam == NULL)) {

            LPCSTR pszStrings = (LPCSTR) lParam;
            DWORD dwStringsLen = 0;
            
            //
            // If strings are not double null terminated, then only create new strings 
            // with double null
            //
            if ((AreTheStringsGood(pszStrings, dwStringsLen) == FALSE) && dwStringsLen) {

                LOGN(eDbgLevelError, "[SendMessageA] Toolbar TB_ADDSTRING bad lParam");

                LPSTR pszNewStrings = (LPSTR) malloc(dwStringsLen + 1);
                if (pszNewStrings) {
                    MoveMemory(pszNewStrings, pszStrings, dwStringsLen);
                    *(pszNewStrings + dwStringsLen) = '\0'; //second '\0'

                    LRESULT lResult = ORIGINAL_API(SendMessageA)(hWnd, uMsg, 
                        wParam, (LPARAM) pszNewStrings);
                    free(pszNewStrings);
                    return lResult;                
                }
            }   
        }
    }

    return ORIGINAL_API(SendMessageA)(hWnd, uMsg, wParam, lParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, SendMessageA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\returntokrondor.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   ReturnToKrondor.cpp

 Abstract:

   This APIHooks GetDIBits to hack around a performance problem with the 
   DIB_PAL_COLORS usage.

 Notes:

   This APIHook emulates Windows 9x.

 History:

   09/07/2000 robkenny  Created

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ReturnToKrondor)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetDIBits) 
APIHOOK_ENUM_END

int
APIHOOK(GetDIBits)(
    HDC hdc,           // handle to DC
    HBITMAP hbmp,      // handle to bitmap
    UINT uStartScan,   // first scan line to set
    UINT cScanLines,   // number of scan lines to copy
    LPVOID lpvBits,    // array for bitmap bits
    LPBITMAPINFO lpbi, // bitmap data buffer
    UINT uUsage        // RGB or palette index
    )
{
    return ORIGINAL_API(GetDIBits)(
                hdc,
                hbmp,
                uStartScan,
                cScanLines,
                lpvBits,
                lpbi,
                DIB_RGB_COLORS      // Force RGB_COLORS
                );
}

HOOK_BEGIN

    APIHOOK_ENTRY(GDI32.DLL, GetDIBits)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\resonate.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    Resonate.cpp

 Abstract:

    The name of the TCP loopback adapter was changed from MS Loopback Adapter to
    Microsoft Loopback Adapter.  Resonate looks for the old name.

 Notes:

    This is an app specific shim.

 History:

    08/12/2002  robkenny    Created

--*/

#include "precomp.h"
#include "Iphlpapi.h"

IMPLEMENT_SHIM_BEGIN(Resonate)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetAdaptersInfo) 
    APIHOOK_ENUM_ENTRY(GetIfTable) 
    APIHOOK_ENUM_ENTRY(GetIfEntry) 
APIHOOK_ENUM_END

typedef DWORD       (*_pfn_GetAdaptersInfo)(PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen);
typedef DWORD       (*_pfn_GetIfTable)( PMIB_IFTABLE pIfTable, PULONG pdwSize, BOOL bOrder );
typedef DWORD       (*_pfn_GetIfEntry)( PMIB_IFROW pIfRow );

/*++

 Convert the loopback adaptor name from Microsoft Loopback Adapter to MS Loopback Adapter 

--*/


DWORD
APIHOOK(GetAdaptersInfo)(
  PIP_ADAPTER_INFO pAdapterInfo,  // buffer to receive data
  PULONG pOutBufLen               // size of data returned
)
{
    DWORD dwRet = ORIGINAL_API(GetAdaptersInfo)(pAdapterInfo, pOutBufLen);
    if (dwRet == ERROR_SUCCESS)
    {
        DPFN(eDbgLevelInfo, "GetAdaptersInfo called successfully");

        // Traverse the linked list, looking for the old name
        for (PIP_ADAPTER_INFO ll = pAdapterInfo; ll != NULL; ll = ll->Next)
        {
            DPFN(eDbgLevelInfo, "Adapter Name(%s)", ll->AdapterName);
            DPFN(eDbgLevelInfo, "Adapter Desc(%s)", ll->Description);
            if (strcmp(ll->Description, "Microsoft Loopback Adapter") == 0)
            {
                (void)StringCchCopyA(ll->Description, MAX_ADAPTER_DESCRIPTION_LENGTH + 4, "MS Loopback Adapter"); 
                LOGN(eDbgLevelError, "Changing name of loopback adapter to %s", ll->Description);
                break;
            }
        }
    }

    return dwRet;
}

DWORD
APIHOOK(GetIfTable)(
  PMIB_IFTABLE pIfTable,  // buffer for interface table 
  PULONG pdwSize,         // size of buffer
  BOOL bOrder             // sort the table by index?
)
{
    DWORD dwRet = ORIGINAL_API(GetIfTable)(pIfTable, pdwSize, bOrder);
    if (dwRet == NO_ERROR)
    {
        DPFN(eDbgLevelInfo, "GetIfTable called successfully");

        // Traverse the array, looking for the old name
        for (DWORD i = 0; i < pIfTable->dwNumEntries; ++i)
        {
            DPFN(eDbgLevelInfo, "Interface Name(%s)", pIfTable->table[i].bDescr);
            if (strcmp((const char *)pIfTable->table[i].bDescr, "Microsoft Loopback Adapter") == 0)
            {
                (void)StringCchCopyA((char *)pIfTable->table[i].bDescr, MAXLEN_IFDESCR, "MS LoopBack Driver"); 
                LOGN(eDbgLevelError, "Changing name of interface to %s", pIfTable->table[i].bDescr);
                break;
            }
        }
    }

    return dwRet;
}

DWORD
APIHOOK(GetIfEntry)(
  PMIB_IFROW pIfRow  // pointer to interface entry 
)
{
    DWORD dwRet = ORIGINAL_API(GetIfEntry)(pIfRow);
    if (dwRet == NO_ERROR)
    {
        DPFN(eDbgLevelInfo, "GetIfEntry called successfully");

        DPFN(eDbgLevelInfo, "Interface Name(%s)", pIfRow->bDescr);
        if (strcmp((const char *)pIfRow->bDescr, "Microsoft Loopback Adapter") == 0)
        {
            (void)StringCchCopyA((char *)pIfRow->bDescr, MAXLEN_IFDESCR, "MS LoopBack Driver"); 
            LOGN(eDbgLevelError, "Changing name of interface to %s", pIfRow->bDescr);
        }
    }

    return dwRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(Iphlpapi.DLL, GetAdaptersInfo)
    APIHOOK_ENTRY(Iphlpapi.DLL, GetIfTable)
    APIHOOK_ENTRY(Iphlpapi.DLL, GetIfEntry)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\riskii.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RiskII.cpp

 Abstract:

    This shim hooks LoadImageA to intercept the loading of two
    cursors and returns copies of the system cursors instead of
    the ones RiskII was trying to get.  RiskII's cursors were
    being rendered by software and it caused them to flicker since
    RiskII locks the primary surface.  The system cursors are 
    hardware cursors and don't flicker.

 History:

 08/03/2000 t-adams    Created

--*/

#include "precomp.h"
#include <mmsystem.h>

IMPLEMENT_SHIM_BEGIN(RiskII)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadImageA) 
APIHOOK_ENUM_END

/*++

  Abstract:

    Intercept the load of two cursors, and replace with the appropriate
    similar-looking system cursors.

  History:

    08/03/2000    t-adams     Created

--*/

HANDLE 
APIHOOK(LoadImageA)(
    HINSTANCE hinst,
    LPCSTR lpszName,
    UINT uType,
    int cxDesired,
    int cyDesired,
    UINT fuLoad) 
{

    HANDLE hRet = INVALID_HANDLE_VALUE;
                                
    CSTRING_TRY
    {
        CString csName(lpszName);

        if (csName.CompareNoCase(L"Gfx\\Arrow_m.cur") == 0 )
        {
            HCURSOR hCur = LoadCursor(NULL, IDC_ARROW);
            if (hCur)
            {
                hRet = CopyCursor(hCur);
            }
        }
        else if (csName.CompareNoCase(L"Gfx\\Busy_m.cur") == 0 )
        {
            HCURSOR hCur = LoadCursor(NULL, IDC_WAIT);
            if (hCur)
            {
                hRet = CopyCursor(hCur);
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    if (hRet == INVALID_HANDLE_VALUE)
    {
        hRet = ORIGINAL_API(LoadImageA)(hinst, lpszName, uType, cxDesired, cyDesired, fuLoad);
    }
    return hRet;        
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, LoadImageA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\resumewriter3.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ResumeWriter3.cpp

 Abstract:

    The setup of this app fails to register the OCX'es as it 
    tries loading the DLL's with a hardcoded 'system' path.
    Corrected the path to the 'system32' path.
   
 Notes:

    This is specific to this app.

 History:

    05/22/2001 prashkud Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ResumeWriter3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END


WCHAR g_wszSystemDir[MAX_PATH];

/*++

    Hooks LoadLibraryA and changes the path that contains 'system' in it
    to the  'system32.

--*/

HMODULE
APIHOOK(LoadLibraryA)(
    LPCSTR lpFileName
    )
{
    CSTRING_TRY
    {
        // Bad string pointers can cause failures in CString.
        if (!IsBadStringPtrA(lpFileName, MAX_PATH))
        {
            CString csFileName(lpFileName);
            if (csFileName.Find(L"system") != -1)
            {
                // We have found 'system' in the path
                // Replace it with 'system32'.
                CString csName;
                csFileName.GetLastPathComponent(csName);              
                CString csNewFileName(g_wszSystemDir);
                csNewFileName.AppendPath(csName);

                DPFN(eDbgLevelInfo, "[ResumeWriter3] changed %s to (%s)\n", lpFileName, csNewFileName.GetAnsi());
                return ORIGINAL_API(LoadLibraryA)(csNewFileName.GetAnsi());                
            }
        }
    }
    CSTRING_CATCH
    {
    }

    return ORIGINAL_API(LoadLibraryA)(lpFileName);
}

/*++

    Cache the system directory when we get called in 
    the beginning.

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        GetSystemDirectory(g_wszSystemDir, MAX_PATH);
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\riven.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

   Riven.cpp

 Abstract:

   A hack for Riven. The game gets confused about what windows version it's
   running under and tries to handle it's own messages. A simple ver lie 
   fixes this issue, but causes the game to use a win9x only method to 
   eject the CD.

 Fix:
   
   We can get ddraw to correctly handle alt+tabbing by turning off the 
   DDSCL_NOWINDOWCHANGES flag on IDirectDraw->SetCooperativeLevel

 Notes:

   This is an app specific hack, but could fix other similar issues.

 Created:

   11/23/1999 linstev

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Riven)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

/*++

 IDirectDraw::SetCooperativeLevel hook

--*/

HRESULT
COMHOOK(IDirectDraw, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}

HRESULT
COMHOOK(IDirectDraw2, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw2, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}

HRESULT
COMHOOK(IDirectDraw4, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw4, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}
HRESULT
COMHOOK(IDirectDraw7, SetCooperativeLevel)( 
    PVOID pThis, 
    HWND hWnd, 
    DWORD dwFlags
    )
{
    if (dwFlags & DDSCL_NOWINDOWCHANGES) 
    {
        dwFlags &= ~DDSCL_NOWINDOWCHANGES;
        LOGN(eDbgLevelError, "Removed NOWINDOWCHANGES flag");
    }

    return ORIGINAL_COM(IDirectDraw7, SetCooperativeLevel, pThis)(
                pThis,
                hWnd,
                dwFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()

    COMHOOK_ENTRY(DirectDraw, IDirectDraw, SetCooperativeLevel, 20)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, SetCooperativeLevel, 20)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, SetCooperativeLevel, 20)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, SetCooperativeLevel, 20)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\rumbaoffice.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    RumbaOffice.cpp

 Abstract:

    Ingnore the first call to NdrProxySendReceive if the ProcNum is 0x8013. 
    This prevents the RPC call from raising an exception because it's being 
    called from an ASYNC callback. The error it would normally return would be 
    RPC_E_CANTCALLOUT_INASYNCCALL. If it raises an exception, the app dies.
        
    No idea why this works on 9X.

 Notes:

    This is an app specific shim.

 History:

    01/08/2001 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RumbaOffice)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(NdrProxySendReceive)
APIHOOK_ENUM_END

BOOL g_bFirst = TRUE;

typedef HRESULT (WINAPI *_pfn_NdrProxySendReceive)(void *pThis, MIDL_STUB_MESSAGE * pStubMsg);

/*++

 Ignore the first call to NdrProxySendReceive.

--*/

HRESULT
APIHOOK(NdrProxySendReceive)(
    void *pThis, 
    MIDL_STUB_MESSAGE * pStubMsg
    )
{
    HRESULT hr;

    if (g_bFirst && (pStubMsg->RpcMsg->ProcNum == 0x8013))
    {
        g_bFirst = FALSE;

        DPFN( eDbgLevelError, "Ignoring call to NdrProxySendReceive");

        hr = 0;
    }
    else
    {
        hr = ORIGINAL_API(NdrProxySendReceive)(pThis, pStubMsg);
    }

    return hr;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(RPCRT4.DLL, NdrProxySendReceive)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\schoolhouserockmath.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SchoolHouseRockMath.cpp

 Abstract:

    This shim directs the install to look in the _InstallTo16 and 
    _InstallFrom16 sections of setup.inf instead of _InstallFrom32 and 
    _InstallTo32. This is needed because the application tries to use a 16-bit 
    DLL during gameplay which is allowed in Win9x but produces errors under 
    Whistler.

 History:

    10/18/2000 jdoherty  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SchoolHouseRockMath)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA) 
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW) 
    APIHOOK_ENUM_ENTRY(GetProfileStringA) 
    APIHOOK_ENUM_ENTRY(GetProfileStringW) 
APIHOOK_ENUM_END

/*++

 This stub function breaks into GetPrivateProfileString and checks to see the section lpAppName
 being referred to is one of the sections in question.

--*/

DWORD 
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    CHAR *szAppNames[] = {"_INSTALLTO32", "_INSTALLFROM32"};
    CHAR *szNewAppNames[] = {"_INSTALLTO16", "_INSTALLFROM16"};
     
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if ((stristr (szAppNames[i], lpAppName) !=NULL ))
        {
            return ORIGINAL_API(GetPrivateProfileStringA)(
                        szNewAppNames[i],
                        lpKeyName,
                        lpDefault,
                        lpReturnedString,
                        nSize,
                        lpFileName
                        );
        }
    }
    
    return ORIGINAL_API(GetPrivateProfileStringA)(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize,
                lpFileName
                );
}

/*++

 This stub function breaks into GetPrivateProfileString and checks to see the section lpAppName
 being referred to is one of the sections in question.

--*/

DWORD
WINAPI
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    WCHAR *wszAppNames[] = {L"_INSTALLTO32", L"_INSTALLFROM32"};
    WCHAR *wszNewAppNames[] = {L"_INSTALLTO16", L"_INSTALLFROM16"};
            
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if (wcsistr (lpAppName, wszAppNames[i]) != NULL)
        {
            return ORIGINAL_API(GetPrivateProfileStringW)(
                    wszNewAppNames[i],
                    lpKeyName,
                    lpDefault,
                    lpReturnedString,
                    nSize,
                    lpFileName
                    );
        }
    }
    
    return ORIGINAL_API(GetPrivateProfileStringW)(
            lpAppName,
            lpKeyName,
            lpDefault,
            lpReturnedString,
            nSize,
            lpFileName
            );
}

/*++

 This stub function breaks into GetProfileString and checks to see the section 
 lpAppName being referred to is one of the sections in question.

--*/

DWORD
APIHOOK(GetProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    CHAR *szAppNames[] = {"_INSTALLTO32", "_INSTALLFROM32"};
    CHAR *szNewAppNames[] = {"_INSTALLTO16", "_INSTALLFROM16"};
           
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if (stristr (szAppNames[i], lpAppName) !=NULL )
        {
            return ORIGINAL_API(GetProfileStringA)(
                        szNewAppNames[i],
                        lpKeyName,
                        lpDefault,
                        lpReturnedString,
                        nSize
                        );
        }
    }
    
    return ORIGINAL_API(GetProfileStringA)(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize
                );
}

/*++

 This stub function breaks into GetProfileString and checks to see the section 
 lpAppName being referred to is one of the sections in question.

--*/

DWORD
APIHOOK(GetProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    )
{
    DWORD dRet;
    int iArraySize = 2;
    // The following array specifies what sections to look for and what to 
    // replace them with when calling GetPrivateProfileString
    WCHAR *wszAppNames[] = {L"_INSTALLTO32", L"_INSTALLFROM32"};
    WCHAR *wszNewAppNames[] = {L"_INSTALLTO16", L"_INSTALLFROM16"};
    
    for (int i = 0; i < iArraySize; i++)
    {
        // Find out if one of the known section names is lpAppName
        // if so change lpAppName parameter to new parameter and call API
        if (wcsistr (lpAppName, wszAppNames[i]) != NULL)
        {
            return ORIGINAL_API(GetProfileStringW)(
                        wszNewAppNames[i],
                        lpKeyName,
                        lpDefault,
                        lpReturnedString,
                        nSize
                        );
        }
    }
    
    return ORIGINAL_API(GetProfileStringW)(
                lpAppName,
                lpKeyName,
                lpDefault,
                lpReturnedString,
                nSize
                );
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetPrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetProfileStringW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\safedisc.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    SafeDisc.cpp

 Abstract:

    Some versions of SafeDisc try to validate kernel32 by checking if certain 
    APIs fall within a particular area in the PE image. Our BBT process moves
    everything around and therefore breaks their checks.

    This shim can be used to fix this problems by effectively moving the entry 
    point of the APIs they test to a jump table located in a 'valid' location.

    The valid location itself is an API that isn't used, but does happen to lie
    before the export directory.

 Notes:

    This is an app specific shim.

 History:

    06/15/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SafeDisc)

#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

#pragma pack(1)

//
// Random API used as a placeholder for a jump table. It's offset must be less 
// than the export directory. Also, since it's overwritten with a jump table, 
// it should not be an API that is used.
//
CHAR *g_szRandomAPI = "CreateMailslotA";

struct HOOK {
    CHAR *szName;
    FARPROC lpAddress;
};
HOOK g_aHooks[] = {
    { "ReadProcessMemory"       , 0 },
    { "WriteProcessMemory"      , 0 },
    { "VirtualProtect"          , 0 },
    { "CreateProcessA"          , 0 },
    { "CreateProcessW"          , 0 },
    { "GetStartupInfoA"         , 0 },
    { "GetStartupInfoW"         , 0 },
    { "GetSystemTime"           , 0 },
    { "GetSystemTimeAsFileTime" , 0 },
    { "TerminateProcess"        , 0 },
    { "Sleep"                   , 0 }
};
DWORD g_dwHookCount = sizeof(g_aHooks) / sizeof(HOOK);

BOOL Patch()
{
    //
    // Get the kernel32 image base 
    //
    HMODULE hKernel = GetModuleHandleW(L"kernel32");
    if (!hKernel) {
        goto Fail;
    }

    //
    // Get the address of the semi-random API where we'll put our jump table
    //
    FARPROC lpRandomAPI = GetProcAddress(hKernel, g_szRandomAPI);
    if (lpRandomAPI == NULL)
    {
        goto Fail;
    }

    //
    // Get the export directory
    //
    PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER) hKernel;
    PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((LPBYTE) hKernel + pIDH->e_lfanew);
    DWORD dwExportOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    PIMAGE_EXPORT_DIRECTORY lpExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)hKernel + dwExportOffset);

    //
    // Write out the jump table 
    //
    LPBYTE lpCurrAPI = (LPBYTE) lpRandomAPI;
    for (UINT i=0; i<g_dwHookCount; i++) {
        //
        // Loop through each API and create a jump table entry for it 
        //
        DWORD dwAPIOffset;

        g_aHooks[i].lpAddress = GetProcAddress(hKernel, g_aHooks[i].szName);
        dwAPIOffset = (DWORD)((DWORD_PTR) g_aHooks[i].lpAddress - (DWORD_PTR) hKernel);

        //
        // This API will cause problems for SafeDisc if it's after the export directory
        //
        if (dwAPIOffset > dwExportOffset) {
            //
            // Each jump table entry has the form: jmp dword ptr [address]
            //
            struct PATCH {
                WORD  wJump;
                DWORD dwAddress;
            };
            PATCH patch = { 0x25FF, (DWORD_PTR)&g_aHooks[i].lpAddress };
            DWORD dwOldProtect;

            DPF("SafeDisc", eDbgLevelWarning, "API %s is being redirected", g_aHooks[i].szName);
            
            //
            // Write the jump table entry
            //
            if (!VirtualProtect(lpCurrAPI, sizeof(PATCH), PAGE_READWRITE, &dwOldProtect)) {
                goto Fail;
            }

            MoveMemory(lpCurrAPI, &patch, sizeof(PATCH));

            if (!VirtualProtect(lpCurrAPI, sizeof(PATCH), dwOldProtect, &dwOldProtect)) { 
                goto Fail;
            }

            //
            // Now patch the export directory
            //
            LPDWORD lpExportList = (LPDWORD)((DWORD_PTR) hKernel + lpExportDirectory->AddressOfFunctions);
            for (UINT j=0; j<lpExportDirectory->NumberOfFunctions; j++) {
                if (*lpExportList == dwAPIOffset) {
                    //
                    // We've found the offset in the export directory, so patch it with the 
                    // new address
                    //
                    DWORD dwNewAPIOffset = (DWORD)((DWORD_PTR) lpCurrAPI - (DWORD_PTR) hKernel);

                    if (!VirtualProtect(lpExportList, sizeof(DWORD), PAGE_READWRITE, &dwOldProtect)) {
                        goto Fail;
                    }

                    MoveMemory(lpExportList, &dwNewAPIOffset, sizeof(DWORD));

                    if (!VirtualProtect(lpExportList, sizeof(DWORD), dwOldProtect, &dwOldProtect)) { 
                        goto Fail;
                    }
                    break;
                }
                lpExportList++;
            }

            lpCurrAPI += sizeof(PATCH);
        }
    }

    
    return TRUE;

Fail:

    return FALSE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        CHAR *lpCommandLine = COMMAND_LINE;

        if (lpCommandLine && (*lpCommandLine != '\0')) {
            g_szRandomAPI = lpCommandLine;
        }

        Patch();
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\settlers3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Settlers3.cpp

 Abstract:

    The app has a protection system that sets the CPU direction flag and 
    expects it to be maintained through calls to WaitForSingleObject, SetEvent
    and ResetEvent.

    We have to patch the import tables manually and pretend to be kernel32 so
    the protection system doesn't fail elsewhere.

 Notes:

    This is an app specific shim.

 History:

    07/05/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Settlers3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//
// The real kernel32 handle
//

HINSTANCE g_hinstKernel;

// Functions to hook imports

BOOL HookImports(HMODULE hModule);

//
// List of hooks we'll be patching
//

FARPROC _GetProcAddress(HMODULE hModule, LPCSTR lpProcName);
HINSTANCE _LoadLibraryA(LPCSTR lpLibFileName);
HMODULE _GetModuleHandleA(LPCSTR lpModuleName);
BOOL _ResetEvent(HANDLE hEvent);
BOOL _SetEvent(HANDLE hEvent);
DWORD _WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);

struct AHOOK {
    LPSTR szName;
    PVOID pfnOld;
    PVOID pfnNew;
};

AHOOK g_HookArray[] = {
    { "LoadLibraryA"        , 0, _LoadLibraryA        },
    { "GetProcAddress"      , 0, _GetProcAddress      }, 
    { "GetModuleHandleA"    , 0, _GetModuleHandleA    },
    { "ResetEvent"          , 0, _ResetEvent          }, 
    { "SetEvent"            , 0, _SetEvent            },
    { "WaitForSingleObject" , 0, _WaitForSingleObject }
};
DWORD g_dwHookCount = sizeof(g_HookArray) / sizeof(AHOOK);

/*++

 Hooks section: each designed to spoof the app into thinking this shim is 
 kernel32.dll.

--*/

HINSTANCE 
_LoadLibraryA(
    LPCSTR lpLibFileName   
    )
{
    if (lpLibFileName && stristr(lpLibFileName, "kernel32")) {
        return g_hinstDll;
    } else {
        HINSTANCE hRet = LoadLibraryA(lpLibFileName);
        HookImports(GetModuleHandleW(0));
        return hRet;
    }
}

FARPROC 
_GetProcAddress(
    HMODULE hModule,    
    LPCSTR lpProcName   
    )
{
    if (hModule == g_hinstDll) {
        hModule = g_hinstKernel;
    }
    
    FARPROC lpRet = GetProcAddress(hModule, lpProcName);

    //
    // Run the list of our hooks to see if we need to spoof them
    //
    if (lpRet) {
        for (UINT i=0; i<g_dwHookCount; i++) {
            if (lpRet == g_HookArray[i].pfnOld) {
                lpRet = (FARPROC) g_HookArray[i].pfnNew;
                break;
            }
        }
    }
                
    return lpRet;
}

HMODULE 
_GetModuleHandleA(
    LPCSTR lpModuleName   
    )
{
    if (lpModuleName && stristr(lpModuleName, "kernel32")) {
        return g_hinstDll;
    } else {
        return GetModuleHandleA(lpModuleName);
    }
}

/*++

 These save and restore the state of the direction flag (actually all flags),
 before and after each call.

--*/

BOOL 
_ResetEvent(
    HANDLE hEvent   
    )
{
    DWORD dwFlags;

    __asm {
        pushfd
        pop  dwFlags
    }

    BOOL bRet = ResetEvent(hEvent);

    __asm {
        push dwFlags
        popfd 
    }

    return bRet;
}

BOOL 
_SetEvent(
    HANDLE hEvent   
    )
{
    DWORD dwFlags;

    __asm {
        pushfd
        pop  dwFlags
    }

    BOOL bRet = SetEvent(hEvent);

    __asm {
        push dwFlags
        popfd 
    }

    return bRet;
}

DWORD
_WaitForSingleObject(
    HANDLE hHandle,        
    DWORD dwMilliseconds   
    )
{
    DWORD dwFlags;

    __asm {
        pushfd
        pop  dwFlags
    }

    DWORD dwRet = WaitForSingleObject(hHandle, dwMilliseconds);
    
    __asm {
        push dwFlags
        popfd 
    }

    return dwRet;
}

/*++

 Patch everyone to point to this dll
  
--*/

BOOL
HookImports(HMODULE hModule)
{
    NTSTATUS                    status;
    BOOL                        bAnyHooked = FALSE;
    PIMAGE_DOS_HEADER           pIDH       = (PIMAGE_DOS_HEADER) hModule;
    PIMAGE_NT_HEADERS           pINTH;
    PIMAGE_IMPORT_DESCRIPTOR    pIID;
    DWORD                       dwImportTableOffset;
    DWORD                       dwOldProtect, dwOldProtect2;
    SIZE_T                      dwProtectSize;
    DWORD                       i, j;
    PVOID                       pfnOld;
    LPBYTE                      pDllBase = (LPBYTE) pIDH;

    if (!hModule || (hModule == g_hinstDll) || (hModule == g_hinstKernel)) {
        return FALSE;
    }

    //
    // Get the import table.
    //
    pINTH = (PIMAGE_NT_HEADERS)(pDllBase + pIDH->e_lfanew);

    dwImportTableOffset = pINTH->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;

    if (dwImportTableOffset == 0) {
        //
        // No import table found. This is probably ntdll.dll
        //
        return TRUE;
    }

    pIID = (PIMAGE_IMPORT_DESCRIPTOR)(pDllBase + dwImportTableOffset);

    //
    // Loop through the import table and search for the APIs that we want to patch
    //
    while (TRUE) {

        LPSTR             pszImportEntryModule;
        PIMAGE_THUNK_DATA pITDA;

        //
        // Return if no first thunk (terminating condition).
        //
        if (pIID->FirstThunk == 0) {
            break;
        }

        pszImportEntryModule = (LPSTR)(pDllBase + pIID->Name);

        //
        // We have APIs to hook for this module!
        //
        pITDA = (PIMAGE_THUNK_DATA)(pDllBase + (DWORD)pIID->FirstThunk);

        while (TRUE) {

            SIZE_T dwFuncAddr;
            AHOOK *pHook = NULL;

            pfnOld = (PVOID)pITDA->u1.Function;

            //
            // Done with all the imports from this module? (terminating condition)
            //
            if (pITDA->u1.Ordinal == 0) {
                break;
            }

            for (i=0; i<g_dwHookCount; i++) {
                if (pfnOld == g_HookArray[i].pfnOld) {
                    pHook = &g_HookArray[i];
                    break;
                }
            }

            // 
            // Check if we've found a hook
            //
            if (!pHook) {
                pITDA++;
                continue;
            }

            //
            // Make the code page writable and overwrite new function pointer
            // in the import table.
            //
            dwProtectSize = sizeof(DWORD);

            dwFuncAddr = (SIZE_T)&pITDA->u1.Function;

            status = VirtualProtect((PVOID)dwFuncAddr,                                            
                                    dwProtectSize,
                                    PAGE_READWRITE,
                                    &dwOldProtect);

            if (NT_SUCCESS(status)) {
                pITDA->u1.Function = (SIZE_T)pHook->pfnNew;

                dwProtectSize = sizeof(DWORD);

                status = VirtualProtect((PVOID)dwFuncAddr,
                                        dwProtectSize,
                                        dwOldProtect,
                                        &dwOldProtect2);

                if (!NT_SUCCESS(status)) {
                    DPFN(eDbgLevelError, "[HookImports] Failed to change back the protection");
                }
            } else {
                DPFN(eDbgLevelError,
                    "[HookImports] Failed 0x%X to change protection to PAGE_READWRITE."
                    " Addr 0x%p\n",
                    status,
                    &pITDA->u1.Function);

            }
            pITDA++;

        }
        pIID++;
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // Patch all the import tables of everyone with this module
        //
        g_hinstKernel = GetModuleHandleW(L"kernel32");
        for (UINT i=0; i<g_dwHookCount; i++) {
            g_HookArray[i].pfnOld = GetProcAddress(g_hinstKernel, g_HookArray[i].szName);
        }

        HookImports(GetModuleHandleW(0));
    }

    return TRUE;
}


HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\sevenkingdoms.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SevenKingdoms.cpp

 Abstract:
    
    The problem is in the installer that ships with some versions: specifically 
    the double pack: i.e. Seven Kingdoms and another. This installer reads 
    win.ini and parses it for localization settings.

 Notes:

    This is an app specific shim.

 History:

    07/24/2000 linstev  Created

--*/

#include "precomp.h"
#include <stdio.h>

IMPLEMENT_SHIM_BEGIN(SevenKingdoms)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateFileA) 
    APIHOOK_ENUM_ENTRY(ReadFile) 
    APIHOOK_ENUM_ENTRY(CloseHandle) 
APIHOOK_ENUM_END

CHAR *g_pszINI; 
DWORD g_dwINIPos = 0;
DWORD g_dwINISize = 0;

/*++

 Spoof the international settings in win.ini.

--*/

HANDLE 
APIHOOK(CreateFileA)(
    LPSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    HANDLE hRet;
    
    if (lpFileName && (stristr(lpFileName, "win.ini")))
    {
        g_dwINIPos = 0;
        hRet = (HANDLE)0xBAADF00D;
    }
    else
    {
        hRet = ORIGINAL_API(CreateFileA)(
            lpFileName, 
            dwDesiredAccess, 
            dwShareMode, 
            lpSecurityAttributes, 
            dwCreationDisposition, 
            dwFlagsAndAttributes, 
            hTemplateFile
            );
    }

    return hRet;
}

/*++

 Spoof the international settings in win.ini.

--*/

BOOL 
APIHOOK(ReadFile)(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    LPOVERLAPPED lpOverlapped
    )
{
    BOOL bRet;

    if (hFile == (HANDLE)0xBAADF00D)
    {
        //
        // We've detected the bogus file, so pretend we are reading it
        //

        if (g_dwINIPos + nNumberOfBytesToRead >= g_dwINISize)
        {
            // At the end of the buffer, so return the number of bytes until the end
            nNumberOfBytesToRead = g_dwINISize - g_dwINIPos;
        }
        
        MoveMemory(lpBuffer, g_pszINI + g_dwINIPos, nNumberOfBytesToRead);

        // Move the initial position - like a file pointer
        g_dwINIPos += nNumberOfBytesToRead;

        if (lpNumberOfBytesRead)
        {
            // Store the number of bytes read
            *lpNumberOfBytesRead = nNumberOfBytesToRead;
        }

        bRet = nNumberOfBytesToRead > 0;
    }
    else
    {
        bRet = ORIGINAL_API(ReadFile)( 
            hFile,
            lpBuffer,
            nNumberOfBytesToRead,
            lpNumberOfBytesRead,
            lpOverlapped);
    }

    return bRet;
}

/*++

 Handle the close of the dummy win.ini file

--*/

BOOL 
APIHOOK(CloseHandle)(HANDLE hObject)
{
    BOOL bRet;

    if (hObject == (HANDLE)0xBAADF00D)
    {
        // Pretend we closed a real file handle
        g_dwINIPos = 0;
        bRet = TRUE;
    }
    else
    {
        bRet = ORIGINAL_API(CloseHandle)(hObject);
    }
    
    return bRet;
}

void AddLocaleInfo(CString & csIni, LCTYPE lctype, const char * iniLine)
{
    CString csLocale;
    if (csLocale.GetLocaleInfoW(LOCALE_USER_DEFAULT, lctype) > 0)
    {
        CString csEntry;
        csEntry.Format(iniLine, csLocale.GetAnsi());
        csIni += csEntry;
    }
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        // 
        // Add all the locale settings to a buffer which looks like the [intl]
        //  group in win.ini on Win9x
        //

        CSTRING_TRY
        {
            CString csIni(L"[intl]\r\n");
            AddLocaleInfo(csIni, LOCALE_ICOUNTRY,       "iCountry=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_ICURRDIGITS,    "ICurrDigits=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_ICURRENCY,      "iCurrency=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_IDATE,          "iDate=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_IDIGITS,        "iDigits=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_ILZERO,         "iLZero=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_IMEASURE,       "iMeasure=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_INEGCURR,       "iNegCurr=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_ITIME,          "iTime=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_ITLZERO,        "iTLZero=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_S1159,          "s1159=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_S2359,          "s2359=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SCOUNTRY,       "sCountry=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SCURRENCY,      "sCurrency=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SDATE,          "sDate=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SDECIMAL,       "sDecimal=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SLANGUAGE,      "sLanguage=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SLIST,          "sList=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SLONGDATE,      "sLongDate=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_SSHORTDATE,     "sShortDate=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_STHOUSAND,      "sThousand=%s\r\n");
            AddLocaleInfo(csIni, LOCALE_STIME,          "sTime=%s\r\n");

            g_pszINI = csIni.ReleaseAnsi();

            g_dwINISize = strlen(g_pszINI);
        }
        CSTRING_CATCH
        {
            // Failed to initialize the locale block, don't bother shimming.
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL, ReadFile)
    APIHOOK_ENTRY(KERNEL32.DLL, CloseHandle)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\simply3d.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Simply3D.cpp

 Abstract:

    From Tomislav Markoc:

        MSPaint calls OleGetClipboard to get IDataObject interface and then 
        calls IDataObject::GetData. This call gets marshaled to Simply 3D 
        GetData.

        FORMATETC looks like:
            cfFormat=8(CF_DIB) or 2(CF_BITMAP)
            ptd=0
            dwAspect=1
            lindex= -1
            tymed=1(TYMED_HGLOBAL) or 16(TYMED_GDI)

        Simply 3D returns STGMEDIUM:
            tymed=0 //WRONG
            hBitmap=hGlobal=some handle !=0
            pUnkForRelease=0

        STGMEDIUM::tymed should be changed with something like this:

        if (STGMEDIUM::tymed==0 && STGMEDIUM::hBitmap && 
           (FORMATETC::tymed==TYMED_HGLOBAL || FORMATETC::tymed==TYMED_GDI))
            STGMEDIUM::tymed=FORMATETC::tymed;


 Notes:

    This is an app specific shim.

 History:

    02/22/2000 linstev Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Simply3D)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OleSetClipboard) 
    APIHOOK_ENUM_ENTRY_COMSERVER(OLE32)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(OLE32)

#define CLSID_DataObject IID_IDataObject

typedef HRESULT   (*_pfn_IDataObject_GetData)(PVOID pThis, FORMATETC *pFormatetc, STGMEDIUM *pmedium);
typedef HRESULT   (*_pfn_OleSetClipboard)(IDataObject * pDataObj);

/*++

 Hook OleSetClipboard to hook the object.

--*/

HRESULT
APIHOOK(OleSetClipboard)(
    IDataObject *pDataObj
    )
{
    HRESULT hReturn = ORIGINAL_API(OleSetClipboard)(pDataObj);

    if (hReturn == NOERROR) {
        HookObject(
            NULL, 
            IID_IDataObject, 
            (PVOID *) &pDataObj, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook GetData and correct the return values as 

--*/

HRESULT
COMHOOK(IDataObject, GetData)(
    PVOID pThis,
    FORMATETC *pFormatetc,  
    STGMEDIUM *pmedium
    )
{
    HRESULT hrReturn = E_FAIL;

    _pfn_IDataObject_GetData pfnOld = 
                ORIGINAL_COM(IDataObject, GetData, pThis);

    if (pfnOld) { 
        hrReturn = (*pfnOld)(pThis, pFormatetc, pmedium);

        if (!pmedium->tymed && pmedium->hBitmap && 
            ((pFormatetc->tymed == TYMED_HGLOBAL) || 
             (pFormatetc->tymed == TYMED_GDI))) {

            LOGN( eDbgLevelError, "[IDataObject_GetData] fixing tymed parameter");
            
            pmedium->tymed = pFormatetc->tymed;
        }
    }

    return hrReturn;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_COMSERVER(OLE32)
    APIHOOK_ENTRY(OLE32.DLL, OleSetClipboard)
    COMHOOK_ENTRY(DataObject, IDataObject, GetData, 3)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\sierracartracing.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   SierraCartRacing.cpp

 Abstract:

    Sierra Cart Racing passes a bad pointer to InitializeSecurityDescriptor which overwrites
    part of the SECURITY_ATTRIBUTES structure and some other stack memory.
    
    The original version of this shim would fail the call to InitializeSecurityDescriptor,
    and force a NULL security descriptor to CreateSemaphoreA.  To reduce the security risk,
    the shim was modified to only pass a NULL security descriptor to CreateSemaphoreA if
    it detects that the LPSECURITY_ATTRIBUTES was overwritten by InitializeSecurityDescriptor,
    and restores the memory overwritten by InitializeSecurityDescriptor.

 Notes:

    This is an app specific shim.

 History:

    11/03/1999 linstev  Created
    03/15/2002 robkenny Re-created to pass security muster.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SierraCartRacing)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateSemaphoreA) 
    APIHOOK_ENUM_ENTRY(InitializeSecurityDescriptor) 
APIHOOK_ENUM_END

BOOL                    g_BLastSecurityDescriptorSet = FALSE;
SECURITY_DESCRIPTOR     g_LastSecurityDescriptor;

/*++

 Use the default security descriptor.

--*/

HANDLE 
APIHOOK(CreateSemaphoreA)(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,  
    LONG lMaximumCount,  
    LPCSTR lpName
    )
{
    if (lpSemaphoreAttributes && g_BLastSecurityDescriptorSet)
    {
        // Initialize a security descriptor
        SECURITY_DESCRIPTOR securityDescriptor;
        InitializeSecurityDescriptor(&securityDescriptor, SECURITY_DESCRIPTOR_REVISION);

        // Check to see if them memory starting at lpSemaphoreAttributes->lpSecurityDescriptor
        // contains the same memory as a security descriptor.
        int compareResult = memcmp(&securityDescriptor,
                                   &lpSemaphoreAttributes->lpSecurityDescriptor,
                                   sizeof(securityDescriptor));
        if (compareResult == 0)
        {
            // Restore the overwritten memory
            memcpy(&lpSemaphoreAttributes->lpSecurityDescriptor, &g_LastSecurityDescriptor, sizeof(g_LastSecurityDescriptor));

            // lpSemaphoreAttributes is bogus
            lpSemaphoreAttributes = NULL;
        }
    }

    return ORIGINAL_API(CreateSemaphoreA)(
        lpSemaphoreAttributes, 
        lInitialCount, 
        lMaximumCount, 
        lpName);
}



/*++

 Returns false for InitializeSecurityDescriptor. i.e. do nothing so we don't 
 touch the stack.

--*/

BOOL 
APIHOOK(InitializeSecurityDescriptor)(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    )
{
    // Save the memory that will be overwritten.
    if (pSecurityDescriptor)
    {
        g_BLastSecurityDescriptorSet = TRUE;
        memcpy(&g_LastSecurityDescriptor, pSecurityDescriptor, sizeof(g_LastSecurityDescriptor));
    }
    return ORIGINAL_API(InitializeSecurityDescriptor)(pSecurityDescriptor, dwRevision);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateSemaphoreA)
    APIHOOK_ENTRY(ADVAPI32.DLL, InitializeSecurityDescriptor)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\sirenjukebox2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SirenJukebox2.cpp

 Abstract:

    This app has a problem with DirectDraw 7.0 and hence we fail the call to 
    GetProcAddress when it asks for DirectDrawCreateEx.

 Notes:

    This is an app specific shim.

 History:
 
    03/13/2001 prashkud  Created
    05/04/2001 prashkud  Modified to fix a bug if ordinals are passed
                         instead of string addresses. We now imitate 
                         the behaviour of the actual GetProcAddress().

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SirenJukebox2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcAddress)    
APIHOOK_ENUM_END

const WCHAR  wszDirectDrawCreateEx[] = L"DirectDrawCreateEx";

/*++

 If the app is asking for the Proc adress for DirectDrawCreateEx, then return 
 NULL.
    
--*/

FARPROC
APIHOOK(GetProcAddress)(
    HMODULE hMod,
    LPCSTR lpProcName
    )
{
    CSTRING_TRY
    {
        //
        // Check to see if lpProcName contains an ordinal value.
        // Only the low word can contain the ordinal and the 
        // upper word has to be 0's.
        //

        if ((ULONG_PTR) lpProcName > 0xffff)
        {
            CString csProcName(lpProcName);

            if (csProcName.CompareNoCase(wszDirectDrawCreateEx) == 0)
            {
                return NULL;
            }
        }
    }
    CSTRING_CATCH
    {
        // Do Nothing
    }

    return ORIGINAL_API(GetProcAddress)(hMod, lpProcName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetProcAddress)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\smsdeadlock.cpp ===
/*

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    SMSDeadlock.cpp

 Abstract:

    SMS experiences a deadlock due to its loading a module that tries to take
    MFC42's AfxResourceLock during DllMain when the LoaderLock is held.

    MFC42's established locking-order is FIRST take the AfxResourceLock, and
    SECONDLY take the loader lock.

    This shim tries to right the order of lock-taking by taking the
    AfxResourceLock prior to allowing LoadLibrary and FreeLibrary calls.
    Thus the order of lock acquisition is righted.

    DLL's for which LoadLibrary takes the Afx lock are specified on the
    command line and separated by semi-colons.  A blank command line indicates
    that ALL modules should take the lock.

    NOTE:  Every module in a process (including system) should be shimmed by
    this shim.  The dlls specified in the command line are the TARGETS of 
    LoadLibrary for which we should take the AfxResource lock.  To actually
    make that switch no matter who calls LoadLibrary, we must shim all
    modules.

 History:

    09/26/2002  astritz     Created
*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SMSDeadlock)

#include "ShimHookMacro.h"

typedef void (AFXAPI * _pfn_AfxLockGlobals)(int nLockType);
typedef void (AFXAPI * _pfn_AfxUnlockGlobals)(int nLockType);

_pfn_AfxLockGlobals     g_pfnAfxLockGlobals         = NULL;
_pfn_AfxUnlockGlobals   g_pfnAfxUnlockGlobals       = NULL;
CString *               g_csLockLib                 = NULL;
int                     g_csLockLibCount            = NULL;

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
    APIHOOK_ENUM_ENTRY(LoadLibraryExA) 
    APIHOOK_ENUM_ENTRY(LoadLibraryW) 
    APIHOOK_ENUM_ENTRY(LoadLibraryExW) 
    APIHOOK_ENUM_ENTRY(FreeLibrary)
APIHOOK_ENUM_END

/*++

 This function parses the COMMAND_LINE for the libraries you wish to ignore.

--*/

BOOL 
ParseCommandLine(
    LPCSTR lpszCommandLine
    )
{
    CSTRING_TRY
    {
        DPF(g_szModuleName, eDbgLevelInfo, "[ParseCommandLine] CommandLine(%s)\n", lpszCommandLine);

        CString csCl(lpszCommandLine);
        CStringParser csParser(csCl, L";");
    
        g_csLockLibCount    = csParser.GetCount();
        g_csLockLib         = csParser.ReleaseArgv();
    
        return TRUE;
    }
    CSTRING_CATCH
    {
        // Do nothing.
    }
    return FALSE;
}

HINSTANCE 
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    HINSTANCE     hRet;
    BOOL        bTakeLock = FALSE;

    if( g_pfnAfxLockGlobals && g_pfnAfxUnlockGlobals ) {

        if( g_csLockLibCount == 0 ) {
            bTakeLock = TRUE;
        } else {
            CSTRING_TRY
            {
                CString csFilePath(lpLibFileName);
                CString csFileName;
                csFilePath.GetLastPathComponent(csFileName);

                for (int i = 0; i < g_csLockLibCount; i++)
                {
                    if (g_csLockLib[i].CompareNoCase(csFileName) == 0)
                    {
                        LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryA] Caught attempt loading %ls, taking AfxResourceLock.", g_csLockLib[i].Get());
                        bTakeLock = TRUE;
                        break;
                    }
                }
            }
            CSTRING_CATCH
            {
                // Do Nothing
            }
        }
    }

    if( bTakeLock ) {
        (*g_pfnAfxLockGlobals)(0);
    }
    
    hRet = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    if( bTakeLock ) {
        (*g_pfnAfxUnlockGlobals)(0);
    }

    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryW)(
    LPCWSTR lpLibFileName
    )
{
    HINSTANCE     hRet;
    BOOL        bTakeLock = FALSE;

    if( g_pfnAfxLockGlobals && g_pfnAfxUnlockGlobals ) {
        if( g_csLockLibCount == 0 ) {
            bTakeLock = TRUE;
        } else {
            CSTRING_TRY
            {
                CString csFilePath(lpLibFileName);
                CString csFileName;
                csFilePath.GetLastPathComponent(csFileName);

                for (int i = 0; i < g_csLockLibCount; i++)
                {
                    if (g_csLockLib[i].CompareNoCase(csFileName) == 0)
                    {
                        LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryW] Caught attempt loading %ls, taking AfxResourceLock.", g_csLockLib[i].Get());
                        bTakeLock = TRUE;
                        break;
                    }
                }
            }
            CSTRING_CATCH
            {
                // Do Nothing
            }
        }
    }

    if( bTakeLock ) {
        (*g_pfnAfxLockGlobals)(0);
    }
    
    hRet = ORIGINAL_API(LoadLibraryW)(lpLibFileName);

    if( bTakeLock ) {
        (*g_pfnAfxUnlockGlobals)(0);
    }

    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryExA)(
    LPCSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    HINSTANCE     hRet;
    BOOL        bTakeLock = FALSE;

    if( g_pfnAfxLockGlobals && g_pfnAfxUnlockGlobals ) {
        if( g_csLockLibCount == 0 ) {
            bTakeLock = TRUE;
        } else {
            CSTRING_TRY
            {
                CString csFilePath(lpLibFileName);
                CString csFileName;
                csFilePath.GetLastPathComponent(csFileName);

                for (int i = 0; i < g_csLockLibCount; i++)
                {
                    if (g_csLockLib[i].CompareNoCase(csFileName) == 0)
                    {
                        LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryExA] Caught attempt loading %ls, taking AfxResourceLock.", g_csLockLib[i].Get());
                        bTakeLock = TRUE;
                        break;
                    }
                }
            }
            CSTRING_CATCH
            {
                // Do Nothing
            }
        }
    }

    if( bTakeLock ) {
        (*g_pfnAfxLockGlobals)(0);
    }

    hRet = ORIGINAL_API(LoadLibraryExA)(lpLibFileName, hFile, dwFlags);

    if( bTakeLock ) {
        (*g_pfnAfxUnlockGlobals)(0);
    }

    return hRet;
}

HINSTANCE 
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    HINSTANCE     hRet;
    BOOL        bTakeLock = FALSE;

    if( g_pfnAfxLockGlobals && g_pfnAfxUnlockGlobals ) {
        if( g_csLockLibCount == 0 ) {
            bTakeLock = TRUE;
        } else {
            CSTRING_TRY
            {
                CString csFilePath(lpLibFileName);
                CString csFileName;
                csFilePath.GetLastPathComponent(csFileName);

                for (int i = 0; i < g_csLockLibCount; i++)
                {
                    if (g_csLockLib[i].CompareNoCase(csFileName) == 0)
                    {
                        LOG(g_szModuleName,eDbgLevelError, "[LoadLibraryExW] Caught attempt loading %ls, taking AfxResourceLock.", g_csLockLib[i].Get());
                        bTakeLock = TRUE;
                        break;
                    }
                }
            }
            CSTRING_CATCH
            {
                // Do Nothing
            }
        }
    }

    if( bTakeLock ) {
        (*g_pfnAfxLockGlobals)(0);
    }

    hRet = ORIGINAL_API(LoadLibraryExW)(lpLibFileName, hFile, dwFlags);

    if( bTakeLock ) {
        (*g_pfnAfxUnlockGlobals)(0);
    }

    return hRet;
}

BOOL
APIHOOK(FreeLibrary)(
    HMODULE hModule
    )
{
    BOOL        bTakeLock = FALSE;
    BOOL        bRet;

    if( g_pfnAfxLockGlobals && g_pfnAfxUnlockGlobals ) {
        if( g_csLockLibCount == 0 ) {
            bTakeLock = TRUE;
        } else {
            WCHAR   wszModule[MAX_PATH];

            if( GetModuleFileNameW(hModule, wszModule, MAX_PATH) ) {
                CSTRING_TRY
                {
                    CString csFilePath(wszModule);
                    CString csFileName;
                    csFilePath.GetLastPathComponent(csFileName);

                    for (int i = 0; i < g_csLockLibCount; i++)
                    {
                        if (g_csLockLib[i].CompareNoCase(csFileName) == 0)
                        {
                            LOG(g_szModuleName,eDbgLevelError, "[FreeLibrary] Caught attempt freeing %ls, taking AfxResourceLock.", g_csLockLib[i].Get());
                            bTakeLock = TRUE;
                            break;
                        }
                    }
                }
                CSTRING_CATCH
                {
                    // Do Nothing
                }
            }
        }
    }

    if( bTakeLock ) {
        (*g_pfnAfxLockGlobals)(0);
    }

    bRet = ORIGINAL_API(FreeLibrary)(hModule);

    if( bTakeLock ) {
        (*g_pfnAfxUnlockGlobals)(0);
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        ParseCommandLine(COMMAND_LINE);
    } 
    else if( fdwReason == SHIM_STATIC_DLLS_INITIALIZED ) 
    {
        HMODULE hMod = LoadLibraryW(L"MFC42.DLL");
        if( NULL != hMod )
        {
            g_pfnAfxLockGlobals = (_pfn_AfxLockGlobals)GetProcAddress(hMod, (LPCSTR)1196);
            g_pfnAfxUnlockGlobals = (_pfn_AfxUnlockGlobals)GetProcAddress(hMod, (LPCSTR)1569);
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryExW)
    APIHOOK_ENTRY(KERNEL32.DLL, FreeLibrary)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\shockwavelocation.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

   ShockwaveLocation.cpp

 Abstract:

   In Encarta Encyclopedia 2000 J DVD, Shockwave is accessible only by installed user's HKCU.
   \WINDOWS\System32\Macromed\Director\SwDir.dll is looking for Shockwave location in HKCU.
   For other users, this shim will create Shockwave location registry in HKCU if Shockwave folder exist
   and not exist in registry.

   Example:
   HKCU\Software\Macromedia\Shockwave\location\coreplayer
   (Default) REG_SZ "C:\WINDOWS\System32\Macromed\Shockwave\"
   HKCU\Software\Macromedia\Shockwave\location\coreplayerxtras
   (Default) REG_SZ "C:\WINDOWS\System32\Macromed\Shockwave\Xtras\"

 Notes:

   PopulateDefaultHKCUSettings shim does not work for this case 'cause the location include
   WINDOWS directry as REG_SZ and cannot be a static data.
   VirtualRegistry shim Redirector also not work 'cause sw70inst.exe does not use Reg API
   and use SWDIR.INF to install in HKCU.

 History:

    04/27/2001  hioh        Created
    03/07/2002  robkenny    Security review.

--*/

#include "precomp.h"


IMPLEMENT_SHIM_BEGIN(ShockwaveLocation)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Add coreplayer & coreplayerxtras location in registry

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        HKEY    hKey;
        WCHAR   szRegCP[] = L"Software\\Macromedia\\Shockwave\\location\\coreplayer";
        WCHAR   szRegCPX[] = L"Software\\Macromedia\\Shockwave\\location\\coreplayerxtras";
        WCHAR   szLoc[MAX_PATH];

        // coreplayer
        if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, szRegCP, 0, KEY_QUERY_VALUE, &hKey))
        {   // key exist, do nothing
            RegCloseKey(hKey);
        }
        else
        {   // key not exist, set key
            UINT cchSystemDir = GetSystemDirectoryW(szLoc, ARRAYSIZE(szLoc));
            if (cchSystemDir > 0 && cchSystemDir < ARRAYSIZE(szLoc))
            {
                if (StringCchCatW(szLoc, MAX_PATH, L"\\Macromed\\Shockwave\\") == S_OK)
                {
                    if (GetFileAttributesW(szLoc) != 0xffffffff)
                    {   // folder exist, create key
                        if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, szRegCP, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL))
                        {   // set location
                            DWORD ccbLoc = (lstrlenW(szLoc) + 1) * sizeof(WCHAR);
                            RegSetValueExW(hKey, NULL, 0, REG_SZ, (BYTE*)szLoc, ccbLoc);

                            RegCloseKey(hKey);
                        }
                    }
                }
            }
        }

        // coreplayerxtras
        if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_CURRENT_USER, szRegCPX, 0, KEY_QUERY_VALUE, &hKey))
        {   // key exist, do nothing
            RegCloseKey(hKey);
        }
        else
        {   // key not exist, set key

            UINT cchSystemDir = GetSystemDirectoryW(szLoc, ARRAYSIZE(szLoc));
            if (cchSystemDir > 0 && cchSystemDir < ARRAYSIZE(szLoc))
            {
                if (StringCchCatW(szLoc, MAX_PATH, L"\\Macromed\\Shockwave\\Xtras\\") == S_OK)
                {
                    if (GetFileAttributesW(szLoc) != 0xffffffff)
                    {   // folder exist, create key
                        if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, szRegCPX, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, NULL))
                        {   // set location
                            DWORD ccbLoc = (lstrlenW(szLoc) + 1) * sizeof(WCHAR);
                            RegSetValueExW(hKey, NULL, 0, REG_SZ, (BYTE*)szLoc, ccbLoc);

                            RegCloseKey(hKey);
                        }
                    }
                }
            }
        }
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\speechviewer3.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    SpeechViewer3.cpp

 Abstract:

    The app requires ChangeDisplaySettings to cause a permanent mode change.

 Notes:

    This is an app specific shim.

 History:

    05/23/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SpeechViewer3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ChangeDisplaySettingsA) 
APIHOOK_ENUM_END

/*++

 Make the mode change permanent.

--*/

LONG 
APIHOOK(ChangeDisplaySettingsA)(
    LPDEVMODEA lpDevMode,  
    DWORD dwFlags         
    )
{
    if (dwFlags & CDS_FULLSCREEN) {
        dwFlags = 0;
    }
    return ORIGINAL_API(ChangeDisplaySettingsA)(lpDevMode, dwFlags);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, ChangeDisplaySettingsA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\solidworks99plus.cpp ===
/*++

 Copyright (c) 2000-2002 Microsoft Corporation

 Module Name:

    SolidWorks99Plus.cpp

 Abstract:

    This patches winhlp32.exe for calls to FTSRCH!OpenIndex only if they come from
    ROBOEX32.DLL. This needs to be written in the shim database otherwise the
    shim will be applied to all the apps using winhlp32.exe (which is bad!).
    
    Win2k's winhlp32.exe will only work with index files located in %windir%\Help
    so we need to redirect the location that the app points to.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000  clupu       Created
    08/05/2001  linstev     Added module checking
    03/12/2002  robkenny    Security review

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SolidWorks99Plus)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenIndex)
APIHOOK_ENUM_END

/*++

 Read the index file from %windir%\Help

--*/

int
APIHOOK(OpenIndex)(
    HANDLE    hsrch,
    char*     pszIndexFile,
    PBYTE     pbSourceName,
    PUINT     pcbSourceNameLimit,
    PUINT     pTime1,
    PUINT     pTime2
    )
{
    if (GetModuleHandleW(L"ROBOEX32.DLL")) {
        //
        // This is SolidWorks
        //
        char szBuff[MAX_PATH];

        DPF("SolidWorks99Plus",
           eDbgLevelInfo,
           "SolidWorks99Plus.dll, Changing OpenIndex file\n\tfrom: \"%s\".\n",
           pszIndexFile);

        UINT cchBuff = GetSystemWindowsDirectoryA(szBuff, MAX_PATH);
        if (cchBuff > 0 && cchBuff < MAX_PATH)
        {
            char * pszWalk = szBuff;
            const char * pszWalk2 = pszIndexFile + lstrlenA(pszIndexFile) - 1;

            while (pszWalk2 > pszIndexFile && *pszWalk2 != '/' && *pszWalk2 != '\\') {
                pszWalk2--;
            }

            if (*pszWalk2 == '/') {

                while (*pszWalk != 0) {
                    if (*pszWalk == '\\') {
                        *pszWalk = '/';
                    }
                    pszWalk++;
                }

                StringCchCatA(pszWalk, MAX_PATH, "/Help");
                StringCchCatA(pszWalk, MAX_PATH, pszWalk2);

            } else if (*pszWalk2 == '\\') {
                StringCchCatA(pszWalk, MAX_PATH, "/Help");
                StringCchCatA(pszWalk, MAX_PATH, pszWalk2);
            } else {
                StringCchCopyA(pszWalk, MAX_PATH, pszWalk2);
            }

            DPF("SolidWorks99Plus",
                eDbgLevelInfo,
                "SolidWorks99Plus.dll, \tto:   \"%s\".\n",
                szBuff);

            return ORIGINAL_API(OpenIndex)(hsrch, szBuff, pbSourceName,
                pcbSourceNameLimit, pTime1, pTime2);
        }
    }

    return ORIGINAL_API(OpenIndex)(hsrch, pszIndexFile, pbSourceName,
                                   pcbSourceNameLimit, pTime1, pTime2);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(FTSRCH.DLL, OpenIndex)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

TARGETNAME=AcSpecfc

TARGETTYPE=DYNLINK

INCLUDES = $(INCLUDES);..;$(SHELL_INC_PATH)

SOURCES=..\ver.rc                          \
        ..\Main.cpp                        \
        ..\3DFrogFrenzy.cpp                \
        ..\Acrobat5.cpp                    \
        ..\AdobeLiveMotion.cpp             \
        ..\AfterDark.cpp                   \
        ..\AliensVsPredator.cpp            \
        ..\AOLFindBundledInstaller_Shim.cpp                \
        ..\AOLFindBundledInstaller_AOLCode.cpp             \
        ..\AOLSystemInfo.cpp               \
        ..\AOLRasSetEntryProperties.cpp    \
        ..\Attune.cpp                      \
        ..\AutoCad.cpp                     \
        ..\AutoDeskWorld2.cpp              \
        ..\BaanERP5.cpp                    \
        ..\BaanERP5c.cpp                   \
        ..\BaanIV.cpp                      \
        ..\BackOffice45Suite.cpp           \
        ..\BackupExec.cpp                  \
        ..\Battleship.cpp                  \
        ..\BaseBall2000.cpp                \
        ..\BattleZone.cpp                  \
        ..\BeyondAtlantis.cpp              \
        ..\BigActionConstruction.cpp       \
        ..\BigGameHunter3.cpp              \
        ..\BizPlanBuilder.cpp              \
        ..\BoeingFix.cpp                   \
        ..\Britannica2001.cpp              \
        ..\Canvas6.cpp                     \
        ..\CanvasCheckedButtons.cpp        \
        ..\Casper.cpp                      \
        ..\ChemOffice.cpp                  \
        ..\Chollian2000.cpp                \
        ..\Chollian2000Plus.cpp            \
        ..\ClueFinders3rdGrade.cpp         \
        ..\CoffeeCupHTMLEditor.cpp         \
        ..\Commandos.cpp                   \
        ..\Cossacks.cpp                    \
        ..\ComptonsBible.cpp               \
        ..\CorelAppsRegistration.cpp       \
        ..\CorelDraw9JPN.cpp               \
        ..\CorelSiteBuilder.cpp            \
        ..\CreateResumesQuickandEasy.cpp   \
        ..\CreativeOnScreenDisplay.cpp     \
        ..\CrystalWebPageServer.cpp        \
        ..\CUSeeMe4.cpp                    \
        ..\Descent2.cpp                    \
        ..\DinosaurActivityCenter.cpp      \
        ..\DirtTrackRacing.cpp             \
        ..\DominantSpecies.cpp             \
        ..\DongFangKuaiChe3000Setup.cpp    \
        ..\DongFangYingDu.cpp              \
        ..\DrEye.cpp                       \
        ..\EA3dSetup.cpp                   \
        ..\EasyCDCreator4.cpp              \
        ..\EasyCDCreator5.cpp              \
        ..\EncartaEncyclopediaDeluxe2K.cpp \
        ..\EncompassMonitor.cpp            \
        ..\EuropeanAirWar.cpp              \
        ..\ExchangeServerSetup.cpp         \
        ..\F18Carrier.cpp                  \
        ..\FailSocket.cpp                  \
        ..\FireFighters.cpp                \
        ..\Force21.cpp                     \
        ..\Gangsters.cpp                   \
        ..\Gizmos.cpp                      \
        ..\HeroSDVD.cpp                    \
        ..\HotFaxMessageCenter4.cpp        \
        ..\HoyleGames.cpp                  \
        ..\HPTourguide.cpp                 \
        ..\HTMLEditor8587.cpp              \
        ..\IConfig.cpp                     \
        ..\IE5DOMSetup.cpp                 \
        ..\ImageCast.cpp                   \
        ..\ISA.cpp                         \
        ..\ISA2.cpp                        \
	    ..\ISA2000SP1.cpp	               \
        ..\ISpeed.cpp                      \
        ..\InstallShield6.cpp              \
        ..\InstantCDDVD.cpp                \
        ..\IntelVideoPhone.cpp             \
        ..\JavaVM.cpp                      \
        ..\JavaVM2.cpp                     \
        ..\JetFighter4.cpp                 \
        ..\Keisoku7.Cpp                    \
        ..\KingsQuestMask.cpp              \
        ..\KOEISecurityCheck.cpp           \
        ..\LHVoiceXPressPlus.cpp           \
        ..\LinksExtreme.cpp                \
        ..\LotusOrganizer5.cpp             \
        ..\MahjonggMadness.cpp             \
        ..\MastersOfOrion2.cpp             \
        ..\MathBlaster9_12.cpp             \
        ..\MaxPayne.cpp                    \
        ..\MECCommander.cpp                \
        ..\MechWarrior2.cpp                \
        ..\MidTownMadness2.cpp             \
        ..\Millionaire.cpp                 \
        ..\MindSpring4.cpp                 \
        ..\ModemWizard.cpp                 \
        ..\Money2001.cpp                   \
        ..\Money2002.cpp                   \
        ..\MSAccess2000IME.cpp             \
        ..\MSDevDisabledButtons.cpp        \
        ..\MSWorks6.cpp                    \
        ..\Mutek.cpp                       \
        ..\MyPhotoCenter2.cpp              \
        ..\NBALive.cpp                     \
        ..\NetBackup45.cpp                 \
        ..\NetZip.cpp                      \
        ..\NetObjectsFusion5.cpp           \
        ..\NetManageViewNow.cpp            \
        ..\NewShenDiaoXiaLv.cpp            \
        ..\NFLBlitz.cpp                    \
        ..\NFLFever2000.cpp                \
        ..\NHL2001.cpp                     \
        ..\NikonView.cpp                   \
        ..\Office9ComplexScript.cpp        \
        ..\OfficeTS.cpp                    \
        ..\Omikron.cpp                     \
        ..\OmniPagePro.cpp                 \
        ..\OmniPagePro11Uninstall.cpp      \
	..\OperationsManager.cpp	   \
        ..\Outlook2000.cpp                 \
        ..\Outlook97.cpp                   \
        ..\Outlook98Wizard.cpp             \
        ..\OverlayPro.cpp                  \
        ..\PanzerCommander.cpp             \
        ..\Patrol.cpp                      \
        ..\Petz.cpp                        \
        ..\PickyEater.cpp                  \
        ..\Pirch98.cpp                     \
        ..\PlaneCrazy.cpp                  \
        ..\PostIt2.cpp                     \
        ..\PowerBuilder.cpp                \
        ..\Ppo3svrScr.cpp                  \
        ..\PrintMaster4.cpp                \
        ..\ProAtlas2000.cpp                \
        ..\QuickBooks8.cpp                 \
        ..\Quicken2000.cpp                 \
        ..\Quicken2001.cpp                 \
        ..\QuickTime5.cpp                  \
        ..\Resonate.cpp                    \
        ..\RCenter.cpp                     \
        ..\ResumeWriter3.cpp               \
        ..\ReturnToKrondor.cpp             \
        ..\RiskII.cpp                      \
        ..\Riven.cpp                       \
        ..\RumbaOffice.cpp                 \
        ..\SafeDisc.cpp                    \
        ..\SchoolHouseRockMath.cpp         \
        ..\Settlers3.cpp                   \
        ..\SevenKingdoms.cpp               \
        ..\ShockwaveLocation.cpp           \
        ..\SierraCartRacing.cpp            \
        ..\Simply3D.cpp                    \
        ..\SirenJukebox2.cpp               \
	..\SMSDeadlock.cpp		   \
        ..\SolidWorks99Plus.cpp            \
        ..\SpecOps2.cpp                    \
        ..\SpeechViewer3.cpp               \
        ..\StoneAge.Cpp                    \
	..\Suda2000.cpp                    \
        ..\Summoner.cpp                    \
        ..\SuperBike.cpp                   \
        ..\SuperChix76.cpp                 \
        ..\SysAdmiral.cpp                  \
        ..\TaskbarAndStartMenuProperty.cpp \
        ..\ThreedJungleTrain.cpp           \
        ..\TimeSlips.cpp                   \
        ..\TonkaConstruction.cpp           \
        ..\TreasureCove.cpp                \
        ..\TurkeyHunter.cpp                \
        ..\TwinssensOdyssey.cpp            \
        ..\Ultima9.cpp                     \
        ..\UltimateSoccerManager.cpp       \
        ..\UltraWinCleaner2002.cpp         \
        ..\UnInstallShield.cpp             \
        ..\UrbanChaos.cpp                  \
        ..\USNF97.cpp                      \
        ..\ViaVoice8J.cpp                  \
        ..\ViperRacing.cpp                 \
        ..\VJEDelta.cpp                    \
        ..\VJEDeltaSetup.cpp               \
        ..\VSAnalyzerServerSetup.cpp       \
        ..\WebPage6.cpp                    \
        ..\WinFaxPro9.cpp                  \
        ..\WinStone99.cpp                  \
        ..\WordPerfect8.cpp                \
        ..\WordPerfect9_1.cpp              \
        ..\Wordperfect9_2.cpp              \
        ..\Wordperfect9_3.cpp              \
        ..\WordPerfectPresentation10.cpp   \
        ..\WorksSuite2001.cpp              \
        ..\Works99.cpp                     \
        ..\Worms2.cpp                      \
        ..\Wps2000.cpp                     \
        ..\ZenWorks.cpp


C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\gdi32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\ole32.lib \
           $(SDK_LIB_PATH)\shell32.lib \
           $(SDK_LIB_PATH)\winmm.lib \
           $(SDK_LIB_PATH)\ddraw.lib \
           $(SDK_LIB_PATH)\userenv.lib \
           $(SDK_LIB_PATH)\Mpr.lib \
           $(SDK_LIB_PATH)\psapi.lib \
           $(SDK_LIB_PATH)\comdlg32.lib \
           $(SDK_LIB_PATH)\imm32.lib \
           $(SDK_LIB_PATH)\ws2_32.lib

TARGETPATH=$(_OBJ_DIR)

DLLBASE=0x21000000

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\specops2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SpecOps2.cpp

 Abstract:

    App does too much within a DLLMain and hangs because dinput is waiting on 
    a thread it just created.

    The fix is to prevent the DllMain from running during the loader lock. The 
    only way to do this seems to be to hook an API that's called really early 
    during the DllMain and jump back to the loader. 

    The catch is that we still need to call the DllMain after the LoadLibrary 
    has completed.

 Notes:

    This is an app specific shim.

 History:

    05/01/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SpecOps2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersion)
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END

// Global state used to determine what to do for a particular call
BOOL g_bState = FALSE;

// The thread handle for matching synchronization logic
HANDLE g_hThread = NULL;

/*++

 This is the first API that the DllMain calls, so we're going to back out 
 jump straight out of it, back into loader code as if it completed normally.

--*/

__declspec(naked)
DWORD
APIHOOK(GetVersion)(
    void
    )
{
    __asm {
        // 
        // Make sure we're on the right thread so we don't have to synchronize
        //
        call dword ptr [GetCurrentThread]
        cmp  eax, g_hThread
        jne  Exit                       

        // test for the right dll
        cmp  g_bState, 1
        jne  Exit                
        
        // we're done
        mov  g_bState, 0                

        // leave the stack and registers as they were before
        add  esp, 20
        pop  edi
        pop  esi
        pop  ebx
        pop  ebp
        ret  12                         

    Exit:

        // original api
        call dword ptr [GetVersion]     
        ret
    }
}

/*++

 When "SO Menu.dll" is loaded, we start the sequence which prevents the DllMain 
 from crashing, but it means we have to run the entry point after the load.

--*/

HINSTANCE
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName
    )
{
    BOOL bCheck = FALSE;
    if (_stricmp(lpLibFileName, "menu\\SO Menu.dll") == 0) {
        //
        // We assume *only* the main thread tries to load this library, so
        // we don't synchronize multiple threads trying to load this same dll
        //
        g_hThread = GetCurrentThread();
        bCheck = TRUE;
        g_bState = TRUE;
    }
        
    //
    // Load the library, if it's "SO Menu", we'll catch the GetVersion called 
    // by its DllMain
    //

    HMODULE hMod = ORIGINAL_API(LoadLibraryA)(lpLibFileName);

    if (hMod && bCheck) {
        //
        // Run the DllMain
        //
        typedef BOOL (WINAPI *_pfn_DllMain)(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);

        PIMAGE_DOS_HEADER pIDH = (PIMAGE_DOS_HEADER) hMod;
        PIMAGE_NT_HEADERS pINTH = (PIMAGE_NT_HEADERS)((LPBYTE)hMod + pIDH->e_lfanew);
        _pfn_DllMain pfnMain = (_pfn_DllMain)((LPBYTE)hMod + pINTH->OptionalHeader.AddressOfEntryPoint);
        
        // Call the startup routine
        (*pfnMain)(hMod, DLL_PROCESS_ATTACH, NULL);
    }

    return hMod;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)
    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\stoneage.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    StoneAge.cpp

 Abstract:

    The app is trying to create a window with NULL WndProc, and later it seems does
    not really use it , and just launch the installshield setup program and exit.
    Fix this by providing a dummy WndProc. 

    BUGBUG: Need to add to EmulateUSER when possible.

 Notes: 
  
    This is an app specific shim.

 History:

    06/09/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(StoneAge)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegisterClassExA) 
APIHOOK_ENUM_END

/*++

 Set the WndProc to DefWndProc if it's NULL.

--*/

ATOM 
APIHOOK(RegisterClassExA)(
    CONST WNDCLASSEXA *lpwcx  // class data
    )
{
    if (!(lpwcx->lpfnWndProc)) {
        WNDCLASSEXA wcNewWndClassEx = *lpwcx;
        
        LOGN(eDbgLevelError, "[RegisterClassExA] Null WndProc specified - correcting.");

        wcNewWndClassEx.lpfnWndProc = DefWindowProcA;

        return ORIGINAL_API(RegisterClassExA)(&wcNewWndClassEx);
    }
    else
    {
        return ORIGINAL_API(RegisterClassExA)(lpwcx);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, RegisterClassExA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\sysadmiral.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SysAdmiral.cpp

 Abstract:

    Application's service control routine does not properly restore the stack 
    when returning.

 History:

    10/22/2001  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SysAdmiral)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(StartServiceCtrlDispatcherA)
APIHOOK_ENUM_END

typedef BOOL (* _pfn_StartServiceCtrlDispatcherA)(CONST LPSERVICE_TABLE_ENTRYA lpServiceTable);

/*++

 0x12345678 is replaced with the original service control routine's address

--*/

__declspec(naked)
void 
Stub()
{
    __asm
    {
        // save the current stack pointer in ESI
        push    esi
        mov     esi, esp

        mov     eax, 0x12345678

        // push the arguments to the routine
        push    [esi+0xc]
        push    [esi+0x8]

        // call the routine
        call    eax

        // Restore the stack to its value before the routine.
        mov     esp, esi
        pop     esi

        ret     0x8
    }
}

#define Stub_OrigApi_Offset     0x4
#define STUB_SIZE               0x20

/*++

 Create an in-memory routine to save and restore the stack.

 This is used rather than a subroutine because we cannot pass any parameters 
 to the routine and it needs to know the address of the original service 
 routine.  A subroutine would have to use a global pointer to the service 
 routine, limiting this shim to handling only a *single* service routine.  

--*/

LPSERVICE_MAIN_FUNCTIONA
BuildStackSaver(LPSERVICE_MAIN_FUNCTIONA lpServiceProc)
{
    // Create the stub
    LPBYTE pStub = (LPBYTE) VirtualAlloc(
        0, 
        STUB_SIZE,
        MEM_COMMIT, 
        PAGE_EXECUTE_READWRITE);

    if (!pStub)
    {
        DPFN( eDbgLevelError, "Could not allocate memory for stub");
        return NULL;
    }         

    // Copy the template code into the memory.
    MoveMemory(pStub, Stub, STUB_SIZE);

    // Replace the place holding function pointer
    DWORD_PTR * origApi = (DWORD_PTR *)(pStub + Stub_OrigApi_Offset);
    *origApi = (DWORD_PTR)lpServiceProc;

    return (LPSERVICE_MAIN_FUNCTIONA)pStub;
}

/*++

 Application's service routine does not properly restore the stack when returning.

--*/

BOOL
APIHOOK(StartServiceCtrlDispatcherA)(
    CONST LPSERVICE_TABLE_ENTRYA lpServiceTable   // service table
    )
{
    SERVICE_TABLE_ENTRYA myServiceTable = *lpServiceTable;

    //
    // Create our in-memory stack restoring functiono
    //

    myServiceTable.lpServiceProc = BuildStackSaver(lpServiceTable->lpServiceProc);
    if (myServiceTable.lpServiceProc)
    {
        return ORIGINAL_API(StartServiceCtrlDispatcherA)(&myServiceTable);
    }
    else
    {
        return FALSE;
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, StartServiceCtrlDispatcherA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\summoner.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   Summoner.cpp

 Abstract:

    They don't correctly detect 3DFX Voodoo cards. This fix changes the driver 
   name from 3dfx to something else.

 Notes:

    This is an app specific shim.

 History:

    05/22/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Summoner)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

/*++

 Change the driver name for GetDeviceIdentifier

--*/

HRESULT 
COMHOOK(IDirectDraw7, GetDeviceIdentifier)(
    PVOID pThis, 
    LPDDDEVICEIDENTIFIER2 lpDeviceIdentifier,
   UINT dwFlags
   )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw7_GetDeviceIdentifier pfnOld = 
        ORIGINAL_COM(IDirectDraw7, GetDeviceIdentifier, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(pThis, lpDeviceIdentifier, dwFlags))) {
      //
      // Check the driver name
      //
      if (_stricmp(lpDeviceIdentifier->szDriver, "3dfxvs.dll") == 0) {
         //
         // This app doesn't like 3dfx for some reason
         //
         StringCchCopyA(lpDeviceIdentifier->szDriver, MAX_DDDEVICEID_STRING, "temp.dll");
      }
    }

    return hReturn;
}
   
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, GetDeviceIdentifier, 27)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\superbike.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    SuperBike.cpp

 Abstract:

    The application attempts to convert the path to the executable into the directory
    containing the executable by replacing the last \ in the path with NULL.
    Unfortunately, they start not at the end of the string, but at the max length
    of the string.  On Win9x the extra memory doesn't (coincidentally) have a \,
    so the proper string is passed as the CWD to CreateProcessA.  On Whistler,
    the extra memory contains a \ so they end up changing nothing.


 History:

    10/26/2000  robkenny    Created
    03/13/2001  robkenny    Converted to CString

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SuperBike)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END

/*++

 Make sure lpCurrentDirectory points to a directory, not an executable

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CSTRING_TRY
    {
        CString csDir(lpCurrentDirectory);
        char * duplicate = NULL;

        if (!csDir.IsEmpty())
        {
            DWORD dwFileAttr = GetFileAttributesW(csDir);
            if (dwFileAttr != -1 &&                             // Doesn't exist
                ( ! (FILE_ATTRIBUTE_DIRECTORY & dwFileAttr)))   // Is not a directory
            {
                csDir.StripPath();
            }
            BOOL bStat = ORIGINAL_API(CreateProcessA)(
                        lpApplicationName,
                        lpCommandLine,
                        lpProcessAttributes,
                        lpThreadAttributes,
                        bInheritHandles,
                        dwCreationFlags,
                        lpEnvironment,
                        csDir.GetAnsiNIE(), // our corrected value
                        lpStartupInfo,
                        lpProcessInformation);

            return bStat;
            
        }
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    BOOL bStat = ORIGINAL_API(CreateProcessA)(
        lpApplicationName,
        lpCommandLine,
        lpProcessAttributes,
        lpThreadAttributes,
        bInheritHandles,
        dwCreationFlags,
        lpEnvironment,
        lpCurrentDirectory,
        lpStartupInfo,
        lpProcessInformation);
    
    return bStat;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\suda2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    Suda2000.cpp

 Abstract:

    Call to GetTempPathA is not getting enough buffer and it is returning some 
    garbage value, so GetTempFileNameA fails. This hooked API, GetTempPathA 
    returns a constant string "%temp%". GetTempFileNameA expands the environment 
    variable ("%temp%") and returns a valid path name.

 History:

    06/15/2001  mamathas   Created
 
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Suda2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetTempPathA) 
    APIHOOK_ENUM_ENTRY(GetTempFileNameA) 
APIHOOK_ENUM_END

/*++

 This stub function intercepts all calls to GetTempPathA and sets lpBuffer[out] 
 with a constant string "%temp%" and returns the length.
 
--*/

DWORD
APIHOOK(GetTempPathA)(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    LOGN(eDbgLevelError,
        "GetTempPathA: Returns invalid Temp Path (%S)\n Changed to %tmp%", lpBuffer);

    StringCchCopyA(lpBuffer, nBufferLength, "%temp%");
    
    return strlen(lpBuffer);
}

/*++

 This stub function intercepts all calls to GetTempFileNameA and sets lpPathName 
 with valid path and then calls the original API.
  
--*/

UINT
APIHOOK(GetTempFileNameA)(
    LPCTSTR lpPathName,      // directory name
    LPCTSTR lpPrefixString,  // file name prefix
    UINT uUnique,            // integer for use in creating the temporary file name
    LPTSTR lpTempFileName    // file name buffer
    )
{
    CHAR szDestinationString[MAX_PATH];
    ZeroMemory(szDestinationString, MAX_PATH);

    ExpandEnvironmentStringsA((LPCSTR)lpPathName, (LPSTR)szDestinationString,  MAX_PATH);

    LOGN(eDbgLevelInfo,
         "ExpandEnvironmentStringsA: Returned the value of environment variable, \"%temp%\" =  (%S) ", szDestinationString);
    
    return ORIGINAL_API(GetTempFileNameA)((LPCSTR)szDestinationString, (LPCSTR)lpPrefixString,uUnique,(LPSTR)lpTempFileName);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempPathA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetTempFileNameA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\threedjungletrain.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    ThreeDJungleTrain.cpp

 Abstract:

    ThreedJungleTrain created a new DirectSound object every time
    it entered the "3D Train Ride" part of the game, and destroyed
    the object every time it went to a "2D interior" part.  It was
    keeping and using an old pointer to the first DirectSound object
    it ever created even after it was destroyed.  It was only luck that
    Win9x would continue to allocate new objects in the same place that
    allowed the game to work.  This shim never allows the release of
    that first object and then continues to hand back pointers to the
    first object when new objects are requested so that the old pointer
    the app uses always points to a (the) valid DirectSound object.

 History:

    08/09/2000 t-adams Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ThreeDJungleTrain)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_ENTRY(DirectSoundCreate) 
APIHOOK_ENUM_END


// Pointer to the first DirectSound object created.
LPDIRECTSOUND g_pDS = NULL;

/*++

Hook DirectSoundCreate to remeber the first DS object created and afterwards
return a pointer to that object when new DS objects are requested.

--*/
HRESULT
APIHOOK(DirectSoundCreate)(
    LPCGUID lpcGuid, 
    LPDIRECTSOUND *ppDS, 
    LPUNKNOWN pUnkOuter)
{
    HRESULT hRet = DS_OK;

    // Check to see if we have an old DS yet.
    if( NULL == g_pDS ) {
        // If not, then get a new DS 
        hRet = ORIGINAL_API(DirectSoundCreate)(lpcGuid, ppDS, pUnkOuter);

        if ( DS_OK == hRet )
        {
            HookObject(
                NULL, 
                IID_IDirectSound, 
                (PVOID*)ppDS, 
                NULL, 
                FALSE);
            g_pDS = *ppDS;
        }

        goto exit;
    
    } else {
        // If so, then give back the old DS
        *ppDS = g_pDS;
        goto exit;
    }
    
exit:        
    return hRet;
}

/*++

Hook IDirectSound_Release so DirectSound object isn't released.

--*/
HRESULT 
COMHOOK(IDirectSound, Release)(
    PVOID pThis)
{
    // Don't release.
    return 0;
}

/*++

 Release global DirectSound object.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {
        if (NULL != g_pDS) {
            ORIGINAL_COM(IDirectSound, Release, g_pDS)(g_pDS);
        }
    }

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(DSOUND.DLL, DirectSoundCreate)

    COMHOOK_ENTRY(DirectSound, IDirectSound, Release, 2)

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\taskbarandstartmenuproperty.cpp ===
/*++

 Copyright (c) 2000-2001 Microsoft Corporation

 Module Name:

   TaskbarAndStartMenuProperty.cpp

 Abstract:

   Show Taskbar and Start Menu Properties dialog.

   This is originally for Hebrew App "Itzrubal Pro" that uses full screen and hide taskbar.
   The App launch always causes Taskbar and Start Menu Properties dialog pop up.
   When the dialog pop up on top of App during app loading, the App causes hung up.
   If the dialog exist prior to App launch, the dialog lose focus and App loaded successfully.

 History:

    07/13/2001  hioh     Created
    01/29/2002  hioh     Buffer overrun fix 518325

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TaskbarAndStartMenuProperty)
#include "ShimHookMacro.h"

//
// No APIs
//
APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

/*++

 Run Taskbar and Start Menu
 
--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED)
    {
        WCHAR               szCommandLine[] = L"rundll32.exe shell32.dll,Options_RunDLL 1";
        WCHAR               szCurrentDirectry[MAX_PATH];
        STARTUPINFO         StartupInfo;
        PROCESS_INFORMATION ProcessInformation;

        GetCurrentDirectoryW(sizeof(szCurrentDirectry)/sizeof(szCurrentDirectry[0]), szCurrentDirectry);

        StartupInfo.cb = sizeof(STARTUPINFO);
        StartupInfo.lpReserved = NULL;
        StartupInfo.lpDesktop = NULL;
        StartupInfo.lpTitle = NULL;
        StartupInfo.dwFlags = 0;
        StartupInfo.cbReserved2 = 0;
        StartupInfo.lpReserved2 = NULL;

        CreateProcessW(
            NULL,                   // name of executable module
            szCommandLine,          // command line string
            NULL,                   // SD
            NULL,                   // SD
            FALSE,                  // handle inheritance option
            CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT | CREATE_DEFAULT_ERROR_MODE,
                                    // creation flags
            NULL,                   // new environment block
            szCurrentDirectry,      // current directory name
            &StartupInfo,           // startup information
            &ProcessInformation     // process information
            );
    }
    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\superchix76.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    SuperChix76.cpp

 Abstract:

    Hook LoadLibrary and calls GetDeviceIdentifier which initializes wintrust. 
    
    This fixes the problem whereby the app will hang if they call 
    GetDeviceIdentifier from within a DllMain - which is an app bug.

 Notes:

    This is an app specific shim.

 History:

    10/22/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SuperChix76)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(LoadLibraryA) 
APIHOOK_ENUM_END

/*++

 Hook LoadLibrary and detect their dll.

--*/

HINSTANCE 
APIHOOK(LoadLibraryA)(
    LPCSTR lpLibFileName   
    )
{
    if (stristr(lpLibFileName, "did3d"))
    {
        LPDIRECTDRAW g_pDD;
        LPDIRECTDRAW7 g_pDD7;
    
        if (0 == DirectDrawCreate(NULL, &g_pDD, NULL))
        {
            if (0 == g_pDD->QueryInterface(IID_IDirectDraw7, (void **)&g_pDD7))
            {
                DDDEVICEIDENTIFIER2 devid;
                DWORD dwBlank[16];  // GetDeviceIdentifier writes passed it's allocation
                g_pDD7->GetDeviceIdentifier(&devid, 0);
                g_pDD7->Release();
            }
            g_pDD->Release();
        }
       
    }

    return ORIGINAL_API(LoadLibraryA)(lpLibFileName);
}
 
/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, LoadLibraryA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\timeslips.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TimeSlip.cpp

 Abstract:

    Convert the command line to use short path names for both the app and the first (and only) argument.
    
    Example:
    C:\program files\accessories\wordpad.exe c:\program files\some app\some data.txt
    C:\Progra~1\access~1\wordpad.exe C:\Progra~1\someap~1\someda~1.txt

 Created:

    01/23/2001  robkenny    Created
    03/13/2001  robkenny    Converted to CString


--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TimeSlips)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA)
APIHOOK_ENUM_END

char * g_lpCommandLine = NULL;

/*++

 Convert the application name to the short path to remove any spaces.

--*/

LPSTR 
APIHOOK(GetCommandLineA)(
    void
    )
{
    if (g_lpCommandLine == NULL)
    {
        LPSTR lpszOldCmdLine = ORIGINAL_API(GetCommandLineA)();
        AppAndCommandLine  appCmdLine(NULL, lpszOldCmdLine);

        CString csArg1 = appCmdLine.GetCommandlineNoAppName();
        csArg1.GetShortPathNameW();

        CString csCL = appCmdLine.GetApplicationName();
        csCL.GetShortPathNameW();
        csCL += L" ";
        csCL += csArg1;

        if (csCL.IsEmpty())
        {
            // We didn't change the CL, use the system value.
            g_lpCommandLine = lpszOldCmdLine;
        }
        else
        {
            g_lpCommandLine = csCL.ReleaseAnsi();

            LOGN(
                eDbgLevelError,
                "[GetCommandLineA] Changed \"%s\" to \"%s\".",
                lpszOldCmdLine, g_lpCommandLine);
        }
    }

    return g_lpCommandLine;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\twinssensodyssey.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TwinssensOdyssey.cpp

 Abstract:

    Return 0x347 when GetProcessorSpeed is called.

 Notes:

    This is an app specific shim.

 History:

    12/30/1999 a-vales  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TwinssensOdyssey)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetProcessorSpeed) 
APIHOOK_ENUM_END

/*++

 Return 0x347 when GetProcessorSpeed is called.

--*/

int 
APIHOOK(GetProcessorSpeed)()
{
    return 0x347;
}

/*++

 Register hooked functions

--*/


HOOK_BEGIN

    APIHOOK_ENTRY(GETINFO.DLL, GetProcessorSpeed)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\turkeyhunter.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    TurkeyHunter.cpp

 Abstract:

    In Win9x, IDirectDraw::GetDC simply locks the surface and creates a DC 
    around it via internal GDI calls. On NT, GDI supports DCs obtained from 
    DirectDraw surfaces. 

    Some games, like Turkey Hunter, use Surface::Unlock to get usage of the 
    surface back, instead of Surface::ReleaseDC. Ordinarily we could simply 
    make the unlock call the DirectDraw ReleaseDC, except that they continue 
    using the DC after they've unlocked the surface.

 Notes:

    This is a general purpose hack.

 History:

    01/20/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TurkeyHunter)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

// Link list of open DCs
struct DC
{
    DC *next;
    HDC hdc;
    HBITMAP hbmp;
    DWORD dwWidth, dwHeight;
    LPDIRECTDRAWSURFACE lpDDSurface;
    BOOL bBad;
};
DC *g_DCList = NULL;

HRESULT 
COMHOOK(IDirectDrawSurface, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface, 
    HDC hDC);

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 Fake a DC - or rather produce a normal GDI DC that doesn't have the surface
 memory backing it.
 
--*/

HRESULT
COMHOOK(IDirectDrawSurface, GetDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC FAR *lphDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    _pfn_IDirectDrawSurface_ReleaseDC pfnOldReleaseDC = NULL;
    _pfn_IDirectDrawSurface_GetDC pfnOld = NULL;
    DDSURFACEDESC ddsd = {sizeof(DDSURFACEDESC)};
    HDC hdc = 0;
    HBITMAP hbmp = 0;
    HGDIOBJ hOld = 0;
    DC *pdc = NULL;

    if (!lphDC || !lpDDSurface)
    {
        DPFN( eDbgLevelError, "Invalid parameters");
        goto Exit;
    }

    // Original GetDC
    pfnOld = ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID) lpDDSurface);

    if (!pfnOld)
    {
        DPFN( eDbgLevelError, "Old GetDC not found");
        goto Exit;
    }
    
    if (FAILED(hReturn = (*pfnOld)(
            lpDDSurface, 
            lphDC)))
    {
        DPFN( eDbgLevelError, "IDirectDraw::GetDC Failed");
        goto Exit;
    }

    // We need the surface desc for the surface width and height
    lpDDSurface->GetSurfaceDesc(&ddsd);
    
    // Create a DC to be used by the app
    hdc = CreateCompatibleDC(0);
    if (!hdc)
    {
        DPFN( eDbgLevelError, "CreateDC failed");
        goto Exit;
    }

    // Create the DIB Section
    BITMAPINFO bmi;
    ZeroMemory(&bmi, sizeof(bmi));
    bmi.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biPlanes   = 1;
    bmi.bmiHeader.biBitCount = 24;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biWidth    = ddsd.dwWidth;
    bmi.bmiHeader.biHeight   = ddsd.dwHeight;
    hbmp = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, NULL, NULL, 0);

    if (!hbmp)
    {
        DPFN( eDbgLevelError, "CreateDIBSection failed");
        goto Exit;
    }

    // Select the DIB Section into the DC
    hOld = SelectObject(hdc, hbmp);
    BitBlt(hdc, 0, 0, ddsd.dwWidth, ddsd.dwHeight, *lphDC, 0, 0, SRCCOPY);
    
    // Original ReleaseDC
    pfnOldReleaseDC = 
        ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDSurface);

    if (!pfnOldReleaseDC)
    {
        DPFN( eDbgLevelError, "Old ReleaseDC not found");
        goto Exit;
    }
    // Release the DirectDraw DC
    (*pfnOldReleaseDC)(lpDDSurface, *lphDC);
    
    // Return the DC we just created
    *lphDC = hdc;

    // Add this to our DC list
    pdc = (DC *) malloc(sizeof DC);
    if (pdc)
    {
        pdc->next = g_DCList;
        g_DCList = pdc;
        pdc->hdc = hdc;
        pdc->lpDDSurface = lpDDSurface;
        pdc->hbmp = hbmp;
        pdc->dwHeight = ddsd.dwHeight;
        pdc->dwWidth = ddsd.dwWidth;
        pdc->bBad = FALSE;
    }
    else
    {
        DPFN( eDbgLevelError, "Out of memory");
        goto Exit;
    }

    hReturn = DD_OK;

Exit:
    if (hReturn != DD_OK)
    {
        if (hOld && hdc)
        {
            SelectObject(hdc, hOld);
        }

        if (hbmp)
        {
            DeleteObject(hbmp);
        }

        if (hdc)
        {
            DeleteDC(hdc);
        }
    }
    
    return DD_OK;
}

/*++

 ReleaseDC has to copy the data back into the surface.

--*/

HRESULT
COMHOOK(IDirectDrawSurface, ReleaseDC)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    HDC hDC
    )
{
    HRESULT hReturn = DDERR_GENERIC;
    
    // Original ReleaseDC
    _pfn_IDirectDrawSurface_ReleaseDC pfnOld = 
            ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDSurface);


    // Run the list to see if we need to do anything
    DC *pdc = g_DCList, *last = NULL;
    while (pdc)
    {
        if ((pdc->lpDDSurface == lpDDSurface) && 
            (pdc->hdc == hDC))
        {
            // Remove it from the list
            if (last)
            {
                last->next = pdc->next;
            }
            else
            {
                g_DCList = pdc->next;
            }
            break;
        }
        last = pdc;
        pdc = pdc->next;
    }

    // We were in the list and someone used Unlock.
    if (pdc && (pdc->bBad))
    {
        // Original GetDC
        _pfn_IDirectDrawSurface_GetDC pfnOldGetDC = 
            ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID)pdc->lpDDSurface);

        // Original ReleaseDC
        _pfn_IDirectDrawSurface_ReleaseDC pfnOldReleaseDC = 
                ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID)pdc->lpDDSurface);

        if (pfnOldGetDC && pfnOldReleaseDC)
        {
            // Copy everything back onto the surface
            HDC hTempDC;
            HGDIOBJ hOld = SelectObject(hDC, pdc->hbmp);
            if (SUCCEEDED((*pfnOldGetDC)(pdc->lpDDSurface, &hTempDC)))
            {
                BitBlt(hTempDC, 0, 0, pdc->dwWidth, pdc->dwHeight, hDC, 0, 0, SRCCOPY);
                (*pfnOldReleaseDC)(pdc->lpDDSurface, hTempDC);
            }
            SelectObject(hDC, hOld);
        
            // Delete the DIB Section
            DeleteObject(pdc->hbmp);

            // Delete the DC
            DeleteDC(hDC);

            hReturn = DD_OK;
        }
    }
    else
    {
        if (pfnOld)
        {
            // Didn't need to fake 
            hReturn = (*pfnOld)(lpDDSurface, hDC);
        }
    }
    
    // Free the list item
    if (pdc) 
    {
        free(pdc);
    }

    return hReturn;
}

/*++
 
 This is where we detect if Surface::Unlock was called after a Surface::GetDC.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Unlock)(
    LPDIRECTDRAWSURFACE lpDDSurface,
    LPVOID lpSurfaceData
    )
{
    HRESULT hRet = DDERR_GENERIC;

    // Walk the list to see if we're in it.
    DC *pdc = g_DCList;
    while (pdc)
    {
        if (pdc->lpDDSurface == lpDDSurface)
        {
            pdc->bBad = TRUE;
            break;    
        }
        pdc = pdc->next;
    }

    if (!pdc)
    {
        // Original Unlock
        _pfn_IDirectDrawSurface_Unlock pfnOld = 
                ORIGINAL_COM(IDirectDrawSurface, Unlock, (LPVOID)lpDDSurface);

        if (pfnOld)
        {
            // This is just a normal unlock
            hRet = (*pfnOld)(lpDDSurface, lpSurfaceData);
        }
    }
    else
    {
        // We never really locked in the first place, so no harm done.
        hRet = DD_OK;
    }

    return hRet;
}

/*++

 This is a problem case where they Blt after the Surface::Unlock, but before
 the Surface::ReleaseDC.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    HRESULT hRet = DDERR_GENERIC;

    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = 
        ORIGINAL_COM(IDirectDrawSurface, Blt, (LPVOID) lpDDDestSurface);

    if (!pfnOld)
    {
        return hRet;
    }

    // Are we in the bad state
    DC *pdc = g_DCList;
    while (pdc)
    {
        if (pdc->lpDDSurface == lpDDDestSurface)
        {
            break;    
        }
        pdc = pdc->next;
    }

    if (!pdc)
    {
        return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
    }

    // To get here, there must be an outstanding DC on this surface
    
    // Original GetDC 
    _pfn_IDirectDrawSurface_GetDC pfnOldGetDC = 
            ORIGINAL_COM(IDirectDrawSurface, GetDC, (LPVOID) lpDDDestSurface);


    // Original ReleaseDC 
    _pfn_IDirectDrawSurface_ReleaseDC pfnOldReleaseDC = 
            ORIGINAL_COM(IDirectDrawSurface, ReleaseDC, (LPVOID) lpDDDestSurface);

    if (!pfnOldGetDC || !pfnOldReleaseDC)
    {
        return hRet;
    }

    // Copy the DC contents to the surface

    HDC hTempDC;
    HGDIOBJ hOld = SelectObject(pdc->hdc, pdc->hbmp);
    if (SUCCEEDED((*pfnOldGetDC)(lpDDDestSurface, &hTempDC)))
    {
        BitBlt(hTempDC, 0, 0, pdc->dwWidth, pdc->dwHeight, pdc->hdc, 0, 0, SRCCOPY);
        (*pfnOldReleaseDC)(lpDDDestSurface, hTempDC);
    }

    // Do the ddraw Blt
    hRet = (*pfnOld)(
        lpDDDestSurface,
        lpDestRect,
        lpDDSrcSurface,
        lpSrcRect,
        dwFlags,
        lpDDBltFX);

    // Copy stuff back to the DC
    if (SUCCEEDED((*pfnOldGetDC)(lpDDDestSurface, &hTempDC)))
    {
        BitBlt(pdc->hdc, 0, 0, pdc->dwWidth, pdc->dwHeight, hTempDC, 0, 0, SRCCOPY);
        (*pfnOldReleaseDC)(lpDDDestSurface, hTempDC);
    }

    SelectObject(pdc->hdc, hOld);

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, GetDC, 17)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, ReleaseDC, 26)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Unlock, 32)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Blt, 5)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ultimatesoccermanager.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    UltimateSoccerManager.cpp

 Abstract:

    A hack for Ultimate Soccer Manager (Sierra Sports). The game caches a 
    pointer to a ddraw system memory surface. It later uses that pointer even 
    after the surface has been freed.

    This worked on Win9x by blind luck: when they re-create a new surface, it 
    happened to end up in the same system memory as before.

 Notes:

    This is an app specific shim.

 History:

    01/07/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UltimateSoccerManager)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

// Keep a list of cached surfaces
struct SLIST 
{
    struct SLIST *next;
    DDSURFACEDESC ddsd;
    LPDIRECTDRAWSURFACE lpDDSurface;
};
SLIST *g_SList = NULL;

/*++

 Hook create surface so we can return the cached surface if possible.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    // Retrieve the old function
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    SLIST *surf = g_SList, *last = NULL;
    while (surf)
    {
        // Check for the same kind of surface. 
        if ((lpDDSurfaceDesc->ddsCaps.dwCaps == surf->ddsd.ddsCaps.dwCaps) &&
            (lpDDSurfaceDesc->dwWidth == surf->ddsd.dwWidth) &&
            (lpDDSurfaceDesc->dwHeight == surf->ddsd.dwHeight))
        {
            *lplpDDSurface = surf->lpDDSurface;

            if (last)
            {
                last->next = surf->next;
            }
            else
            {
                g_SList = surf->next;
            }
            free(surf);

            DPFN( eDbgLevelInfo, "Returning cached surface %08lx\n", *lplpDDSurface);

            return DD_OK;
        }
        last = surf;
        surf = surf->next;
    }

    if (SUCCEEDED(hReturn = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    return hReturn;
}

/*++

 If it's a system memory surface, go ahead and cache it if we're about to 
 release it anyway.

--*/

ULONG 
COMHOOK(IDirectDrawSurface, Release)(
    LPDIRECTDRAWSURFACE lpDDSurface
    )
{
    lpDDSurface->AddRef();

    // Retrieve the old function
    _pfn_IDirectDrawSurface_Release pfnOld = ORIGINAL_COM(IDirectDrawSurface, Release, (LPVOID) lpDDSurface);

    ULONG uRet = (*pfnOld)(lpDDSurface);

    if (uRet == 1)
    {
        DDSURFACEDESC ddsd = {sizeof(ddsd)};
      
        if (SUCCEEDED(lpDDSurface->GetSurfaceDesc(&ddsd)) &&
            (ddsd.ddsCaps.dwCaps ==
                (DDSCAPS_OFFSCREENPLAIN | DDSCAPS_SYSTEMMEMORY)))
        {
            SLIST *surf = (SLIST *) malloc(sizeof(SLIST));
            surf->next = g_SList;
            MoveMemory(&surf->ddsd, &ddsd, sizeof(ddsd));
            surf->lpDDSurface = lpDDSurface;
            g_SList = surf;

            DPFN( eDbgLevelInfo, "Surface %08lx is being cached\n", lpDDSurface);

            return 0;
        }
    }

    return (*pfnOld)(lpDDSurface);
}

/*++

 Register hooked functions

--*/
HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Release, 2)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ultima9.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    Ultima9.cpp

 Abstract:

    Clean up bad ddraw CreateSurface caps.

 Notes:

    This is an app specific shim.

 History:

    03/04/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Ultima9)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

VOID FixCaps(LPDDSURFACEDESC lpDDSurfaceDesc)
{
   if (lpDDSurfaceDesc->dwFlags & DDSD_CAPS)
   {
       if ((lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_COMPLEX) && 
           (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
       {
            lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;        
       }
   }
}

VOID FixCaps2(LPDDSURFACEDESC2 lpDDSurfaceDesc)
{
   if (lpDDSurfaceDesc->dwFlags & DDSD_CAPS)
   {
       if ((lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_COMPLEX) && 
           (lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_MIPMAP))
       {
            lpDDSurfaceDesc->ddsCaps.dwCaps |= DDSCAPS_TEXTURE;        
       }
   }
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps(lpDDSurfaceDesc);

    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw2, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps(lpDDSurfaceDesc);

    _pfn_IDirectDraw2_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw2, CreateSurface, pThis);

    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw4, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps2(lpDDSurfaceDesc);

    _pfn_IDirectDraw4_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw4, CreateSurface, pThis);

Retry:
    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    if ((hRet == DDERR_INVALIDCAPS) && (lpDDSurfaceDesc->ddsCaps.dwCaps2))
    {
       lpDDSurfaceDesc->ddsCaps.dwCaps2 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps3 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps4 = 0;
       goto Retry;
    }

    return hRet;
}

/*++

 Hook create surface and fix parameters

--*/

HRESULT 
COMHOOK(IDirectDraw7, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC2 lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    FixCaps2(lpDDSurfaceDesc);

    _pfn_IDirectDraw7_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw7, CreateSurface, pThis);

Retry:
    HRESULT hRet = (*pfnOld)(
        pThis, 
        lpDDSurfaceDesc, 
        lplpDDSurface, 
        pUnkOuter);

    if ((hRet == DDERR_INVALIDCAPS) && (lpDDSurfaceDesc->ddsCaps.dwCaps2))
    {
       lpDDSurfaceDesc->ddsCaps.dwCaps2 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps3 = 0;
       lpDDSurfaceDesc->ddsCaps.dwCaps4 = 0;
       goto Retry;
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw2, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw4, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDraw7, CreateSurface, 6)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\treasurecove.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    TreasureCove.cpp

 Abstract:

    This SHIM hooks _lopen and fakes the opening of the file when the file is 
    "midimap.cfg".

 Notes:

    This is an app specific shim.

 History:

    12/14/00 prashkud  Created

--*/

#include "precomp.h"

// This module has been given an official blessing to use the str routines.
// Security change - using strsafe.h
#include "strsafe.h"

IMPLEMENT_SHIM_BEGIN(TreasureCove)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(_lopen)
APIHOOK_ENUM_END

/*++

 App requires this file to exist.

--*/

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int iReadWrite
    )
{
    if (stristr(lpPathName, "midimap.cfg"))
    {
        return (HFILE)1;
    }
    else
    {
        return ORIGINAL_API(_lopen)(lpPathName, iReadWrite);
    }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL,_lopen)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\tonkaconstruction.cpp ===
/*++

 Copyright (c) 1999 Microsoft Corporation

 Module Name:

    TonkaConstruction.cpp

 Abstract:

    Workaround for GDI behavior difference when bltting palettized bitmaps. On 
    Win9x GDI first looked at the current index for a color match when building 
    a lookup table, but on NT, it simply searches from the beginning. This 
    breaks palette animation. The fix is to make sure that the entries that are 
    animated are different from all the others.
    
 Notes:

    This is an app specific shim.

 History:

    12/02/2001 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(TonkaConstruction)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreatePalette) 
APIHOOK_ENUM_END

/*++

 Make sure index 10->15 are different from all other entries.

--*/

HPALETTE
APIHOOK(CreatePalette)(
    CONST LOGPALETTE *lplgpl    
    )
{
Restart:
    for (int i=10; i<=15; i++) {
        LPDWORD p1 = (DWORD *)&lplgpl->palPalEntry[i];
        for (int j=16; j<=255; j++) {
            LPDWORD p2 = (DWORD *)&lplgpl->palPalEntry[j]; 

            if (*p1 == *p2) {
                //
                // Entry is the same, so make it different
                //
                *p1 = *p1-1;
                goto Restart;
            }
        }
    }
    
    return ORIGINAL_API(CreatePalette)(lplgpl);
}
   
/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(GDI32.DLL, CreatePalette)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\ultrawincleaner2002.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    UltraWinCleaner2002.cpp

 Abstract:

    Ultra WinCleaner 2002 - WinJunk Cleaner removes files under 
    %WINDIR%\Resource\Themes.  This causes themes to fail to load.  Fixed by 
    hiding everything under %WINDIR%\Resource from FindFirstFileA.

 Notes:

    This is a application specific shim.

 History:

    5/13/2002 mikrause  Created

--*/

#include "precomp.h"

#include <nt.h>

IMPLEMENT_SHIM_BEGIN(UltraWinCleaner2002)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(NtQueryDirectoryFile)
APIHOOK_ENUM_END

UNICODE_STRING g_strWinResourceDir;

typedef NTSTATUS (WINAPI *_pfn_NtQueryDirectoryFile)(HANDLE, HANDLE, 
    PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, PVOID, ULONG, 
    FILE_INFORMATION_CLASS, BOOLEAN, PUNICODE_STRING, BOOLEAN);

NTSTATUS
APIHOOK(NtQueryDirectoryFile)(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG FileInformationLength,
    IN FILE_INFORMATION_CLASS FileInformationClass,
    IN BOOLEAN ReturnSingleEntry,
    IN PUNICODE_STRING FileName OPTIONAL,
    IN BOOLEAN RestartScan
    )
{
    //
    // If caller wants any async behavior, skip.
    // FileName must be valid.
    //
    if (Event == NULL && ApcRoutine == NULL && ApcContext == NULL && FileName != NULL) {
        // Only trap complete wildcard searches.
        if (lstrcmpW(FileName->Buffer, L"*.*") == 0 || 
            lstrcmpW(FileName->Buffer, L"*") == 0) {

            DWORD dwSize = MAX_PATH * sizeof(WCHAR) + sizeof(OBJECT_NAME_INFORMATION);
            PBYTE pbBuffer = new BYTE[dwSize]; 
            if (pbBuffer) {
                ULONG RetLen;
                ZeroMemory(pbBuffer, dwSize);
                POBJECT_NAME_INFORMATION poni = (POBJECT_NAME_INFORMATION)pbBuffer;           
                // Get the name of the directory
                NTSTATUS status = NtQueryObject(FileHandle, ObjectNameInformation, 
                poni, dwSize, &RetLen);

                // Retry if not enough buffer
                if (status == STATUS_BUFFER_TOO_SMALL) {
                    delete [] pbBuffer;
                    pbBuffer = new BYTE[RetLen];
                    if (pbBuffer) {
                        poni = (POBJECT_NAME_INFORMATION)pbBuffer;
                        status = NtQueryObject(FileHandle, ObjectNameInformation,
                        poni, RetLen, &RetLen);
                    }
                }

                // Check if it is the Windows Resource directory.
                if (NT_SUCCESS(status)) {               
                    if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, 
                        poni->Name.Buffer, poni->Name.Length / sizeof(WCHAR), 
                        g_strWinResourceDir.Buffer, g_strWinResourceDir.Length / sizeof(WCHAR)) == CSTR_EQUAL) {

                        // Pretend this directory doesn't exist.
                        DPFN(eDbgLevelInfo, "[NtQueryDirectoryFile] Ignoring all file searches in %S",
                            poni->Name.Buffer);
                        delete [] pbBuffer;
                        return STATUS_NO_SUCH_FILE;
                    }
                }
                if (pbBuffer) {
                    delete [] pbBuffer;
                }
            }
        }      
    }

    return ORIGINAL_API(NtQueryDirectoryFile)(FileHandle, Event, ApcRoutine,
        ApcContext, IoStatusBlock, FileInformation, FileInformationLength,
        FileInformationClass, ReturnSingleEntry, FileName, RestartScan);
}

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        CSTRING_TRY
        {
            // Get the Windows Resource directory (which holds themes)
            CString csWinResourceDir;
            csWinResourceDir.GetWindowsDirectoryW();
            csWinResourceDir.AppendPath(L"Resources");

            //
            // Convert the DOS name like C:\Windows\Resources to
            // \Device\HarddiskVolume0\Windows\Resources which NT likes.
            //        
            CString csWinDrive;
            csWinResourceDir.GetDrivePortion(csWinDrive);
            WCHAR wszBuffer[1024];
            if (QueryDosDeviceW(csWinDrive, wszBuffer, 1024)) {
                csWinResourceDir.Replace(csWinDrive, wszBuffer);
                ZeroMemory(&g_strWinResourceDir, sizeof(g_strWinResourceDir));

                PWSTR wsz = new WCHAR[csWinResourceDir.GetLength()+1];
                if (wsz) {
                    StringCchCopyW(wsz, csWinResourceDir.GetLength() + 1, csWinResourceDir);
                    DPFN(eDbgLevelInfo, "Ignoring all file searches in %S", wsz);
                    RtlInitUnicodeString(&g_strWinResourceDir, wsz);
                } else {
                    return FALSE;
                }
            } else {
                return FALSE;
            }         
        }
        CSTRING_CATCH
        {
            DPFN(eDbgLevelError, "CString exception in NotifyFunc!\n");
            return FALSE;
        }
    }

    return TRUE;
}

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(NTDLL.DLL, NtQueryDirectoryFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\uninstallshield.cpp ===
/*++
eDbgLevelError
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    UnInstallShield.cpp

 Abstract:
    
    UnInstallShield has an insidious bug where it calls WaitForSingleObject
    on the HINSTANCE returned by ShellExecute. Since an HINSTANCE is not
    an actual HANDLE, the WaitForSingleObject behaviour was completely random
    and in some cases caused UnInstallShield to hang. The fix is to change
    the HINSTANCE returned from ShellExecute to 0x0BADF00D and then look for
    it being passed in to WaitForSingleObject. If found, WAIT_OBJECT_0 is
    returned immediately to prevent deadlock.
    
 Notes:

    This is an app specific shim.

 History:

    12/04/2000 jdoherty  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UnInstallShield)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ShellExecuteA)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
    APIHOOK_ENUM_ENTRY(WaitForSingleObject)
APIHOOK_ENUM_END

/*++

 Hook ShellExecuteA so we can check the return value.

--*/

HINSTANCE
APIHOOK(ShellExecuteA)(
    HWND hwnd, 
    LPSTR lpVerb,
    LPSTR lpFile, 
    LPSTR lpParameters, 
    LPSTR lpDirectory,
    INT nShowCmd
    )
{
    HINSTANCE hRet = ORIGINAL_API(ShellExecuteA)(
                        hwnd,
                        lpVerb,
                        lpFile,
                        lpParameters,
                        lpDirectory,
                        nShowCmd
                        );

    DPFN( eDbgLevelInfo, "[ShellExecuteA] Checking return value for 0x0000002a");
    if (hRet == (HINSTANCE)0x0000002a)
    {
        DPFN( eDbgLevelInfo, "[ShellExecuteA] 0x0000002a found to be return value.  Return 0x0BADF00D");
        //
        //  if the HINSTANCE returned is 0x0000002a then return BAADF00D
        //
        hRet = (HINSTANCE)0x0BADF00D;
    }

    return hRet;
}

/*++

 Hook ShellExecuteW so we can check the return value.

--*/

HINSTANCE
APIHOOK(ShellExecuteW)(
    HWND hwnd, 
    LPWSTR lpVerb,
    LPWSTR lpFile, 
    LPWSTR lpParameters, 
    LPWSTR lpDirectory,
    INT nShowCmd
    )
{
    HINSTANCE hRet = ORIGINAL_API(ShellExecuteW)(
                        hwnd,
                        lpVerb,
                        lpFile,
                        lpParameters,
                        lpDirectory,
                        nShowCmd
                        );
    DPFN( eDbgLevelInfo, "[ShellExecuteW] Checking return value for 0x0000002a");
    if (hRet == (HINSTANCE)0x0000002a)
    {
        DPFN( eDbgLevelInfo, "[ShellExecuteW] 0x0000002a found to be return value.  Return 0x0BADF00D");
        //
        //  if the HINSTANCE returned is 0x0000002a then return BAADF00D
        //
        hRet = (HINSTANCE)0x0BADF00D;
    }

    return hRet;
}

/*++

 Hook WaitForSingleObject to see if we are waiting for the known HINSTANCE.

--*/

DWORD
APIHOOK(WaitForSingleObject)(
  HANDLE hHandle,          
  DWORD dwMilliseconds   
  )
{
    DWORD dRet;
    
    DPFN( eDbgLevelInfo, "[WaitForSingleObject] Checking to see if hHandle waiting on is 0x0000002A");

    if (hHandle == (HANDLE)0x0BADF00D)
    {
        DPFN( eDbgLevelInfo, "[WaitForSingleObject] hHandle waiting on is 0x0000002A, returning WAIT_OBJECT_0");
        //
        //  if the hHandle is 0x0BADF00D then return WAIT_OBJECT_0
        //
        dRet = WAIT_OBJECT_0;
    }
    else
    {
        dRet = ORIGINAL_API(WaitForSingleObject)(
                        hHandle,
                        dwMilliseconds
                        );
    }

    return dRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteA)
    APIHOOK_ENTRY(SHELL32.DLL, ShellExecuteW)
    APIHOOK_ENTRY(KERNEL32.DLL, WaitForSingleObject)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\urbanchaos.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    UrbanChaos.cpp

 Abstract:

    The sound system (Miles) uses a very high-resolution timer: 32ms. The app
    has badly designed message loop code. Instead of running everything off the
    loop, they have their movie playing code interspersed with a call to 
    empty the queue. Unfortunately for them, the queue on NT is almost always 
    filled with these timer messages, so their code to keep track of how far
    along their movie is gets starved.

    To fix this we reduce the timer resolution.

 Notes:

    This is an app specific shim.


 History:
        
    10/31/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(UrbanChaos)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SetTimer) 
APIHOOK_ENUM_END

/*++

 Reduce the timer resolution to a managable level.

--*/

UINT_PTR
APIHOOK(SetTimer)(
    HWND hWnd,              
    UINT nIDEvent,          
    UINT uElapse,           
    TIMERPROC lpTimerFunc   
    )
{
    // Reduce timer resolution
    if (uElapse < 100)
    {
        uElapse = 500;
    }

    return ORIGINAL_API(SetTimer)(hWnd, nIDEvent, uElapse, lpTimerFunc);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(USER32.DLL, SetTimer)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\viperracing.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    CheckTAPIVersionParameters.cpp

 Abstract:

    Hooks the call to lineNegotiateAPIVersion so that device 0 doesn't fail 
    causing the application to stop querying devices.

 Notes:
    
    This is an app specific shim. Could potentially be general, but requires
    research.

 History:

    07/17/2000 a-brienw Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ViperRacing)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(lineNegotiateAPIVersion)
APIHOOK_ENUM_END

/*++

 Hook lineNegotiateAPIVersion to reverse the order of the devices.

--*/

LONG
APIHOOK(lineNegotiateAPIVersion)(
    HLINEAPP hLineApp,
    DWORD dwDeviceID,
    DWORD dwAPILowVersion,
    DWORD dwAPIHighVersion,
    LPDWORD lpdwAPIVersion,
    LPLINEEXTENSIONID lpExtensionID
    )
{
    if (dwDeviceID == 0) dwDeviceID = 1;
    
    return ORIGINAL_API(lineNegotiateAPIVersion)(
        hLineApp,
        dwDeviceID,
        dwAPILowVersion,
        dwAPIHighVersion,
        lpdwAPIVersion,
        lpExtensionID);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(TAPI32.DLL, lineNegotiateAPIVersion)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\vjedelta.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    VJEDelta.cpp

 Abstract:

    Broken by ACL changes to directories off the root.

 Notes:

    This is an app specific shim.

 History:

    05/31/2001 linstev   Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VJEDelta)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(OpenFile) 
APIHOOK_ENUM_END

/*++

 Remove write attributes on OpenFile in the case of failure.

--*/

HFILE
APIHOOK(OpenFile)(
    LPCSTR lpFileName,        
    LPOFSTRUCT lpReOpenBuff,  
    UINT uStyle               
    )
{
    HFILE hRet = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);

    if ((hRet == HFILE_ERROR) && (GetLastError() == ERROR_ACCESS_DENIED)) {
        //
        // Remove write attributes
        // 

        WCHAR *lpName = ToUnicode(lpFileName);

        if (lpName) {
            if (wcsistr(lpName, L"VJED95") && wcsistr(lpName, L".DIC")) {
                //
                // This is a file we care about
                //
                uStyle &= ~(OF_WRITE | OF_READWRITE);
                LOGN(eDbgLevelError, "Removed write attributes from %S", lpName);
                hRet = ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
            }
            free(lpName);
        }
    }

    return hRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(KERNEL32.DLL, OpenFile)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\vjedeltasetup.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    VJEDeltaSetup.cpp

 Abstract:

    This app' setup program has a MYDLL.DLL, it has memory corruption in it's 
    IsAdmin(). Fixing this by provide a new procedure IsAdmin().
    (Copy/Paste from PSDK)

 History:

    06/12/2001 xiaoz   create

--*/

#include "precomp.h"

//
// app's private Prototype 
//
typedef BOOL (WINAPI *_pfn_IsAdmin)(void);

IMPLEMENT_SHIM_BEGIN(VJEDeltaSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(IsAdmin)
APIHOOK_ENUM_END

/*++

 New function to check whethe currently login as Admin, Copy/Paste from PSDK

--*/

BOOL 
APIHOOK(IsAdmin)(
    void
    )
{
    PSID pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL IsMember;
    HANDLE hToken = INVALID_HANDLE_VALUE;
    TOKEN_OWNER SIDforOwner;
    BOOL bRet = FALSE;

    //
    // Open a handle to the access token for the calling process.
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY | TOKEN_ADJUST_DEFAULT, 
                          &hToken ))
    {
        goto Cleanup;
    }
    //
    // Create a SID for the BUILTIN\Administrators group.
    //
    if (!AllocateAndInitializeSid(&SIDAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, 
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSID))
    {
        pSID = NULL;
        goto Cleanup;
    }
    //
    // Check if the administrator group SID is enabled in current process token
    //
    if (!CheckTokenMembership(NULL, pSID, &IsMember))
    {
        goto Cleanup;
    }    
    if (IsMember)
    {
        bRet = TRUE;
    }

Cleanup:
    if (pSID)
    {
        FreeSid(pSID);
    }
    if (hToken != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hToken);
    }
 
    return bRet;

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(MYDLL.DLL, IsAdmin)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\usnf97.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:
    
    USNF97.cpp

 Abstract:

    USNF '97 synchronizes it's video playback with cli/sti combinations. This 
    fails on NT, so we have to make sure they aren't bltting during the 
    refresh. Note that each time a cli/sti is hit, it makes only 1 blt 
    synchronize with the refresh. After the intro has played, cli/sti is no 
    longer used and so the blts don't incur extra overhead.

 Notes:

    This is an app specific shim.

 History:

    02/10/2000 linstev  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(USNF97)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY_DIRECTX_COMSERVER()
    APIHOOK_ENUM_ENTRY(GetStartupInfoA) 
APIHOOK_ENUM_END

IMPLEMENT_DIRECTX_COMSERVER_HOOKS()

LPDIRECTDRAW g_lpDirectDraw = NULL;
BOOL bFixBlt = FALSE;

/*++

 Hook create surface so we can be sure we're being called.

--*/

HRESULT 
COMHOOK(IDirectDraw, CreateSurface)(
    PVOID pThis, 
    LPDDSURFACEDESC lpDDSurfaceDesc, 
    LPDIRECTDRAWSURFACE* lplpDDSurface, 
    IUnknown* pUnkOuter 
    )
{
    HRESULT hReturn;
    
    _pfn_IDirectDraw_CreateSurface pfnOld = 
        ORIGINAL_COM(IDirectDraw, CreateSurface, pThis);

    if (SUCCEEDED(hReturn = (*pfnOld)(
            pThis, 
            lpDDSurfaceDesc, 
            lplpDDSurface, 
            pUnkOuter)))
    {
        HookObject(
            NULL, 
            IID_IDirectDrawSurface, 
            (PVOID*)lplpDDSurface, 
            NULL, 
            FALSE);
    }

    g_lpDirectDraw = (LPDIRECTDRAW)pThis;

    return hReturn;
}

/*++

 Synchronize the blt with the refresh if a cli/sti has just been called.

--*/

HRESULT 
COMHOOK(IDirectDrawSurface, Blt)(
    LPDIRECTDRAWSURFACE lpDDDestSurface,
    LPRECT lpDestRect,
    LPDIRECTDRAWSURFACE lpDDSrcSurface,
    LPRECT lpSrcRect,
    DWORD dwFlags,
    LPDDBLTFX lpDDBltFX 
    )
{
    // Original Blt
    _pfn_IDirectDrawSurface_Blt pfnOld = ORIGINAL_COM(IDirectDrawSurface, Blt, (LPVOID) lpDDDestSurface);

    if (bFixBlt)
    {
        // Make sure we're in the blank.
        DWORD dwScanLine = 0;
        while (dwScanLine<480)
        {
            g_lpDirectDraw->GetScanLine(&dwScanLine);
        }
        bFixBlt = FALSE;
    }
   
    return (*pfnOld)(
            lpDDDestSurface,
            lpDestRect,
            lpDDSrcSurface,
            lpSrcRect,
            dwFlags,
            lpDDBltFX);
}

/*++

 Custom exception handler to filter the cli/sti instructions.
 Handle out of range idivs.

--*/

LONG 
USNF97_ExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    CONTEXT *lpContext = ExceptionInfo->ContextRecord;
    LONG lRet = EXCEPTION_CONTINUE_SEARCH;

    if ((*((LPBYTE)lpContext->Eip) == 0xFA) ||
        (*((LPBYTE)lpContext->Eip) == 0xFB))
    {
        bFixBlt = TRUE;
        lpContext->Eip++;
        lRet = EXCEPTION_CONTINUE_EXECUTION;
    }
    else if ((*((LPBYTE)lpContext->Eip) == 0xF7) ||     // Handle idiv
             (*((LPBYTE)lpContext->Eip+1) == 0xF7))     // Handle 16 bit idiv
    {
        DPFN( eDbgLevelWarning, "Detected 'idiv' overflow: validating edx:eax");
        lpContext->Edx=0;
        if ((LONG)lpContext->Eax < 0)
        {
            lpContext->Eax = (DWORD)(-(LONG)lpContext->Eax);
        }
        lRet = EXCEPTION_CONTINUE_EXECUTION;
    }

    return lRet;
}

/*++

 Hook the exception handler.

--*/

VOID 
APIHOOK(GetStartupInfoA)( 
    LPSTARTUPINFOA lpStartupInfo   
    )
{
    SetUnhandledExceptionFilter(USNF97_ExceptionFilter);
    ORIGINAL_API(GetStartupInfoA)(lpStartupInfo);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, GetStartupInfoA)

    APIHOOK_ENTRY_DIRECTX_COMSERVER()
    COMHOOK_ENTRY(DirectDraw, IDirectDraw, CreateSurface, 6)
    COMHOOK_ENTRY(DirectDraw, IDirectDrawSurface, Blt, 5)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\vsanalyzerserversetup.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    VSAnalyzerServerSetup.cpp

 Abstract:

    This fix is for hardening the passwords for
    Visual C++ Analyzer Server Setup.

 Notes:

    This is an app specific shim.

 History:

    02/17/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(VSAnalyzerServerSetup)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(NetUserAdd)
    APIHOOK_ENUM_ENTRY(LsaStorePrivateData)
APIHOOK_ENUM_END

#include <lmcons.h>
#include <lmaccess.h>
#include <ntsecapi.h>

static WCHAR gwszPW[LM20_PWLEN] = L"Aa+0";

/*++

    Harden the password requirements

--*/

DWORD
APIHOOK(NetUserAdd)(
    LPCWSTR servername,
    DWORD   level,
    LPBYTE  buf,
    LPDWORD parm_err
    )
{
    NET_API_STATUS Status;
    USER_INFO_2*   puiNew;
    LPWSTR         pwszPSWRD;

    if (level == 2) {

        //
        // Grab the pointer to the buffer as a pointer to USER_INFO_2
        //
        puiNew = (USER_INFO_2*)buf;

        //
        // Get the current password.
        //
        pwszPSWRD = puiNew->usri2_password;

        if( wcslen(pwszPSWRD) >= 4 ) 
        {
            DPFN(
                eDbgLevelInfo,
                "VSAnalyzerServerSetup.dll, NetUserAdd PW:     \"%ws\".\n",
                pwszPSWRD);

            //
            // Copy the current password to the temp buffer.
            //
            StringCchCopyW(gwszPW + 4, ARRAYSIZE(gwszPW)-4, pwszPSWRD + 4);

            //
            // Stick in the new password.
            //
            puiNew->usri2_password = gwszPW;

            DPFN(
                eDbgLevelInfo,
                "VSAnalyzerServerSetup.dll, NetUserAdd new PW: \"%ws\".\n",
                gwszPW);
        }
    }

    //
    // Call the original API.
    //
    Status = ORIGINAL_API(NetUserAdd)(
                                servername,
                                level,
                                buf,
                                parm_err);

    if (level == 2) {

        //
        // Restore the password.
        //
        puiNew->usri2_password = pwszPSWRD;
    }

    return Status;
}

/*++

    Harden the password requirements

--*/

NTSTATUS
APIHOOK(LsaStorePrivateData)(
    LSA_HANDLE          PolicyHandle,
    PLSA_UNICODE_STRING KeyName,
    PLSA_UNICODE_STRING PrivateData
    )
{
    NTSTATUS Status;
    LPWSTR   pwszPSWRD;

    //
    // Save the originals.
    //
    pwszPSWRD = PrivateData->Buffer;

    DPFN(
        eDbgLevelInfo,
        "VSAnalyzerServerSetup.dll, LsaStorePrivateData PW:     \"%ws\".\n",
        pwszPSWRD);

    if( wcslen(pwszPSWRD) >= 4 )
    {
        //
        // Copy the current password to the temp buffer.
        //
        StringCchCopyW(gwszPW + 4, ARRAYSIZE(gwszPW)-4, pwszPSWRD + 4);

        //
        // Stick in the new settings.
        //
        PrivateData->Buffer = gwszPW;

        DPFN(
            eDbgLevelInfo,
            "VSAnalyzerServerSetup.dll, LsaStorePrivateData new PW: \"%ws\".\n",
            gwszPW);
    }

    //
    // Call the original LsaStorePrivateData.
    //
    Status = ORIGINAL_API(LsaStorePrivateData)(
                                PolicyHandle,
                                KeyName,
                                PrivateData);
    //
    // Restore the originals.
    //
    PrivateData->Buffer = pwszPSWRD;

    return Status;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(NETAPI32.DLL, NetUserAdd)
    APIHOOK_ENTRY(ADVAPI32.DLL, LsaStorePrivateData)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\viavoice8j.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    ViaVoice8J.cpp

 Abstract:

    ViaVoice8J mutes Master and Wave volume on Win XP. Disable mute. ViaVoice8J 
    installs riched20.dll and riched32.dll. These old dll prevent enroll wizard 
    richedit working properly on Win XP. Remove those.

 Notes:

    This is an app specific shim.

 History:

    06/03/2002 hioh     Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ViaVoice8J)
#include "ShimHookMacro.h"

typedef MMRESULT (WINAPI *_pfn_mixerSetControlDetails)(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mixerSetControlDetails) 
APIHOOK_ENUM_END

/*++

 Disregard mute when fdwDetails is 0. 

--*/

MMRESULT
APIHOOK(mixerSetControlDetails)(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails)
{
    if (fdwDetails == 0) {
        return (0);
    }

    return ORIGINAL_API(mixerSetControlDetails)(hmxobj, pmxcd, fdwDetails);
}

/*++

 Remove installed \bin\riched20.dll & \bin\riched32.dll

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    if (fdwReason == DLL_PROCESS_DETACH) {

        CSTRING_TRY 
        {
            HKEY hKey;
            WCHAR szRegDir[] = L"SOFTWARE\\IBM\\ViaVoice Runtimes\\RTConfig";

            // Get ViaVoice Registry
            if (ERROR_SUCCESS == RegOpenKeyExW(HKEY_LOCAL_MACHINE, szRegDir, 0, 
                KEY_QUERY_VALUE, &hKey)) {

                WCHAR szRegBin[] = L"bin";
                DWORD dwType;
                WCHAR szDir[MAX_PATH];
                DWORD cbData = sizeof(szDir);

                // Get installed directory
                if (ERROR_SUCCESS == RegQueryValueExW(hKey, szRegBin, NULL, &dwType, 
                    (LPBYTE) szDir, &cbData)) {

                    RegCloseKey(hKey);

                    // Delete problem richedit files
                    CString csDel;
                    csDel = szDir;
                    csDel += L"\\riched20.dll";
                    if (INVALID_FILE_ATTRIBUTES != GetFileAttributesW(csDel)) {
                        // Delete riched20.dll
                        DeleteFileW(csDel);
                    }
                    csDel = szDir;
                    csDel += L"\\riched32.dll";
                    if (INVALID_FILE_ATTRIBUTES != GetFileAttributesW(csDel)) {
                        // Delete riched32.dll
                        DeleteFileW(csDel);
                    }
                }
            }
        }
        CSTRING_CATCH 
        {
            // Do nothing
        }
    }   

    return TRUE;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(WINMM.DLL, mixerSetControlDetails)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\winfaxpro9.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinFaxPro9.cpp

 Abstract:

    Use QueryServiceStatus instead of ControlService if ControlService is
    called for SERVICE_CONTROL_INTERROGATE.
    
    No idea why this works on NT4.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WinFaxPro9)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ControlService)
APIHOOK_ENUM_END


/*++

    Use QueryServiceStatus instead of ControlService if ControlService is
    called for SERVICE_CONTROL_INTERROGATE.

--*/

BOOL
APIHOOK(ControlService)(
    SC_HANDLE         hService,
    DWORD             dwControl,
    LPSERVICE_STATUS  lpServiceStatus
    )
{
    if (dwControl == SERVICE_CONTROL_INTERROGATE) {

        DPFN(
            eDbgLevelWarning,
            "[ControlService] calling QueryServiceStatus instead of ControlService.\n");
        
        return QueryServiceStatus(hService, lpServiceStatus);
        
    } else {
        return ORIGINAL_API(ControlService)(
                                hService,
                                dwControl,
                                lpServiceStatus);
    }
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(ADVAPI32.DLL, ControlService)
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\wordperfect9_1.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WordPerfect9_1.cpp

 Abstract:

    Dispatch WM_USER messages (an OLE message in this case) automatically
    so the app doesn't hang. This is needed because of changes in OLE's behavior
    from Win9x to NT.

 Notes:

    This is an app specific shim.

 History:

    02/16/2000 clupu Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfect9_1)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(PeekMessageA)
APIHOOK_ENUM_END

/*++

 Dispatch WM_USER (an OLE message in this case) messages automatically.

--*/

BOOL
APIHOOK(PeekMessageA)(
    LPMSG lpMsg,
    HWND  hWnd,
    UINT  wMsgFilterMin,
    UINT  wMsgFilterMax,
    UINT  wRemoveMsg)
{
    BOOL bRet;

    bRet = ORIGINAL_API(PeekMessageA)(
        lpMsg,
        hWnd,
        wMsgFilterMin,
        wMsgFilterMax,
        wRemoveMsg);

    if (bRet && lpMsg->message == WM_USER && lpMsg->hwnd != NULL) {

        DispatchMessageA(lpMsg);

        if (wRemoveMsg == PM_REMOVE) {
            return APIHOOK(PeekMessageA)(
                lpMsg,
                hWnd,
                wMsgFilterMin,
                wMsgFilterMax,
                wRemoveMsg);
        }
    }

    return bRet;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, PeekMessageA)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\webpage6.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WebPage6.cpp

 Abstract:
    
    The app passes in an uninitialized POINT structure in a call to ScreenToClient API.
    The API call fails, however the apps goes on to use the POINT structure
    resulting in an AV. This shim zeroes in the POINT structure passed to the API 
    if the API call fails.
    
 History:

    02/02/2001 a-leelat    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WebPage6)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(ScreenToClient)
APIHOOK_ENUM_END


BOOL APIHOOK(ScreenToClient)(
  HWND hWnd,        // handle to window
  LPPOINT lpPoint   // screen coordinates
)
{

    BOOL bRet;   
 
    //Call the actual API
    bRet = ORIGINAL_API(ScreenToClient)(hWnd,lpPoint);


    //Zero fill the POINT structure
    if ( (bRet == 0) && lpPoint )
    {
        ZeroMemory(lpPoint,sizeof(POINT));
    }

    return bRet;
          
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY( USER32.DLL, ScreenToClient)
 
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\wordperfect8.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WordPerfect8.cpp
 Abstract:
    If the SafeArray* to the SafeArrayAccessData is an invalid one
    this function returns a NULL pointer for the data. Corel WordPerfect8
    was AV'ing because of this.

         This is an app specific shim.

 History:
 
    02/07/2001 prashkud  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfect8)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SafeArrayAccessData)
APIHOOK_ENUM_END



/*++

    This hooks SafeArrayAccessData and returns
    an error code if *ppvData is NULL.
--*/

HRESULT
APIHOOK(SafeArrayAccessData)(
    SAFEARRAY *psa,
    void HUGEP **ppvData
    )
{
    HRESULT hRes = S_OK;


    hRes = ORIGINAL_API(SafeArrayAccessData)(
            psa,
            ppvData
            );

    if (*ppvData == NULL)
    {
        DPFN( eDbgLevelError, "Getting a NULL pointer for the\
             SafeArray Data - ppvData = %lx & *ppvData =%lx",ppvData,*ppvData);
        DPFN( eDbgLevelError, "SAFEARRAY is psa = %lx,\
             psa.cbElements= %l",psa,psa->cbElements);
        hRes = E_UNEXPECTED;
    }
    return hRes;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(OLEAUT32.DLL, SafeArrayAccessData)    
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\wordperfectpresentation10.cpp ===
/*++

 Copyright (c) 2002 Microsoft Corporation

 Module Name:

    WordPerfectPresentation10.cpp

 Abstract:

    WordPerfect 2002 Presentation 10 expects WNetAddConnection to return ERROR_BAD_NET_NAME.
    The API is returning either  ERROR_BAD_NETPATH or ERROR_NO_NET_OR_BAD_PATH

 Notes:

    This is an app specific shim.

 History:

    09/20/2002  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfectPresentation10)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(WNetAddConnectionA)
    APIHOOK_ENUM_ENTRY(WNetAddConnectionW)
APIHOOK_ENUM_END

typedef DWORD       (*_pfn_WNetAddConnectionA)(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName);
typedef DWORD       (*_pfn_WNetAddConnectionW)(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName);

/*++

   Error code ERROR_BAD_NET_NAME has been replaced with error ERROR_NO_NET_OR_BAD_PATH

--*/

DWORD
APIHOOK(WNetAddConnectionA)(
  LPCSTR lpRemoteName, // network device name
  LPCSTR lpPassword,   // password
  LPCSTR lpLocalName   // local device name
)
{
    DWORD dwError = ORIGINAL_API(WNetAddConnectionA)(lpRemoteName, lpPassword, lpLocalName);
    if (dwError == ERROR_BAD_NETPATH || dwError == ERROR_NO_NET_OR_BAD_PATH)
    {
        dwError = ERROR_BAD_NET_NAME;
    }

    return dwError;
}

/*++

   Error code ERROR_BAD_NET_NAME has been replaced with error ERROR_NO_NET_OR_BAD_PATH

--*/

DWORD
APIHOOK(WNetAddConnectionW)(
  LPCWSTR lpRemoteName, // network device name
  LPCWSTR lpPassword,   // password
  LPCWSTR lpLocalName   // local device name
)
{
    DWORD dwError = ORIGINAL_API(WNetAddConnectionW)(lpRemoteName, lpPassword, lpLocalName);
    if (dwError == ERROR_BAD_NETPATH || dwError == ERROR_NO_NET_OR_BAD_PATH)
    {
        dwError = ERROR_BAD_NET_NAME;
    }

    return dwError;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(MPR.DLL,  WNetAddConnectionA)
    APIHOOK_ENTRY(MPR.DLL,  WNetAddConnectionW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\winstone99.cpp ===
/*
 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    WinStone99.cpp

    Bug: Whistler #185797
    
 Problem:

    Only for Winstone '99. Winstone uses scripts that hide the taskbar, and print stuff. 
    PrintUI displays a balloon tip informing the user that the printing job is done (this is a 
    new addition to Whistler).

    The balloon tip utilizes user tracking code, and is hence left stationary on the machine, 
    till the user clicks on it, or there is 10 seconds of user activity on the machine. 
    Winstone runs these automated tests, hence there is no user activity on the machine, when 
    the balloon is up, so it stays up forever.

    Later, when Winstone tries to enumerate the application windows, the presence of the 
    balloon tip throws it off track. Hence this apphack that disables the display of these 
    balloons when Winstone is running.

    Winstone is a collection of Visual Test scripts, and zdbui32.exe is the only exe that runs 
    throughout when Winstone is running. So disable user tracking when Winstone is running.

 Solution:

    Disable display of balloon tips when Winstone is running and enable it when Winstone is
    finished

 Details:

    Winstone sends a message to the tray that disables the balloon tip when it is running, and
    re-sends the message to the tray when it is done, so that the tray can enable the balloon 
    tip

 History:

    09/20/2000  ramkumar Created
*/

#include "precomp.h"
#include <shlapip.h>

IMPLEMENT_SHIM_BEGIN(WinStone99)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetCommandLineA) 
    APIHOOK_ENUM_ENTRY(GetCommandLineW) 
APIHOOK_ENUM_END

BOOL g_bInit = FALSE;
HWND g_hwndTray;
UINT g_uEnableBalloonMessage;

/*++

 Initialize

--*/

VOID
WinStone99_Initialize()
{
    if (!g_bInit)
    {
        g_bInit = TRUE;

        g_uEnableBalloonMessage = RegisterWindowMessage(ENABLE_BALLOONTIP_MESSAGE);
        if (!g_uEnableBalloonMessage)
        {
            return;
        }

        g_hwndTray = FindWindowA(WNDCLASS_TRAYNOTIFY, NULL);
        if (g_hwndTray)
        {
            SendMessage(g_hwndTray, g_uEnableBalloonMessage, FALSE, 0);
        }
    }
}

/*++

 Initialize.

--*/

LPSTR 
APIHOOK(GetCommandLineA)()
{
    WinStone99_Initialize();
    return ORIGINAL_API(GetCommandLineA)();
}

/*++

 Initialize.

--*/

LPWSTR 
APIHOOK(GetCommandLineW)()
{
    WinStone99_Initialize();
    return ORIGINAL_API(GetCommandLineW)();
}

/*++
 
 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_DETACH)
    {
        if (g_bInit)
        {
            if (g_hwndTray)
            {
                SendMessage(g_hwndTray, g_uEnableBalloonMessage, TRUE, 0);
            }
        }
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetCommandLineW)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\wordperfect9_2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   WordPerfect9_2.cpp

 Abstract:  

   WORDPERFECT 9 - GRAMMAR CHECK BUG:

   Shim prevents an internal reference count used by the Grammar Checker 
   from becoming negative by not allowing Add/Release to be called more than
   once for the life of the interface.

   This COM Interface allocates some internal memory in DllGetClassObject()
   and frees the memory in the Release().  
   
   Under WIN98 and NT4 this works because DllGetClassObject() is called at
   the beginning of Grammar Checking and Release() is called after completion.

   In Whistler OLE makes two pairs of extra calls (AddRef => Release & 
   QueryInterface => Release) causing Release() to free the internal 
   memory before the object is truly deleted.  The code also set the internal
   reference count to -2.  On the next initiation of the grammar checker the 
   internal REF count NZ (-2) and DllGetClassObject() does not allocate the 
   needed memory and then access violates.

 Notes:

   This is an application specific shim.

 History:

   12/01/2000 a-larrsh Created
--*/

#include "precomp.h"
#include <initguid.h>

IMPLEMENT_SHIM_BEGIN(WordPerfect9_2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
   APIHOOK_ENUM_ENTRY(DllGetClassObject) 
   APIHOOK_ENUM_ENTRY_COMSERVER(wt9li)
APIHOOK_ENUM_END

IMPLEMENT_COMSERVER_HOOK(wt9li)

/* ++

   COM definitions for object we are hooking

--*/

class  __declspec(uuid("C0E10005-0500-0900-C0E1-C0E1C0E1C0E1")) WP9;
struct __declspec(uuid("C0E10005-0100-0900-C0E1-C0E1C0E1C0E1")) IWP9;

DEFINE_GUID(CLSID_WP9, 0xC0E10005, 0x0500, 0x0900,  0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1);
DEFINE_GUID(IID_IWP9,  0xC0E10005, 0x0100, 0x0900,  0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1, 0xC0, 0xE1);

typedef HRESULT   (*_pfn_IWP9_QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject );
typedef ULONG     (*_pfn_IWP9_AddRef)( PVOID pThis );
typedef ULONG     (*_pfn_IWP9_Release)( PVOID pThis );


/*++

    Manage OLE Object Ref count for QueryInterface, AddRef and Release

--*/

static int g_nInternalRefCount = 0;

HRESULT 
APIHOOK(DllGetClassObject)(REFCLSID rclsid, REFIID riid, LPVOID * ppv)
{
    HRESULT hrResult;
   
   hrResult = ORIGINAL_API(DllGetClassObject)(rclsid, riid, ppv);            

   if (  IsEqualGUID(rclsid, CLSID_WP9) &&
         IsEqualGUID(riid,    IID_IWP9) &&
         hrResult == S_OK)
   {
      if (g_nInternalRefCount == 0)
      {
         g_nInternalRefCount++;
      }

      DPFN( eDbgLevelInfo, "DllGetClassObject");
   }

    return hrResult;
}

ULONG
COMHOOK(IWP9, AddRef)(PVOID pThis)
{       
   if (g_nInternalRefCount == 0)
   {
      _pfn_IWP9_AddRef pfnAddRef = (_pfn_IWP9_AddRef) ORIGINAL_COM(IWP9, AddRef, pThis);
      (*pfnAddRef)(pThis);
   }

   g_nInternalRefCount++;
   
   DPFN( eDbgLevelInfo, "AddRef");

   return g_nInternalRefCount;
}


ULONG
COMHOOK(IWP9, Release)(PVOID pThis)
{
   g_nInternalRefCount--;

   if (g_nInternalRefCount == 0)
   {
      _pfn_IWP9_Release pfnRelease = (_pfn_IWP9_Release) ORIGINAL_COM(IWP9, Release, pThis);   
      (*pfnRelease)(pThis);
   }
   
   DPFN( eDbgLevelInfo, "Release");

   return g_nInternalRefCount;
}

HRESULT
COMHOOK(IWP9, QueryInterface)( PVOID pThis, REFIID iid, PVOID* ppvObject )
{
   HRESULT hrResult;
   
   _pfn_IWP9_QueryInterface pfnQueryInterface = (_pfn_IWP9_QueryInterface) ORIGINAL_COM(IWP9, QueryInterface, pThis);

   hrResult = (*pfnQueryInterface)(pThis, iid, ppvObject);
   
   DPFN( eDbgLevelInfo, "QueryInterface");
   return hrResult;
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY_COMSERVER(wt9li)
    APIHOOK_ENTRY(wt9li.dll, DllGetClassObject)

    COMHOOK_ENTRY(WP9, IWP9, QueryInterface,  0)
    COMHOOK_ENTRY(WP9, IWP9, AddRef,  1)
    COMHOOK_ENTRY(WP9, IWP9, Release, 2)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\wordperfect9_3.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

   WordPerfect9_3.cpp

 Abstract:  

   WORDPERFECT 9 - Mapping Network Drives from Open / Save / Save As Dialogs:

 Notes:

   This is an application specific shim.

 History:

   02/21/2001 a-larrsh Created
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WordPerfect9_3)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderLocation) 
APIHOOK_ENUM_END

// typedef HRESULT   (WINAPI *_pfn_SHGetSpecialFolderLocation)(HWND hwndOwner, int nFolder, LPITEMIDLIST *ppidl);


/*++

 Hook SHGetDesktopFolder to get the IShellFolder Interface Pointer.

--*/

HRESULT
APIHOOK(SHGetSpecialFolderLocation)(
    HWND hwndOwner,
    int nFolder,
    LPITEMIDLIST *ppidl
)
{
   if (hwndOwner == NULL && nFolder == 0x11 && (*ppidl) == NULL)
   {
      DWORD dwReturn = WNetConnectionDialog(hwndOwner, RESOURCETYPE_DISK);

      switch(dwReturn)
      {
      case NO_ERROR:
         DPFN( eDbgLevelInfo, "Creating NETWORK CONNECTIONS dialog Successful");
         break;

      case ERROR_INVALID_PASSWORD:
      case ERROR_NO_NETWORK:
      case ERROR_EXTENDED_ERROR:
         DPFN( eDbgLevelWarning, "Creating NETWORK CONNECTIONS dialog Successful");
         break;

      case ERROR_NOT_ENOUGH_MEMORY:
      default:
         DPFN( eDbgLevelError, "Creating NETWORK CONNECTIONS dialog Failed");
         break;      
      }

      return NOERROR;
   }
   else
   {
      return ORIGINAL_API(SHGetSpecialFolderLocation)(hwndOwner, nFolder, ppidl);              
   }
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(SHELL32.DLL, SHGetSpecialFolderLocation)
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\works99.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:
    
    Works99.cpp

 Abstract:

    This shim is to add in the missing/corrupted registry values
    for Works Suite 99 / Works Deluxe 99

 Notes:

    This is a app specific shim.

 History:

    03/12/2001 rankala  Created
    03/12/2001 a-leelat Modified for shim.

--*/


#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(Works99)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END


static LONG SetThreadingModel2Both(IN WCHAR *szKeyPath);
static LONG AddCAGKey(void);



VOID Works99()
{
    // Fix broken ThreadingModel value for several CLSID
    SetThreadingModel2Both(L"CLSID\\{29D44CA0-DD3A-11d0-95DF-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{4BA2C080-68BB-11d0-95BD-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{4BA2C081-68BB-11d0-95BD-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{56EE2738-BDF7-11d1-8C28-00C04FB995C9}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{6CFFE322-6E97-11d1-8C1C-00C04FB995C9}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{711D9B80-02F2-11d1-B244-00AA00A74BFF}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{8EE20D86-6DEC-11d1-8C1C-00C04FB995C9}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{92AABF20-39C8-11d1-95F6-00C04FD57E8C}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{9B3B23C0-E236-11d0-A5C9-0080C7195D7E}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{9B3B23C1-E236-11d0-A5C9-0080C7195D7E}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{9B3B23C2-E236-11d0-A5C9-0080C7195D7E}\\LocalServer32");
    SetThreadingModel2Both(L"CLSID\\{9B3B23C3-E236-11d0-A5C9-0080C7195D7E}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{CB40F470-02F1-11D1-B244-00AA00A74BFF}\\InProcServer32");
    SetThreadingModel2Both(L"CLSID\\{EAF6F280-DD53-11d0-95DF-00C04FD57E8C}\\InProcServer32");

    // Add CAG key and all of its values if missing
    AddCAGKey();
}

/*

 Function Description:

    Set ThreadingModel Registry REG_SZ value to "Both" for a given key

*/

static 
LONG SetThreadingModel2Both(
    IN WCHAR *szKeyPath
    )
{

    HKEY    hKey;
    LONG    lStatus;        

    // Fix broken ThreadingModel value for several CLSID

    lStatus = RegOpenKeyExW (HKEY_CLASSES_ROOT, 
                             szKeyPath, 
                             0, 
                             KEY_ALL_ACCESS, 
                             &hKey);

    if ( lStatus == ERROR_SUCCESS ) {
        
        // Set it always since this is a one-time operation and 
        //it must have "Both", no matter what is the current data
        lStatus = RegSetValueExW(hKey, 
                                 L"ThreadingModel", 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)L"Both", 
                                 (wcslen(L"Both") + 1) * sizeof(WCHAR));

        RegCloseKey(hKey);
    }

    return lStatus;
}

/*

 Function Description:

    Check existance of CAG key, add key + all values if it doesn't exist

*/
static 
LONG AddCAGKey(
    void
    )
{
    HKEY    hKey, hKey1, hKey2;
    WCHAR   szData[MAX_PATH];
    DWORD   dwData;
    LONG    lStatus;        
    DWORD   dwCreated;

    // If this key doesn't exist, assume that something 
    // is completely wrong and don't try to complete the Registry
    lStatus = RegOpenKeyExW (HKEY_LOCAL_MACHINE, 
                             L"SOFTWARE\\Microsoft\\ClipArt Gallery\\5.0\\ConcurrentDatabases", 
                             0, 
                             KEY_ALL_ACCESS, 
                             &hKey);

    if (ERROR_SUCCESS != lStatus) {
        return lStatus;
    }

    // Check for next sub key, create if missing
    lStatus = RegCreateKeyExW (hKey, 
                               L"Core", 
                               0, 
                               NULL, 
                               REG_OPTION_NON_VOLATILE, 
                               KEY_ALL_ACCESS, 
                               NULL, 
                               &hKey1, 
                               NULL);
    RegCloseKey(hKey);

    if (ERROR_SUCCESS != lStatus) {
        return lStatus;
    }

    // Check for next sub key, create if missing, 
    // if so, we need create a set of values as well
    lStatus = RegCreateKeyExW (hKey1, 
                               L"CAG", 
                               0, 
                               NULL, 
                               REG_OPTION_NON_VOLATILE, 
                               KEY_ALL_ACCESS, 
                               NULL, 
                               &hKey2, 
                               &dwCreated);
    RegCloseKey(hKey1);

    if (ERROR_SUCCESS != lStatus) {
        return lStatus;
    }

    if (REG_CREATED_NEW_KEY == dwCreated) {

        // Create the appropriate set of values
        if (! SHGetSpecialFolderPathW(NULL, szData, CSIDL_PROGRAM_FILES, FALSE)) {
            RegCloseKey(hKey2);
            return ERROR_FILE_NOT_FOUND;
        }

        if (!SUCCEEDED(StringCchCatW(szData, ARRAYSIZE(szData), L"\\Common Files\\Microsoft Shared\\Clipart\\cagcat50")))
        {
            RegCloseKey(hKey2);
            return ERROR_FILE_NOT_FOUND;
        }

        lStatus = RegSetValueExW(hKey2, 
                                 L"Section1Path1", 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        StringCchCatW(szData, ARRAYSIZE(szData), L"\\CagCat50.MMC");
        lStatus = RegSetValueExW(hKey2, 
                                 L"CatalogPath0", 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        dwData = 3;
        lStatus = RegSetValueExW(hKey2, 
                                 L"CatalogDriveType0", 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        dwData = 1;
        lStatus = RegSetValueExW(hKey2, 
                                 L"CatalogSections", 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        StringCchCopyW(szData, ARRAYSIZE(szData), L"MAIN");
        lStatus = RegSetValueExW(hKey2, 
                                 L"Section1Name", 
                                 0, 
                                 REG_SZ, 
                                 (BYTE*)szData, 
                                 (wcslen(szData) + 1) * sizeof(WCHAR));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        dwData = 3;
        lStatus = RegSetValueExW(hKey2, 
                                 L"Section1DriveType1", 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        dwData = 1;
        lStatus = RegSetValueExW(hKey2, 
                                 L"Section1Paths", 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        dwData = 1033;
        lStatus = RegSetValueExW(hKey2, 
                                 L"CatalogLCID", 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, 
                                 sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

        dwData = 1;
        lStatus = RegSetValueExW(hKey2, 
                                 L"CatalogVersionID", 
                                 0, 
                                 REG_DWORD, 
                                 (BYTE*)&dwData, sizeof(DWORD));

        if (ERROR_SUCCESS != lStatus) {
            RegCloseKey(hKey2);
            return lStatus;
        }

    }
    
    RegCloseKey(hKey2);

    return lStatus;
}



/*++

 Register hooked functions

--*/

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason)
{
    
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        Works99();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\worms2.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Worms2.cpp

 Abstract:

    Extremely lame hack because we don't properly support full-screen MCI 
    playback on NT.

 Notes:

    This is an app specific shim.

 History:

    12/04/2000 linstev  Created

--*/

#include "precomp.h"
#include <mmsystem.h>
#include <digitalv.h>
#include <mciavi.h>

IMPLEMENT_SHIM_BEGIN(Worms2)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(mciSendCommandA) 
APIHOOK_ENUM_END

/*++

 Do lots of lame stuff.

--*/

MCIERROR 
APIHOOK(mciSendCommandA)(
    MCIDEVICEID IDDevice,  
    UINT uMsg,             
    DWORD fdwCommand,      
    DWORD dwParam          
    )
{
    if ((uMsg == MCI_PLAY) &&
        (fdwCommand == (MCI_NOTIFY | MCI_WAIT | MCI_MCIAVI_PLAY_FULLSCREEN)))
    {
        DEVMODEA dm;
        dm.dmSize = sizeof(dm);
        dm.dmPelsWidth = 320;
        dm.dmPelsHeight = 200;
        dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
        ChangeDisplaySettingsA(&dm, CDS_FULLSCREEN);

        #define szWndClass "WORMS2_HACK_WINDOW"
        WNDCLASSA cls;
        HMODULE hModule = GetModuleHandle(0);
        if (!GetClassInfoA(hModule, szWndClass, &cls))
        {
            cls.lpszClassName = szWndClass;
            cls.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
            cls.hInstance     = hModule;
            cls.hIcon         = NULL;
            cls.hCursor       = NULL;
            cls.lpszMenuName  = NULL;
            cls.style         = CS_DBLCLKS;
            cls.lpfnWndProc   = DefWindowProc;
            cls.cbWndExtra    = sizeof(INT_PTR);
            cls.cbClsExtra    = 0;
            if (RegisterClassA(&cls) == 0)
            {
                goto Fail;
            }
        }

        HWND hWnd = CreateWindowA(
            szWndClass,
            szWndClass,
            WS_OVERLAPPED|WS_POPUP|WS_VISIBLE,
            0,
            0,
            GetSystemMetrics(SM_CXSCREEN), 
            GetSystemMetrics(SM_CYSCREEN),
            (HWND)NULL, 
            NULL,
            hModule,
            (LPVOID)NULL);

        if (!hWnd)
        {
            goto Fail;
        }

        MCIERROR merr;
        MCI_DGV_WINDOW_PARMSA mciwnd;
        mciwnd.dwCallback = (DWORD)DefWindowProcA;
        mciwnd.hWnd = hWnd;
        mciwnd.lpstrText = 0;
        mciwnd.nCmdShow = 0;
        merr = mciSendCommandA(IDDevice, MCI_WINDOW, MCI_DGV_WINDOW_HWND, (DWORD)&mciwnd);
        if (merr != MMSYSERR_NOERROR)
        {
            DestroyWindow(hWnd);
            goto Fail;
        }

        ShowCursor(FALSE);
        MCI_PLAY_PARMS mciply;
        mciply.dwCallback = (DWORD)hWnd;
        mciply.dwFrom = 0x40000000;
        mciply.dwTo = 0;
        merr = mciSendCommandA(IDDevice, MCI_PLAY, MCI_NOTIFY | MCI_WAIT, (DWORD)&mciply);
        DestroyWindow(hWnd);
        ShowCursor(TRUE);

        if (merr != MMSYSERR_NOERROR)
        {
            goto Fail;
        }
        return 0;
    }
    
Fail:
    return ORIGINAL_API(mciSendCommandA)(
        IDDevice,
        uMsg,
        fdwCommand,
        dwParam);
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(WINMM.DLL, mciSendCommandA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\wps2000.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    WPS2000.cpp

 Abstract:

    This in in fact NT user bug, see whistler bug 359407's attached mail for 
    detail. The problem is NT user's MSGFILTER hook is not dbcs-enabled, the dbcs 
    char code sent to ANSI edit control actually got reverted, 2nd byte first 
    followed by first byte. The code path seems only hit when edit control is 
    ANSI window and used in OLE server.

 Notes: 
  
    This is an app specific shim.

 History:

    06/02/2001 xiaoz    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WPS2000)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateDialogIndirectParamA) 
APIHOOK_ENUM_END

//
// Global windowproc for subclassed Edit Control
//

WNDPROC g_lpWndProc = NULL;

//
// CONSTANT for how we were being launched
//
#define EMBEDDIND_STATUS_UNKOWN 0  // We have not checked whether how we were launched 
#define EMBEDDIND_STATUS_YES    1  // We were launched as an OLE object
#define EMBEDDIND_STATUS_NO     2  // We were launched as stand-alone exe file

//
// Global variable to keep our status
//
UINT g_nEmbeddingObject =EMBEDDIND_STATUS_UNKOWN;

/*++

 The subclassed edit windowproc that we use to exchange the 1st byte and 2nd byte 
 of a DBCS char

--*/

LRESULT
CALLBACK
WindowProcA(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    BYTE bHi,bLo;

    //
    // If it' not a WM_IME_CHAR message, ignore it
    //
    if (uMsg == WM_IME_CHAR)
    { 
        //
        // Exchange the 1st byte with 2nd byte
        //
        bHi = HIBYTE(wParam);
        bLo = LOBYTE(wParam);
        wParam = bLo*256 + bHi;
    }

    return CallWindowProcA(g_lpWndProc, hWnd, uMsg, wParam, lParam);
}


/*++

 Enumerate the control on the dlg and if is editbox, subclass it.

--*/

BOOL 
CALLBACK 
EnumChildProc(
    HWND hwnd,
    LPARAM lParam 
    )
{
    CString cstrEdit(L"Edit");
    WCHAR szClassName[MAX_PATH];
    WNDPROC lpWndProc;

    GetClassName(hwnd, szClassName, MAX_PATH);

    //
    // Only care Edit Control
    //
    if (!cstrEdit.CompareNoCase(szClassName))
    {
        //
        // There are 3 Edit Control on thsi speficic dlg,all standard one
        // having same WinProc Address
        //
        lpWndProc = (WNDPROC) GetWindowLongPtrA(hwnd, GWLP_WNDPROC);
        if (lpWndProc)
        {
           g_lpWndProc = lpWndProc;
           SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LONG_PTR)WindowProcA);
           LOGN(eDbgLevelWarning, "Edit Control Sub-Classed");
        }
    }
    return TRUE;
}

/*++

 Check commandline for a sub-string "-Embedding".

--*/
UINT GetAppLaunchMethod()
{
    WCHAR *pwstrCmdLine;
 
    //
    // If we have not check this, then do it 
    //
    if (g_nEmbeddingObject == EMBEDDIND_STATUS_UNKOWN)
    {
        CString cStrCmdLineRightPart;
        CString cStrCmdLine = GetCommandLine();
        CString cstrEmbeded(L"-Embedding");

        cStrCmdLineRightPart = cStrCmdLine.Right(cstrEmbeded.GetLength());
        if (cStrCmdLineRightPart.CompareNoCase(cstrEmbeded))
        {
            g_nEmbeddingObject = EMBEDDIND_STATUS_NO;
        }
        else
        {
            g_nEmbeddingObject = EMBEDDIND_STATUS_YES;
        }
    }

    return (g_nEmbeddingObject);
}

/*++

 Hook CreateDialogIndirectParamA to find this specific dlg and subclass
 edit control on it 

--*/

HWND 
APIHOOK(CreateDialogIndirectParamA)( 
    HINSTANCE hInstance, 
    LPCDLGTEMPLATE lpTemplate, 
    HWND hWndParent, 
    DLGPROC lpDialogFunc, 
    LPARAM lParamInit
    )
{
    HWND hDlg;
    WCHAR wszCaption[MAX_PATH];
    WCHAR wszTitle[] = { (WCHAR)0x6587, (WCHAR)0x672c, (WCHAR)0x8f93, (WCHAR)0x5165, (WCHAR)0x0000 };
    CString cstrCaption;
    
    hDlg = ORIGINAL_API(CreateDialogIndirectParamA)(hInstance, lpTemplate,
        hWndParent, lpDialogFunc, lParamInit);

    //
    // If dlg can not be created or not launched as OLE server, ignore it
    //
    if (!hDlg ||  (EMBEDDIND_STATUS_YES != GetAppLaunchMethod()))
    {
        goto End;
    }

    //
    // Try to get caption and see if that's the dlg we are interested 
    //
    if (!GetWindowText(hDlg, wszCaption, MAX_PATH))
    {
        goto End;
    }

    cstrCaption = wszCaption;
    if (!cstrCaption.CompareNoCase(wszTitle))
    {
        EnumChildWindows(hDlg, EnumChildProc, NULL);
    }

End:
    return hDlg;
}

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    APIHOOK_ENTRY(USER32.DLL, CreateDialogIndirectParamA)        
HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\zenworks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    ZenWorks.cpp

 Abstract:

    ZenWorks console plugins setup program changes the
    HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path
    registry key from REG_EXPAND_SZ to REG_SZ.

 Notes:

    This is an app specific shim.

 History:

    06/06/2001  robkenny    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ZenWorks)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(RegSetValueExA) 
APIHOOK_ENUM_END

/*++

 Prevent HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment\Path
 from being changed from a REG_EXPAND_SZ to REG_SZ

--*/

LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,
    LPCSTR lpValueName,
    DWORD  Reserved,
    DWORD  dwType,
    CONST BYTE * lpData,
    DWORD  cbData
    )
{
    CSTRING_TRY
    {
        CString csValueName(lpValueName);

        DPFN( eDbgLevelSpew, "RegSetValueExA lpValueName(%S)", csValueName.Get());

        if (dwType == REG_SZ &&
            csValueName.CompareNoCase(L"Path") == 0)
        {
            dwType = REG_EXPAND_SZ;
            DPFN( eDbgLevelError, "RegSetValueExA lpValueName(%S) forced to REG_EXPAND_SZ type.",
                  csValueName.Get());
        }
    }
    CSTRING_CATCH
    {
        // fall through
    }

    /*
     * Call the original API
     */
    
    return ORIGINAL_API(RegSetValueExA)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}


/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\specific\workssuite2001.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    WorksSuite2001.cpp

 Abstract:

    Added the hook for CreateProcess to prevent IE5Setup.exe from starting
    up if the system has a higher version of IE.

 Notes:

    This is an app specific.

 History:

    03/28/2001	a-larrsh    Created
    07/13/2001	prashkud    Added hook for CreateProcess
    01/11/2001  robkenny    Removed code that was deleting Shockwave files whenever this shim loaded.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(WorksSuite2001)
#include "ShimHookMacro.h"

#include "userenv.h"

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA) 
APIHOOK_ENUM_END


/*++

    Hooks CreateProcessA and if the process being invoked is "ie5setup.exe",
    determines the IE version on the system and if it is higher than IE 5.5,
    launches an harmless .exe like "rundll32.exe" instead.

--*/

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,                 
    LPSTR                   lpCommandLine,                      
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, 
    BOOL                    bInheritHandles,                     
    DWORD                   dwCreationFlags,                    
    LPVOID                  lpEnvironment,                     
    LPCSTR                  lpCurrentDirectory,                
    LPSTARTUPINFOA          lpStartupInfo,             
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    DPFN( eDbgLevelSpew, "[CreateProcessA] appname:(%s)\ncommandline:(%s)",
          lpApplicationName, lpCommandLine );

    CSTRING_TRY
    {
        CString csAppName(lpApplicationName);
        CString csCmdLine(lpCommandLine);
        
        if ((csAppName.Find(L"ie5setup.exe") != -1) ||
            (csCmdLine.Find(L"ie5setup.exe") != -1))
        {
            //
            // App has called CreateProcess on ie5setup.exe.
            // Check the version of IE that we have on the machine.
            //

            HKEY hKey = NULL;            
            if ((RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                               L"Software\\Microsoft\\Internet Explorer",
                               0,
                               KEY_QUERY_VALUE,
                               &hKey) == ERROR_SUCCESS))
            {
                WCHAR wszBuf[MAX_PATH];
                DWORD dwSize = MAX_PATH;

                if (RegQueryValueExW(hKey, L"Version", NULL, NULL,
                    (LPBYTE)wszBuf, &dwSize) == ERROR_SUCCESS)
                {
                    WCHAR *StopString = NULL;
                    CStringParser csParser(wszBuf, L".");
                    
                    // We need at least the major and minor version numbers from the version string
                    if (csParser.GetCount() >= 2)
                    {
                        long lVal = wcstol(csParser[0].Get(), &StopString, 10);

                        if (lVal > 5)
                        {
                            //
                            // Call rundll32.exe, which is harmless
                            //
                            csAppName = "";
                            csCmdLine = "rundll32.exe";
                        }           
                        else
                        {
                            // check the 2nd value
                            StopString = NULL;
                            lVal = 0;
                            lVal = wcstol(csParser[1].Get(), &StopString, 10);
                            if (lVal > 5)
                            {
                                csAppName = "";
                                csCmdLine = "rundll32.exe";
                            }
                        }
                    }
                }
                RegCloseKey(hKey);
            }
        }

        return ORIGINAL_API(CreateProcessA)(
            csAppName.GetAnsiNIE(),csCmdLine.GetAnsiNIE(),
            lpProcessAttributes,lpThreadAttributes, bInheritHandles,
            dwCreationFlags, lpEnvironment,lpCurrentDirectory,
            lpStartupInfo,lpProcessInformation);
    }
    CSTRING_CATCH
    {
        // Do nothing
    }

    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
            lpCommandLine, lpProcessAttributes,
            lpThreadAttributes, bInheritHandles,
            dwCreationFlags, lpEnvironment,
            lpCurrentDirectory, lpStartupInfo,lpProcessInformation);

}

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    APIHOOK_ENTRY(KERNEL32.DLL, CreateProcessA)

HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\highversionlie.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   HighVersionLie.cpp

 Abstract:

   This DLL hooks GetVersion and GetVersionEx so that they return a future OS
   version credentials.

 Notes:

   This is a general purpose shim.

 History:

   02/08/2001   clupu       Created
   09/21/2001   rparsons    Added VLOG on hooks per billshih.
   10/17/2001   rparsons    Fixed bugs in GetVersionExW and GetVersion.
   11/27/2001   rparsons    Modified the VLOGs so they display what we
                            used for the API call.
   02/20/2002   rparsons    Implemented strsafe functions.

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(HighVersionLie)
#include "ShimHookMacro.h"

BEGIN_DEFINE_VERIFIER_LOG(HighVersionLie)
    VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSION)
    VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSIONEX)
END_DEFINE_VERIFIER_LOG(HighVersionLie)

INIT_VERIFIER_LOG(HighVersionLie);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetVersionExA)
    APIHOOK_ENUM_ENTRY(GetVersionExW)
    APIHOOK_ENUM_ENTRY(GetVersion)
APIHOOK_ENUM_END

DWORD g_dwMajorVersion;
DWORD g_dwMinorVersion;
DWORD g_dwBuildNumber;

BOOL
APIHOOK(GetVersionExA)(
    OUT LPOSVERSIONINFOA lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExA)(lpVersionInformation)) {
        LOGN(eDbgLevelInfo,
             "[GetVersionExA] called. Returning %lu.%lu build %lu",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        VLOG(VLOG_LEVEL_INFO,
             VLOG_HIGHVERSION_GETVERSIONEX,
             "Returned %lu.%lu build number %lu.",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        lpVersionInformation->dwMajorVersion = g_dwMajorVersion;
        lpVersionInformation->dwMinorVersion = g_dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = g_dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = '\0';

        bReturn = TRUE;
    }
    return bReturn;
}

BOOL
APIHOOK(GetVersionExW)(
    OUT LPOSVERSIONINFOW lpVersionInformation
    )
{
    BOOL bReturn = FALSE;

    if (ORIGINAL_API(GetVersionExW)(lpVersionInformation)) {
        LOGN(eDbgLevelInfo,
             "[GetVersionExW] called. Returning %lu.%lu build %lu",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        VLOG(VLOG_LEVEL_INFO,
             VLOG_HIGHVERSION_GETVERSIONEX,
             "Returned %lu.%lu build number %lu.",
             g_dwMajorVersion,
             g_dwMinorVersion,
             g_dwBuildNumber);

        lpVersionInformation->dwMajorVersion = g_dwMajorVersion;
        lpVersionInformation->dwMinorVersion = g_dwMinorVersion;
        lpVersionInformation->dwBuildNumber  = g_dwBuildNumber;
        lpVersionInformation->dwPlatformId   = VER_PLATFORM_WIN32_NT;
        *lpVersionInformation->szCSDVersion  = L'\0';

        bReturn = TRUE;
    }
    return bReturn;
}

DWORD
APIHOOK(GetVersion)(
    void
    )
{
    LOGN(eDbgLevelInfo,
         "[GetVersion] called. Returning %lu.%lu build %lu",
         g_dwMajorVersion,
         g_dwMinorVersion,
         g_dwBuildNumber);

    VLOG(VLOG_LEVEL_INFO,
         VLOG_HIGHVERSION_GETVERSION,
         "Returned %lu.%lu build number %lu.",
         g_dwMajorVersion,
         g_dwMinorVersion,
         g_dwBuildNumber);

    return (((VER_PLATFORM_WIN32_NT ^ 0x2) << 30) |
            (g_dwBuildNumber << 16) |
            (g_dwMinorVersion << 8) |
             g_dwMajorVersion);
}

INT_PTR CALLBACK
DlgOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPCWSTR szExeName;

    switch (message) {
    case WM_INITDIALOG:
        {
            WCHAR szTemp[20];

            //
            // Limit the number of characters for each edit control.
            //
            SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
            SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MINOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
            SendDlgItemMessage(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, EM_LIMITTEXT, (WPARAM)5, 0);

            //
            // find out what exe we're handling settings for
            //
            szExeName = ExeNameFromLParam(lParam);

            g_dwMajorVersion = GetShimSettingDWORD(L"HighVersionLie", szExeName, L"MajorVersion", 7);
            g_dwMinorVersion = GetShimSettingDWORD(L"HighVersionLie", szExeName, L"MinorVersion", 2);
            g_dwBuildNumber  = GetShimSettingDWORD(L"HighVersionLie", szExeName, L"BuildNumber", 3595);

            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), L"%d", g_dwMajorVersion);
            SetDlgItemText(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, szTemp);

            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), L"%d", g_dwMinorVersion);
            SetDlgItemText(hDlg, IDC_HVL_EDIT_MINOR_VERSION, szTemp);

            StringCchPrintf(szTemp, ARRAYSIZE(szTemp), L"%d", g_dwBuildNumber);
            SetDlgItemText(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, szTemp);

            return TRUE;
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_HVL_BTN_DEFAULT:
            {
                WCHAR szTemp[20];

                g_dwMajorVersion = 7;
                g_dwMinorVersion = 2;
                g_dwBuildNumber = 3595;

                //
                // Limit the number of characters for each edit control.
                //
                SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
                SendDlgItemMessage(hDlg, IDC_HVL_EDIT_MINOR_VERSION, EM_LIMITTEXT, (WPARAM)5, 0);
                SendDlgItemMessage(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, EM_LIMITTEXT, (WPARAM)5, 0);

                StringCchPrintf(szTemp, ARRAYSIZE(szTemp), L"%d", g_dwMajorVersion);
                SetDlgItemText(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, szTemp);

                StringCchPrintf(szTemp, ARRAYSIZE(szTemp), L"%d", g_dwMinorVersion);
                SetDlgItemText(hDlg, IDC_HVL_EDIT_MINOR_VERSION, szTemp);

                StringCchPrintf(szTemp, ARRAYSIZE(szTemp), L"%d", g_dwBuildNumber);
                SetDlgItemText(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, szTemp);

                break;
            }
        }
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_APPLY:

            g_dwMajorVersion = GetDlgItemInt(hDlg, IDC_HVL_EDIT_MAJOR_VERSION, NULL, FALSE);
            g_dwMinorVersion = GetDlgItemInt(hDlg, IDC_HVL_EDIT_MINOR_VERSION, NULL, FALSE);
            g_dwBuildNumber  = GetDlgItemInt(hDlg, IDC_HVL_EDIT_BUILD_NUMBER, NULL, FALSE);

            SaveShimSettingDWORD(L"HighVersionLie", szExeName, L"MajorVersion", g_dwMajorVersion);
            SaveShimSettingDWORD(L"HighVersionLie", szExeName, L"MinorVersion", g_dwMinorVersion);
            SaveShimSettingDWORD(L"HighVersionLie", szExeName, L"BuildNumber", g_dwBuildNumber);

            break;
        }
        break;
    }

    return FALSE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_HIGHVERSIONLIE_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_HIGHVERSIONLIE_FRIENDLY)
    SHIM_INFO_VERSION(1, 4)
    SHIM_INFO_FLAGS(0)
    SHIM_INFO_INCLUDE_EXCLUDE("I:msi.dll E:msvcrt.dll msvcirt.dll oleaut32.dll")
    SHIM_INFO_OPTIONS_PAGE(IDD_HIGHVERSION_OPTIONS, DlgOptions)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    if (fdwReason == DLL_PROCESS_ATTACH) {
        //
        // get the settings
        //
        WCHAR szExe[100];

        GetCurrentExeName(szExe, 100);

        g_dwMajorVersion = GetShimSettingDWORD(L"HighVersionLie", szExe, L"MajorVersion", 7);
        g_dwMinorVersion = GetShimSettingDWORD(L"HighVersionLie", szExe, L"MinorVersion", 2);
        g_dwBuildNumber = GetShimSettingDWORD(L"HighVersionLie", szExe, L"BuildNumber", 3595);

        DUMP_VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSION,
                                AVS_HIGHVERSION_GETVERSION,
                                AVS_HIGHVERSION_GETVERSION_R,
                                AVS_HIGHVERSION_GETVERSION_URL)

        DUMP_VERIFIER_LOG_ENTRY(VLOG_HIGHVERSION_GETVERSIONEX,
                                AVS_HIGHVERSION_GETVERSIONEX,
                                AVS_HIGHVERSION_GETVERSIONEX_R,
                                AVS_HIGHVERSION_GETVERSIONEX_URL)
    }

    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExA)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersionExW)
    APIHOOK_ENTRY(KERNEL32.DLL, GetVersion)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\dxfileversioninfo.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   DXFileVersionInfo.cpp

 Abstract:

   This AppVerifier shim hooks GetFileVersionInfo and
   checks to see if the application is checking version
   information for any known DirectX files.
   
   See the FileVersionInfoLie shim for details on the problem.
   
 Notes:

   This is a general purpose shim.

 History:

   06/26/2001   rparsons    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(DXFileVersionInfo)
#include "ShimHookMacro.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(DXFileVersionInfo)
    VERIFIER_LOG_ENTRY(VLOG_DXFILEVERSIONINFO_DXFILE)
END_DEFINE_VERIFIER_LOG(DXFileVersionInfo)

INIT_VERIFIER_LOG(DXFileVersionInfo);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoW)
APIHOOK_ENUM_END

// Keep a list of files to track.
typedef struct FILELIST {
    struct FILELIST* pNext;
    CString          csFileName;
} FILELIST, *PFILELIST;

PFILELIST   g_pFileListHead = NULL;
const int   g_nNumDirectX7a = 68;

WCHAR  *g_szDirectX7aFiles[g_nNumDirectX7a] =
    { L"dplay.dll",      L"d3dim.dll",        L"d3dim700.dll",
      L"d3dpmesh.dll",   L"d3dramp.dll",      L"d3drampf.dll",
      L"d3dref.dll",     L"d3drg16f.dll",     L"d3drg24f.dll",
      L"d3drg24x.dll",   L"d3dhalf.dll",      L"d3drg32f.dll",
      L"d3drg32x.dll",   L"d3drg55x.dll",     L"d3drg56x.dll",
      L"d3drg8f.dll",    L"d3drg8x.dll",      L"d3drgbf.dll",
      L"d3drgbxf.dll",   L"d3drm.dll",        L"d3drm16f.dll",
      L"d3drm24f.dll",   L"d3drm32f.dll",     L"d3drm8f.dll",
      L"d3dxof.dll",     L"ddhelp.exe",       L"ddraw.dll",
      L"ddraw16.dll",    L"ddrawex.dll",      L"devnode1.dll",
      L"devnode2.dll",   L"dinput.dll",       L"dmband.dll",
      L"dmcompos.dll",   L"dmime.dll",        L"dmloader.dll",
      L"dmstyle.dll",    L"dmsynth.dll",      L"dmusic.dll",
      L"dmusic16.dll",   L"dmusic32.dll",     L"dplayx.dll",
      L"dpmodemx.dll",   L"dpserial.dll",     L"dpwsock.dll",
      L"dpwsockx.dll",   L"dsetup.dll",       L"dsetup16.dll",
      L"dsetup32.dll",   L"dsetup6e.dll",     L"dsetup6j.dll",
      L"dsetupe.dll",    L"dsetupj.dll",      L"dsound.dll",
      L"dsound3d.dll",   L"dx7vb.dll",        L"dxmigr.dll",
      L"gcdef.dll",      L"gchand.dll",       L"msvcrt.dll",
      L"pid.dll",        L"vjoyd.vxd",        L"dinput.vxd",
      L"dsound.vxd",     L"joyhid.vxd",       L"mtrr.vxd",
      L"ddraw.vxd",      L"d3d8.dll"
    };

void
CheckDirectXFile(
    IN CString& csFileName
    )
{
    CSTRING_TRY {

        PFILELIST pFileList = g_pFileListHead;

        CString csFilePart;
        csFileName.GetLastPathComponent(csFilePart);

        //
        // Walk the list and perform a comparison. Report wrong-doers.
        //
        while (pFileList) {

            if (csFilePart.CompareNoCase(pFileList->csFileName) == 0) {
                VLOG(VLOG_LEVEL_ERROR, VLOG_DXFILEVERSIONINFO_DXFILE, "GetFileVersionInfo called for %ls", csFileName.Get());
                break;
            }
            
            pFileList = pFileList->pNext;
        }
        
    }
    CSTRING_CATCH {

        // Do nothing
    }
}

BOOL 
APIHOOK(GetFileVersionInfoA)(
    LPSTR  lpstrFilename,
    DWORD  dwHandle,
    DWORD  dwLen,
    LPVOID lpData
    )
{
    CString csFileName(lpstrFilename);

    //
    // See if they're requesting information on a known DX file.
    //
    CheckDirectXFile(csFileName);

    return ORIGINAL_API(GetFileVersionInfoA)( 
                        lpstrFilename, 
                        dwHandle, 
                        dwLen, 
                        lpData);
}

BOOL 
APIHOOK(GetFileVersionInfoW)(
    LPWSTR  lpstrFilename,
    DWORD   dwHandle,
    DWORD   dwLen,
    LPVOID  lpData
    )
{
    CString csFileName(lpstrFilename);

    //
    // See if they're requesting information on a known DX file.
    //
    CheckDirectXFile(csFileName);

    return ORIGINAL_API(GetFileVersionInfoW)( 
                        lpstrFilename, 
                        dwHandle, 
                        dwLen, 
                        lpData);
}

/*++

 Build the linked list of files to look for.

--*/
BOOL
BuildFileList(
    void
    )
{
    int         nCount;
    FILELIST*   pFileList = NULL;

    for (nCount = 0; nCount < g_nNumDirectX7a; nCount++) {
        //
        // Allocate a new node, then assign the file name
        // from our global array.
        //
        pFileList = new FILELIST;

        if (!pFileList) {
            LOGN(eDbgLevelError, "[BuildFileList] Failed to allocate memory");
            return FALSE;
        }

        pFileList->csFileName = g_szDirectX7aFiles[nCount];

        pFileList->pNext = g_pFileListHead;
        g_pFileListHead = pFileList;
        
    }
    
    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_DXFILEVERINFO_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_DXFILEVERINFO_FRIENDLY)
    SHIM_INFO_VERSION(1, 2)
    SHIM_INFO_FLAGS(AVRF_FLAG_EXTERNAL_ONLY)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return BuildFileList();
    }

    return TRUE;
}

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_DXFILEVERSIONINFO_DXFILE, 
                            AVS_DXFILEVERINFO_DXFILE,
                            AVS_DXFILEVERINFO_DXFILE_R,
                            AVS_DXFILEVERINFO_DXFILE_URL)

    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoA)
    APIHOOK_ENTRY(VERSION.DLL, GetFileVersionInfoW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\filepaths.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   FilePaths.cpp

 Abstract:

   This AppVerifier shim hooks the APIs that require
   the caller to provide a path to a file or directory
   and attempts to ensure that the path is not a hardcoded
   one.

 Notes:

   This is a general purpose shim.

 Created:

   02/26/2001   clupu

 Modified:

  07/24/2001    rparsons    Added hooks for Nt* calls
                            Added checks for apps that use environment variables

  09/04/2001    rparsons    Fixed a bug in the Massage functions where we would
                            stop processing a fake path as soon as we found a hardcode
                            path. Also, we now fix multiple fake paths in the same string.

  10/17/2001    rparsons    Fixed bug where we wouldn't always report a bad path.
                            This was because the CString Find method is case sensitive,
                            but the paths we were comparing were mixed in case. Now all
                            paths are in lower case form prior to the comparison.

  11/21/2001    rparsons    Fixed Raid bug # 492674. FilePaths did not contain an implementation
                            for SHFileOperation - apps that used this API would not get their
                            paths corrected, thus failing.

  11/29/2001    rparsons    Fixed Raid bug # 497853. Removed the hooks for GetTempFileName as they
                            were causing a false positive to be generated. Also added code that
                            would handle cases where the user provides a path via a common dialog
                            and we provide a fake path to be massaged later.

  12/11/2001    rparsons    Fixed Raid bug # 505599. Added hooks for all RegQueryValue* calls
                            and NtQueryValueKey. The Nt hook allows us to catch paths for
                            system components.

  02/20/2002    rparsons    Implemented strsafe functions.
--*/
#include "precomp.h"
#include "rtlutils.h"

IMPLEMENT_SHIM_BEGIN(FilePaths)
#include "ShimHookMacro.h"
#include "ShimCString.h"
#include "veriflog.h"
#include "ids.h"

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(GetCommandLineA)
    APIHOOK_ENUM_ENTRY(GetCommandLineW)

    APIHOOK_ENUM_ENTRY(GetTempPathA)
    APIHOOK_ENUM_ENTRY(GetTempPathW)

    APIHOOK_ENUM_ENTRY(GetOpenFileNameA)
    APIHOOK_ENUM_ENTRY(GetOpenFileNameW)

    APIHOOK_ENUM_ENTRY(GetSaveFileNameA)
    APIHOOK_ENUM_ENTRY(GetSaveFileNameW)

    APIHOOK_ENUM_ENTRY(GetModuleFileNameA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameW)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameExA)
    APIHOOK_ENUM_ENTRY(GetModuleFileNameExW)

    APIHOOK_ENUM_ENTRY(GetCurrentDirectoryA)
    APIHOOK_ENUM_ENTRY(GetCurrentDirectoryW)

    APIHOOK_ENUM_ENTRY(GetSystemDirectoryA)
    APIHOOK_ENUM_ENTRY(GetSystemDirectoryW)
    APIHOOK_ENUM_ENTRY(GetSystemWindowsDirectoryA)
    APIHOOK_ENUM_ENTRY(GetSystemWindowsDirectoryW)
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryA)
    APIHOOK_ENUM_ENTRY(GetWindowsDirectoryW)

    APIHOOK_ENUM_ENTRY(SHGetFolderPathA)
    APIHOOK_ENUM_ENTRY(SHGetFolderPathW)

    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderPathA)
    APIHOOK_ENUM_ENTRY(SHGetSpecialFolderPathW)

    APIHOOK_ENUM_ENTRY(SHGetPathFromIDListA)
    APIHOOK_ENUM_ENTRY(SHGetPathFromIDListW)

    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(ShellExecuteA)
    APIHOOK_ENUM_ENTRY(ShellExecuteW)
    APIHOOK_ENUM_ENTRY(ShellExecuteExA)
    APIHOOK_ENUM_ENTRY(ShellExecuteExW)

    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)

    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(CopyFileExA)
    APIHOOK_ENUM_ENTRY(CopyFileExW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExW)

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)

    APIHOOK_ENUM_ENTRY(FindFirstFileA)
    APIHOOK_ENUM_ENTRY(FindFirstFileW)
    APIHOOK_ENUM_ENTRY(FindFirstFileExA)
    APIHOOK_ENUM_ENTRY(FindFirstFileExW)

    APIHOOK_ENUM_ENTRY(GetBinaryTypeA)
    APIHOOK_ENUM_ENTRY(GetBinaryTypeW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesW)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExA)
    APIHOOK_ENUM_ENTRY(GetFileAttributesExW)
    APIHOOK_ENUM_ENTRY(SetFileAttributesA)
    APIHOOK_ENUM_ENTRY(SetFileAttributesW)

    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(MoveFileExA)
    APIHOOK_ENUM_ENTRY(MoveFileExW)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressA)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressW)

    APIHOOK_ENUM_ENTRY(RemoveDirectoryA)
    APIHOOK_ENUM_ENTRY(RemoveDirectoryW)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryA)
    APIHOOK_ENUM_ENTRY(SetCurrentDirectoryW)
    APIHOOK_ENUM_ENTRY(LoadLibraryA)
    APIHOOK_ENUM_ENTRY(LoadLibraryW)
    APIHOOK_ENUM_ENTRY(LoadLibraryExA)
    APIHOOK_ENUM_ENTRY(LoadLibraryExW)

    APIHOOK_ENUM_ENTRY(SearchPathA)
    APIHOOK_ENUM_ENTRY(SearchPathW)

    APIHOOK_ENUM_ENTRY(SHFileOperationA)
    APIHOOK_ENUM_ENTRY(SHFileOperationW)

    APIHOOK_ENUM_ENTRY(ExpandEnvironmentStringsA)
    APIHOOK_ENUM_ENTRY(ExpandEnvironmentStringsW)

    APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoSizeW)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoA)
    APIHOOK_ENUM_ENTRY(GetFileVersionInfoW)

    APIHOOK_ENUM_ENTRY(OpenFile)

    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)

    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)

    APIHOOK_ENUM_ENTRY(NtCreateFile)
    APIHOOK_ENUM_ENTRY(NtOpenFile)
    APIHOOK_ENUM_ENTRY(NtQueryAttributesFile)
    APIHOOK_ENUM_ENTRY(NtQueryFullAttributesFile)
    APIHOOK_ENUM_ENTRY(NtCreateProcessEx)

    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lcreat)

APIHOOK_ENUM_END

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(FilePaths)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_GETTEMPPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_WINDOWSPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSWINDOWSPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSTEMPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PERSONALPATH)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONPROGRAMS)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONSTARTMENU)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PROGRAMS)
    VERIFIER_LOG_ENTRY(VLOG_HARDCODED_STARTMENU)
END_DEFINE_VERIFIER_LOG(FilePaths)

INIT_VERIFIER_LOG(FilePaths);


// This is a private define (shlapip.h) that can mess up ShellExecuteEx
#ifndef SEE_MASK_FILEANDURL
#define SEE_MASK_FILEANDURL       0x00400000
#endif

#define MAX_HARDCODED_PATHS 4

//
// Linked-list for SHFileOperation
//
typedef struct FILELIST {
    struct FILELIST*    pNext;
    UINT                cchSize;
    LPWSTR              pwszFilePath;
} FILELIST, *PFILELIST;

enum ListType {
    eFrom = 0,
    eTo
};

//
// Head of the linked-lists for SHFileOperation
//
PFILELIST   g_pFileListFromHead = NULL;
PFILELIST   g_pFileListToHead = NULL;

//
// Critical section to keep our linked list safe.
//
RTL_CRITICAL_SECTION    g_csLinkedList;

//
// Fake command-line for GetCommandLine calls.
//
LPSTR   g_pszCommandLineA;
LPWSTR  g_pwszCommandLineW;

typedef struct _PATH_INFO {
    char    szSimulatedPathA[256];
    WCHAR   szSimulatedPathW[256];

    char    szCorrectPathA[MAX_PATH];
    WCHAR   szCorrectPathW[MAX_PATH];

    int     nSimulatedPathLen;
    int     nCorrectPathLen;

    char    szHardCodedPathsA[MAX_HARDCODED_PATHS][MAX_PATH];
    WCHAR   szHardCodedPathsW[MAX_HARDCODED_PATHS][MAX_PATH];

    DWORD   dwIssueCode;
} PATH_INFO, *PPATH_INFO;


//
// the following enum and the g_Paths initializers must be kept in parallel
// Note: The paths must be in lower case for the comparison to work properly.
//
enum _PATH_NUM {
    PATH_TEMP = 0,
    PATH_WINDOWS,
    PATH_SYSTEM_WINDOWS,
    PATH_SYSTEM,
    PATH_PERSONAL,
    PATH_COMMON_PROGRAMS,
    PATH_COMMON_STARTMENU,
    PATH_PROGRAMS,
    PATH_STARTMENU
};

PATH_INFO g_Paths[] = {
    {
       "c:\\abc\\temppath\\123\\",
       L"c:\\abc\\temppath\\123\\",
       "",
       L"",
       0,
       0,
       {
           "\\temp\\",
           "",
           "",
           ""
       },
       {
           L"\\temp\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_GETTEMPPATH
    },
    {
       "c:\\abc\\windowsdir\\123",
       L"c:\\abc\\windowsdir\\123",
       "",
       L"",
       0,
       0,
       {
           ":\\windows\\",
           ":\\winnt\\",
           "",
           ""
       },
       {
           L":\\windows\\",
           L":\\winnt\\",
           L"",
           L""
       },
       VLOG_HARDCODED_WINDOWSPATH
    },
    {
       "c:\\abc\\systemwindowsdir\\123",
       L"c:\\abc\\systemwindowsdir\\123",
       "",
       L"",
       0,
       0,
       {
           ":\\windows\\",
           ":\\winnt\\",
           "",
           ""
       },
       {
           L":\\windows\\",
           L":\\winnt\\",
           L"",
           L""
       },
       VLOG_HARDCODED_SYSWINDOWSPATH
    },
    {
       "c:\\abc\\systemdir\\123",
       L"c:\\abc\\systemdir\\123",
       "",
       L"",
       0,
       0,
       {
           "\\system\\",
           "\\system32\\",
           "",
           ""
       },
       {
           L"\\system\\",
           L"\\system32\\",
           L"",
           L""
       },
       VLOG_HARDCODED_SYSTEMPATH
    },
    {
       "c:\\abc\\personal\\123",
       L"c:\\abc\\personal\\123",
       "",
       L"",
       0,
       0,
       {
           "\\my documents\\",
           "",
           "",
           ""
       },
       {
           L"\\my documents\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_PERSONALPATH
    },
    {
       "c:\\abc\\commonprograms\\123",
       L"c:\\abc\\commonprograms\\123",
       "",
       L"",
       0,
       0,
       {
           "\\all users\\start menu\\programs\\",
           "",
           "",
           ""
       },
       {
           L"\\all users\\start menu\\programs\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_COMMONPROGRAMS
    },
    {
       "c:\\abc\\commonstartmenu\\123",
       L"c:\\abc\\commonstartmenu\\123",
       "",
       L"",
       0,
       0,
       {
           "\\all users\\start menu\\",
           "",
           "",
           ""
       },
       {
           L"\\all users\\start menu\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_COMMONSTARTMENU
    },
    {
       "c:\\abc\\programs\\123",
       L"c:\\abc\\programs\\123",
       "",
       L"",
       0,
       0,
       {
           "\\start menu\\programs\\",
           "",
           "",
           ""
       },
       {
           L"\\start menu\\programs\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_PROGRAMS
    },
    {
       "c:\\abc\\startmenu\\123",
       L"c:\\abc\\startmenu\\123",
       "",
       L"",
       0,
       0,
       {
           "\\start menu\\",
           "",
           "",
           ""
       },
       {
           L"\\start menu\\",
           L"",
           L"",
           L""
       },
       VLOG_HARDCODED_STARTMENU
    }

};

const int g_nPaths = sizeof(g_Paths)/sizeof(g_Paths[0]);

static BOOL g_bPathsInited = FALSE;

void
InitFakeCommandLine(
    void
    )
{
    int     cchSize;
    int     nPathIndex;
    BOOL    fReplaced = FALSE;

    CString csCommandLine(GetCommandLineW());

    csCommandLine.MakeLower();

    //
    // Point them to the normal command-line at first.
    //
    g_pwszCommandLineW = GetCommandLineW();
    g_pszCommandLineA = GetCommandLineA();

    //
    // Replace real paths with simulated paths.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        if (csCommandLine.Replace(g_Paths[nPathIndex].szCorrectPathW,
                                  g_Paths[nPathIndex].szSimulatedPathW)) {
            fReplaced = TRUE;
        }
    }

    if (fReplaced) {
        //
        // Allocate room on the heap and save the command line away.
        //
        cchSize = csCommandLine.GetLength();

        g_pwszCommandLineW = (LPWSTR)malloc(cchSize * sizeof(WCHAR));

        if (!g_pwszCommandLineW) {
            DPFN(eDbgLevelError, "[InitFakeCommandLine] No memory available");
            return;
        }

        g_pszCommandLineA = (LPSTR)malloc(cchSize);

        if (!g_pszCommandLineA) {
            DPFN(eDbgLevelError, "[InitFakeCommandLine] No memory available");
            free(g_pwszCommandLineW);
            return;
        }

        StringCchCopy(g_pwszCommandLineW, cchSize, csCommandLine.Get());
        StringCchCopyA(g_pszCommandLineA, cchSize, csCommandLine.GetAnsi());
    }
}

void
InitPaths(
    void
    )
{
    g_bPathsInited = TRUE;

    //
    // Convert paths to lower case as this is necessary when performing
    // the comparison.
    //
    CharLowerA(g_Paths[PATH_TEMP].szCorrectPathA);
    CharLowerW(g_Paths[PATH_TEMP].szCorrectPathW);

    CharLowerA(g_Paths[PATH_WINDOWS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_WINDOWS].szCorrectPathW);

    CharLowerA(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathW);

    CharLowerA(g_Paths[PATH_SYSTEM].szCorrectPathA);
    CharLowerW(g_Paths[PATH_SYSTEM].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PERSONAL].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_PERSONAL, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PERSONAL].szCorrectPathW);
    g_Paths[PATH_PERSONAL].nCorrectPathLen = strlen(g_Paths[PATH_PERSONAL].szCorrectPathA);
    g_Paths[PATH_PERSONAL].nSimulatedPathLen = strlen(g_Paths[PATH_PERSONAL].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_PERSONAL].szCorrectPathA);
    CharLowerW(g_Paths[PATH_PERSONAL].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_STARTMENU].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_STARTMENU].szCorrectPathW);
    g_Paths[PATH_STARTMENU].nCorrectPathLen = strlen(g_Paths[PATH_STARTMENU].szCorrectPathA);
    g_Paths[PATH_STARTMENU].nSimulatedPathLen = strlen(g_Paths[PATH_STARTMENU].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_STARTMENU].szCorrectPathA);
    CharLowerW(g_Paths[PATH_STARTMENU].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_STARTMENU].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_COMMON_STARTMENU, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_STARTMENU].szCorrectPathW);
    g_Paths[PATH_COMMON_STARTMENU].nCorrectPathLen = strlen(g_Paths[PATH_COMMON_STARTMENU].szCorrectPathA);
    g_Paths[PATH_COMMON_STARTMENU].nSimulatedPathLen = strlen(g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_COMMON_STARTMENU].szCorrectPathA);
    CharLowerW(g_Paths[PATH_COMMON_STARTMENU].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PROGRAMS].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_PROGRAMS].szCorrectPathW);
    g_Paths[PATH_PROGRAMS].nCorrectPathLen = strlen(g_Paths[PATH_PROGRAMS].szCorrectPathA);
    g_Paths[PATH_PROGRAMS].nSimulatedPathLen = strlen(g_Paths[PATH_PROGRAMS].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_PROGRAMS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_PROGRAMS].szCorrectPathW);

    SHGetFolderPathA(NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathA);
    SHGetFolderPathW(NULL, CSIDL_COMMON_PROGRAMS, NULL, SHGFP_TYPE_CURRENT,  g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathW);
    g_Paths[PATH_COMMON_PROGRAMS].nCorrectPathLen = strlen(g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathA);
    g_Paths[PATH_COMMON_PROGRAMS].nSimulatedPathLen = strlen(g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathA);
    CharLowerA(g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathA);
    CharLowerW(g_Paths[PATH_COMMON_PROGRAMS].szCorrectPathW);

    InitFakeCommandLine();
}

inline void
FPFreeA(
    LPSTR  lpMalloc,
    LPCSTR lpOrig
    )
{
    if (lpMalloc != lpOrig) {
        free((LPVOID)lpMalloc);
    }
}

inline void
FPFreeW(
    LPWSTR  lpMalloc,
    LPCWSTR lpOrig
    )
{
    if (lpMalloc != lpOrig) {
        free((LPVOID)lpMalloc);
    }
}

void
MassageRealPathToFakePathW(
    LPWSTR pwszPath,
    DWORD  cchBufferSize
    )
{
    int  nPathIndex;
    BOOL fReplaced = FALSE;

    if (!pwszPath || 0 == cchBufferSize) {
        return;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }

    DPFN(eDbgLevelInfo, "[MassageRealPathToFakePath] '%ls'", pwszPath);

    CString csString(pwszPath);

    csString.MakeLower();

    //
    // Replace real paths with simulated paths.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        if (csString.Replace(g_Paths[nPathIndex].szCorrectPathW,
                             g_Paths[nPathIndex].szSimulatedPathW)) {
            fReplaced = TRUE;
        }
    }

    if (fReplaced) {
        //
        // Ensure that the buffer is large enough to contain the new path.
        //
        if (cchBufferSize < (DWORD)csString.GetLength()) {
            DPFN(eDbgLevelError,
                 "[MassageRealPathToFakePath] Buffer is not large enough. Need %d have %lu",
                 csString.GetLength(),
                 cchBufferSize);
            return;
        } else {
            StringCchCopy(pwszPath, cchBufferSize, csString);
        }
    }
}

void
MassageRealPathToFakePathA(
    LPSTR pszPath,
    DWORD cchBufferSize
    )
{
    int  nPathIndex;
    BOOL fReplaced = FALSE;

    if (!pszPath || 0 == cchBufferSize) {
        return;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }

    DPFN(eDbgLevelInfo, "[MassageRealPathToFakePath] '%s'", pszPath);

    CString csString(pszPath);

    csString.MakeLower();

    //
    // Replace real paths with simulated paths.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        if (csString.Replace(g_Paths[nPathIndex].szCorrectPathW,
                             g_Paths[nPathIndex].szSimulatedPathW)) {
            fReplaced = TRUE;
        }
    }

    if (fReplaced) {
        //
        // Ensure that the buffer is large enough to contain the new path.
        //
        if (cchBufferSize < (DWORD)csString.GetLength()) {
            DPFN(eDbgLevelError,
                 "[MassageRealPathToFakePath] Buffer is not large enough. Need %d have %lu",
                 csString.GetLength(),
                 cchBufferSize);
            return;
        } else {
            StringCchCopyA(pszPath, cchBufferSize, csString.GetAnsi());
        }
    }
}

LPWSTR
MassageStringForPathW(
    LPCWSTR pwszString
    )
{
    int     nPosition;
    int     nPathIndex, nHardcodedIndex;
    UINT    nLen = 0;
    UINT    cFakePaths = 0;
    LPWSTR  pwszPath;
    LPWSTR  pwszNew = NULL;
    CString csToken(L"");

    if (pwszString == NULL || *pwszString == 0) {
        return (LPWSTR)pwszString;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }

    DPFN(eDbgLevelInfo, "[MassageStringForPathW] '%ls'", pwszString);

    //
    // Search the string for hardcoded paths first.
    //
    CString csString(pwszString);

    csString.MakeLower();

    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {

        for (nHardcodedIndex = 0; nHardcodedIndex < MAX_HARDCODED_PATHS; ++nHardcodedIndex) {
            pwszPath = g_Paths[nPathIndex].szHardCodedPathsW[nHardcodedIndex];

            if (!pwszPath[0]) {
                break;
            }

            nPosition = csString.Find(pwszPath);

            if (nPosition != -1) {
                VLOG(VLOG_LEVEL_ERROR,
                     g_Paths[nPathIndex].dwIssueCode,
                     "Hardcoded path found in path '%ls'.",
                     pwszString);
                break;
            }
            nPosition = 0;
        }
    }

    //
    // Now search for the fake paths that we substituted ourselves.
    //
    CStringToken csTokenList(csString, L" ");

    while (csTokenList.GetToken(csToken)) {

        csToken.MakeLower();
        for (nPathIndex = 0, nPosition = 0; nPathIndex < g_nPaths; ++nPathIndex) {

            nPosition = csToken.Find(g_Paths[nPathIndex].szSimulatedPathW);

            if (nPosition != -1) {
                cFakePaths++;
                break;
            }
            nPosition = 0;
        }
    }

    //
    // See if the string contained any fake paths. If not, we're done here.
    //
    if (!cFakePaths) {
        return (LPWSTR)pwszString;
    }

    //
    // Our string has simulated paths; replace them.
    //
    for (nPathIndex = 0; nPathIndex < g_nPaths; ++nPathIndex) {
        csString.Replace(g_Paths[nPathIndex].szSimulatedPathW,
                         g_Paths[nPathIndex].szCorrectPathW);
    }

    //
    // Allocate a string large enough to hold the corrected path and
    // give it back to the caller. They'll free it later.
    //
    nLen =  MAX_PATH * cFakePaths;
    nLen += csString.GetLength();

    pwszNew = (LPWSTR)malloc((nLen + 1) * sizeof(WCHAR));

    if (!pwszNew) {
        DPFN(eDbgLevelError,
             "[MassageStringForPathW] Failed to allocate memory");
        return (LPWSTR)pwszString;
    }

    StringCchCopy(pwszNew, nLen + 1, csString);

    DPFN(eDbgLevelInfo,
         "[MassageStringForPathW] Replaced '%ls' with '%ls'",
         pwszString,
         pwszNew);

    return pwszNew;
}

LPSTR
MassageStringForPathA(
    LPCSTR pszString
    )
{
    int     cchSize, nRetLen = 0;
    WCHAR   wszTmp[MAX_PATH];
    LPWSTR  pwszReturn = NULL;
    LPSTR   pszNew = NULL;

    if (pszString == NULL || *pszString == 0) {
        return (LPSTR)pszString;
    }

    if (!g_bPathsInited) {
        InitPaths();
    }

    //
    // Convert from ANSI to Unicode so we can pass this on
    // to the Unicode version of the function.
    //
    cchSize = MultiByteToWideChar(CP_ACP,
                                  0,
                                  pszString,
                                  -1,
                                  wszTmp,
                                  ARRAYSIZE(wszTmp));

    if (cchSize == 0) {
        DPFN(eDbgLevelError, "[MassageStringForPathA] Ansi -> Unicode failed");
        return (LPSTR)pszString;
    }

    pwszReturn = MassageStringForPathW(wszTmp);

    //
    // If the return is the same as the source, we're done.
    //
    if (!_wcsicmp(pwszReturn, wszTmp)) {
        return (LPSTR)pszString;
    }

    //
    // Allocate a buffer large enough to hold the return
    // and give it back to the caller as ANSI.
    //
    nRetLen = wcslen(pwszReturn) + 1;

    pszNew = (LPSTR)malloc(nRetLen);

    if (!pszNew) {
        DPFN(eDbgLevelError, "[MassageStringForPathA] No memory available");
        return (LPSTR)pszString;
    }

    cchSize = WideCharToMultiByte(CP_ACP,
                                  0,
                                  pwszReturn,
                                  -1,
                                  pszNew,
                                  nRetLen,
                                  NULL,
                                  NULL);

    if (cchSize == 0) {
        DPFN(eDbgLevelError, "[MassageStringForPathA] Unicode -> Ansi failed");
        free(pszNew);
        return (LPSTR)pszString;
    }

    free(pwszReturn);

    return pszNew;
}

void
MassageNtPath(
    IN  POBJECT_ATTRIBUTES pObjectAttributes,
    OUT POBJECT_ATTRIBUTES pRetObjectAttributes
    )
{
    NTSTATUS                    status;
    PUNICODE_STRING             pstrObjectName = NULL;
    LPWSTR                      pwszString = NULL;
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH * 2];
    BOOL                        TranslationStatus = FALSE;

    //
    // Preserve the existing attributes.
    //
    InitializeObjectAttributes(pRetObjectAttributes,
                               pObjectAttributes->ObjectName,
                               pObjectAttributes->Attributes,
                               pObjectAttributes->RootDirectory,
                               pObjectAttributes->SecurityDescriptor);

    //
    // Ensure that we have a valid source path to work with.
    //
    if (!pObjectAttributes->ObjectName->Buffer) {
        return;
    }

    DPFN(eDbgLevelInfo,
         "[MassageNtPath] '%ls'",
         pObjectAttributes->ObjectName->Buffer);

    //
    // Convert from an NT path to a DOS path.
    //
    RtlInitUnicodeStringBuffer(&DosPathBuffer,
                               PathBuffer,
                               sizeof(PathBuffer));

    status = ShimAssignUnicodeStringBuffer(&DosPathBuffer,
                                           pObjectAttributes->ObjectName);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[MassageNtPath] Failed to initialize DOS path buffer");
        return;
    }

    status = ShimNtPathNameToDosPathName(0, &DosPathBuffer, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[MassageNtPath] Failed to convert NT '%ls' to DOS path",
             pObjectAttributes->ObjectName->Buffer);
        goto cleanup;
    }

    //
    // Now check for a hardcoded path.
    //
    pwszString = MassageStringForPathW(DosPathBuffer.String.Buffer);

    //
    // Convert from a DOS path to an NT path name.
    //
    pstrObjectName = (PUNICODE_STRING)RtlAllocateHeap(RtlProcessHeap(),
                                                      HEAP_ZERO_MEMORY,
                                                      sizeof(UNICODE_STRING));

    if (!pstrObjectName) {
        DPFN(eDbgLevelError, "[MassageNtPath] Failed to allocate memory");
        goto cleanup;
    }

    TranslationStatus = RtlDosPathNameToNtPathName_U(pwszString,
                                                     pstrObjectName,
                                                     NULL,
                                                     NULL);

    if (!TranslationStatus) {
        DPFN(eDbgLevelError,
             "[MassageNtPath] Failed to convert DOS '%ls' to NT path",
             pwszString);
        goto cleanup;
    }

    //
    // Everything worked, so now we update the ObjectName and return it through
    // the structure.
    //
    pRetObjectAttributes->ObjectName = pstrObjectName;

cleanup:

    FPFreeW(pwszString, DosPathBuffer.String.Buffer);

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);
}

inline
void
FPNtFree(
    IN POBJECT_ATTRIBUTES pOriginal,
    IN POBJECT_ATTRIBUTES pAllocated
    )
{
    RtlFreeUnicodeString(pAllocated->ObjectName);

    if (pOriginal->ObjectName != pAllocated->ObjectName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pAllocated->ObjectName);
    }
}

LPSTR
APIHOOK(GetCommandLineA)(
    void
    )
{
    if (g_bPathsInited) {
        return g_pszCommandLineA;
    } else {
        return ORIGINAL_API(GetCommandLineA)();
    }
}

LPWSTR
APIHOOK(GetCommandLineW)(
    void
    )
{
    if (g_bPathsInited) {
        return g_pwszCommandLineW;
    } else {
        return ORIGINAL_API(GetCommandLineW)();
    }
}

DWORD
APIHOOK(GetFileAttributesA)(
    LPCSTR lpFileName           // name of file or directory
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetFileAttributesA)(lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(GetFileAttributesW)(
    LPCWSTR lpFileName          // name of file or directory
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetFileAttributesW)(lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(SetFileAttributesA)(
    LPCSTR lpFileName,          // file name
    DWORD  dwFileAttributes     // attributes
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(SetFileAttributesA)(lpszString, dwFileAttributes);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(SetFileAttributesW)(
    LPCWSTR lpFileName,         // file name
    DWORD   dwFileAttributes    // attributes
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(SetFileAttributesW)(lpszString, dwFileAttributes);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(GetFileAttributesExA)(
    LPCSTR lpFileName,                       // file or directory name
    GET_FILEEX_INFO_LEVELS fInfoLevelId,     // attribute
    LPVOID                 lpFileInformation // attribute information
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExA)(lpszString,
                                                          fInfoLevelId,
                                                          lpFileInformation);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(GetFileAttributesExW)(
    LPCWSTR                lpFileName,       // file or directory name
    GET_FILEEX_INFO_LEVELS fInfoLevelId,     // attribute
    LPVOID                 lpFileInformation // attribute information
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetFileAttributesExW)(lpszString,
                                                          fInfoLevelId,
                                                          lpFileInformation);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}

BOOL
APIHOOK(CreateProcessA)(
    LPCSTR                  lpApplicationName,
    LPSTR                   lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCSTR                  lpCurrentDirectory,
    LPSTARTUPINFOA          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    LPSTR lpszStringAppName = MassageStringForPathA(lpApplicationName);
    LPSTR lpszStringCmdLine = MassageStringForPathA(lpCommandLine);

    BOOL returnValue = ORIGINAL_API(CreateProcessA)(lpszStringAppName,
                                                    lpszStringCmdLine,
                                                    lpProcessAttributes,
                                                    lpThreadAttributes,
                                                    bInheritHandles,
                                                    dwCreationFlags,
                                                    lpEnvironment,
                                                    lpCurrentDirectory,
                                                    lpStartupInfo,
                                                    lpProcessInformation);

    FPFreeA(lpszStringAppName, lpApplicationName);
    FPFreeA(lpszStringCmdLine, lpCommandLine);

    return returnValue;
}


BOOL
APIHOOK(CreateProcessW)(
    LPCWSTR                 lpApplicationName,
    LPWSTR                  lpCommandLine,
    LPSECURITY_ATTRIBUTES   lpProcessAttributes,
    LPSECURITY_ATTRIBUTES   lpThreadAttributes,
    BOOL                    bInheritHandles,
    DWORD                   dwCreationFlags,
    LPVOID                  lpEnvironment,
    LPCWSTR                 lpCurrentDirectory,
    LPSTARTUPINFOW          lpStartupInfo,
    LPPROCESS_INFORMATION   lpProcessInformation
    )
{
    LPWSTR lpszStringAppName = MassageStringForPathW(lpApplicationName);
    LPWSTR lpszStringCmdLine = MassageStringForPathW(lpCommandLine);

    BOOL returnValue = ORIGINAL_API(CreateProcessW)(lpszStringAppName,
                                                    lpszStringCmdLine,
                                                    lpProcessAttributes,
                                                    lpThreadAttributes,
                                                    bInheritHandles,
                                                    dwCreationFlags,
                                                    lpEnvironment,
                                                    lpCurrentDirectory,
                                                    lpStartupInfo,
                                                    lpProcessInformation);

    FPFreeW(lpszStringAppName, lpApplicationName);
    FPFreeW(lpszStringCmdLine, lpCommandLine);

    return returnValue;
}


UINT
APIHOOK(WinExec)(
    LPCSTR lpCmdLine,
    UINT   uCmdShow
    )
{
    LPSTR lpszString = MassageStringForPathA(lpCmdLine);

    UINT returnValue = ORIGINAL_API(WinExec)(lpszString, uCmdShow);

    FPFreeA(lpszString, lpCmdLine);

    return returnValue;
}


HINSTANCE
APIHOOK(ShellExecuteA)(
    HWND   hwnd,
    LPCSTR lpVerb,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    INT    nShowCmd
    )
{
    LPSTR lpszStringFile = MassageStringForPathA(lpFile);
    LPSTR lpszStringDir = MassageStringForPathA(lpDirectory);

    HINSTANCE returnValue = ORIGINAL_API(ShellExecuteA)(hwnd,
                                                        lpVerb,
                                                        lpszStringFile,
                                                        lpParameters,
                                                        lpszStringDir,
                                                        nShowCmd);

    FPFreeA(lpszStringFile, lpFile);
    FPFreeA(lpszStringDir, lpDirectory);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteW

--*/

HINSTANCE
APIHOOK(ShellExecuteW)(
    HWND    hwnd,
    LPCWSTR lpVerb,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    INT     nShowCmd
    )
{
    LPWSTR lpszStringFile = MassageStringForPathW(lpFile);
    LPWSTR lpszStringDir = MassageStringForPathW(lpDirectory);

    HINSTANCE returnValue = ORIGINAL_API(ShellExecuteW)(hwnd,
                                                        lpVerb,
                                                        lpszStringFile,
                                                        lpParameters,
                                                        lpszStringDir,
                                                        nShowCmd);

    FPFreeW(lpszStringFile, lpFile);
    FPFreeW(lpszStringDir, lpDirectory);

    return returnValue;
}

BOOL
APIHOOK(ShellExecuteExA)(
    LPSHELLEXECUTEINFOA lpExecInfo
    )
{
    //
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    //
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL) {
        return ORIGINAL_API(ShellExecuteExA)(lpExecInfo);
    }

    LPSTR lpszStringFile = MassageStringForPathA(lpExecInfo->lpFile);
    LPSTR lpszStringDir = MassageStringForPathA(lpExecInfo->lpDirectory);

    LPCSTR lpFileSave = lpExecInfo->lpFile;
    LPCSTR lpDirSave  = lpExecInfo->lpDirectory;

    lpExecInfo->lpFile      = lpszStringFile;
    lpExecInfo->lpDirectory = lpszStringDir;

    BOOL returnValue = ORIGINAL_API(ShellExecuteExA)(lpExecInfo);

    lpExecInfo->lpFile      = lpFileSave;
    lpExecInfo->lpDirectory = lpDirSave;

    FPFreeA(lpszStringFile, lpFileSave);
    FPFreeA(lpszStringDir, lpDirSave);

    return returnValue;
}

/*++

    Convert Win9x paths to WinNT paths for ShellExecuteExW

--*/

BOOL
APIHOOK(ShellExecuteExW)(
    LPSHELLEXECUTEINFOW lpExecInfo
    )
{
    //
    // Check for this magical *internal* flag that tells the system
    // that lpExecInfo->lpFile is actually a file and URL combined with
    // a 0 byte seperator, (file\0url\0)
    // Since this is internal only, we should not be receiving bad paths.
    //
    if (lpExecInfo->fMask & SEE_MASK_FILEANDURL) {
        return ORIGINAL_API(ShellExecuteExW)(lpExecInfo);
    }

    LPWSTR lpszStringFile = MassageStringForPathW(lpExecInfo->lpFile);
    LPWSTR lpszStringDir = MassageStringForPathW(lpExecInfo->lpDirectory);

    LPCWSTR lpFileSave = lpExecInfo->lpFile;
    LPCWSTR lpDirSave  = lpExecInfo->lpDirectory;

    lpExecInfo->lpFile      = lpszStringFile;
    lpExecInfo->lpDirectory = lpszStringDir;

    BOOL returnValue = ORIGINAL_API(ShellExecuteExW)(lpExecInfo);

    lpExecInfo->lpFile      = lpFileSave;
    lpExecInfo->lpDirectory = lpDirSave;

    FPFreeW(lpszStringFile, lpFileSave);
    FPFreeW(lpszStringDir, lpDirSave);

    return returnValue;
}


UINT
APIHOOK(GetPrivateProfileIntA)(
    LPCSTR  lpAppName,          // section name
    LPCSTR  lpKeyName,          // key name
    INT     nDefault,           // return value if key name not found
    LPCSTR  lpFileName          // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntA)(lpAppName,
                                                           lpKeyName,
                                                           nDefault,
                                                           lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


UINT
APIHOOK(GetPrivateProfileIntW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpKeyName,          // key name
    INT     nDefault,           // return value if key name not found
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    UINT returnValue = ORIGINAL_API(GetPrivateProfileIntW)(lpAppName,
                                                           lpKeyName,
                                                           nDefault,
                                                           lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionA)(
    LPCSTR  lpAppName,          // section name
    LPSTR   lpReturnedString,   // return buffer
    DWORD   nSize,              // size of return buffer
    LPCSTR  lpFileName          // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionA)(lpAppName,
                                                                lpReturnedString,
                                                                nSize,
                                                                lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionW)(
    LPCWSTR lpAppName,          // section name
    LPWSTR  lpReturnedString,   // return buffer
    DWORD   nSize,              // size of return buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionW)(lpAppName,
                                                                lpReturnedString,
                                                                nSize,
                                                                lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionNamesA)(
    LPSTR  lpszReturnBuffer,    // return buffer
    DWORD  nSize,               // size of return buffer
    LPCSTR lpFileName           // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesA)(lpszReturnBuffer,
                                                                     nSize,
                                                                     lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileSectionNamesW)(
    LPWSTR  lpszReturnBuffer,   // return buffer
    DWORD   nSize,              // size of return buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileSectionNamesW)(lpszReturnBuffer,
                                                                     nSize,
                                                                     lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,           // section name
    LPCSTR lpKeyName,           // key name
    LPCSTR lpDefault,           // default string
    LPSTR  lpReturnedString,    // destination buffer
    DWORD  nSize,               // size of destination buffer
    LPCSTR lpFileName           // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringA)(lpAppName,
                                                               lpKeyName,
                                                               lpDefault,
                                                               lpReturnedString,
                                                               nSize,
                                                               lpszString);
    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


DWORD
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpKeyName,          // key name
    LPCWSTR lpDefault,          // default string
    LPWSTR  lpReturnedString,   // destination buffer
    DWORD   nSize,              // size of destination buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(GetPrivateProfileStringW)(lpAppName,
                                                               lpKeyName,
                                                               lpDefault,
                                                               lpReturnedString,
                                                               nSize,
                                                               lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,         // section name
    LPCSTR lpszKey,             // key name
    LPVOID lpStruct,            // return buffer
    UINT   uSizeStruct,         // size of return buffer
    LPCSTR lpFileName           // initialization file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructA)(lpszSection,
                                                              lpszKey,
                                                              lpStruct,
                                                              uSizeStruct,
                                                              lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,        // section name
    LPCWSTR lpszKey,            // key name
    LPVOID  lpStruct,           // return buffer
    UINT    uSizeStruct,        // size of return buffer
    LPCWSTR lpFileName          // initialization file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(GetPrivateProfileStructW)(lpszSection,
                                                              lpszKey,
                                                              lpStruct,
                                                              uSizeStruct,
                                                              lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,           // section name
    LPCSTR lpString,            // data
    LPCSTR lpFileName           // file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionA)(lpAppName,
                                                                 lpString,
                                                                 lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpString,           // data
    LPCWSTR lpFileName          // file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileSectionW)(lpAppName,
                                                                 lpString,
                                                                 lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,           // section name
    LPCSTR lpKeyName,           // key name
    LPCSTR lpString,            // string to add
    LPCSTR lpFileName           // initialization file
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringA)(lpAppName,
                                                                lpKeyName,
                                                                lpString,
                                                                lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,          // section name
    LPCWSTR lpKeyName,          // key name
    LPCWSTR lpString,           // string to add
    LPCWSTR lpFileName          // initialization file
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStringW)(lpAppName,
                                                                lpKeyName,
                                                                lpString,
                                                                lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,         // section name
    LPCSTR lpszKey,             // key name
    LPVOID lpStruct,            // data buffer
    UINT   uSizeStruct,         // size of data buffer
    LPCSTR lpFileName           // initialization file
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructA)(lpszSection,
                                                                lpszKey,
                                                                lpStruct,
                                                                uSizeStruct,
                                                                lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,        // section name
    LPCWSTR lpszKey,            // key name
    LPVOID  lpStruct,           // data buffer
    UINT    uSizeStruct,        // size of data buffer
    LPCWSTR lpFileName          // initialization file
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(WritePrivateProfileStructW)(lpszSection,
                                                                lpszKey,
                                                                lpStruct,
                                                                uSizeStruct,
                                                                lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,  // name of an existing file
    LPCSTR lpNewFileName,       // name of new file
    BOOL   bFailIfExists        // operation if file exists
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(CopyFileA)(lpszStringExisting,
                                               lpszStringNew,
                                               bFailIfExists);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName, // name of an existing file
    LPCWSTR lpNewFileName,      // name of new file
    BOOL    bFailIfExists       // operation if file exists
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(CopyFileW)(lpszStringExisting,
                                               lpszStringNew,
                                               bFailIfExists);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL APIHOOK(CopyFileExA)(
    LPCSTR             lpExistingFileName,  // name of existing file
    LPCSTR             lpNewFileName,       // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // callback parameter
    LPBOOL             pbCancel,            // cancel status
    DWORD              dwCopyFlags          // copy options
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(CopyFileExA)(lpszStringExisting,
                                                 lpszStringNew,
                                                 lpProgressRoutine,
                                                 lpData,
                                                 pbCancel,
                                                 dwCopyFlags);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(CopyFileExW)(
    LPCWSTR            lpExistingFileName,  // name of existing file
    LPCWSTR            lpNewFileName,       // name of new file
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // callback parameter
    LPBOOL             pbCancel,            // cancel status
    DWORD              dwCopyFlags          // copy options
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(CopyFileExW)(lpszStringExisting,
                                                 lpszStringNew,
                                                 lpProgressRoutine,
                                                 lpData,
                                                 pbCancel,
                                                 dwCopyFlags);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryA)(
    LPCSTR                lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    BOOL returnValue = ORIGINAL_API(CreateDirectoryA)(lpszString, lpSecurityAttributes);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryW)(
    LPCWSTR               lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    BOOL returnValue = ORIGINAL_API(CreateDirectoryW)(lpszString, lpSecurityAttributes);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryExA)(
    LPCSTR                lpTemplateDirectory,   // template directory
    LPCSTR                lpNewDirectory,        // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes   // SD
    )
{
    LPSTR lpszStringTemplate = MassageStringForPathA(lpTemplateDirectory);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewDirectory);

    BOOL returnValue = ORIGINAL_API(CreateDirectoryExA)(lpszStringTemplate,
                                                        lpszStringNew,
                                                        lpSecurityAttributes);

    FPFreeA(lpszStringTemplate, lpTemplateDirectory);
    FPFreeA(lpszStringNew, lpNewDirectory);

    return returnValue;
}


BOOL
APIHOOK(CreateDirectoryExW)(
    LPCWSTR               lpTemplateDirectory,  // template directory
    LPCWSTR               lpNewDirectory,       // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPWSTR lpszStringTemplate = MassageStringForPathW(lpTemplateDirectory);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewDirectory);

    BOOL returnValue = ORIGINAL_API(CreateDirectoryExW)(lpszStringTemplate,
                                                        lpszStringNew,
                                                        lpSecurityAttributes);

    FPFreeW(lpszStringTemplate, lpTemplateDirectory);
    FPFreeW(lpszStringNew, lpNewDirectory);

    return returnValue;
}


HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HANDLE returnValue = ORIGINAL_API(CreateFileA)(lpszString,
                                                   dwDesiredAccess,
                                                   dwShareMode,
                                                   lpSecurityAttributes,
                                                   dwCreationDisposition,
                                                   dwFlagsAndAttributes,
                                                   hTemplateFile);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    HANDLE returnValue = ORIGINAL_API(CreateFileW)(lpszString,
                                                   dwDesiredAccess,
                                                   dwShareMode,
                                                   lpSecurityAttributes,
                                                   dwCreationDisposition,
                                                   dwFlagsAndAttributes,
                                                   hTemplateFile);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName           // file name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    BOOL returnValue = ORIGINAL_API(DeleteFileA)(lpszString);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName          // file name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    BOOL returnValue = ORIGINAL_API(DeleteFileW)(lpszString);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileA)(
    LPCSTR             lpFileName,      // file name
    LPWIN32_FIND_DATAA lpFindFileData   // data buffer
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileA)(lpszString, lpFindFileData);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileW)(
  LPCWSTR            lpFileName,        // file name
  LPWIN32_FIND_DATAW lpFindFileData     // data buffer
)
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileW)(lpszString, lpFindFileData);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileExA)(
    LPCSTR             lpFileName,       // file name
    FINDEX_INFO_LEVELS fInfoLevelId,     // information level
    LPVOID             lpFindFileData,   // information buffer
    FINDEX_SEARCH_OPS  fSearchOp,        // filtering type
    LPVOID             lpSearchFilter,   // search criteria
    DWORD              dwAdditionalFlags // additional search control
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExA)(lpszString,
                                                        fInfoLevelId,
                                                        lpFindFileData,
                                                        fSearchOp,
                                                        lpSearchFilter,
                                                        dwAdditionalFlags);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}


HANDLE
APIHOOK(FindFirstFileExW)(
    LPCWSTR            lpFileName,       // file name
    FINDEX_INFO_LEVELS fInfoLevelId,     // information level
    LPVOID             lpFindFileData,   // information buffer
    FINDEX_SEARCH_OPS  fSearchOp,        // filtering type
    LPVOID             lpSearchFilter,   // search criteria
    DWORD              dwAdditionalFlags // additional search control
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpFileName);

    HANDLE returnValue = ORIGINAL_API(FindFirstFileExW)(lpszString,
                                                        fInfoLevelId,
                                                        lpFindFileData,
                                                        fSearchOp,
                                                        lpSearchFilter,
                                                        dwAdditionalFlags);

    FPFreeW(lpszString, lpFileName);

    return returnValue;
}


BOOL
APIHOOK(GetBinaryTypeA)(
    LPCSTR  lpApplicationName,      // full file path
    LPDWORD lpBinaryType            // binary type information
    )
{
    LPSTR lpszString = MassageStringForPathA(lpApplicationName);

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeA)(lpszString, lpBinaryType);

    FPFreeA(lpszString, lpApplicationName);

    return returnValue;
}


BOOL
APIHOOK(GetBinaryTypeW)(
    LPCWSTR lpApplicationName,      // full file path
    LPDWORD lpBinaryType            // binary type information
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpApplicationName);

    BOOL returnValue = ORIGINAL_API(GetBinaryTypeW)(lpszString, lpBinaryType);

    FPFreeW(lpszString, lpApplicationName);

    return returnValue;
}

BOOL
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,      // file name
    LPCSTR lpNewFileName            // new file name
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileA)(lpszStringExisting, lpszStringNew);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,     // file name
    LPCWSTR lpNewFileName           // new file name
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileW)(lpszStringExisting, lpszStringNew);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileExA)(
    LPCSTR lpExistingFileName,      // file name
    LPCSTR lpNewFileName,           // new file name
    DWORD  dwFlags                  // move options
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileExA)(lpszStringExisting, lpszStringNew, dwFlags);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileExW)(
    LPCWSTR lpExistingFileName,     // file name
    LPCWSTR lpNewFileName,          // new file name
    DWORD   dwFlags                 // move options
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileExW)(lpszStringExisting, lpszStringNew, dwFlags);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileWithProgressA)(
    LPCSTR             lpExistingFileName,  // file name
    LPCSTR             lpNewFileName,       // new file name
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // parameter for callback
    DWORD              dwFlags              // move options
    )
{
    LPSTR lpszStringExisting = MassageStringForPathA(lpExistingFileName);
    LPSTR lpszStringNew = MassageStringForPathA(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressA)(lpszStringExisting,
                                                           lpszStringNew,
                                                           lpProgressRoutine,
                                                           lpData,
                                                           dwFlags);

    FPFreeA(lpszStringExisting, lpExistingFileName);
    FPFreeA(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(MoveFileWithProgressW)(
    LPCWSTR            lpExistingFileName,  // file name
    LPCWSTR            lpNewFileName,       // new file name
    LPPROGRESS_ROUTINE lpProgressRoutine,   // callback function
    LPVOID             lpData,              // parameter for callback
    DWORD              dwFlags              // move options
    )
{
    LPWSTR lpszStringExisting = MassageStringForPathW(lpExistingFileName);
    LPWSTR lpszStringNew = MassageStringForPathW(lpNewFileName);

    BOOL returnValue = ORIGINAL_API(MoveFileWithProgressW)(lpExistingFileName,
                                                           lpNewFileName,
                                                           lpProgressRoutine,
                                                           lpData,
                                                           dwFlags);

    FPFreeW(lpszStringExisting, lpExistingFileName);
    FPFreeW(lpszStringNew, lpNewFileName);

    return returnValue;
}


BOOL
APIHOOK(RemoveDirectoryA)(
    LPCSTR lpPathName           // directory name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryA)(lpszString);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(RemoveDirectoryW)(
    LPCWSTR lpPathName          // directory name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    BOOL returnValue = ORIGINAL_API(RemoveDirectoryW)(lpszString);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(SetCurrentDirectoryA)(
    LPCSTR lpPathName           // new directory name
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryA)(lpszString);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}


BOOL
APIHOOK(SetCurrentDirectoryW)(
    LPCWSTR lpPathName          // new directory name
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    BOOL returnValue = ORIGINAL_API(SetCurrentDirectoryW)(lpszString);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryA)(
    LPCSTR lpPathName
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryA)(lpszString);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryW)(
    LPCWSTR lpPathName
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryW)(lpszString);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryExA)(
    LPCSTR  lpPathName,
    HANDLE  hFile,
    DWORD   dwFlags
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryExA)(lpszString, hFile, dwFlags);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}

HMODULE
APIHOOK(LoadLibraryExW)(
    LPCWSTR lpPathName,
    HANDLE  hFile,
    DWORD   dwFlags
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpPathName);

    HMODULE returnValue = ORIGINAL_API(LoadLibraryExW)(lpszString, hFile, dwFlags);

    FPFreeW(lpszString, lpPathName);

    return returnValue;
}

HFILE
APIHOOK(OpenFile)(
    LPCSTR     lpFileName,      // file name
    LPOFSTRUCT lpReOpenBuff,    // file information
    UINT       uStyle           // action and attributes
    )
{
    LPSTR lpszString = MassageStringForPathA(lpFileName);

    HFILE returnValue = ORIGINAL_API(OpenFile)(lpszString, lpReOpenBuff, uStyle);

    MassageRealPathToFakePathA(lpReOpenBuff->szPathName, OFS_MAXPATHNAME);

    FPFreeA(lpszString, lpFileName);

    return returnValue;
}

LONG
APIHOOK(RegSetValueA)(
    HKEY   hKey,            // handle to key
    LPCSTR lpSubKey,        // subkey name
    DWORD  dwType,          // information type
    LPCSTR lpData,          // value data
    DWORD  cbData           // size of value data
    )
{
    LPSTR lpszString = MassageStringForPathA(lpData);

    //
    // Data key is length of string *not* including null byte.
    //
    if (lpszString != NULL) {
        cbData = strlen(lpszString);
    }

    LONG returnValue = ORIGINAL_API(RegSetValueA)(hKey,
                                                  lpSubKey,
                                                  dwType,
                                                  lpszString,
                                                  cbData);

    FPFreeA(lpszString, lpData);

    return returnValue;
}

LONG
APIHOOK(RegSetValueW)(
    HKEY    hKey,           // handle to key
    LPCWSTR lpSubKey,       // subkey name
    DWORD   dwType,         // information type
    LPCWSTR lpData,         // value data
    DWORD   cbData          // size of value data
    )
{
    LPWSTR lpszString = MassageStringForPathW(lpData);

    //
    // Data key is length of string *not* including null byte.
    //
    if (lpszString) {
        cbData = wcslen(lpszString) * sizeof(WCHAR);
    }

    LONG returnValue = ORIGINAL_API(RegSetValueW)(hKey,
                                                  lpSubKey,
                                                  dwType,
                                                  lpszString,
                                                  cbData);

    FPFreeW(lpszString, lpData);

    return returnValue;
}

LONG
APIHOOK(RegSetValueExA)(
    HKEY   hKey,            // handle to key
    LPCSTR lpValueName,     // value name
    DWORD  Reserved,        // reserved
    DWORD  dwType,          // value type
    CONST BYTE *lpData,     // value data
    DWORD  cbData           // size of value data
    )
{
    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ) {

        LPSTR lpszString = MassageStringForPathA((LPCSTR)lpData);

        //
        // Data key is length of string *not* including null byte.
        //
        if (lpszString) {
            cbData = strlen(lpszString);
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExA)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        (CONST BYTE*)lpszString,
                                                        cbData);
        FPFreeA(lpszString, (LPCSTR)lpData);

        return returnValue;

    } else {
        //
        // Pass data on through.
        //
        LONG returnValue = ORIGINAL_API(RegSetValueExA)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        lpData,
                                                        cbData);
        return returnValue;

    }
}

LONG
APIHOOK(RegSetValueExW)(
    HKEY    hKey,           // handle to key
    LPCWSTR lpValueName,    // value name
    DWORD   Reserved,       // reserved
    DWORD   dwType,         // value type
    CONST BYTE *lpData,     // value data
    DWORD   cbData          // size of value data
    )
{
    if (dwType == REG_SZ || dwType == REG_EXPAND_SZ) {

        LPWSTR lpszString = MassageStringForPathW((LPCWSTR)lpData);

        //
        // Data key is length of string *not* including null byte.
        //
        if (lpszString) {
            cbData = (wcslen(lpszString) + 1) * sizeof(WCHAR);
        }

        LONG returnValue = ORIGINAL_API(RegSetValueExW)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        (CONST BYTE*)lpszString,
                                                        cbData);
        FPFreeW(lpszString, (LPCWSTR)lpData);

        return returnValue;

    } else {
        //
        // Pass data on through.
        //
        LONG returnValue = ORIGINAL_API(RegSetValueExW)(hKey,
                                                        lpValueName,
                                                        Reserved,
                                                        dwType,
                                                        lpData,
                                                        cbData);
        return returnValue;
    }

}

LONG
APIHOOK(RegQueryValueA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    LPSTR  lpValue,
    PLONG  lpcbValue
    )
{
    //
    // Obtain the size of the buffer prior to the call.
    // When the call is complete, lpcbValue will contain
    // the size of the data stored in the buffer. We
    // need the size of the buffer.
    //
    LONG cbValue = 0;

    if (lpcbValue) {
        cbValue = *lpcbValue;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueA)(hKey,
                                                    lpSubKey,
                                                    lpValue,
                                                    lpcbValue);

    if (ERROR_SUCCESS == returnValue) {
        MassageRealPathToFakePathA(lpValue, (DWORD)cbValue);
    }

    return returnValue;
}

LONG
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPWSTR  lpValue,
    PLONG   lpcbValue
    )
{
    LONG cbValue = 0;

    if (lpcbValue) {
        cbValue = *lpcbValue;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueW)(hKey,
                                                    lpSubKey,
                                                    lpValue,
                                                    lpcbValue);

    if (ERROR_SUCCESS == returnValue) {
        MassageRealPathToFakePathW(lpValue, (DWORD)cbValue);
    }

    return returnValue;
}

LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPCSTR  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    DWORD cbData = 0;
    DWORD dwType = 0;

    if (lpcbData) {
        cbData = *lpcbData;
    }

    if (!lpType) {
        lpType = &dwType;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueExA)(hKey,
                                                      lpValueName,
                                                      lpReserved,
                                                      lpType,
                                                      lpData,
                                                      lpcbData);

    if (ERROR_SUCCESS == returnValue) {
        if (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ) {
            MassageRealPathToFakePathA((LPSTR)lpData, cbData);
        }
    }

    return returnValue;
}

LONG
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    DWORD cbData = 0;
    DWORD dwType = 0;

    if (lpcbData) {
        cbData = *lpcbData;
    }

    if (!lpType) {
        lpType = &dwType;
    }

    LONG returnValue = ORIGINAL_API(RegQueryValueExW)(hKey,
                                                      lpValueName,
                                                      lpReserved,
                                                      lpType,
                                                      lpData,
                                                      lpcbData);

    if (ERROR_SUCCESS == returnValue) {
        if (*lpType == REG_SZ || *lpType == REG_EXPAND_SZ) {
            MassageRealPathToFakePathW((LPWSTR)lpData, cbData);
        }
    }

    return returnValue;
}

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int    iReadWrite
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HFILE returnValue = ORIGINAL_API(_lopen)(lpszString, iReadWrite);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}

HFILE
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int    iAttribute
    )
{
    LPSTR lpszString = MassageStringForPathA(lpPathName);

    HFILE returnValue = ORIGINAL_API(_lcreat)(lpszString, iAttribute);

    FPFreeA(lpszString, lpPathName);

    return returnValue;
}

DWORD
APIHOOK(SearchPathA)(
    LPCSTR lpPath,        // search path
    LPCSTR lpFileName,    // file name
    LPCSTR lpExtension,   // file extension
    DWORD  nBufferLength, // size of buffer
    LPSTR  lpBuffer,      // found file name buffer
    LPSTR  *lpFilePart    // file component
    )
{
    LPSTR lpszStringPath = MassageStringForPathA(lpPath);
    LPSTR lpszStringFile = MassageStringForPathA(lpFileName);

    DWORD returnValue = ORIGINAL_API(SearchPathA)(lpszStringPath,
                                                  lpszStringFile,
                                                  lpExtension,
                                                  nBufferLength,
                                                  lpBuffer,
                                                  lpFilePart);

    FPFreeA(lpszStringPath, lpPath);
    FPFreeA(lpszStringFile, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(SearchPathW)(
    LPCWSTR lpPath,         // search path
    LPCWSTR lpFileName,     // file name
    LPCWSTR lpExtension,    // file extension
    DWORD   nBufferLength,  // size of buffer
    LPWSTR  lpBuffer,       // found file name buffer
    LPWSTR  *lpFilePart     // file component
    )
{
    LPWSTR lpszStringPath = MassageStringForPathW(lpPath);
    LPWSTR lpszStringFile = MassageStringForPathW(lpFileName);

    DWORD returnValue = ORIGINAL_API(SearchPathW)(lpszStringPath,
                                                  lpszStringFile,
                                                  lpExtension,
                                                  nBufferLength,
                                                  lpBuffer,
                                                  lpFilePart);

    FPFreeW(lpszStringPath, lpPath);
    FPFreeW(lpszStringFile, lpFileName);

    return returnValue;
}

DWORD
APIHOOK(ExpandEnvironmentStringsA)(
    LPCSTR lpSrc,    // string with environment variables
    LPSTR  lpDst,    // string with expanded strings
    DWORD  nSize     // maximum characters in expanded string
    )
{
    DWORD returnValue = ORIGINAL_API(ExpandEnvironmentStringsA)(lpSrc,
                                                                lpDst,
                                                                nSize);

    if (returnValue && (!(returnValue > nSize))) {
        LPSTR lpszString = MassageStringForPathA(lpDst);

        returnValue = ORIGINAL_API(ExpandEnvironmentStringsA)(lpszString,
                                                              lpDst,
                                                              nSize);

        FPFreeA(lpszString, lpDst);
    }

    return returnValue;
}

DWORD
APIHOOK(ExpandEnvironmentStringsW)(
    LPCWSTR lpSrc,    // string with environment variables
    LPWSTR  lpDst,    // string with expanded strings
    DWORD   nSize     // maximum characters in expanded string
    )
{
    DWORD returnValue = ORIGINAL_API(ExpandEnvironmentStringsW)(lpSrc,
                                                                lpDst,
                                                                nSize);

    if (returnValue && (!(returnValue > nSize))) {
        LPWSTR lpszString = MassageStringForPathW(lpDst);

        returnValue = ORIGINAL_API(ExpandEnvironmentStringsW)(lpszString,
                                                              lpDst,
                                                              nSize);

        FPFreeW(lpszString, lpDst);
    }

    return returnValue;
}

DWORD
APIHOOK(GetFileVersionInfoSizeA)(
    LPSTR   lptstrFilename,   // file name
    LPDWORD lpdwHandle        // set to zero
    )
{
    LPSTR lpszString = MassageStringForPathA(lptstrFilename);

    DWORD returnValue = ORIGINAL_API(GetFileVersionInfoSizeA)(lpszString,
                                                              lpdwHandle);

    FPFreeA(lpszString, lptstrFilename);

    return returnValue;
}

DWORD
APIHOOK(GetFileVersionInfoSizeW)(
    LPWSTR   lptstrFilename,   // file name
    LPDWORD  lpdwHandle        // set to zero
    )
{
    LPWSTR lpszString = MassageStringForPathW(lptstrFilename);

    DWORD returnValue = ORIGINAL_API(GetFileVersionInfoSizeW)(lpszString,
                                                              lpdwHandle);

    FPFreeW(lpszString, lptstrFilename);

    return returnValue;
}

BOOL
APIHOOK(GetFileVersionInfoA)(
    LPSTR  lptstrFilename,    // file name
    DWORD  dwHandle,          // ignored
    DWORD  dwLen,             // size of buffer
    LPVOID lpData             // version information buffer
    )
{
    LPSTR lpszString = MassageStringForPathA(lptstrFilename);

    BOOL returnValue = ORIGINAL_API(GetFileVersionInfoA)(lpszString,
                                                         dwHandle,
                                                         dwLen,
                                                         lpData);

    FPFreeA(lpszString, lptstrFilename);

    return returnValue;
}

BOOL
APIHOOK(GetFileVersionInfoW)(
    LPWSTR  lptstrFilename,    // file name
    DWORD   dwHandle,          // ignored
    DWORD   dwLen,             // size of buffer
    LPVOID  lpData             // version information buffer
    )
{
    LPWSTR lpszString = MassageStringForPathW(lptstrFilename);

    BOOL returnValue = ORIGINAL_API(GetFileVersionInfoW)(lpszString,
                                                         dwHandle,
                                                         dwLen,
                                                         lpData);

    FPFreeW(lpszString, lptstrFilename);

    return returnValue;
}

BOOL
APIHOOK(GetOpenFileNameA)(
    LPOPENFILENAMEA lpofn   // initialization data
    )
{
    BOOL    fReturn = FALSE;

    fReturn = ORIGINAL_API(GetOpenFileNameA)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathA(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

BOOL
APIHOOK(GetOpenFileNameW)(
    LPOPENFILENAMEW lpofn   // initialization data
    )
{
    BOOL fReturn = ORIGINAL_API(GetOpenFileNameW)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathW(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

BOOL
APIHOOK(GetSaveFileNameA)(
    LPOPENFILENAMEA lpofn   // initialization data
    )
{
    BOOL fReturn = ORIGINAL_API(GetSaveFileNameA)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathA(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

BOOL
APIHOOK(GetSaveFileNameW)(
    LPOPENFILENAMEW lpofn   // initialization data
    )
{
    BOOL fReturn = ORIGINAL_API(GetSaveFileNameW)(lpofn);

    if (fReturn) {
        MassageRealPathToFakePathW(lpofn->lpstrFile, lpofn->nMaxFile);
    }

    return fReturn;
}

DWORD
APIHOOK(GetModuleFileNameA)(
    HMODULE hModule,      // handle to module
    LPSTR   lpFilename,   // path buffer
    DWORD   nSize         // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameA)(hModule,
                                                      lpFilename,
                                                      nSize);

    if (dwReturn) {
        MassageRealPathToFakePathA(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetModuleFileNameW)(
    HMODULE hModule,     // handle to module
    LPWSTR  lpFilename,  // path buffer
    DWORD   nSize        // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameW)(hModule,
                                                      lpFilename,
                                                      nSize);
    if (dwReturn) {
        MassageRealPathToFakePathW(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetModuleFileNameExA)(
    HANDLE  hProcess,     // handle to process
    HMODULE hModule,      // handle to module
    LPSTR   lpFilename,   // path buffer
    DWORD   nSize         // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameExA)(hProcess,
                                                        hModule,
                                                        lpFilename,
                                                        nSize);
    if (dwReturn) {
        MassageRealPathToFakePathA(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetModuleFileNameExW)(
    HANDLE  hProcess,     // handle to process
    HMODULE hModule,      // handle to module
    LPWSTR  lpFilename,   // path buffer
    DWORD   nSize         // size of buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetModuleFileNameExW)(hProcess,
                                                        hModule,
                                                        lpFilename,
                                                        nSize);
    if (dwReturn) {
        MassageRealPathToFakePathW(lpFilename, nSize);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetCurrentDirectoryA)(
    DWORD nBufferLength,  // size of directory buffer
    LPSTR lpBuffer        // directory buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetCurrentDirectoryA)(nBufferLength,
                                                        lpBuffer);

    if (dwReturn) {
        MassageRealPathToFakePathA(lpBuffer, nBufferLength);
    }

    return dwReturn;
}

DWORD
APIHOOK(GetCurrentDirectoryW)(
    DWORD  nBufferLength,  // size of directory buffer
    LPWSTR lpBuffer        // directory buffer
    )
{
    DWORD dwReturn = ORIGINAL_API(GetCurrentDirectoryW)(nBufferLength,
                                                        lpBuffer);

    if (dwReturn) {
        MassageRealPathToFakePathW(lpBuffer, nBufferLength);
    }

    return dwReturn;
}

/*++

 Add a corrected path to the linked list.

--*/
BOOL
AddCorrectedPath(
    LPCWSTR  pwszCorrectedPath,
    ListType eType
    )
{
    int         nLen = 0;
    PFILELIST   pFile = NULL;
    LPWSTR      pwszFilePath = NULL;

    pFile = (PFILELIST)malloc(sizeof(FILELIST));

    if (!pFile) {
        DPFN(eDbgLevelError, "[AddCorrectedPath] No memory for new node!");
        return FALSE;
    }

    //
    // We allocate the memory here to make it easier to keep track of.
    // When we release the memory at the end, we can release all of it
    // from one place.
    //
    nLen = lstrlenW(pwszCorrectedPath) + 1;

    pwszFilePath = (LPWSTR)malloc(nLen * sizeof(WCHAR));

    if (!pwszFilePath) {
        DPFN(eDbgLevelError, "[AddCorrectedPath] No memory for wide path!");
        return FALSE;
    }

    StringCchCopy(pwszFilePath, nLen, pwszCorrectedPath);

    pFile->cchSize      = nLen;
    pFile->pwszFilePath = pwszFilePath;

    //
    // Determine which list we should add this node to.
    //
    if (eType == eFrom) {
        pFile->pNext        = g_pFileListFromHead;
        g_pFileListFromHead = pFile;
    } else {
        pFile->pNext        = g_pFileListToHead;
        g_pFileListToHead   = pFile;
    }

    return TRUE;
}

/*++

 Build a list of strings separated by NULLs with two NULLs at the end.

--*/
LPWSTR
BuildStringList(
    ListType eListType
    )
{
    UINT        uMemSize = 0;
    PFILELIST   pFile = NULL;
    PFILELIST   pHead = NULL;
    LPWSTR      pwszReturn = NULL;
    LPWSTR      pwszNextString = NULL;

    //
    // Determine which list we're working with.
    //
    switch (eListType) {
    case eFrom:
        pHead = pFile = g_pFileListFromHead;
        break;

    case eTo:
        pHead = pFile = g_pFileListToHead;
        break;

    default:
        break;
    }

    //
    // Walk the list and determine how large of a block we'll need to allocate.
    //
    while (pFile) {
        uMemSize += pFile->cchSize;
        pFile = pFile->pNext;
    }

    if (!uMemSize) {
        DPFN(eDbgLevelError, "[BuildStringList] List is empty!");
        return NULL;
    }

    //
    // Allocate a block large enough to hold the strings with a NULL at the end.
    //
    pwszReturn = (LPWSTR)malloc(++uMemSize * sizeof(WCHAR));

    if (!pwszReturn) {
        DPFN(eDbgLevelError, "[BuildStringList] No memory for string!");
        return NULL;
    }

    //
    // Walk the linked list and build the list of Unicode strings.
    //
    pwszNextString  = pwszReturn;
    *pwszNextString = '\0';

    while (pHead) {
        wcsncpy(pwszNextString, pHead->pwszFilePath, pHead->cchSize);
        pwszNextString += pHead->cchSize;
        pHead = pHead->pNext;
    }

    *pwszNextString++ = '\0';

    return pwszReturn;
}

/*++

 Release memory that was allocated while processing SHFileOperation.

--*/
void
ReleaseMemAllocations(
    LPWSTR   pwszFinalPath,
    ListType eListType
    )
{
    PFILELIST  pHead = NULL;
    PFILELIST  pTemp = NULL;

    switch (eListType) {
    case eFrom:
        pHead = g_pFileListFromHead;
        break;

    case eTo:
        pHead = g_pFileListToHead;
        break;

    default:
        break;
    }

    //
    // Free the paths first, then the nodes next.
    //
    while (pHead) {
        if (pHead->pwszFilePath) {
            free(pHead->pwszFilePath);
        }

        pTemp = pHead;
        pHead = pHead->pNext;
        free(pTemp);
    }

    if (pwszFinalPath) {
        free(pwszFinalPath);
    }
}

/*++

 Build a linked list of corrected paths.

--*/
BOOL
BuildLinkedList(
    LPCWSTR  pwszOriginalPath,
    ListType eListType
    )
{
    UINT    uSize = 0;
    LPWSTR  pwszReturnPath = NULL;

    if (pwszOriginalPath) {
        while (TRUE) {
            pwszReturnPath = MassageStringForPathW(pwszOriginalPath);

            //
            // Add this corrected path to our list.
            //
            if (!AddCorrectedPath(pwszReturnPath, eListType)) {
                DPFN(eDbgLevelError,
                     "[BuildLinkedList] Failed to add wide path to linked list");
                return FALSE;
            }

            FPFreeW(pwszReturnPath, pwszOriginalPath);

            uSize = lstrlenW(pwszOriginalPath) + 1;
            pwszOriginalPath += uSize;

            if (*pwszOriginalPath == '\0') {
                break;
            }
        }
    }

    return TRUE;
}

BOOL
ConvertStringsToUnicode(
    LPWSTR*           pwszBuffer,
    LPSHFILEOPSTRUCTA lpFileOp,
    LPSHFILEOPSTRUCTW lpOutFileOp
    )
{
    UINT    cchSize = 0;
    UINT    cchWideSize = 0;
    UINT    cchTotalSize = 0;
    UINT    cchSizeTitle = 0;
    LPCSTR  pszAnsi = NULL;
    LPWSTR  pwszTemp = NULL;

    //
    // Determine how large of a buffer we need to allocate.
    //
    if (lpFileOp->pFrom) {
        pszAnsi = lpFileOp->pFrom;

        do {
            cchSize = lstrlenA(pszAnsi) + 1;
            cchTotalSize += cchSize;
            pszAnsi += cchSize;
        } while (cchSize != 1);
    }

    if (lpFileOp->pTo) {
        pszAnsi = lpFileOp->pTo;

        do {
            cchSize = lstrlenA(pszAnsi) + 1;
            cchTotalSize += cchSize;
            pszAnsi += cchSize;
        } while (cchSize != 1);
    }

    if (lpFileOp->lpszProgressTitle) {
        cchSizeTitle = lstrlenA(lpFileOp->lpszProgressTitle) + 1;
        cchTotalSize += cchSizeTitle;
    }

    if (cchTotalSize != 0) {
        pwszTemp = *pwszBuffer = (LPWSTR)malloc(cchTotalSize * sizeof(WCHAR));

        if (!*pwszBuffer) {
            DPFN(eDbgLevelError,
                 "[ConvertStringsToUnicode] No memory for buffer");
            return FALSE;
        }
    }

    //
    // Perform the ANSI to Unicode conversion.
    //
    if (lpFileOp->pFrom) {
        lpOutFileOp->pFrom = pwszTemp;
        pszAnsi = lpFileOp->pFrom;

        do {
            cchSize = lstrlenA(pszAnsi) + 1;

            cchWideSize = MultiByteToWideChar(
                CP_ACP,
                0,
                pszAnsi,
                cchSize,
                pwszTemp,
                cchSize);

            pszAnsi  += cchSize;
            pwszTemp += cchWideSize;
        } while (cchSize != 1);
    } else {
        lpOutFileOp->pFrom = NULL;
    }

    if (lpFileOp->pTo) {
        lpOutFileOp->pTo = pwszTemp;
        pszAnsi  = lpFileOp->pTo;
        do {
            cchSize = lstrlenA(pszAnsi) + 1;

            cchWideSize = MultiByteToWideChar(
                CP_ACP,
                0,
                pszAnsi,
                cchSize,
                pwszTemp,
                cchSize);

            pszAnsi  += cchSize;
            pwszTemp += cchWideSize;
        } while (cchSize != 1);
    } else {
        lpOutFileOp->pTo = NULL;
    }

    if (lpFileOp->lpszProgressTitle) {
        lpOutFileOp->lpszProgressTitle = pwszTemp;

        MultiByteToWideChar(
            CP_ACP,
            0,
            lpFileOp->lpszProgressTitle,
            cchSizeTitle,
            pwszTemp,
            cchSizeTitle);
    } else {
        lpOutFileOp->lpszProgressTitle = NULL;
    }

    return TRUE;
}

int
APIHOOK(SHFileOperationW)(
    LPSHFILEOPSTRUCTW lpFileOp
    )
{
    int     nReturn = 0;
    LPCWSTR pwszOriginalFrom = NULL;
    LPCWSTR pwszOriginalTo = NULL;
    LPWSTR  pwszFinalFrom = NULL;
    LPWSTR  pwszFinalTo = NULL;

    pwszOriginalFrom = lpFileOp->pFrom;
    pwszOriginalTo   = lpFileOp->pTo;

    RtlEnterCriticalSection(&g_csLinkedList);

    //
    // Build a linked list of the 'from' paths first,
    // and then process to 'to' paths.
    //
    if (!BuildLinkedList(pwszOriginalFrom, eFrom)) {
        DPFN(eDbgLevelError,
             "[SHFileOperationW] Failed to add 'from' path to linked list");
        goto exit;
    }

    if (!BuildLinkedList(pwszOriginalTo, eTo)) {
        DPFN(eDbgLevelError,
             "[SHFileOperationW] Failed to add 'to' path to linked list");
        goto exit;
    }

    //
    // All paths have been massaged - build a list of NULL
    // separated strings with a double NULL at the end.
    //
    pwszFinalFrom = BuildStringList(eFrom);

    if (!pwszFinalFrom) {
        DPFN(eDbgLevelError, "[SHFileOperationW] Failed to build 'from' list");
        goto exit;
    }

    pwszFinalTo = BuildStringList(eTo);

    if (!pwszFinalTo) {
        DPFN(eDbgLevelError, "[SHFileOperationW] Failed to build 'to' list");
        goto exit;
    }

    //
    // Package the strings back into the struct, call the original API
    // to get the results, and then free any memory we've allocated.
    //
    lpFileOp->pFrom = pwszFinalFrom;
    lpFileOp->pTo   = pwszFinalTo;

exit:

    RtlLeaveCriticalSection(&g_csLinkedList);

    nReturn = ORIGINAL_API(SHFileOperationW)(lpFileOp);

    ReleaseMemAllocations(pwszFinalFrom, eFrom);
    ReleaseMemAllocations(pwszFinalTo, eTo);

    g_pFileListFromHead = NULL;
    g_pFileListToHead = NULL;

    return nReturn;
}

int
APIHOOK(SHFileOperationA)(
    LPSHFILEOPSTRUCTA lpFileOp
    )
{
    int             nReturn = 0;
    LPWSTR          pwszBuffer = NULL;
    SHFILEOPSTRUCTW shfileop;

    memcpy(&shfileop, lpFileOp, sizeof(SHFILEOPSTRUCTW));

    if (!ConvertStringsToUnicode(&pwszBuffer, lpFileOp, &shfileop)) {
        DPFN(eDbgLevelError,
             "[SHFileOperationA] Failed to convert strings");
        goto exit;
    }

    nReturn = APIHOOK(SHFileOperationW)(&shfileop);

    //
    // Link up the two members that could have changed.
    //
    lpFileOp->fAnyOperationsAborted = shfileop.fAnyOperationsAborted;
    lpFileOp->hNameMappings         = shfileop.hNameMappings;

    if (pwszBuffer) {
        free(pwszBuffer);
    }

    return nReturn;

exit:

    return ORIGINAL_API(SHFileOperationA)(lpFileOp);
}

NTSTATUS
APIHOOK(NtCreateFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    PLARGE_INTEGER     AllocationSize,
    ULONG              FileAttributes,
    ULONG              ShareAccess,
    ULONG              CreateDisposition,
    ULONG              CreateOptions,
    PVOID              EaBuffer,
    ULONG              EaLength
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtCreateFile)(FileHandle,
                                                 DesiredAccess,
                                                 &NewObjectAttributes,
                                                 IoStatusBlock,
                                                 AllocationSize,
                                                 FileAttributes,
                                                 ShareAccess,
                                                 CreateDisposition,
                                                 CreateOptions,
                                                 EaBuffer,
                                                 EaLength);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

NTSTATUS
APIHOOK(NtOpenFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    ULONG              ShareAccess,
    ULONG              OpenOptions
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtOpenFile)(FileHandle,
                                               DesiredAccess,
                                               &NewObjectAttributes,
                                               IoStatusBlock,
                                               ShareAccess,
                                               OpenOptions);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

NTSTATUS
APIHOOK(NtQueryAttributesFile)(
    POBJECT_ATTRIBUTES      ObjectAttributes,
    PFILE_BASIC_INFORMATION FileInformation
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtQueryAttributesFile)(&NewObjectAttributes,
                                                          FileInformation);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

NTSTATUS
APIHOOK(NtQueryFullAttributesFile)(
    POBJECT_ATTRIBUTES             ObjectAttributes,
    PFILE_NETWORK_OPEN_INFORMATION FileInformation
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtQueryFullAttributesFile)(&NewObjectAttributes,
                                                              FileInformation);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

NTSTATUS
APIHOOK(NtCreateProcessEx)(
    PHANDLE            ProcessHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    HANDLE             ParentProcess,
    ULONG              Flags,
    HANDLE             SectionHandle,
    HANDLE             DebugPort,
    HANDLE             ExceptionPort,
    ULONG              JobMemberLevel
    )
{
    OBJECT_ATTRIBUTES NewObjectAttributes;

    MassageNtPath(ObjectAttributes, &NewObjectAttributes);

    NTSTATUS status = ORIGINAL_API(NtCreateProcessEx)(ProcessHandle,
                                                      DesiredAccess,
                                                      &NewObjectAttributes,
                                                      ParentProcess,
                                                      Flags,
                                                      SectionHandle,
                                                      DebugPort,
                                                      ExceptionPort,
                                                      JobMemberLevel);

    FPNtFree(ObjectAttributes, &NewObjectAttributes);

    return status;
}

UINT
GetSimulatedPathA(
    LPSTR lpBuffer,
    UINT  unSize,
    int   nWhich
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    if (unSize > (DWORD)g_Paths[nWhich].nSimulatedPathLen) {
        StringCchCopyA(lpBuffer, unSize, g_Paths[nWhich].szSimulatedPathA);
        return g_Paths[nWhich].nSimulatedPathLen;
    } else {
        return g_Paths[nWhich].nSimulatedPathLen + 1;
    }
}

UINT
GetSimulatedPathW(
    LPWSTR lpBuffer,
    UINT   unSize,
    int    nWhich
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    if (unSize > (DWORD)g_Paths[nWhich].nSimulatedPathLen) {
        StringCchCopy(lpBuffer, unSize, g_Paths[nWhich].szSimulatedPathW);
        return g_Paths[nWhich].nSimulatedPathLen;
    } else {
        return g_Paths[nWhich].nSimulatedPathLen + 1;
    }
}

DWORD
APIHOOK(GetTempPathA)(
    DWORD nBufferLength,
    LPSTR lpBuffer
    )
{
    return GetSimulatedPathA(lpBuffer, nBufferLength, PATH_TEMP);
}

DWORD
APIHOOK(GetTempPathW)(
    DWORD  nBufferLength,
    LPWSTR lpBuffer
    )
{
    return GetSimulatedPathW(lpBuffer, nBufferLength, PATH_TEMP);
}

UINT
APIHOOK(GetWindowsDirectoryA)(
    LPSTR lpBuffer,
    UINT  unSize
    )
{
    return GetSimulatedPathA(lpBuffer, unSize, PATH_WINDOWS);
}

UINT
APIHOOK(GetWindowsDirectoryW)(
    LPWSTR lpBuffer,
    UINT   unSize
    )
{
    return GetSimulatedPathW(lpBuffer, unSize, PATH_WINDOWS);
}

UINT
APIHOOK(GetSystemWindowsDirectoryA)(
    LPSTR lpBuffer,
    UINT  unSize
    )
{
    return GetSimulatedPathA(lpBuffer, unSize, PATH_SYSTEM_WINDOWS);
}

UINT
APIHOOK(GetSystemWindowsDirectoryW)(
    LPWSTR lpBuffer,
    UINT   unSize
    )
{
    return GetSimulatedPathW(lpBuffer, unSize, PATH_SYSTEM_WINDOWS);
}

UINT
APIHOOK(GetSystemDirectoryA)(
    LPSTR lpBuffer,
    UINT  unSize
    )
{
    return GetSimulatedPathA(lpBuffer, unSize, PATH_SYSTEM);
}

UINT
APIHOOK(GetSystemDirectoryW)(
    LPWSTR lpBuffer,
    UINT   unSize
    )
{
    return GetSimulatedPathW(lpBuffer, unSize, PATH_SYSTEM);
}

BOOL
APIHOOK(SHGetSpecialFolderPathA)(
    HWND  hwndOwner,
    LPSTR lpszPath,
    int   nFolder,
    BOOL  fCreate
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    switch (nFolder) {
    case CSIDL_PERSONAL:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_PERSONAL].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_SYSTEM:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_SYSTEM].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_WINDOWS:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_WINDOWS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_PROGRAMS:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_STARTMENU:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_COMMON_PROGRAMS:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathA);
        return TRUE;
        break;

    case CSIDL_COMMON_STARTMENU:
        StringCchCopyA(lpszPath, MAX_PATH, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathA);
        return TRUE;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetSpecialFolderPathA)(hwndOwner, lpszPath, nFolder, fCreate);
}

BOOL
APIHOOK(SHGetSpecialFolderPathW)(
    HWND   hwndOwner,
    LPWSTR lpszPath,
    int    nFolder,
    BOOL   fCreate
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    switch (nFolder) {
    case CSIDL_PERSONAL:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_PERSONAL].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_SYSTEM:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_SYSTEM].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_WINDOWS:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_WINDOWS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_PROGRAMS:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_STARTMENU:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_COMMON_PROGRAMS:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathW);
        return TRUE;
        break;

    case CSIDL_COMMON_STARTMENU:
        StringCchCopy(lpszPath, MAX_PATH, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathW);
        return TRUE;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetSpecialFolderPathW)(hwndOwner, lpszPath, nFolder, fCreate);
}

HRESULT
APIHOOK(SHGetFolderPathA)(
    HWND   hwndOwner,
    int    nFolder,
    HANDLE hToken,
    DWORD  dwFlags,
    LPSTR  pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    switch (nFolder) {
    case CSIDL_PERSONAL:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_PERSONAL].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_SYSTEM:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_SYSTEM].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_WINDOWS:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_WINDOWS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_PROGRAMS:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_STARTMENU:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_COMMON_PROGRAMS:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathA);
        return S_OK;
        break;

    case CSIDL_COMMON_STARTMENU:
        StringCchCopyA(pszPath, MAX_PATH, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathA);
        return S_OK;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetFolderPathA)(hwndOwner, nFolder, hToken, dwFlags, pszPath);
}

HRESULT
APIHOOK(SHGetFolderPathW)(
    HWND   hwndOwner,
    int    nFolder,
    HANDLE hToken,
    DWORD  dwFlags,
    LPWSTR pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    switch (nFolder) {
    case CSIDL_PERSONAL:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_PERSONAL].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_SYSTEM:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_SYSTEM].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_WINDOWS:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_WINDOWS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_PROGRAMS:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_STARTMENU:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_PROGRAMS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_COMMON_PROGRAMS:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_COMMON_PROGRAMS].szSimulatedPathW);
        return S_OK;
        break;

    case CSIDL_COMMON_STARTMENU:
        StringCchCopy(pszPath, MAX_PATH, g_Paths[PATH_COMMON_STARTMENU].szSimulatedPathW);
        return S_OK;
        break;

    }

    //
    // the others we aren't nabbing
    //
    return ORIGINAL_API(SHGetFolderPathW)(hwndOwner, nFolder, hToken, dwFlags, pszPath);
}

BOOL
APIHOOK(SHGetPathFromIDListA)(
    LPCITEMIDLIST pidl,
    LPSTR         pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    BOOL fReturn = ORIGINAL_API(SHGetPathFromIDListA)(pidl, pszPath);

    if (fReturn) {
        MassageRealPathToFakePathA(pszPath, MAX_PATH);
    }

    return fReturn;
}

BOOL
APIHOOK(SHGetPathFromIDListW)(
    LPCITEMIDLIST pidl,
    LPWSTR        pszPath
    )
{
    if (!g_bPathsInited) {
        InitPaths();
    }

    BOOL fReturn = ORIGINAL_API(SHGetPathFromIDListW)(pidl, pszPath);

    if (fReturn) {
        MassageRealPathToFakePathW(pszPath, MAX_PATH);
    }

    return fReturn;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_FILEPATHS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_FILEPATHS_FRIENDLY)
    SHIM_INFO_FLAGS(AVRF_FLAG_RUN_ALONE | AVRF_FLAG_EXTERNAL_ONLY)
    SHIM_INFO_GROUPS(0)
    SHIM_INFO_VERSION(1, 6)
    SHIM_INFO_INCLUDE_EXCLUDE("E:ole32.dll oleaut32.dll")

SHIM_INFO_END()

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {

        UINT    cchSize;
        DWORD   cchReturned;

        //
        // Initialize a critical section to keep our linked list safe.
        //
        RtlInitializeCriticalSection(&g_csLinkedList);

        cchReturned = GetTempPathA(MAX_PATH, g_Paths[PATH_TEMP].szCorrectPathA);

        if (cchReturned > sizeof(g_Paths[PATH_TEMP].szCorrectPathA) || cchReturned == 0) {
            goto exit;
        }

        cchReturned = GetTempPathW(MAX_PATH, g_Paths[PATH_TEMP].szCorrectPathW);

        if (cchReturned > ARRAYSIZE(g_Paths[PATH_TEMP].szCorrectPathW) || cchReturned == 0) {
            goto exit;
        }

        g_Paths[PATH_TEMP].nCorrectPathLen = strlen(g_Paths[PATH_TEMP].szCorrectPathA);
        g_Paths[PATH_TEMP].nSimulatedPathLen = strlen(g_Paths[PATH_TEMP].szSimulatedPathA);

        cchSize = GetWindowsDirectoryA(g_Paths[PATH_WINDOWS].szCorrectPathA, MAX_PATH);

        if (cchSize > sizeof(g_Paths[PATH_WINDOWS].szCorrectPathA) || cchSize == 0) {
            goto exit;
        }

        cchSize = GetWindowsDirectoryW(g_Paths[PATH_WINDOWS].szCorrectPathW, MAX_PATH);

        if (cchSize > ARRAYSIZE(g_Paths[PATH_WINDOWS].szCorrectPathW) || cchSize == 0) {
            goto exit;
        }

        g_Paths[PATH_WINDOWS].nCorrectPathLen = strlen(g_Paths[PATH_WINDOWS].szCorrectPathA);
        g_Paths[PATH_WINDOWS].nSimulatedPathLen = strlen(g_Paths[PATH_WINDOWS].szSimulatedPathA);

        cchSize = GetSystemWindowsDirectoryA(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA, MAX_PATH);

        if (cchSize > sizeof(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA) || cchSize == 0) {
            goto exit;
        }

        cchSize = GetSystemWindowsDirectoryW(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathW, MAX_PATH);

        if (cchSize > ARRAYSIZE(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathW) || cchSize == 0) {
            goto exit;
        }

        g_Paths[PATH_SYSTEM_WINDOWS].nCorrectPathLen = strlen(g_Paths[PATH_SYSTEM_WINDOWS].szCorrectPathA);
        g_Paths[PATH_SYSTEM_WINDOWS].nSimulatedPathLen = strlen(g_Paths[PATH_SYSTEM_WINDOWS].szSimulatedPathA);

        cchSize = GetSystemDirectoryA(g_Paths[PATH_SYSTEM].szCorrectPathA, MAX_PATH);

        if (cchSize > sizeof(g_Paths[PATH_SYSTEM].szCorrectPathA) || cchSize == 0) {
            goto exit;
        }

        cchSize = GetSystemDirectoryW(g_Paths[PATH_SYSTEM].szCorrectPathW, MAX_PATH);

        if (cchSize > ARRAYSIZE(g_Paths[PATH_SYSTEM].szCorrectPathW) || cchSize == 0) {
            goto exit;
        }

        g_Paths[PATH_SYSTEM].nCorrectPathLen = strlen(g_Paths[PATH_SYSTEM].szCorrectPathA);
        g_Paths[PATH_SYSTEM].nSimulatedPathLen = strlen(g_Paths[PATH_SYSTEM].szSimulatedPathA);

        //
        // Catch apps that use ExpandEnvironmentStrings.
        //
        SetEnvironmentVariableW(L"TEMP", g_Paths[PATH_TEMP].szSimulatedPathW);
        SetEnvironmentVariableW(L"TMP", g_Paths[PATH_TEMP].szSimulatedPathW);
        SetEnvironmentVariableW(L"windir", g_Paths[PATH_WINDOWS].szSimulatedPathW);

    }

    return TRUE;

exit:
    DPFN(eDbgLevelError,
         "[NOTIFY_FUNCTION] 0x%08X Failed to initialize",
         GetLastError());

    return FALSE;
}

/*++

  Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_GETTEMPPATH,
                            AVS_HARDCODED_GETTEMPPATH,
                            AVS_HARDCODED_GETTEMPPATH_R,
                            AVS_HARDCODED_GETTEMPPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_WINDOWSPATH,
                            AVS_HARDCODED_WINDOWSPATH,
                            AVS_HARDCODED_WINDOWSPATH_R,
                            AVS_HARDCODED_WINDOWSPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSWINDOWSPATH,
                            AVS_HARDCODED_SYSWINDOWSPATH,
                            AVS_HARDCODED_SYSWINDOWSPATH_R,
                            AVS_HARDCODED_SYSWINDOWSPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_SYSTEMPATH,
                            AVS_HARDCODED_SYSTEMPATH,
                            AVS_HARDCODED_SYSTEMPATH_R,
                            AVS_HARDCODED_SYSTEMPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PERSONALPATH,
                            AVS_HARDCODED_PERSONALPATH,
                            AVS_HARDCODED_PERSONALPATH_R,
                            AVS_HARDCODED_PERSONALPATH_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONPROGRAMS,
                            AVS_HARDCODED_COMMONPROGRAMS,
                            AVS_HARDCODED_COMMONPROGRAMS_R,
                            AVS_HARDCODED_COMMONPROGRAMS_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_COMMONSTARTMENU,
                            AVS_HARDCODED_COMMONSTARTMENU,
                            AVS_HARDCODED_COMMONSTARTMENU_R,
                            AVS_HARDCODED_COMMONSTARTMENU_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_PROGRAMS,
                            AVS_HARDCODED_PROGRAMS,
                            AVS_HARDCODED_PROGRAMS_R,
                            AVS_HARDCODED_PROGRAMS_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HARDCODED_STARTMENU,
                            AVS_HARDCODED_STARTMENU,
                            AVS_HARDCODED_STARTMENU_R,
                            AVS_HARDCODED_STARTMENU_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineA)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetCommandLineW)

    APIHOOK_ENTRY(KERNEL32.DLL,                     GetTempPathA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetTempPathW)

    APIHOOK_ENTRY(KERNEL32.DLL,              GetSystemDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,              GetSystemDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,       GetSystemWindowsDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,       GetSystemWindowsDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetWindowsDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetWindowsDirectoryW)

    APIHOOK_ENTRY(SHELL32.DLL,                  SHGetFolderPathA)
    APIHOOK_ENTRY(SHELL32.DLL,                  SHGetFolderPathW)

    APIHOOK_ENTRY(SHELL32.DLL,           SHGetSpecialFolderPathA)
    APIHOOK_ENTRY(SHELL32.DLL,           SHGetSpecialFolderPathW)

    APIHOOK_ENTRY(SHELL32.DLL,              SHGetPathFromIDListA)
    APIHOOK_ENTRY(SHELL32.DLL,              SHGetPathFromIDListW)

    APIHOOK_ENTRY(COMDLG32.DLL,                 GetOpenFileNameA)
    APIHOOK_ENTRY(COMDLG32.DLL,                 GetOpenFileNameW)

    APIHOOK_ENTRY(COMDLG32.DLL,                 GetSaveFileNameA)
    APIHOOK_ENTRY(COMDLG32.DLL,                 GetSaveFileNameW)

    APIHOOK_ENTRY(KERNEL32.DLL,               GetModuleFileNameA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetModuleFileNameW)

    APIHOOK_ENTRY(PSAPI.DLL,                GetModuleFileNameExA)
    APIHOOK_ENTRY(PSAPI.DLL,                GetModuleFileNameExW)

    APIHOOK_ENTRY(KERNEL32.DLL,             GetCurrentDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetCurrentDirectoryW)

    APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   CreateProcessW)
    APIHOOK_ENTRY(KERNEL32.DLL,                          WinExec)

    APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteA)
    APIHOOK_ENTRY(SHELL32.DLL,                     ShellExecuteW)
    APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExA)
    APIHOOK_ENTRY(SHELL32.DLL,                   ShellExecuteExW)

    APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntA)
    APIHOOK_ENTRY(KERNEL32.DLL,            GetPrivateProfileIntW)
    APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,        GetPrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesA)
    APIHOOK_ENTRY(KERNEL32.DLL,   GetPrivateProfileSectionNamesW)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileStructW)

    APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,      WritePrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,       WritePrivateProfileStructW)

    // g_bFileRoutines)
    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExA)
    APIHOOK_ENTRY(KERNEL32.DLL,               CreateDirectoryExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileW)

    APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   FindFirstFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 FindFirstFileExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   GetBinaryTypeW)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetFileAttributesW)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExA)
    APIHOOK_ENTRY(KERNEL32.DLL,             GetFileAttributesExW)
    APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesA)
    APIHOOK_ENTRY(KERNEL32.DLL,               SetFileAttributesW)

    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressA)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressW)

    APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 RemoveDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,             SetCurrentDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,                     LoadLibraryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     LoadLibraryW)
    APIHOOK_ENTRY(KERNEL32.DLL,                   LoadLibraryExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   LoadLibraryExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                      SearchPathA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      SearchPathW)

    APIHOOK_ENTRY(KERNEL32.DLL,        ExpandEnvironmentStringsA)
    APIHOOK_ENTRY(KERNEL32.DLL,        ExpandEnvironmentStringsW)

    APIHOOK_ENTRY(VERSION.DLL,           GetFileVersionInfoSizeA)
    APIHOOK_ENTRY(VERSION.DLL,           GetFileVersionInfoSizeW)
    APIHOOK_ENTRY(VERSION.DLL,               GetFileVersionInfoA)
    APIHOOK_ENTRY(VERSION.DLL,               GetFileVersionInfoW)

    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationA)
    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationW)

    APIHOOK_ENTRY(KERNEL32.DLL,                         OpenFile)

    // 16 bit compatibility file routines
    APIHOOK_ENTRY(KERNEL32.DLL,                           _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL,                          _lcreat)

    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegQueryValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegQueryValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegQueryValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegQueryValueExW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExW)

    APIHOOK_ENTRY(NTDLL.DLL,                        NtCreateFile)
    APIHOOK_ENTRY(NTDLL.DLL,                          NtOpenFile)
    APIHOOK_ENTRY(NTDLL.DLL,               NtQueryAttributesFile)
    APIHOOK_ENTRY(NTDLL.DLL,           NtQueryFullAttributesFile)
    APIHOOK_ENTRY(NTDLL.DLL,                   NtCreateProcessEx)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\ids.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by verifier.rc
//
// Scheme for resource includes:
//  
// - Dialog box definition and controls should start at 0
//   and should end at 49.
//
// - VLOG entries and other AVS defines should start at 50
//   and should end at 99.
//
// - Each shim should be placed into it's own section
//   to keep defines separated for all shims.
//

/*****************************************************
// RegistryChecks Begin
//***************************************************/
#define AVS_HKCU_AppEvents_READ                     10
#define AVS_HKCU_AppEvents_READ_R                   11
#define AVS_HKCU_AppEvents_READ_URL                 12
#define AVS_HKCU_Console_READ                       13
#define AVS_HKCU_Console_READ_R                     14
#define AVS_HKCU_Console_READ_URL                   15
#define AVS_HKCU_ControlPanel_READ                  16
#define AVS_HKCU_ControlPanel_READ_R                17
#define AVS_HKCU_ControlPanel_READ_URL              18
#define AVS_HKCU_Environment_READ                   19
#define AVS_HKCU_Environment_READ_R                 20
#define AVS_HKCU_Environment_READ_URL               21
#define AVS_HKCU_Identities_READ                    22
#define AVS_HKCU_Identities_READ_R                  23
#define AVS_HKCU_Identities_READ_URL                24
#define AVS_HKCU_KeyboardLayout_READ                25
#define AVS_HKCU_KeyboardLayout_READ_R              26
#define AVS_HKCU_KeyboardLayout_READ_URL            27
#define AVS_HKCU_Printers_READ                      28
#define AVS_HKCU_Printers_READ_R                    29
#define AVS_HKCU_Printers_READ_URL                  30
#define AVS_HKCU_RemoteAccess_READ                  31
#define AVS_HKCU_RemoteAccess_READ_R                32
#define AVS_HKCU_RemoteAccess_READ_URL              33
#define AVS_HKCU_SessionInformation_READ            34
#define AVS_HKCU_SessionInformation_READ_R          35
#define AVS_HKCU_SessionInformation_READ_URL        36
#define AVS_HKCU_UNICODEProgramGroups_READ          37
#define AVS_HKCU_UNICODEProgramGroups_READ_R        38
#define AVS_HKCU_UNICODEProgramGroups_READ_URL      39
#define AVS_HKCU_VolatileEnvironment_READ           40
#define AVS_HKCU_VolatileEnvironment_READ_R         41
#define AVS_HKCU_VolatileEnvironment_READ_URL       42
#define AVS_HKCU_Windows31MigrationStatus_READ      43
#define AVS_HKCU_Windows31MigrationStatus_READ_R    44
#define AVS_HKCU_Windows31MigrationStatus_READ_URL  45
#define AVS_HKLM_HARDWARE_READ                      46
#define AVS_HKLM_HARDWARE_READ_R                    47
#define AVS_HKLM_HARDWARE_READ_URL                  48
#define AVS_HKLM_SAM_READ                           49
#define AVS_HKLM_SAM_READ_R                         50
#define AVS_HKLM_SAM_READ_URL                       51
#define AVS_HKLM_SECURITY_READ                      52
#define AVS_HKLM_SECURITY_READ_R                    53
#define AVS_HKLM_SECURITY_READ_URL                  54
#define AVS_HKLM_SYSTEM_READ                        55
#define AVS_HKLM_SYSTEM_READ_R                      56
#define AVS_HKLM_SYSTEM_READ_URL                    57
#define AVS_HKCC_READ                               58
#define AVS_HKCC_READ_R                             59
#define AVS_HKCC_READ_URL                           60
#define AVS_HKUS_READ                               61
#define AVS_HKUS_READ_R                             62
#define AVS_HKUS_READ_URL                           63
#define AVS_NON_HKCU_WRITE                          64
#define AVS_NON_HKCU_WRITE_R                        65
#define AVS_NON_HKCU_WRITE_URL                      66
#define AVS_REGISTRYCHECKS_DESC                     67
#define AVS_REGISTRYCHECKS_FRIENDLY                 68
/*****************************************************
// RegistryChecks End
//***************************************************/

/*****************************************************
// FilePaths Begin
//***************************************************/
#define AVS_HARDCODED_WINDOWSPATH                   150
#define AVS_HARDCODED_WINDOWSPATH_R                 151
#define AVS_HARDCODED_WINDOWSPATH_URL               152
#define AVS_HARDCODED_SYSWINDOWSPATH                153
#define AVS_HARDCODED_SYSWINDOWSPATH_R              154
#define AVS_HARDCODED_SYSWINDOWSPATH_URL            155
#define AVS_HARDCODED_SYSTEMPATH                    156
#define AVS_HARDCODED_SYSTEMPATH_R                  157
#define AVS_HARDCODED_SYSTEMPATH_URL                158
#define AVS_HARDCODED_PERSONALPATH                  159
#define AVS_HARDCODED_PERSONALPATH_R                160
#define AVS_HARDCODED_PERSONALPATH_URL              161
#define AVS_HARDCODED_COMMONPROGRAMS                162
#define AVS_HARDCODED_COMMONPROGRAMS_R              163
#define AVS_HARDCODED_COMMONPROGRAMS_URL            164
#define AVS_HARDCODED_COMMONSTARTMENU               165
#define AVS_HARDCODED_COMMONSTARTMENU_R             166
#define AVS_HARDCODED_COMMONSTARTMENU_URL           167
#define AVS_HARDCODED_PROGRAMS                      168
#define AVS_HARDCODED_PROGRAMS_R                    169
#define AVS_HARDCODED_PROGRAMS_URL                  170
#define AVS_HARDCODED_STARTMENU                     171
#define AVS_HARDCODED_STARTMENU_R                   172
#define AVS_HARDCODED_STARTMENU_URL                 173
#define AVS_HARDCODED_GETTEMPPATH                   174
#define AVS_HARDCODED_GETTEMPPATH_R                 175
#define AVS_HARDCODED_GETTEMPPATH_URL               176
#define AVS_FILEPATHS_DESC                          177
#define AVS_FILEPATHS_FRIENDLY                      178
/*****************************************************
// FilePaths End
//***************************************************/

/*****************************************************
// LogStartAndStop Begin
//***************************************************/
#define AVS_APP_STOPPED                             250
#define AVS_APP_STOPPED_R                           251
#define AVS_APP_STOPPED_URL                         252
#define AVS_APP_STARTED                             253
#define AVS_APP_STARTED_R                           254
#define AVS_APP_STARTED_URL                         255
#define AVS_LOGSTARTANDSTOP_DESC                    256
#define AVS_LOGSTARTANDSTOP_FRIENDLY                257
/*****************************************************
// LogStartAndStop End
//***************************************************/

/*****************************************************
// HighVersionLie Begin
//***************************************************/
#define IDD_HIGHVERSION_OPTIONS                     300
#define IDC_HVL_EDIT_MAJOR_VERSION                  301
#define IDC_HVL_EDIT_MINOR_VERSION                  302
#define IDC_HVL_EDIT_BUILD_NUMBER                   303
#define IDC_HVL_BTN_DEFAULT                         304
#define AVS_HIGHVERSION_GETVERSIONEX                350
#define AVS_HIGHVERSION_GETVERSIONEX_R              351
#define AVS_HIGHVERSION_GETVERSIONEX_URL            352
#define AVS_HIGHVERSION_GETVERSION                  353
#define AVS_HIGHVERSION_GETVERSION_R                354
#define AVS_HIGHVERSION_GETVERSION_URL              355
#define AVS_HIGHVERSIONLIE_DESC                     356
#define AVS_HIGHVERSIONLIE_FRIENDLY                 357
/*****************************************************
// HighVersionLie End
//***************************************************/

/*****************************************************
// LogFileChanges Begin
//***************************************************/
#define IDD_LOGFILECHANGES_OPTIONS                  400
#define IDC_LFC_LOG_ATTRIBUTES                      401
#define IDC_LFC_UFW_PROGFILES                       402
#define IDC_LFC_UFW_WINDOWS                         403
#define IDC_LFC_BTN_DEFAULT                         404
#define AVS_LOGFILECHANGES_LOGLOC                   450
#define AVS_LOGFILECHANGES_LOGLOC_R                 451
#define AVS_LOGFILECHANGES_LOGLOC_URL               452
#define AVS_LOGFILECHANGES_UFW                      453
#define AVS_LOGFILECHANGES_UFW_R                    454
#define AVS_LOGFILECHANGES_UFW_URL                  455
#define AVS_LOGFILECHANGES_DESC                     456
#define AVS_LOGFILECHANGES_FRIENDLY                 457
/*****************************************************
// LogFileChanges End
//***************************************************/

/*****************************************************
// WindowsFileProtection Begin
//***************************************************/
#define AVS_WFP_COPYFILE                            550
#define AVS_WFP_MOVEFILE                            551
#define AVS_WFP_DELETEFILE                          552
#define AVS_WFP_REPLACEFILE                         553
#define AVS_WFP_WRITEFILE                           554
#define AVS_WFP_OPENFILE                            555
#define AVS_WFP_SHFILEOP                            556
#define AVS_WFP_GENERAL_R                           557
#define AVS_WFP_GENERAL_URL                         558
#define AVS_WINFILEPROTECT_DESC                     559
#define AVS_WINFILEPROTECT_FRIENDLY                 560
/*****************************************************
// WindowsFileProtection End
//***************************************************/

/*****************************************************
// DirectXFileVersionInfo Begin
//***************************************************/
#define AVS_DXFILEVERINFO_DXFILE                    650
#define AVS_DXFILEVERINFO_DXFILE_R                  651
#define AVS_DXFILEVERINFO_DXFILE_URL                652
#define AVS_DXFILEVERINFO_DESC                      653
#define AVS_DXFILEVERINFO_FRIENDLY                  654
/*****************************************************
// DirectXFileVersionInfo End
//***************************************************/

/*****************************************************
// LogRegistryChanges Begin
//***************************************************/
#define AVS_LOGREGCHANGES_LOGLOC                    750
#define AVS_LOGREGCHANGES_LOGLOC_R                  751
#define AVS_LOGREGCHANGES_LOGLOC_URL                752
#define AVS_LOGREGCHANGES_DESC                      753
#define AVS_LOGREGCHANGES_FRIENDLY                  754
/*****************************************************
// LogRegistryChanges End
//***************************************************/

/*****************************************************
// ObsoleteAPICalls Begin
//***************************************************/
#define AVS_OBSOLETECALLS_API                       850
#define AVS_OBSOLETECALLS_API_R                     851
#define AVS_OBSOLETECALLS_API_URL                   852
#define AVS_OBSOLETECALLS_DESC                      853
#define AVS_OBSOLETECALLS_FRIENDLY                  854
/*****************************************************
// ObsoleteAPICalls End
//***************************************************/

/*****************************************************
// KernelModeDriverInstall Begin
//***************************************************/
#define AVS_KMODEDRIVER_INST                        950
#define AVS_KMODEDRIVER_INST_R                      951
#define AVS_KMODEDRIVER_INST_URL                    952
#define AVS_KMODEDRIVER_DESC                        953
#define AVS_KMODEDRIVER_FRIENDLY                    954
/*****************************************************
// KernelModeDriverInstall End
//***************************************************/

/*****************************************************
// SecurityChecks Begin
//***************************************************/
#define AVS_SECURITYCHECKS_DESC                     1050
#define AVS_SECURITYCHECKS_FRIENDLY                 1051
#define AVS_SECURITYCHECKS_BADARGUMENTS             1052
#define AVS_SECURITYCHECKS_BADARGUMENTS_R           1053
#define AVS_SECURITYCHECKS_BADARGUMENTS_URL         1054
#define AVS_SECURITYCHECKS_WINEXEC                  1055
#define AVS_SECURITYCHECKS_WINEXEC_R                1056
#define AVS_SECURITYCHECKS_WINEXEC_URL              1057
#define AVS_SECURITYCHECKS_NULL_DACL                1058
#define AVS_SECURITYCHECKS_NULL_DACL_R              1059
#define AVS_SECURITYCHECKS_NULL_DACL_URL            1060
#define AVS_SECURITYCHECKS_WORLDWRITE_DACL          1061
#define AVS_SECURITYCHECKS_WORLDWRITE_DACL_R        1062
#define AVS_SECURITYCHECKS_WORLDWRITE_DACL_URL      1063
/*****************************************************
// KernelModeDriverInstall End
//***************************************************/

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\logfilechanges.h ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   LogFileChanges.h

 Abstract:

   This AppVerifier shim hooks all the native file I/O APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created

--*/
#ifndef __APPVERIFIER_LOGFILECHANGES_H_
#define __APPVERIFIER_LOGFILECHANGES_H_

#include "precomp.h"

//
// Length (in characters) of the largest element.
//
#define MAX_ELEMENT_SIZE 1024 * 10

//
// Length (in characters) of the longest operation type.
//
#define MAX_OPERATION_LENGTH 32

//
// Flags that indicate what state the file is in.
//
#define LFC_EXISTING    0x00000001
#define LFC_DELETED     0x00000002
#define LFC_MODIFIED    0x00000004
#define LFC_UNAPPRVFW   0x00000008

//
// Maximum number of handles we can track for a single file.
//
#define MAX_NUM_HANDLES 64

//
// We maintain a doubly linked list of file handles so we know what file is being modified
// during a file operation.
//
typedef struct _LOG_HANDLE {
    LIST_ENTRY      Entry;
    HANDLE          hFile[MAX_NUM_HANDLES];     // array of file handles
    DWORD           dwFlags;                    // flags that relate to the state of the file
    LPWSTR          pwszFilePath;               // full path to the file
    UINT            cHandles;                   // number of handles open for this file
} LOG_HANDLE, *PLOG_HANDLE;

//
// Flags that define different settings in effect.
//
#define LFC_OPTION_ATTRIBUTES       0x00000001
#define LFC_OPTION_UFW_WINDOWS      0x00000002
#define LFC_OPTION_UFW_PROGFILES    0x00000004

//
// Enumeration for different operations.
//
typedef enum {
    eCreatedFile = 0,
    eOpenedFile,
    eDeletedFile,
    eModifiedFile,
    eRenamedFile
} OperationType;

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif
#define ARRAYSIZE(a)  (sizeof(a) / sizeof(a[0]))

//
// Macros for memory allocation/deallocation.
//
#define MemAlloc(s)     RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define MemFree(b)      RtlFreeHeap(RtlProcessHeap(), 0, (b))

//
// On Windows 2000, we need to pre-allocate the event
// in RTL_CRITICAL_SECTION. On XP and above, this is
// a no-op.
//
#define PREALLOCATE_EVENT_MASK  0x80000000

//
// Critical section wrapper class.
//
class CCriticalSection
{
private:
    CRITICAL_SECTION m_CritSec;

public:
    CCriticalSection()
    {
        InitializeCriticalSectionAndSpinCount(&m_CritSec,
                                              PREALLOCATE_EVENT_MASK | 4000);
    }

    ~CCriticalSection()
    {
        DeleteCriticalSection(&m_CritSec);
    }

    void Lock()
    {
        EnterCriticalSection(&m_CritSec);
    }

    BOOL TryLock()
    {
        return TryEnterCriticalSection(&m_CritSec);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_CritSec);
    }
};


//
// Auto-lock class that uses the CCriticalSection class.
//
class CLock
{
private:
    CCriticalSection &m_CriticalSection;

public:
    CLock(CCriticalSection &CriticalSection)
        : m_CriticalSection(CriticalSection)
    {
        m_CriticalSection.Lock();
    }

    ~CLock()
    {
        m_CriticalSection.Unlock();
    }
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(NtDeleteFile)
    APIHOOK_ENUM_ENTRY(NtClose)
    APIHOOK_ENUM_ENTRY(NtCreateFile)
    APIHOOK_ENUM_ENTRY(NtOpenFile)
    APIHOOK_ENUM_ENTRY(NtWriteFile)
    APIHOOK_ENUM_ENTRY(NtWriteFileGather)
    APIHOOK_ENUM_ENTRY(NtSetInformationFile)

    //
    // Hook these only for Windows 2000 so we know when
    // it's safe to call shel32.
    //
#ifdef SHIM_WIN2K
    APIHOOK_ENUM_ENTRY(GetStartupInfoA)
    APIHOOK_ENUM_ENTRY(GetStartupInfoW)
#endif // SHIM_WIN2K

APIHOOK_ENUM_END

#endif // __APPVERIFIER_LOGFILECHANGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\kernelmodedriverinstall.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   KernelModeDriverInstall.cpp

 Abstract:

   This AppVerifier shim detects if an application
   is attempting to install a kernel mode driver.
   It monitors calls to CreateService and monitors
   the registry where information about drivers is
   stored.

 Notes:

   This is a general purpose shim.

 History:

   09/30/2001   rparsons    Created
   10/03/2001   rparsons    Fixed Raid bug # 476193
   11/29/2001   rparsons    Fixed Raid bug # 499824

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(KernelModeDriverInstall)
#include "ShimHookMacro.h"

BEGIN_DEFINE_VERIFIER_LOG(KernelModeDriverInstall)
    VERIFIER_LOG_ENTRY(VLOG_KMODEDRIVER_INST)    
END_DEFINE_VERIFIER_LOG(KernelModeDriverInstall)

INIT_VERIFIER_LOG(KernelModeDriverInstall);

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateServiceA)
    APIHOOK_ENUM_ENTRY(CreateServiceW)
    APIHOOK_ENUM_ENTRY(NtSetValueKey)
    
APIHOOK_ENUM_END

//
// Initial size to use for a stack based buffer when
// performing a Nt registry API call.
//
#define MAX_INFO_LENGTH 512

//
// Constant for the 'ControlSet' & 'CurrentrControlSet' key path in the registry.
//
#define KMDI_CONTROLSET_KEY     L"REGISTRY\\MACHINE\\SYSTEM\\ControlSet"
#define KMDI_CURCONTROLSET_KEY  L"REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet"

//
// Constant for the 'Services' key path.
//
#define KMDI_SERVICES_KEY L"Services\\"

//
// Constant for the ValueName that we need to look for.
//
#define KMDI_VALUE_NAME L"Type"

//
// Constant for the Value that we need to look for.
//
#define KMDI_TYPE_VALUE 0x00000001L

//
// Macros for memory allocation/deallocation.
//
#define MemAlloc(s) RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (s));
#define MemFree(b)  RtlFreeHeap(RtlProcessHeap(), 0, (b));

SC_HANDLE
APIHOOK(CreateServiceA)(
    SC_HANDLE hSCManager,           // handle to SCM database 
    LPCSTR    lpServiceName,        // name of service to start
    LPCSTR    lpDisplayName,        // display name
    DWORD     dwDesiredAccess,      // type of access to service
    DWORD     dwServiceType,        // type of service
    DWORD     dwStartType,          // when to start service
    DWORD     dwErrorControl,       // severity of service failure
    LPCSTR    lpBinaryPathName,     // name of binary file
    LPCSTR    lpLoadOrderGroup,     // name of load ordering group
    LPDWORD   lpdwTagId,            // tag identifier
    LPCSTR    lpDependencies,       // array of dependency names
    LPCSTR    lpServiceStartName,   // account name 
    LPCSTR    lpPassword            // account password
    )
{
    SC_HANDLE scHandle;

    scHandle = ORIGINAL_API(CreateServiceA)(hSCManager,
                                            lpServiceName,
                                            lpDisplayName,
                                            dwDesiredAccess,
                                            dwServiceType,
                                            dwStartType,
                                            dwErrorControl,
                                            lpBinaryPathName,
                                            lpLoadOrderGroup,
                                            lpdwTagId,
                                            lpDependencies,
                                            lpServiceStartName,
                                            lpPassword);

    if (scHandle) {
        //
        // If the ServiceType flag specifies that this is a kernel
        // mode driver, raise a flag.
        //
        if (dwServiceType & SERVICE_KERNEL_DRIVER) {
            VLOG(VLOG_LEVEL_INFO,
                 VLOG_KMODEDRIVER_INST,
                 "CreateServiceA was called. The path to the driver is %hs",
                 lpBinaryPathName);
        }
    }

    return scHandle;
}

SC_HANDLE
APIHOOK(CreateServiceW)(
    SC_HANDLE hSCManager,           // handle to SCM database 
    LPCWSTR   lpServiceName,        // name of service to start
    LPCWSTR   lpDisplayName,        // display name
    DWORD     dwDesiredAccess,      // type of access to service
    DWORD     dwServiceType,        // type of service
    DWORD     dwStartType,          // when to start service
    DWORD     dwErrorControl,       // severity of service failure
    LPCWSTR   lpBinaryPathName,     // name of binary file
    LPCWSTR   lpLoadOrderGroup,     // name of load ordering group
    LPDWORD   lpdwTagId,            // tag identifier
    LPCWSTR   lpDependencies,       // array of dependency names
    LPCWSTR   lpServiceStartName,   // account name 
    LPCWSTR   lpPassword            // account password
    )
{
    SC_HANDLE scHandle;
    
    scHandle =  ORIGINAL_API(CreateServiceW)(hSCManager,
                                             lpServiceName,
                                             lpDisplayName,
                                             dwDesiredAccess,
                                             dwServiceType,
                                             dwStartType,
                                             dwErrorControl,
                                             lpBinaryPathName,
                                             lpLoadOrderGroup,
                                             lpdwTagId,
                                             lpDependencies,
                                             lpServiceStartName,
                                             lpPassword);

    if (scHandle) {
        //
        // If the ServiceType flag specifies that this is a kernel
        // mode driver, raise a flag.
        //
        if (dwServiceType & SERVICE_KERNEL_DRIVER) {
            VLOG(VLOG_LEVEL_INFO,
                 VLOG_KMODEDRIVER_INST,
                 "CreateServiceW was called. The path to the driver is %ls",
                 lpBinaryPathName);
        }
    }

    return scHandle;
}

/*++

 Validate the registry data we received and warn the user if a driver is being installed.

--*/
void
WarnUserIfKernelModeDriver(
    IN HANDLE          hKey,
    IN PUNICODE_STRING pstrValueName,
    IN ULONG           ulType,
    IN PVOID           pData
    )
{
    NTSTATUS                status;
    ULONG                   ulSize;
    BYTE                    KeyNameInfo[MAX_INFO_LENGTH];
    PKEY_NAME_INFORMATION   pKeyNameInfo;

    pKeyNameInfo = (PKEY_NAME_INFORMATION)KeyNameInfo;
    
    //
    // RegSetValue allows for NULL value names.
    // Ensure that we don't have one before going any further.
    //
    if (!pstrValueName->Buffer) {
        return;
    }

    //
    // Determine if the ValueName is 'Type'.
    // If not, we don't need to go any further.
    //
    if (_wcsicmp(pstrValueName->Buffer, KMDI_VALUE_NAME)) {
        DPFN(eDbgLevelInfo,
             "[WarnUserIfKernelModeDriver] ValueName is not '%ls'",
             KMDI_VALUE_NAME);
        return;
    }

    //
    // Determine if the type of the value is DWORD.
    // If not, we need don't need to go any further.
    //
    if (REG_DWORD != ulType) {
        DPFN(eDbgLevelInfo,
             "[WarnUserIfKernelModeDriver] ValueType is not REG_DWORD");
        return;
    }

    //
    // At this point, we have a value that is of type REG_DWORD and
    // has a name of 'Type'. Now we see if the key is a subkey of 'Services'.
    //
    status = NtQueryKey(hKey,
                        KeyNameInformation,
                        pKeyNameInfo,
                        MAX_INFO_LENGTH,
                        &ulSize);

    if ((STATUS_BUFFER_OVERFLOW == status) ||
        (STATUS_BUFFER_TOO_SMALL == status)) {
        //
        // Our stack based buffer wasn't large enough.
        // Allocate from the heap and call it again.
        //
        pKeyNameInfo = (PKEY_NAME_INFORMATION)MemAlloc(ulSize);

        if (!pKeyNameInfo) {
            DPFN(eDbgLevelError,
                 "[WarnUserIfKernelModeDriver] Failed to allocate memory");
            return;
        }

        status = NtQueryKey(hKey,
                            KeyNameInformation,
                            pKeyNameInfo,
                            ulSize,
                            &ulSize);
    }

    if (NT_SUCCESS(status)) {
        //
        // See if this key points to CurrentControlSet or ControlSet.
        //
        if (wcsistr(pKeyNameInfo->Name, KMDI_CURCONTROLSET_KEY) ||
            wcsistr(pKeyNameInfo->Name, KMDI_CONTROLSET_KEY)) {
            
            //
            // Now see if this key points to Services.
            //
            if (wcsistr(pKeyNameInfo->Name, KMDI_SERVICES_KEY)) {
                //
                // We've got a key under 'Services'.
                // If the Data has a value of 0x00000001, 
                // we've got a kernel mode driver being installed.
                //
                if ((*(DWORD*)pData == KMDI_TYPE_VALUE)) {
                    VLOG(VLOG_LEVEL_ERROR,
                         VLOG_KMODEDRIVER_INST,
                         "The driver was installed via the registry.");
                }
            }
        }
    }

    if (pKeyNameInfo != (PKEY_NAME_INFORMATION)KeyNameInfo) {
        MemFree(pKeyNameInfo);
    }
}

NTSTATUS
APIHOOK(NtSetValueKey)(
    IN HANDLE          KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG           TitleIndex OPTIONAL,
    IN ULONG           Type,
    IN PVOID           Data,
    IN ULONG           DataSize
    )
{
    NTSTATUS    status;

    status = ORIGINAL_API(NtSetValueKey)(KeyHandle,
                                         ValueName,
                                         TitleIndex,
                                         Type,
                                         Data,
                                         DataSize);

    if (NT_SUCCESS(status)) {
        WarnUserIfKernelModeDriver(KeyHandle, ValueName, Type, Data);
    }

    return status;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_KMODEDRIVER_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_KMODEDRIVER_FRIENDLY)
    SHIM_INFO_VERSION(1, 1)
    SHIM_INFO_FLAGS(AVRF_FLAG_EXTERNAL_ONLY)
    SHIM_INFO_INCLUDE_EXCLUDE("I:advapi32.dll")
    
SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_KMODEDRIVER_INST, 
                            AVS_KMODEDRIVER_INST,
                            AVS_KMODEDRIVER_INST_R,
                            AVS_KMODEDRIVER_INST_URL)

    APIHOOK_ENTRY(ADVAPI32.DLL,     CreateServiceA)
    APIHOOK_ENTRY(ADVAPI32.DLL,     CreateServiceW)
    APIHOOK_ENTRY(NTDLL.DLL,         NtSetValueKey)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\logfilechanges.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   LogFileChanges.cpp

 Abstract:

   This AppVerifier shim hooks all the native file I/O APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created
   09/20/2001   rparsons    Output attributes in XML
                            VLOG with log file location
   02/20/2002   rparsons    Implemented strsafe functions
   05/01/2002   rparsons    Fixed Raid bug # 

--*/
#include "precomp.h"
#include "rtlutils.h"

IMPLEMENT_SHIM_BEGIN(LogFileChanges)
#include "ShimHookMacro.h"
#include "LogFileChanges.h"

BEGIN_DEFINE_VERIFIER_LOG(LogFileChanges)
    VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_LOGLOC)
    VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_UFW)
END_DEFINE_VERIFIER_LOG(LogFileChanges)

INIT_VERIFIER_LOG(LogFileChanges);

//
// Stores the NT path to the file system log file for the current session.
//
UNICODE_STRING g_strLogFilePath;

//
// Stores the DOS path to the file system log file for the current session.
//
WCHAR g_wszLogFilePath[MAX_PATH];

//
// Stores the full path to the %windir% directory.
//
WCHAR g_wszWindowsDir[MAX_PATH];

//
// Stores the full path to the 'Program Files' directory.
//
WCHAR g_wszProgramFilesDir[MAX_PATH];

//
// Head of our doubly linked list.
//
LIST_ENTRY g_OpenHandleListHead;

//
// Stores the settings for our shim.
//
DWORD g_dwSettings;

//
// Global buffer for putting text into the XML.
//
WCHAR g_wszXMLBuffer[MAX_ELEMENT_SIZE];

//
// Critical section that keeps us safe while using linked-lists, etc.
//
CCriticalSection g_csCritSec;

/*++

 Writes an entry to the log file.

--*/
void
WriteEntryToLog(
    IN LPCWSTR pwszEntry
    )
{
    int                 cbSize;
    HANDLE              hFile;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    NTSTATUS            status;

    //
    // Note that we have to use native APIs throughout this function
    // to avoid a problem with circular hooking. That is, if we simply
    // call WriteFile, which is exported from kernel32, it will call NtWriteFile,
    // which is a call that we hook, in turn leaving us in and endless loop.
    //

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &g_strLogFilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[WriteEntryToLog] 0x%X Failed to open log",
             status);
        return;
    }

    //
    // Write the data out to the file.
    //
    cbSize = wcslen(pwszEntry);
    cbSize *= sizeof(WCHAR);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)pwszEntry,
                         (ULONG)cbSize,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[WriteEntryToLog] 0x%X Failed to make entry",
             status);
        goto exit;
    }

exit:

    NtClose(hFile);

}

/*++

 Creates our XML file to store our results in.

--*/
BOOL
InitializeLogFile(
    void
    )
{
    BOOL                bReturn = FALSE;
    BOOL                bStatus = FALSE;
    HANDLE              hFile;
    DWORD               cchSize;
    WCHAR*              pwchSlash = NULL;
    WCHAR*              pwchDot = NULL;
    WCHAR               wszLogFilePath[MAX_PATH];
    WCHAR               wszModPathName[MAX_PATH];
    WCHAR               wszLogFile[MAX_PATH / 2];
    WCHAR               wszShortName[MAX_PATH / 2];
    WCHAR               wszLogHdr[512];
    WCHAR               wchUnicodeHdr = 0xFEFF;
    HRESULT             hr;
    NTSTATUS            status;
    SYSTEMTIME          st;
    UNICODE_STRING      strLogFile;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;

    //
    // Format the log header.
    //
    cchSize = GetModuleFileName(NULL, wszModPathName, ARRAYSIZE(wszModPathName));

    if (cchSize > ARRAYSIZE(wszModPathName) || cchSize == 0) {
        StringCchCopy(wszModPathName, ARRAYSIZE(wszModPathName), L"unknown");
    }

    hr = StringCchPrintf(wszLogHdr,
                         ARRAYSIZE(wszLogHdr),
                         L"%lc<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<APPLICATION NAME=\"%ls\">\r\n",
                         wchUnicodeHdr,
                         wszModPathName);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to format log header",
             HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // Get the path where log files are stored.
    //
    cchSize = GetAppVerifierLogPath(wszLogFilePath, ARRAYSIZE(wszLogFilePath));

    if (cchSize > ARRAYSIZE(wszLogFilePath) || cchSize == 0) {
        DPFN(eDbgLevelError, "[InitializeLogFile] Failed to get log path");
        return FALSE;
    }

    //
    // See if the directory exists - don't try to create it.
    //
    if (GetFileAttributes(wszLogFilePath) == -1) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] Log file directory '%ls' does not exist",
             wszLogFilePath);
        return FALSE;
    }

    //
    // Set up the log filename.
    // The format is this: processname_filesys_yyyymmdd_hhmmss.xml
    //
    GetLocalTime(&st);

    *wszShortName = 0;
    pwchDot = wcsrchr(wszModPathName, '.');

    if (pwchDot) {
        *pwchDot = 0;
    }

    pwchSlash = wcsrchr(wszModPathName, '\\');

    if (pwchSlash) {
        StringCchCopy(wszShortName, ARRAYSIZE(wszShortName), ++pwchSlash);
    }

    hr = StringCchPrintf(wszLogFile,
                         ARRAYSIZE(wszLogFile),
                         L"%ls_filesys_%02hu%02hu%02hu_%02hu%02hu%02hu.xml",
                         wszShortName,
                         st.wYear,
                         st.wMonth,
                         st.wDay,
                         st.wHour,
                         st.wMinute,
                         st.wSecond);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to format log filename",
             HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // See if the file already exists.
    //
    SetCurrentDirectory(wszLogFilePath);

    if (GetFileAttributes(wszLogFile) != -1) {
        //
        // Reformat the filename.
        //
        hr = StringCchPrintf(wszLogFile,
                             ARRAYSIZE(wszLogFile),
                             L"%ls_filesys_%02hu%02hu%02hu_%02hu%02hu%02hu_%lu.xml",
                             wszShortName,
                             st.wYear,
                             st.wMonth,
                             st.wDay,
                             st.wHour,
                             st.wMinute,
                             st.wSecond,
                             GetTickCount());

        if (FAILED(hr)) {
            DPFN(eDbgLevelError,
                 "[InitializeLogFile] 0x%08X Failed to reformat log filename",
                 HRESULT_CODE(hr));
            return FALSE;
        }
    }

    StringCchCat(wszLogFilePath, ARRAYSIZE(wszLogFilePath), L"\\");
    hr = StringCchCat(wszLogFilePath, ARRAYSIZE(wszLogFilePath), wszLogFile);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to format path to log",
             HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // Preserve this path for later use.
    //
    hr = StringCchCopy(g_wszLogFilePath,
                       ARRAYSIZE(g_wszLogFilePath),
                       wszLogFilePath);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to save path to log",
             HRESULT_CODE(hr));
        return FALSE;
    }

    bStatus = RtlDosPathNameToNtPathName_U(wszLogFilePath,
                                           &strLogFile,
                                           NULL,
                                           NULL);

    if (!bStatus) {
        DPFN(eDbgLevelError, "[InitializeLogFile] DOS path --> NT path failed");
        return FALSE;
    }

    //
    // Create the log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_CREATE,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%X Failed to create log",
             status);
        goto cleanup;
    }

    NtClose(hFile);

    //
    // Preserve the NT path for later use.
    //
    status = ShimDuplicateUnicodeString(RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                        RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                        &strLogFile,
                                        &g_strLogFilePath);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%X Failed to save log file path",
             status);
        goto cleanup;
    }

    //
    // Write the header to the log.
    //
    WriteEntryToLog(wszLogHdr);

    bReturn = TRUE;

cleanup:

    if (bStatus) {
        RtlFreeUnicodeString(&strLogFile);
    }

    return bReturn;
}

/*++

 Displays the name associated with this object.

--*/
void
PrintNameFromHandle(
    IN HANDLE hObject
    )
{
    NTSTATUS                    status;
    WCHAR                       wszBuffer[MAX_PATH];
    OBJECT_NAME_INFORMATION*    poni = NULL;

    *wszBuffer = 0;

    poni = (OBJECT_NAME_INFORMATION*)wszBuffer;

    status = NtQueryObject(hObject,
                           ObjectNameInformation,
                           poni,
                           MAX_PATH,
                           NULL);

    if (NT_SUCCESS(status)) {
        DPFN(eDbgLevelInfo,
             "Handle 0x%08X has name: %ls",
             hObject,
             poni->Name.Buffer);
    }
}

/*++

 Formats the data to form an XML element.

--*/
void
FormatDataIntoElement(
    IN OperationType eType,
    IN LPCWSTR       pwszFilePath
    )
{
    size_t      cchRemaining;
    DWORD       dwCount;
    DWORD       dwAttrCount;
    WCHAR*      pwszEnd = NULL;
    WCHAR       wszItem[MAX_PATH];
    WCHAR       wszOperation[MAX_OPERATION_LENGTH];
    PATTRINFO   pAttrInfo = NULL;
    HRESULT     hr;

    CString csFilePart(L"");
    CString csPathPart(L"");
    CString csString(pwszFilePath);

    *g_wszXMLBuffer = 0;

    //
    // Replace any & or ' in the file path.
    // We have to do this since we're saving to XML.
    // Note that the file system doesn't allow < > or "
    //
    csString.Replace(L"&", L"amp;");
    csString.Replace(L"'", L"&apos;");

    //
    // Put the path into a CString, then break it into pieces
    // so we can use it in our element.
    //
    csString.GetNotLastPathComponent(csPathPart);
    csString.GetLastPathComponent(csFilePart);

    switch (eType) {
    case eCreatedFile:
        StringCchCopy(wszOperation, ARRAYSIZE(wszOperation), L"Created File");
        break;
    case eModifiedFile:
        StringCchCopy(wszOperation, ARRAYSIZE(wszOperation), L"Modified File");
        break;
    case eDeletedFile:
        StringCchCopy(wszOperation, ARRAYSIZE(wszOperation), L"Deleted File");
        break;
    default:
        StringCchCopy(wszOperation, ARRAYSIZE(wszOperation), L"Unknown");
        break;
    }

    //
    // If we're logging attributes and this is not file deletion, press on.
    //
    if ((g_dwSettings & LFC_OPTION_ATTRIBUTES) && (eType != eDeletedFile)) {

        hr = StringCchPrintfEx(g_wszXMLBuffer,
                               ARRAYSIZE(g_wszXMLBuffer),
                               &pwszEnd,
                               &cchRemaining,
                               0,
                               L"    <FILE OPERATION=\"%ls\" NAME=\"%ls\" PATH=\"%ls\"",
                               wszOperation,
                               csFilePart.Get(),
                               csPathPart.Get());

        if (FAILED(hr)) {
            DPFN(eDbgLevelError,
                 "[FormatDataIntoElement] 0x%08X Error formatting data",
                 HRESULT_CODE(hr));
            return;
        }

        //
        // Call the attribute manager to get the attributes for this file.
        // Loop through all the attributes and add the ones that are available.
        //
        if (SdbGetFileAttributes(pwszFilePath, &pAttrInfo, &dwAttrCount)) {

            for (dwCount = 0; dwCount < dwAttrCount; dwCount++) {

                if (pAttrInfo[dwCount].dwFlags & ATTRIBUTE_AVAILABLE) {
                    if (!SdbFormatAttribute(&pAttrInfo[dwCount],
                                            wszItem,
                                            ARRAYSIZE(wszItem))) {
                        continue;
                    }

                    hr = StringCchPrintfEx(pwszEnd,
                                           cchRemaining,
                                           &pwszEnd,
                                           &cchRemaining,
                                           0,
                                           L" %ls",
                                           wszItem);

                    if (FAILED(hr)) {
                        DPFN(eDbgLevelError,
                             "[FormatDataIntoElement] 0x%08X Error formatting attribute data",
                             HRESULT_CODE(hr));
                        return;
                    }
                }
            }

            if (pAttrInfo) {
                SdbFreeFileAttributes(pAttrInfo);
            }
        }

        //
        // Append the '/>\r\n' to the file element.
        //
        hr = StringCchPrintfEx(pwszEnd,
                               cchRemaining,
                               NULL,
                               NULL,
                               0,
                               L"/>\r\n");

        if (FAILED(hr)) {
            DPFN(eDbgLevelError,
                 "[FormatDataIntoElement] 0x%08X Error formatting end of element",
                 HRESULT_CODE(hr));
            return;
        }
    } else {
        //
        // Format the element without attributes.
        //
        StringCchPrintf(g_wszXMLBuffer,
                        ARRAYSIZE(g_wszXMLBuffer),
                        L"    <FILE OPERATION=\"%ls\" NAME=\"%ls\" PATH=\"%ls\"/>\r\n",
                        wszOperation,
                        csFilePart.Get(),
                        csPathPart.Get());
    }

    WriteEntryToLog(g_wszXMLBuffer);
}

/*++

 Format file system data passed in and write it to the log.

--*/
void
FormatFileDataLogEntry(
    IN PLOG_HANDLE pHandle
    )
{
    //
    // Ensure that our parameters are valid before going any further.
    //
    if (!pHandle || !pHandle->pwszFilePath) {
        DPFN(eDbgLevelError, "[FormatFileDataLogEntry] Invalid parameter(s)");
        return;
    }

    //
    // Save ourselves a lot of work by logging only what needs to be logged.
    //
    if ((pHandle->dwFlags & LFC_EXISTING) &&
        (!(pHandle->dwFlags & LFC_DELETED)) &&
        (!(pHandle->dwFlags & LFC_MODIFIED))) {
        return;
    }

    //
    // Check for an unapproved file write, and keep moving afterward.
    //
    if (pHandle->dwFlags & LFC_UNAPPRVFW) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_LOGFILECHANGES_UFW,
             "Path and Filename: %ls",
             pHandle->pwszFilePath);
    }

    //
    // Move through the different operations.
    //
    // 1. Check for a deletion of an existing file.
    //
    if ((pHandle->dwFlags & LFC_DELETED) &&
        (pHandle->dwFlags & LFC_EXISTING)) {
        FormatDataIntoElement(eDeletedFile, pHandle->pwszFilePath);
        return;
    }

    //
    // 2. Check for modification of an existing file.
    //
    if ((pHandle->dwFlags & LFC_MODIFIED) &&
        (pHandle->dwFlags & LFC_EXISTING)) {
        FormatDataIntoElement(eModifiedFile, pHandle->pwszFilePath);
        return;
    }

    //
    // 3. Check for creation of a new file.
    //
    if (!(pHandle->dwFlags & LFC_EXISTING) &&
        (!(pHandle->dwFlags & LFC_DELETED))) {
        FormatDataIntoElement(eCreatedFile, pHandle->pwszFilePath);
        return;
    }

}

/*++

 Writes the closing element to the file and outputs the log file location.

--*/
void
CloseLogFile(
    void
    )
{
    WCHAR   wszBuffer[] = L"</APPLICATION>";

    WriteEntryToLog(wszBuffer);

    VLOG(VLOG_LEVEL_INFO, VLOG_LOGFILECHANGES_LOGLOC, "%ls", g_wszLogFilePath);
}

/*++

 Write the entire linked list out to the log file.

--*/
BOOL
WriteListToLogFile(
    void
    )
{
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pHandle = NULL;

    //
    // Walk the list and write each node to the log file.
    //
    pCurrent = g_OpenHandleListHead.Blink;

    while (pCurrent != &g_OpenHandleListHead) {
        pHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        FormatFileDataLogEntry(pHandle);

        pCurrent = pCurrent->Blink;
    }

    CloseLogFile();

    return TRUE;
}

/*++

 Given a file path, attempt to locate it in the list.
 This function may not always return a pointer.

--*/
PLOG_HANDLE
FindPathInList(
    IN LPCWSTR pwszFilePath
    )
{
    BOOL        fFound = FALSE;
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pHandle = NULL;

    //
    // Attempt to locate the entry in the list.
    //
    pCurrent = g_OpenHandleListHead.Flink;

    while (pCurrent != &g_OpenHandleListHead) {

        pHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        if (!_wcsicmp(pwszFilePath, pHandle->pwszFilePath)) {
            fFound = TRUE;
            break;
        }

        pCurrent = pCurrent->Flink;
    }

    return (fFound ? pHandle : NULL);
}

/*++

 Given a file handle and a file path, add an entry to the list.

--*/
PLOG_HANDLE
AddFileToList(
    IN HANDLE  hFile,
    IN LPCWSTR pwszPath,
    IN BOOL    fExisting,
    IN ULONG   ulCreateOptions
    )
{
    PLOG_HANDLE pHandle = NULL;
    int         nLen;

    if (!pwszPath) {
        DPFN(eDbgLevelError, "[AddFileToList] Invalid parameter");
        return NULL;
    }

    pHandle = (PLOG_HANDLE)MemAlloc(sizeof(LOG_HANDLE));

    if (!pHandle) {
        DPFN(eDbgLevelError, "[AddFileToList] Failed to allocate mem for struct");
        return NULL;
    }
    nLen = wcslen(pwszPath);

    pHandle->pwszFilePath = (LPWSTR)MemAlloc((nLen + 1) * sizeof(WCHAR));

    if (!pHandle->pwszFilePath) {
        DPFN(eDbgLevelError, "[AddFileToList] Failed to allocate mem for path");
        MemFree(pHandle);
        return NULL;
    }

    if ((ulCreateOptions == FILE_OVERWRITE_IF) && fExisting) {
        pHandle->dwFlags |= LFC_MODIFIED;
    }

    if (ulCreateOptions & FILE_DELETE_ON_CLOSE) {
        pHandle->dwFlags |= LFC_DELETED;
    }

    pHandle->cHandles   = 1;
    pHandle->hFile[0]   = hFile ? hFile : INVALID_HANDLE_VALUE;

    if (fExisting) {
        pHandle->dwFlags |= LFC_EXISTING;
    }

    StringCchCopy(pHandle->pwszFilePath, nLen + 1, pwszPath);

    DPFN(eDbgLevelInfo, "[AddFileToList] Adding entry: %p", pHandle);

    InsertHeadList(&g_OpenHandleListHead, &pHandle->Entry);

    return pHandle;
}

/*++

 Given a file handle, return a pointer to an entry in the list.
 This function should always return a pointer, although we'll handle
 the case if one is not returned.

--*/
PLOG_HANDLE
FindHandleInArray(
    IN HANDLE hFile
    )
{
    UINT        uCount;
    BOOL        fFound = FALSE;
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pFindHandle = NULL;

    //
    // An invalid handle value is useless.
    //
    if (INVALID_HANDLE_VALUE == hFile) {
        DPFN(eDbgLevelError, "[FindHandleInArray] Invalid handle passed!");
        return FALSE;
    }

    pCurrent = g_OpenHandleListHead.Flink;

    while (pCurrent != &g_OpenHandleListHead) {
        pFindHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindHandle->cHandles; uCount++) {
            if (pFindHandle->hFile[uCount] == hFile) {
                fFound = TRUE;
                break;
            }
        }

        if (fFound) {
            break;
        }

        pCurrent = pCurrent->Flink;
    }

    //
    // If the handle was not found, send output to the debugger.
    //
    if (!fFound) {
        DPFN(eDbgLevelError,
             "[FindHandleInArray] Handle 0x%08X not found!",
             hFile);
        PrintNameFromHandle(hFile);
    }

    return (pFindHandle ? pFindHandle : NULL);
}

/*++

 Given a file handle, remove it from the array in the list.

--*/
BOOL
RemoveHandleFromArray(
    IN HANDLE hFile
    )
{
    UINT        uCount;
    PLIST_ENTRY pCurrent = NULL;
    PLOG_HANDLE pFindHandle = NULL;

    //
    // An invalid handle value is useless.
    //
    if (INVALID_HANDLE_VALUE == hFile) {
        DPFN(eDbgLevelError, "[RemoveHandleFromArray] Invalid handle passed!");
        return FALSE;
    }

    pCurrent = g_OpenHandleListHead.Flink;

    while (pCurrent != &g_OpenHandleListHead) {

        pFindHandle = CONTAINING_RECORD(pCurrent, LOG_HANDLE, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindHandle->cHandles; uCount++) {
            //
            // If we find the handle, set the array element to -1 and
            // decrement the count of handles for this entry.
            //
            if (pFindHandle->hFile[uCount] == hFile) {
                DPFN(eDbgLevelInfo,
                     "[RemoveHandleFromArray] Removing handle 0x%08X",
                     hFile);
                pFindHandle->hFile[uCount] = INVALID_HANDLE_VALUE;
                pFindHandle->cHandles--;
                return TRUE;
            }
        }

        pCurrent = pCurrent->Flink;
    }

    return TRUE;
}

/*++

 Obtains the location of the 'Program Files' directory
 and stores it.

--*/
void
GetProgramFilesDir(
    void
    )
{
    SHGetFolderPath(NULL,
                    CSIDL_PROGRAM_FILES,
                    NULL,
                    SHGFP_TYPE_CURRENT,
                    g_wszProgramFilesDir);

    if (*g_wszProgramFilesDir) {
        _wcslwr(g_wszProgramFilesDir);
    }
}

/*++

 Determine if the application is performing an operation in
 Windows or Program Files.

--*/
void
CheckForUnapprovedFileWrite(
    IN PLOG_HANDLE pHandle
    )
{
    int nPosition;

    //
    // Check our flags and search for the directories accordingly.
    // If we find a match, we're done.
    //
    CString csPath(pHandle->pwszFilePath);
    csPath.MakeLower();

    if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) && (*g_wszWindowsDir)) {
        nPosition = 0;
        nPosition = csPath.Find(g_wszWindowsDir);

        if (nPosition != -1) {
            pHandle->dwFlags |= LFC_UNAPPRVFW;
            return;
        }
    }

    if ((g_dwSettings & LFC_OPTION_UFW_PROGFILES) && (*g_wszProgramFilesDir)) {
        nPosition = 0;
        nPosition = csPath.Find(g_wszProgramFilesDir);

        if (nPosition != -1) {
            pHandle->dwFlags |= LFC_UNAPPRVFW;
            return;
        }
    }
}

/*++

 Inserts a handle into an existing list entry.

--*/
void
InsertHandleIntoList(
    IN HANDLE      hFile,
    IN PLOG_HANDLE pHandle
    )
{
    UINT    uCount = 0;

    //
    // Insert the handle into an empty spot and
    // update the number of handles we're storing.
    // Make sure we don't overstep the array bounds.
    //
    for (uCount = 0; uCount < pHandle->cHandles; uCount++) {
        if (INVALID_HANDLE_VALUE == pHandle->hFile[uCount]) {
            break;
        }
    }

    if (uCount >= MAX_NUM_HANDLES) {
        DPFN(eDbgLevelError, "[InsertHandleIntoList] Handle count reached");
        return;
    }

    pHandle->hFile[uCount] = hFile;
    pHandle->cHandles++;

    //
    // It's not possible to get a handle to a file that's been deleted,
    // so remove these bits.
    //
    pHandle->dwFlags &= ~LFC_DELETED;
}

/*++

 Does all the work of updating the linked list.

--*/
void
UpdateFileList(
    IN OperationType eType,
    IN LPWSTR        pwszFilePath,
    IN HANDLE        hFile,
    IN ULONG         ulCreateDisposition,
    IN BOOL          fExisting
    )
{
    UINT        uCount;
    DWORD       dwLen = 0;
    PLOG_HANDLE pHandle = NULL;

    switch (eType) {
    case eCreatedFile:
    case eOpenedFile:
        //
        // Attempt to find the path in the list.
        // We need to check the CreateFile flags as they could
        // change an existing file.
        //
        pHandle = FindPathInList(pwszFilePath);

        if (pHandle) {
            //
            // If the file was created with the CREATE_ALWAYS flag,
            // and the file was an existing one, mark it changed.
            //
            if ((ulCreateDisposition == FILE_OVERWRITE_IF) && fExisting) {
                pHandle->dwFlags |= LFC_MODIFIED;

                if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                    (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                    CheckForUnapprovedFileWrite(pHandle);
                }
            }

            //
            // If the file was opened with the FILE_DELETE_ON_CLOSE flag,
            // mark it deleted.
            //
            if (ulCreateDisposition & FILE_DELETE_ON_CLOSE) {
                pHandle->dwFlags |= LFC_DELETED;
            }

            InsertHandleIntoList(hFile, pHandle);

            break;
        }

        //
        // The file path was not in the list, so we've never seen
        // this file before. We're going to add this guy to the list.
        //
        AddFileToList(hFile, pwszFilePath, fExisting, ulCreateDisposition);
        break;

    case eModifiedFile:
        //
        // No file path is available, so find the handle in the list.
        //
        pHandle = FindHandleInArray(hFile);

        if (pHandle) {
            pHandle->dwFlags |= LFC_MODIFIED;

            if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                CheckForUnapprovedFileWrite(pHandle);
            }
        }
        break;

    case eDeletedFile:
        //
        // Deletetion comes from two places. One provides a file path,
        // the other a handle. Determine which one we have.
        //
        if (hFile) {
            pHandle = FindHandleInArray(hFile);
        } else {
            pHandle = FindPathInList(pwszFilePath);
        }

        //
        // Rare case: If a handle wasn't available, deletion
        // is coming from NtDeleteFile, which hardly ever
        // gets called directly. Add the file path to the list
        // so we can track this deletion.
        //
        if (!pHandle && !hFile) {
            pHandle = AddFileToList(NULL, pwszFilePath, TRUE, 0);
        }

        if (pHandle) {
            pHandle->dwFlags |= LFC_DELETED;

            if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                CheckForUnapprovedFileWrite(pHandle);
            }
        }
        break;

    case eRenamedFile:
        {
            PLOG_HANDLE pSrcHandle = NULL;
            PLOG_HANDLE pDestHandle = NULL;
            WCHAR       wszFullPath[MAX_PATH];
            WCHAR*      pSlash = NULL;
            UINT        cbCopy;

            //
            // A rename is two separate operations in one.
            // * Delete of an existing file.
            // * Create of a new file.
            //
            // In this case, we attempt to find the destination file
            // in our list. If the file is not there, we add to the
            // list, then mark it as modified.
            //
            // As far as the source file, we mark it as deleted since it's
            // gone from the disk after the rename.
            //
            pSrcHandle = FindHandleInArray(hFile);

            if (pSrcHandle) {
                pDestHandle = FindPathInList(pwszFilePath);

                if (!pDestHandle) {
                    //
                    // The rename will only contain the new file name,
                    // not the path. Build a full path to the new file
                    // prior to adding it to the list.
                    //
                    StringCchCopy(wszFullPath,
                                  ARRAYSIZE(wszFullPath),
                                  pSrcHandle->pwszFilePath);

                    pSlash = wcsrchr(wszFullPath, '\\');

                    if (pSlash) {
                        *++pSlash = '\0';
                    }

                    // BUGBUG: Do we need account for the existing contents
                    //         of the buffer?
                    StringCchCat(wszFullPath,
                                 ARRAYSIZE(wszFullPath),
                                 pwszFilePath);

                    pDestHandle = AddFileToList((HANDLE)-1,
                                                wszFullPath,
                                                fExisting,
                                                ulCreateDisposition);
                }

                if (pDestHandle) {
                    pDestHandle->dwFlags  = 0;
                    pDestHandle->dwFlags |= LFC_MODIFIED;

                    if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                        (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                        CheckForUnapprovedFileWrite(pDestHandle);
                    }
                }

                pSrcHandle->dwFlags &= ~LFC_MODIFIED;
                pSrcHandle->dwFlags |= LFC_DELETED;

                if ((g_dwSettings & LFC_OPTION_UFW_WINDOWS) ||
                    (g_dwSettings & LFC_OPTION_UFW_PROGFILES)) {
                    CheckForUnapprovedFileWrite(pSrcHandle);
                }
            }
            break;
        }

    default:
        DPFN(eDbgLevelError, "[UpdateFileList] Invalid enum type!");
        return;
    }
}

/*++

 Given an NT path, convert it to a DOS path.

--*/
BOOL
ConvertNtPathToDosPath(
    IN     PUNICODE_STRING            pstrSource,
    IN OUT PRTL_UNICODE_STRING_BUFFER pstrDest
    )
{
    NTSTATUS    status;

    if (!pstrSource || !pstrDest) {
        DPFN(eDbgLevelError, "[ConvertNtPathToDosPath] Invalid parameter(s)");
        return FALSE;
    }

    status = ShimAssignUnicodeStringBuffer(pstrDest, pstrSource);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[ConvertNtPathToDosPath] Failed to initialize DOS path buffer");
        return FALSE;
    }

    status = ShimNtPathNameToDosPathName(0, pstrDest, 0, NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError, "[ConvertNtPathToDosPath] Failed to convert NT -> DOS path");
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
APIHOOK(NtCreateFile)(
    OUT PHANDLE            FileHandle,
    IN  ACCESS_MASK        DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK   IoStatusBlock,
    IN  PLARGE_INTEGER     AllocationSize OPTIONAL,
    IN  ULONG              FileAttributes,
    IN  ULONG              ShareAccess,
    IN  ULONG              CreateDisposition,
    IN  ULONG              CreateOptions,
    IN  PVOID              EaBuffer OPTIONAL,
    IN  ULONG              EaLength
    )
{
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH];
    NTSTATUS                    status;
    BOOL                        fExists;
    BOOL                        fConverted;
    CLock                       cLock(g_csCritSec);

    RtlInitUnicodeStringBuffer(&DosPathBuffer, PathBuffer, sizeof(PathBuffer));

    fConverted = ConvertNtPathToDosPath(ObjectAttributes->ObjectName, &DosPathBuffer);

    if (!fConverted) {
        DPFN(eDbgLevelError,
             "[NtCreateFile] Failed to convert NT path: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    fExists = RtlDoesFileExists_U(DosPathBuffer.String.Buffer);

    status = ORIGINAL_API(NtCreateFile)(FileHandle,
                                        DesiredAccess,
                                        ObjectAttributes,
                                        IoStatusBlock,
                                        AllocationSize,
                                        FileAttributes,
                                        ShareAccess,
                                        CreateDisposition,
                                        CreateOptions,
                                        EaBuffer,
                                        EaLength);

    //
    // Three conditions are required before the file is added to the list.
    // 1. The file must be a file system object. RtlDoesFileExists_U will
    //    return FALSE if it's not.
    //
    // 2. We must have been able to convert the NT path to a DOS path.
    //
    // 3. The call to NtCreateFile must have succeeded.
    //
    if (RtlDoesFileExists_U(DosPathBuffer.String.Buffer) && fConverted && NT_SUCCESS(status)) {
        UpdateFileList(eCreatedFile,
                       DosPathBuffer.String.Buffer,
                       *FileHandle,
                       CreateDisposition,
                       fExists);
    }

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);

    return status;
}

NTSTATUS
APIHOOK(NtOpenFile)(
    OUT PHANDLE            FileHandle,
    IN  ACCESS_MASK        DesiredAccess,
    IN  POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK   IoStatusBlock,
    IN  ULONG              ShareAccess,
    IN  ULONG              OpenOptions
    )
{
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH];
    NTSTATUS                    status;
    BOOL                        fConverted;
    CLock                       cLock(g_csCritSec);

    RtlInitUnicodeStringBuffer(&DosPathBuffer, PathBuffer, sizeof(PathBuffer));

    fConverted = ConvertNtPathToDosPath(ObjectAttributes->ObjectName, &DosPathBuffer);

    if (!fConverted) {
        DPFN(eDbgLevelError,
             "[NtOpenFile] Failed to convert NT path: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    status = ORIGINAL_API(NtOpenFile)(FileHandle,
                                      DesiredAccess,
                                      ObjectAttributes,
                                      IoStatusBlock,
                                      ShareAccess,
                                      OpenOptions);

    //
    // Two conditions are required before we add this handle to the list.
    // 1. We must have been able to convert the NT path to a DOS path.
    //
    // 2. The call to NtOpenFile must have succeeded.
    //
    if (fConverted && NT_SUCCESS(status)) {
        UpdateFileList(eOpenedFile,
                       DosPathBuffer.String.Buffer,
                       *FileHandle,
                       OpenOptions,
                       TRUE);
    }

    RtlFreeUnicodeStringBuffer(&DosPathBuffer);

    return status;
}

NTSTATUS
APIHOOK(NtClose)(
    IN HANDLE Handle
    )
{
    CLock   cLock(g_csCritSec);

    RemoveHandleFromArray(Handle);

    return ORIGINAL_API(NtClose)(Handle);
}

NTSTATUS
APIHOOK(NtWriteFile)(
    IN  HANDLE           FileHandle,
    IN  HANDLE           Event OPTIONAL,
    IN  PIO_APC_ROUTINE  ApcRoutine OPTIONAL,
    IN  PVOID            ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN  PVOID            Buffer,
    IN  ULONG            Length,
    IN  PLARGE_INTEGER   ByteOffset OPTIONAL,
    IN  PULONG           Key OPTIONAL
    )
{
    NTSTATUS    status;
    CLock       cLock(g_csCritSec);

    status = ORIGINAL_API(NtWriteFile)(FileHandle,
                                       Event,
                                       ApcRoutine,
                                       ApcContext,
                                       IoStatusBlock,
                                       Buffer,
                                       Length,
                                       ByteOffset,
                                       Key);

    //
    // Handle the case in which the caller is using overlapped I/O.
    //
    if (STATUS_PENDING == status) {
        status = NtWaitForSingleObject(Event, FALSE, NULL);
    }

    //
    // If the call to NtWriteFile succeeded, update the list.
    //
    if (NT_SUCCESS(status)) {
        UpdateFileList(eModifiedFile,
                       NULL,
                       FileHandle,
                       0,
                       TRUE);
    }

    return status;
}

NTSTATUS
APIHOOK(NtWriteFileGather)(
    IN  HANDLE                FileHandle,
    IN  HANDLE                Event OPTIONAL,
    IN  PIO_APC_ROUTINE       ApcRoutine OPTIONAL,
    IN  PVOID                 ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK      IoStatusBlock,
    IN  PFILE_SEGMENT_ELEMENT SegmentArray,
    IN  ULONG                 Length,
    IN  PLARGE_INTEGER        ByteOffset OPTIONAL,
    IN  PULONG                Key OPTIONAL
    )
{
    NTSTATUS    status;
    CLock       cLock(g_csCritSec);

    status = ORIGINAL_API(NtWriteFileGather)(FileHandle,
                                             Event,
                                             ApcRoutine,
                                             ApcContext,
                                             IoStatusBlock,
                                             SegmentArray,
                                             Length,
                                             ByteOffset,
                                             Key);

    //
    // Handle the case in which the caller is using overlapped I/O.
    //
    if (STATUS_PENDING == status) {
        status = NtWaitForSingleObject(FileHandle, FALSE, NULL);
    }

    //
    // If the call to NtWriteFileGather succeeded, update the list.
    //
    if (NT_SUCCESS(status)) {
        UpdateFileList(eModifiedFile,
                       NULL,
                       FileHandle,
                       0,
                       TRUE);
    }

    return status;
}

NTSTATUS
APIHOOK(NtSetInformationFile)(
    IN  HANDLE                 FileHandle,
    OUT PIO_STATUS_BLOCK       IoStatusBlock,
    IN  PVOID                  FileInformation,
    IN  ULONG                  Length,
    IN  FILE_INFORMATION_CLASS FileInformationClass
    )
{
    NTSTATUS    status;
    CLock       cLock(g_csCritSec);

    status = ORIGINAL_API(NtSetInformationFile)(FileHandle,
                                                IoStatusBlock,
                                                FileInformation,
                                                Length,
                                                FileInformationClass);

    //
    // This API is called for a variety of reasons, but were only
    // interested in a couple different cases.
    //
    if (NT_SUCCESS(status)) {
        switch (FileInformationClass) {
        case FileAllocationInformation:
        case FileEndOfFileInformation:

                UpdateFileList(eModifiedFile,
                               NULL,
                               FileHandle,
                               0,
                               TRUE);
                break;

        case FileRenameInformation:
            {
                PFILE_RENAME_INFORMATION    pRenameInfo = NULL;
                UNICODE_STRING              ustrTemp;
                RTL_UNICODE_STRING_BUFFER   ubufDosPath;
                WCHAR*                      pwszPathBuffer = NULL;
                WCHAR*                      pwszTempBuffer = NULL;
                DWORD                       dwPathBufSize = 0;


                pRenameInfo = (PFILE_RENAME_INFORMATION)FileInformation;

                pwszTempBuffer = (WCHAR*)MemAlloc(pRenameInfo->FileNameLength + sizeof(WCHAR));

                //
                // allow for possible expansion when converting to DOS path
                //
                dwPathBufSize = pRenameInfo->FileNameLength + MAX_PATH;
                pwszPathBuffer = (WCHAR*)MemAlloc(dwPathBufSize);

                if (!pwszTempBuffer || !pwszPathBuffer) {
                    goto outRename;
                }

                //
                // copy the string into a local buffer and terminate it.
                //
                memcpy(pwszTempBuffer, pRenameInfo->FileName, pRenameInfo->FileNameLength);
                pwszTempBuffer[pRenameInfo->FileNameLength / 2] = 0;

                RtlInitUnicodeString(&ustrTemp, pwszTempBuffer);
                RtlInitUnicodeStringBuffer(&ubufDosPath, (PUCHAR)pwszPathBuffer, dwPathBufSize);

                //
                // Convert the path from DOS to NT, and if successful,
                // update the list.
                //
                if (!ConvertNtPathToDosPath(&ustrTemp, &ubufDosPath)) {
                    DPFN(eDbgLevelError,
                         "[NtSetInformationFile] Failed to convert NT path: %ls",
                         pRenameInfo->FileName);
                } else {
                    UpdateFileList(eRenamedFile,
                                   ubufDosPath.String.Buffer,
                                   FileHandle,
                                   0,
                                   TRUE);
                }
outRename:
                if (pwszTempBuffer) {
                    MemFree(pwszTempBuffer);
                }
                if (pwszPathBuffer) {
                    MemFree(pwszPathBuffer);
                }


                break;
            }

        case FileDispositionInformation:
            {
                PFILE_DISPOSITION_INFORMATION pDisposition = NULL;

                pDisposition = (PFILE_DISPOSITION_INFORMATION)FileInformation;

                //
                // Determine if the file is being deleted.
                // Note that we have to undefine DeleteFile.
                //
                #undef DeleteFile
                if (pDisposition) {
                    if (pDisposition->DeleteFile) {
                        UpdateFileList(eDeletedFile,
                                       NULL,
                                       FileHandle,
                                       0,
                                       TRUE);
                    }
                }
                break;
            }
        }
    }

    return status;
}

NTSTATUS
APIHOOK(NtDeleteFile)(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    RTL_UNICODE_STRING_BUFFER   DosPathBuffer;
    UCHAR                       PathBuffer[MAX_PATH];
    NTSTATUS                    status;
    BOOL                        fConverted;
    CLock                       cLock(g_csCritSec);

    RtlInitUnicodeStringBuffer(&DosPathBuffer, PathBuffer, sizeof(PathBuffer));

    fConverted = ConvertNtPathToDosPath(ObjectAttributes->ObjectName, &DosPathBuffer);

    if (!fConverted) {
        DPFN(eDbgLevelError,
             "[NtDeleteFile] Failed to convert NT path: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    status = ORIGINAL_API(NtDeleteFile)(ObjectAttributes);

    if (fConverted && NT_SUCCESS(status)) {
        UpdateFileList(eDeletedFile,
                       DosPathBuffer.String.Buffer,
                       NULL,
                       0,
                       TRUE);
    }

    return status;
}

//
// When this gets called on Win2K, it's safe to call
// SHGetFolderPath.
//
#ifdef SHIM_WIN2K
void
APIHOOK(GetStartupInfoA)(
    LPSTARTUPINFOA lpStartupInfo
    )
{
    GetProgramFilesDir();

    ORIGINAL_API(GetStartupInfoA)(lpStartupInfo);
}

void
APIHOOK(GetStartupInfoW)(
    LPSTARTUPINFOW lpStartupInfo
    )
{
    GetProgramFilesDir();

    ORIGINAL_API(GetStartupInfoW)(lpStartupInfo);
}
#endif // SHIM_WIN2K

/*++

 Controls our property page that is displayed in the Verifer.

--*/
INT_PTR CALLBACK
DlgOptions(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static LPCWSTR szExeName;

    switch (message) {
    case WM_INITDIALOG:

        //
        // find out what exe we're handling settings for
        //
        szExeName = ExeNameFromLParam(lParam);

        g_dwSettings = GetShimSettingDWORD(L"LogFileChanges", szExeName, L"LogSettings", 1);

        if (g_dwSettings & LFC_OPTION_ATTRIBUTES) {
            CheckDlgButton(hDlg, IDC_LFC_LOG_ATTRIBUTES, BST_CHECKED);
        }

        if (g_dwSettings & LFC_OPTION_UFW_WINDOWS) {
            CheckDlgButton(hDlg, IDC_LFC_UFW_WINDOWS, BST_CHECKED);
        }

        if (g_dwSettings & LFC_OPTION_UFW_PROGFILES) {
            CheckDlgButton(hDlg, IDC_LFC_UFW_PROGFILES, BST_CHECKED);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_LFC_BTN_DEFAULT:

            g_dwSettings = 0;
            g_dwSettings = LFC_OPTION_ATTRIBUTES;

            CheckDlgButton(hDlg, IDC_LFC_LOG_ATTRIBUTES, BST_CHECKED);
            CheckDlgButton(hDlg, IDC_LFC_UFW_WINDOWS, BST_UNCHECKED);
            CheckDlgButton(hDlg, IDC_LFC_UFW_PROGFILES, BST_UNCHECKED);

            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *) lParam)->code) {

        case PSN_APPLY:
            {
                UINT uState;

                g_dwSettings = 0;

                uState = IsDlgButtonChecked(hDlg, IDC_LFC_LOG_ATTRIBUTES);

                if (BST_CHECKED == uState) {
                    g_dwSettings = LFC_OPTION_ATTRIBUTES;
                }

                uState = IsDlgButtonChecked(hDlg, IDC_LFC_UFW_WINDOWS);

                if (BST_CHECKED == uState) {
                    g_dwSettings |= LFC_OPTION_UFW_WINDOWS;
                }

                uState = IsDlgButtonChecked(hDlg, IDC_LFC_UFW_PROGFILES);

                if (BST_CHECKED == uState) {
                    g_dwSettings |= LFC_OPTION_UFW_PROGFILES;
                }

                SaveShimSettingDWORD(L"LogFileChanges", szExeName, L"LogSettings", g_dwSettings);

            }
            break;
        }
        break;
    }

    return FALSE;
}

/*++

 Initialize the list head and the log file.

--*/
BOOL
InitializeShim(
    void
    )
{
    UINT    cchSize;

    //
    // Initialize our list head.
    //
    InitializeListHead(&g_OpenHandleListHead);

    //
    // Initialize this so we'll know when it's okay to
    // use it later on.
    //
    *g_wszProgramFilesDir = 0;

    //
    // Store the %windir% path for later use.
    //
    cchSize = GetWindowsDirectory(g_wszWindowsDir, ARRAYSIZE(g_wszWindowsDir));

    if (cchSize == 0 || cchSize > ARRAYSIZE(g_wszWindowsDir)) {
        DPFN(eDbgLevelError,
             "[InitializeShim] 0x%08X Failed to get windir path",
             GetLastError());
        *g_wszWindowsDir = 0;
    } else {
        _wcslwr(g_wszWindowsDir);
    }

    //
    // Get our settings and store them.
    //
    WCHAR szExe[100];

    GetCurrentExeName(szExe, 100);

    g_dwSettings = GetShimSettingDWORD(L"LogFileChanges", szExe, L"LogSettings", 1);

    //
    // Initialize our log file.
    //
    return InitializeLogFile();
}

/*++

 Handle process attach/detach notifications.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return InitializeShim();
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        return WriteListToLogFile();
    } else if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {
        GetProgramFilesDir();
    }

    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_LOGFILECHANGES_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_LOGFILECHANGES_FRIENDLY)
    SHIM_INFO_VERSION(1, 9)
    SHIM_INFO_INCLUDE_EXCLUDE("I:kernel32.dll E:rpcrt4.dll ntdll.dll")
    SHIM_INFO_OPTIONS_PAGE(IDD_LOGFILECHANGES_OPTIONS, DlgOptions)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_DEFAULT | AVRF_FLAG_EXTERNAL_ONLY)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_LOGLOC,
                            AVS_LOGFILECHANGES_LOGLOC,
                            AVS_LOGFILECHANGES_LOGLOC_R,
                            AVS_LOGFILECHANGES_LOGLOC_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_LOGFILECHANGES_UFW,
                            AVS_LOGFILECHANGES_UFW,
                            AVS_LOGFILECHANGES_UFW_R,
                            AVS_LOGFILECHANGES_UFW_URL)

    APIHOOK_ENTRY(NTDLL.DLL,                        NtCreateFile)
    APIHOOK_ENTRY(NTDLL.DLL,                          NtOpenFile)
    APIHOOK_ENTRY(NTDLL.DLL,                         NtWriteFile)
    APIHOOK_ENTRY(NTDLL.DLL,                   NtWriteFileGather)
    APIHOOK_ENTRY(NTDLL.DLL,                NtSetInformationFile)
    APIHOOK_ENTRY(NTDLL.DLL,                             NtClose)
    APIHOOK_ENTRY(NTDLL.DLL,                        NtDeleteFile)

#ifdef SHIM_WIN2K
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetStartupInfoA)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetStartupInfoW)
#endif // SHIM_WIN2K

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\logregistrychanges.h ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   LogRegistryChanges.h

 Abstract:

   This AppVerifier shim hooks all the registry APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created

--*/
#ifndef __APPVERIFIER_LOGREGISTRYCHANGES_H_
#define __APPVERIFIER_LOGREGISTRYCHANGES_H_

#include "precomp.h"

//
// Length (in characters) of our initial buffer for logging data.
//
#define TEMP_BUFFER_SIZE 1024

//
// Length (in characters) of the longest value name we expect.
//
#define MAX_VALUENAME_SIZE 260

//
// Length (in characters) of any empty element used for key modifications.
//
#define KEY_ELEMENT_SIZE 64

//
// Length (in characters) of an empty element used for value modifications.
//
#define VALUE_ELEMENT_SIZE 640

//
// Length (in characters) of a predefined key handle.
//
#define MAX_ROOT_LENGTH 22

//
// Length (in characters) of the longest data type (i.e., REG_EXPAND_SZ)
//
#define MAX_DATA_TYPE_LENGTH 14

//
// Length (in characters) of the longest operation type (i.e., ReplaceKey)
//
#define MAX_OPERATION_LENGTH 11

//
// Count of predefined key handles that we refer to.
//
#define NUM_PREDEFINED_HANDLES 7

//
// Delta for memory allocations.
//
#define BUFFER_ALLOCATION_DELTA 1024

//
// Macros for memory allocation/deallocation.
//
#define MemAlloc(s)     RtlAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (s))
#define MemReAlloc(b,s) RtlReAllocateHeap(RtlProcessHeap(), HEAP_ZERO_MEMORY, (b), (s))
#define MemFree(b)      RtlFreeHeap(RtlProcessHeap(), 0, (b))

//
// Macro that returns TRUE if the given registry handle is predefined.
//
#define IsPredefinedRegistryHandle( h )                                     \
    ((  ( h == HKEY_CLASSES_ROOT        )                                   \
    ||  ( h == HKEY_CURRENT_USER        )                                   \
    ||  ( h == HKEY_LOCAL_MACHINE       )                                   \
    ||  ( h == HKEY_USERS               )                                   \
    ||  ( h == HKEY_CURRENT_CONFIG      )                                   \
    ||  ( h == HKEY_PERFORMANCE_DATA    )                                   \
    ||  ( h == HKEY_DYN_DATA            ))                                  \
    ?   TRUE                                                                \
    :   FALSE )

//
// A doubly linked list of all the values associated with a particular key path.
//
typedef struct _KEY_DATA {
    LIST_ENTRY  Entry;
    DWORD       dwFlags;                            // flags that relate to the state of the value
    DWORD       dwOriginalValueType;                // value type of original key data
    DWORD       dwFinalValueType;                   // value type of final key data
    WCHAR       wszValueName[MAX_VALUENAME_SIZE];   // value name
    PVOID       pOriginalData;                      // original key data (stored on the heap)
    PVOID       pFinalData;                         // final key data (stored on the heap)
    DWORD       cbOriginalDataSize;                 // original key data buffer size (in bytes)
    DWORD       cbFinalDataSize;                    // final key data buffer size (in bytes)
} KEY_DATA, *PKEY_DATA;

//
// Maximum number of key handles we can track for a single registry path.
//
#define MAX_NUM_HANDLES 64

//
// We keep a doubly linked list of keys currently open so we know how to
// resolve a key handle to a full key path.
//
typedef struct _LOG_OPEN_KEY {
    LIST_ENTRY  Entry;
    LIST_ENTRY  KeyData;                    // points to the data (if any) associated with this key
    HKEY        hKeyBase[MAX_NUM_HANDLES];  // array of key handles
    HKEY        hKeyRoot;                   // handle to predefined key
    DWORD       dwFlags;                    // flags that relate to the state of the key
    LPWSTR      pwszFullKeyPath;            // HKEY_LOCAL_MACHINE\Software\Microsoft\Windows...
    LPWSTR      pwszSubKeyPath;             // Software\Microsoft\Windows...
    UINT        cHandles;                   // number of handles open for this key path
} LOG_OPEN_KEY, *PLOG_OPEN_KEY;

//
// Flags that indicate what state the key is in.
//
#define LRC_EXISTING_KEY    0x00000001
#define LRC_DELETED_KEY     0x00000002
//
// Flags that indicate what state the value is in.
//
#define LRC_EXISTING_VALUE  0x00000001
#define LRC_DELETED_VALUE   0x00000002
#define LRC_MODIFIED_VALUE  0x00000004

//
// Enumeration for updating the key information.
//
typedef enum {
    eAddKeyHandle = 0,
    eRemoveKeyHandle,
    eDeletedKey,
    eStartModifyValue,
    eEndModifyValue,
    eStartDeleteValue,
    eEndDeleteValue
} UpdateType;

//
// The reg class that does all the real work.
//
class CLogRegistry {

public:

    LONG CreateKeyExA(
        HKEY                  hKey,
        LPCSTR                pszSubKey,
        DWORD                 Reserved,
        LPSTR                 pszClass,
        DWORD                 dwOptions,
        REGSAM                samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY                 phkResult,
        LPDWORD               lpdwDisposition
        );

    LONG CreateKeyExW(
        HKEY                  hKey,
        LPCWSTR               pwszSubKey,
        DWORD                 Reserved,
        LPWSTR                pwszClass,
        DWORD                 dwOptions,
        REGSAM                samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY                 phkResult,
        LPDWORD               lpdwDisposition
        );

    LONG OpenKeyExA(
        HKEY   hKey,
        LPCSTR pszSubKey,
        DWORD  ulOptions,
        REGSAM samDesired,
        PHKEY  phkResult
        );

    LONG OpenKeyExW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        DWORD   ulOptions,
        REGSAM  samDesired,
        PHKEY   phkResult
        );

    LONG OpenCurrentUser(
        REGSAM samDesired,
        PHKEY  phkResult
        );

    LONG OpenUserClassesRoot(
        HANDLE hToken,
        DWORD  dwOptions,
        REGSAM samDesired,
        PHKEY  phkResult
        );

    LONG SetValueA(
        HKEY   hKey,
        LPCSTR pszSubKey,
        DWORD  dwType,
        LPCSTR pszData,
        DWORD  cbData
        );

    LONG SetValueW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        DWORD   dwType,
        LPCWSTR lpData,
        DWORD   cbData
        );

    LONG SetValueExA(
        HKEY        hKey,
        LPCSTR      pszValueName,
        DWORD       Reserved,
        DWORD       dwType,
        CONST BYTE* lpData,
        DWORD       cbData
        );

    LONG SetValueExW(
        HKEY        hKey,
        LPCWSTR     pwszValueName,
        DWORD       Reserved,
        DWORD       dwType,
        CONST BYTE* lpData,
        DWORD       cbData
        );

    LONG CloseKey(
        HKEY hKey
        );

    LONG DeleteKeyA(
        HKEY   hKey,
        LPCSTR pszSubKey
        );

    LONG DeleteKeyW(
        HKEY    hKey,
        LPCWSTR pwszSubKey
        );

    LONG DeleteValueA(
        HKEY    hKey,
        LPCSTR  pszValueName
        );

    LONG DeleteValueW(
        HKEY    hKey,
        LPCWSTR pwszValueName
        );

private:
    BOOL GetOriginalDataForKey(
        IN PLOG_OPEN_KEY pLogOpenKey,
        IN PKEY_DATA     pKeyData,
        IN LPCWSTR       pwszValueName
        );

    BOOL GetFinalDataForKey(
        IN PLOG_OPEN_KEY pLogOpenKey,
        IN PKEY_DATA     pKeyData,
        IN LPCWSTR       pwszValueName
        );

    PLOG_OPEN_KEY AddSpecialKeyHandleToList(
        IN HKEY hKeyRoot,
        IN HKEY hKeyNew
        );

    PKEY_DATA AddValueNameToList(
        IN PLOG_OPEN_KEY pLogOpenKey,
        IN LPCWSTR       pwszValueName
        );

    HKEY ForceSubKeyIntoList(
        IN  HKEY    hKeyPredefined,
        IN  LPCWSTR pwszSubKey
        );

    PKEY_DATA FindValueNameInList(
        IN LPCWSTR       pwszValueName,
        IN PLOG_OPEN_KEY pOpenKey
        );

    PLOG_OPEN_KEY FindKeyPathInList(
        IN LPCWSTR pwszKeyPath
        );

    PLOG_OPEN_KEY RemoveKeyHandleFromArray(
        IN HKEY hKey
        );

    PLOG_OPEN_KEY FindKeyHandleInArray(
        IN HKEY hKey
        );

    PLOG_OPEN_KEY AddKeyHandleToList(
        IN HKEY    hKey,
        IN HKEY    hKeyNew,
        IN LPCWSTR pwszSubKeyPath,
        IN BOOL    fExisting
        );

    PLOG_OPEN_KEY UpdateKeyList(
        IN HKEY       hKeyRoot,
        IN HKEY       hKeyNew,
        IN LPCWSTR    pwszSubKey,
        IN LPCWSTR    pwszValueName,
        IN BOOL       fExisting,
        IN UpdateType eType
        );
};

//
// On Windows 2000, we need to pre-allocate the event
// in RTL_CRITICAL_SECTION. On XP and above, this is
// a no-op.
//
#define PREALLOCATE_EVENT_MASK  0x80000000

//
// Critical section wrapper class.
//
class CCriticalSection
{
private:
    CRITICAL_SECTION m_CritSec;

public:
    CCriticalSection()
    {
        InitializeCriticalSectionAndSpinCount(&m_CritSec,
                                              PREALLOCATE_EVENT_MASK | 4000);
    }

    ~CCriticalSection()
    {
        DeleteCriticalSection(&m_CritSec);
    }

    void Lock()
    {
        EnterCriticalSection(&m_CritSec);
    }

    BOOL TryLock()
    {
        return TryEnterCriticalSection(&m_CritSec);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_CritSec);
    }
};


//
// Auto-lock class that uses the CCriticalSection class.
//
class CLock
{
private:
    CCriticalSection &m_CriticalSection;

public:
    CLock(CCriticalSection &CriticalSection)
        : m_CriticalSection(CriticalSection)
    {
        m_CriticalSection.Lock();
    }

    ~CLock()
    {
        m_CriticalSection.Unlock();
    }
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegOpenCurrentUser)
    APIHOOK_ENUM_ENTRY(RegOpenUserClassesRoot)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyA)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)
    APIHOOK_ENUM_ENTRY(RegDeleteValueA)
    APIHOOK_ENUM_ENTRY(RegDeleteValueW)

    APIHOOK_ENUM_ENTRY(WriteProfileStringA)
    APIHOOK_ENUM_ENTRY(WriteProfileStringW)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionA)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionW)

APIHOOK_ENUM_END

#endif // __APPVERIFIER_LOGREGISTRYCHANGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\logregistrychanges.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   LogRegistryChanges.cpp

 Abstract:

   This AppVerifier shim hooks all the registry APIs
   that change the state of the system and logs their
   associated data to a text file.

 Notes:

   This is a general purpose shim.

 History:

   08/17/2001   rparsons    Created
   09/20/2001   rparsons    File I/O operations use NT APIs
   09/23/2001   rparsons    VLOG with log file location
   10/06/2001   rparsons    Open key handles are never removed from the list
   02/20/2002   rparsons    Implemented strsafe functions

--*/
#include "precomp.h"
#include "rtlutils.h"

IMPLEMENT_SHIM_BEGIN(LogRegistryChanges)
#include "ShimHookMacro.h"
#include "ShimCString.h"
#include "LogRegistryChanges.h"

BEGIN_DEFINE_VERIFIER_LOG(LogRegistryChanges)
    VERIFIER_LOG_ENTRY(VLOG_LOGREGCHANGES_LOGLOC)
END_DEFINE_VERIFIER_LOG(LogRegistryChanges)

INIT_VERIFIER_LOG(LogRegistryChanges);

//
// Stores the NT path to the file system log file for the current session.
//
UNICODE_STRING g_strLogFilePath;

//
// Stores the DOS path to the file system log file for the current session.
//
WCHAR g_wszLogFilePath[MAX_PATH];

//
// Head of our open key handle linked list.
//
LIST_ENTRY g_OpenKeyListHead;

//
// Temporary buffer stored on the heap.
// Used when creating XML elements to log.
// This doesn't get freed.
//
LPWSTR g_pwszTempBuffer;

//
// Size of the temporary buffer above.
//
DWORD g_cbTempBufferSize;

//
// Stores the unique id used for NULL value names.
//
WCHAR g_wszUniqueId[MAX_PATH * 2];

//
// Temporary buffers stored on the heap.
// Used when extracting old & new data for logging.
// These don't get freed.
//
LPWSTR g_pwszOriginalData;
LPWSTR g_pwszFinalData;

//
// Size of the temporary buffers above.
//
DWORD g_cbOriginalDataBufferSize;
DWORD g_cbFinalDataBufferSize;

//
// Critical section that keeps us safe while using linked-lists, etc.
//
CCriticalSection g_csCritSec;

/*++

 Writes an entry to the log file.

--*/
void
WriteEntryToLog(
    IN LPCWSTR pwszEntry
    )
{
    int                 cbSize;
    HANDLE              hFile;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    LARGE_INTEGER       liOffset;
    NTSTATUS            status;

    //
    // Note that we have to use native APIs throughout this function
    // to avoid a problem with circular hooking. That is, if we simply
    // call WriteFile, which is exported from kernel32, it will call NtWriteFile,
    // which is a call that we hook, in turn leaving us in and endless loop.
    //

    //
    // Attempt to get a handle to our log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &g_strLogFilePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          FILE_APPEND_DATA | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          0,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_OPEN,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[WriteEntryToLog] 0x%X Failed to open log",
             status);
        return;
    }

    //
    // Write the data out to the file.
    //
    cbSize = wcslen(pwszEntry);
    cbSize *= sizeof(WCHAR);

    IoStatusBlock.Status = 0;
    IoStatusBlock.Information = 0;

    liOffset.LowPart  = 0;
    liOffset.HighPart = 0;

    status = NtWriteFile(hFile,
                         NULL,
                         NULL,
                         NULL,
                         &IoStatusBlock,
                         (PVOID)pwszEntry,
                         (ULONG)cbSize,
                         &liOffset,
                         NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[WriteEntryToLog] 0x%X Failed to make entry",
             status);
        goto exit;
    }

exit:

    NtClose(hFile);

}

/*++

 Creates our XML file to store our results in.

--*/
BOOL
InitializeLogFile(
    void
    )
{
    BOOL                bReturn = FALSE;
    BOOL                bStatus = FALSE;
    HANDLE              hFile;
    DWORD               cchSize;
    WCHAR*              pwchSlash = NULL;
    WCHAR*              pwchDot = NULL;
    WCHAR               wszLogFilePath[MAX_PATH];
    WCHAR               wszModPathName[MAX_PATH];
    WCHAR               wszLogFile[MAX_PATH / 2];
    WCHAR               wszShortName[MAX_PATH / 2];
    WCHAR               wszLogHdr[512];
    WCHAR               wchUnicodeHdr = 0xFEFF;
    HRESULT             hr;
    NTSTATUS            status;
    SYSTEMTIME          st;
    UNICODE_STRING      strLogFile;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;

    //
    // Format the log header.
    //
    cchSize = GetModuleFileName(NULL, wszModPathName, ARRAYSIZE(wszModPathName));

    if (cchSize > ARRAYSIZE(wszModPathName) || cchSize == 0) {
        StringCchCopy(wszModPathName, ARRAYSIZE(wszModPathName), L"unknown");
    }

    hr = StringCchPrintf(wszLogHdr,
                         ARRAYSIZE(wszLogHdr),
                         L"%lc<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n<APPLICATION NAME=\"%ls\">\r\n",
                         wchUnicodeHdr,
                         wszModPathName);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to format log header",
             HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // Get the path where log files are stored.
    //
    cchSize = GetAppVerifierLogPath(wszLogFilePath, ARRAYSIZE(wszLogFilePath));

    if (cchSize > ARRAYSIZE(wszLogFilePath) || cchSize == 0) {
        DPFN(eDbgLevelError, "[InitializeLogFile] Failed to get log path");
        return FALSE;
    }

    //
    // See if the directory exists - but don't try to create it.
    //
    if (GetFileAttributes(wszLogFilePath) == -1) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] Log file directory '%ls' does not exist",
             wszLogFilePath);
        return FALSE;
    }

    //
    // Set up the log filename.
    // The format is this: processname_registry_yyyymmdd_hhmmss.xml
    //
    GetLocalTime(&st);

    *wszShortName = 0;
    pwchDot = wcsrchr(wszModPathName, '.');

    if (pwchDot) {
        *pwchDot = 0;
    }

    pwchSlash = wcsrchr(wszModPathName, '\\');

    if (pwchSlash) {
        StringCchCopy(wszShortName, ARRAYSIZE(wszShortName), ++pwchSlash);
    }

    hr = StringCchPrintf(wszLogFile,
                         ARRAYSIZE(wszLogFile),
                         L"%ls_registry_%02hu%02hu%02hu_%02hu%02hu%02hu.xml",
                         wszShortName,
                         st.wYear,
                         st.wMonth,
                         st.wDay,
                         st.wHour,
                         st.wMinute,
                         st.wSecond);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to format log filename",
             HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // See if the file already exists.
    //
    SetCurrentDirectory(wszLogFilePath);

    if (GetFileAttributes(wszLogFile) != -1) {
        //
        // Reformat the filename.
        //
        hr = StringCchPrintf(wszLogFile,
                         ARRAYSIZE(wszLogFile),
                         L"%ls_registry_%02hu%02hu%02hu_%02hu%02hu%02hu_%lu.xml",
                         wszShortName,
                         st.wYear,
                         st.wMonth,
                         st.wDay,
                         st.wHour,
                         st.wMinute,
                         st.wSecond,
                         GetTickCount());

        if (FAILED(hr)) {
            DPFN(eDbgLevelError,
                 "[InitializeLogFile] 0x%08X Failed to reformat log filename",
                 HRESULT_CODE(hr));
            return FALSE;
        }
    }

    StringCchCat(wszLogFilePath, ARRAYSIZE(wszLogFilePath), L"\\");
    hr = StringCchCat(wszLogFilePath, ARRAYSIZE(wszLogFilePath), wszLogFile);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to format path to log",
             HRESULT_CODE(hr));
        return FALSE;
    }

    //
    // Preserve this path for later use.
    //
    hr = StringCchCopy(g_wszLogFilePath,
                       ARRAYSIZE(g_wszLogFilePath),
                       wszLogFilePath);

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%08X Failed to save path to log",
             HRESULT_CODE(hr));
        return FALSE;
    }

    bStatus = RtlDosPathNameToNtPathName_U(wszLogFilePath,
                                           &strLogFile,
                                           NULL,
                                           NULL);

    if (!bStatus) {
        DPFN(eDbgLevelError, "[InitializeLogFile] DOS path --> NT path failed");
        return FALSE;
    }

    //
    // Create the log file.
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &strLogFile,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = NtCreateFile(&hFile,
                          GENERIC_WRITE | SYNCHRONIZE,
                          &ObjectAttributes,
                          &IoStatusBlock,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          0,
                          FILE_CREATE,
                          FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                          NULL,
                          0);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%X Failed to create log",
             status);
        goto cleanup;
    }

    NtClose(hFile);

    //
    // Preserve the NT path for later use.
    //
    status = ShimDuplicateUnicodeString(RTL_DUPLICATE_UNICODE_STRING_NULL_TERMINATE |
                                        RTL_DUPLICATE_UNICODE_STRING_ALLOCATE_NULL_STRING,
                                        &strLogFile,
                                        &g_strLogFilePath);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[InitializeLogFile] 0x%X Failed to save log file path",
             status);
        goto cleanup;
    }

    //
    // Write the header to the log.
    //
    WriteEntryToLog(wszLogHdr);

    bReturn = TRUE;

cleanup:

    if (bStatus) {
        RtlFreeUnicodeString(&strLogFile);
    }

    return bReturn;
}

/*++

 Writes the closing element to the file and outputs the log file location.

--*/
BOOL
CloseLogFile(
    void
    )
{
    WCHAR   wszBuffer[] = L"</APPLICATION>";

    WriteEntryToLog(wszBuffer);

    VLOG(VLOG_LEVEL_INFO, VLOG_LOGREGCHANGES_LOGLOC, "%ls", g_wszLogFilePath);

    return TRUE;
}

/*++

 Converts from ANSI to Unicode. The caller must free the buffer.

--*/
BOOL
ConvertAnsiToUnicode(
    IN  LPCSTR  pszAnsiString,
    OUT LPWSTR* pwszUnicodeString
    )
{
    int cchSize = 0;

    cchSize = lstrlenA(pszAnsiString);

    if (cchSize) {
        *pwszUnicodeString = (LPWSTR)MemAlloc(++cchSize * sizeof(WCHAR));

        if (!*pwszUnicodeString) {
            DPFN(eDbgLevelError,
                 "[ConvertAnsiToUnicode] Failed to allocate memory");
            return FALSE;
        }

        cchSize = MultiByteToWideChar(CP_ACP,
                                      0,
                                      pszAnsiString,
                                      -1,
                                      *pwszUnicodeString,
                                      cchSize);

        if (cchSize == 0) {
            DPFN(eDbgLevelError,
                 "[ConvertAnsiToUnicode] 0x%08X Ansi -> Unicode failed",
                 GetLastError());
            MemFree(*pwszUnicodeString);
            return FALSE;
        }
    }

    return TRUE;
}

/*++

 Converts a list of NULL terminated strings from ANSI to Unicode.
 The caller must free the buffer.

--*/
BOOL
ConvertMultiSzToUnicode(
    IN  LPCSTR  pszAnsiStringList,
    OUT LPWSTR* pwszWideStringList
    )
{
    int     nLen = 0;
    UINT    cchSize = 0;
    UINT    cchWideSize = 0;
    UINT    cchTotalSize = 0;
    LPCSTR  pszAnsi = NULL;
    LPWSTR  pwszTemp = NULL;

    if (!pszAnsiStringList) {
        DPFN(eDbgLevelError, "[ConvertMultiSzToUnicode] Invalid parameter");
        return FALSE;
    }

    pszAnsi = pszAnsiStringList;

    //
    // Determine how large of a buffer we need to allocate.
    //
    do {
        cchSize = lstrlenA(pszAnsi) + 1;
        cchTotalSize += cchSize;
        pszAnsi += cchSize;
    } while (cchSize != 1);

    if (cchTotalSize != 0) {
        pwszTemp = *pwszWideStringList = (LPWSTR)MemAlloc(cchTotalSize * sizeof(WCHAR));

        if (!*pwszWideStringList) {
            DPFN(eDbgLevelError,
                 "[ConvertMultiSzToUnicode] No memory for buffer");
            return FALSE;
        }
    }

    //
    // Perform the ANSI to Unicode conversion.
    //
    pszAnsi = pszAnsiStringList;

    do {
        nLen = lstrlenA(pszAnsi) + 1;

        cchWideSize = MultiByteToWideChar(
            CP_ACP,
            0,
            pszAnsi,
            -1,
            pwszTemp,
            nLen);

        pszAnsi  += nLen;
        pwszTemp += cchWideSize;
    } while (nLen != 1);

    return TRUE;
}

/*++

 Given a predefined key handle such as HKEY_LOCAL_MACHINE, return a string.

--*/
BOOL
PredefinedKeyToString(
    IN  HKEY    hKey,
    IN  DWORD   cchSize,
    OUT LPWSTR* pwszString
    )
{
    if (hKey == HKEY_CLASSES_ROOT) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_CLASSES_ROOT");
    }
    else if (hKey == HKEY_CURRENT_CONFIG) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_CURRENT_CONFIG");
    }
    else if (hKey == HKEY_CURRENT_USER) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_CURRENT_USER");
    }
    else if (hKey == HKEY_LOCAL_MACHINE) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_LOCAL_MACHINE");
    }
    else if (hKey == HKEY_USERS) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_USERS");
    }
    else if (hKey == HKEY_DYN_DATA) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_DYN_DATA");
    }
    else if (hKey == HKEY_PERFORMANCE_DATA) {
        StringCchCopy(*pwszString, cchSize, L"HKEY_PERFORMANCE_DATA");
    }
    else {
        StringCchCopy(*pwszString, cchSize, L"Not recognized");
        return FALSE;
    }

    return TRUE;
}

/*++

 Displays the name associated with this object.

--*/
#if DBG
void
PrintNameFromKey(
    IN HKEY hKey
    )
{
    NTSTATUS                    status;
    WCHAR                       wszBuffer[MAX_PATH];
    OBJECT_NAME_INFORMATION*    poni = NULL;

    *wszBuffer = 0;

    poni = (OBJECT_NAME_INFORMATION*)wszBuffer;

    status = NtQueryObject(hKey, ObjectNameInformation, poni, MAX_PATH, NULL);

    if (NT_SUCCESS(status)) {
        DPFN(eDbgLevelInfo,
             "Key 0x%08X has name: %ls",
             hKey,
             poni->Name.Buffer);
    }
}
#endif // DBG

/*++

 Given a pointer to a key node, get the original data.

--*/
BOOL
CLogRegistry::GetOriginalDataForKey(
    IN PLOG_OPEN_KEY pLogOpenKey,
    IN PKEY_DATA     pKeyData,
    IN LPCWSTR       pwszValueName
    )
{
    BOOL    fReturn = FALSE;
    HKEY    hKeyLocal;
    DWORD   cbSize = 0, dwType = 0;
    LONG    lRetVal;

    if (!pLogOpenKey || !pKeyData) {
        DPFN(eDbgLevelError, "[GetOriginalDataForKey] Invalid parameter(s)");
        return FALSE;
    }

    lRetVal = RegOpenKeyEx(pLogOpenKey->hKeyRoot,
                           pLogOpenKey->pwszSubKeyPath,
                           0,
                           KEY_QUERY_VALUE,
                           &hKeyLocal);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetOriginalDataForKey] Failed to open key");
        return FALSE;
    }

    //
    // Query the size of the data. If the data doesn't exist, return success.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              &dwType,
                              NULL,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        if (ERROR_FILE_NOT_FOUND == lRetVal) {
            RegCloseKey(hKeyLocal);
            return TRUE;
        } else {
            DPFN(eDbgLevelError, "[GetOldDataForKey] Failed to get data size");
            goto cleanup;
        }
    }

    //
    // Update the flags to indicate that the value already exists.
    //
    pKeyData->dwFlags |= LRC_EXISTING_VALUE;

    //
    // Allocate a buffer large enough to store the old data.
    //
    if (dwType != REG_DWORD && dwType != REG_BINARY) {
        pKeyData->pOriginalData = (PVOID)MemAlloc(cbSize * sizeof(WCHAR));
        pKeyData->cbOriginalDataSize = cbSize * sizeof(WCHAR);
    } else {
        pKeyData->pOriginalData = (PVOID)MemAlloc(cbSize);
        pKeyData->cbOriginalDataSize = cbSize;
    }

    if (!pKeyData->pOriginalData) {
        DPFN(eDbgLevelError,
             "[GetOriginalDataForKey] Failed to allocate memory");
        goto cleanup;
    }

    pKeyData->dwOriginalValueType = dwType;

    //
    // Now make the call again this time getting the actual data.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              0,
                              (LPBYTE)pKeyData->pOriginalData,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetOriginalDataForKey] Failed to get data");
        goto cleanup;
    }

    fReturn = TRUE;

cleanup:

    RegCloseKey(hKeyLocal);

    return fReturn;
}

/*++

 Given a pointer to a key node, get the final data.

--*/
BOOL
CLogRegistry::GetFinalDataForKey(
    IN PLOG_OPEN_KEY pLogOpenKey,
    IN PKEY_DATA     pKeyData,
    IN LPCWSTR       pwszValueName
    )
{
    BOOL    fReturn = FALSE;
    HKEY    hKeyLocal;
    DWORD   cbSize = 0, dwType = 0;
    LONG    lRetVal;
    PVOID   pTemp = NULL;

    if (!pLogOpenKey || !pKeyData) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Invalid parameter(s)");
        return FALSE;
    }

    lRetVal = RegOpenKeyEx(pLogOpenKey->hKeyRoot,
                           pLogOpenKey->pwszSubKeyPath,
                           0,
                           KEY_QUERY_VALUE,
                           &hKeyLocal);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Failed to open key");
        return FALSE;
    }

    //
    // Query the size of the data. If the data doesn't exist, return success.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              &dwType,
                              NULL,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        if (ERROR_FILE_NOT_FOUND == lRetVal) {
            RegCloseKey(hKeyLocal);
            return TRUE;
        } else {
            DPFN(eDbgLevelError,
                 "[GetFinalDataForKey] Failed to get data size");
            goto cleanup;
        }
    }

    //
    // It's possible that multiple queries were issued against the same
    // key. If this is the case, the buffer to hold the data has already
    // been allocated. Determine if the block is large enough.
    //
    if (pKeyData->pFinalData) {
        if (dwType != REG_DWORD && dwType != REG_BINARY) {
            //
            // If MemReAlloc fails, we would lose the pointer that
            // we already had in pKeyData->pFinalData. This preserves
            // the pointer.
            //
            if (pKeyData->cbFinalDataSize < (cbSize * sizeof(WCHAR))) {
                pKeyData->cbFinalDataSize = cbSize * sizeof(WCHAR);
                pTemp = MemReAlloc(pKeyData->pFinalData,
                                   cbSize * sizeof(WCHAR));
            }
        } else {
            if (pKeyData->cbFinalDataSize < cbSize) {
                pKeyData->cbFinalDataSize = cbSize;
                pTemp = MemReAlloc(pKeyData->pFinalData,
                                   cbSize);
            }
        }

        if (pTemp) {
            pKeyData->pFinalData = pTemp;
        } else {
            DPFN(eDbgLevelError,
                 "[GetFinalDataForKey] Failed to reallocate memory");
            goto cleanup;
        }

    } else {
        if (dwType != REG_DWORD && dwType != REG_BINARY) {
            pKeyData->pFinalData = MemAlloc(cbSize * sizeof(WCHAR));
            pKeyData->cbFinalDataSize = cbSize * sizeof(WCHAR);
        } else {
            pKeyData->pFinalData = MemAlloc(cbSize);
            pKeyData->cbFinalDataSize = cbSize;
        }
    }

    if (!pKeyData->pFinalData) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Failed to allocate memory");
        goto cleanup;
    }

    pKeyData->dwFinalValueType = dwType;

    //
    // Now make the call again this time getting the actual data.
    //
    lRetVal = RegQueryValueEx(hKeyLocal,
                              pwszValueName,
                              0,
                              0,
                              (LPBYTE)pKeyData->pFinalData,
                              &cbSize);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[GetFinalDataForKey] Failed to get data");
        goto cleanup;
    }

    fReturn = TRUE;

cleanup:

    RegCloseKey(hKeyLocal);

    return fReturn;
}

/*++

 Given a value name, attempt to find it in the list.
 This function may not always return a pointer.

--*/
PKEY_DATA
CLogRegistry::FindValueNameInList(
    IN LPCWSTR       pwszValueName,
    IN PLOG_OPEN_KEY pOpenKey
    )
{
    BOOL        fFound = FALSE;
    PLIST_ENTRY pHead = NULL;
    PLIST_ENTRY pNext = NULL;
    PKEY_DATA   pFindData = NULL;

    if (!pwszValueName || !pOpenKey) {
        DPFN(eDbgLevelError, "[FindValueNameInList] Invalid parameter(s)");
        return NULL;
    }

    pHead = &pOpenKey->KeyData;
    pNext = pHead->Flink;

    while (pNext != pHead) {
        pFindData = CONTAINING_RECORD(pNext, KEY_DATA, Entry);

        if (!_wcsicmp(pwszValueName, pFindData->wszValueName)) {
            fFound = TRUE;
            break;
        }

        pNext = pNext->Flink;
    }

    return (fFound ? pFindData : NULL);
}

/*++

 Given a key path, attempt to locate it in the list.
 This function may not always return a pointer.

--*/
PLOG_OPEN_KEY
CLogRegistry::FindKeyPathInList(
    IN LPCWSTR pwszKeyPath
    )
{
    BOOL            fFound = FALSE;
    PLIST_ENTRY     pCurrent = NULL;
    PLOG_OPEN_KEY   pFindKey = NULL;

    if (!pwszKeyPath) {
        DPFN(eDbgLevelError, "[FindKeyPathInList] Invalid parameter");
        return NULL;
    }

    //
    // Attempt to locate the entry in the list.
    //
    pCurrent = g_OpenKeyListHead.Flink;

    while (pCurrent != &g_OpenKeyListHead) {
        pFindKey = CONTAINING_RECORD(pCurrent, LOG_OPEN_KEY, Entry);

        if (pFindKey->pwszFullKeyPath) {
            if (!_wcsicmp(pwszKeyPath, pFindKey->pwszFullKeyPath)) {
                fFound = TRUE;
                break;
            }
        }

        pCurrent = pCurrent->Flink;
    }

    return (fFound ? pFindKey : NULL);
}

/*++

 Given a key handle, remove it from the array in the list.

--*/
PLOG_OPEN_KEY
CLogRegistry::RemoveKeyHandleFromArray(
    IN HKEY hKey
    )
{
    UINT            uCount;
    PLIST_ENTRY     pCurrent = NULL;
    PLOG_OPEN_KEY   pFindKey = NULL;

    if (!hKey) {
        DPFN(eDbgLevelError,
             "[RemoveKeyHandleFromArray] Invalid key handle passed!");
        return NULL;
    }

    pCurrent = g_OpenKeyListHead.Flink;

    while (pCurrent != &g_OpenKeyListHead) {
        pFindKey = CONTAINING_RECORD(pCurrent, LOG_OPEN_KEY, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindKey->cHandles; uCount++) {
            //
            // If we find the handle, set the array element to NULL and
            // decrement the count of handles for this entry.
            //
            if (pFindKey->hKeyBase[uCount] == hKey) {
                DPFN(eDbgLevelInfo,
                     "[RemoveKeyHandleFromArray] Removing handle 0x%08X",
                     hKey);
                pFindKey->hKeyBase[uCount] = NULL;
                pFindKey->cHandles--;
                return pFindKey;
            }
        }

        pCurrent = pCurrent->Flink;
    }

    return NULL;
}

/*++

 Finds a key handle in the array.

--*/
PLOG_OPEN_KEY
CLogRegistry::FindKeyHandleInArray(
    IN HKEY hKey
    )
{
    UINT            uCount;
    BOOL            fFound = FALSE;
    PLOG_OPEN_KEY   pFindKey = NULL;
    PLIST_ENTRY     pCurrent = NULL;

    if (!hKey) {
        DPFN(eDbgLevelError,
             "[FindKeyHandleInArray] Invalid key handle passed!");
        return NULL;
    }

    pCurrent = g_OpenKeyListHead.Flink;

    while (pCurrent != &g_OpenKeyListHead) {
        pFindKey = CONTAINING_RECORD(pCurrent, LOG_OPEN_KEY, Entry);

        //
        // Step through this guy's array looking for the handle.
        //
        for (uCount = 0; uCount < pFindKey->cHandles; uCount++) {
            if (pFindKey->hKeyBase[uCount] == hKey) {
                fFound = TRUE;
                break;
            }
        }

        if (fFound) {
            break;
        }

        pCurrent = pCurrent->Flink;
    }

#if DBG
    if (!fFound) {
        //
        // Dear God - the key handle is not in the list!
        // Break into the debugger on checked builds.
        //
        DPFN(eDbgLevelError,
             "[FindKeyHandleInArray] Key 0x%08X not in list!",
             hKey);
        PrintNameFromKey(hKey);
        DbgBreakPoint();
    }
#endif // DBG

    return (fFound ? pFindKey : NULL);
}

/*++

 Given a predefined handle and a subkey path,
 open the key to force it into the list.

--*/
HKEY
CLogRegistry::ForceSubKeyIntoList(
    IN HKEY    hKeyPredefined,
    IN LPCWSTR pwszSubKey
    )
{
    LONG    lRetVal;
    HKEY    hKeyRet;

    if (!pwszSubKey) {
        DPFN(eDbgLevelError, "[ForceSubKeyIntoList] Invalid parameter");
        return NULL;
    }

    lRetVal = OpenKeyExW(hKeyPredefined,
                         pwszSubKey,
                         0,
                         KEY_WRITE,
                         &hKeyRet);

    if (ERROR_SUCCESS != lRetVal) {
        DPFN(eDbgLevelError, "[ForceSubKeyIntoList] Failed to open key");
        return NULL;
    }

    return hKeyRet;
}

/*++

 Add a non-predefined key handle to the array.

--*/
PLOG_OPEN_KEY
CLogRegistry::AddKeyHandleToList(
    IN HKEY    hKey,
    IN HKEY    hKeyNew,
    IN LPCWSTR pwszSubKeyPath,
    IN BOOL    fExisting
    )
{
    UINT            uCount;
    DWORD           cchLen;
    PLOG_OPEN_KEY   pFindKey = NULL;
    PLOG_OPEN_KEY   pRetKey = NULL;
    PLOG_OPEN_KEY   pExistingFindKey = NULL;

    //
    // If hKeyNew, which is the key handle the caller received
    // from the function, is a predefined handle, we simply
    // call FindKeyInArray, which will return a pointer to the
    // list entry that contains that key handle. These handles
    // were added during initialization, so there's no chance
    // that the caller won't get a pointer back.
    //
    if (IsPredefinedRegistryHandle(hKeyNew)) {
        return FindKeyHandleInArray(hKeyNew);
    }

    //
    // We've got a usual case where a key has been opened, and
    // now the caller is opening a subkey underneath it.
    //
    pFindKey = FindKeyHandleInArray(hKey);

    //
    // If pFindKey ever comes back as NULL, something is really
    // wrong. Every OpenKey/CreateKey comes through us and goes
    // into the list (with the exception of predefined handles
    // which are already stored there.) Dump out as much data
    // as we can to figure out what went wrong.
    //
    if (!pFindKey) {
        DPFN(eDbgLevelError,
            "[AddKeyHandleToList] Key not found in list! Key Handle = 0x%08X  New key = 0x%08X  Path = %ls",
            hKey, hKeyNew, pwszSubKeyPath);
        return NULL;
    }

    pRetKey = (PLOG_OPEN_KEY)MemAlloc(sizeof(LOG_OPEN_KEY));

    if (!pRetKey) {
        DPFN(eDbgLevelError, "[AddKeyHandleToList] No memory available");
        return NULL;
    }

    //
    // Make room for the subkey path that will go into the new
    // node. If the node that we found has a subkey path stored,
    // take that into account also.
    //
    if (pwszSubKeyPath) {
        cchLen = wcslen(pwszSubKeyPath);
    }

    if (pFindKey->pwszSubKeyPath) {
        cchLen += wcslen(pFindKey->pwszSubKeyPath);
    }

    if (pFindKey->pwszSubKeyPath || pwszSubKeyPath) {
        cchLen += 2;
        pRetKey->pwszSubKeyPath = (LPWSTR)MemAlloc(cchLen * sizeof(WCHAR));

        if (!pRetKey->pwszSubKeyPath) {
            DPFN(eDbgLevelError, "[AddKeyHandleToList] No memory for subkey path");
            goto cleanup;
        }
    }

    //
    // If the node that we found has a subkey path, take it
    // and copy it over to the new node and concatenate
    // the subkey path that we got passed. Otherwise just
    // store the path that was passed, if available.
    //
    if (pFindKey->pwszSubKeyPath && pwszSubKeyPath) {
        StringCchCopy(pRetKey->pwszSubKeyPath, cchLen, pFindKey->pwszSubKeyPath);
        StringCchCat(pRetKey->pwszSubKeyPath, cchLen, L"\\");
        StringCchCat(pRetKey->pwszSubKeyPath, cchLen, pwszSubKeyPath);
    } else if (pwszSubKeyPath) {
        StringCchCopy(pRetKey->pwszSubKeyPath, cchLen, pwszSubKeyPath);
    }

    //
    // Make room for the full key path. This will store a path
    // of something like HKEY_LOCAL_MACHINE\Software\Microsoft...
    // that will be used for logging purposes.
    //
    if (pRetKey->pwszSubKeyPath) {
        cchLen = wcslen(pRetKey->pwszSubKeyPath);
    }

    cchLen += 2;
    cchLen += MAX_ROOT_LENGTH;
    pRetKey->pwszFullKeyPath = (LPWSTR)MemAlloc(cchLen * sizeof(WCHAR));

    if (!pRetKey->pwszFullKeyPath) {
        DPFN(eDbgLevelError,
            "[AddKeyHandleToList] No memory for full key path");
        goto cleanup;
    }

    //
    // Convert the predefined handle to a string and store it in
    // the node that we're about to add to the list.
    //
    if (!PredefinedKeyToString(pFindKey->hKeyRoot,
                               MAX_ROOT_LENGTH,
                               &pRetKey->pwszFullKeyPath)) {
        DPFN(eDbgLevelError,
             "[AddKeyHandleToList] PredefinedKey -> String failed");
        goto cleanup;
    }

    if (pwszSubKeyPath) {
        StringCchCat(pRetKey->pwszFullKeyPath, cchLen, L"\\");
        StringCchCat(pRetKey->pwszFullKeyPath, cchLen, pRetKey->pwszSubKeyPath);
    }

    //
    // At this point we have a full key path.
    // We attempt to find the path in the linked list.
    // If we find it, we're going to update the handle array and count for this guy.
    // If we don't find it, we're going to add a new entry to the list.
    //
    pExistingFindKey = FindKeyPathInList(pRetKey->pwszFullKeyPath);

    if (!pExistingFindKey) {
        //
        // Fill in information about this key and add it to the list.
        //
        pRetKey->hKeyBase[0]  = hKeyNew;
        pRetKey->hKeyRoot     = pFindKey->hKeyRoot;
        pRetKey->cHandles     = 1;
        pRetKey->dwFlags     |= fExisting ? LRC_EXISTING_KEY : 0;

        InitializeListHead(&pRetKey->KeyData);

        DPFN(eDbgLevelInfo, "[AddKeyHandleToList] Adding key: %p", pRetKey);

        InsertHeadList(&g_OpenKeyListHead, &pRetKey->Entry);

        return pRetKey;

    } else {
        //
        // Store this handle in the array and increment the handle count.
        // Make sure we don't overstep the array bounds.
        //
        for (uCount = 0; uCount < pExistingFindKey->cHandles; uCount++) {
            if (NULL == pExistingFindKey->hKeyBase[uCount]) {
                break;
            }
        }

        if (uCount >= MAX_NUM_HANDLES) {
            DPFN(eDbgLevelError, "[AddKeyHandleToList] Handle count reached");
            goto cleanup;
        }

        pExistingFindKey->hKeyBase[uCount] = hKeyNew;
        pExistingFindKey->dwFlags &= ~LRC_DELETED_KEY;
        pExistingFindKey->cHandles++;
    }

cleanup:

    if (pRetKey->pwszFullKeyPath) {
        MemFree(pRetKey->pwszFullKeyPath);
    }

    if (pRetKey) {
        MemFree(pRetKey);
    }

    return pExistingFindKey;
}

/*++

 Add a value to the list.

--*/
PKEY_DATA
CLogRegistry::AddValueNameToList(
    IN PLOG_OPEN_KEY pLogOpenKey,
    IN LPCWSTR       pwszValueName
    )
{
    PKEY_DATA   pKeyData = NULL;

    pKeyData = (PKEY_DATA)MemAlloc(sizeof(KEY_DATA));

    if (!pKeyData) {
        DPFN(eDbgLevelError, "[AddValueNameToList] Failed to allocate memory");
        return NULL;
    }

    if (!GetOriginalDataForKey(pLogOpenKey, pKeyData, pwszValueName)) {
        DPFN(eDbgLevelError,
             "[AddValueNameToList] Failed to get original data");
        goto cleanup;
    }

    if (pwszValueName) {
        StringCchCopy(pKeyData->wszValueName,
                      ARRAYSIZE(pKeyData->wszValueName),
                      pwszValueName);
    } else {
        //
        // If the valuename is NULL, assign our unique id.
        //
        StringCchCopy(pKeyData->wszValueName,
                      ARRAYSIZE(pKeyData->wszValueName),
                      g_wszUniqueId);
    }

    InsertHeadList(&pLogOpenKey->KeyData, &pKeyData->Entry);

    return pKeyData;

cleanup:

    if (pKeyData) {
        MemFree(pKeyData);
    }

    return NULL;
}

/*++

 The entry point for modifying the linked list data.

--*/
PLOG_OPEN_KEY
CLogRegistry::UpdateKeyList(
    IN HKEY       hKeyRoot,
    IN HKEY       hKeyNew,
    IN LPCWSTR    pwszSubKey,
    IN LPCWSTR    pwszValueName,
    IN BOOL       fExisting,
    IN UpdateType eType
    )
{
    PKEY_DATA       pKeyData = NULL;
    PLOG_OPEN_KEY   pRetKey = NULL;

    switch (eType) {
    case eAddKeyHandle:
        pRetKey = AddKeyHandleToList(hKeyRoot, hKeyNew, pwszSubKey, fExisting);
        break;

    case eRemoveKeyHandle:
        pRetKey = RemoveKeyHandleFromArray(hKeyNew);
        break;

    case eStartModifyValue:
    case eStartDeleteValue:
        pRetKey = FindKeyHandleInArray(hKeyNew);

        if (!pRetKey) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] Start Modify: Failed to find handle in array");
            break;
        }

        if (!pwszValueName) {
            pKeyData = FindValueNameInList(g_wszUniqueId, pRetKey);
        } else {
            pKeyData = FindValueNameInList(pwszValueName, pRetKey);
        }

        if (pKeyData) {
            //
            // If the caller is attempting to modify the value, and we've
            // already gotten data for it, don't do it again.
            // Also, if they're attempting to delete the value, and it's
            // been modified, don't do it again.
            //
            if ((pKeyData->pOriginalData || pKeyData->pFinalData) ||
                (pKeyData->dwFlags & LRC_MODIFIED_VALUE) &&
                (eStartDeleteValue == eType)) {
                break;
            }

            if (!GetOriginalDataForKey(pRetKey, pKeyData, pwszValueName)) {
                DPFN(eDbgLevelError,
                     "[UpdateKeyList] Start Modify: Failed to get original data");
                break;
            }
        } else {
            //
            // We've never seen this value before. Insert it into the list.
            //
            if (!AddValueNameToList(pRetKey, pwszValueName)) {
                DPFN(eDbgLevelError,
                     "[UpdateKeyList] Start Modify: Failed to insert value");
                break;
            }
        }

        break;

    case eEndModifyValue:
    case eEndDeleteValue:
        pRetKey = FindKeyHandleInArray(hKeyNew);

        if (!pRetKey) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] End Modify: Failed to find handle in array");
            break;
        }

        if (!pwszValueName) {
            pKeyData = FindValueNameInList(g_wszUniqueId, pRetKey);
        } else {
            pKeyData = FindValueNameInList(pwszValueName, pRetKey);
        }

        if (!pKeyData) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] End Modify: Failed to find value in list");
            break;
        }

        if (eEndModifyValue == eType) {
            if (!GetFinalDataForKey(pRetKey, pKeyData, pwszValueName)) {
                DPFN(eDbgLevelError,
                     "[UpdateKeyList] End Modify: Failed to get final data");
                break;
            }

            pKeyData->dwFlags |= LRC_MODIFIED_VALUE;
        }
        else if (eEndDeleteValue == eType) {
            pKeyData->dwFlags |= LRC_DELETED_VALUE;
        }

        break;

    case eDeletedKey:
        pRetKey = FindKeyHandleInArray(hKeyNew);

        if (!pRetKey) {
            DPFN(eDbgLevelError,
                 "[UpdateKeyList] DeleteKey: Failed to find handle in array");
            break;
        }

        pRetKey->dwFlags |= LRC_DELETED_KEY;

        break;

    default:
        DPFN(eDbgLevelError, "[UpdateKeyList] Invalid enum type!");
        break;
    }

    return pRetKey;
}

/*++

 Formats the data to form an XML element and logs it.

--*/
void
FormatKeyDataIntoElement(
    IN LPCWSTR       pwszOperation,
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    UINT    cbSize;
    PVOID   pTemp = NULL;
    HRESULT hr;

    if (!pLogOpenKey) {
        DPFN(eDbgLevelError, "[FormatKeyDataIntoElement] Invalid argument");
        return;
    }

    //
    // To make it easier to replace & ' " < and > with their
    // XML entities, we convert the data to CString.
    //
    CString csFullKeyPath(pLogOpenKey->pwszFullKeyPath);

    csFullKeyPath.Replace(L"&", L"&amp;");
    csFullKeyPath.Replace(L"<", L"&lt;");
    csFullKeyPath.Replace(L">", L"&gt;");
    csFullKeyPath.Replace(L"'", L"&apos;");
    csFullKeyPath.Replace(L"\"", L"&quot;");

    //
    // To keep allocations to a minimum, we allocate a global
    // buffer one time, then reallocate if the data we're
    // logging is larger than the buffer.
    //
    if (g_cbTempBufferSize == 0) {
        g_pwszTempBuffer = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszTempBuffer) {
            DPFN(eDbgLevelError,
                 "[FormatKeyDataIntoElement] Failed to allocate memory");
            return;
        }

        g_cbTempBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    *g_pwszTempBuffer = 0;

    //
    // Determine how large of a buffer we'll need.
    //
    cbSize = csFullKeyPath.GetLength();
    cbSize += MAX_OPERATION_LENGTH;
    cbSize += KEY_ELEMENT_SIZE;
    cbSize *= sizeof(WCHAR);

    if (cbSize > g_cbTempBufferSize) {
        //
        // Our global buffer is not large enough; reallocate.
        //
        pTemp = (LPWSTR)MemReAlloc(g_pwszTempBuffer,
                                   cbSize + BUFFER_ALLOCATION_DELTA);

        if (pTemp) {
            g_pwszTempBuffer = (LPWSTR)pTemp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatKeyDataIntoElement] Failed to reallocate memory");
            return;
        }

        g_cbTempBufferSize = cbSize + BUFFER_ALLOCATION_DELTA;
    }

    hr = StringCbPrintf(g_pwszTempBuffer,
                        g_cbTempBufferSize,
                        L"    <OPERATION TYPE=\"%ls\" KEY_PATH=\"%ls\"/>\r\n",
                        pwszOperation,
                        csFullKeyPath.Get());

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[FormatKeyDataIntoElement] 0x%08X Failed to format data",
             HRESULT_CODE(hr));
        return;
    }

    WriteEntryToLog(g_pwszTempBuffer);
}

void
FormatValueDataIntoElement(
    IN CString& csFullKeyPath,
    IN LPCWSTR  pwszOperation,
    IN LPCWSTR  pwszValueName,
    IN LPCWSTR  pwszOriginalValueType,
    IN LPCWSTR  pwszFinalValueType
    )
{
    UINT    cbSize;
    WCHAR*  pwszEnd = NULL;
    size_t  cbRemaining;
    PVOID   pTemp = NULL;
    HRESULT hr;

    //
    // To keep allocations to a minimum, we allocate a global
    // buffer one time, then reallocate if the data we're
    // logging is larger than the buffer.
    //
    if (!g_cbTempBufferSize) {
        g_pwszTempBuffer = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszTempBuffer) {
            DPFN(eDbgLevelError,
                 "[FormatValueDataIntoElement] Failed to allocate memory");
            return;
        }

        g_cbTempBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    //
    // Determine how large of a buffer we'll need.
    //
    cbSize = wcslen(pwszOperation);
    cbSize += wcslen(pwszOriginalValueType);
    cbSize += wcslen(pwszFinalValueType);
    cbSize += wcslen(g_pwszOriginalData);
    cbSize += wcslen(g_pwszFinalData);
    cbSize += csFullKeyPath.GetLength();
    cbSize += VALUE_ELEMENT_SIZE;

    if (pwszValueName) {
        cbSize += wcslen(pwszValueName);
    }

    cbSize *= sizeof(WCHAR);

    if (cbSize > g_cbTempBufferSize) {
        //
        // Our global buffer is not large enough; reallocate.
        //
        pTemp = (LPWSTR)MemReAlloc(g_pwszTempBuffer,
                                   cbSize + BUFFER_ALLOCATION_DELTA);

        if (pTemp) {
            g_pwszTempBuffer = (LPWSTR)pTemp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatValueDataIntoElement] Failed to reallocate memory");
            return;
        }

        g_cbTempBufferSize = cbSize + BUFFER_ALLOCATION_DELTA;
    }

    //
    // Open the <OPERATION> element.
    //
    hr = StringCbPrintfEx(g_pwszTempBuffer,
                          g_cbTempBufferSize,
                          &pwszEnd,
                          &cbRemaining,
                          0,
                          L"    <OPERATION TYPE=\"%ls\" KEY_PATH=\"%ls\">\r\n",
                          pwszOperation,
                          csFullKeyPath.Get());

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[FormatValueDataIntoElement] 0x%08X Failed to format OPERATION",
             HRESULT_CODE(hr));
        return;
    }

    //
    // Write the <VALUE_NAME> element.
    //
    if (pwszValueName) {
        hr = StringCbPrintfEx(pwszEnd,
                              cbRemaining,
                              &pwszEnd,
                              &cbRemaining,
                              0,
                              L"        <VALUE_NAME><![CDATA[%ls]]></VALUE_NAME>\r\n",
                              pwszValueName);
    } else {
        hr = StringCbPrintfEx(pwszEnd,
                              cbRemaining,
                              &pwszEnd,
                              &cbRemaining,
                              0,
                              L"        <VALUE_NAME/>\r\n");
    }

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[FormatValueDataIntoElement] 0x%08X Failed to format VALUE_NAME",
             HRESULT_CODE(hr));
        return;
    }

    //
    // Write the <ORIGINAL_DATA> element.
    //
    if (g_pwszOriginalData[0]) {
        hr = StringCbPrintfEx(pwszEnd,
                              cbRemaining,
                              &pwszEnd,
                              &cbRemaining,
                              0,
                              L"        <ORIGINAL_DATA TYPE=\"%ls\"><![CDATA[%ls]]></ORIGINAL_DATA>\r\n",
                              pwszOriginalValueType,
                              g_pwszOriginalData);
    } else {
        hr = StringCbPrintfEx(pwszEnd,
                              cbRemaining,
                              &pwszEnd,
                              &cbRemaining,
                              0,
                              L"        <ORIGINAL_DATA/>\r\n");
    }

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[FormatValueDataIntoElement] 0x%08X Failed to format ORIGINAL_DATA",
             HRESULT_CODE(hr));
        return;
    }

    //
    // Write the <FINAL_DATA> element.
    //
    if (g_pwszFinalData[0]) {
        hr = StringCbPrintfEx(pwszEnd,
                              cbRemaining,
                              &pwszEnd,
                              &cbRemaining,
                              0,
                              L"        <FINAL_DATA TYPE=\"%ls\"><![CDATA[%ls]]></FINAL_DATA>\r\n",
                              pwszFinalValueType,
                              g_pwszFinalData);
    } else {
        hr = StringCbPrintfEx(pwszEnd,
                              cbRemaining,
                              &pwszEnd,
                              &cbRemaining,
                              0,
                              L"        <FINAL_DATA/>\r\n");
    }

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[FormatValueDataIntoElement] 0x%08X Failed to format FINAL_DATA",
             HRESULT_CODE(hr));
        return;
    }

    //
    // Close the <OPERATION> element.
    //
    hr = StringCbPrintf(pwszEnd,
                        cbRemaining,
                        L"    </OPERATION>\r\n");

    if (FAILED(hr)) {
        DPFN(eDbgLevelError,
             "[FormatValueDataIntoElement] 0x%08X Failed to close OPERATION",
             HRESULT_CODE(hr));
        return;
    }

    WriteEntryToLog(g_pwszTempBuffer);
}

/*++

 Converts binary data into a readable string.

--*/
void
ExtractBinaryData(
    IN  PVOID   pBinary,
    IN  DWORD   cbDataSize,
    IN  DWORD   cbOutBufferSize,
    OUT LPWSTR* pwszString
    )
{
    size_t  cbRemaining;
    WCHAR*  pwszEnd = NULL;
    PBYTE   pByte = NULL;
    DWORD   dwLoop = 0;

    if (!pBinary || !pwszString) {
        DPFN(eDbgLevelError, "[ExtractBinaryData] Invalid parameter(s)");
        return;
    }

    //
    // Point to the data and determine how many times we need to loop.
    //
    pByte = (BYTE*)pBinary;
    dwLoop = cbDataSize / sizeof(WCHAR);

    //
    // Initialize the count of characters remaining and the pointer
    // to our destination string. This has to occur outside of the
    // loop.
    //
    cbRemaining = cbOutBufferSize;
    pwszEnd     = *pwszString;

    while (dwLoop) {
        StringCbPrintfEx(pwszEnd,
                         cbRemaining,
                         &pwszEnd,
                         &cbRemaining,
                         0,
                         L"%lx",
                         *pByte++);
        dwLoop--;
    }
}

/*++

 Converts a REG_MULTI_SZ to a readable string.

--*/
void
ExtractMultiSzStrings(
    IN  PVOID   pMultiSz,
    IN  DWORD   cbOutBufferSize,
    OUT LPWSTR* pwszString
    )
{
    size_t  cbRemaining;
    UINT    uSize;
    WCHAR*  pwszEnd = NULL;
    LPWSTR  pwszTmp = NULL;

    if (!pMultiSz || !pwszString) {
        DPFN(eDbgLevelError, "[ExtractMultiSzStrings] Invalid parameter(s)");
        return;
    }

    //
    // Walk the list of NULL-terminated strings and put them in the buffer.
    //
    pwszTmp = (LPWSTR)pMultiSz;

    cbRemaining = cbOutBufferSize;
    pwszEnd     = *pwszString;

    while (TRUE) {
        StringCbPrintfEx(pwszEnd,
                         cbRemaining,
                         &pwszEnd,
                         &cbRemaining,
                         0,
                         L" %ls",
                         pwszTmp);

        uSize = wcslen(pwszTmp) + 1;
        pwszTmp += uSize;

        if (*pwszTmp == '\0') {
            break;
        }
    }
}

/*++

 Formats the value data to form an XML element and logs it.

--*/
void
FormatValueData(
    IN LPCWSTR       pwszOperation,
    IN PKEY_DATA     pKeyData,
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    WCHAR   wszFinalValueType[MAX_DATA_TYPE_LENGTH];
    WCHAR   wszOriginalValueType[MAX_DATA_TYPE_LENGTH];
    LPCWSTR pwszValueName = NULL;
    PVOID   pOriginalTmp = NULL;
    PVOID   pFinalTmp = NULL;

    //
    // If we haven't already, allocate buffers that we'll
    // use and reuse when getting original and final data.
    //
    if (!g_cbOriginalDataBufferSize) {
        g_pwszOriginalData = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszOriginalData) {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to allocate memory for old data");
            return;
        }

        g_cbOriginalDataBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    if (!g_cbFinalDataBufferSize) {
        g_pwszFinalData = (LPWSTR)MemAlloc(TEMP_BUFFER_SIZE * sizeof(WCHAR));

        if (!g_pwszFinalData) {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to allocate memory for new data");
            return;
        }

        g_cbFinalDataBufferSize = TEMP_BUFFER_SIZE * sizeof(WCHAR);
    }

    *g_pwszOriginalData = 0;
    *g_pwszFinalData = 0;

    //
    // To make it easier to replace & ' " < and > with their
    // XML entities, we convert the data to CString.
    //
    CString csFullKeyPath(pLogOpenKey->pwszFullKeyPath);

    csFullKeyPath.Replace(L"&", L"&amp;");
    csFullKeyPath.Replace(L"<", L"&lt;");
    csFullKeyPath.Replace(L">", L"&gt;");
    csFullKeyPath.Replace(L"'", L"&apos;");
    csFullKeyPath.Replace(L"\"", L"&quot;");

    switch (pKeyData->dwOriginalValueType) {
    case REG_SZ:
        StringCchCopy(wszOriginalValueType,
                      ARRAYSIZE(wszOriginalValueType),
                      L"REG_SZ");
        break;
    case REG_EXPAND_SZ:
        StringCchCopy(wszOriginalValueType,
                      ARRAYSIZE(wszOriginalValueType),
                      L"REG_EXPAND_SZ");
        break;
    case REG_MULTI_SZ:
        StringCchCopy(wszOriginalValueType,
                      ARRAYSIZE(wszOriginalValueType),
                      L"REG_MULTI_SZ");
        break;
    case REG_DWORD:
        StringCchCopy(wszOriginalValueType,
                      ARRAYSIZE(wszOriginalValueType),
                      L"REG_DWORD");
        break;
    case REG_BINARY:
        StringCchCopy(wszOriginalValueType,
                      ARRAYSIZE(wszOriginalValueType),
                      L"REG_BINARY");
        break;
    default:
        StringCchCopy(wszOriginalValueType,
                      ARRAYSIZE(wszOriginalValueType),
                      L"Unknown");
        break;
    }

    switch (pKeyData->dwFinalValueType) {
    case REG_SZ:
        StringCchCopy(wszFinalValueType,
                      ARRAYSIZE(wszFinalValueType),
                      L"REG_SZ");
        break;
    case REG_EXPAND_SZ:
        StringCchCopy(wszFinalValueType,
                      ARRAYSIZE(wszFinalValueType),
                      L"REG_EXPAND_SZ");
        break;
    case REG_MULTI_SZ:
        StringCchCopy(wszFinalValueType,
                      ARRAYSIZE(wszFinalValueType),
                      L"REG_MULTI_SZ");
        break;
    case REG_DWORD:
        StringCchCopy(wszFinalValueType,
                      ARRAYSIZE(wszFinalValueType),
                      L"REG_DWORD");
        break;
    case REG_BINARY:
        StringCchCopy(wszFinalValueType,
                      ARRAYSIZE(wszFinalValueType),
                      L"REG_BINARY");
        break;
    default:
        StringCchCopy(wszFinalValueType,
                      ARRAYSIZE(wszFinalValueType),
                      L"Unknown");
        break;
    }

    //
    // If our temporary buffers are not large enough to store the data, reallocate.
    //
    if (pKeyData->cbOriginalDataSize > g_cbOriginalDataBufferSize) {
        pOriginalTmp = (LPWSTR)MemReAlloc(g_pwszOriginalData,
                                          pKeyData->cbOriginalDataSize + BUFFER_ALLOCATION_DELTA);

        if (pOriginalTmp) {
            g_pwszOriginalData = (LPWSTR)pOriginalTmp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to reallocate for original data");
            return;
        }

        g_cbOriginalDataBufferSize = pKeyData->cbOriginalDataSize + BUFFER_ALLOCATION_DELTA;
    }

    if (pKeyData->cbFinalDataSize > g_cbFinalDataBufferSize) {
        pFinalTmp = (LPWSTR)MemReAlloc(g_pwszFinalData,
                                       pKeyData->cbFinalDataSize + BUFFER_ALLOCATION_DELTA);

        if (pFinalTmp) {
            g_pwszFinalData = (LPWSTR)pFinalTmp;
        } else {
            DPFN(eDbgLevelError,
                 "[FormatValueData] Failed to reallocate for new data");
            return;
        }

        g_cbFinalDataBufferSize = pKeyData->cbFinalDataSize + BUFFER_ALLOCATION_DELTA;
    }

    //
    // Store the original and new data in the buffers.
    // Note that operations are performed differently based on the data type.
    //
    if (pKeyData->pOriginalData) {
        switch (pKeyData->dwOriginalValueType) {
        case REG_DWORD:
            StringCbPrintf(g_pwszOriginalData,
                           g_cbOriginalDataBufferSize,
                           L"%lu",
                           (*(DWORD*)pKeyData->pOriginalData));
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
            StringCbCopy(g_pwszOriginalData,
                         g_cbOriginalDataBufferSize,
                         (const WCHAR*)pKeyData->pOriginalData);
            break;

        case REG_MULTI_SZ:
            ExtractMultiSzStrings(pKeyData->pOriginalData,
                                  g_cbOriginalDataBufferSize,
                                  &g_pwszOriginalData);
            break;

        case REG_BINARY:
            ExtractBinaryData(pKeyData->pOriginalData,
                              pKeyData->cbOriginalDataSize,
                              g_cbOriginalDataBufferSize,
                              &g_pwszOriginalData);
            break;

        default:
            DPFN(eDbgLevelError, "[FormatValueData] Unsupported value type");
            break;
        }
    }

    if (pKeyData->pFinalData) {
        switch (pKeyData->dwFinalValueType) {
        case REG_DWORD:
            StringCbPrintf(g_pwszFinalData,
                           g_cbFinalDataBufferSize,
                           L"%lu",
                           (*(DWORD*)pKeyData->pFinalData));
            break;

        case REG_SZ:
        case REG_EXPAND_SZ:
            StringCbCopy(g_pwszFinalData,
                         g_cbFinalDataBufferSize,
                         (const WCHAR*)pKeyData->pFinalData);
            break;

        case REG_MULTI_SZ:
            ExtractMultiSzStrings(pKeyData->pFinalData,
                                  g_cbFinalDataBufferSize,
                                  &g_pwszFinalData);
            break;

        case REG_BINARY:
            ExtractBinaryData(pKeyData->pFinalData,
                              pKeyData->cbFinalDataSize,
                              g_cbFinalDataBufferSize,
                              &g_pwszFinalData);
            break;

        default:
            DPFN(eDbgLevelError, "[FormatValueData] Unsupported value type");
            break;
        }
    }

    //
    // Ensure that our unique id doesn't show up in the log.
    //
    if (_wcsicmp(pKeyData->wszValueName, g_wszUniqueId)) {
        pwszValueName = pKeyData->wszValueName;
    }

    //
    // Put the data into an XML element and log it.
    //
    FormatValueDataIntoElement(csFullKeyPath,
                               pwszOperation,
                               pwszValueName,
                               wszOriginalValueType,
                               wszFinalValueType);
}

/*++

 Determines the changes that took place on the specified key and
 if applicable, writes it to the log.

--*/
BOOL
EvaluateKeyChanges(
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    if (!pLogOpenKey) {
        DPFN(eDbgLevelError, "[EvaluateKeyChanges] Invalid parameter");
        return FALSE;
    }

    //
    // 1. Check for deletion of an existing key.
    //
    if ((pLogOpenKey->dwFlags & LRC_DELETED_KEY) &&
        (pLogOpenKey->dwFlags & LRC_EXISTING_KEY)) {
        FormatKeyDataIntoElement(L"Deleted Key", pLogOpenKey);
        return TRUE;
    }

    //
    // 2. Check for creation of a new key.
    //
    if (!(pLogOpenKey->dwFlags & LRC_EXISTING_KEY) &&
        (!(pLogOpenKey->dwFlags & LRC_DELETED_KEY))) {
        FormatKeyDataIntoElement(L"Created Key", pLogOpenKey);
        return TRUE;
    }

    //
    // 3. Check for deletion of a non-existing key.
    // This is an indicator that we should not look for
    // changes to values below this key.
    //
    if (pLogOpenKey->dwFlags & LRC_DELETED_KEY) {
        return FALSE;
    }

    return TRUE;
}

/*++

 Determines the changes that took place on the specified value and
 if applicable, writes it to the log.

--*/
void
EvaluateValueChanges(
    IN PKEY_DATA     pKeyData,
    IN PLOG_OPEN_KEY pLogOpenKey
    )
{
    if (!pKeyData || !pLogOpenKey) {
        DPFN(eDbgLevelError, "[EvaluateValueChanges] Invalid parameter(s)");
        return;
    }

    //
    // 1. Check for deletion of an existing value.
    //
    if ((pKeyData->dwFlags & LRC_DELETED_VALUE) &&
        (pKeyData->dwFlags & LRC_EXISTING_VALUE)) {
        FormatValueData(L"Deleted Value", pKeyData, pLogOpenKey);
        return;
    }

    //
    // 2. Check for modification of an existing value.
    //
    if ((pKeyData->dwFlags & LRC_EXISTING_VALUE) &&
        (pKeyData->dwFlags & LRC_MODIFIED_VALUE)) {
        FormatValueData(L"Modified Value", pKeyData, pLogOpenKey);
        return;
    }

    //
    // 3. Check for creation of a new value value.
    //
    if ((pKeyData->dwFlags & LRC_MODIFIED_VALUE) &&
        (!(pKeyData->dwFlags & LRC_DELETED_VALUE) &&
        (!(pKeyData->dwFlags & LRC_EXISTING_VALUE)))) {
        FormatValueData(L"Created Value", pKeyData, pLogOpenKey);
        return;
    }
}

/*++

 Write the entire linked list out to the log file.

--*/
BOOL
WriteListToLogFile(
    void
    )
{
    PLIST_ENTRY   pKeyNext = NULL;
    PLIST_ENTRY   pValueHead = NULL;
    PLIST_ENTRY   pValueNext = NULL;
    PKEY_DATA     pKeyData = NULL;
    PLOG_OPEN_KEY pOpenKey = NULL;

    //
    // Write out modifications for keys.
    //
    pKeyNext = g_OpenKeyListHead.Blink;

    while (pKeyNext != &g_OpenKeyListHead) {
        pOpenKey = CONTAINING_RECORD(pKeyNext, LOG_OPEN_KEY, Entry);

        //
        // EvaluateKeyChanges will return TRUE if the key was not
        // deleted. If this is the case, continue the search and
        // evaluate changes to values within this key.
        //
        if (EvaluateKeyChanges(pOpenKey)) {
            //
            // Write out modifications for values.
            //
            pValueHead = &pOpenKey->KeyData;
            pValueNext = pValueHead->Blink;

            while (pValueNext != pValueHead) {
                pKeyData = CONTAINING_RECORD(pValueNext, KEY_DATA, Entry);

                EvaluateValueChanges(pKeyData, pOpenKey);

                pValueNext = pValueNext->Blink;
            }
        }

        pKeyNext = pKeyNext->Blink;
    }

    CloseLogFile();

    return TRUE;
}

//
// Begin implementation of the class.
//
LONG
CLogRegistry::CreateKeyExA(
    HKEY                  hKey,
    LPCSTR                pszSubKey,
    DWORD                 Reserved,
    LPSTR                 pszClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    LPWSTR  pwszSubKey = NULL;
    LPWSTR  pwszClass = NULL;
    LONG    lRetVal;

    //
    // Stub out to CreateKeyExW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[CreateKeyExA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    if (pszClass) {
        if (!ConvertAnsiToUnicode(pszClass, &pwszClass)) {
            DPFN(eDbgLevelError, "[CreateKeyExA] Ansi to Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = CreateKeyExW(
        hKey,
        pwszSubKey,
        Reserved,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    if (pwszClass) {
        MemFree(pwszClass);
    }

    return lRetVal;
}

LONG
CLogRegistry::CreateKeyExW(
    HKEY                  hKey,
    LPCWSTR               pwszSubKey,
    DWORD                 Reserved,
    LPWSTR                pwszClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    DWORD   dwDisposition = 0;
    LONG    lRetVal;
    BOOL    fExisting = FALSE;

    if (!lpdwDisposition) {
        lpdwDisposition = &dwDisposition;
    }

    lRetVal = ORIGINAL_API(RegCreateKeyExW)(
        hKey,
        pwszSubKey,
        Reserved,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);

    if (lRetVal == ERROR_SUCCESS) {
        if (REG_OPENED_EXISTING_KEY == *lpdwDisposition) {
            fExisting = TRUE;
        }

        UpdateKeyList(hKey,
                      *phkResult,
                      pwszSubKey,
                      NULL,
                      fExisting,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG
CLogRegistry::OpenKeyExA(
    HKEY   hKey,
    LPCSTR pszSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LPWSTR  pwszSubKey = NULL;
    LONG    lRetVal;

    //
    // Stub out to OpenKeyExW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[OpenKeyExA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = OpenKeyExW(
        hKey,
        pwszSubKey,
        ulOptions,
        samDesired,
        phkResult);

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    return lRetVal;
}

LONG
CLogRegistry::OpenKeyExW(
    HKEY    hKey,
    LPCWSTR pwszSubKey,
    DWORD   ulOptions,
    REGSAM  samDesired,
    PHKEY   phkResult
    )
{
    LONG    lRetVal;

    lRetVal = ORIGINAL_API(RegOpenKeyExW)(
        hKey,
        pwszSubKey,
        ulOptions,
        samDesired,
        phkResult);

    if (lRetVal == ERROR_SUCCESS) {
        UpdateKeyList(hKey,
                      *phkResult,
                      pwszSubKey,
                      NULL,
                      TRUE,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG
CLogRegistry::OpenCurrentUser(
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LONG    lRetVal;

    lRetVal = ORIGINAL_API(RegOpenCurrentUser)(
        samDesired,
        phkResult);

    if (lRetVal == ERROR_SUCCESS) {
        UpdateKeyList(HKEY_CURRENT_USER,
                      *phkResult,
                      NULL,
                      NULL,
                      TRUE,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG
CLogRegistry::OpenUserClassesRoot(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    LONG    lRetVal;

    lRetVal = ORIGINAL_API(RegOpenUserClassesRoot)(
        hToken,
        dwOptions,
        samDesired,
        phkResult);

    if (lRetVal == ERROR_SUCCESS) {
        UpdateKeyList(HKEY_CLASSES_ROOT,
                      *phkResult,
                      NULL,
                      NULL,
                      TRUE,
                      eAddKeyHandle);
    }

    return lRetVal;
}

LONG
CLogRegistry::SetValueA(
    HKEY   hKey,
    LPCSTR pszSubKey,
    DWORD  dwType,
    LPCSTR lpData,
    DWORD  cbData
    )
{
    LPWSTR  pwszSubKey = NULL;
    LPWSTR  pwszData = NULL;
    LONG    lRetVal;

    //
    // Stub out to SetValueW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[SetValueA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    if (lpData) {
        if (!ConvertAnsiToUnicode(lpData, &pwszData)) {
            DPFN(eDbgLevelError, "[SetValueA] Ansi to Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = SetValueW(
        hKey,
        pwszSubKey,
        dwType,
        pwszData,
        cbData * sizeof(WCHAR));

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    if (pwszData) {
        MemFree(pwszData);
    }

    return lRetVal;
}

LONG
CLogRegistry::SetValueW(
    HKEY    hKey,
    LPCWSTR pwszSubKey,
    DWORD   dwType,
    LPCWSTR lpData,
    DWORD   cbData
    )
{
    HKEY    hKeyLocal;
    LONG    lRetVal;

    //
    // Call OpenKeyEx to force this key to be added to the list.
    //
    if (pwszSubKey) {
        lRetVal = OpenKeyExW(hKey,
                             pwszSubKey,
                             0,
                             KEY_SET_VALUE,
                             &hKeyLocal);

        if (ERROR_SUCCESS != lRetVal) {
            DPFN(eDbgLevelError, "[SetValueW] Failed to open key");
            return lRetVal;
        }

        lRetVal = SetValueExW(hKeyLocal,
                              NULL,
                              0,
                              dwType,
                              (const BYTE*)lpData,
                              cbData);

        CloseKey(hKeyLocal);

        return lRetVal;
    }

    //
    // All other cases will be handled properly.
    //
    lRetVal = SetValueExW(hKey,
                          NULL,
                          0,
                          dwType,
                          (const BYTE*)lpData,
                          cbData);

    return lRetVal;
}

LONG
CLogRegistry::SetValueExA(
    HKEY        hKey,
    LPCSTR      pszValueName,
    DWORD       Reserved,
    DWORD       dwType,
    CONST BYTE* lpData,
    DWORD       cbData
    )
{
    LPWSTR  pwszData = NULL;
    LPWSTR  pwszValueName = NULL;
    LONG    lRetVal;
    BOOL    fString = FALSE;

    //
    // Stub out to SetValueExW.
    //
    if (pszValueName) {
        if (!ConvertAnsiToUnicode(pszValueName, &pwszValueName)) {
            DPFN(eDbgLevelError, "[SetValueExA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    if (REG_SZ == dwType || REG_EXPAND_SZ == dwType || REG_MULTI_SZ == dwType) {
        fString = TRUE;
    }

    //
    // If the data is of type string, convert it to Unicode.
    //
    if (lpData) {
        if (REG_MULTI_SZ == dwType) {
            if (!ConvertMultiSzToUnicode((LPCSTR)lpData, &pwszData)) {
                DPFN(eDbgLevelError, "[SetValueExA] Multi Sz to Unicode failed");
                return ERROR_OUTOFMEMORY;
            }
        }
        else if (REG_SZ == dwType || REG_EXPAND_SZ == dwType) {
            if (!ConvertAnsiToUnicode((LPCSTR)lpData, &pwszData)) {
                DPFN(eDbgLevelError, "[SetValueExA] Ansi to Unicode failed");
                return ERROR_OUTOFMEMORY;
            }
        }
    }

    if (fString) {
        lRetVal = SetValueExW(
            hKey,
            pwszValueName,
            Reserved,
            dwType,
            (const BYTE*)pwszData,
            cbData * sizeof(WCHAR));
    } else {
        lRetVal = SetValueExW(
            hKey,
            pwszValueName,
            Reserved,
            dwType,
            lpData,
            cbData);
    }

    if (pwszValueName) {
        MemFree(pwszValueName);
    }

    if (pwszData) {
        MemFree(pwszData);
    }

    return lRetVal;
}

LONG
CLogRegistry::SetValueExW(
    HKEY        hKey,
    LPCWSTR     pwszValueName,
    DWORD       Reserved,
    DWORD       dwType,
    CONST BYTE* lpData,
    DWORD       cbData
    )
{
    LONG    lRetVal;

    UpdateKeyList(NULL, hKey, NULL, pwszValueName, FALSE, eStartModifyValue);

    lRetVal = ORIGINAL_API(RegSetValueExW)(
        hKey,
        pwszValueName,
        Reserved,
        dwType,
        lpData,
        cbData);

    if (ERROR_SUCCESS == lRetVal) {
        UpdateKeyList(NULL, hKey, NULL, pwszValueName, FALSE, eEndModifyValue);
    }

    return lRetVal;
}

LONG
CLogRegistry::CloseKey(
    HKEY hKey
    )
{
    UpdateKeyList(NULL, hKey, NULL, NULL, TRUE, eRemoveKeyHandle);

    return ORIGINAL_API(RegCloseKey)(hKey);
}

LONG
CLogRegistry::DeleteKeyA(
    HKEY   hKey,
    LPCSTR pszSubKey
    )
{
    LPWSTR  pwszSubKey = NULL;
    LONG    lRetVal;

    //
    // Stub out to DeleteKeyW.
    //
    if (pszSubKey) {
        if (!ConvertAnsiToUnicode(pszSubKey, &pwszSubKey)) {
            DPFN(eDbgLevelError, "[DeleteKeyA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = DeleteKeyW(hKey, pwszSubKey);

    if (pwszSubKey) {
        MemFree(pwszSubKey);
    }

    return lRetVal;
}

LONG
CLogRegistry::DeleteKeyW(
    HKEY    hKey,
    LPCWSTR pwszSubKey
    )
{
    LONG    lRetVal;
    HKEY    hKeyLocal;

    //
    // The caller can pass a predefined handle or an open key
    // handle. In all cases, we open the key they're passing
    // to force it into the list. Note that we mainly do
    // this for logging purposes only.
    //
    hKeyLocal = ForceSubKeyIntoList(hKey, pwszSubKey);

    lRetVal = ORIGINAL_API(RegDeleteKeyW)(hKey, pwszSubKey);

    if (ERROR_SUCCESS == lRetVal && hKeyLocal) {
        UpdateKeyList(NULL, hKeyLocal, pwszSubKey, NULL, TRUE, eDeletedKey);
    }

    if (hKeyLocal) {
        CloseKey(hKeyLocal);
    }

    return lRetVal;
}

LONG
CLogRegistry::DeleteValueA(
    HKEY   hKey,
    LPCSTR pszValueName
    )
{
    LPWSTR  pwszValueName = NULL;
    LONG    lRetVal;

    //
    // Stub out to DeleteValueW.
    //
    if (pszValueName) {
        if (!ConvertAnsiToUnicode(pszValueName, &pwszValueName)) {
            DPFN(eDbgLevelError, "[DeleteValueA] Ansi -> Unicode failed");
            return ERROR_OUTOFMEMORY;
        }
    }

    lRetVal = DeleteValueW(hKey, pwszValueName);

    if (pwszValueName) {
        MemFree(pwszValueName);
    }

    return lRetVal;
}

LONG
CLogRegistry::DeleteValueW(
    HKEY    hKey,
    LPCWSTR pwszValueName
    )
{
    LONG    lRetVal;

    UpdateKeyList(NULL, hKey, NULL, pwszValueName, TRUE, eStartDeleteValue);

    lRetVal = ORIGINAL_API(RegDeleteValueW)(hKey, pwszValueName);

    if (ERROR_SUCCESS == lRetVal) {
        UpdateKeyList(NULL, hKey, NULL, pwszValueName, TRUE, eEndDeleteValue);
    }

    return lRetVal;
}

CLogRegistry clr;

//
// Implemenation of the actual Registry API hooks.
//
LONG
APIHOOK(RegOpenKeyA)(
    HKEY  hKey,
    LPSTR lpSubKey,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.OpenKeyExA(
        hKey,
        lpSubKey,
        0,
        MAXIMUM_ALLOWED,
        phkResult);
}

LONG
APIHOOK(RegOpenKeyW)(
    HKEY   hKey,
    LPWSTR lpSubKey,
    PHKEY  phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.OpenKeyExW(
        hKey,
        lpSubKey,
        0,
        MAXIMUM_ALLOWED,
        phkResult);
}

LONG
APIHOOK(RegOpenKeyExA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    DWORD  ulOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.OpenKeyExA(
        hKey,
        lpSubKey,
        ulOptions,
        samDesired,
        phkResult);
}

LONG
APIHOOK(RegOpenKeyExW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    DWORD   ulOptions,
    REGSAM  samDesired,
    PHKEY   phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.OpenKeyExW(
        hKey,
        lpSubKey,
        ulOptions,
        samDesired,
        phkResult);
}

LONG
APIHOOK(RegOpenCurrentUser)(
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.OpenCurrentUser(
        samDesired,
        phkResult);
}

LONG
APIHOOK(RegOpenUserClassesRoot)(
    HANDLE hToken,
    DWORD  dwOptions,
    REGSAM samDesired,
    PHKEY  phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.OpenUserClassesRoot(
        hToken,
        dwOptions,
        samDesired,
        phkResult);
}

LONG
APIHOOK(RegCreateKeyA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    PHKEY  phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.CreateKeyExA(
        hKey,
        lpSubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL);
}

LONG
APIHOOK(RegCreateKeyW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    PHKEY   phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return clr.CreateKeyExW(
        hKey,
        lpSubKey,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL);
}

LONG
APIHOOK(RegCreateKeyExA)(
    HKEY                  hKey,
    LPCSTR                lpSubKey,
    DWORD                 Reserved,
    LPSTR                 lpClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    CLock   cLock(g_csCritSec);

    return clr.CreateKeyExA(
        hKey,
        lpSubKey,
        Reserved,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);
}

LONG
APIHOOK(RegCreateKeyExW)(
    HKEY                  hKey,
    LPCWSTR               lpSubKey,
    DWORD                 Reserved,
    LPWSTR                lpClass,
    DWORD                 dwOptions,
    REGSAM                samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,
    LPDWORD               lpdwDisposition
    )
{
    CLock   cLock(g_csCritSec);

    return clr.CreateKeyExW(
        hKey,
        lpSubKey,
        Reserved,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition);
}

LONG
APIHOOK(RegSetValueA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    DWORD  dwType,
    LPCSTR lpData,
    DWORD  cbData
    )
{
    CLock   cLock(g_csCritSec);

    return clr.SetValueA(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegSetValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    DWORD   dwType,
    LPCWSTR lpData,
    DWORD   cbData
    )
{
    CLock   cLock(g_csCritSec);

    return clr.SetValueW(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegSetValueExA)(
    HKEY        hKey,
    LPCSTR      lpSubKey,
    DWORD       Reserved,
    DWORD       dwType,
    CONST BYTE* lpData,
    DWORD       cbData
    )
{
    CLock   cLock(g_csCritSec);

    return clr.SetValueExA(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegSetValueExW)(
    HKEY        hKey,
    LPCWSTR     lpSubKey,
    DWORD       Reserved,
    DWORD       dwType,
    CONST BYTE* lpData,
    DWORD       cbData
    )
{
    CLock   cLock(g_csCritSec);

    return clr.SetValueExW(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegCloseKey)(
    HKEY hKey
    )
{
    CLock   cLock(g_csCritSec);

    return clr.CloseKey(
        hKey);
}

LONG
APIHOOK(RegDeleteKeyA)(
    HKEY   hKey,
    LPCSTR lpSubKey
    )
{
    CLock   cLock(g_csCritSec);

    return clr.DeleteKeyA(
        hKey,
        lpSubKey);
}

LONG
APIHOOK(RegDeleteKeyW)(
    HKEY    hKey,
    LPCWSTR lpSubKey
    )
{
    CLock   cLock(g_csCritSec);

    return clr.DeleteKeyW(
        hKey,
        lpSubKey);
}

LONG
APIHOOK(RegDeleteValueA)(
    HKEY   hKey,
    LPCSTR lpValueName
    )
{
    CLock   cLock(g_csCritSec);

    return clr.DeleteValueA(
        hKey,
        lpValueName);
}

LONG
APIHOOK(RegDeleteValueW)(
    HKEY    hKey,
    LPCWSTR lpValueName
    )
{
    CLock   cLock(g_csCritSec);

    return clr.DeleteValueW(
        hKey,
        lpValueName);
}

/*++

 Creates a unique id used to represent NULL values on registry calls.

--*/
void
InitializeNullValueId(
    void
    )
{
    SYSTEMTIME  st;
    WCHAR*      pwszSlash = NULL;
    WCHAR       wszModPathName[MAX_PATH];
    WCHAR       wszShortName[MAX_PATH];

    //
    // Because there is a NULL valuename for every key in the registry,
    // we need a unique key that we can use to represent NULL in our list.
    //
    if (!GetModuleFileName(NULL, wszModPathName, ARRAYSIZE(wszModPathName))) {
        StringCchCopy(wszModPathName,
                      ARRAYSIZE(wszModPathName),
                      L"uniqueexeidentifier");
    }

    pwszSlash = wcsrchr(wszModPathName, '\\');

    if (pwszSlash) {
        StringCchCopy(wszShortName, ARRAYSIZE(wszShortName), ++pwszSlash);
    }

    GetLocalTime(&st);

    //
    // The format of our unique id will look like this:
    // processname.xxx-lrc-yymmdd-default
    //
    StringCchPrintf(g_wszUniqueId,
                    ARRAYSIZE(g_wszUniqueId),
                    L"%ls-lrc-%02hu%02hu%02hu-default",
                    wszShortName,
                    st.wYear,
                    st.wMonth,
                    st.wDay);
}

/*++

 Adds the predefined key handles to the list.

--*/
BOOL
AddPredefinedHandlesToList(
    void
    )
{
    UINT            uCount;
    PLOG_OPEN_KEY   pKey = NULL;
    HKEY            rgKeys[NUM_PREDEFINED_HANDLES] = { HKEY_LOCAL_MACHINE,
                                                       HKEY_CLASSES_ROOT,
                                                       HKEY_CURRENT_USER,
                                                       HKEY_USERS,
                                                       HKEY_CURRENT_CONFIG,
                                                       HKEY_DYN_DATA,
                                                       HKEY_PERFORMANCE_DATA };

    for (uCount = 0; uCount < NUM_PREDEFINED_HANDLES; uCount++) {
        pKey = (PLOG_OPEN_KEY)MemAlloc(sizeof(LOG_OPEN_KEY));

        if (!pKey) {
            DPFN(eDbgLevelError,
                 "[AddPredefinedHandlesToList] No memory available");
            return FALSE;
        }

        pKey->pwszFullKeyPath = (LPWSTR)MemAlloc(MAX_ROOT_LENGTH * sizeof(WCHAR));

        if (!pKey->pwszFullKeyPath) {
            DPFN(eDbgLevelError,
                 "[AddPredefinedHandlesToList] Failed to allocate memory");
            return FALSE;
        }

        if (!PredefinedKeyToString(rgKeys[uCount],
                                   MAX_ROOT_LENGTH,
                                   &pKey->pwszFullKeyPath)) {
            DPFN(eDbgLevelError,
                "[AddPredefinedHandlesToList] PredefinedKey -> String failed");
            return FALSE;
        }

        pKey->hKeyRoot         = rgKeys[uCount];
        pKey->hKeyBase[0]      = rgKeys[uCount];
        pKey->pwszSubKeyPath   = NULL;
        pKey->dwFlags          = LRC_EXISTING_KEY;
        pKey->cHandles         = 1;

        InitializeListHead(&pKey->KeyData);

        InsertHeadList(&g_OpenKeyListHead, &pKey->Entry);
    }

    return TRUE;
}

/*++

 Initialize the the list head and the log file.

--*/
BOOL
InitializeShim(
    void
    )
{
    CLock   cLock(g_csCritSec);

    //
    // Initialize our open key handle list head and the
    // key data list head.
    //
    InitializeListHead(&g_OpenKeyListHead);

    //
    // Add the predefined handles to the list.
    //
    if (!AddPredefinedHandlesToList()) {
        return FALSE;
    }

    InitializeNullValueId();

    //
    // Initialize our log file.
    //
    return InitializeLogFile();
}

/*++

 Handle process attach notification.

--*/
BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == DLL_PROCESS_ATTACH) {
        return InitializeShim();
    } else if (fdwReason == DLL_PROCESS_DETACH) {
        return WriteListToLogFile();
    }

    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_LOGREGCHANGES_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_LOGREGCHANGES_FRIENDLY)
    SHIM_INFO_VERSION(1, 7)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_DEFAULT | AVRF_FLAG_EXTERNAL_ONLY)

SHIM_INFO_END()

/*++

 Register hooked functions.

--*/

HOOK_BEGIN

    CALL_NOTIFY_FUNCTION

    DUMP_VERIFIER_LOG_ENTRY(VLOG_LOGREGCHANGES_LOGLOC,
                            AVS_LOGREGCHANGES_LOGLOC,
                            AVS_LOGREGCHANGES_LOGLOC_R,
                            AVS_LOGREGCHANGES_LOGLOC_URL)

    APIHOOK_ENTRY(ADVAPI32.DLL,                      RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                      RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegOpenKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL,               RegOpenCurrentUser)
    APIHOOK_ENTRY(ADVAPI32.DLL,           RegOpenUserClassesRoot)

    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegCreateKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegCreateKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegCreateKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegCreateKeyExW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                     RegSetValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                   RegSetValueExW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegDeleteKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                    RegDeleteKeyW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegDeleteValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                  RegDeleteValueW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                      RegCloseKey)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\logstartandstop.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   LogStartAndStop.cpp

 Abstract:

   This DLL just adds start and stop messages to the verifier log.

 Notes:

   This is a general purpose shim.

 History:

   06/05/2001 dmunsil  Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(LogStartAndStop)
#include "ShimHookMacro.h"

APIHOOK_ENUM_BEGIN
APIHOOK_ENUM_END

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(LogStartAndStop)
    VERIFIER_LOG_ENTRY(VLOG_APP_STARTED)
    VERIFIER_LOG_ENTRY(VLOG_APP_STOPPED)
END_DEFINE_VERIFIER_LOG(LogStartAndStop)

INIT_VERIFIER_LOG(LogStartAndStop);

BOOL
NOTIFY_FUNCTION(
    DWORD fdwReason
    )
{
    if (fdwReason == SHIM_STATIC_DLLS_INITIALIZED) {

        VLOG(VLOG_LEVEL_INFO, VLOG_APP_STARTED, "The application started.");

    } else if (fdwReason == DLL_PROCESS_DETACH) {

        VLOG(VLOG_LEVEL_INFO, VLOG_APP_STOPPED, "The application stopped.");
    }
    
    return TRUE;
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_LOGSTARTANDSTOP_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_LOGSTARTANDSTOP_FRIENDLY)
    SHIM_INFO_VERSION(1, 2)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_WIN2K)

SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN
    DUMP_VERIFIER_LOG_ENTRY(VLOG_APP_STARTED, 
                            AVS_APP_STARTED,
                            AVS_APP_STARTED_R,
                            AVS_APP_STARTED_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_APP_STOPPED, 
                            AVS_APP_STOPPED,
                            AVS_APP_STOPPED_R,
                            AVS_APP_STOPPED_URL)

    CALL_NOTIFY_FUNCTION
HOOK_END


IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\obsoleteapicalls.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   ObsoleteAPICalls.cpp

 Abstract:

   This AppVerifier shim hooks the API calls that are considered
   obsolete by the Platform SDK team and logs an entry.

 Notes:

   This is a general purpose shim.
   
   API calls are listed in alphabetical order to allow
   them to be quickly located in the shim and to allow
   new ones to be added in the proper location.

 History:

   09/30/2001   rparsons    Created
   10/10/2001   rparsons    Removed SetHandleCount

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(ObsoleteAPICalls)
#include "ShimHookMacro.h"

BEGIN_DEFINE_VERIFIER_LOG(ObsoleteAPICalls)
    VERIFIER_LOG_ENTRY(VLOG_OBSOLETECALLS_API)    
END_DEFINE_VERIFIER_LOG(ObsoleteAPICalls)

INIT_VERIFIER_LOG(ObsoleteAPICalls);

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(_hread)
    APIHOOK_ENUM_ENTRY(_hwrite)
    APIHOOK_ENUM_ENTRY(_lclose)
    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(_llseek)
    APIHOOK_ENUM_ENTRY(_lopen)
    APIHOOK_ENUM_ENTRY(_lread)
    APIHOOK_ENUM_ENTRY(_lwrite)
    APIHOOK_ENUM_ENTRY(AnyPopup)
    APIHOOK_ENUM_ENTRY(CloseMetaFile)
    APIHOOK_ENUM_ENTRY(CopyLZFile)
    APIHOOK_ENUM_ENTRY(CopyMetaFileA)
    APIHOOK_ENUM_ENTRY(CopyMetaFileW)
    APIHOOK_ENUM_ENTRY(CreateDIBPatternBrush)
    APIHOOK_ENUM_ENTRY(CreateDiscardableBitmap)
    APIHOOK_ENUM_ENTRY(CreateMetaFileA)
    APIHOOK_ENUM_ENTRY(CreateMetaFileW)
    APIHOOK_ENUM_ENTRY(DeleteMetaFile)
    APIHOOK_ENUM_ENTRY(EnumFontFamiliesA)
    APIHOOK_ENUM_ENTRY(EnumFontFamiliesW)
    APIHOOK_ENUM_ENTRY(EnumFontFamProc)
    APIHOOK_ENUM_ENTRY(EnumFontsA)
    APIHOOK_ENUM_ENTRY(EnumFontsW)
    APIHOOK_ENUM_ENTRY(EnumFontsProc)
    APIHOOK_ENUM_ENTRY(EnumMetaFile)
    APIHOOK_ENUM_ENTRY(EnumMetaFileProc)
    APIHOOK_ENUM_ENTRY(FixBrushOrgEx)
    APIHOOK_ENUM_ENTRY(FloodFill)
    APIHOOK_ENUM_ENTRY(FreeResource)
    APIHOOK_ENUM_ENTRY(GetBitmapBits)
    APIHOOK_ENUM_ENTRY(GetCharWidthA)
    APIHOOK_ENUM_ENTRY(GetCharWidthW)
    APIHOOK_ENUM_ENTRY(GetClassWord)
    APIHOOK_ENUM_ENTRY(GetKBCodePage)
    APIHOOK_ENUM_ENTRY(GetMetaFileA)
    APIHOOK_ENUM_ENTRY(GetMetaFileW)
    APIHOOK_ENUM_ENTRY(GetMetaFileBitsEx)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileIntW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileSectionNamesW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(GetPrivateProfileStructW)
    APIHOOK_ENUM_ENTRY(GetProfileIntA)
    APIHOOK_ENUM_ENTRY(GetProfileIntW)
    APIHOOK_ENUM_ENTRY(GetProfileSectionA)
    APIHOOK_ENUM_ENTRY(GetProfileSectionW)
    APIHOOK_ENUM_ENTRY(GetProfileStringA)
    APIHOOK_ENUM_ENTRY(GetProfileStringW)
    APIHOOK_ENUM_ENTRY(GetSysModalWindow)
    APIHOOK_ENUM_ENTRY(GetTextExtentPointA)
    APIHOOK_ENUM_ENTRY(GetTextExtentPointW)
    APIHOOK_ENUM_ENTRY(GetWindowWord)
    APIHOOK_ENUM_ENTRY(GlobalAlloc)
    APIHOOK_ENUM_ENTRY(GlobalCompact)
    APIHOOK_ENUM_ENTRY(GlobalFix)
    APIHOOK_ENUM_ENTRY(GlobalFlags)
    APIHOOK_ENUM_ENTRY(GlobalFree)
    APIHOOK_ENUM_ENTRY(GlobalHandle)
    APIHOOK_ENUM_ENTRY(GlobalLock)
    APIHOOK_ENUM_ENTRY(GlobalReAlloc)
    APIHOOK_ENUM_ENTRY(GlobalSize)
    APIHOOK_ENUM_ENTRY(GlobalUnfix)
    APIHOOK_ENUM_ENTRY(GlobalUnlock)
    APIHOOK_ENUM_ENTRY(GlobalUnWire)
    APIHOOK_ENUM_ENTRY(GlobalWire)
    APIHOOK_ENUM_ENTRY(IsBadHugeReadPtr)
    APIHOOK_ENUM_ENTRY(IsBadHugeWritePtr)
    APIHOOK_ENUM_ENTRY(LoadModule)
    APIHOOK_ENUM_ENTRY(LocalAlloc)
    APIHOOK_ENUM_ENTRY(LocalCompact)
    APIHOOK_ENUM_ENTRY(LocalDiscard)
    APIHOOK_ENUM_ENTRY(LocalFlags)
    APIHOOK_ENUM_ENTRY(LocalFree)
    APIHOOK_ENUM_ENTRY(LocalHandle)
    APIHOOK_ENUM_ENTRY(LocalLock)
    APIHOOK_ENUM_ENTRY(LocalReAlloc)
    APIHOOK_ENUM_ENTRY(LocalShrink)
    APIHOOK_ENUM_ENTRY(LocalSize)
    APIHOOK_ENUM_ENTRY(LocalUnlock)
    APIHOOK_ENUM_ENTRY(LZDone)
    APIHOOK_ENUM_ENTRY(LZStart)
    APIHOOK_ENUM_ENTRY(OpenFile)
    APIHOOK_ENUM_ENTRY(PlayMetaFile)
    APIHOOK_ENUM_ENTRY(PlayMetaFileRecord)
    APIHOOK_ENUM_ENTRY(PrinterMessageBoxA)
    APIHOOK_ENUM_ENTRY(PrinterMessageBoxW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(SetBitmapBits)
    APIHOOK_ENUM_ENTRY(SetClassWord)
    APIHOOK_ENUM_ENTRY(SetDebugErrorLevel)
    APIHOOK_ENUM_ENTRY(SetMessageQueue)
    APIHOOK_ENUM_ENTRY(SetMetaFileBitsEx)
    APIHOOK_ENUM_ENTRY(SetSysModalWindow)
    APIHOOK_ENUM_ENTRY(SetWindowsHookA)
    APIHOOK_ENUM_ENTRY(SetWindowsHookW)
    APIHOOK_ENUM_ENTRY(SetWindowWord)
    APIHOOK_ENUM_ENTRY(UnhookWindowsHook)
    APIHOOK_ENUM_ENTRY(WaitForPrinterChange)
    APIHOOK_ENUM_ENTRY(WinExec)
    APIHOOK_ENUM_ENTRY(WNetAddConnectionA)
    APIHOOK_ENUM_ENTRY(WNetAddConnectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileSectionW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStringW)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructA)
    APIHOOK_ENUM_ENTRY(WritePrivateProfileStructW)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionA)
    APIHOOK_ENUM_ENTRY(WriteProfileSectionW)
    APIHOOK_ENUM_ENTRY(WriteProfileStringA)
    APIHOOK_ENUM_ENTRY(WriteProfileStringW)
    
APIHOOK_ENUM_END

LONG
APIHOOK(_hread)(
    HFILE  hFile,
    LPVOID lpBuffer,
    LONG   lBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _hread");

    return ORIGINAL_API(_hread)(hFile, lpBuffer, lBytes);
}

LONG
APIHOOK(_hwrite)(
    HFILE  hFile,
    LPCSTR lpBuffer,
    LONG   lBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _hwrite");

    return ORIGINAL_API(_hwrite)(hFile, lpBuffer, lBytes);
}

HFILE
APIHOOK(_lclose)(
    HFILE hFile
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lclose");

    return ORIGINAL_API(_lclose)(hFile);
}

HFILE
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int    iAttribute
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lcreat");
    
    return ORIGINAL_API(_lcreat)(lpPathName, iAttribute);

}

LONG
APIHOOK(_llseek)(
    HFILE hFile,
    LONG  lOffset,
    int   iOrigin
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _llseek");

    return ORIGINAL_API(_llseek)(hFile, lOffset, iOrigin);
}

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int    iReadWrite
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lopen");
    
    return ORIGINAL_API(_lopen)(lpPathName, iReadWrite);
}

UINT
APIHOOK(_lread)(
    HFILE  hFile,
    LPVOID lpBuffer,
    UINT   uBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lread");

    return ORIGINAL_API(_lread)(hFile, lpBuffer, uBytes);
}

UINT
APIHOOK(_lwrite)(
    HFILE  hFile,
    LPCSTR lpBuffer,
    UINT   uBytes
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: _lwrite");

    return ORIGINAL_API(_lwrite)(hFile, lpBuffer, uBytes);
}

BOOL
APIHOOK(AnyPopup)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: AnyPopup");

    return ORIGINAL_API(AnyPopup)();
}

HMETAFILE
APIHOOK(CloseMetaFile)(
    HDC hdc
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CloseMetaFile");

    return ORIGINAL_API(CloseMetaFile)(hdc);
}

LONG
APIHOOK(CopyLZFile)(
    int nUnknown1,
    int nUnknown2
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CopyLZFile");

    return ORIGINAL_API(CopyLZFile)(nUnknown1, nUnknown2);
}

HMETAFILE
APIHOOK(CopyMetaFileA)(
    HMETAFILE hmfSrc,
    LPCSTR    lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CopyMetaFileA");

    return ORIGINAL_API(CopyMetaFileA)(hmfSrc, lpszFile);
}

HMETAFILE
APIHOOK(CopyMetaFileW)(
    HMETAFILE hmfSrc,
    LPCWSTR    lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CopyMetaFileW");

    return ORIGINAL_API(CopyMetaFileW)(hmfSrc, lpszFile);
}

HBRUSH
APIHOOK(CreateDIBPatternBrush)(
    HGLOBAL hglbDIBPacked,
    UINT    fuColorSpec
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateDIBPatternBrush");

    return ORIGINAL_API(CreateDIBPatternBrush)(hglbDIBPacked, fuColorSpec);
}

HBITMAP
APIHOOK(CreateDiscardableBitmap)(
    HDC hdc,   
    int nWidth,
    int nHeight
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateDiscardableBitmap");

    return ORIGINAL_API(CreateDiscardableBitmap)(hdc, nWidth, nHeight);
}

HDC
APIHOOK(CreateMetaFileA)(
    LPCSTR lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateMetaFileA");

    return ORIGINAL_API(CreateMetaFileA)(lpszFile);
}

HDC
APIHOOK(CreateMetaFileW)(
    LPCWSTR lpszFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: CreateMetaFileW");

    return ORIGINAL_API(CreateMetaFileW)(lpszFile);
}

BOOL
APIHOOK(DeleteMetaFile)(
    HMETAFILE hmf
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: DeleteMetaFile");

    return ORIGINAL_API(DeleteMetaFile)(hmf);
}

int
APIHOOK(EnumFontFamiliesA)(
    HDC          hdc,
    LPCSTR       lpszFamily,
    FONTENUMPROC lpEnumFontFamProc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontFamiliesA");

    return ORIGINAL_API(EnumFontFamiliesA)(hdc, lpszFamily, lpEnumFontFamProc, lParam);
}

int
APIHOOK(EnumFontFamiliesW)(
    HDC          hdc,
    LPCWSTR      lpszFamily,
    FONTENUMPROC lpEnumFontFamProc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontFamiliesW");

    return ORIGINAL_API(EnumFontFamiliesW)(hdc, lpszFamily, lpEnumFontFamProc, lParam);
}

int
APIHOOK(EnumFontFamProc)(
    ENUMLOGFONT   *lpelf,
    NEWTEXTMETRIC *lpntm,
    DWORD         FontType,
    LPARAM        lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontFamProc");

    return ORIGINAL_API(EnumFontFamProc)(lpelf, lpntm, FontType, lParam);
}

int
APIHOOK(EnumFontsA)(
    HDC          hdc,
    LPCSTR       lpFaceName,
    FONTENUMPROC lpFontFunc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontsA");

    return ORIGINAL_API(EnumFontsA)(hdc, lpFaceName, lpFontFunc, lParam);
}

int
APIHOOK(EnumFontsW)(
    HDC          hdc,
    LPCWSTR      lpFaceName,
    FONTENUMPROC lpFontFunc,
    LPARAM       lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontsW");

    return ORIGINAL_API(EnumFontsW)(hdc, lpFaceName, lpFontFunc, lParam);
}

int
APIHOOK(EnumFontsProc)(
    CONST LOGFONT    *lplf,
    CONST TEXTMETRIC *lptm,
    DWORD            dwType,
    LPARAM           lpData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumFontsProc");

    return ORIGINAL_API(EnumFontsProc)(lplf, lptm, dwType, lpData);
}

BOOL
APIHOOK(EnumMetaFile)(
    HDC        hdc,
    HMETAFILE  hmf,
    MFENUMPROC lpMetaFunc,
    LPARAM     lParam
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumMetaFile");

    return ORIGINAL_API(EnumMetaFile)(hdc, hmf, lpMetaFunc, lParam);
}

int
APIHOOK(EnumMetaFileProc)(
    HDC         hDC,
    HANDLETABLE *lpHTable,
    METARECORD  *lpMFR,
    int         nObj,
    LPARAM      lpClientData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: EnumMetaFileProc");

    return ORIGINAL_API(EnumMetaFileProc)(hDC, lpHTable, lpMFR, nObj, lpClientData);
}

BOOL
APIHOOK(FixBrushOrgEx)(
    HDC     hdc,
    int     nUnknown1,
    int     nUnknown2,
    LPPOINT lpPoint
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: FixBrushOrgEx");

    return ORIGINAL_API(FixBrushOrgEx)(hdc, nUnknown1, nUnknown2, lpPoint);
}

BOOL
APIHOOK(FloodFill)(
    HDC      hdc,
    int      nXStart,
    int      nYStart,
    COLORREF crFill
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: FloodFill");

    return ORIGINAL_API(FloodFill)(hdc, nXStart, nYStart, crFill);
}

BOOL
APIHOOK(FreeResource)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: FreeResource");

    return ORIGINAL_API(FreeResource)(hMem);
}

LONG
APIHOOK(GetBitmapBits)(
    HBITMAP hbmp,
    LONG    cbBuffer,
    LPVOID  lpvBits
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetBitmapBits");

    return ORIGINAL_API(GetBitmapBits)(hbmp, cbBuffer, lpvBits);
}

BOOL
APIHOOK(GetCharWidthA)(
    HDC   hdc,
    UINT  iFirstChar,
    UINT  iLastChar,
    LPINT lpBuffer
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetCharWidthA");

    return ORIGINAL_API(GetCharWidthA)(hdc, iFirstChar, iLastChar, lpBuffer);
}

BOOL
APIHOOK(GetCharWidthW)(
    HDC   hdc,
    UINT  iFirstChar,
    UINT  iLastChar,
    LPINT lpBuffer
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetCharWidthW");

    return ORIGINAL_API(GetCharWidthW)(hdc, iFirstChar, iLastChar, lpBuffer);
}

WORD
APIHOOK(GetClassWord)(
    HWND hWnd,
    int  nIndex
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetClassWord");

    return ORIGINAL_API(GetClassWord)(hWnd, nIndex);
}

UINT
APIHOOK(GetKBCodePage)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetKBCodePage");

    return ORIGINAL_API(GetKBCodePage)();
}

HMETAFILE
APIHOOK(GetMetaFileA)(
    LPCSTR lpszString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetMetaFileA");

    return ORIGINAL_API(GetMetaFileA)(lpszString);
}

HMETAFILE
APIHOOK(GetMetaFileW)(
    LPCWSTR lpszString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetMetaFileW");

    return ORIGINAL_API(GetMetaFileW)(lpszString);
}

UINT
APIHOOK(GetMetaFileBitsEx)(
    HMETAFILE hmf,
    UINT      nSize,
    LPVOID    lpvData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetMetaFileBitsEx");

    return ORIGINAL_API(GetMetaFileBitsEx)(hmf, nSize, lpvData);
}

UINT
APIHOOK(GetPrivateProfileIntA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT    nDefault,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileIntA");

    return ORIGINAL_API(GetPrivateProfileIntA)(lpAppName, lpKeyName, nDefault, lpFileName);
}

UINT
APIHOOK(GetPrivateProfileIntW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileIntW");

    return ORIGINAL_API(GetPrivateProfileIntW)(lpAppName, lpKeyName, nDefault, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionA)(
    LPCSTR lpAppName,       
    LPSTR  lpReturnedString,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionA");

    return ORIGINAL_API(GetPrivateProfileSectionA)(lpAppName, lpReturnedString, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionW)(
    LPCWSTR lpAppName,       
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionW");

    return ORIGINAL_API(GetPrivateProfileSectionW)(lpAppName, lpReturnedString, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionNamesA)(
    LPSTR  lpszReturnBuffer,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionNamesA");

    return ORIGINAL_API(GetPrivateProfileSectionNamesA)(lpszReturnBuffer, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileSectionNamesW)(
    LPWSTR  lpszReturnBuffer,
    DWORD   nSize,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileSectionNamesW");

    return ORIGINAL_API(GetPrivateProfileSectionNamesW)(lpszReturnBuffer, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileStringA)(
    LPCSTR lpAppName,       
    LPCSTR lpKeyName,       
    LPCSTR lpDefault,       
    LPSTR  lpReturnedString,
    DWORD  nSize,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStringA");

    return ORIGINAL_API(GetPrivateProfileStringA)(lpAppName, lpKeyName, lpDefault,
                                                  lpReturnedString, nSize, lpFileName);
}

DWORD
APIHOOK(GetPrivateProfileStringW)(
    LPCWSTR lpAppName,       
    LPCWSTR lpKeyName,       
    LPCWSTR lpDefault,       
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStringW");

    return ORIGINAL_API(GetPrivateProfileStringW)(lpAppName, lpKeyName, lpDefault,
                                                  lpReturnedString, nSize, lpFileName);
}

BOOL
APIHOOK(GetPrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT   uSizeStruct,
    LPCSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStructA");

    return ORIGINAL_API(GetPrivateProfileStructA)(lpszSection, lpszKey, lpStruct,
                                                  uSizeStruct, szFile);
}

BOOL
APIHOOK(GetPrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID  lpStruct,
    UINT    uSizeStruct,
    LPCWSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetPrivateProfileStructW");

    return ORIGINAL_API(GetPrivateProfileStructW)(lpszSection, lpszKey, lpStruct,
                                                  uSizeStruct, szFile);
}

UINT
APIHOOK(GetProfileIntA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT    nDefault
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileIntA");

    return ORIGINAL_API(GetProfileIntA)(lpAppName, lpKeyName, nDefault);
}

UINT
APIHOOK(GetProfileIntW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileIntW");

    return ORIGINAL_API(GetProfileIntW)(lpAppName, lpKeyName, nDefault);
}

DWORD
APIHOOK(GetProfileSectionA)(
    LPCSTR lpAppName,
    LPSTR  lpReturnedString,
    DWORD  nSize
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileSectionA");

    return ORIGINAL_API(GetProfileSectionA)(lpAppName, lpReturnedString, nSize);
}

DWORD
APIHOOK(GetProfileSectionW)(
    LPCWSTR lpAppName,
    LPWSTR  lpReturnedString,
    DWORD   nSize
  )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileSectionW");

    return ORIGINAL_API(GetProfileSectionW)(lpAppName, lpReturnedString, nSize);
}

DWORD
APIHOOK(GetProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR  lpReturnedString,
    DWORD  nSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileStringA");

    return ORIGINAL_API(GetProfileStringA)(lpAppName, lpKeyName, lpDefault,
                                           lpReturnedString, nSize);
}

DWORD
APIHOOK(GetProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetProfileStringW");

    return ORIGINAL_API(GetProfileStringW)(lpAppName, lpKeyName, lpDefault,
                                           lpReturnedString, nSize);
}

HWND
APIHOOK(GetSysModalWindow)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetSysModalWindow");

    return ORIGINAL_API(GetSysModalWindow)();
}

BOOL
APIHOOK(GetTextExtentPointA)(
    HDC    hdc,
    LPCSTR lpString,
    int    cbString,
    LPSIZE lpSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetTextExtentPointA");

    return ORIGINAL_API(GetTextExtentPointA)(hdc, lpString, cbString, lpSize);
}

BOOL
APIHOOK(GetTextExtentPointW)(
    HDC     hdc,
    LPCWSTR lpString,
    int     cbString,
    LPSIZE  lpSize
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetTextExtentPointW");

    return ORIGINAL_API(GetTextExtentPointW)(hdc, lpString, cbString, lpSize);
}

WORD
APIHOOK(GetWindowWord)(
    HWND hWnd,
    int  nUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GetWindowWord");

    return ORIGINAL_API(GetWindowWord)(hWnd, nUnknown);
}

HGLOBAL
APIHOOK(GlobalAlloc)(
    UINT   uFlags,
    SIZE_T dwBytes
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalAlloc");

    return ORIGINAL_API(GlobalAlloc)(uFlags, dwBytes);
}

DWORD
APIHOOK(GlobalCompact)(
    DWORD dwUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalCompact");

    return ORIGINAL_API(GlobalCompact)(dwUnknown);
}

void
APIHOOK(GlobalFix)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalFix");

    return ORIGINAL_API(GlobalFix)(hMem);
}

UINT
APIHOOK(GlobalFlags)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalFlags");

    return ORIGINAL_API(GlobalFlags)(hMem);
}

HGLOBAL
APIHOOK(GlobalFree)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalFree");

    return ORIGINAL_API(GlobalFree)(hMem);
}

HGLOBAL
APIHOOK(GlobalHandle)(
    LPCVOID pMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalHandle");

    return ORIGINAL_API(GlobalHandle)(pMem);
}

LPVOID
APIHOOK(GlobalLock)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalLock");

    return ORIGINAL_API(GlobalLock)(hMem);
}

HGLOBAL
APIHOOK(GlobalReAlloc)(
    HGLOBAL hMem,
    SIZE_T  dwBytes,
    UINT    uFlags
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalReAlloc");

    return ORIGINAL_API(GlobalReAlloc)(hMem, dwBytes, uFlags);
}

SIZE_T
APIHOOK(GlobalSize)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalSize");

    return ORIGINAL_API(GlobalSize)(hMem);
}

void
APIHOOK(GlobalUnfix)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalUnfix");

    return ORIGINAL_API(GlobalUnfix)(hMem);
}

BOOL
APIHOOK(GlobalUnlock)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalUnlock");

    return ORIGINAL_API(GlobalUnlock)(hMem);
}

BOOL
APIHOOK(GlobalUnWire)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalUnWire");

    return ORIGINAL_API(GlobalUnWire)(hMem);
}

char FAR*
APIHOOK(GlobalWire)(
    HGLOBAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: GlobalWire");

    return ORIGINAL_API(GlobalWire)(hMem);
}

BOOL
APIHOOK(IsBadHugeReadPtr)(
    const void _huge* lp,
    DWORD cb
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: IsBadHugeReadPtr");

    return ORIGINAL_API(IsBadHugeReadPtr)(lp, cb);
}

BOOL
APIHOOK(IsBadHugeWritePtr)(
    const void _huge* lp,
    DWORD cb
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: IsBadHugeWritePtr");

    return ORIGINAL_API(IsBadHugeWritePtr)(lp, cb);
}

DWORD
APIHOOK(LoadModule)(
    LPCSTR lpModuleName,
    LPVOID lpParameterBlock
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LoadModule");

    return ORIGINAL_API(LoadModule)(lpModuleName, lpParameterBlock);
}

HLOCAL
APIHOOK(LocalAlloc)(
    UINT   uFlags,
    SIZE_T uBytes
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalAlloc");

    return ORIGINAL_API(LocalAlloc)(uFlags, uBytes);
}

UINT
APIHOOK(LocalCompact)(
    UINT uUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalCompact");

    return ORIGINAL_API(LocalCompact)(uUnknown);
}

HLOCAL
APIHOOK(LocalDiscard)(
    HLOCAL hlocMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalDiscard");

    return ORIGINAL_API(LocalDiscard)(hlocMem);
}

UINT
APIHOOK(LocalFlags)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalFlags");

    return ORIGINAL_API(LocalFlags)(hMem);
}

HLOCAL
APIHOOK(LocalFree)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalFree");

    return ORIGINAL_API(LocalFree)(hMem);
}

HLOCAL
APIHOOK(LocalHandle)(
    LPCVOID pMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalHandle");

    return ORIGINAL_API(LocalHandle)(pMem);
}

LPVOID
APIHOOK(LocalLock)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalLock");

    return ORIGINAL_API(LocalLock)(hMem);
}

HLOCAL
APIHOOK(LocalReAlloc)(
    HLOCAL hMem,
    SIZE_T uBytes,
    UINT   uFlags
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalReAlloc");

    return ORIGINAL_API(LocalReAlloc)(hMem, uBytes, uFlags);
}

UINT
APIHOOK(LocalShrink)(
    HLOCAL hMem,
    UINT   uUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalShrink");

    return ORIGINAL_API(LocalShrink)(hMem, uUnknown);
}

UINT
APIHOOK(LocalSize)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalSize");

    return ORIGINAL_API(LocalSize)(hMem);
}

BOOL
APIHOOK(LocalUnlock)(
    HLOCAL hMem
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LocalUnlock");

    return ORIGINAL_API(LocalUnlock)(hMem);
}

void
APIHOOK(LZDone)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LZDone");

    return ORIGINAL_API(LZDone)();
}

int
APIHOOK(LZStart)(
    void
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: LZStart");

    return ORIGINAL_API(LZStart)();
}

HFILE
APIHOOK(OpenFile)(
    LPCSTR     lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT       uStyle
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: OpenFile");

    return ORIGINAL_API(OpenFile)(lpFileName, lpReOpenBuff, uStyle);
}

BOOL
APIHOOK(PlayMetaFile)(
    HDC       hdc,
    HMETAFILE hmf
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PlayMetaFile");

    return ORIGINAL_API(PlayMetaFile)(hdc, hmf);
}

BOOL
APIHOOK(PlayMetaFileRecord)(
    HDC           hdc,
    LPHANDLETABLE lpHandletable,
    LPMETARECORD  lpMetaRecord,
    UINT          nHandles
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PlayMetaFileRecord");

    return ORIGINAL_API(PlayMetaFileRecord)(hdc, lpHandletable, lpMetaRecord, nHandles);
}

DWORD
APIHOOK(PrinterMessageBoxA)(
    HANDLE hPrinter,
    DWORD  Error,
    HWND   hWnd,
    LPSTR  pText,
    LPSTR  pCaption,
    DWORD  dwType
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PrinterMessageBoxA");

    return ORIGINAL_API(PrinterMessageBoxA)(hPrinter, Error, hWnd, pText, pCaption, dwType);
}

DWORD
APIHOOK(PrinterMessageBoxW)(
    HANDLE hPrinter,
    DWORD  Error,
    HWND   hWnd,
    LPWSTR  pText,
    LPWSTR  pCaption,
    DWORD  dwType
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: PrinterMessageBoxW");

    return ORIGINAL_API(PrinterMessageBoxW)(hPrinter, Error, hWnd, pText, pCaption, dwType);
}

LONG
APIHOOK(RegCreateKeyA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    PHKEY  phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegCreateKeyA");

    return ORIGINAL_API(RegCreateKeyA)(hKey, lpSubKey, phkResult);
}

LONG
APIHOOK(RegCreateKeyW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    PHKEY   phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegCreateKeyW");

    return ORIGINAL_API(RegCreateKeyW)(hKey, lpSubKey, phkResult);
}

LONG
APIHOOK(RegEnumKeyA)(
    HKEY  hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cchName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegEnumKeyA");

    return ORIGINAL_API(RegEnumKeyA)(hKey, dwIndex, lpName, cchName);
}

LONG
APIHOOK(RegEnumKeyW)(
    HKEY   hKey,
    DWORD  dwIndex,
    LPWSTR lpName,
    DWORD  cchName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegEnumKeyW");

    return ORIGINAL_API(RegEnumKeyW)(hKey, dwIndex, lpName, cchName);
}

LONG 
APIHOOK(RegOpenKeyA)(
    HKEY  hKey,         
    LPSTR lpSubKey,  
    PHKEY phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegOpenKeyA");

    return ORIGINAL_API(RegOpenKeyA)(hKey, lpSubKey, phkResult);
}

LONG 
APIHOOK(RegOpenKeyW)(
    HKEY   hKey,         
    LPWSTR lpSubKey,  
    PHKEY  phkResult
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegOpenKeyW");

    return ORIGINAL_API(RegOpenKeyW)(hKey, lpSubKey, phkResult);
}

LONG 
APIHOOK(RegQueryValueA)(
    HKEY   hKey,
    LPCSTR lpSubKey,
    LPSTR  lpValue,
    PLONG  lpcbValue
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegQueryValueA");

    return ORIGINAL_API(RegQueryValueA)(hKey, lpSubKey, lpValue, lpcbValue);
}

LONG 
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR lpSubKey,
    LPWSTR  lpValue,
    PLONG   lpcbValue
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegQueryValueW");

    return ORIGINAL_API(RegQueryValueW)(hKey, lpSubKey, lpValue, lpcbValue);
}

LONG      
APIHOOK(RegSetValueA)(
    HKEY   hKey, 
    LPCSTR lpSubKey, 
    DWORD  dwType, 
    LPCSTR lpData, 
    DWORD  cbData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegSetValueA");

    return ORIGINAL_API(RegSetValueA)(hKey, lpSubKey, dwType, lpData, cbData);
}

LONG      
APIHOOK(RegSetValueW)(
    HKEY    hKey, 
    LPCWSTR lpSubKey, 
    DWORD   dwType, 
    LPCWSTR lpData, 
    DWORD   cbData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: RegSetValueW");

    return ORIGINAL_API(RegSetValueW)(hKey, lpSubKey, dwType, lpData, cbData);
}

LONG
APIHOOK(SetBitmapBits)(
    HBITMAP    hbmp,
    DWORD      cBytes,
    CONST VOID *lpBits
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetBitmapBits");

    return ORIGINAL_API(SetBitmapBits)(hbmp, cBytes, lpBits);
}

WORD
APIHOOK(SetClassWord)(
    HWND hWnd,
    int  nIndex,
    WORD wNewWord
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetClassWord");

    return ORIGINAL_API(SetClassWord)(hWnd, nIndex, wNewWord);
}

void
APIHOOK(SetDebugErrorLevel)(
    DWORD dwLevel
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetDebugErrorLevel");

    return ORIGINAL_API(SetDebugErrorLevel)(dwLevel);
}

BOOL
APIHOOK(SetMessageQueue)(
    int nUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetMessageQueue");

    return ORIGINAL_API(SetMessageQueue)(nUnknown);
}

HMETAFILE
APIHOOK(SetMetaFileBitsEx)(
    UINT       nSize,
    CONST BYTE *lpData
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetMetaFileBitsEx");

    return ORIGINAL_API(SetMetaFileBitsEx)(nSize, lpData);
}

HWND
APIHOOK(SetSysModalWindow)(
    HWND hWnd
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetSysModalWindow");

    return ORIGINAL_API(SetSysModalWindow)(hWnd);
}

HHOOK
APIHOOK(SetWindowsHookA)(
    int      idHook,
    HOOKPROC lpfn
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetWindowsHookA");

    return ORIGINAL_API(SetWindowsHookA)(idHook, lpfn);
}

HHOOK
APIHOOK(SetWindowsHookW)(
    int      idHook,
    HOOKPROC lpfn
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetWindowsHookW");

    return ORIGINAL_API(SetWindowsHookW)(idHook, lpfn);
}

WORD
APIHOOK(SetWindowWord)(
    HWND hWnd,
    int  nUnknown,
    WORD wUnknown
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: SetWindowWord");

    return ORIGINAL_API(SetWindowWord)(hWnd, nUnknown, wUnknown);
}

BOOL
APIHOOK(UnhookWindowsHook)(
    int      idHook,
    HOOKPROC lpfn
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: UnhookWindowsHook");

    return ORIGINAL_API(UnhookWindowsHook)(idHook, lpfn);
}

DWORD
APIHOOK(WaitForPrinterChange)(
    HANDLE hPrinter,
    DWORD  Flags
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WaitForPrinterChange");

    return ORIGINAL_API(WaitForPrinterChange)(hPrinter, Flags);
}

UINT
APIHOOK(WinExec)(
    LPCSTR lpCmdLine,
    UINT   uCmdShow
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WinExec");

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}

DWORD
APIHOOK(WNetAddConnectionA)(
    LPCSTR lpRemoteName,
    LPCSTR lpPassword,
    LPCSTR lpLocalName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WNetAddConnectionA");

    return ORIGINAL_API(WNetAddConnectionA)(lpRemoteName, lpPassword, lpLocalName);
}

DWORD
APIHOOK(WNetAddConnectionW)(
    LPCWSTR lpRemoteName,
    LPCWSTR lpPassword,
    LPCWSTR lpLocalName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WNetAddConnectionW");

    return ORIGINAL_API(WNetAddConnectionW)(lpRemoteName, lpPassword, lpLocalName);
}

BOOL
APIHOOK(WritePrivateProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileSectionA");

    return ORIGINAL_API(WritePrivateProfileSectionA)(lpAppName, lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileSectionW");

    return ORIGINAL_API(WritePrivateProfileSectionW)(lpAppName, lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStringA");

    return ORIGINAL_API(WritePrivateProfileStringA)(lpAppName, lpKeyName,
                                                    lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStringW");

    return ORIGINAL_API(WritePrivateProfileStringW)(lpAppName, lpKeyName,
                                                    lpString, lpFileName);
}

BOOL
APIHOOK(WritePrivateProfileStructA)(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID lpStruct,
    UINT   uSizeStruct,
    LPCSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStructA");

    return ORIGINAL_API(WritePrivateProfileStructA)(lpszSection, lpszKey, lpStruct,
                                                    uSizeStruct, szFile);
}

BOOL
APIHOOK(WritePrivateProfileStructW)(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID  lpStruct,
    UINT    uSizeStruct,
    LPCWSTR szFile
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WritePrivateProfileStructW");

    return ORIGINAL_API(WritePrivateProfileStructW)(lpszSection, lpszKey, lpStruct,
                                                    uSizeStruct, szFile);
}

BOOL
APIHOOK(WriteProfileSectionA)(
    LPCSTR lpAppName,
    LPCSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileSectionA");

    return ORIGINAL_API(WriteProfileSectionA)(lpAppName, lpString);
}

BOOL
APIHOOK(WriteProfileSectionW)(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileSectionW");

    return ORIGINAL_API(WriteProfileSectionW)(lpAppName, lpString);
}

BOOL
APIHOOK(WriteProfileStringA)(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileStringA");

    return ORIGINAL_API(WriteProfileStringA)(lpAppName, lpKeyName, lpString);
}

BOOL
APIHOOK(WriteProfileStringW)(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    )
{
    VLOG(VLOG_LEVEL_WARNING, VLOG_OBSOLETECALLS_API, "API: WriteProfileStringW");

    return ORIGINAL_API(WriteProfileStringW)(lpAppName, lpKeyName, lpString);
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_OBSOLETECALLS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_OBSOLETECALLS_FRIENDLY)
    SHIM_INFO_FLAGS(AVRF_FLAG_NO_WIN2K | AVRF_FLAG_EXTERNAL_ONLY)
    SHIM_INFO_VERSION(2, 0)
    
SHIM_INFO_END()

/*++

 Register hooked functions

--*/

HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_OBSOLETECALLS_API, 
                            AVS_OBSOLETECALLS_API,
                            AVS_OBSOLETECALLS_API_R,
                            AVS_OBSOLETECALLS_API_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                                 _hread)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _hwrite)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _lclose)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _lcreat)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _llseek)
    APIHOOK_ENTRY(KERNEL32.DLL,                                 _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL,                                 _lread)
    APIHOOK_ENTRY(KERNEL32.DLL,                                _lwrite)
    APIHOOK_ENTRY(USER32.DLL,                                 AnyPopup)
    APIHOOK_ENTRY(GDI32.DLL,                             CloseMetaFile)
    APIHOOK_ENTRY(LZ32.DLL,                                 CopyLZFile)
    APIHOOK_ENTRY(GDI32.DLL,                             CopyMetaFileA)
    APIHOOK_ENTRY(GDI32.DLL,                             CopyMetaFileW)
    APIHOOK_ENTRY(GDI32.DLL,                     CreateDIBPatternBrush)
    APIHOOK_ENTRY(GDI32.DLL,                   CreateDiscardableBitmap)
    APIHOOK_ENTRY(GDI32.DLL,                           CreateMetaFileA)
    APIHOOK_ENTRY(GDI32.DLL,                           CreateMetaFileW)
    APIHOOK_ENTRY(GDI32.DLL,                            DeleteMetaFile)
    APIHOOK_ENTRY(GDI32.DLL,                         EnumFontFamiliesA)
    APIHOOK_ENTRY(GDI32.DLL,                         EnumFontFamiliesW)
    APIHOOK_ENTRY(GDI32.DLL,                           EnumFontFamProc)
    APIHOOK_ENTRY(GDI32.DLL,                                EnumFontsA)
    APIHOOK_ENTRY(GDI32.DLL,                                EnumFontsW)
    APIHOOK_ENTRY(GDI32.DLL,                             EnumFontsProc)
    APIHOOK_ENTRY(GDI32.DLL,                              EnumMetaFile)
    APIHOOK_ENTRY(GDI32.DLL,                          EnumMetaFileProc)
    APIHOOK_ENTRY(GDI32.DLL,                             FixBrushOrgEx)
    APIHOOK_ENTRY(GDI32.DLL,                                 FloodFill)
    APIHOOK_ENTRY(KERNEL32.DLL,                           FreeResource)
    APIHOOK_ENTRY(GDI32.DLL,                             GetBitmapBits)
    APIHOOK_ENTRY(GDI32.DLL,                             GetCharWidthA)
    APIHOOK_ENTRY(GDI32.DLL,                             GetCharWidthW)
    APIHOOK_ENTRY(USER32.DLL,                             GetClassWord)
    APIHOOK_ENTRY(USER32.DLL,                            GetKBCodePage)
    APIHOOK_ENTRY(GDI32.DLL,                              GetMetaFileA)
    APIHOOK_ENTRY(GDI32.DLL,                              GetMetaFileW)
    APIHOOK_ENTRY(GDI32.DLL,                         GetMetaFileBitsEx)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetPrivateProfileIntA)
    APIHOOK_ENTRY(KERNEL32.DLL,                  GetPrivateProfileIntW)
    APIHOOK_ENTRY(KERNEL32.DLL,              GetPrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,              GetPrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileSectionNamesA)
    APIHOOK_ENTRY(KERNEL32.DLL,         GetPrivateProfileSectionNamesW)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,               GetPrivateProfileStructW)
    APIHOOK_ENTRY(KERNEL32.DLL,                         GetProfileIntA)
    APIHOOK_ENTRY(KERNEL32.DLL,                         GetProfileIntW)
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     GetProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      GetProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      GetProfileStringW)
    APIHOOK_ENTRY(USER32.DLL,                        GetSysModalWindow)
    APIHOOK_ENTRY(GDI32.DLL,                       GetTextExtentPointA)
    APIHOOK_ENTRY(GDI32.DLL,                       GetTextExtentPointW)
    APIHOOK_ENTRY(USER32.DLL,                            GetWindowWord)
    APIHOOK_ENTRY(KERNEL32.DLL,                            GlobalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                          GlobalCompact)
    APIHOOK_ENTRY(KERNEL32.DLL,                              GlobalFix)
    APIHOOK_ENTRY(KERNEL32.DLL,                            GlobalFlags)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalFree)
    APIHOOK_ENTRY(KERNEL32.DLL,                           GlobalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalLock)
    APIHOOK_ENTRY(KERNEL32.DLL,                          GlobalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalSize)
    APIHOOK_ENTRY(KERNEL32.DLL,                            GlobalUnfix)
    APIHOOK_ENTRY(KERNEL32.DLL,                           GlobalUnlock)
    APIHOOK_ENTRY(KERNEL32.DLL,                           GlobalUnWire)
    APIHOOK_ENTRY(KERNEL32.DLL,                             GlobalWire)
    APIHOOK_ENTRY(KERNEL32.DLL,                       IsBadHugeReadPtr)
    APIHOOK_ENTRY(KERNEL32.DLL,                      IsBadHugeWritePtr)
    APIHOOK_ENTRY(KERNEL32.DLL,                             LoadModule)
    APIHOOK_ENTRY(KERNEL32.DLL,                             LocalAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                           LocalCompact)
    APIHOOK_ENTRY(KERNEL32.DLL,                           LocalDiscard)
    APIHOOK_ENTRY(KERNEL32.DLL,                             LocalFlags)
    APIHOOK_ENTRY(KERNEL32.DLL,                              LocalFree)
    APIHOOK_ENTRY(KERNEL32.DLL,                            LocalHandle)
    APIHOOK_ENTRY(KERNEL32.DLL,                              LocalLock)
    APIHOOK_ENTRY(KERNEL32.DLL,                           LocalReAlloc)
    APIHOOK_ENTRY(KERNEL32.DLL,                            LocalShrink)
    APIHOOK_ENTRY(KERNEL32.DLL,                              LocalSize)
    APIHOOK_ENTRY(KERNEL32.DLL,                            LocalUnlock)
    APIHOOK_ENTRY(LZ32.DLL,                                     LZDone)
    APIHOOK_ENTRY(LZ32.DLL,                                    LZStart)
    APIHOOK_ENTRY(KERNEL32.DLL,                               OpenFile)
    APIHOOK_ENTRY(GDI32.DLL,                              PlayMetaFile)
    APIHOOK_ENTRY(GDI32.DLL,                        PlayMetaFileRecord)
    APIHOOK_ENTRY(WINSPOOL.DRV,                     PrinterMessageBoxA)
    APIHOOK_ENTRY(WINSPOOL.DRV,                     PrinterMessageBoxW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                          RegCreateKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                          RegCreateKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegEnumKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegEnumKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                            RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                         RegQueryValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                         RegQueryValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                           RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                           RegSetValueW)
    APIHOOK_ENTRY(GDI32.DLL,                             SetBitmapBits)
    APIHOOK_ENTRY(USER32.DLL,                             SetClassWord)
    APIHOOK_ENTRY(USER32.DLL,                       SetDebugErrorLevel)
    APIHOOK_ENTRY(USER32.DLL,                          SetMessageQueue)
    APIHOOK_ENTRY(GDI32.DLL,                         SetMetaFileBitsEx)
    APIHOOK_ENTRY(USER32.DLL,                        SetSysModalWindow)
    APIHOOK_ENTRY(USER32.DLL,                          SetWindowsHookA)
    APIHOOK_ENTRY(USER32.DLL,                          SetWindowsHookW)
    APIHOOK_ENTRY(USER32.DLL,                            SetWindowWord)
    APIHOOK_ENTRY(USER32.DLL,                        UnhookWindowsHook)
    APIHOOK_ENTRY(WINSPOOL.DRV,                   WaitForPrinterChange)
    APIHOOK_ENTRY(KERNEL32.DLL,                                WinExec)
    APIHOOK_ENTRY(MPR.DLL,                          WNetAddConnectionA)
    APIHOOK_ENTRY(MPR.DLL,                          WNetAddConnectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,            WritePrivateProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,            WritePrivateProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStringW)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStructA)
    APIHOOK_ENTRY(KERNEL32.DLL,             WritePrivateProfileStructW)
    APIHOOK_ENTRY(KERNEL32.DLL,                   WriteProfileSectionA)
    APIHOOK_ENTRY(KERNEL32.DLL,                   WriteProfileSectionW)
    APIHOOK_ENTRY(KERNEL32.DLL,                    WriteProfileStringA)
    APIHOOK_ENTRY(KERNEL32.DLL,                    WriteProfileStringW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\precomp.h ===
#ifndef _VFSHIMS_PRECOMP_H_
#define _VFSHIMS_PRECOMP_H_

#include "ShimHook.h"

using namespace ShimLib;

#include "VerifLog.h"
#include "ids.h"
#include "strsafe.h"

#endif // _VFSHIMS_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\main.cpp ===
/*++

 Copyright (c) 2000 Microsoft Corporation

 Module Name:

    Main.cpp

 Abstract:

    Container for all verifier shims definitions.

 History:

    01/25/2000 clupu Created

--*/

#include "precomp.h"
#include "ShimHookMacro.h"
#include "veriflog.h"
#include "ids.h"

DECLARE_SHIM(FilePaths)
DECLARE_SHIM(HighVersionLie)
DECLARE_SHIM(RegistryChecks)
DECLARE_SHIM(LogStartAndStop)
DECLARE_SHIM(WindowsFileProtection)
DECLARE_SHIM(DXFileVersionInfo)
DECLARE_SHIM(LogRegistryChanges)
DECLARE_SHIM(LogFileChanges)
DECLARE_SHIM(ObsoleteAPICalls)
DECLARE_SHIM(KernelModeDriverInstall)
DECLARE_SHIM(SecurityChecks)

VOID MULTISHIM_NOTIFY_FUNCTION()(DWORD fdwReason)
{
    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:
            
            DPF("VerifierShims", eDbgLevelSpew, "Verifier Shims initialized.");
            break;
    
        case DLL_PROCESS_DETACH:
            DPF("VerifierShims", eDbgLevelSpew, "Verifier Shims uninitialized.");
            break;

        case SHIM_PROCESS_DYING:
            //
            // Push our DLL to be the last one to be unloaded.
            //
            MakeShimUnloadLast(NULL);
            break;
        default:
            break;
    }
}

MULTISHIM_BEGIN()
    
    INIT_VLOG_SUPPORT()

    MULTISHIM_ENTRY(LogStartAndStop)
    MULTISHIM_ENTRY(FilePaths)
    MULTISHIM_ENTRY(HighVersionLie)
    MULTISHIM_ENTRY(RegistryChecks)
    MULTISHIM_ENTRY(WindowsFileProtection)
    MULTISHIM_ENTRY(DXFileVersionInfo)
    MULTISHIM_ENTRY(LogRegistryChanges)
    MULTISHIM_ENTRY(LogFileChanges)
    MULTISHIM_ENTRY(ObsoleteAPICalls)
    MULTISHIM_ENTRY(KernelModeDriverInstall)
    MULTISHIM_ENTRY(SecurityChecks)

    CALL_MULTISHIM_NOTIFY_FUNCTION()
MULTISHIM_END()

DECLARE_VERIFIER_DLL()

DECLARE_VERIFIER_SHIM(LogStartAndStop)
DECLARE_VERIFIER_SHIM(FilePaths)
DECLARE_VERIFIER_SHIM(HighVersionLie)
DECLARE_VERIFIER_SHIM(RegistryChecks)
DECLARE_VERIFIER_SHIM(WindowsFileProtection)
DECLARE_VERIFIER_SHIM(DXFileVersionInfo)
DECLARE_VERIFIER_SHIM(LogRegistryChanges)
DECLARE_VERIFIER_SHIM(LogFileChanges)
DECLARE_VERIFIER_SHIM(ObsoleteAPICalls)
DECLARE_VERIFIER_SHIM(KernelModeDriverInstall)
DECLARE_VERIFIER_SHIM(SecurityChecks)

ENUM_VERIFIER_SHIMS_BEGIN()

    ENUM_VERIFIER_SHIMS_ENTRY(LogStartAndStop)
    ENUM_VERIFIER_SHIMS_ENTRY(FilePaths)
    ENUM_VERIFIER_SHIMS_ENTRY(HighVersionLie)
    ENUM_VERIFIER_SHIMS_ENTRY(RegistryChecks)
    ENUM_VERIFIER_SHIMS_ENTRY(WindowsFileProtection)
    ENUM_VERIFIER_SHIMS_ENTRY(DXFileVersionInfo)
    ENUM_VERIFIER_SHIMS_ENTRY(LogRegistryChanges)
    ENUM_VERIFIER_SHIMS_ENTRY(LogFileChanges)
    ENUM_VERIFIER_SHIMS_ENTRY(ObsoleteAPICalls)
    ENUM_VERIFIER_SHIMS_ENTRY(KernelModeDriverInstall)
    ENUM_VERIFIER_SHIMS_ENTRY(SecurityChecks)

ENUM_VERIFIER_SHIMS_END()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

!ENDIF

DLLDEF=..\verifier.def

TARGETTYPE=DYNLINK

SOURCES=..\verifier.rc                             \
        ..\Main.cpp                                \
        ..\HighVersionLie.cpp                      \
        ..\SecurityChecks.cpp                      \
        ..\ObsoleteAPICalls.cpp                    \
        ..\FilePaths.cpp                           \
        ..\LogStartAndStop.cpp                     \
        ..\RegistryChecks.cpp                      \
        ..\WindowsFileProtection.cpp               \
        ..\DXFileVersionInfo.cpp                   \
        ..\LogRegistryChanges.cpp                  \
        ..\LogFileChanges.cpp                      \
        ..\KernelModeDriverInstall.cpp             \

C_DEFINES=$(C_DEFINES) -DSHIM_HOOKDLL_VERSION2

TARGETPATH=$(_OBJ_DIR)

INCLUDES=$(INCLUDES);                               \
         ..

TARGETLIBS=$(TARGETLIBS)                                                \
           $(WINDOWS_LIB_PATH)\avrflib.lib                              \
           $(SDBAPI_PATH)\lib\$(O)\sdbapil.lib                          \
           $(SDK_LIB_PATH)\shell32.lib                                  \
           $(SDK_LIB_PATH)\advapi32.lib                                 \
           $(SDK_LIB_PATH)\user32.lib                                   \
           $(SDK_LIB_PATH)\ntdll.lib                                    \
           $(SDK_LIB_PATH)\sfc.lib                                      \
           $(SDK_LIB_PATH)\version.lib

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\registrychecks.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

    RegistryChecks.cpp

 Abstract:
    Warn the app when it's trying to read from or write to inappropriate
    places in the registry.

 Notes:

    This is a general purpose shim.

 History:

    03/09/2001  maonis      Created
    09/04/2001  maonis      Since none of the paths we compare with exceed MAX_PATH - 1
                            characters, we only examine at most that many characters of
                            the key paths to make sure there's no buffer overflow in
                            the paths of open keys.
    02/20/2002  rparsons    Implemented strsafe functions.
    02/25/2002  rparsons    Modified critical section code to be thread safe.
--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(RegistryChecks)
#include "ShimHookMacro.h"
#include "RegistryChecks.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(RegistryChecks)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Console_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_ControlPanel_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Environment_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Identities_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_KeyboardLayout_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Printers_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_RemoteAccess_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_SessionInformation_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_UNICODEProgramGroups_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_VolatileEnvironment_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCU_Windows31MigrationStatus_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_HARDWARE_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_SAM_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_SECURITY_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKLM_SYSTEM_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKCC_READ)
    VERIFIER_LOG_ENTRY(VLOG_HKUS_READ)
    VERIFIER_LOG_ENTRY(VLOG_NON_HKCU_WRITE)
END_DEFINE_VERIFIER_LOG(RegistryChecks)

INIT_VERIFIER_LOG(RegistryChecks);


const RCWARNING g_warnNoDirectRead[] =
{
    {HKCU_Console_STR,                  VLOG_HKCU_Console_READ,                 NUM_OF_CHAR(HKCU_Console_STR)},
    {HKCU_ControlPanel_STR,             VLOG_HKCU_ControlPanel_READ,            NUM_OF_CHAR(HKCU_ControlPanel_STR)},
    {HKCU_Environment_STR,              VLOG_HKCU_Environment_READ,             NUM_OF_CHAR(HKCU_Environment_STR)},
    {HKCU_Identities_STR,               VLOG_HKCU_Identities_READ,              NUM_OF_CHAR(HKCU_Identities_STR)},
    {HKCU_KeyboardLayout_STR,           VLOG_HKCU_KeyboardLayout_READ,          NUM_OF_CHAR(HKCU_KeyboardLayout_STR)},
    {HKCU_Printers_STR,                 VLOG_HKCU_Printers_READ,                NUM_OF_CHAR(HKCU_Printers_STR)},
    {HKCU_RemoteAccess_STR,             VLOG_HKCU_RemoteAccess_READ,            NUM_OF_CHAR(HKCU_RemoteAccess_STR)},
    {HKCU_SessionInformation_STR,       VLOG_HKCU_SessionInformation_READ,      NUM_OF_CHAR(HKCU_SessionInformation_STR)},
    {HKCU_UNICODEProgramGroups_STR,     VLOG_HKCU_UNICODEProgramGroups_READ,    NUM_OF_CHAR(HKCU_UNICODEProgramGroups_STR)},
    {HKCU_VolatileEnvironment_STR,      VLOG_HKCU_VolatileEnvironment_READ,     NUM_OF_CHAR(HKCU_VolatileEnvironment_STR)},
    {HKCU_Windows31MigrationStatus_STR, VLOG_HKCU_Windows31MigrationStatus_READ,NUM_OF_CHAR(HKCU_Windows31MigrationStatus_STR)},
    {HKLM_HARDWARE_STR,                 VLOG_HKLM_HARDWARE_READ,                NUM_OF_CHAR(HKLM_HARDWARE_STR)},
    {HKLM_SAM_STR,                      VLOG_HKLM_SAM_READ,                     NUM_OF_CHAR(HKLM_SAM_STR)},
    {HKLM_SECURITY_STR,                 VLOG_HKLM_SECURITY_READ,                NUM_OF_CHAR(HKLM_SECURITY_STR)},
    {HKLM_SYSTEM_STR,                   VLOG_HKLM_SYSTEM_READ,                  NUM_OF_CHAR(HKLM_SYSTEM_STR)},
    {HKCC_STR,                          VLOG_HKCC_READ,                         NUM_OF_CHAR(HKCC_STR)},
    {HKUS_STR,                          VLOG_HKUS_READ,                         NUM_OF_CHAR(HKUS_STR)},
};

const UINT g_cWarnNDirectRead = sizeof(g_warnNoDirectRead) / sizeof(RCWARNING);

//
// Critical section that keeps us safe while using linked-lists, etc.
//
CCriticalSection g_csCritSec;

VOID
MakePathW(
    IN RCOPENKEY* key,
    IN HKEY hKey,
    IN LPCWSTR lpSubKey,
    IN OUT LPWSTR lpPath
    )
{
    if (key) {
        if (key->wszPath[0]) {
            //
            // We only care about at most MAX_PATH - 1 characters.
            //
            wcsncpy(lpPath, key->wszPath, MAX_PATH - 1);
        }
    } else {
        if (hKey == HKEY_CLASSES_ROOT) {
            StringCchCopy(lpPath, MAX_PATH - 1, L"HKCR");
        } else if (hKey == HKEY_CURRENT_CONFIG) {
            StringCchCopy(lpPath, MAX_PATH - 1, L"HKCC");
        } else if (hKey == HKEY_CURRENT_USER) {
            StringCchCopy(lpPath, MAX_PATH - 1, L"HKCU");
        } else if (hKey == HKEY_LOCAL_MACHINE) {
            StringCchCopy(lpPath, MAX_PATH - 1, L"HKLM");
        } else if (hKey == HKEY_USERS) {
            StringCchCopy(lpPath, MAX_PATH - 1, L"HKUS");
        } else {
            StringCchCopy(lpPath, MAX_PATH - 1, L"Not recongized");
        }
    }

    if (lpSubKey && *lpSubKey) {
        DWORD cLen = wcslen(lpPath);
        //
        // We only care about at most MAX_PATH - 1 characters.
        //
        if (cLen < MAX_PATH - 1) {
            lpPath[cLen] = L'\\';
            wcsncpy(lpPath + cLen + 1, lpSubKey, MAX_PATH - cLen - 2);
        }
    }

    lpPath[MAX_PATH - 1] = L'\0';
}

VOID CheckReading(
    IN LPCWSTR pwszPath
    )
{
    RCWARNING warn;

    for (UINT ui = 0; ui < g_cWarnNDirectRead; ++ui) {
        warn = g_warnNoDirectRead[ui];
        if (!_wcsnicmp(pwszPath, warn.wszPath, warn.cLen)) {
            VLOG(VLOG_LEVEL_ERROR, warn.dwAVStatus,
                 "Read from dangerous registry entry '%ls'.",
                 pwszPath);
        }
    }
}

// We warn for every tempt of writing to anything besides keys under HKCU.
// Note this applies to both Users and Admins/Power Users because when an
// app is running it shouldn't write anything to non HKCU keys, which should
// be done during the installation time.
VOID CheckWriting(
    IN REGSAM samDesired,
    IN LPCWSTR pwszPath
    )
{
    if ((samDesired &~ STANDARD_RIGHTS_WRITE) & KEY_WRITE) {
        if (_wcsnicmp(pwszPath, L"HKCU", 4)) {
            VLOG(VLOG_LEVEL_ERROR, VLOG_NON_HKCU_WRITE, "Write to non-HKCU registry entry '%ls'.", pwszPath);
        }
    }
}

//
// Implementation of the CRegistryChecks class.
//

RCOPENKEY*
CRegistryChecks::FindKey(
    HKEY hKey
    )
{
    RCOPENKEY* key = keys;

    while (key) {
        if (key->hkBase == hKey) {
            return key;
        }

        key = key->next;
    }

    return NULL;
}

// We add the key to the front of the list because the most
// recently added keys are usually used/deleted first.
BOOL
CRegistryChecks::AddKey(
    HKEY hKey,
    LPCWSTR pwszPath
    )
{
    RCOPENKEY* key = new RCOPENKEY;

    if (!key) {
        return FALSE;
    }

    key->hkBase = hKey;

    //
    // None of the key paths we need to check exceed MAX_PATH - 1 characters so
    // we only need to copy at most that many characters.
    //
    wcsncpy(key->wszPath, pwszPath, MAX_PATH - 1);
    key->wszPath[MAX_PATH - 1] = L'\0';

    key->next = keys;
    keys = key;

    return TRUE;
}

VOID
CRegistryChecks::Check(
    HKEY hKey,
    LPCSTR lpSubKey,
    BOOL fCheckRead,
    BOOL fCheckWrite,
    REGSAM samDesired
    )
{
    LPWSTR pwszSubKey = NULL;

    if (pwszSubKey = ToUnicode(lpSubKey)) {
        Check(hKey, pwszSubKey, fCheckRead, fCheckWrite);
        free(pwszSubKey);
    } else {
        DPFN(eDbgLevelError, "Failed to convert %s to unicode", lpSubKey);
    }
}

VOID
CRegistryChecks::Check(
    HKEY hKey,
    LPCWSTR lpSubKey,
    BOOL fCheckRead,
    BOOL fCheckWrite,
    REGSAM samDesired
    )
{
    RCOPENKEY* key = FindKey(hKey);
    WCHAR wszPath[MAX_PATH] = L"";
    MakePathW(key, hKey, lpSubKey, wszPath);

    if (fCheckRead) {
        CheckReading(wszPath);
    }

    if (fCheckWrite) {
        CheckWriting(samDesired, wszPath);
    }
}

LONG
CRegistryChecks::OpenKeyExOriginalW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    if (bCreate) {
        return ORIGINAL_API(RegCreateKeyExW)(
            hKey,
            lpSubKey,
            0,
            lpClass,
            dwOptions,
            samDesired,
            lpSecurityAttributes,
            phkResult,
            lpdwDisposition);
    } else {
        return ORIGINAL_API(RegOpenKeyExW)(
            hKey,
            lpSubKey,
            0,
            samDesired,
            phkResult);
    }
}

LONG
CRegistryChecks::OpenKeyExA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    LONG lRet;
    LPWSTR pwszSubKey = NULL;
    LPWSTR pwszClass = NULL;

    if (lpSubKey) {
        if (!(pwszSubKey = ToUnicode(lpSubKey))) {
            DPFN(eDbgLevelError, "Failed to convert %s to unicode", lpSubKey);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (lpClass) {
        if (!(pwszClass = ToUnicode(lpClass)))
        {
            free(pwszSubKey);
            DPFN(eDbgLevelError, "Failed to convert %s to unicode", lpClass);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    lRet = OpenKeyExW(
        hKey,
        pwszSubKey,
        pwszClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        bCreate);

    free(pwszSubKey);
    free(pwszClass);

    return lRet;
}

LONG
CRegistryChecks::OpenKeyExW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition,
    BOOL bCreate
    )
{
    RCOPENKEY* key = FindKey(hKey);
    WCHAR wszPath[MAX_PATH] = L"";
    MakePathW(key, hKey, lpSubKey, wszPath);

    CheckReading(wszPath);
    CheckWriting(samDesired, wszPath);

    LONG lRes = OpenKeyExOriginalW(
        hKey,
        lpSubKey,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        bCreate);

    if (lRes == ERROR_SUCCESS) {
        if (AddKey(*phkResult, wszPath)) {
            DPFN(eDbgLevelInfo, "[OpenKeyExW] success - adding key 0x%08X", *phkResult);
        } else {
            lRes = ERROR_INVALID_HANDLE;
        }
    }

    return lRes;
}

LONG
CRegistryChecks::QueryValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    LPSTR lpValue,
    PLONG lpcbValue
    )
{
    Check(hKey, lpSubKey, TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueA)(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG
CRegistryChecks::QueryValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG lpcbValue
    )
{
    Check(hKey, lpSubKey, TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueW)(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG
CRegistryChecks::QueryValueExA(
    HKEY    hKey,
    LPCSTR  lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueExA)(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
CRegistryChecks::QueryValueExW(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryValueExW)(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
CRegistryChecks::QueryInfoKeyA(
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryInfoKeyA)(
        hKey,
        lpClass,
        lpcbClass,
        lpReserved,
        lpcSubKeys,
        lpcbMaxSubKeyLen,
        lpcbMaxClassLen,
        lpcValues,
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG
CRegistryChecks::QueryInfoKeyW(
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegQueryInfoKeyW)(
        hKey,
        lpClass,
        lpcbClass,
        lpReserved,
        lpcSubKeys,
        lpcbMaxSubKeyLen,
        lpcbMaxClassLen,
        lpcValues,
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG
CRegistryChecks::SetValueA(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegSetValueA)(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG
CRegistryChecks::SetValueW(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegSetValueW)(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG
CRegistryChecks::SetValueExA(
    HKEY hKey,
    LPCSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE * lpData,
    DWORD cbData
    )
{
    Check(hKey, L"", FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegSetValueExA)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG
CRegistryChecks::SetValueExW(
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE * lpData,
    DWORD cbData
    )
{
    Check(hKey, L"", FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegSetValueExW)(
        hKey,
        lpValueName,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG
CRegistryChecks::EnumValueA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumValueA)(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

// If the key was not originated from HKCU,
// we enum at the original location.
LONG
CRegistryChecks::EnumValueW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumValueW)(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
CRegistryChecks::EnumKeyExA(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumKeyExA)(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

// If the key was not originated from HKCU,
// we enum at the original location.
LONG
CRegistryChecks::EnumKeyExW(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    Check(hKey, L"", TRUE, FALSE);

    return ORIGINAL_API(RegEnumKeyExW)(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

// Remove the key from the list.
LONG
CRegistryChecks::CloseKey(
    HKEY hKey
    )
{
    RCOPENKEY* key = keys;
    RCOPENKEY* last = NULL;

    while (key) {
        if (key->hkBase == hKey) {
            if (last) {
                last->next = key->next;
            } else {
                keys = key->next;
            }

            delete key;
            break;
        }

        last = key;
        key = key->next;
    }

    DPFN(eDbgLevelInfo, "[CloseKey] closing key 0x%08X", hKey);

    return ORIGINAL_API(RegCloseKey)(hKey);
}

LONG
CRegistryChecks::DeleteKeyA(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegDeleteKeyA)(
        hKey,
        lpSubKey);
}

LONG
CRegistryChecks::DeleteKeyW(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    Check(hKey, lpSubKey, FALSE, TRUE, KEY_WRITE);

    return ORIGINAL_API(RegDeleteKeyW)(
        hKey,
        lpSubKey);
}

CRegistryChecks RRegistry;

//
// Hook APIs.
//

LONG
APIHOOK(RegOpenKeyA)(
    HKEY hKey,
    LPSTR lpSubKey,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExA(
        hKey,
        lpSubKey,
        0,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG
APIHOOK(RegOpenKeyW)(
    HKEY hKey,
    LPWSTR lpSubKey,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExW(
        hKey,
        lpSubKey,
        0,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG
APIHOOK(RegOpenKeyExA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExA(
        hKey,
        lpSubKey,
        0,
        REG_OPTION_NON_VOLATILE,
        samDesired,
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG
APIHOOK(RegOpenKeyExW)(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExW(
        hKey,
        lpSubKey,
        0,
        REG_OPTION_NON_VOLATILE,
        samDesired,
        NULL,
        phkResult,
        NULL,
        FALSE);
}

LONG
APIHOOK(RegCreateKeyA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExA(
        hKey,
        lpSubKey,
        0,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL,
        TRUE);
}

LONG
APIHOOK(RegCreateKeyW)(
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExW(
        hKey,
        lpSubKey,
        0,
        REG_OPTION_NON_VOLATILE,
        MAXIMUM_ALLOWED,
        NULL,
        phkResult,
        NULL,
        TRUE);
}

LONG
APIHOOK(RegCreateKeyExA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExA(
        hKey,
        lpSubKey,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        TRUE);
}

LONG
APIHOOK(RegCreateKeyExW)(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.OpenKeyExW(
        hKey,
        lpSubKey,
        lpClass,
        dwOptions,
        samDesired,
        lpSecurityAttributes,
        phkResult,
        lpdwDisposition,
        TRUE);
}

LONG
APIHOOK(RegQueryValueA)(
    HKEY    hKey,
    LPCSTR  lpSubKey,
    LPSTR lpValue,
    PLONG lpcbValue
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.QueryValueA(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG
APIHOOK(RegQueryValueW)(
    HKEY    hKey,
    LPCWSTR  lpSubKey,
    LPWSTR  lpValue,
    PLONG lpcbValue
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.QueryValueW(
        hKey,
        lpSubKey,
        lpValue,
        lpcbValue);
}

LONG
APIHOOK(RegQueryValueExA)(
    HKEY    hKey,
    LPCSTR   lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.QueryValueExA(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
APIHOOK(RegQueryValueExW)(
    HKEY    hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE  lpData,
    LPDWORD lpcbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.QueryValueExW(
        hKey,
        lpValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
APIHOOK(RegQueryInfoKeyA)(
    HKEY hKey,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.QueryInfoKeyA(
        hKey,
        lpClass,
        lpcbClass,
        lpReserved,
        lpcSubKeys,
        lpcbMaxSubKeyLen,
        lpcbMaxClassLen,
        lpcValues,
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG
APIHOOK(RegQueryInfoKeyW)(
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.QueryInfoKeyW(
        hKey,
        lpClass,
        lpcbClass,
        lpReserved,
        lpcSubKeys,
        lpcbMaxSubKeyLen,
        lpcbMaxClassLen,
        lpcValues,
        lpcbMaxValueNameLen,
        lpcbMaxValueLen,
        lpcbSecurityDescriptor,
        lpftLastWriteTime);
}

LONG
APIHOOK(RegSetValueA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD dwType,
    LPCSTR lpData,
    DWORD cbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.SetValueA(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegSetValueW)(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.SetValueW(
        hKey,
        lpSubKey,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegSetValueExA)(
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE * lpData,
    DWORD cbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.SetValueExA(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegSetValueExW)(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE * lpData,
    DWORD cbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.SetValueExW(
        hKey,
        lpSubKey,
        Reserved,
        dwType,
        lpData,
        cbData);
}

LONG
APIHOOK(RegEnumValueA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.EnumValueA(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
APIHOOK(RegEnumValueW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.EnumValueW(
        hKey,
        dwIndex,
        lpValueName,
        lpcbValueName,
        lpReserved,
        lpType,
        lpData,
        lpcbData);
}

LONG
APIHOOK(RegEnumKeyA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    DWORD cbName
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.EnumKeyExA(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL); // can this be null???
}

LONG
APIHOOK(RegEnumKeyW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.EnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        &cbName,
        NULL,
        NULL,
        NULL,
        NULL);
}

LONG
APIHOOK(RegEnumKeyExA)(
    HKEY hKey,
    DWORD dwIndex,
    LPSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.EnumKeyExA(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG
APIHOOK(RegEnumKeyExW)(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.EnumKeyExW(
        hKey,
        dwIndex,
        lpName,
        lpcbName,
        lpReserved,
        lpClass,
        lpcbClass,
        lpftLastWriteTime);
}

LONG
APIHOOK(RegCloseKey)(HKEY hKey)
{
    CLock   cLock(g_csCritSec);

    return RRegistry.CloseKey(hKey);
}

LONG
APIHOOK(RegDeleteKeyA)(
    HKEY hKey,
    LPCSTR lpSubKey
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.DeleteKeyA(hKey, lpSubKey);
}

LONG
APIHOOK(RegDeleteKeyW)(
    HKEY hKey,
    LPCWSTR lpSubKey
    )
{
    CLock   cLock(g_csCritSec);

    return RRegistry.DeleteKeyW(hKey, lpSubKey);
}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_REGISTRYCHECKS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_REGISTRYCHECKS_FRIENDLY)
    SHIM_INFO_VERSION(1, 3)
    SHIM_INFO_FLAGS(AVRF_FLAG_EXTERNAL_ONLY)
    SHIM_INFO_INCLUDE_EXCLUDE("E:msi.dll sxs.dll comctl32.dll ole32.dll oleaut32.dll")

SHIM_INFO_END()

/*++

 Register hooked functions

 Note we purposely ignore the cleanup because some apps call registry functions
 during process detach.

--*/

HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Console_READ,
                            AVS_HKCU_Console_READ,
                            AVS_HKCU_Console_READ_R,
                            AVS_HKCU_Console_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_ControlPanel_READ,
                            AVS_HKCU_ControlPanel_READ,
                            AVS_HKCU_ControlPanel_READ_R,
                            AVS_HKCU_ControlPanel_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Environment_READ,
                            AVS_HKCU_Environment_READ,
                            AVS_HKCU_Environment_READ_R,
                            AVS_HKCU_Environment_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Identities_READ,
                            AVS_HKCU_Identities_READ,
                            AVS_HKCU_Identities_READ_R,
                            AVS_HKCU_Identities_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_KeyboardLayout_READ,
                            AVS_HKCU_KeyboardLayout_READ,
                            AVS_HKCU_KeyboardLayout_READ_R,
                            AVS_HKCU_KeyboardLayout_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Printers_READ,
                            AVS_HKCU_Printers_READ,
                            AVS_HKCU_Printers_READ_R,
                            AVS_HKCU_Printers_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_RemoteAccess_READ,
                            AVS_HKCU_RemoteAccess_READ,
                            AVS_HKCU_RemoteAccess_READ_R,
                            AVS_HKCU_RemoteAccess_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_SessionInformation_READ,
                            AVS_HKCU_SessionInformation_READ,
                            AVS_HKCU_SessionInformation_READ_R,
                            AVS_HKCU_SessionInformation_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_UNICODEProgramGroups_READ,
                            AVS_HKCU_UNICODEProgramGroups_READ,
                            AVS_HKCU_UNICODEProgramGroups_READ_R,
                            AVS_HKCU_UNICODEProgramGroups_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_VolatileEnvironment_READ,
                            AVS_HKCU_VolatileEnvironment_READ,
                            AVS_HKCU_VolatileEnvironment_READ_R,
                            AVS_HKCU_VolatileEnvironment_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCU_Windows31MigrationStatus_READ,
                            AVS_HKCU_Windows31MigrationStatus_READ,
                            AVS_HKCU_Windows31MigrationStatus_READ_R,
                            AVS_HKCU_Windows31MigrationStatus_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_HARDWARE_READ,
                            AVS_HKLM_HARDWARE_READ,
                            AVS_HKLM_HARDWARE_READ_R,
                            AVS_HKLM_HARDWARE_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_SAM_READ,
                            AVS_HKLM_SAM_READ,
                            AVS_HKLM_SAM_READ_R,
                            AVS_HKLM_SAM_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_SECURITY_READ,
                            AVS_HKLM_SECURITY_READ,
                            AVS_HKLM_SECURITY_READ_R,
                            AVS_HKLM_SECURITY_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKLM_SYSTEM_READ,
                            AVS_HKLM_SYSTEM_READ,
                            AVS_HKLM_SYSTEM_READ_R,
                            AVS_HKLM_SYSTEM_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKCC_READ,
                            AVS_HKCC_READ,
                            AVS_HKCC_READ_R,
                            AVS_HKCC_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_HKUS_READ,
                            AVS_HKUS_READ,
                            AVS_HKUS_READ_R,
                            AVS_HKUS_READ_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_NON_HKCU_WRITE,
                            AVS_NON_HKCU_WRITE,
                            AVS_NON_HKCU_WRITE_R,
                            AVS_NON_HKCU_WRITE_URL)


    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegOpenKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCreateKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegCloseKey)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryValueExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegQueryInfoKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegSetValueExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumValueW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegEnumKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL, RegDeleteKeyW)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\registrychecks.h ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

    RegistryChecks.h

 History:

    03/09/2001 maonis  Created

--*/

#ifndef __APPVERIFIER_REGCHK_H_
#define __APPVERIFIER_REGCHK_H_

#include "precomp.h"

//
// We keep a list of keys currently open so we know where a key is
// originated from.
//
struct RCOPENKEY
{
    RCOPENKEY *next;

    HKEY hkBase;
    WCHAR wszPath[MAX_PATH];
};

struct RCWARNING
{
    WCHAR wszPath[MAX_PATH];
    DWORD dwAVStatus;
    DWORD cLen;
};

#define HKCU_AppEvents_STR                  L"HKCU\\AppEvents"
#define HKCU_Console_STR                    L"HKCU\\Console"
#define HKCU_ControlPanel_STR               L"HKCU\\Control Panel"
#define HKCU_Environment_STR                L"HKCU\\Environment"
#define HKCU_Identities_STR                 L"HKCU\\Identities"
#define HKCU_KeyboardLayout_STR             L"HKCU\\Keyboard Layout"
#define HKCU_Printers_STR                   L"HKCU\\Printers"
#define HKCU_RemoteAccess_STR               L"HKCU\\RemoteAccess"
#define HKCU_SessionInformation_STR         L"HKCU\\SessionInformation"
#define HKCU_UNICODEProgramGroups_STR       L"HKCU\\UNICODE Program Groups"
#define HKCU_VolatileEnvironment_STR        L"HKCU\\Volatile Environment"
#define HKCU_Windows31MigrationStatus_STR   L"HKCU\\Windows 3.1 Migration Status"
#define HKLM_HARDWARE_STR                   L"HKLM\\HARDWARE"
#define HKLM_SAM_STR                        L"HKLM\\SAM"
#define HKLM_SECURITY_STR                   L"HKLM\\SECURITY"
#define HKLM_SYSTEM_STR                     L"HKLM\\SYSTEM"
#define HKCC_STR                            L"HKCC"
#define HKUS_STR                            L"HKUS"

#define NUM_OF_CHAR(x) sizeof(x) / 2 - 1

//
// On Windows 2000, we need to pre-allocate the event
// in RTL_CRITICAL_SECTION. On XP and above, this is
// a no-op.
//
#define PREALLOCATE_EVENT_MASK  0x80000000

//
// Critical section wrapper class.
//
class CCriticalSection
{
private:
    CRITICAL_SECTION m_CritSec;

public:
    CCriticalSection()
    {
        InitializeCriticalSectionAndSpinCount(&m_CritSec,
                                              PREALLOCATE_EVENT_MASK | 4000);
    }

    ~CCriticalSection()
    {
        DeleteCriticalSection(&m_CritSec);
    }

    void Lock()
    {
        EnterCriticalSection(&m_CritSec);
    }

    BOOL TryLock()
    {
        return TryEnterCriticalSection(&m_CritSec);
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_CritSec);
    }
};

//
// Auto-lock class that uses the CCriticalSection class.
//
class CLock
{
private:
    CCriticalSection &m_CriticalSection;

public:
    CLock(CCriticalSection &CriticalSection)
        : m_CriticalSection(CriticalSection)
    {
        m_CriticalSection.Lock();
    }

    ~CLock()
    {
        m_CriticalSection.Unlock();
    }
};

//
// The reg class that does all the real work.
//

class CRegistryChecks
{
public:

    LONG OpenKeyExA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG OpenKeyExW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    LONG QueryValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        LPSTR lpValue,
        PLONG lpcbValue
        );

    LONG QueryValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpValue,
        PLONG lpcbValue
        );

    LONG QueryValueExA(
        HKEY    hKey,
        LPCSTR   lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData
        );

    LONG QueryValueExW(
        HKEY    hKey,
        LPCWSTR   lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData
        );

    LONG QueryInfoKeyA(
        HKEY hKey,
        LPSTR lpClass,
        LPDWORD lpcbClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime
        );

    LONG QueryInfoKeyW(
        HKEY hKey,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime
        );

    LONG SetValueA(
        HKEY hKey,
        LPCSTR lpSubKey,
        DWORD dwType,
        LPCSTR lpData,
        DWORD cbData
        );

    LONG SetValueW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        DWORD dwType,
        LPCWSTR lpData,
        DWORD cbData
        );

    LONG SetValueExA(
        HKEY hKey,
        LPCSTR lpValueName,
        DWORD Reserved,
        DWORD dwType,
        CONST BYTE * lpData,
        DWORD cbData
        );

    LONG SetValueExW(
        HKEY hKey,
        LPCWSTR lpValueName,
        DWORD Reserved,
        DWORD dwType,
        CONST BYTE * lpData,
        DWORD cbData
        );

    LONG EnumValueA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumValueW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpValueName,
        LPDWORD lpcbValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE lpData,
        LPDWORD lpcbData
        );

    LONG EnumKeyExA(
        HKEY hKey,
        DWORD dwIndex,
        LPSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime
        );

    LONG EnumKeyExW(
        HKEY hKey,
        DWORD dwIndex,
        LPWSTR lpName,
        LPDWORD lpcbName,
        LPDWORD lpReserved,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        PFILETIME lpftLastWriteTime
        );

    LONG CloseKey(
        HKEY hKey
        );

    LONG DeleteKeyA(
        HKEY hKey,
        LPCSTR lpSubKey
        );

    LONG DeleteKeyW(
        HKEY hKey,
        LPCWSTR lpSubKey
        );

private:
    RCOPENKEY* FindKey(HKEY hKey);

    BOOL AddKey(
        HKEY hKey,
        LPCWSTR pwszPath
        );

    LONG OpenKeyExOriginalW(
        HKEY hKey,
        LPCWSTR lpSubKey,
        LPWSTR lpClass,
        DWORD dwOptions,
        REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
        PHKEY phkResult,
        LPDWORD lpdwDisposition,
        BOOL bCreate
        );

    VOID Check(
        HKEY hKey,
        LPCSTR lpSubKey,
        BOOL fCheckRead,
        BOOL fCheckWrite,
        REGSAM samDesired = 0
        );

    VOID Check(
        HKEY hKey,
        LPCWSTR lpSubKey,
        BOOL fCheckRead,
        BOOL fCheckWrite,
        REGSAM samDesired = 0
        );

    RCOPENKEY* keys;
};

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(RegOpenKeyA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyW)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExA)
    APIHOOK_ENUM_ENTRY(RegOpenKeyExW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyW)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegCloseKey)
    APIHOOK_ENUM_ENTRY(RegQueryValueA)
    APIHOOK_ENUM_ENTRY(RegQueryValueW)
    APIHOOK_ENUM_ENTRY(RegQueryValueExA)
    APIHOOK_ENUM_ENTRY(RegQueryValueExW)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyA)
    APIHOOK_ENUM_ENTRY(RegQueryInfoKeyW)
    APIHOOK_ENUM_ENTRY(RegSetValueA)
    APIHOOK_ENUM_ENTRY(RegSetValueW)
    APIHOOK_ENUM_ENTRY(RegSetValueExA)
    APIHOOK_ENUM_ENTRY(RegSetValueExW)
    APIHOOK_ENUM_ENTRY(RegEnumValueA)
    APIHOOK_ENUM_ENTRY(RegEnumValueW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyW)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExA)
    APIHOOK_ENUM_ENTRY(RegEnumKeyExW)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyA)
    APIHOOK_ENUM_ENTRY(RegDeleteKeyW)

APIHOOK_ENUM_END


#endif // __APPVERIFIER_REGCHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\windowsfileprotection.cpp ===
/*++

 Copyright (c) Microsoft Corporation. All rights reserved.

 Module Name:

   WindowsFileProtection.cpp

 Abstract:

   This AppVerifier shim hooks the file I/O APIs that could
   potentially change a file under Windows File Protection.

   When one of the files is accessed or modified, an event
   is written to the log.

 Notes:

   This is a general purpose shim.

 History:

   06/25/2001   rparsons    Created

   11/26/2001   rparsons    Remove unused local variables.
                            Make SHFileOperation more efficent.

--*/

#include "precomp.h"
#include "rtlutils.h"
#include "sfc.h"

IMPLEMENT_SHIM_BEGIN(WindowsFileProtection)
#include "ShimHookMacro.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(WindowFileProtection)
    VERIFIER_LOG_ENTRY(VLOG_WFP_COPYFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_MOVEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_DELETEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_REPLACEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_WRITEFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_OPENFILE)
    VERIFIER_LOG_ENTRY(VLOG_WFP_SHFILEOP)
END_DEFINE_VERIFIER_LOG(WindowFileProtection)

INIT_VERIFIER_LOG(WindowFileProtection);

APIHOOK_ENUM_BEGIN

    APIHOOK_ENUM_ENTRY(CreateFileA)
    APIHOOK_ENUM_ENTRY(CreateFileW)
    APIHOOK_ENUM_ENTRY(OpenFile)

    APIHOOK_ENUM_ENTRY(CopyFileA)
    APIHOOK_ENUM_ENTRY(CopyFileW)
    APIHOOK_ENUM_ENTRY(CopyFileExA)
    APIHOOK_ENUM_ENTRY(CopyFileExW)
    APIHOOK_ENUM_ENTRY(DeleteFileA)
    APIHOOK_ENUM_ENTRY(DeleteFileW)
    APIHOOK_ENUM_ENTRY(MoveFileA)
    APIHOOK_ENUM_ENTRY(MoveFileW)
    APIHOOK_ENUM_ENTRY(MoveFileExA)
    APIHOOK_ENUM_ENTRY(MoveFileExW)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressA)
    APIHOOK_ENUM_ENTRY(MoveFileWithProgressW)
    APIHOOK_ENUM_ENTRY(ReplaceFileA)
    APIHOOK_ENUM_ENTRY(ReplaceFileW)
    APIHOOK_ENUM_ENTRY(SHFileOperationA)
    APIHOOK_ENUM_ENTRY(SHFileOperationW)

    APIHOOK_ENUM_ENTRY(_lcreat)
    APIHOOK_ENUM_ENTRY(_lopen)

    APIHOOK_ENUM_ENTRY(NtCreateFile)
    APIHOOK_ENUM_ENTRY(NtOpenFile)

APIHOOK_ENUM_END

/*++

 ANSI wrapper for SfcIsFileProtected.

--*/
BOOL
IsFileProtected(
    LPCSTR pszFileName
    )
{
    LPWSTR  pwszWideFileName = NULL;
    int     nLen;
    BOOL    bReturn = FALSE;

    //
    // Convert from ANSI to Unicode.
    //
    nLen = lstrlenA(pszFileName) + 1;

    if (nLen) {

        pwszWideFileName = (LPWSTR)RtlAllocateHeap(RtlProcessHeap(),
                                                   HEAP_ZERO_MEMORY,
                                                   nLen * sizeof(WCHAR));

        if (!pwszWideFileName) {
            DPFN(eDbgLevelError, "[IsFileProtected] Failed to allocate memory");
            return FALSE;
        }

        if (!MultiByteToWideChar(CP_ACP,
                                 0,
                                 pszFileName,
                                 -1,
                                 pwszWideFileName,
                                 nLen)) {
            DPFN(eDbgLevelError, "[IsFileProtected] ANSI -> Unicode failed");
            goto cleanup;
        }

        bReturn = SfcIsFileProtected(NULL, pwszWideFileName);
    }

cleanup:

    if (pwszWideFileName) {
        RtlFreeHeap(RtlProcessHeap(), 0, pwszWideFileName);
    }

    return bReturn;
}

/*++

 Wraps SfcIsFileProtected for NT path names.

--*/
BOOL
IsNtFileProtected(
    IN PUNICODE_STRING pstrNtFileName
    )
{
    NTSTATUS                    status;
    RTL_UNICODE_STRING_BUFFER   DosPath;
    BOOL                        fReturn = FALSE;
    UCHAR                       DosPathBuffer[MAX_PATH * 2];

    if (!pstrNtFileName) {
        DPFN(eDbgLevelError, "[IsNtFileProtected] Invalid parameter");
        return FALSE;
    }

    //
    // Convert from an NT path to a DOS path.
    //
    RtlInitUnicodeStringBuffer(&DosPath, DosPathBuffer, sizeof(DosPathBuffer));

    status = ShimAssignUnicodeStringBuffer(&DosPath, pstrNtFileName);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[IsNtFileProtected] Failed to initialize DOS path buffer");
        return fReturn;
    }

    status = ShimNtPathNameToDosPathName(0, &DosPath, NULL, NULL);

    if (!NT_SUCCESS(status)) {
        DPFN(eDbgLevelError,
             "[IsNtFileProtected] Failed to convert NT \"%ls\" to DOS path",
            pstrNtFileName->Buffer);
        goto cleanup;
    }

    //
    // Now check for a protected file.
    //
    if (SfcIsFileProtected(NULL, DosPath.String.Buffer)) {
        fReturn = TRUE;
    }

cleanup:

    RtlFreeUnicodeStringBuffer(&DosPath);

    return fReturn;
}

BOOL
APIHOOK(CopyFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL   bFailIfExists
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!bFailIfExists && IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE,
             "API: CopyFileA  Filename: %s",
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileA)(lpExistingFileName,
                                   lpNewFileName,
                                   bFailIfExists);
}

BOOL
APIHOOK(CopyFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL    bFailIfExists
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!bFailIfExists && SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE,
             "API: CopyFileW  Filename: %ls",
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileW)(lpExistingFileName,
                                   lpNewFileName,
                                   bFailIfExists);
}

BOOL
APIHOOK(CopyFileExA)(
    LPCSTR             lpExistingFileName,
    LPCSTR             lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    LPBOOL             pbCancel,
    DWORD              dwCopyFlags
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!(dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE,
             "API: CopyFileExA  Filename: %s",
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileExA)(lpExistingFileName,
                                     lpNewFileName,
                                     lpProgressRoutine,
                                     lpData,
                                     pbCancel,
                                     dwCopyFlags);

}

BOOL
APIHOOK(CopyFileExW)(
    LPCWSTR            lpExistingFileName,
    LPCWSTR            lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    LPBOOL             pbCancel,
    DWORD              dwCopyFlags
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (!(dwCopyFlags & COPY_FILE_FAIL_IF_EXISTS) &&
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_COPYFILE,
             "API: CopyFileExW  Filename: %ls",
             lpNewFileName);
    }

    return ORIGINAL_API(CopyFileExW)(lpExistingFileName,
                                     lpNewFileName,
                                     lpProgressRoutine,
                                     lpData,
                                     pbCancel,
                                     dwCopyFlags);

}

BOOL
APIHOOK(DeleteFileA)(
    LPCSTR lpFileName
    )
{
    if (IsFileProtected(lpFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_DELETEFILE,
             "API: DeleteFileA  Filename: %s",
             lpFileName);
    }

    return ORIGINAL_API(DeleteFileA)(lpFileName);
}

BOOL
APIHOOK(DeleteFileW)(
    LPCWSTR lpFileName
    )
{
    if (SfcIsFileProtected(NULL, lpFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_DELETEFILE,
             "API: DeleteFileW  Filename: %ls",
             lpFileName);
    }

    return ORIGINAL_API(DeleteFileW)(lpFileName);
}

BOOL
APIHOOK(MoveFileA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (IsFileProtected(lpExistingFileName) ||
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE,
             "API: MoveFileA  Filename: %s  Filename: %s",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileA)(lpExistingFileName,
                                   lpNewFileName);
}

BOOL
APIHOOK(MoveFileW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpExistingFileName) ||
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE,
             "API: MoveFileW  Filename: %ls  Filename: %ls",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileW)(lpExistingFileName,
                                   lpNewFileName);
}

BOOL
APIHOOK(MoveFileExA)(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD  dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (IsFileProtected(lpExistingFileName) ||
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE,
             "API: MoveFileExA  Filename: %s  Filename: %s",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileExA)(lpExistingFileName,
                                     lpNewFileName,
                                     dwFlags);
}

BOOL
APIHOOK(MoveFileExW)(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD   dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpExistingFileName) ||
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE, "API: MoveFileExW  Filename: %ls  Filename: %ls",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileExW)(lpExistingFileName,
                                     lpNewFileName,
                                     dwFlags);
}

BOOL
APIHOOK(MoveFileWithProgressA)(
    LPCSTR             lpExistingFileName,
    LPCSTR             lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    DWORD              dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (IsFileProtected(lpExistingFileName) ||
        IsFileProtected(lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE,
             "API: MoveFileWithProgressA  Filename: %s  Filename: %s",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileWithProgressA)(lpExistingFileName,
                                               lpNewFileName,
                                               lpProgressRoutine,
                                               lpData,
                                               dwFlags);
}

BOOL
APIHOOK(MoveFileWithProgressW)(
    LPCWSTR            lpExistingFileName,
    LPCWSTR            lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID             lpData,
    DWORD              dwFlags
    )
{
    //
    // Ensure that the source or destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpExistingFileName) ||
        SfcIsFileProtected(NULL, lpNewFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_MOVEFILE,
             "API: MoveFileWithProgressW  Filename: %ls  Filename: %ls",
             lpExistingFileName,
             lpNewFileName);
    }

    return ORIGINAL_API(MoveFileWithProgressW)(lpExistingFileName,
                                               lpNewFileName,
                                               lpProgressRoutine,
                                               lpData,
                                               dwFlags);
}

BOOL
APIHOOK(ReplaceFileA)(
    LPCSTR lpReplacedFileName,
    LPCSTR lpReplacementFileName,
    LPCSTR lpBackupFileName,
    DWORD  dwReplaceFlags,
    LPVOID lpExclude,
    LPVOID lpReserved
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (IsFileProtected(lpReplacedFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_REPLACEFILE,
             "API: ReplaceFileA  Filename: %s",
             lpReplacedFileName);
    }

    return ORIGINAL_API(ReplaceFileA)(lpReplacedFileName,
                                      lpReplacementFileName,
                                      lpBackupFileName,
                                      dwReplaceFlags,
                                      lpExclude,
                                      lpReserved);

}

BOOL
APIHOOK(ReplaceFileW)(
    LPCWSTR lpReplacedFileName,
    LPCWSTR lpReplacementFileName,
    LPCWSTR lpBackupFileName,
    DWORD   dwReplaceFlags,
    LPVOID  lpExclude,
    LPVOID  lpReserved
    )
{
    //
    // Ensure that the destination is not protected.
    //
    if (SfcIsFileProtected(NULL, lpReplacedFileName)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_REPLACEFILE,
             "API: ReplaceFileW  Filename: %ls",
             lpReplacedFileName);
    }

    return ORIGINAL_API(ReplaceFileW)(lpReplacedFileName,
                                      lpReplacementFileName,
                                      lpBackupFileName,
                                      dwReplaceFlags,
                                      lpExclude,
                                      lpReserved);

}

void
ReportProtectedFileA(
    LPCSTR pszFilePath
    )
{
    UINT uSize = 0;

    if (pszFilePath) {
        while (TRUE) {
            if (IsFileProtected(pszFilePath)) {
                VLOG(VLOG_LEVEL_ERROR,
                     VLOG_WFP_SHFILEOP,
                     "API: SHFileOperationA  Filename: %s", pszFilePath);
            }

            uSize = lstrlenA(pszFilePath) + 1;
            pszFilePath += uSize;

            if (*pszFilePath == '\0') {
                break;
            }
        }
    }
}

void
ReportProtectedFileW(
    LPCWSTR pwszFilePath
    )
{
    UINT uSize = 0;

    if (pwszFilePath) {
        while (TRUE) {
            if (SfcIsFileProtected(NULL, pwszFilePath)) {
                VLOG(VLOG_LEVEL_ERROR,
                     VLOG_WFP_SHFILEOP,
                     "API: SHFileOperationW  Filename: %ls", pwszFilePath);
            }

            uSize = lstrlenW(pwszFilePath) + 1;
            pwszFilePath += uSize;

            if (*pwszFilePath == '\0') {
                break;
            }
        }
    }
}

int
APIHOOK(SHFileOperationA)(
    LPSHFILEOPSTRUCTA lpFileOp
    )
{
    //
    // If they're going to rename files on collision, don't bother.
    //
    if (!(lpFileOp->fFlags & FOF_RENAMEONCOLLISION)) {
        ReportProtectedFileA(lpFileOp->pFrom);
        ReportProtectedFileA(lpFileOp->pTo);
    }

    return ORIGINAL_API(SHFileOperationA)(lpFileOp);
}

int
APIHOOK(SHFileOperationW)(
    LPSHFILEOPSTRUCTW lpFileOp
    )
{
    //
    // If they're going to rename files on collision, don't bother.
    //
    if (!(lpFileOp->fFlags & FOF_RENAMEONCOLLISION)) {
        ReportProtectedFileW(lpFileOp->pFrom);
        ReportProtectedFileW(lpFileOp->pTo);
    }

    return ORIGINAL_API(SHFileOperationW)(lpFileOp);
}

HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if (IsFileProtected(lpFileName) &&
        (dwDesiredAccess & GENERIC_WRITE ||
         dwDesiredAccess & GENERIC_READ)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: CreateFileA  Filename: %s",
             lpFileName);
    }

    return ORIGINAL_API(CreateFileA)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}

HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,
    DWORD                 dwDesiredAccess,
    DWORD                 dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD                 dwCreationDisposition,
    DWORD                 dwFlagsAndAttributes,
    HANDLE                hTemplateFile
    )
{
    if (SfcIsFileProtected(NULL, lpFileName) &&
         (dwDesiredAccess & GENERIC_WRITE ||
          dwDesiredAccess & GENERIC_READ)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: CreateFileW  Filename: %ls",
             lpFileName);
    }

    return ORIGINAL_API(CreateFileW)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}

HFILE
APIHOOK(OpenFile)(
    LPCSTR     lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT       uStyle
    )
{
    if (IsFileProtected(lpFileName) &&
        (uStyle & OF_READWRITE ||
         uStyle & OF_CREATE ||
         uStyle & OF_DELETE)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: OpenFile  Filename: %s",
             lpFileName);
    }

    return ORIGINAL_API(OpenFile)(lpFileName,
                                  lpReOpenBuff,
                                  uStyle);
}

HFILE
APIHOOK(_lopen)(
    LPCSTR lpPathName,
    int    iReadWrite
    )
{
    if (IsFileProtected(lpPathName) &&
        (iReadWrite & OF_READWRITE ||
         iReadWrite & OF_WRITE)) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: _lopen  Filename: %s",
             lpPathName);
    }

    return ORIGINAL_API(_lopen)(lpPathName,
                                iReadWrite);
}

HFILE
APIHOOK(_lcreat)(
    LPCSTR lpPathName,
    int    iAttribute
    )
{
    if (IsFileProtected(lpPathName) && iAttribute != 1) {
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_WFP_OPENFILE,
             "API: _lcreat  Filename: %s",
             lpPathName);
    }

    return ORIGINAL_API(_lcreat)(lpPathName,
                                 iAttribute);

}

NTSTATUS
APIHOOK(NtCreateFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    PLARGE_INTEGER     AllocationSize,
    ULONG              FileAttributes,
    ULONG              ShareAccess,
    ULONG              CreateDisposition,
    ULONG              CreateOptions,
    PVOID              EaBuffer,
    ULONG              EaLength
    )
{
    if (IsNtFileProtected(ObjectAttributes->ObjectName)) {
        VLOG(VLOG_LEVEL_ERROR, VLOG_WFP_OPENFILE,
             "API: NtCreateFile  Filename: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    return ORIGINAL_API(NtCreateFile)(FileHandle,
                                      DesiredAccess,
                                      ObjectAttributes,
                                      IoStatusBlock,
                                      AllocationSize,
                                      FileAttributes,
                                      ShareAccess,
                                      CreateDisposition,
                                      CreateOptions,
                                      EaBuffer,
                                      EaLength);

}

NTSTATUS
APIHOOK(NtOpenFile)(
    PHANDLE            FileHandle,
    ACCESS_MASK        DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes,
    PIO_STATUS_BLOCK   IoStatusBlock,
    ULONG              ShareAccess,
    ULONG              OpenOptions
    )
{
    if (IsNtFileProtected(ObjectAttributes->ObjectName)) {
        VLOG(VLOG_LEVEL_ERROR, VLOG_WFP_OPENFILE,
             "API: NtOpenFile  Filename: %ls",
             ObjectAttributes->ObjectName->Buffer);
    }

    return ORIGINAL_API(NtOpenFile)(FileHandle,
                                    DesiredAccess,
                                    ObjectAttributes,
                                    IoStatusBlock,
                                    ShareAccess,
                                    OpenOptions);

}

SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_WINFILEPROTECT_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_WINFILEPROTECT_FRIENDLY)
    SHIM_INFO_VERSION(1, 5)
    SHIM_INFO_FLAGS(AVRF_FLAG_EXTERNAL_ONLY)
    SHIM_INFO_INCLUDE_EXCLUDE("E:rpcrt4.dll kernel32.dll")

SHIM_INFO_END()

/*++

 Register hooked functions.

--*/
HOOK_BEGIN

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_COPYFILE,
                            AVS_WFP_COPYFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_MOVEFILE,
                            AVS_WFP_MOVEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_DELETEFILE,
                            AVS_WFP_DELETEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_REPLACEFILE,
                            AVS_WFP_REPLACEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_WRITEFILE,
                            AVS_WFP_WRITEFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_OPENFILE,
                            AVS_WFP_OPENFILE,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_WFP_SHFILEOP,
                            AVS_WFP_SHFILEOP,
                            AVS_WFP_GENERAL_R,
                            AVS_WFP_GENERAL_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CreateFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                         OpenFile)

    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        CopyFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      CopyFileExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      DeleteFileW)

    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                        MoveFileW)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                      MoveFileExW)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressA)
    APIHOOK_ENTRY(KERNEL32.DLL,            MoveFileWithProgressW)

    APIHOOK_ENTRY(KERNEL32.DLL,                     ReplaceFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                     ReplaceFileW)

    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationA)
    APIHOOK_ENTRY(SHELL32.DLL,                  SHFileOperationW)

    // 16-bit compatibility file routines.
    APIHOOK_ENTRY(KERNEL32.DLL,                           _lopen)
    APIHOOK_ENTRY(KERNEL32.DLL,                          _lcreat)

    APIHOOK_ENTRY(NTDLL.DLL,                        NtCreateFile)
    APIHOOK_ENTRY(NTDLL.DLL,                          NtOpenFile)

HOOK_END

IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SlayerXP.rc
//
#define IDS_PROJNAME                    100
#define IDD_LAYER_PROPPAGE              101
#define IDC_LAYER_NAME                  1005
#define IDC_DISABLE_OTHER_FIXES         1006
#define IDC_LEARN                       1009
#define IDC_TEXT_INSTRUCTIONS           1013
#define IDS_LAYER_WIN95_EXT             2000
#define IDS_LAYER_WIN98_EXT             2001
#define IDS_LAYER_NT4_EXT               2002
#define IDS_LAYER_WIN2K_EXT             2003
#define IDS_LAYER_WINXP_EXT             2004
#define IDS_COMPAT_UNAVAILABLE          2005
#define IDS_COMPAT_UNAVAILABLE_SYSTEM   2006
#define IDS_COMPATIBILITY               2007
#define IDC_USE_LAYER                   5000
#define IDC_256COLORS                   5001
#define IDC_640X480                     5002
#define IDC_ENABLE_THEMES               5003
#define IDC_ENABLELUA                   5004

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\shims\verifier\securitychecks.cpp ===
/*++

 Copyright (c) 2001 Microsoft Corporation

 Module Name:

   SecurityChecks.cpp

 Abstract:

   This AppVerifier shim hooks CreateProcess, CreateProcessAsUser,
   and WinExec and checks to see if some conditions exist that
   might allow trojan horse behavior to occur.
   
 Notes:

   This is a general purpose shim.

 History:

   12/13/2001   rparsons    Created

--*/

#include "precomp.h"

IMPLEMENT_SHIM_BEGIN(SecurityChecks)
#include "ShimHookMacro.h"

//
// verifier log entries
//
BEGIN_DEFINE_VERIFIER_LOG(SecurityChecks)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_BADARGUMENTS)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WINEXEC)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_NULL_DACL)
    VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WORLDWRITE_DACL)
END_DEFINE_VERIFIER_LOG(SecurityChecks)

INIT_VERIFIER_LOG(SecurityChecks);

APIHOOK_ENUM_BEGIN
    APIHOOK_ENUM_ENTRY(CreateProcessA)
    APIHOOK_ENUM_ENTRY(CreateProcessW)
    APIHOOK_ENUM_ENTRY(CreateProcessAsUserA)
    APIHOOK_ENUM_ENTRY(CreateProcessAsUserW)
    APIHOOK_ENUM_ENTRY(WinExec)

	APIHOOK_ENUM_ENTRY(CreateFileA)	
	APIHOOK_ENUM_ENTRY(CreateFileW)
	APIHOOK_ENUM_ENTRY(CreateDesktopA)	
	APIHOOK_ENUM_ENTRY(CreateDesktopW)	
	APIHOOK_ENUM_ENTRY(CreateWindowStationA)
	APIHOOK_ENUM_ENTRY(CreateWindowStationW)
    
    APIHOOK_ENUM_ENTRY(RegCreateKeyExA)
    APIHOOK_ENUM_ENTRY(RegCreateKeyExW)
    APIHOOK_ENUM_ENTRY(RegSaveKeyA)
    APIHOOK_ENUM_ENTRY(RegSaveKeyW)
    APIHOOK_ENUM_ENTRY(RegSaveKeyExA)
    APIHOOK_ENUM_ENTRY(RegSaveKeyExW)

    APIHOOK_ENUM_ENTRY(CreateFileMappingA)
    APIHOOK_ENUM_ENTRY(CreateFileMappingW)
    APIHOOK_ENUM_ENTRY(CreateJobObjectA)
    APIHOOK_ENUM_ENTRY(CreateJobObjectW)
    APIHOOK_ENUM_ENTRY(CreateThread)
    APIHOOK_ENUM_ENTRY(CreateRemoteThread)

    APIHOOK_ENUM_ENTRY(CreateDirectoryA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryW)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExA)
    APIHOOK_ENUM_ENTRY(CreateDirectoryExW)
    APIHOOK_ENUM_ENTRY(CreateHardLinkA)
    APIHOOK_ENUM_ENTRY(CreateHardLinkW)
    APIHOOK_ENUM_ENTRY(CreateMailslotA)
    APIHOOK_ENUM_ENTRY(CreateMailslotW)
    APIHOOK_ENUM_ENTRY(CreateNamedPipeA)
    APIHOOK_ENUM_ENTRY(CreateNamedPipeW)
    APIHOOK_ENUM_ENTRY(CreatePipe)
    APIHOOK_ENUM_ENTRY(CreateMutexA)
    APIHOOK_ENUM_ENTRY(CreateMutexW)
    APIHOOK_ENUM_ENTRY(CreateSemaphoreA)
    APIHOOK_ENUM_ENTRY(CreateSemaphoreW)
    APIHOOK_ENUM_ENTRY(CreateWaitableTimerA)
    APIHOOK_ENUM_ENTRY(CreateWaitableTimerW)
    APIHOOK_ENUM_ENTRY(CreateEventA)
    APIHOOK_ENUM_ENTRY(CreateEventW)

    APIHOOK_ENUM_ENTRY(SetFileSecurityA)
    APIHOOK_ENUM_ENTRY(SetFileSecurityW)
    APIHOOK_ENUM_ENTRY(SetKernelObjectSecurity)
    APIHOOK_ENUM_ENTRY(SetNamedSecurityInfoA)
    APIHOOK_ENUM_ENTRY(SetNamedSecurityInfoW)
    APIHOOK_ENUM_ENTRY(SetSecurityInfo)
    APIHOOK_ENUM_ENTRY(RegSetKeySecurity)
    APIHOOK_ENUM_ENTRY(SetUserObjectSecurity)
    APIHOOK_ENUM_ENTRY(SetServiceObjectSecurity)

    APIHOOK_ENUM_ENTRY(SetNtmsObjectSecurity)
    APIHOOK_ENUM_ENTRY(ClusterRegCreateKey)
    APIHOOK_ENUM_ENTRY(ClusterRegSetKeySecurity)
    APIHOOK_ENUM_ENTRY(CreateNtmsMediaPoolA)
    APIHOOK_ENUM_ENTRY(CreateNtmsMediaPoolW)

APIHOOK_ENUM_END

BYTE g_ajSidBuffer[SECURITY_MAX_SID_SIZE];
PSID g_pWorldSid = NULL;

WCHAR g_wszWinDir[MAX_PATH];
DWORD g_dwWinDirLen = 0;

void
InitWorldSid(
    void
    )
{
    DWORD dwSidSize = sizeof(g_ajSidBuffer);

    if (CreateWellKnownSid(WinWorldSid, NULL, g_ajSidBuffer, &dwSidSize)) {
        g_pWorldSid = g_ajSidBuffer;
    } else {
        g_pWorldSid = NULL;
    }
}

void
CheckDacl(
    PACL        pDacl,
    LPCWSTR     szCaller,
    LPCWSTR     szParam,
    LPCWSTR     szName
    )
{
    if (!pDacl) {
        //
        // we have a NULL dacl -- log a problem
        //
        VLOG(VLOG_LEVEL_ERROR,
             VLOG_SECURITYCHECKS_NULL_DACL,
             "Called %ls, and specified a NULL DACL in %ls for object '%ls.'",
             szCaller,
             szParam,
             szName);
        return;
    }

    if (!g_pWorldSid) {
        //
        // we never were able to get the world Sid
        //
        return;
    }

    for (DWORD i = 0; i < pDacl->AceCount; ++i) {
        PACE_HEADER     pAceHeader = NULL;
        PSID            pSID;
        ACCESS_MASK     dwAccessMask;

        if (!GetAce(pDacl, i, (LPVOID*)&pAceHeader)) {
            continue;
        }

        //
        // if it's not some form of ACCESS_ALLOWED ACE, we aren't interested
        //
        if (pAceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE) {

            pSID = &(((PACCESS_ALLOWED_ACE)pAceHeader)->SidStart);
            dwAccessMask = ((PACCESS_ALLOWED_ACE)pAceHeader)->Mask;

        } else if (pAceHeader->AceType == ACCESS_ALLOWED_OBJECT_ACE_TYPE) {

            PACCESS_ALLOWED_OBJECT_ACE pAAOAce = (PACCESS_ALLOWED_OBJECT_ACE)pAceHeader;

            //
            // who the heck came up with this system? The Sid starts at a different place
            // depending on the flags. Anyone ever heard of multiple structs? Sigh.
            //
            if ((pAAOAce->Flags & ACE_OBJECT_TYPE_PRESENT) && (pAAOAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)) {

                pSID = &(pAAOAce->SidStart);

            } else if ((pAAOAce->Flags & ACE_OBJECT_TYPE_PRESENT) || (pAAOAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)){

                pSID = (PSID)&(pAAOAce->InheritedObjectType);

            } else {

                pSID = (PSID)&(pAAOAce->ObjectType);
            }

            dwAccessMask = ((PACCESS_ALLOWED_OBJECT_ACE)pAceHeader)->Mask;

        } else {
            continue;
        }

        //
        // check the validity of the SID, just to be safe
        //
        if (!IsValidSid(pSID)) {

            continue;
        }


        //
        // if the SID is the world, and the access mask allows WRITE_DAC and WRITE_OWNER, we have a problem
        //
        if ((dwAccessMask & (WRITE_DAC | WRITE_OWNER)) && EqualSid(pSID, g_pWorldSid)) {
            VLOG(VLOG_LEVEL_ERROR,
                 VLOG_SECURITYCHECKS_WORLDWRITE_DACL,
                 "Called %ls, and specified a DACL with WRITE_DAC and/or WRITE_OWNER for WORLD in %ls for object '%ls.'",
                 szCaller,
                 szParam,
                 szName);
            return;
        }

    }
}

void
CheckSecurityDescriptor(
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    LPCWSTR                 szCaller,
    LPCWSTR                 szParam,
    LPCWSTR                 szName
    )
{
    BOOL                    bDaclPresent = FALSE;
    BOOL                    bDaclDefaulted = FALSE;
    PACL                    pDacl = NULL;

    if (!pSecurityDescriptor || !szName || !szName[0]) {
        //
        // there are no attributes, so they get the default, which is fine,
        // or the object doesn't have a name, so it can't be highjacked
        //
        return;
    }

    if (GetSecurityDescriptorDacl(pSecurityDescriptor, &bDaclPresent, &pDacl, &bDaclDefaulted)) {
        if (bDaclPresent) {
            CheckDacl(pDacl, szCaller, szParam, szName);
        }
    }
}

void
CheckSecurityAttributes(
    LPSECURITY_ATTRIBUTES   pSecurityAttrib,
    LPCWSTR                 szCaller,
    LPCWSTR                 szParam,
    LPCWSTR                 szName
    )
{
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;

    if (!pSecurityAttrib) {
        //
        // there's no attributes, so they get the default, which is fine
        //
        return;
    }

    pSecurityDescriptor = (PSECURITY_DESCRIPTOR)pSecurityAttrib->lpSecurityDescriptor;

    CheckSecurityDescriptor(pSecurityDescriptor, szCaller, szParam, szName);
}

void
CheckCreateProcess(
    LPCWSTR		pwszApplicationName,
    LPCWSTR		pwszCommandLine,
    LPCWSTR		pwszCaller
    )
{
    //
    // if applicationname is non-null, there's no problem
    //
    if (pwszApplicationName) {
        return;
    }

    //
    // if there's no command line, there's a problem, but not one we want to solve
    //
    if (!pwszCommandLine) {
        return;
    }

    //
    // if there are no spaces, no problem
    //
    LPWSTR pSpaceLoc = wcschr(pwszCommandLine, L' ');
    if (!pSpaceLoc) {
        return;
    }

    //
    // if the beginning of the command line is quoted, no problem
    //
    if (pwszCommandLine[0] == L'\"') {
        return;
    }

    //
    // if the phrase '.exe ' appears before the first space, we'll call that good
    //
    LPWSTR pExeLoc = wcsistr(pwszCommandLine, L".exe ");
    if (pExeLoc && pExeLoc < pSpaceLoc) {
        return;
    }

    //
    // if the first part of the command line is windir, we'll call that good
    //
    if (g_dwWinDirLen && _wcsnicmp(pwszCommandLine, g_wszWinDir, g_dwWinDirLen) == 0) {
        return;
    }


	if (_wcsicmp(pwszCaller, L"winexec") == 0) {
		VLOG(VLOG_LEVEL_ERROR,
			 VLOG_SECURITYCHECKS_BADARGUMENTS,
			 "Called %ls with command line '%ls'. The command line has spaces, and the exe name is not in quotes.",
			 pwszCaller,
			 pwszCommandLine);
    } else {
		VLOG(VLOG_LEVEL_ERROR,
			 VLOG_SECURITYCHECKS_BADARGUMENTS,
			 "Called %ls with command line '%ls'. The lpApplicationName argument is NULL, lpCommandLine has spaces, and the exe name is not in quotes.",
			 pwszCaller,
			 pwszCommandLine);
    }
}

void
CheckForNoPathInFileName(
    LPCWSTR  pwszFilePath,
    LPCWSTR  pwszCaller
    )
{
    if (!pwszFilePath || !pwszCaller) {
        return;
    }

    //
    // skip quotes and space if necessary
    //
    DWORD dwBegin = 0;
    while (pwszFilePath[dwBegin] == L'\"' || pwszFilePath[dwBegin] == L' ') {
        dwBegin++;
    }

    //
    // if there's nothing left of the string, get out
    //
    if (!pwszFilePath[dwBegin] || !pwszFilePath[dwBegin + 1]) {
        return;
    }

    //
    // check for DOS (x:...) and UNC (\\...) full paths
    //
    if (pwszFilePath[dwBegin + 1] == L':' || (pwszFilePath[dwBegin] == L'\\' && pwszFilePath[dwBegin + 1] == L'\\')) {
        //
        // full path
        //
        return;
    }

    VLOG(VLOG_LEVEL_ERROR,
         VLOG_SECURITYCHECKS_BADARGUMENTS,
         "Called '%ls' with '%ls' specified. Use a full path to the file to ensure that you get the executable you want, and not a malicious exe with the same name.",
         pwszCaller,
         pwszFilePath);
}

BOOL 
APIHOOK(CreateProcessA)(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes, 
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo, 
    LPPROCESS_INFORMATION lpProcessInformation 
    )
{
    LPWSTR pwszApplicationName = ToUnicode(lpApplicationName);
    LPWSTR pwszCommandLine = ToUnicode(lpCommandLine);

    CheckCreateProcess(pwszApplicationName, pwszCommandLine, L"CreateProcess");

    if (pwszApplicationName) {
        CheckForNoPathInFileName(pwszApplicationName, L"CreateProcess");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", pwszApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", pwszApplicationName);
    } else {
        CheckForNoPathInFileName(pwszCommandLine, L"CreateProcess");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", pwszCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", pwszCommandLine);
    }

    if (pwszApplicationName) {
        free(pwszApplicationName);
        pwszApplicationName = NULL;
    }
    if (pwszCommandLine) {
        free(pwszCommandLine);
        pwszCommandLine = NULL;
    }

    return ORIGINAL_API(CreateProcessA)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironment,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessW)(
    LPCWSTR               lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPWSTR                lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CheckCreateProcess(lpApplicationName, lpCommandLine, L"CreateProcess");

    if (lpApplicationName) {
        CheckForNoPathInFileName(lpApplicationName, L"CreateProcess");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", lpApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", lpApplicationName);
    } else {
        CheckForNoPathInFileName(lpCommandLine, L"CreateProcess");
    
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcess", L"lpProcessAttributes", lpCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcess", L"lpThreadAttributes", lpCommandLine);
    }


    return ORIGINAL_API(CreateProcessW)(lpApplicationName,
                                        lpCommandLine,
                                        lpProcessAttributes,
                                        lpThreadAttributes,
                                        bInheritHandles,
                                        dwCreationFlags,
                                        lpEnvironment,
                                        lpCurrentDirectory,
                                        lpStartupInfo,
                                        lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessAsUserA)(
    HANDLE                hToken,
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes, 
    LPSECURITY_ATTRIBUTES lpThreadAttributes, 
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo, 
    LPPROCESS_INFORMATION lpProcessInformation 
    )
{
    LPWSTR pwszApplicationName = ToUnicode(lpApplicationName);
    LPWSTR pwszCommandLine = ToUnicode(lpCommandLine);

    CheckCreateProcess(pwszApplicationName, pwszCommandLine, L"CreateProcessAsUser");

    if (pwszApplicationName) {
        CheckForNoPathInFileName(pwszApplicationName, L"CreateProcessAsUser");

        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", pwszApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", pwszApplicationName);
    } else {
        CheckForNoPathInFileName(pwszCommandLine, L"CreateProcessAsUser");
        
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", pwszCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", pwszCommandLine);
    }

    if (pwszApplicationName) {
        free(pwszApplicationName);
        pwszApplicationName = NULL;
    }
    if (pwszCommandLine) {
        free(pwszCommandLine);
        pwszCommandLine = NULL;
    }

    return ORIGINAL_API(CreateProcessAsUserA)(hToken,
                                              lpApplicationName,
                                              lpCommandLine,
                                              lpProcessAttributes,    
                                              lpThreadAttributes,
                                              bInheritHandles,
                                              dwCreationFlags,
                                              lpEnvironment,
                                              lpCurrentDirectory,
                                              lpStartupInfo,
                                              lpProcessInformation);
}

BOOL 
APIHOOK(CreateProcessAsUserW)(
    HANDLE                hToken,
    LPCWSTR               lpApplicationName,
    LPWSTR                lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPWSTR                lpCurrentDirectory,
    LPSTARTUPINFOW        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    CheckCreateProcess(lpApplicationName, lpCommandLine, L"CreateProcessAsUser");

    if (lpApplicationName) {
        CheckForNoPathInFileName(lpApplicationName, L"CreateProcessAsUser");
    
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", lpApplicationName);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", lpApplicationName);
    } else {
        CheckForNoPathInFileName(lpCommandLine, L"CreateProcessAsUser");
    
        CheckSecurityAttributes(lpProcessAttributes, L"CreateProcessAsUser", L"lpProcessAttributes", lpCommandLine);
        CheckSecurityAttributes(lpThreadAttributes, L"CreateProcessAsUser", L"lpThreadAttributes", lpCommandLine);
    }

    return ORIGINAL_API(CreateProcessAsUserW)(hToken,
                                              lpApplicationName,
                                              lpCommandLine,
                                              lpProcessAttributes,
                                              lpThreadAttributes,
                                              bInheritHandles,
                                              dwCreationFlags,
                                              lpEnvironment,
                                              lpCurrentDirectory,
                                              lpStartupInfo,
                                              lpProcessInformation);
}

UINT 
APIHOOK(WinExec)(
    LPCSTR lpCmdLine, 
    UINT   uCmdShow 
    )
{
    LPWSTR pwszCmdLine = ToUnicode(lpCmdLine);

    VLOG(VLOG_LEVEL_ERROR, VLOG_SECURITYCHECKS_WINEXEC, "Called WinExec.");

    CheckForNoPathInFileName(pwszCmdLine, L"WinExec");

    CheckCreateProcess(NULL, pwszCmdLine, L"WinExec");

    if (pwszCmdLine) {
        free(pwszCmdLine);
        pwszCmdLine = NULL;
    }

    return ORIGINAL_API(WinExec)(lpCmdLine, uCmdShow);
}


HANDLE
APIHOOK(CreateFileA)(
    LPCSTR                lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    LPWSTR pwszName = ToUnicode(lpFileName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateFile", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateFileA)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);

}


HANDLE
APIHOOK(CreateFileW)(
    LPCWSTR               lpFileName,            // file name
    DWORD                 dwDesiredAccess,       // access mode
    DWORD                 dwShareMode,           // share mode
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  // SD
    DWORD                 dwCreationDisposition, // how to create
    DWORD                 dwFlagsAndAttributes,  // file attributes
    HANDLE                hTemplateFile          // handle to template file
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateFile", L"lpSecurityAttributes", lpFileName);
    
    return ORIGINAL_API(CreateFileW)(lpFileName,
                                     dwDesiredAccess,
                                     dwShareMode,
                                     lpSecurityAttributes,
                                     dwCreationDisposition,
                                     dwFlagsAndAttributes,
                                     hTemplateFile);
}


HDESK 
APIHOOK(CreateDesktopA)(
    LPCSTR lpszDesktop,          // name of new desktop
    LPCSTR lpszDevice,           // reserved; must be NULL
    LPDEVMODEA pDevmode,         // reserved; must be NULL
    DWORD dwFlags,               // desktop interaction
    ACCESS_MASK dwDesiredAccess, // access of returned handle
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    LPWSTR pwszName = ToUnicode(lpszDesktop);

    CheckSecurityAttributes(lpsa, L"CreateDesktop", L"lpsa", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateDesktopA)(lpszDesktop,        
                                        lpszDevice,         
                                        pDevmode,         
                                        dwFlags,              
                                        dwDesiredAccess,
                                        lpsa);
}

HDESK 
APIHOOK(CreateDesktopW)(
    LPCWSTR lpszDesktop,         // name of new desktop
    LPCWSTR lpszDevice,          // reserved; must be NULL
    LPDEVMODEW pDevmode,         // reserved; must be NULL
    DWORD dwFlags,               // desktop interaction
    ACCESS_MASK dwDesiredAccess, // access of returned handle
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    CheckSecurityAttributes(lpsa, L"CreateDesktop", L"lpsa", lpszDesktop);

    return ORIGINAL_API(CreateDesktopW)(lpszDesktop,        
                                        lpszDevice,         
                                        pDevmode,         
                                        dwFlags,              
                                        dwDesiredAccess,
                                        lpsa);
}



HWINSTA 
APIHOOK(CreateWindowStationA)(
    LPSTR lpwinsta,              // new window station name
    DWORD dwReserved,            // reserved; must be zero
    ACCESS_MASK dwDesiredAccess, // requested access
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    LPWSTR pwszName = ToUnicode(lpwinsta);

    CheckSecurityAttributes(lpsa, L"CreateWindowStation", L"lpsa", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateWindowStationA)(lpwinsta,        
                                              dwReserved,         
                                              dwDesiredAccess,
                                              lpsa);
}

HWINSTA 
APIHOOK(CreateWindowStationW)(
    LPWSTR lpwinsta,             // new window station name
    DWORD dwReserved,            // reserved; must be zero
    ACCESS_MASK dwDesiredAccess, // requested access
    LPSECURITY_ATTRIBUTES lpsa   // security attributes
    )
{
    CheckSecurityAttributes(lpsa, L"CreateWindowStation", L"lpsa", lpwinsta);

    return ORIGINAL_API(CreateWindowStationW)(lpwinsta,        
                                              dwReserved,         
                                              dwDesiredAccess,
                                              lpsa);
}


LONG 
APIHOOK(RegCreateKeyExA)(
    HKEY                  hKey,                
    LPCSTR                lpSubKey,         
    DWORD                 Reserved,           
    LPSTR                 lpClass,           
    DWORD                 dwOptions,          
    REGSAM                samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,          
    LPDWORD               lpdwDisposition   
    )
{
    LPWSTR pwszName = ToUnicode(lpSubKey);

    CheckSecurityAttributes(lpSecurityAttributes, L"RegCreateKeyEx", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(RegCreateKeyExA)(hKey,
                                         lpSubKey,
                                         Reserved,
                                         lpClass,
                                         dwOptions,
                                         samDesired,
                                         lpSecurityAttributes,
                                         phkResult,
                                         lpdwDisposition);
}

LONG 
APIHOOK(RegCreateKeyExW)(
    HKEY                  hKey,                
    LPCWSTR               lpSubKey,         
    DWORD                 Reserved,           
    LPWSTR                lpClass,           
    DWORD                 dwOptions,          
    REGSAM                samDesired,        
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY                 phkResult,          
    LPDWORD               lpdwDisposition   
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"RegCreateKeyEx", L"lpSecurityAttributes", lpSubKey);
    
    return ORIGINAL_API(RegCreateKeyExW)(hKey,
                                         lpSubKey,
                                         Reserved,
                                         lpClass,
                                         dwOptions,
                                         samDesired,
                                         lpSecurityAttributes,
                                         phkResult,
                                         lpdwDisposition);
}

LONG 
APIHOOK(RegSaveKeyA)(
    HKEY                    hKey,                 // handle to key
    LPCSTR                  lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpFile);

    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKey", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(RegSaveKeyA)(hKey,
                                     lpFile,
                                     lpSecurityAttributes);
}

LONG 
APIHOOK(RegSaveKeyW)(
    HKEY                    hKey,                 // handle to key
    LPCWSTR                 lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKey", L"lpSecurityAttributes", lpFile);
    
    return ORIGINAL_API(RegSaveKeyW)(hKey,
                                     lpFile,
                                     lpSecurityAttributes);
}

LONG 
APIHOOK(RegSaveKeyExA)(
    HKEY                    hKey,                 // handle to key
    LPCSTR                  lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes, // SD
    DWORD                   Flags
    )
{
    LPWSTR pwszName = ToUnicode(lpFile);

    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKeyEx", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(RegSaveKeyExA)(hKey,
                                     lpFile,
                                     lpSecurityAttributes,
                                     Flags);
}

LONG 
APIHOOK(RegSaveKeyExW)(
    HKEY                    hKey,                 // handle to key
    LPCWSTR                 lpFile,               // data file
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes, // SD
    DWORD                   Flags
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"RegSaveKeyEx", L"lpSecurityAttributes", lpFile);
    
    return ORIGINAL_API(RegSaveKeyExW)(hKey,
                                       lpFile,
                                       lpSecurityAttributes,
                                       Flags);
}

HANDLE 
APIHOOK(CreateFileMappingA)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCSTR lpName             
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpAttributes, L"CreateFileMapping", L"lpAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateFileMappingA)(hFile, 
                                           lpAttributes, 
                                           flProtect, 
                                           dwMaximumSizeHigh, 
                                           dwMaximumSizeLow, 
                                           lpName);
}

HANDLE 
APIHOOK(CreateFileMappingW)(
    HANDLE hFile,              
    LPSECURITY_ATTRIBUTES lpAttributes,
    DWORD flProtect,           
    DWORD dwMaximumSizeHigh,   
    DWORD dwMaximumSizeLow,    
    LPCWSTR lpName             
    )
{
    CheckSecurityAttributes(lpAttributes, L"CreateFileMapping", L"lpAttributes", lpName);
    
    return ORIGINAL_API(CreateFileMappingW)(hFile, 
                                            lpAttributes, 
                                            flProtect, 
                                            dwMaximumSizeHigh, 
                                            dwMaximumSizeLow, 
                                            lpName);
}

HANDLE 
APIHOOK(CreateJobObjectA)(
    LPSECURITY_ATTRIBUTES   lpJobAttributes,  // SD
    LPCSTR                  lpName            // job name 
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpJobAttributes, L"CreateJobObject", L"lpJobAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateJobObjectA)(lpJobAttributes,
                                          lpName);
}

HANDLE 
APIHOOK(CreateJobObjectW)(
    LPSECURITY_ATTRIBUTES   lpJobAttributes,  // SD
    LPCWSTR                 lpName            // job name 
    )
{
    CheckSecurityAttributes(lpJobAttributes, L"CreateJobObject", L"lpJobAttributes", lpName);
    
    return ORIGINAL_API(CreateJobObjectW)(lpJobAttributes,
                                          lpName);
}


HANDLE
APIHOOK(CreateThread)(
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, // SD
    SIZE_T                  dwStackSize,        // initial stack size
    LPTHREAD_START_ROUTINE  lpStartAddress,     // thread function
    LPVOID                  lpParameter,        // thread argument
    DWORD                   dwCreationFlags,    // creation option
    LPDWORD                 lpThreadId          // thread identifier
    )
{
    CheckSecurityAttributes(lpThreadAttributes, L"CreateThread", L"lpThreadAttributes", L"Unnamed thread");
    
    return ORIGINAL_API(CreateThread)(lpThreadAttributes,
                                      (DWORD)dwStackSize,
                                      lpStartAddress,
                                      lpParameter,    
                                      dwCreationFlags,
                                      lpThreadId);      
}

HANDLE 
APIHOOK(CreateRemoteThread)(
    HANDLE                  hProcess,           // handle to process
    LPSECURITY_ATTRIBUTES   lpThreadAttributes, // SD
    SIZE_T                  dwStackSize,        // initial stack size
    LPTHREAD_START_ROUTINE  lpStartAddress,     // thread function
    LPVOID                  lpParameter,        // thread argument
    DWORD                   dwCreationFlags,    // creation option
    LPDWORD                 lpThreadId          // thread identifier
    )
{
    CheckSecurityAttributes(lpThreadAttributes, L"CreateRemoteThread", L"lpThreadAttributes", L"Unnamed thread");
    
    return ORIGINAL_API(CreateRemoteThread)(hProcess, 
                                            lpThreadAttributes,
                                            dwStackSize,
                                            lpStartAddress,
                                            lpParameter,    
                                            dwCreationFlags,
                                            lpThreadId);      
}




BOOL
APIHOOK(CreateDirectoryA)(
    LPCSTR                lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpPathName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectory", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateDirectoryA)(lpPathName, 
                                          lpSecurityAttributes);
}


BOOL
APIHOOK(CreateDirectoryW)(
    LPCWSTR               lpPathName,           // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectory", L"lpSecurityAttributes", lpPathName);
    
    return ORIGINAL_API(CreateDirectoryW)(lpPathName, 
                                          lpSecurityAttributes);
}


BOOL
APIHOOK(CreateDirectoryExA)(
    LPCSTR                lpTemplateDirectory,   // template directory
    LPCSTR                lpNewDirectory,        // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes   // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpNewDirectory);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectoryEx", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateDirectoryExA)(lpTemplateDirectory,
                                            lpNewDirectory,
                                            lpSecurityAttributes);

}


BOOL
APIHOOK(CreateDirectoryExW)(
    LPCWSTR               lpTemplateDirectory,  // template directory
    LPCWSTR               lpNewDirectory,       // directory name
    LPSECURITY_ATTRIBUTES lpSecurityAttributes  // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateDirectoryEx", L"lpSecurityAttributes", lpNewDirectory);
    
    return ORIGINAL_API(CreateDirectoryExW)(lpTemplateDirectory,
                                            lpNewDirectory,
                                            lpSecurityAttributes);

}

BOOL 
APIHOOK(CreateHardLinkA)(
    LPCSTR                  lpFileName,          // link name name
    LPCSTR                  lpExistingFileName,  // target file name
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  
    )
{
    LPWSTR pwszName = ToUnicode(lpFileName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateHardLink", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateHardLinkA)(lpFileName,
                                         lpExistingFileName,
                                         lpSecurityAttributes);


}

BOOL 
APIHOOK(CreateHardLinkW)(
    LPCWSTR                 lpFileName,          // link name name
    LPCWSTR                 lpExistingFileName,  // target file name
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes  
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateHardLink", L"lpSecurityAttributes", lpFileName);
    
    return ORIGINAL_API(CreateHardLinkW)(lpFileName,
                                         lpExistingFileName,
                                         lpSecurityAttributes);


}


HANDLE 
APIHOOK(CreateMailslotA)(
    LPCSTR                  lpName,              // mailslot name
    DWORD                   nMaxMessageSize,     // maximum message size
    DWORD                   lReadTimeout,        // read time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes // inheritance option
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateMailslot", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateMailslotA)(lpName,
                                         nMaxMessageSize,
                                         lReadTimeout,
                                         lpSecurityAttributes);
}

HANDLE 
APIHOOK(CreateMailslotW)(
    LPCWSTR                 lpName,              // mailslot name
    DWORD                   nMaxMessageSize,     // maximum message size
    DWORD                   lReadTimeout,        // read time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes // inheritance option
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateMailslot", L"lpSecurityAttributes", lpName);
    
    return ORIGINAL_API(CreateMailslotW)(lpName,
                                         nMaxMessageSize,
                                         lReadTimeout,
                                         lpSecurityAttributes);
}


HANDLE 
APIHOOK(CreateNamedPipeA)(
    LPCSTR                  lpName,                 // pipe name
    DWORD                   dwOpenMode,             // pipe open mode
    DWORD                   dwPipeMode,             // pipe-specific modes
    DWORD                   nMaxInstances,          // maximum number of instances
    DWORD                   nOutBufferSize,         // output buffer size
    DWORD                   nInBufferSize,          // input buffer size
    DWORD                   nDefaultTimeOut,        // time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes    // SD
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNamedPipe", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateNamedPipeA)(lpName,
                                          dwOpenMode, 
                                          dwPipeMode,
                                          nMaxInstances,      
                                          nOutBufferSize,     
                                          nInBufferSize,      
                                          nDefaultTimeOut,    
                                          lpSecurityAttributes);
}

HANDLE 
APIHOOK(CreateNamedPipeW)(
    LPCWSTR                 lpName,                 // pipe name
    DWORD                   dwOpenMode,             // pipe open mode
    DWORD                   dwPipeMode,             // pipe-specific modes
    DWORD                   nMaxInstances,          // maximum number of instances
    DWORD                   nOutBufferSize,         // output buffer size
    DWORD                   nInBufferSize,          // input buffer size
    DWORD                   nDefaultTimeOut,        // time-out interval
    LPSECURITY_ATTRIBUTES   lpSecurityAttributes    // SD
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNamedPipe", L"lpSecurityAttributes", lpName);
    
    return ORIGINAL_API(CreateNamedPipeW)(lpName,
                                          dwOpenMode, 
                                          dwPipeMode,
                                          nMaxInstances,      
                                          nOutBufferSize,     
                                          nInBufferSize,      
                                          nDefaultTimeOut,    
                                          lpSecurityAttributes);
}

BOOL 
APIHOOK(CreatePipe)(
    PHANDLE                 hReadPipe,         // read handle
    PHANDLE                 hWritePipe,        // write handle
    LPSECURITY_ATTRIBUTES   lpPipeAttributes,  // security attributes
    DWORD                   nSize              // pipe size
    )
{
    CheckSecurityAttributes(lpPipeAttributes, L"CreatePipe", L"lpPipeAttributes", L"Unnamed pipe");
    
    return ORIGINAL_API(CreatePipe)(hReadPipe,
                                    hWritePipe,
                                    lpPipeAttributes,
                                    nSize);
}

HANDLE 
APIHOOK(CreateMutexA)(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD
    BOOL bInitialOwner,                       // initial owner
    LPCSTR lpName                             // object name
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpMutexAttributes, L"CreateMutex", L"lpMutexAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateMutexA)(lpMutexAttributes,
                                      bInitialOwner,
                                      lpName);
}

HANDLE 
APIHOOK(CreateMutexW)(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,  // SD
    BOOL bInitialOwner,                       // initial owner
    LPCWSTR lpName                            // object name
    )
{
    CheckSecurityAttributes(lpMutexAttributes, L"CreateMutex", L"lpMutexAttributes", lpName);
    
    return ORIGINAL_API(CreateMutexW)(lpMutexAttributes,
                                      bInitialOwner,
                                      lpName);
}

HANDLE 
APIHOOK(CreateSemaphoreA)(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD
    LONG lInitialCount,                          // initial count
    LONG lMaximumCount,                          // maximum count
    LPCSTR lpName                                // object name
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpSemaphoreAttributes, L"CreateSemaphore", L"lpSemaphoreAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateSemaphoreA)(lpSemaphoreAttributes,
                                          lInitialCount,
                                          lMaximumCount,
                                          lpName);
}

HANDLE 
APIHOOK(CreateSemaphoreW)(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, // SD
    LONG lInitialCount,                          // initial count
    LONG lMaximumCount,                          // maximum count
    LPCWSTR lpName                               // object name
    )
{
    CheckSecurityAttributes(lpSemaphoreAttributes, L"CreateSemaphore", L"lpSemaphoreAttributes", lpName);
    
    return ORIGINAL_API(CreateSemaphoreW)(lpSemaphoreAttributes,
                                          lInitialCount,
                                          lMaximumCount,
                                          lpName);
}


HANDLE
APIHOOK(CreateWaitableTimerA)(
    IN LPSECURITY_ATTRIBUTES lpTimerAttributes,
    IN BOOL bManualReset,
    IN LPCSTR lpTimerName
    )
{
    LPWSTR pwszName = ToUnicode(lpTimerName);

    CheckSecurityAttributes(lpTimerAttributes, L"CreateWaitableTimer", L"lpTimerAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateWaitableTimerA)(lpTimerAttributes,
                                              bManualReset,
                                              lpTimerName);
}


HANDLE
APIHOOK(CreateWaitableTimerW)(
    IN LPSECURITY_ATTRIBUTES lpTimerAttributes,
    IN BOOL bManualReset,
    IN LPCWSTR lpTimerName
    )
{
    CheckSecurityAttributes(lpTimerAttributes, L"CreateWaitableTimer", L"lpTimerAttributes", lpTimerName);
    
    return ORIGINAL_API(CreateWaitableTimerW)(lpTimerAttributes,
                                              bManualReset,
                                              lpTimerName);
}

HANDLE
APIHOOK(CreateEventA)(
    IN LPSECURITY_ATTRIBUTES lpEventAttributes,
    IN BOOL bManualReset,
    IN BOOL bInitialState,
    IN LPCSTR lpName
    )
{
    LPWSTR pwszName = ToUnicode(lpName);

    CheckSecurityAttributes(lpEventAttributes, L"CreateEvent", L"lpEventAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateEventA)(lpEventAttributes,
                                      bManualReset,
                                      bInitialState,
                                      lpName);
}

HANDLE
APIHOOK(CreateEventW)(
    IN LPSECURITY_ATTRIBUTES lpEventAttributes,
    IN BOOL bManualReset,
    IN BOOL bInitialState,
    IN LPCWSTR lpName
    )
{
    CheckSecurityAttributes(lpEventAttributes, L"CreateEvent", L"lpEventAttributes", lpName);
    
    return ORIGINAL_API(CreateEventW)(lpEventAttributes,
                                      bManualReset,
                                      bInitialState,
                                      lpName);
}

BOOL
APIHOOK(SetFileSecurityA) (
    IN LPCSTR lpFileName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        LPWSTR pwszName = ToUnicode(lpFileName);

        CheckSecurityDescriptor(pSecurityDescriptor, L"SetFileSecurity", L"pSecurityDescriptor", pwszName);

        if (pwszName) {
            free(pwszName);
            pwszName = NULL;
        }
    }
    
    return ORIGINAL_API(SetFileSecurityA)(lpFileName,
                                          SecurityInformation,
                                          pSecurityDescriptor);
}

BOOL
APIHOOK(SetFileSecurityW) (
    IN LPCWSTR lpFileName,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(pSecurityDescriptor, L"SetFileSecurity", L"pSecurityDescriptor", lpFileName);
    }

    return ORIGINAL_API(SetFileSecurityW)(lpFileName,
                                          SecurityInformation,
                                          pSecurityDescriptor);
}


BOOL
APIHOOK(SetKernelObjectSecurity) (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(pSecurityDescriptor, L"SetKernelObjectSecurity", L"pSecurityDescriptor", L"Unknown Kernel Object");
    }

    return ORIGINAL_API(SetKernelObjectSecurity)(Handle,
                                                 SecurityInformation,
                                                 pSecurityDescriptor);
}


DWORD
APIHOOK(SetNamedSecurityInfoA)(
    IN LPSTR               pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOwner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
    )
{
    if (SecurityInfo & DACL_SECURITY_INFORMATION) {
        LPWSTR pwszName = ToUnicode(pObjectName);

        CheckDacl(pDacl, L"SetNamedSecurityInfo", L"pDacl", pwszName);

        if (pwszName) {
            free(pwszName);
            pwszName = NULL;
        }
    }

    return ORIGINAL_API(SetNamedSecurityInfoA)(pObjectName,
                                               ObjectType,
                                               SecurityInfo,
                                               psidOwner,
                                               psidGroup,
                                               pDacl,
                                               pSacl);
}

DWORD
APIHOOK(SetNamedSecurityInfoW)(
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOwner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
    )
{
    if (SecurityInfo & DACL_SECURITY_INFORMATION) {
        CheckDacl(pDacl, L"SetNamedSecurityInfo", L"pDacl", pObjectName);
    }

    return ORIGINAL_API(SetNamedSecurityInfoW)(pObjectName,
                                               ObjectType,
                                               SecurityInfo,
                                               psidOwner,
                                               psidGroup,
                                               pDacl,
                                               pSacl);
}

DWORD
APIHOOK(SetSecurityInfo)(
    IN HANDLE                handle,
    IN SE_OBJECT_TYPE        ObjectType,
    IN SECURITY_INFORMATION  SecurityInfo,
    IN PSID                  psidOwner,
    IN PSID                  psidGroup,
    IN PACL                  pDacl,
    IN PACL                  pSacl
    )
{
    if (SecurityInfo & DACL_SECURITY_INFORMATION) {
        CheckDacl(pDacl, L"SetSecurityInfo", L"pDacl", L"Unknown Object");
    }

    return ORIGINAL_API(SetSecurityInfo)(handle,
                                         ObjectType,
                                         SecurityInfo,
                                         psidOwner,
                                         psidGroup,
                                         pDacl,
                                         pSacl);
}

LONG
APIHOOK(RegSetKeySecurity) (
    IN HKEY hKey,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(pSecurityDescriptor, L"RegSetKeySecurity", L"pSecurityDescriptor", L"Unknown Key");
    }

    return ORIGINAL_API(RegSetKeySecurity)(hKey,
                                           SecurityInformation,
                                           pSecurityDescriptor);
}

BOOL
APIHOOK(SetUserObjectSecurity)(
    IN HANDLE hObj,
    IN PSECURITY_INFORMATION pSIRequested,
    IN PSECURITY_DESCRIPTOR pSID)
{
    if (*pSIRequested & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(pSID, L"SetUserObjectSecurity", L"pSID", L"Unknown Object");
    }

    return ORIGINAL_API(SetUserObjectSecurity)(hObj,
                                               pSIRequested,
                                               pSID);
}


BOOL
APIHOOK(SetServiceObjectSecurity)(
    SC_HANDLE               hService,
    SECURITY_INFORMATION    dwSecurityInformation,
    PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    )
{
    if (dwSecurityInformation & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(lpSecurityDescriptor, L"SetServiceObjectSecurity", L"lpSecurityDescriptor", L"Unknown Service");
    }

    return ORIGINAL_API(SetServiceObjectSecurity)(hService,
                                                  dwSecurityInformation,
                                                  lpSecurityDescriptor);
}


DWORD 
APIHOOK(SetNtmsObjectSecurity)(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    SECURITY_INFORMATION lpSecurityInformation,
    PSECURITY_DESCRIPTOR lpSecurityDescriptor
    )
{
    if (lpSecurityInformation & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(lpSecurityDescriptor, L"SetNtmsObjectSecurity", L"lpSecurityDescriptor", L"Unknown Object");
    }

    return ORIGINAL_API(SetNtmsObjectSecurity)(hSession,
                                               lpObjectId,
                                               dwType,
                                               lpSecurityInformation,
                                               lpSecurityDescriptor);
}


LONG 
APIHOOK(ClusterRegCreateKey)(
    HKEY hKey,                                   
    LPCWSTR lpszSubKey,                          
    DWORD dwOptions,                             
    REGSAM samDesired,                           
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,  
    PHKEY phkResult,                             
    LPDWORD lpdwDisposition                      
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"ClusterRegCreateKey", L"lpSecurityAttributes", lpszSubKey);
    
    return ORIGINAL_API(ClusterRegCreateKey)(hKey,
                                             lpszSubKey,
                                             dwOptions,
                                             samDesired,
                                             lpSecurityAttributes,
                                             phkResult,
                                             lpdwDisposition);
}

LONG 
APIHOOK(ClusterRegSetKeySecurity)(
    HKEY hKey,                                
    SECURITY_INFORMATION SecurityInformation,  
    PSECURITY_DESCRIPTOR pSecurityDescriptor  
    )
{
    if (SecurityInformation & DACL_SECURITY_INFORMATION) {
        CheckSecurityDescriptor(pSecurityDescriptor, L"ClusterRegSetKeySecurity", L"pSecurityDescriptor", L"Unknown Key");
    }

    return ORIGINAL_API(ClusterRegSetKeySecurity)(hKey,
                                                  SecurityInformation,
                                                  pSecurityDescriptor);
}


DWORD 
APIHOOK(CreateNtmsMediaPoolA)(
    HANDLE hSession,
    LPCSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId
    )
{
    LPWSTR pwszName = ToUnicode(lpPoolName);

    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNtmsMediaPool", L"lpSecurityAttributes", pwszName);

    if (pwszName) {
        free(pwszName);
        pwszName = NULL;
    }
    
    return ORIGINAL_API(CreateNtmsMediaPoolA)(hSession,
                                              lpPoolName,
                                              lpMediaType,
                                              dwAction,
                                              lpSecurityAttributes,
                                              lpPoolId);

}

DWORD 
APIHOOK(CreateNtmsMediaPoolW)(
    HANDLE hSession,
    LPCWSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId            // OUT
    )
{
    CheckSecurityAttributes(lpSecurityAttributes, L"CreateNtmsMediaPool", L"lpSecurityAttributes", lpPoolName);
    
    return ORIGINAL_API(CreateNtmsMediaPoolW)(hSession,
                                              lpPoolName,
                                              lpMediaType,
                                              dwAction,
                                              lpSecurityAttributes,
                                              lpPoolId);
}




SHIM_INFO_BEGIN()

    SHIM_INFO_DESCRIPTION(AVS_SECURITYCHECKS_DESC)
    SHIM_INFO_FRIENDLY_NAME(AVS_SECURITYCHECKS_FRIENDLY)
    SHIM_INFO_FLAGS(0)
    SHIM_INFO_GROUPS(0)    
    SHIM_INFO_VERSION(2, 4)
    SHIM_INFO_INCLUDE_EXCLUDE("I:*")

SHIM_INFO_END()

/*++

 Register hooked functions.

--*/
HOOK_BEGIN

    if (fdwReason == DLL_PROCESS_ATTACH) {
        DWORD dwSize;

        InitWorldSid();

        dwSize = GetSystemWindowsDirectoryW(g_wszWinDir, ARRAYSIZE(g_wszWinDir));
        if (dwSize == 0 || dwSize > ARRAYSIZE(g_wszWinDir)) {
            g_wszWinDir[0] = 0;
        }
        g_dwWinDirLen = wcslen(g_wszWinDir);
    }

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_BADARGUMENTS, 
                            AVS_SECURITYCHECKS_BADARGUMENTS,
                            AVS_SECURITYCHECKS_BADARGUMENTS_R,
                            AVS_SECURITYCHECKS_BADARGUMENTS_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WINEXEC, 
                            AVS_SECURITYCHECKS_WINEXEC,
                            AVS_SECURITYCHECKS_WINEXEC_R,
                            AVS_SECURITYCHECKS_WINEXEC_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_NULL_DACL, 
                            AVS_SECURITYCHECKS_NULL_DACL,
                            AVS_SECURITYCHECKS_NULL_DACL_R,
                            AVS_SECURITYCHECKS_NULL_DACL_URL)

    DUMP_VERIFIER_LOG_ENTRY(VLOG_SECURITYCHECKS_WORLDWRITE_DACL, 
                            AVS_SECURITYCHECKS_WORLDWRITE_DACL,
                            AVS_SECURITYCHECKS_WORLDWRITE_DACL_R,
                            AVS_SECURITYCHECKS_WORLDWRITE_DACL_URL)

    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateProcessA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateProcessW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 CreateProcessAsUserA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 CreateProcessAsUserW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 WinExec)

    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileW)
    APIHOOK_ENTRY(USER32.DLL,                   CreateDesktopA)
    APIHOOK_ENTRY(USER32.DLL,                   CreateDesktopW)
    APIHOOK_ENTRY(USER32.DLL,                   CreateWindowStationA)
    APIHOOK_ENTRY(USER32.DLL,                   CreateWindowStationW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegCreateKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegCreateKeyExW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyExA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSaveKeyExW)

    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileMappingA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateFileMappingW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateJobObjectA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateJobObjectW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateThread)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateRemoteThread)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryExA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateDirectoryExW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateHardLinkA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateHardLinkW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMailslotA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMailslotW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateNamedPipeA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateNamedPipeW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreatePipe)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMutexA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateMutexW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateSemaphoreA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateSemaphoreW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateWaitableTimerA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateWaitableTimerW)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateEventA)
    APIHOOK_ENTRY(KERNEL32.DLL,                 CreateEventW)

    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetFileSecurityA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetFileSecurityW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetKernelObjectSecurity)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetNamedSecurityInfoA)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetNamedSecurityInfoW)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetSecurityInfo)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 RegSetKeySecurity)

    APIHOOK_ENTRY(USER32.DLL,                   SetUserObjectSecurity)
    APIHOOK_ENTRY(ADVAPI32.DLL,                 SetServiceObjectSecurity)
    APIHOOK_ENTRY(NTMSAPI.DLL,                  SetNtmsObjectSecurity)
    APIHOOK_ENTRY(CLUSAPI.DLL,                  ClusterRegCreateKey)
    APIHOOK_ENTRY(CLUSAPI.DLL,                  ClusterRegSetKeySecurity)
    APIHOOK_ENTRY(NTMSAPI.DLL,                  CreateNtmsMediaPoolA)
    APIHOOK_ENTRY(NTMSAPI.DLL,                  CreateNtmsMediaPoolW)

HOOK_END



IMPLEMENT_SHIM_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\shellextensions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       ShellExtensions.h
//
//--------------------------------------------------------------------------

#ifndef __SHELLEXTENSIONS_H
#define __SHELLEXTENSIONS_H



class CLayerUIPropPage:
    protected IShellExtInit,
    IShellPropSheetExt,
    public CComObjectRoot,
    public CComCoClass<CLayerUIPropPage, &CLSID_ShimLayerPropertyPage>
{
    BEGIN_COM_MAP(CLayerUIPropPage)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellPropSheetExt)
    END_COM_MAP()

public:
    DECLARE_REGISTRY_CLSID()

    CLayerUIPropPage();
    ~CLayerUIPropPage();

    //
    // IShellExtInit methods
    //
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder,
                            LPDATAOBJECT  pDataObj,
                            HKEY          hKeyID);
  
    //
    // IShellPropSheetExt methods
    //
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                          LPARAM               lParam);

    STDMETHODIMP ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplacePage,
                             LPARAM lParam);
    
    friend INT_PTR CALLBACK
        LayerPageDlgProc(HWND   hdlg,
                         UINT   uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

private:
    CComPtr<IDataObject>  m_spDataObj;

    TCHAR                 m_szFile[MAX_PATH];
};


#endif // __SHELLEXTENSIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\shellextensions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      ShellExtensions.cpp
//
//  Contents:  object to implement propertypage extensions
//             for Win2k shim layer
//
//  History:   23-september-00 clupu    Created
//
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "ShellExtensions.h"
#include <sfc.h>
#include "Aclapi.h"
#include "strsafe.h"

UINT    g_DllRefCount = 0;

extern HINSTANCE g_hInstance;

typedef struct _LAYER_INFO {
    WCHAR   wszInternalName[32];
    UINT    nstrFriendlyName;
} LAYER_INFO, *PLAYER_INFO;

//
// internal definitions of layer names
//
#define STR_LAYER_WIN95             L"WIN95"
#define STR_LAYER_WIN98             L"WIN98"
#define STR_LAYER_WINNT             L"NT4SP5"
#define STR_LAYER_WIN2K             L"WIN2000"
#define STR_LAYER_WINXP             L"WINXP"
#define STR_LAYER_256COLOR          L"256COLOR"
#define STR_LAYER_LORES             L"640X480"
#define STR_LAYER_DISABLETHEMES     L"DISABLETHEMES"
#define STR_LAYER_ENABLELUA         L"LUA"

//
// Layer flags
//
#define FLAG_256                    0x00000001
#define FLAG_640x480                0x00000002
#define FLAG_DISABLE_THEMES         0x00000004
#define FLAG_ENABLE_LUA             0x00000010

const LAYER_INFO g_LayerInfo[] =
{
    {
        STR_LAYER_WIN95,
        IDS_LAYER_WIN95_EXT
    },
    {
        STR_LAYER_WIN98,
        IDS_LAYER_WIN98_EXT
    },
    {
        STR_LAYER_WINNT,
        IDS_LAYER_NT4_EXT
    },
    {
        STR_LAYER_WIN2K,
        IDS_LAYER_WIN2K_EXT
    },
    {
        STR_LAYER_WINXP,
        IDS_LAYER_WINXP_EXT
    }
};


#define NUM_LAYERS (sizeof(g_LayerInfo)/sizeof(g_LayerInfo[0]))

typedef BOOL (STDAPICALLTYPE *_pfn_AllowPermLayer)(WCHAR* pwszPath);
typedef BOOL (STDAPICALLTYPE *_pfn_GetPermLayers)(WCHAR* pwszPath, WCHAR *pwszLayers, DWORD *pdwBytes, DWORD dwFlags);
typedef BOOL (STDAPICALLTYPE *_pfn_SetPermLayers)(WCHAR* pwszPath, WCHAR *pwszLayers, BOOL bMachine);

HINSTANCE g_hAppHelp = NULL;
BOOL      g_bAdmin = FALSE;
BOOL      g_bServer = FALSE;

_pfn_AllowPermLayer g_pfnAllowPermLayer = NULL;
_pfn_GetPermLayers  g_pfnGetPermLayers = NULL;
_pfn_SetPermLayers  g_pfnSetPermLayers = NULL;

void
IsDotNetServer(
    void
    )
{
    OSVERSIONINFOEX osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (!GetVersionEx((OSVERSIONINFO*)&osvi)) {
        return;
    }

    if (osvi.wProductType != VER_NT_WORKSTATION) {
        g_bServer = TRUE;
    }
}

BOOL
CheckGroupPolicy(
    void
    )
{
    HKEY hKey;
    LONG lResult;
    DWORD dwValue, dwSize = sizeof(dwValue);
    DWORD dwType;

    //
    // First, check for the whole engine being disabled.
    //
    lResult = RegOpenKeyExW (HKEY_LOCAL_MACHINE, POLICY_KEY_APPCOMPAT_W, 0,
                            KEY_READ, &hKey);
    if (lResult == ERROR_SUCCESS) {
        dwValue = 0;
        lResult = RegQueryValueExW (hKey, POLICY_VALUE_DISABLE_ENGINE_W, 0, &dwType,
                                   (LPBYTE) &dwValue, &dwSize);
        RegCloseKey (hKey);
    }

    //
    // The default is enabled, so if we didn't find a value, treat it like the value is 0.
    //
    if (lResult != ERROR_SUCCESS || dwValue == 0) {
        //
        // Check for the proppage being disabled.
        //
        lResult = RegOpenKeyExW (HKEY_LOCAL_MACHINE, POLICY_KEY_APPCOMPAT_W, 0,
                                KEY_READ, &hKey);
        if (lResult == ERROR_SUCCESS) {
            dwValue = 0;
            lResult = RegQueryValueExW (hKey, POLICY_VALUE_DISABLE_PROPPAGE_W, 0, &dwType,
                                       (LPBYTE) &dwValue, &dwSize);
            RegCloseKey (hKey);
        }

        //
        // The default is to be enabled, so if we didn't find a value, or the value is 0, then we're good to go.
        //
        if (lResult != ERROR_SUCCESS || dwValue == 0) {
            return TRUE;
        }
    }

    return FALSE;

}

BOOL
InitAppHelpCalls(
    void
    )
{
    HINSTANCE hAppHelp;

    if (g_hAppHelp) {
        //
        // we're already inited
        //
        return TRUE;
    }

    hAppHelp = LoadLibrary(TEXT("apphelp.dll"));
    if (!hAppHelp) {
        LogMsg(_T("[InitAppHelpCalls] Can't get handle to apphelp.dll.\n"));
        return FALSE;
    }

    g_pfnAllowPermLayer = (_pfn_AllowPermLayer)GetProcAddress(hAppHelp, "AllowPermLayer");
    g_pfnGetPermLayers = (_pfn_GetPermLayers)GetProcAddress(hAppHelp, "GetPermLayers");
    g_pfnSetPermLayers = (_pfn_SetPermLayers)GetProcAddress(hAppHelp, "SetPermLayers");

    if (!g_pfnAllowPermLayer || !g_pfnGetPermLayers || !g_pfnSetPermLayers) {
        LogMsg(_T("[InitAppHelpCalls] Can't get function pointers.\n"));
        return FALSE;
    }

    //
    // this needs to be here at the end to avoid a race condition
    //
    g_hAppHelp = hAppHelp;

    return TRUE;
}

BOOL
GiveUsersWriteAccess(
    void
    )
{
    DWORD                    dwRes;
    EXPLICIT_ACCESS          ea;
    PACL                     pOldDACL;
    PACL                     pNewDACL = NULL;
    PSECURITY_DESCRIPTOR     pSD = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    PSID                     pUsersSID = NULL;
    TCHAR                    szDir[MAX_PATH];

    ExpandEnvironmentStrings(LUA_REDIR_W, szDir, MAX_PATH);

    if (!CreateDirectory(szDir, NULL)) {
        DWORD err = GetLastError();

        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            LogMsg(_T("[GiveUsersWriteAccess] Failed to create the directory.\n"));
            return FALSE;
        }
    }

    dwRes = GetNamedSecurityInfo(szDir,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 &pOldDACL,
                                 NULL,
                                 &pSD);

    if (ERROR_SUCCESS != dwRes) {
        LogMsg(_T("[GiveUsersWriteAccess] GetNamedSecurityInfo error %u\n"), dwRes);
        goto Cleanup;
    }

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_USERS,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pUsersSID) ) {
        LogMsg(_T("[GiveUsersWriteAccess] AllocateAndInitializeSid error %u\n"), GetLastError());
        goto Cleanup;
    }

    //
    // Initialize an EXPLICIT_ACCESS structure for the new ACE.
    //
    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    ea.grfAccessPermissions = FILE_GENERIC_WRITE | FILE_GENERIC_READ | DELETE;
    ea.grfAccessMode        = GRANT_ACCESS;
    ea.grfInheritance       = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
    ea.Trustee.TrusteeType  = TRUSTEE_IS_GROUP;
    ea.Trustee.ptstrName    = (LPTSTR)pUsersSID;

    //
    // Create a new ACL that merges the new ACE
    // into the existing DACL.
    //
    dwRes = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);

    if (ERROR_SUCCESS != dwRes)  {
        LogMsg(_T("[GiveUsersWriteAccess] SetEntriesInAcl error %u\n"), dwRes);
        goto Cleanup;
    }

    dwRes = SetNamedSecurityInfo(szDir,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 pNewDACL,
                                 NULL);

    if (ERROR_SUCCESS != dwRes)  {
        LogMsg(_T("[GiveUsersWriteAccess] SetNamedSecurityInfo error %u\n"), dwRes);
        goto Cleanup;
    }

Cleanup:

    if (pSD) {
        LocalFree(pSD);
    }

    if (pUsersSID) {
        FreeSid(pUsersSID);
    }

    if (pNewDACL) {
        LocalFree(pNewDACL);
    }

    return (dwRes == ERROR_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////
// GetLayerInfo
//
BOOL
GetLayerInfo(
    TCHAR* szPath,
    DWORD  dwFrom,
    int*   pnMainLayer,
    DWORD* pdwFlags
    )
{
    WCHAR wszLayers[256];
    DWORD dwBytes = sizeof(wszLayers);
    int   i;

    if (!pnMainLayer || pdwFlags == NULL) {
        LogMsg(_T("[GetLayerInfo] invalid parameters\n"));
        return FALSE;
    }

    *pdwFlags = 0;

    //
    // get layer string
    //
    if (!g_pfnGetPermLayers(szPath, wszLayers, &dwBytes, dwFrom)) {
        *pnMainLayer = -1;
        return TRUE;
    }

    LogMsg(_T("[GetLayerInfo] Layers \"%s\"\n"), wszLayers);

    //
    // Make the layer string upper case, so we'll match case-insensitive
    //
    _wcsupr(wszLayers);

    //
    // find the first layer that matches
    //
    *pnMainLayer = -1;
    for (i = 0; i < NUM_LAYERS; ++i) {
        if (wcsstr(wszLayers, g_LayerInfo[i].wszInternalName) != NULL) {
            *pnMainLayer = i;
        }
    }

    if (wcsstr(wszLayers, STR_LAYER_256COLOR) != NULL) {
        *pdwFlags |= FLAG_256;
    }

    if (wcsstr(wszLayers, STR_LAYER_LORES) != NULL) {
        *pdwFlags |= FLAG_640x480;
    }

    if (wcsstr(wszLayers, STR_LAYER_DISABLETHEMES) != NULL) {
        *pdwFlags |= FLAG_DISABLE_THEMES;
    }

    if (wcsstr(wszLayers, STR_LAYER_ENABLELUA) != NULL) {
        *pdwFlags |= FLAG_ENABLE_LUA;
    }

    LogMsg(_T("[GetLayerInfo] Layers 0x%x\n"), *pdwFlags);

    return TRUE;
}

void
BuildLayerString(
    WCHAR*  pwszLayers,
    DWORD   cchBufSize,
    int     nMainLayer,
    DWORD   dwFlags,
    BOOL    bMachine
    )
{
    pwszLayers[0] = 0;

    if (nMainLayer >= 0 && nMainLayer < NUM_LAYERS) {
        StringCchCatW(pwszLayers, cchBufSize, g_LayerInfo[nMainLayer].wszInternalName);
    }

    if (dwFlags & FLAG_256) {
        if (pwszLayers[0]) {
            StringCchCatW(pwszLayers, cchBufSize, L" ");
        }
        StringCchCatW(pwszLayers, cchBufSize, STR_LAYER_256COLOR);
    }

    if (dwFlags & FLAG_640x480) {
        if (pwszLayers[0]) {
            StringCchCatW(pwszLayers, cchBufSize, L" ");
        }
        StringCchCatW(pwszLayers, cchBufSize, STR_LAYER_LORES);
    }

    if (dwFlags & FLAG_DISABLE_THEMES) {
        if (pwszLayers[0]) {
            StringCchCatW(pwszLayers, cchBufSize, L" ");
        }
        StringCchCatW(pwszLayers, cchBufSize, STR_LAYER_DISABLETHEMES);
    }

    if (bMachine) {
        if (dwFlags & FLAG_ENABLE_LUA) {
            if (pwszLayers[0]) {
                StringCchCatW(pwszLayers, cchBufSize, L" ");
            }
            StringCchCatW(pwszLayers, cchBufSize, STR_LAYER_ENABLELUA);
        }
    }
}

//////////////////////////////////////////////////////////////////////////
// SetLayerInfo
//
BOOL
SetLayerInfo(
    TCHAR* szPath,
    int    nMainLayer,
    DWORD  dwFlags
    )
{
    WCHAR wszLayers[256];

    //
    // build layer string
    //
    BuildLayerString(wszLayers, ARRAYSIZE(wszLayers), nMainLayer, dwFlags, FALSE);

    if (g_bAdmin) {

        WCHAR wszMachineLayers[256];
        DWORD dwMachineFlags;
        int   nMainLayer;
        //
        // Get the layers first.
        //
        GetLayerInfo(szPath, GPLK_MACHINE, &nMainLayer, &dwMachineFlags);

        if (dwFlags & FLAG_ENABLE_LUA) {
            if (!GiveUsersWriteAccess()) {
                LogMsg(_T("[SetLayerInfo] Failed to change directory ACLs.\n"));
            }

            dwMachineFlags |= FLAG_ENABLE_LUA;

        } else {
            dwMachineFlags &= ~FLAG_ENABLE_LUA;
        }

        BuildLayerString(wszMachineLayers, ARRAYSIZE(wszMachineLayers), nMainLayer, dwMachineFlags, TRUE);

        if (!g_pfnSetPermLayers(szPath, wszMachineLayers, TRUE)) {
            return FALSE;
        }
    }

    //
    // set it
    //
    return g_pfnSetPermLayers(szPath, wszLayers, FALSE);
}

void
NotifyDataChanged(
    HWND hDlg
    )
{
    HWND hParent;

    if (!hDlg) {
        LogMsg(_T("[NotifyDataChanged] NULL handle passed in\n"));
        return;
    }

    hParent = GetParent(hDlg);

    if (!hParent) {
        LogMsg(_T("[NotifyDataChanged] Can't get get prop sheet parent\n"));
        return;
    }

    PropSheet_Changed(hParent, hDlg);
}


BOOL
SearchGroupForSID(
    DWORD dwGroup,
    BOOL* pfIsMember
    )
{
    PSID                     pSID = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth = SECURITY_NT_AUTHORITY;
    BOOL                     fRes = FALSE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 dwGroup,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 &pSID)) {
        LogMsg(_T("[SearchGroupForSID] AllocateAndInitializeSid failed 0x%X\n"), GetLastError());
        goto out;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        LogMsg(_T("[SearchGroupForSID] CheckTokenMembership failed 0x%X\n"), GetLastError());
        goto out;
    }

    fRes = TRUE;

out:

    if (pSID) {
        FreeSid(pSID);
    }

    if (!fRes && pfIsMember) {
        *pfIsMember = FALSE;
    }

    return fRes;
}

void
CheckForRestrictedUser(
    void
    )
{
    BOOL fIsAdmin = FALSE;

    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &fIsAdmin)) {
        return;
    }

    g_bAdmin = fIsAdmin;

    return;
}

//////////////////////////////////////////////////////////////////////////
// LayerPageDlgProc
//
//  The dialog proc for the layer property page.

INT_PTR CALLBACK
LayerPageDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int   wCode       = LOWORD(wParam);
    int   wNotifyCode = HIWORD(wParam);
    int   nLayer      = -1;
    DWORD dwFlags     = 0;

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            PROPSHEETPAGE*    ppsp      = (PROPSHEETPAGE*)lParam;
            DWORD             dwFlags   = 0;
            CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)ppsp->lParam;
            HINSTANCE         hSlayerXPInst     = NULL;
            BOOL              bSystemBinary;
            int i;

            LogMsg(_T("[LayerPageDlgProc] WM_INITDIALOG - item \"%s\"\n"),
                   pPropPage->m_szFile);

            //
            // Store the name of the EXE/LNK in the dialog.
            //
            SetWindowLongPtr(hdlg, GWLP_USERDATA, (LONG_PTR)pPropPage->m_szFile);

            //
            // Check for restricted users.
            //
            CheckForRestrictedUser();

            //
            // Check for .NET Server which uses a different URL for help center.
            //
            IsDotNetServer();

            if (!g_bAdmin) {
                EnableWindow(GetDlgItem(hdlg, IDC_ENABLELUA), FALSE);
            }

            //
            // Add the names of the layers.
            //
            for (i = 0; i < NUM_LAYERS; ++i) {
                TCHAR szFriendlyName[100];

                if (LoadString(g_hInstance, g_LayerInfo[i].nstrFriendlyName, szFriendlyName, ARRAYSIZE(szFriendlyName))) {
                    SendDlgItemMessage(hdlg,
                                       IDC_LAYER_NAME,
                                       CB_ADDSTRING,
                                       0,
                                       (LPARAM)szFriendlyName);
                }
            }

            //
            // Check if the EXE is SFPed.
            //
            bSystemBinary = SfcIsFileProtected(0, pPropPage->m_szFile);

            //
            // Check to see if we can change layers on this file
            //
            if (!g_pfnAllowPermLayer(pPropPage->m_szFile) || bSystemBinary) {

                TCHAR szTemp[256] = _T("");

                SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
                EnableWindow(GetDlgItem(hdlg, IDC_USE_LAYER), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_256COLORS), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_640X480), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_ENABLE_THEMES), FALSE);
                EnableWindow(GetDlgItem(hdlg, IDC_ENABLELUA), FALSE);

                //
                // Change the text on the static object
                //
                if (bSystemBinary) {
                    LoadString(g_hInstance, IDS_COMPAT_UNAVAILABLE_SYSTEM, szTemp, ARRAYSIZE(szTemp));
                } else {
                    LoadString(g_hInstance, IDS_COMPAT_UNAVAILABLE, szTemp, ARRAYSIZE(szTemp));
                }

                SendDlgItemMessage(hdlg, IDC_TEXT_INSTRUCTIONS, WM_SETTEXT, 0, (LPARAM)szTemp);

            } else {
                //
                // Read the layer storage for info on this item.
                //
                GetLayerInfo(pPropPage->m_szFile, GPLK_ALL, &nLayer, &dwFlags);

                //
                // Select the appropriate layer for this item. If no info
                // is available in the layer store, default to the Win9x layer.
                //
                if (nLayer != -1) {
                    SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, nLayer, 0);
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);
                    SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_SETCHECK, BST_CHECKED, 0);

                } else {
                    SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), FALSE);
                    SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_SETCHECK, BST_UNCHECKED, 0);
                }

                if (dwFlags & FLAG_256) {
                    SendDlgItemMessage(hdlg, IDC_256COLORS, BM_SETCHECK, BST_CHECKED, 0);
                }

                if (dwFlags & FLAG_640x480) {
                    SendDlgItemMessage(hdlg, IDC_640X480, BM_SETCHECK, BST_CHECKED, 0);
                }

                if (dwFlags & FLAG_DISABLE_THEMES) {
                    SendDlgItemMessage(hdlg, IDC_ENABLE_THEMES, BM_SETCHECK, BST_CHECKED, 0);
                }

                if (dwFlags & FLAG_ENABLE_LUA) {
                    SendDlgItemMessage(hdlg, IDC_ENABLELUA, BM_SETCHECK, BST_CHECKED, 0);
                }
            }

            break;
        }

    case WM_HELP:
        {
            LPHELPINFO lphi;

            lphi = (LPHELPINFO)lParam;
            if (lphi->iContextType == HELPINFO_WINDOW) {
                WinHelp((HWND)lphi->hItemHandle,
                        L"Windows.hlp",
                        HELP_CONTEXTPOPUP,
                        (DWORD)lphi->iCtrlId);

            }
            break;
       }
   case WM_COMMAND:
        {

            switch (wNotifyCode) {

            case CBN_SELCHANGE:
                NotifyDataChanged(hdlg);
                return TRUE;
            }

            switch (wCode) {

            case IDC_256COLORS:
            case IDC_640X480:
            case IDC_ENABLE_THEMES:
            case IDC_ENABLELUA:
                NotifyDataChanged(hdlg);
                break;


            case IDC_USE_LAYER:
                if (SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);

                } else {
                    EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), FALSE);
                }
                NotifyDataChanged(hdlg);
                break;

            default:
                return FALSE;
            }
            break;
        }

    case WM_NOTIFY:
        {
            NMHDR *pHdr = (NMHDR*)lParam;

            switch (pHdr->code) {
            case NM_CLICK:
            case NM_RETURN:
                {
                    if ((int)wParam != IDC_LEARN) {
                        break;
                    }

                    SHELLEXECUTEINFO sei = { 0 };

                    sei.cbSize = sizeof(SHELLEXECUTEINFO);
                    sei.fMask  = SEE_MASK_DOENVSUBST;
                    sei.hwnd   = hdlg;
                    sei.nShow  = SW_SHOWNORMAL;

                    if (g_bServer) {
                        sei.lpFile = _T("hcp://services/subsite?node=Troubleshooting_Strategies&")
                                     _T("topic=MS-ITS%3A%25HELP_LOCATION%25%5Cmisc.chm%3A%3A/")
                                     _T("compatibility_tab_and_wizard.htm");
                    } else {
                        sei.lpFile = _T("hcp://services/subsite?node=TopLevelBucket_4/")
                                     _T("Fixing_a_problem&topic=MS-ITS%3A%25HELP_LOCATION")
                                     _T("%25%5Cmisc.chm%3A%3A/compatibility_tab_and_wizard.htm")
                                     _T("&select=TopLevelBucket_4/Fixing_a_problem/")
                                     _T("Application_and_software_problems");
                    }

                    ShellExecuteEx(&sei);
                    break;
                }
            case PSN_APPLY:
                {
                    TCHAR *szFile;

                    szFile = (TCHAR*)GetWindowLongPtr(hdlg, GWLP_USERDATA);

                    if (szFile) {
                        if (SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                            LRESULT retval;

                            retval = SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_GETCURSEL, 0, 0);
                            if (retval == CB_ERR) {
                                LogMsg(_T("[LayerPageDlgProc] Can't get combobox selection\n"));
                                nLayer = -1;
                            } else {
                                nLayer = (int)retval;
                            }
                        } else {
                            nLayer = -1;
                        }

                        dwFlags = 0;

                        if (SendDlgItemMessage(hdlg, IDC_256COLORS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                            dwFlags |= FLAG_256;
                        }

                        if (SendDlgItemMessage(hdlg, IDC_640X480, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                            dwFlags |= FLAG_640x480;
                        }

                        if (SendDlgItemMessage(hdlg, IDC_ENABLE_THEMES, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                            dwFlags |= FLAG_DISABLE_THEMES;
                        }

                        if (SendDlgItemMessage(hdlg, IDC_ENABLELUA, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                            dwFlags |= FLAG_ENABLE_LUA;
                        }

                        SetLayerInfo(szFile, nLayer, dwFlags);
                    } else {
                        LogMsg(_T("[LayerPageDlgProc] Can't get file name from WindowLong\n"));
                    }

                    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, PSNRET_NOERROR);

                    break;
                }
            }
            return TRUE;
        }

    default:
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
// LayerPageCallbackProc
//
//  The callback for the property page.

UINT CALLBACK
LayerPageCallbackProc(
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    switch (uMsg) {
    case PSPCB_RELEASE:
        if (ppsp->lParam != 0) {
            CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)(ppsp->lParam);

            LogMsg(_T("[LayerPageCallbackProc] releasing CLayerUIPropPage\n"));

            pPropPage->Release();
        }
        break;
    }

    return 1;
}


BOOL
GetExeFromLnk(
    TCHAR* pszLnk,
    TCHAR* pszExe,
    int    cchSize
    )
{
    HRESULT         hres;
    IShellLink*     psl = NULL;
    IPersistFile*   pPf = NULL;
    TCHAR           szArg[MAX_PATH];
    BOOL            bSuccess = FALSE;

    IShellLinkDataList* psldl = NULL;
    EXP_DARWIN_LINK*    pexpDarwin = NULL;

    hres = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID*)&psl);
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] CoCreateInstance failed\n"));
        return FALSE;
    }

    hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&pPf);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] QueryInterface for IPersistFile failed\n"));
        goto cleanup;
    }

    //
    // Load the link file.
    //
    hres = pPf->Load(pszLnk, STGM_READ);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to load link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    //
    // See if this is a DARWIN link.
    //

    hres = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&psldl);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get IShellLinkDataList.\n"));
    } else {
        hres = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);

        if (SUCCEEDED(hres)) {
            LogMsg(_T("[GetExeFromLnk] this is a DARWIN link \"%s\".\n"),
                   pszLnk);
            goto cleanup;
        }
    }

    //
    // Resolve the link.
    //
    hres = psl->Resolve(NULL,
                        SLR_NOTRACK | SLR_NOSEARCH | SLR_NO_UI | SLR_NOUPDATE);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to resolve the link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    pszExe[0] = 0;

    //
    // Get the path to the link target.
    //
    hres = psl->GetPath(pszExe,
                        cchSize,
                        NULL,
                        SLGP_UNCPRIORITY);

    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get the path for link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    bSuccess = TRUE;

cleanup:

    if (pPf) {
        pPf->Release();
    }

    if (psl) {
        psl->Release();
    }

    if (psldl) {
        psldl->Release();
    }

    if (pexpDarwin) {
        LocalFree(pexpDarwin);
    }

    return bSuccess;
}


//////////////////////////////////////////////////////////////////////////
// CLayerUIPropPage

CLayerUIPropPage::CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::CLayerUIPropPage]\n"));
}

CLayerUIPropPage::~CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::~CLayerUIPropPage]\n"));
}

//////////////////////////////////////////////////////////////////////////
//
// Function: ValidateExecutableFile
//
// This function exists also in compatUI.dll for the purpose of validating
// the file as being acceptable for compatibility handling. It looks at the
// file extension to determine whether a given file is "acceptable"
//

BOOL
ValidateExecutableFile(
    LPCTSTR pszPath,
    BOOL    bValidateFileExists,
    BOOL*   pbIsLink
    )
{
    LPTSTR rgExt[] = {  // this list should be sorted
            _T("BAT"),
            _T("CMD"),
            _T("COM"),
            _T("EXE"),
            _T("LNK"),
            _T("PIF")
            };
    LPTSTR pExt;
    TCHAR  szLnk[] = _T("LNK");
    int i;
    int iCmp = 1;

    pExt = PathFindExtension(pszPath);
    if (pExt == NULL || *pExt == TEXT('\0')) {
        return FALSE;
    }
    ++pExt; // move past '.'

    for (i = 0; i < sizeof(rgExt)/sizeof(rgExt[0]) && iCmp > 0; ++i) {
        iCmp = _tcsicmp(pExt, rgExt[i]);
    }

    if (iCmp) {
        return FALSE;
    }

    if (pbIsLink) {
        *pbIsLink = !_tcsicmp(pExt, szLnk);
    }

    return bValidateFileExists ? PathFileExists(pszPath) : TRUE;
}


//////////////////////////////////////////////////////////////////////////
// IShellExtInit methods

STDMETHODIMP
CLayerUIPropPage::Initialize(
    LPCITEMIDLIST pIDFolder,
    LPDATAOBJECT  pDataObj,
    HKEY          hKeyID
    )
{
    LogMsg(_T("[CLayerUIPropPage::Initialize]\n"));

    if (pDataObj == NULL) {
        LogMsg(_T("\t failed. bad argument.\n"));
        return E_INVALIDARG;
    }

    //
    // check the policy settings
    //
    if (!CheckGroupPolicy()) {
        LogMsg(_T("\t failed. Group policy set to disable compat UI.\n"));
        return  E_ACCESSDENIED;
    }

    //
    // init the apphelp calls
    //
    if (!InitAppHelpCalls()) {
        LogMsg(_T("\t failed. couldn't init apphelp calls.\n"));
        return  E_FAIL;
    }

    //
    // Store a pointer to the data object
    //
    m_spDataObj = pDataObj;

    //
    // If a data object pointer was passed in, save it and
    // extract the file name.
    //
    STGMEDIUM   medium;
    UINT        uCount;
    FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1,
        TYMED_HGLOBAL};

    m_szFile[0] = 0;

    if (SUCCEEDED(m_spDataObj->GetData(&fe, &medium))) {

        //
        // Get the file name from the CF_HDROP.
        //
        uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1,
                               NULL, 0);
        if (uCount == 1) {

            TCHAR  szExe[MAX_PATH];
            BOOL   bIsLink = FALSE;

            DragQueryFile((HDROP)medium.hGlobal, 0, szExe,
                          sizeof(szExe) / sizeof(TCHAR));

            LogMsg(_T("\tProp page for: \"%s\".\n"), szExe);

            if (ValidateExecutableFile(szExe, TRUE, &bIsLink)) {


                if (bIsLink) {
                    //
                    // the file is a link indeed, get the contents
                    //
                    if (!GetExeFromLnk(szExe, m_szFile, ARRAYSIZE(m_szFile))) {

                        //
                        // can't get exe from the link
                        //
                        LogMsg(_T("Couldn't convert \"%s\" to EXE.\n"), m_szFile);
                        m_szFile[0] = 0;

                    } else {

                        LogMsg(_T("\tLNK points to: \"%s\".\n"), m_szFile);
                        //
                        // check to see if it's a shortcut to an EXE file
                        //
                        if (!ValidateExecutableFile(m_szFile, FALSE, NULL)) {
                            //
                            // shortcut points to a file of the unsupported type, reset the name
                            //
                            LogMsg(_T("\tNot an EXE file. Won't init prop page.\n"), m_szFile);
                            m_szFile[0] = 0;
                        }
                    }
                } else {
                    //
                    // not a link, just copy the filename
                    //

                    StringCchCopy(m_szFile, ARRAYSIZE(m_szFile), szExe);

                }
            } else {
                //
                // this is the case when the file is not .lnk, exe or other recognizable type.
                //
                LogMsg(_T("\tNot an EXE or LNK file. Won't init prop page.\n"));
                m_szFile[0] = 0;
            }
        }

        ReleaseStgMedium(&medium);
    } else {
        LogMsg(_T("\t failed to get the data.\n"));
    }

    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////
// IShellPropSheetExt methods


STDMETHODIMP
CLayerUIPropPage::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    PROPSHEETPAGE  psp;
    HPROPSHEETPAGE hPage;
    TCHAR          szCompatibility[128] = _T("");
    BOOL           fIsGuest = FALSE;
    DWORD          dwBinaryType = SCS_32BIT_BINARY;

    LogMsg(_T("[CLayerUIPropPage::AddPages]\n"));

    if (m_szFile[0] == 0) {
        return S_OK;
    }

    if (GetBinaryTypeW(m_szFile, &dwBinaryType)) {
        if (dwBinaryType == SCS_64BIT_BINARY) {
            //
            // If this is a 64-bit binary, don't show the page.
            //
            //
            LogMsg(_T("\tDisable the compatibility page for 64-bit binary\n"));
            return S_OK;            
        }
    }

    //
    // Disable the property page for guests
    //
    if (!SearchGroupForSID(DOMAIN_ALIAS_RID_GUESTS, &fIsGuest)) {
        LogMsg(_T("\tFailed to lookup the GUEST account\n"));
        return S_OK;
    }

    if (fIsGuest) {
        LogMsg(_T("\tDisable the compatibility page for the GUEST account\n"));
        return S_OK;
    }

    if (!LoadString(g_hInstance, IDS_COMPATIBILITY, szCompatibility, ARRAYSIZE(szCompatibility))) {
        LogMsg(_T("\tFailed to load \"Compatibility\" resource string\n"));
        return S_OK;
    }

    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance     = _Module.m_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_LAYER_PROPPAGE);
    psp.hIcon         = 0;
    psp.pszTitle      = szCompatibility;
    psp.pfnDlgProc    = LayerPageDlgProc;
    psp.pcRefParent   = &g_DllRefCount;
    psp.pfnCallback   = LayerPageCallbackProc;
    psp.lParam        = (LPARAM)this;

    LogMsg(_T("\titem           \"%s\".\n"), m_szFile);
    LogMsg(_T("\tg_DllRefCount  %d.\n"), g_DllRefCount);

    AddRef();

    hPage = CreatePropertySheetPage(&psp);

    if (hPage != NULL) {

        if (lpfnAddPage(hPage, lParam)) {
            return S_OK;
        } else {
            DestroyPropertySheetPage(hPage);
            Release();
            return S_OK;
        }
    } else {
        return E_OUTOFMEMORY;
    }

    return E_FAIL;
}

STDMETHODIMP
CLayerUIPropPage::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplacePage,
    LPARAM               lParam
    )
{
    LogMsg(_T("[CLayerUIPropPage::ReplacePage]\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\win2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SlayerUI.rc
//
#define IDS_PROJNAME                    100
#define IDD_LAYER_PROPPAGE              101
#define IDC_USE_LAYER                   1004
#define IDC_LAYER_NAME                  1005
#define IDC_DISABLE_OTHER_FIXES         1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_)
#define AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#if ( _ATL_VER >= 0x0300 )
#define _ATL_NO_UUIDOF 
#endif


using namespace ATL;

class CLayerUIModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID()                                        \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                    \
{                                                                       \
    return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);    \
}

extern CLayerUIModule _Module;

#include <atlcom.h>

#include <shellapi.h>
#include <shlobj.h>

extern const CLSID CLSID_ShimLayerPropertyPage;

#if DBG

    void LogMsgDbg(LPTSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else

    #define LogMsg

#endif // DBG


#include "shfusion.h"
#include "shimdb.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\slayerver.h ===
//
// Increase me when you update the code!
//
#define SLAYER_BIN_VERSION 6,0,5,0

#define SLAYER_STRING_VERSION_HELPER(x) #x
#define SLAYER_STRING_VERSION(x) SLAYER_STRING_VERSION_HELPER(x)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\win2k\shellextensions.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 2000
//
//  File:       ShellExtensions.h
//
//--------------------------------------------------------------------------

#ifndef __SHELLEXTENSIONS_H
#define __SHELLEXTENSIONS_H

#define LI_WIN95    0x00000001
#define LI_NT4      0x00000002
#define LI_WIN98    0x00000004

#define LS_MAGIC    0x07036745

void InitLayerStorage(BOOL bDelete);
void CheckForRights(void);

//
// LayeredItemOperation flags
//
#define LIO_READITEM    1
#define LIO_ADDITEM     2
#define LIO_DELETEITEM  3

#ifndef ARRAYSIZE
#define ARRAYSIZE(rg) (sizeof(rg)/sizeof((rg)[0]))
#endif


typedef struct tagLayerStorageHeader {
    DWORD       dwItemCount;    // number of items in the file
    DWORD       dwMagic;        // magic to identify the file
    SYSTEMTIME  timeLast;       // time of last access
} LayerStorageHeader, *PLayerStorageHeader;


typedef struct tagLayeredItem {
    WCHAR   szItemName[MAX_PATH];
    DWORD   dwFlags;

} LayeredItem, *PLayeredItem;


class CLayerUIPropPage:
    protected IShellExtInit,
    IShellPropSheetExt,
    public CComObjectRoot,
    public CComCoClass<CLayerUIPropPage, &CLSID_ShimLayerPropertyPage>
{
    BEGIN_COM_MAP(CLayerUIPropPage)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IShellPropSheetExt)
    END_COM_MAP()

public:
    DECLARE_REGISTRY_CLSID()

    CLayerUIPropPage();
    ~CLayerUIPropPage();

    //
    // IShellExtInit methods
    //
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder,
                            LPDATAOBJECT  pDataObj,
                            HKEY          hKeyID);
  
    //
    // IShellPropSheetExt methods
    //
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage,
                          LPARAM               lParam);

    STDMETHODIMP ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplacePage,
                             LPARAM lParam);
    
    friend INT_PTR CALLBACK
        LayerPageDlgProc(HWND   hdlg,
                         UINT   uMsg,
                         WPARAM wParam,
                         LPARAM lParam);

private:
    CComPtr<IDataObject>  m_spDataObj;

    TCHAR                 m_szFile[MAX_PATH];
};


#endif // __SHELLEXTENSIONS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\slayerxp.cpp ===
// SlayerXP.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SlayerUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>

#include "shlobjp.h"

#include "SlayerXP.h"

#include <stdio.h>
#include <stdarg.h>

#include "SlayerXP_i.c"

#include "ShellExtensions.h"
#include "strsafe.h"

// {513d916f-2a8e-4f51-aeab-0cbc76fb1af8}
static const CLSID CLSID_ShimLayerPropertyPage = 
  {	0x513d916f, 0x2a8e, 0x4f51, { 0xae, 0xab, 0x0c, 0xbc, 0x76, 0xfb, 0x1a, 0xf8 } };


HINSTANCE g_hInstance;
CLayerUIModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_ShimLayerPropertyPage, CLayerUIPropPage)
END_OBJECT_MAP()

#if DBG

/////////////////////////////////////////////////////////////////////////////
// LogMsgDbg

void LogMsgDbg(
    LPTSTR pwszFmt,
    ... )
{
    WCHAR   gwszT[1024];
    va_list arglist;

    va_start(arglist, pwszFmt);
    StringCchVPrintfW(gwszT, ARRAYSIZE(gwszT), pwszFmt, arglist);
    va_end(arglist);
    
    OutputDebugStringW(gwszT);
}

#endif // DBG

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;

        _Module.Init(ObjectMap, hInstance, &LIBID_SLAYERUILib);

        SHFusionInitializeFromModuleID(hInstance, SXS_MANIFEST_RESOURCE_ID);

        LinkWindow_RegisterClass();

        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH) {

        SHFusionUninitialize();

        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\win2k\shellextensions.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:      ShellExtensions.cpp
//
//  Contents:  object to implement propertypage extensions
//             for Win2k shim layer
//
//  History:   23-september-00 clupu    Created
//             
//
//--------------------------------------------------------------------------

#include "stdafx.h"
#include "resource.h"
#include "ShellExtensions.h"
#include "strsafe.h"

UINT    g_DllRefCount = 0;
BOOL    g_bExtEnabled = FALSE;
TCHAR   g_szLayerStorage[MAX_PATH] = _T("");

//////////////////////////////////////////////////////////////////////////
// InitLayerStorage
//
//  Get the name of the file that will be used to store
//  information about which EXEs/LNKs are layered.

void
InitLayerStorage(
    BOOL bDelete
    )
{
    GetSystemWindowsDirectory(g_szLayerStorage, ARRAYSIZE(g_szLayerStorage));
    
    if (g_szLayerStorage[lstrlen(g_szLayerStorage) - 1] == _T('\\')) {
        g_szLayerStorage[lstrlen(g_szLayerStorage) - 1] = 0;
    }
    
    StringCchCat(g_szLayerStorage, ARRAYSIZE(g_szLayerStorage), _T("\\AppPatch\\LayerStorage.dat"));

    if (bDelete) {
        DeleteFile(g_szLayerStorage);
    }
}


//////////////////////////////////////////////////////////////////////////
// CheckForRights
//

#define APPCOMPAT_KEY         _T("System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility")
#define APPCOMPAT_TEST_SUBKEY _T("12181969-7036745")

void
CheckForRights(
    void
    )
{
    HKEY hkey = NULL, hkeyTest = NULL;
    LONG lRes;

    g_bExtEnabled = FALSE;
    
    lRes = RegOpenKey(HKEY_LOCAL_MACHINE, APPCOMPAT_KEY, &hkey);
    
    if (lRes != ERROR_SUCCESS) {
        LogMsg(_T("[CheckForRights] cannot open the appcompat key.\n")
               _T("The appcompat shell extension will be disabled\n"));
        return;
    }
    
    lRes = RegCreateKey(hkey, APPCOMPAT_TEST_SUBKEY, &hkeyTest);

    if (lRes != ERROR_SUCCESS) {
        LogMsg(_T("[CheckForRights] cannot create test registry key.\n")
               _T("The appcompat shell extension will be disabled\n"));
        goto cleanup;
    }
    
    RegCloseKey(hkeyTest);
    hkeyTest = NULL;
    
    lRes = RegDeleteKey(hkey, APPCOMPAT_TEST_SUBKEY);
    
    if (lRes != ERROR_SUCCESS) {
        LogMsg(_T("[CheckForRights] cannot delete test registry key.\n")
               _T("The appcompat shell extension will be disabled\n"));
        goto cleanup;
    }
    
    g_bExtEnabled = TRUE;

cleanup:
    if (hkey != NULL) {
        RegCloseKey(hkey);
    }
}


//////////////////////////////////////////////////////////////////////////
// CreateLayeredStorage
//
//  Create the file for layer storage.

void
CreateLayeredStorage(
    LPWSTR pszItem,
    DWORD  dwFlags
    )
{
    HANDLE hFile;

    hFile = CreateFile(g_szLayerStorage,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       CREATE_NEW,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        LogMsg(_T("[CreateLayeredStorage] cannot create the storage file!\n"));
        return;
    }

    LayerStorageHeader Header;
    LayeredItem        Item;

    Header.dwItemCount = 1;
    Header.dwMagic     = LS_MAGIC;

    GetLocalTime(&Header.timeLast);

    ZeroMemory(&Item, sizeof(Item));

    Item.dwFlags = dwFlags;
    StringCchCopy(Item.szItemName, ARRAYSIZE(Item.szItemName), pszItem);

    DWORD dwBytesWritten = 0;

    WriteFile(hFile, &Header, sizeof(Header), &dwBytesWritten, NULL);
    WriteFile(hFile, &Item,   sizeof(Item),   &dwBytesWritten, NULL);
    
    LogMsg(_T("[CreateLayeredStorage] storage file \"%s\" initialized\n"),
           g_szLayerStorage);
    
    CloseHandle(hFile);
}

//////////////////////////////////////////////////////////////////////////
// LayeredItemOperation
//
//  Add/Delete/Query items in the layer storage

void
LayeredItemOperation(
    LPWSTR  pszItem,
    DWORD   dwOp,
    LPDWORD lpdwFlags
    )
{
    LogMsg(_T("[LayeredItemOperation] op %d item \"%s\"\n"),
           dwOp, pszItem);

    HANDLE              hFile        = INVALID_HANDLE_VALUE;
    HANDLE              hFileMapping = NULL;
    DWORD               dwFileSize;
    PBYTE               pData        = NULL;
    PLayerStorageHeader pHeader      = NULL;
    PLayeredItem        pItems;
    PLayeredItem        pCrtItem     = NULL;
    int                 nLeft, nRight, nMid, nItem;
    BOOL                bShrinkFile  = FALSE;
    
    //
    // Make sure we don't corrupt the layer storage.
    //
    if (lstrlenW(pszItem) + 1 > MAX_PATH) {
        pszItem[MAX_PATH - 1] = 0;
    }
    
    hFile = CreateFile(g_szLayerStorage,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        
        LogMsg(_T("[LayeredItemOperation] the layer storage doesn't exist\n"));
        
        if (dwOp == LIO_READITEM) {
            *lpdwFlags = 0;
            return;
        }

        if (dwOp == LIO_DELETEITEM) {
            LogMsg(_T("[LayeredItemOperation] cannot delete item\n"));
            return;
        }

        //
        // The file doesn't exist and the operation is LIO_ADDITEM.
        // Create the file, write the item and get out.
        //
        CreateLayeredStorage(pszItem, *lpdwFlags);
        return;
    }

    //
    // The file already exists. Create a file mapping that will allow
    // for adding/deleting/querying the item.
    //
    dwFileSize = GetFileSize(hFile, NULL);

    hFileMapping = CreateFileMapping(hFile,
                                     NULL,
                                     PAGE_READWRITE,
                                     0,
                                     dwFileSize + (dwOp == LIO_ADDITEM ? sizeof(LayeredItem) : 0),
                                     NULL);

    if (hFileMapping == NULL) {
        LogMsg(_T("[LayeredItemOperation] CreateFileMapping failed 0x%X\n"),
               GetLastError());
        goto done;
    }

    pData = (PBYTE)MapViewOfFile(hFileMapping,
                                 FILE_MAP_READ | FILE_MAP_WRITE,
                                 0,
                                 0,
                                 0);
    
    if (pData == NULL) {
        LogMsg(_T("[LayeredItemOperation] MapViewOfFile failed 0x%X\n"),
               GetLastError());
        goto done;
    }

    pHeader = (PLayerStorageHeader)pData;

    pItems = (PLayeredItem)(pData + sizeof(LayerStorageHeader));

    //
    // Make sure it's our file.
    //
    if (dwFileSize < sizeof(LayerStorageHeader) || pHeader->dwMagic != LS_MAGIC) {
        LogMsg(_T("[LayeredItemOperation] invalid file magic 0x%0X\n"),
               pHeader->dwMagic);
        goto done;
    }

    //
    // Get the last access time.
    //
    GetLocalTime(&pHeader->timeLast);
    
    //
    // First search for the item. The array is sorted so we do binary search.
    //
    nItem = -1, nLeft = 0, nRight = (int)pHeader->dwItemCount - 1;

    while (nLeft <= nRight) {
        
        int nVal;
        
        nMid = (nLeft + nRight) / 2;

        pCrtItem  = pItems + nMid;
        
        nVal = lstrcmpi(pszItem, pCrtItem->szItemName);
        
        if (nVal == 0) {
            nItem = nMid;
            break;
        } else if (nVal < 0) {
            nRight = nMid - 1;
        } else {
            nLeft = nMid + 1;
        }
    }

    if (nItem == -1) {
        LogMsg(_T("[LayeredItemOperation] the item was not found in the file.\n"));

        if (dwOp == LIO_DELETEITEM) {
            goto done;
        }
        
        if (dwOp == LIO_READITEM) {
            *lpdwFlags = 0;
            goto done;
        }
        
        if (pHeader->dwItemCount == 0) {
            pCrtItem = pItems;
        } else {
            
            MoveMemory(pItems + nLeft + 1,
                       pItems + nLeft,
                       ((int)pHeader->dwItemCount - nLeft) * sizeof(LayeredItem));

            pCrtItem = pItems + nLeft;
        }
        
        ZeroMemory(pCrtItem, sizeof(LayeredItem));

        pCrtItem->dwFlags = *lpdwFlags;
        StringCchCopy(pCrtItem->szItemName, ARRAYSIZE(pCrtItem->szItemName), pszItem);

        (pHeader->dwItemCount)++;
    } else {
        //
        // The item is already in the file.
        //
        LogMsg(_T("[LayeredItemOperation] the item is in the file\n"));

        if (dwOp == LIO_READITEM) {
            *lpdwFlags = pCrtItem->dwFlags;
            goto done;
        }
        
        if (dwOp == LIO_DELETEITEM) {
            MoveMemory(pItems + nItem,
                       pItems + nItem + 1,
                       ((int)pHeader->dwItemCount - nItem - 1) * sizeof(LayeredItem));
            
            (pHeader->dwItemCount)--;
        } else {
            //
            // Update the item's flags.
            //
            pCrtItem->dwFlags = *lpdwFlags;
        }
        
        //
        // We've found the item so shrink the file by one item.
        //
        bShrinkFile = TRUE;
    }
    
done:

    if (pData != NULL) {
        UnmapViewOfFile(pData);
    }

    if (hFileMapping != NULL) {
        CloseHandle(hFileMapping);
    }

    if (bShrinkFile) {
        SetFilePointer(hFile, - (int)sizeof(LayeredItem), NULL, FILE_END);
        SetEndOfFile(hFile);
    }
    
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}

//////////////////////////////////////////////////////////////////////////
// LayerSelection
//
//  The user changed the selection in the combo-box with the layers.
//  Persist the user's selection to the layer storage.

void
LayerSelection(
    HWND   hdlg,
    LPWSTR pszItem
    )
{
    //
    // See which layer is selected.
    //
    LPARAM lSel = SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_GETCURSEL, 0, 0);

    if (lSel == CB_ERR) {
        LogMsg(_T("[LayerSelection] couldn't get the current selection\n"));
    } else {

        DWORD dwFlags;

        switch (lSel) {
        case 0:
            dwFlags = LI_WIN95;
            break;
        case 1:
            dwFlags = LI_WIN98;
            break;
        case 2:
            dwFlags = LI_NT4;
            break;
        default:
            LogMsg(_T("[LayerSelection] bad selection. default to Win9x\n"));
            dwFlags = LI_WIN95;
            break;
        }

        LayeredItemOperation(pszItem, LIO_ADDITEM, &dwFlags);
    }
}

//////////////////////////////////////////////////////////////////////////
// LayerPageDlgProc
//
//  The dialog proc for the layer property page.

INT_PTR CALLBACK
LayerPageDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
    {
        PROPSHEETPAGE*    ppsp = (PROPSHEETPAGE*)lParam;
        DWORD             dwFlags = 0;
        CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)ppsp->lParam;
        
        LogMsg(_T("[LayerPageDlgProc] WM_INITDIALOG - item \"%s\"\n"),
               pPropPage->m_szFile);
        
        //
        // Store the name of the EXE/LNK in the dialog.
        //
        SetWindowLong(hdlg, GWL_USERDATA, (LPARAM)pPropPage->m_szFile);
        
        //
        // Add the names of the layers.
        //
        SendDlgItemMessage(hdlg,
                           IDC_LAYER_NAME,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)_T("Windows 95 Compatibility Layer"));
        
        SendDlgItemMessage(hdlg,
                           IDC_LAYER_NAME,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)_T("Windows 98 Compatibility Layer"));
        
        SendDlgItemMessage(hdlg,
                           IDC_LAYER_NAME,
                           CB_ADDSTRING,
                           0,
                           (LPARAM)_T("Windows NT4 SP5 Compatibility Layer"));
        
        //
        // Read the layer storage for info on this item.
        //
        LayeredItemOperation(pPropPage->m_szFile, LIO_READITEM, &dwFlags);
        
        //
        // Select the appropriate layer for this item. If no info
        // is available in the layer store, default to the Win9x layer.
        //
        BOOL bEnable;
        
        switch (dwFlags) {
        case LI_WIN95:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
            bEnable = TRUE;
            break;
        
        case LI_WIN98:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 1, 0);
            bEnable = TRUE;
            break;
        
        case LI_NT4:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 2, 0);
            bEnable = TRUE;
            break;
        
        default:
            SendDlgItemMessage(hdlg, IDC_LAYER_NAME, CB_SETCURSEL, 0, 0);
            bEnable = FALSE;
        }

        if (bEnable) {
            EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);
            SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_SETCHECK, BST_CHECKED, 0);
        }
        
        break;
    }

    case WM_COMMAND:
    {
        LPWSTR pszItem;
        
        pszItem = (LPTSTR)GetWindowLong(hdlg, GWL_USERDATA);
        
        switch (wNotifyCode) {
        case CBN_SELCHANGE:
            LayerSelection(hdlg, pszItem);
            return TRUE;
        }
        
        switch (wCode) {
        
        case IDC_USE_LAYER:
            if (SendDlgItemMessage(hdlg, IDC_USE_LAYER, BM_GETCHECK, 0, 0) == BST_CHECKED) {
                EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), TRUE);
                LayerSelection(hdlg, pszItem);

            } else {
                EnableWindow(GetDlgItem(hdlg, IDC_LAYER_NAME), FALSE);
                LayeredItemOperation(pszItem, LIO_DELETEITEM, NULL);
            }
            break;

        default:
            return FALSE;
        }
        break;
    }

    default:
        return FALSE;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
// LayerPageCallbackProc
//
//  The callback for the property page.

UINT CALLBACK
LayerPageCallbackProc(
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp
    )
{
    switch (uMsg) {
    case PSPCB_RELEASE:
        if (ppsp->lParam != 0) {
            CLayerUIPropPage* pPropPage = (CLayerUIPropPage*)(ppsp->lParam);
            
            LogMsg(_T("[LayerPageCallbackProc] releasing CLayerUIPropPage\n"));
            
            pPropPage->Release();
        }
        break;
    }
    
    return 1;
}


BOOL
GetExeFromLnk(
    TCHAR* pszLnk,
    TCHAR* pszExe,
    int    cchSize
    )
{
    HRESULT         hres;
    IShellLink*     psl = NULL;
    IPersistFile*   pPf = NULL;
    WIN32_FIND_DATA wfd;
    TCHAR           szArg[MAX_PATH];
    BOOL            bSuccess = FALSE;
    
    IShellLinkDataList* psldl = NULL;
    EXP_DARWIN_LINK*    pexpDarwin = NULL;
    
    hres = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID*)&psl);
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] CoCreateInstance failed\n"));
        return FALSE;
    }

    hres = psl->QueryInterface(IID_IPersistFile, (LPVOID*)&pPf);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] QueryInterface for IPersistFile failed\n"));
        goto cleanup;
    }

    //
    // Load the link file.
    //
    hres = pPf->Load(pszLnk, STGM_READ);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to load link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    //
    // See if this is a DARWIN link.
    //

    hres = psl->QueryInterface(IID_IShellLinkDataList, (LPVOID*)&psldl);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get IShellLinkDataList.\n"));
    } else {
        hres = psldl->CopyDataBlock(EXP_DARWIN_ID_SIG, (void**)&pexpDarwin);
        
        if (SUCCEEDED(hres)) {
            LogMsg(_T("[GetExeFromLnk] this is a DARWIN link \"%s\".\n"),
                   pszLnk);
            goto cleanup;
        }
    }
    
    //
    // Resolve the link.
    //
    hres = psl->Resolve(NULL,
                        SLR_NOTRACK | SLR_NOSEARCH | SLR_NO_UI | SLR_NOUPDATE);
    
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to resolve the link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }
    
    pszExe[0] = _T('\"');
    
    //
    // Get the path to the link target.
    //
    hres = psl->GetPath(pszExe + 1,
                        cchSize,
                        &wfd,
                        SLGP_UNCPRIORITY);
                  
    if (FAILED(hres)) {
        LogMsg(_T("[GetExeFromLnk] failed to get the path for link \"%s\"\n"),
               pszLnk);
        goto cleanup;
    }

    szArg[0] = 0;

    hres = psl->GetArguments(szArg, MAX_PATH);

    if (SUCCEEDED(hres) && szArg[0] != 0) {
        StringCchCat(pszExe, cchSize, _T("\" "));
        StringCchCat(pszExe, cchSize, szArg);
    } else {
        StringCchCat(pszExe, cchSize, _T("\""));
    }

    bSuccess = TRUE;

cleanup:
    
    if (pPf != NULL) {
        pPf->Release();
    }
    
    if (psl) {
        psl->Release();
    }

    if (psldl) {
        psldl->Release();
    }

    if (pexpDarwin) {
        LocalFree(pexpDarwin);
    }
    
    return bSuccess;
}


//////////////////////////////////////////////////////////////////////////
// CLayerUIPropPage

CLayerUIPropPage::CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::CLayerUIPropPage]\n"));
}

CLayerUIPropPage::~CLayerUIPropPage()
{
    LogMsg(_T("[CLayerUIPropPage::~CLayerUIPropPage]\n"));
}


//////////////////////////////////////////////////////////////////////////
// IShellExtInit methods

STDMETHODIMP
CLayerUIPropPage::Initialize(
    LPCITEMIDLIST pIDFolder, 
    LPDATAOBJECT  pDataObj,
    HKEY          hKeyID
    )
{
    LogMsg(_T("[CLayerUIPropPage::Initialize]\n"));

    if (!g_bExtEnabled) {
        return NOERROR;
    }
    
    if (pDataObj == NULL) {
        LogMsg(_T("\t failed. bad argument.\n"));
        return E_INVALIDARG;
    }

    //
    // Store a pointer to the data object
    //
    m_spDataObj = pDataObj;

    //
    // If a data object pointer was passed in, save it and
    // extract the file name.
    //
    STGMEDIUM   medium;
    UINT        uCount;
    FORMATETC   fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, 
                      TYMED_HGLOBAL};

    if (SUCCEEDED(m_spDataObj->GetData(&fe, &medium))) {
        
        //
        // Get the file name from the CF_HDROP.
        //
        uCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, 
                               NULL, 0);
        if (uCount > 0) {
            
            TCHAR szExe[MAX_PATH];
            
            DragQueryFile((HDROP)medium.hGlobal, 0, szExe, 
                          ARRAYSIZE(szExe));
            
            LogMsg(_T("\tlink \"%s\".\n"), szExe);

            if (!GetExeFromLnk(szExe, m_szFile, ARRAYSIZE(m_szFile))) {
                m_szFile[0] = 0;
            }
            
            LogMsg(_T("\tfile \"%s\".\n"), m_szFile);
        }

        ReleaseStgMedium(&medium);
    } else {
        LogMsg(_T("\t failed to get the data.\n"));
    }
    
    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////
// IShellPropSheetExt methods


STDMETHODIMP
CLayerUIPropPage::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM               lParam
    )
{
    PROPSHEETPAGE  psp;
    HPROPSHEETPAGE hPage;

    LogMsg(_T("[CLayerUIPropPage::AddPages]\n"));
    
    if (!g_bExtEnabled || m_szFile[0] == 0) {
        return S_OK;
    }
    
    psp.dwSize        = sizeof(psp);
    psp.dwFlags       = PSP_USEREFPARENT | PSP_USETITLE | PSP_USECALLBACK;
    psp.hInstance     = _Module.m_hInst;
    psp.pszTemplate   = MAKEINTRESOURCE(IDD_LAYER_PROPPAGE);
    psp.hIcon         = 0;
    psp.pszTitle      = _T("Compatibility");
    psp.pfnDlgProc    = LayerPageDlgProc;
    psp.pcRefParent   = &g_DllRefCount;
    psp.pfnCallback   = LayerPageCallbackProc;
    psp.lParam        = (LPARAM)this;

    LogMsg(_T("\titem           \"%s\".\n"), m_szFile);
    LogMsg(_T("\tg_DllRefCount  %d.\n"), g_DllRefCount);
    
    AddRef();
    
    hPage = CreatePropertySheetPage(&psp);
            
    if (hPage != NULL) {
        
        if (lpfnAddPage(hPage, lParam)) {
            return S_OK;
        } else {
            DestroyPropertySheetPage(hPage);
            Release();
            return S_OK;
        }
    } else {
        return E_OUTOFMEMORY;
    }
    
    return E_FAIL;
}

STDMETHODIMP
CLayerUIPropPage::ReplacePage(
    UINT                 uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplacePage,
    LPARAM               lParam
    )
{
    LogMsg(_T("[CLayerUIPropPage::ReplacePage]\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\win2k\slayerui.cpp ===
// SlayerUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SlayerUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SlayerUI.h"

#include <stdio.h>
#include <stdarg.h>

#include "SlayerUI_i.c"

#include "ShellExtensions.h"


// {513d916f-2a8e-4f51-aeab-0cbc76fb1af8}
static const CLSID CLSID_ShimLayerPropertyPage = 
  {	0x513d916f, 0x2a8e, 0x4f51, { 0xae, 0xab, 0x0c, 0xbc, 0x76, 0xfb, 0x1a, 0xf8 } };

CLayerUIModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
  OBJECT_ENTRY(CLSID_ShimLayerPropertyPage, CLayerUIPropPage)
END_OBJECT_MAP()

#if DBG

/////////////////////////////////////////////////////////////////////////////
// LogMsgDbg

void LogMsgDbg(
    LPTSTR pwszFmt,
    ... )
{
    WCHAR   gwszT[1024];
    va_list arglist;

    va_start(arglist, pwszFmt);
    _vsnwprintf(gwszT, 1023, pwszFmt, arglist);
    gwszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugStringW(gwszT);
}

#endif // DBG

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SLAYERUILib);

        InitLayerStorage(FALSE);

        //
        // Check for the registry rights
        //
        CheckForRights();

        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\whistler\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "ShellExtensions.h"
#include "strsafe.h"

typedef DWORD (*PFNSHDeleteKeyW)(HKEY hkey, LPWSTR pszSubkey);

HRESULT WINAPI
CLayerUIModule::UpdateRegistryCLSID(
    const CLSID& clsid,
    BOOL         bRegister
    )
{
    static const TCHAR szIPS32[] = _T("InprocServer32");
    static const TCHAR szCLSID[] = _T("CLSID");
    static const TCHAR szPropPageExt[] = _T("ShimLayer Property Page");

    HRESULT hRes = S_OK;
    HRESULT hr = S_OK;

    LPOLESTR lpOleStrCLSIDValue = NULL;
    
    if (clsid != CLSID_ShimLayerPropertyPage) {
        LogMsg(_T("[UpdateRegistryCLSID] unknown CLSID!\n"));
        return E_FAIL;
    }
    
    hr = ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);
    if (hr != S_OK) {
        LogMsg(_T("[UpdateRegistryCLSID] can't get string from CLSID!\n"));
        return E_FAIL;
    }

    HKEY hkey = NULL;
    LONG lRes;
    
    if (bRegister) {
        
        TCHAR szBuffer[MAX_PATH];
        DWORD keyType = 0;

        //
        // Write the key for registration. Include the value to specify
        // the threading model.
        //
        StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), _T("%s\\%s\\%s"), szCLSID, lpOleStrCLSIDValue, szIPS32);
        
        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to open/create \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        ::GetModuleFileName(m_hInst, szBuffer, ARRAYSIZE(szBuffer));
        
        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)szBuffer,
                             (lstrlen(szBuffer) + 1) * sizeof(TCHAR));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write value \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             _T("ThreadingModel"),
                             0,
                             REG_SZ,
                             (BYTE*)_T("Apartment"),
                             sizeof(_T("Apartment")));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write \"ThreadingModel\"\n"));
            goto Exit;
        }

        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Open the key with the name of the .exe extension and
        // add the keys to support the shell extensions.
        //
        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer),
                        _T("lnkfile\\shellex\\PropertySheetHandlers\\%s"),
                        szPropPageExt);

        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            goto Exit;
        }

        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)lpOleStrCLSIDValue,
                             (lstrlen(lpOleStrCLSIDValue) + 1) * sizeof(TCHAR));

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to add the shell extension handler\n"));
            goto Exit;
        }
        
        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Now add the shell extension to the approved list.
        //
        lRes = RegCreateKey(HKEY_LOCAL_MACHINE,
                            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                            &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             lpOleStrCLSIDValue,
                             0,
                             REG_SZ,
                             (BYTE*)szPropPageExt,
                             sizeof(szPropPageExt));

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }

Exit:        
        if (hkey != NULL) {
            RegCloseKey(hkey);
            hkey = NULL;
        }
            
        hRes = HRESULT_FROM_WIN32(lRes);
    
    } else {
        //
        // Time to clean up.
        //
        PFNSHDeleteKeyW pfnSHDeleteKey;

        HMODULE hmod = LoadLibrary(_T("Shlwapi.dll"));

        if (hmod == NULL) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to load Shlwapi.dll\n"));
            return E_FAIL;
        }
        
        pfnSHDeleteKey = (PFNSHDeleteKeyW)GetProcAddress(hmod, "SHDeleteKeyW");

        if (pfnSHDeleteKey == NULL) {
            FreeLibrary(hmod);
            LogMsg(_T("[UpdateRegistryCLSID] cannot get Shlwapi!SHDeleteKeyW\n"));
            return E_FAIL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            (*pfnSHDeleteKey)(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, _T("lnkfile\\shellex"), &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            
            (*pfnSHDeleteKey)(hkey, _T("PropertySheetHandlers\\ShimLayer Property Page"));
            
            RegCloseKey(hkey);
            hkey = NULL;
        }
        
        lRes = RegOpenKey(HKEY_LOCAL_MACHINE,
                          _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                          &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            RegDeleteValue(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        FreeLibrary(hmod);
    }

    //
    // Notify the shell of our changes
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    if (lpOleStrCLSIDValue) {
        ::CoTaskMemFree(lpOleStrCLSIDValue);
    }
    
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\win2k\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_)
#define AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

#if ( _ATL_VER >= 0x0300 )
#define _ATL_NO_UUIDOF 
#endif


using namespace ATL;

class CLayerUIModule : public CComModule
{
public:
	HRESULT WINAPI UpdateRegistryCLSID(const CLSID& clsid, BOOL bRegister);
};

#define DECLARE_REGISTRY_CLSID()                                        \
static HRESULT WINAPI UpdateRegistry(BOOL bRegister)                    \
{                                                                       \
    return _Module.UpdateRegistryCLSID(GetObjectCLSID(), bRegister);    \
}

extern CLayerUIModule _Module;

#include <atlcom.h>

#include <shellapi.h>
#include <shlobj.h>

extern const CLSID CLSID_ShimLayerPropertyPage;

#if DBG

    void LogMsgDbg(LPTSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else

    #define LogMsg

#endif // DBG


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__88E11F15_58D2_477F_9D30_DBF092670E6A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\slayerui\win2k\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

#include "ShellExtensions.h"
#include "strsafe.h"

typedef DWORD (*PFNSHDeleteKeyW)(HKEY hkey, LPWSTR pszSubkey);

HRESULT WINAPI
CLayerUIModule::UpdateRegistryCLSID(
    const CLSID& clsid,
    BOOL         bRegister
    )
{
    static const TCHAR szIPS32[] = _T("InprocServer32");
    static const TCHAR szCLSID[] = _T("CLSID");
    static const TCHAR szPropPageExt[] = _T("ShimLayer Property Page");

    HRESULT hRes = S_OK;
    HRESULT hr = S_OK;

    LPOLESTR lpOleStrCLSIDValue = NULL;
    
    if (clsid != CLSID_ShimLayerPropertyPage) {
        LogMsg(_T("[UpdateRegistryCLSID] unknown CLSID!\n"));
        return E_FAIL;
    }
    
    hr = ::StringFromCLSID(clsid, &lpOleStrCLSIDValue);
    if (hr != S_OK) {
        LogMsg(_T("[UpdateRegistryCLSID] can't get string from CLSID!\n"));
        return E_FAIL;
    }


    HKEY hkey = NULL;
    LONG lRes;
    
    if (bRegister) {
        
        TCHAR szBuffer[MAX_PATH];
        DWORD keyType = 0;

        //
        // Write the key for registration. Include the value to specify
        // the threading model.
        //
        StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), _T("%s\\%s\\%s"), szCLSID, lpOleStrCLSIDValue, szIPS32);
        
        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to open/create \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        ::GetModuleFileName(m_hInst, szBuffer, MAX_PATH);
        
        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)szBuffer,
                             (lstrlen(szBuffer) + 1) * sizeof(TCHAR));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write value \"%s\"\n"),
                   szBuffer);
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             _T("ThreadingModel"),
                             0,
                             REG_SZ,
                             (BYTE*)_T("Apartment"),
                             sizeof(_T("Apartment")));
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to write \"ThreadingModel\"\n"));
            goto Exit;
        }

        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Open the key with the name of the .exe extension and
        // add the keys to support the shell extensions.
        //
        StringCchPrintf(szBuffer,
                        ARRAYSIZE(szBuffer), 
                        _T("lnkfile\\shellex\\PropertySheetHandlers\\%s"),
                        szPropPageExt);

        lRes = RegCreateKey(HKEY_CLASSES_ROOT, szBuffer, &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            goto Exit;
        }

        lRes = RegSetValueEx(hkey,
                             NULL,
                             0,
                             REG_SZ,
                             (BYTE*)lpOleStrCLSIDValue,
                             (lstrlen(lpOleStrCLSIDValue) + 1) * sizeof(TCHAR));

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to add the shell extension handler\n"));
            goto Exit;
        }
        
        RegCloseKey(hkey);
        hkey = NULL;

        //
        // Now add the shell extension to the approved list.
        //
        lRes = RegCreateKey(HKEY_LOCAL_MACHINE,
                            _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                            &hkey);
        
        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }
        
        lRes = RegSetValueEx(hkey,
                             lpOleStrCLSIDValue,
                             0,
                             REG_SZ,
                             (BYTE*)szPropPageExt,
                             sizeof(szPropPageExt));

        if (lRes != ERROR_SUCCESS) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to approve the shell extension handler\n"));
            goto Exit;
        }

Exit:        
        if (hkey != NULL) {
            RegCloseKey(hkey);
            hkey = NULL;
        }
            
        hRes = HRESULT_FROM_WIN32(lRes);
    
    } else {
        //
        // Time to clean up.
        //
        PFNSHDeleteKeyW pfnSHDeleteKey;

        HMODULE hmod = LoadLibrary(_T("Shlwapi.dll"));

        if (hmod == NULL) {
            LogMsg(_T("[UpdateRegistryCLSID] failed to load Shlwapi.dll\n"));
            return E_FAIL;
        }
        
        pfnSHDeleteKey = (PFNSHDeleteKeyW)GetProcAddress(hmod, "SHDeleteKeyW");

        if (pfnSHDeleteKey == NULL) {
            FreeLibrary(hmod);
            LogMsg(_T("[UpdateRegistryCLSID] cannot get Shlwapi!SHDeleteKeyW\n"));
            return E_FAIL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, szCLSID, &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            (*pfnSHDeleteKey)(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        lRes = RegOpenKey(HKEY_CLASSES_ROOT, _T("lnkfile\\shellex"), &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            
            (*pfnSHDeleteKey)(hkey, _T("PropertySheetHandlers\\ShimLayer Property Page"));
            
            RegCloseKey(hkey);
            hkey = NULL;
        }
        
        lRes = RegOpenKey(HKEY_LOCAL_MACHINE,
                          _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"),
                          &hkey);
        
        if (lRes == ERROR_SUCCESS) {
            RegDeleteValue(hkey, lpOleStrCLSIDValue);
            
            RegCloseKey(hkey);
            hkey = NULL;
        }

        FreeLibrary(hmod);
    }

    //
    // Delete the layer storage.
    //
    InitLayerStorage(TRUE);
    
    //
    // Notify the shell of our changes
    //
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    if (lpOleStrCLSIDValue) {
        ::CoTaskMemFree(lpOleStrCLSIDValue);
    }
    
    
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowser\acbrowser.h ===
#ifndef _ACBROWSERWHISTLER_H
#define _ACBROWSERWHISTLER_H

#include <windows.h>

typedef enum {
    FIX_SHIM,
    FIX_PATCH,
    FIX_LAYER,
    FIX_FLAG
} FIXTYPE;

typedef enum {
    FLAG_USER,
    FLAG_KERNEL
} FLAGTYPE;

typedef struct tagFIX {
    
    struct tagFIX* pNext;
    
    char*       pszName;
    char*       pszDescription;
    ULONGLONG   ullMask;            // only for FIX_FLAG
    FLAGTYPE    flagType;           // only for FIX_FLAG
    FIXTYPE     fixType;
} FIX, *PFIX;

typedef struct tagFIXLIST {

    struct tagFIXLIST* pNext;

    PFIX pFix;

} FIXLIST, *PFIXLIST;


typedef enum {
    APPTYPE_NONE,
    APPTYPE_INC_NOBLOCK,
    APPTYPE_INC_HARDBLOCK,
    APPTYPE_MINORPROBLEM,
    APPTYPE_REINSTALL,
    APPTYPE_VERSIONSUB,
    APPTYPE_SHIM
} SEVERITY;

typedef struct tagAPPHELP {
    BOOL        bPresent;
    SEVERITY    severity;
    DWORD       htmlHelpId;
} APPHELP, *PAPPHELP;

typedef struct tagATTRIBUTE {
    struct tagATTRIBUTE* pNext;

    char*   pszText;

} ATTRIBUTE, *PATTRIBUTE;

typedef struct tagMATCHINGFILE {

    struct tagMATCHINGFILE* pNext;
    
    char*       pszName;
    PATTRIBUTE  pFirstAttribute;

} MATCHINGFILE, *PMATCHINGFILE;

typedef struct tagDBENTRY {
    
    struct tagDBENTRY* pNext;
    
    char*           pszExeName;
    char*           pszAppName;
    char            szGUID[48];
    
    PFIXLIST        pFirstShim;
    PFIXLIST        pFirstPatch;
    PFIXLIST        pFirstLayer;
    PFIXLIST        pFirstFlag;
    
    APPHELP         appHelp;
    
    PMATCHINGFILE   pFirstMatchingFile;
    int             nMatchingFiles;

    BOOL            bDisablePerUser;
    BOOL            bDisablePerMachine;

} DBENTRY, *PDBENTRY;


void LogMsg(LPSTR pszFmt, ... );
BOOL CenterWindow(HWND hWnd);

PDBENTRY
GetDatabaseEntries(
    void
    );

void
UpdateFixStatus(
    char* pszGUID,
    BOOL  bPerUser,
    BOOL  bPerMachine
    );

#endif // _ACBROWSERWHISTLER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BrowseAppCompat.rc
//
#define IDD_DIALOG                      101
#define IDI_APPICON                     102

#define IDC_LIST                        1000
#define IDC_ENTRY                       1001
#define IDC_ALL_ENTRIES                 1002
#define IDC_PER_USER                    1011
#define IDC_PER_MACHINE                 1012
#define IDC_STATISTICS                  1021
#define IDC_W_APPHELP                   1023
#define IDC_WO_APPHELP                  1024
#define IDC_W_PATCHES                   1025
#define IDC_WO_PATCHES                  1026
#define IDC_W_FLAGS                     1027
#define IDC_WO_FLAGS                    1028
#define IDC_W_LAYERS                    1029
#define IDC_WO_LAYERS                   1030
#define IDC_DC_APPHELP                  1031
#define IDC_DC_PATCHES                  1032
#define IDC_W_SHIMS                     1033
#define IDC_WO_SHIMS                    1034
#define IDC_DC_SHIMS                    1035
#define IDC_DC_FLAGS                    1036
#define IDC_DC_LAYERS                   1037
#define IDC_DISABLED_ONLY               1038


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1019
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowser\acbrowser.c ===
#include "acBrowser.h"
#include "resource.h"

#include <commctrl.h>
#include <commdlg.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

extern PDBENTRY g_pEntries;

#define SHOW_W_SHIMS        0x00000001
#define SHOW_W_FLAGS        0x00000002
#define SHOW_W_LAYERS       0x00000004
#define SHOW_W_PATCHES      0x00000008
#define SHOW_W_APPHELP      0x00000010

#define SHOW_WO_SHIMS       0x00000100
#define SHOW_WO_FLAGS       0x00000200
#define SHOW_WO_LAYERS      0x00000400
#define SHOW_WO_PATCHES     0x00000800
#define SHOW_WO_APPHELP     0x00001000

//
// These flags cannot occur simultaneously.
//
#define SHOW_MORETHAN5      0x00010000
#define SHOW_NOMATCHING     0x00020000

#define SHOW_DISABLED_ONLY  0x80000000

#define ID_SHOW_CONTENT     1234

//
// Global Variables
//

HINSTANCE g_hInstance;
HWND      g_hDlg;

HWND      g_hwndList;

HWND      g_hwndEntryTree;

int       g_nItems;

BOOL      g_bSortAppAsc;
BOOL      g_bSortExeAsc;

PDBENTRY  g_pSelEntry;

char      g_szBinary[MAX_PATH];

DWORD     g_dwCrtShowFlags = 0xFFFFFFFF;

#define COLUMN_APP      0
#define COLUMN_EXE      1

char* g_szSeverity[] = { "NONE",
                         "NOBLOCK",
                         "HARDBLOCK",
                         "MINORPROBLEM",
                         "REINSTALL",
                         "VERSIONSUB",
                         "SHIM"};

#define IDQ_ALL             0
#define IDQ_MORETHAN5       1
#define IDQ_NOMATCHING      2
                         
char* g_aszQueries[] = { "All entries",
                         "Entries with more than 5 extra matching files",
                         "Entries with no extra matching files",
                         ""
};


void
LogMsg(
    LPSTR pszFmt,
    ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

/*******************************************************************************
* CenterWindow
*
*  This function must be called at the WM_INIDIALOG in order to
*  move the dialog window centered in the client area of the
*  parent or owner window.
*******************************************************************************/
BOOL CenterWindow(
    HWND hWnd)
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    if (hParent == NULL)
        hParent = GetDesktopWindow();

    GetWindowRect(hParent,            (LPRECT)&rectParent);
    GetWindowRect(hWnd,               (LPRECT)&rectWindow);
    GetWindowRect(GetDesktopWindow(), (LPRECT)&rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left)
        ptPoint.x = rectScreen.left;
    if (ptPoint.x > rectScreen.right  - nCX)
        ptPoint.x = rectScreen.right  - nCX;
    if (ptPoint.y < rectScreen.top)
        ptPoint.y = rectScreen.top;
    if (ptPoint.y > rectScreen.bottom - nCY)
        ptPoint.y = rectScreen.bottom - nCY;

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD)
        ScreenToClient(hParent, (LPPOINT)&ptPoint);

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE))
        return FALSE;

    return TRUE;
}

void
AddEntryToList(
    PDBENTRY pEntry
    )
{
    LVITEM lvi; 
    
    lvi.mask      = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText   = pEntry->pszAppName;
    lvi.iItem     = g_nItems;
    lvi.iSubItem  = COLUMN_APP;
    lvi.lParam    = (LPARAM)pEntry;

    ListView_InsertItem(g_hwndList, &lvi);
    ListView_SetItemText(g_hwndList, g_nItems, COLUMN_EXE, pEntry->pszExeName);
    
    g_nItems++;
}

void
InsertColumnIntoListView(
    LPSTR    lpszColumn,
    DWORD    dwSubItem,
    DWORD    widthPercent
    )
{
    LVCOLUMN  lvc;
    RECT      rcClient;
    DWORD     width;

    GetWindowRect(g_hwndList, &rcClient);
    
    width = rcClient.right - rcClient.left -
                4 * GetSystemMetrics(SM_CXBORDER) -
                GetSystemMetrics(SM_CXVSCROLL);
    
    width = width * widthPercent / 100;
    
    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.iSubItem = dwSubItem;
    lvc.cx       = width;
    lvc.pszText  = lpszColumn;
    
    ListView_InsertColumn(g_hwndList, dwSubItem, &lvc);
}

void
UpdateEntryTreeView(
    PDBENTRY pEntry
    )
{
    HTREEITEM       hItemExe;
    HTREEITEM       hMatchItem;
    HTREEITEM       hItemMatchingFiles;
    PMATCHINGFILE   pMatch;
    PFIXLIST        pFixList;
    TV_INSERTSTRUCT is;
    char            szText[256];
    
    TreeView_DeleteAllItems(g_hwndEntryTree);

    wsprintf(szText, "%s - %s", pEntry->pszExeName, pEntry->szGUID);
    
    is.hParent      = TVI_ROOT;
    is.hInsertAfter = TVI_LAST;
    is.item.mask    = TVIF_TEXT | TVIF_PARAM;
    is.item.lParam  = 0;
    is.item.pszText = szText;
    
    hItemExe = TreeView_InsertItem(g_hwndEntryTree, &is);
    
    if (pEntry->appHelp.bPresent) {
        
        wsprintf(szText, "AppHelp - %s",
                 g_szSeverity[pEntry->appHelp.severity]);
        
        is.hParent      = hItemExe;
        is.item.pszText = szText;

        TreeView_InsertItem(g_hwndEntryTree, &is);
    }
    
    if (pEntry->pFirstShim) {
        
        HTREEITEM hItemShims;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Fixes";

        hItemShims = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemShims;
        
        pFixList = pEntry->pFirstShim;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemShims, TVE_EXPAND);
    }
    
    if (pEntry->pFirstPatch) {
        
        HTREEITEM hItemPatches;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Patches";

        hItemPatches = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemPatches;
        
        pFixList = pEntry->pFirstPatch;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemPatches, TVE_EXPAND);
    }
    
    if (pEntry->pFirstFlag) {
        
        HTREEITEM hItemFlags;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Flags";

        hItemFlags = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemFlags;
        
        pFixList = pEntry->pFirstFlag;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemFlags, TVE_EXPAND);
    }
    
    if (pEntry->pFirstLayer) {
        
        HTREEITEM hItemLayers;
        
        is.hParent      = hItemExe;
        is.hInsertAfter = TVI_SORT;
        is.item.lParam  = 0;
        is.item.pszText = "Compatibility Layers";

        hItemLayers = TreeView_InsertItem(g_hwndEntryTree, &is);
        
        is.hParent = hItemLayers;
        
        pFixList = pEntry->pFirstLayer;

        while (pFixList) {
            is.item.lParam  = (LPARAM)pFixList->pFix->pszDescription;
            is.item.pszText = pFixList->pFix->pszName;
            
            TreeView_InsertItem(g_hwndEntryTree, &is);

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(g_hwndEntryTree, hItemLayers, TVE_EXPAND);
    }

    pMatch = pEntry->pFirstMatchingFile;

    is.hParent      = hItemExe;
    is.item.lParam  = 0;
    is.item.pszText = "Matching Files";

    hItemMatchingFiles = TreeView_InsertItem(g_hwndEntryTree, &is);
    
    while (pMatch) {
        
        PATTRIBUTE pAttr;
        
        is.hInsertAfter = TVI_SORT;
        is.hParent = hItemMatchingFiles;
        is.item.pszText = pMatch->pszName;

        hMatchItem = TreeView_InsertItem(g_hwndEntryTree, &is);

        pAttr = pMatch->pFirstAttribute;

        while (pAttr) {
            is.hParent      = hMatchItem;
            is.hInsertAfter = TVI_SORT;
            is.item.pszText = pAttr->pszText;

            TreeView_InsertItem(g_hwndEntryTree, &is);
            
            pAttr = pAttr->pNext;
        }

        pMatch = pMatch->pNext;
    }

    TreeView_Expand(g_hwndEntryTree, hItemMatchingFiles, TVE_EXPAND);

    TreeView_Expand(g_hwndEntryTree, hItemExe, TVE_EXPAND);
}

void
AppSelectedChanged(
    HWND   hdlg,
    int    nSel
    )
{
    LVITEM         lvi;
    PDBENTRY       pEntry;

    if (nSel == -1)
        return;

    lvi.iItem = nSel;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pEntry = (PDBENTRY)lvi.lParam;

    g_pSelEntry = pEntry;

    //
    // Update the entry tree view
    //
    UpdateEntryTreeView(pEntry);
    
    SendDlgItemMessage(hdlg, IDC_PER_USER, BM_SETCHECK,
                       (pEntry->bDisablePerUser ? BST_CHECKED : BST_UNCHECKED), 0);

    SendDlgItemMessage(hdlg, IDC_PER_MACHINE, BM_SETCHECK,
                       (pEntry->bDisablePerMachine ? BST_CHECKED : BST_UNCHECKED), 0);
}


int CALLBACK
CompareItems(
    LPARAM lParam1,
    LPARAM lParam2, 
    LPARAM column)
{
    PDBENTRY pItem1 = (PDBENTRY)lParam1;
    PDBENTRY pItem2 = (PDBENTRY)lParam2;
    int      nVal = 0;

    if (column == COLUMN_APP) {
        if (g_bSortAppAsc) {
            nVal = lstrcmpi(pItem1->pszAppName, pItem2->pszAppName);
        } else {
            nVal = lstrcmpi(pItem2->pszAppName, pItem1->pszAppName);
        }
    }

    if (column == COLUMN_EXE) {
        if (g_bSortExeAsc) {
            nVal = lstrcmpi(pItem1->pszExeName, pItem2->pszExeName);
        } else {
            nVal = lstrcmpi(pItem2->pszExeName, pItem1->pszExeName);
        }
    }
    return nVal;
}
 
void
ShowFixes(
    HWND  hdlg,
    DWORD dwShowFlags
    )
{
    PDBENTRY pEntry;
    char     szEntries[128];
    BOOL     bDontShow;
    
    if (dwShowFlags == g_dwCrtShowFlags) {
        return;
    }
    
    g_nItems = 0;

    SendMessage(g_hwndList, WM_SETREDRAW, FALSE, 0);
    
    ListView_DeleteAllItems(g_hwndList);
    
    pEntry = g_pEntries;

    while (pEntry != NULL) {
        
        bDontShow = (pEntry->pFirstShim == NULL && (dwShowFlags & SHOW_W_SHIMS) ||
                     pEntry->appHelp.bPresent == FALSE && (dwShowFlags & SHOW_W_APPHELP) ||
                     pEntry->pFirstFlag == NULL && (dwShowFlags & SHOW_W_FLAGS) ||
                     pEntry->pFirstPatch == NULL && (dwShowFlags & SHOW_W_PATCHES) ||
                     pEntry->pFirstLayer == NULL && (dwShowFlags & SHOW_W_LAYERS));

        bDontShow = bDontShow ||
                    (pEntry->pFirstShim && (dwShowFlags & SHOW_WO_SHIMS) ||
                     pEntry->appHelp.bPresent && (dwShowFlags & SHOW_WO_APPHELP) ||
                     pEntry->pFirstFlag && (dwShowFlags & SHOW_WO_FLAGS) ||
                     pEntry->pFirstPatch && (dwShowFlags & SHOW_WO_PATCHES) ||
                     pEntry->pFirstLayer && (dwShowFlags & SHOW_WO_LAYERS));
        
        if ((dwShowFlags & SHOW_DISABLED_ONLY) &&
            !pEntry->bDisablePerMachine &&
            !pEntry->bDisablePerUser) {

            bDontShow = TRUE;
        }

        if (dwShowFlags & SHOW_MORETHAN5) {
            if (pEntry->nMatchingFiles < 6) {
                bDontShow = TRUE;
            }
        }
        
        if (dwShowFlags & SHOW_NOMATCHING) {
            if (pEntry->nMatchingFiles > 1) {
                bDontShow = TRUE;
            }
        }
        
        if (!bDontShow) {
            AddEntryToList(pEntry);
        }

        pEntry = pEntry->pNext;
    }
    
    ListView_SortItems(g_hwndList, CompareItems, COLUMN_APP);
    
    wsprintf(szEntries, "%d entries. Use the headers to sort them.", g_nItems);
    
    SetDlgItemText(hdlg, IDC_ALL_ENTRIES, szEntries);
    
    SendMessage(g_hwndList, WM_SETREDRAW, TRUE, 0);

    g_dwCrtShowFlags = dwShowFlags;
}

void
DoInitDialog(
    HWND hdlg
    )
{
    HICON hIcon;
    int   i;
    
    g_hDlg = hdlg;

    CenterWindow(hdlg);

    g_hwndList = GetDlgItem(hdlg, IDC_LIST);
    
    ListView_SetExtendedListViewStyle(g_hwndList, 0x20);

    g_hwndEntryTree = GetDlgItem(hdlg, IDC_ENTRY);
    
    g_nItems = 0;

    InsertColumnIntoListView("Application", COLUMN_APP, 60);
    InsertColumnIntoListView("Main Binary", COLUMN_EXE, 40);
    
    g_bSortAppAsc = TRUE;
    g_bSortExeAsc = FALSE;

    //
    // Show the app icon.
    //
    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APPICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);
    
    SendDlgItemMessage(hdlg, IDC_DC_APPHELP, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_SHIMS, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_FLAGS, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_PATCHES, BM_SETCHECK, BST_CHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_DC_LAYERS, BM_SETCHECK, BST_CHECKED, 0);

    //
    // Populate the statistics queries
    //
    for (i = 0; *g_aszQueries[i] != 0; i++) {
        SendDlgItemMessage(hdlg, IDC_STATISTICS, CB_ADDSTRING, 0, (LPARAM)g_aszQueries[i]);
    }
    
    SetCursor(NULL);
    
    SetTimer(hdlg, ID_SHOW_CONTENT, 100, NULL);
}

void
FilterAndShow(
    HWND hdlg
    )
{
    DWORD dwShowFlags = 0;

    if (SendDlgItemMessage(hdlg, IDC_W_APPHELP, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_APPHELP;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_APPHELP, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_APPHELP;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_SHIMS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_SHIMS;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_SHIMS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_SHIMS;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_PATCHES, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_PATCHES;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_PATCHES, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_PATCHES;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_FLAGS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_FLAGS;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_FLAGS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_FLAGS;
    }

    if (SendDlgItemMessage(hdlg, IDC_W_LAYERS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_W_LAYERS;
    } else if (SendDlgItemMessage(hdlg, IDC_WO_LAYERS, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_WO_LAYERS;
    }

    if (SendDlgItemMessage(hdlg, IDC_DISABLED_ONLY, BM_GETCHECK, 0, 0) == BST_CHECKED) {
        dwShowFlags |= SHOW_DISABLED_ONLY;
    }

    SendDlgItemMessage(hdlg, IDC_PER_USER, BM_SETCHECK, BST_UNCHECKED, 0);
    SendDlgItemMessage(hdlg, IDC_PER_MACHINE, BM_SETCHECK, BST_UNCHECKED, 0);
    
    ShowFixes(hdlg, dwShowFlags);
    
    TreeView_DeleteAllItems(g_hwndEntryTree);
}

void
OnSubmitChanges(
    HWND hdlg
    )
{
    BOOL bPerUser, bPerMachine;
    
    if (g_pSelEntry == NULL) {
        return;
    }

    bPerUser = (SendDlgItemMessage(hdlg, IDC_PER_USER, BM_GETCHECK, 0, 0) == BST_CHECKED);
    bPerMachine = (SendDlgItemMessage(hdlg, IDC_PER_MACHINE, BM_GETCHECK, 0, 0) == BST_CHECKED);

    UpdateFixStatus(g_pSelEntry->szGUID, bPerUser, bPerMachine);

    g_pSelEntry->bDisablePerUser = bPerUser;
    g_pSelEntry->bDisablePerMachine = bPerMachine;
}

INT_PTR CALLBACK
BrowseAppCompatDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        DoInitDialog(hdlg);
        break;

    case WM_TIMER:
        if (wParam == ID_SHOW_CONTENT) {
            KillTimer(hdlg, ID_SHOW_CONTENT);
            
            //
            // Read the database
            //
            GetDatabaseEntries();

            ShowFixes(hdlg, 0);
            
            SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
        }
        break;

    case WM_NOTIFY:
        if (wParam == IDC_LIST) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            
            case LVN_COLUMNCLICK:
            {
                LPNMLISTVIEW pnmlv = (LPNMLISTVIEW)lParam;

                if (pnmlv->iSubItem == COLUMN_APP) {
                    g_bSortAppAsc = !g_bSortAppAsc;
                }

                if (pnmlv->iSubItem == COLUMN_EXE) {
                    g_bSortExeAsc = !g_bSortExeAsc;
                }
                
                ListView_SortItems(g_hwndList, CompareItems, pnmlv->iSubItem);
                
                break;
            }
            
            case LVN_ITEMCHANGED:
            {
                int nSel = ListView_GetSelectionMark(g_hwndList);
                
                AppSelectedChanged(hdlg, nSel);
                break;
            }

            case NM_CLICK:
            {    
                LVHITTESTINFO ht;
                int           nSel;

                GetCursorPos(&ht.pt);
                ScreenToClient(g_hwndList, &ht.pt);

                nSel = ListView_SubItemHitTest(g_hwndList, &ht);
            
                if (nSel != -1) {
                    ListView_SetItemState(g_hwndList,
                                          nSel,
                                          LVIS_SELECTED | LVIS_FOCUSED,
                                          LVIS_SELECTED | LVIS_FOCUSED);
                }
                
                AppSelectedChanged(hdlg, nSel);
                break;
            }
            default:
                break;
            }
        } else if (wParam == IDC_ENTRY) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            
            case TVN_GETINFOTIP:
            {
                LPNMTVGETINFOTIP lpGetInfoTip = (LPNMTVGETINFOTIP)lParam;

                if (lpGetInfoTip->lParam != 0) {
                    lstrcpy(lpGetInfoTip->pszText, (char*)lpGetInfoTip->lParam);
                }

                break;
            }
            }
        }
        
        break;

    case WM_COMMAND:
        
        if (wNotifyCode == CBN_SELCHANGE) {
            
            int nSel;

            nSel = (int)SendDlgItemMessage(hdlg, IDC_STATISTICS, CB_GETCURSEL, 0, 0);

            switch (nSel) {
            case IDQ_ALL:
                ShowFixes(hdlg, (g_dwCrtShowFlags & ~(SHOW_MORETHAN5 | SHOW_NOMATCHING)));
                break;
            
            case IDQ_MORETHAN5:
                ShowFixes(hdlg, ((g_dwCrtShowFlags | SHOW_MORETHAN5) & ~SHOW_NOMATCHING));
                break;
            
            case IDQ_NOMATCHING:
                ShowFixes(hdlg, ((g_dwCrtShowFlags | SHOW_NOMATCHING) & ~SHOW_MORETHAN5));
                break;
            }
        }
        
        switch (wCode) {
        
        case IDC_PER_USER:
        case IDC_PER_MACHINE:
            OnSubmitChanges(hdlg);
            break;
        
        case IDC_W_APPHELP:
        case IDC_W_SHIMS:
        case IDC_W_FLAGS:
        case IDC_W_LAYERS:
        case IDC_W_PATCHES:
        case IDC_WO_APPHELP:
        case IDC_WO_SHIMS:
        case IDC_WO_FLAGS:
        case IDC_WO_LAYERS:
        case IDC_WO_PATCHES:
        case IDC_DC_APPHELP:
        case IDC_DC_SHIMS:
        case IDC_DC_FLAGS:
        case IDC_DC_LAYERS:
        case IDC_DC_PATCHES:
        
        case IDC_DISABLED_ONLY:
            FilterAndShow(hdlg);
            break;
        
        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    InitCommonControls();

    g_hInstance = hInstance;

    DialogBox(hInstance,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              BrowseAppCompatDlgProc);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowserwin2k\acbrowser.h ===
#ifndef _ACBROWSER_H
#define _ACBROWSER_H

#include <windows.h>

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSION       0x00000005
#define APPTYPE_SHIM          0x00000006

typedef VOID (*PFNADDSHIM)(char* pszApp,
                           char* pszShim,
                           char* pszAttributes,
                           BOOL  bEnabled,
                           BOOL  bShim);


void LogMsg(LPSTR pszFmt, ... );
BOOL CenterWindow(HWND hWnd);

BOOL
EnumShimmedApps_Win2000(
    PFNADDSHIM pfnAddShim,
    BOOL       bOnlyShims);

BOOL
EnableShim_Win2000(
    char* pszApp,
    char* pszShim);

BOOL
DisableShim_Win2000(
    char* pszApp,
    char* pszShim);

BOOL
DeleteShim_Win2000(
    char* pszApp,
    char* pszShim);

#endif // _ACBROWSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowser\dbsupport.c ===
#include "acBrowser.h"
#include <wchar.h>

#include <commctrl.h>
#include <psapi.h>

#include "shimdb.h"


#define SHIM_LOG_FILE       "shimlog.txt"

#define Alloc(cb)       \
            HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)

#define Free(p)         \
            HeapFree(GetProcessHeap(), 0, p)

PDBENTRY g_pEntries;
PFIX     g_pFixes;


#define MAX_DATA_SIZE       1024
#define MAX_NAME            256
#define MAX_DESCRIPTION     1024

WCHAR g_wszData[MAX_DATA_SIZE];

char g_szName[MAX_NAME];
char g_szDescription[MAX_DESCRIPTION];


#define APPCOMPAT_DISABLED  0x03

//
// REGISTRY STUFF. Needs to be revised
//

#define APPCOMPAT_KEY "Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags"

BOOL
CheckRegistry(
    HKEY  hkeyRoot,
    char* pszGUID
    )
{
    LONG  status;
    HKEY  hkey = NULL;
    BOOL  bDisabled = FALSE;
    DWORD dwFlags;
    DWORD type;
    DWORD cbSize = sizeof(DWORD);

    status = RegOpenKey(hkeyRoot, APPCOMPAT_KEY, &hkey);

    if (status != ERROR_SUCCESS) {
        return FALSE;
    }

    status = RegQueryValueEx(hkey, pszGUID, NULL, &type, (LPBYTE)&dwFlags, &cbSize);

    if (status == ERROR_SUCCESS && type == REG_DWORD && (dwFlags & APPCOMPAT_DISABLED)) {
        bDisabled = TRUE;
    }

    RegCloseKey(hkey);

    return bDisabled;
}

BOOL
WriteRegistry(
    HKEY  hkeyRoot,
    char* pszKeyName
    )
{
    LONG  status;
    HKEY  hkey;
    DWORD dwValue = 0x03;
    DWORD dwDisposition = 0;
    BOOL  bDisabled = FALSE;

    status = RegCreateKeyEx(hkeyRoot,
                            APPCOMPAT_KEY,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkey,
                            &dwDisposition);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to set the value for \"%s\"\n", pszKeyName);
        return FALSE;
    }

    status = RegSetValueEx(hkey, pszKeyName, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(DWORD));

    RegCloseKey(hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to set the value for \"%s\"\n", pszKeyName);
        return FALSE;
    }

    return TRUE;
}

BOOL
DeleteRegistry(
    HKEY  hkeyRoot,
    char* pszKeyName
    )
{
    LONG  status;
    HKEY  hkey = NULL;
    DWORD dwValue = 0;
    DWORD dwDisposition = 0;
    BOOL  bDisabled = FALSE;

    status = RegOpenKey(hkeyRoot, APPCOMPAT_KEY, &hkey);

    if (status != ERROR_SUCCESS) {
        return TRUE;
    }

    status = RegDeleteValue(hkey, pszKeyName);

    RegCloseKey(hkey);

    return TRUE;
}

typedef void (*PFNFLUSHCACHE)(HWND, HINSTANCE, LPSTR, int);

void
FlushTheCache(
    void
    )
{
    HINSTANCE     hmod;
    PFNFLUSHCACHE pfnFlushCache;
    char          szPath[MAX_PATH];

    GetSystemDirectory(szPath, MAX_PATH);

    lstrcat(szPath, "\\apphelp.dll");

    hmod = LoadLibrary(szPath);

    if (hmod != NULL) {
        pfnFlushCache = (PFNFLUSHCACHE)GetProcAddress(hmod, "ShimFlushCache");

        if (pfnFlushCache != NULL) {
            (*pfnFlushCache)(0, 0, NULL, 0);
        }
    }
}

void
UpdateFixStatus(
    char* pszGUID,
    BOOL  bPerUser,
    BOOL  bPerMachine
    )
{
    if (bPerUser) {
        WriteRegistry(HKEY_CURRENT_USER, pszGUID);
    } else {
        DeleteRegistry(HKEY_CURRENT_USER, pszGUID);
    }

    if (bPerMachine) {
        WriteRegistry(HKEY_LOCAL_MACHINE, pszGUID);
    } else {
        DeleteRegistry(HKEY_LOCAL_MACHINE, pszGUID);
    }

    FlushTheCache();
}


PFIX
AllocFix(
    char*   pszFixName,
    char*   pszFixDescription,
    FIXTYPE type
    )
{
    PFIX   pFix;
    char*  pszAlloc;

    pFix = (PFIX)Alloc(sizeof(FIX));
    
    if (pFix == NULL) {
        LogMsg("Cannot allocate %d bytes\n", sizeof(FIX));
        return NULL;
    }

    if (pszFixName == NULL || *pszFixName == 0) {
        pFix->pszName = NULL;
    } else {
        pszAlloc = (char*)Alloc(lstrlen(pszFixName) + 1);
        pFix->pszName = pszAlloc;
        if (pszAlloc != NULL) {
            lstrcpy(pszAlloc, pszFixName);
        } else {
            LogMsg("Cannot allocate %d bytes\n", lstrlen(pszFixName) + 1);
            goto Error;
        }
    }

    if (pszFixDescription == NULL || *pszFixDescription == 0) {
        pFix->pszDescription = NULL;
    } else {
        pszAlloc = (char*)Alloc(lstrlen(pszFixDescription) + 1);
        pFix->pszDescription = pszAlloc;
        if (pszAlloc != NULL) {
            lstrcpy(pszAlloc, pszFixDescription);
        } else {
            LogMsg("Cannot allocate %d bytes\n", lstrlen(pszFixDescription) + 1);
            goto Error;
        }
    }
    
    pFix->fixType = type;
    pFix->pNext   = NULL;

    return pFix;

Error:
    if (pFix->pszName != NULL) {
        Free(pFix->pszName);
    }
    
    if (pFix->pszDescription != NULL) {
        Free(pFix->pszDescription);
    }
    
    Free(pFix);

    return NULL;
}


void
ReadFix(
    PDB     pdb,
    TAGID   tiFix,
    FIXTYPE type
    )
{
    TAGID     tiInfo;
    TAG       tWhich;
    PFIX      pFix;
    ULONGLONG ullUser = 0;
    ULONGLONG ullKernel = 0;

    tiInfo = SdbGetFirstChild(pdb, tiFix);

    g_szName[0] = 0;
    g_szDescription[0] = 0;

    while (tiInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiInfo);

        switch (tWhich) {

        case TAG_NAME:
            if (SdbReadStringTag(pdb, tiInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(g_szName, "%ws", g_wszData);
            }
            break;

        case TAG_DESCRIPTION:
            if (SdbReadStringTag(pdb, tiInfo, g_wszData, MAX_DESCRIPTION * sizeof(WCHAR))) {
                wsprintf(g_szDescription, "%ws", g_wszData);
            }
            break;

        case TAG_FLAG_MASK_USER:
            ullUser = SdbReadQWORDTag(pdb, tiInfo, 0);
            break;

        case TAG_FLAG_MASK_KERNEL:
            ullKernel = SdbReadQWORDTag(pdb, tiInfo, 0);
            break;

        default:
            break;
        }

        tiInfo = SdbGetNextChild(pdb, tiFix, tiInfo);
    }

    pFix = AllocFix(g_szName, g_szDescription, type);

    if (pFix != NULL) {
        
        if (type == FIX_FLAG) {
            if (ullKernel == 0) {
                pFix->flagType = FLAG_USER;
                pFix->ullMask = ullUser;
            } else {
                pFix->flagType = FLAG_KERNEL;
                pFix->ullMask = ullKernel;
            }
        }
        
        pFix->pNext = g_pFixes;
        g_pFixes = pFix;
    }
}

void
ReadFixes(
    PDB   pdb,
    TAGID tiDatabase,
    TAGID tiLibrary
    )
{
    TAGID tiFix;

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_SHIM);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_SHIM);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_PATCH);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_PATCH);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    tiFix = SdbFindFirstTag(pdb, tiLibrary, TAG_FLAG);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_FLAG);
        tiFix = SdbFindNextTag(pdb, tiLibrary, tiFix);
    }

    //
    // The LAYERs are under the DATABASE tag instead of LIBRARY :-(
    //
    tiFix = SdbFindFirstTag(pdb, tiDatabase, TAG_LAYER);

    while (tiFix != 0) {
        ReadFix(pdb, tiFix, FIX_LAYER);
        tiFix = SdbFindNextTag(pdb, tiDatabase, tiFix);
    }
}

PFIX
FindFix(
    char*    pszFixName,
    FIXTYPE  fixType
    )
{
    PFIX pFix = g_pFixes;

    while (pFix != NULL) {

        if (pFix->pszName && lstrcmpi(pszFixName, pFix->pszName) == 0) {
            return pFix;
        }

        pFix = pFix->pNext;
    }
    
    return NULL;
}

PFIX
FindFlagFix(
    ULONGLONG ullMask,
    FLAGTYPE  flagType
    )
{
    PFIX pFix = g_pFixes;

    while (pFix != NULL) {

        if (pFix->fixType == FIX_FLAG &&
            pFix->flagType == flagType &&
            pFix->ullMask == ullMask) {
            
            return pFix;
        }
        
        pFix = pFix->pNext;
    }
    
    return NULL;
}

BOOL
AddFlags(
    PDB      pdb,
    TAGID    tiFlags,
    PDBENTRY pEntry,
    FLAGTYPE flagType
    )
{
    ULONGLONG ullFlags;
    ULONGLONG ullMask = 1;
    PFIX      pFix;
    PFIXLIST  pFixList;
    int       i;
    
    ullFlags = SdbReadQWORDTag(pdb, tiFlags, 0);

    for (i = 0; i < sizeof(ULONGLONG) * 8; i++) {

        if (ullFlags & ullMask) {

            pFix = FindFlagFix(ullMask, flagType);

            if (pFix == NULL) {
                LogMsg("Cannot find flag fix ref\n");
            }

            pFixList = (PFIXLIST)Alloc(sizeof(FIXLIST));

            if (pFixList == NULL) {
                LogMsg("Cannot allocate %d bytes\n", sizeof(FIXLIST));
                return FALSE;
            }

            pFixList->pFix = pFix;
            pFixList->pNext = pEntry->pFirstFlag;

            pEntry->pFirstFlag = pFixList;
        }
        
        ullMask <<= 1;
    }
    
    return TRUE;
}


BOOL
AddFix(
    PDB      pdb,
    TAGID    tiFix,
    PDBENTRY pEntry,
    FIXTYPE  fixType
    )
{
    TAGID     tiName;
    char      szFixName[MAX_NAME];
    PFIX      pFix;
    PFIXLIST* ppHead;
    PFIXLIST  pFixList;

    tiName = SdbFindFirstTag(pdb, tiFix, TAG_NAME);

    if (!SdbReadStringTag(pdb, tiName, g_wszData, MAX_NAME * sizeof(WCHAR))) {
        LogMsg("Cannot read the name of the fix\n");
        return FALSE;
    }

    wsprintf(szFixName, "%ws", g_wszData);

    pFix = FindFix(szFixName, fixType);

    if (pFix == NULL) {
        LogMsg("Cannot find fix ref for: \"%s\" type %d\n", szFixName, fixType);
        return FALSE;
    }

    switch (fixType) {
    case FIX_SHIM:
        ppHead = &pEntry->pFirstShim;
        break;
    
    case FIX_PATCH:
        ppHead = &pEntry->pFirstPatch;
        break;
    
    case FIX_FLAG:
        ppHead = &pEntry->pFirstFlag;
        break;
    
    case FIX_LAYER:
        ppHead = &pEntry->pFirstLayer;
        break;
    }

    pFixList = (PFIXLIST)Alloc(sizeof(FIXLIST));

    if (pFixList == NULL) {
        LogMsg("Cannot allocate %d bytes\n", sizeof(FIXLIST));
        return FALSE;
    }

    pFixList->pFix = pFix;
    pFixList->pNext = *ppHead;

    *ppHead = pFixList;
    
    return TRUE;
}

void
AddAttr(
    char*         pszAttr,
    PMATCHINGFILE pMatch
    )
{
    PATTRIBUTE pAttr;

    pAttr = (PATTRIBUTE)Alloc(sizeof(ATTRIBUTE));

    if (pAttr) {
        pAttr->pszText = (char*)Alloc(lstrlen(pszAttr) + 1);

        if (pAttr->pszText) {
            lstrcpy(pAttr->pszText, pszAttr);

            pAttr->pNext = pMatch->pFirstAttribute;

            pMatch->pFirstAttribute = pAttr;
        } else {
            Free(pAttr);
        }
    }
}

VOID
PrintBinVer(
    char*          pszText,
    LARGE_INTEGER* pliBinVer
    )
{
    wsprintf(pszText, "%d", HIWORD(pliBinVer->HighPart));
    pszText += lstrlen(pszText);

    if (LOWORD(pliBinVer->HighPart) == 0xFFFF) {
        return;
    }
    
    wsprintf(pszText, ".%d", LOWORD(pliBinVer->HighPart));
    pszText += lstrlen(pszText);

    if (HIWORD(pliBinVer->LowPart) == 0xFFFF) {
        return;
    }
    
    wsprintf(pszText, ".%d", HIWORD(pliBinVer->LowPart));
    pszText += lstrlen(pszText);
    
    if (LOWORD(pliBinVer->LowPart) == 0xFFFF) {
        return;
    }
    
    wsprintf(pszText, ".%d", LOWORD(pliBinVer->LowPart));
    pszText += lstrlen(pszText);
}

BOOL
AddMatchingFile(
    PDB      pdb,
    TAGID    tiMatch,
    PDBENTRY pEntry
    )
{
    TAGID         tiMatchInfo;
    TAG           tWhich;
    DWORD         dw;
    LARGE_INTEGER li;
    PMATCHINGFILE pMatch;
    char          szStr[128];
    char          szAttr[256];

    pMatch = (PMATCHINGFILE)Alloc(sizeof(MATCHINGFILE));

    if (pMatch == NULL) {
        return FALSE;
    }

    tiMatchInfo = SdbGetFirstChild(pdb, tiMatch);

    while (tiMatchInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiMatchInfo);

        switch (tWhich) {

        case TAG_NAME:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(szAttr, "%ws", g_wszData);
                
                pMatch->pszName = (char*)Alloc(lstrlen(szAttr) + 1);

                if (pMatch->pszName) {
                    lstrcpy(pMatch->pszName, szAttr);
                }
            }
            break;

        case TAG_SIZE:
            dw = SdbReadDWORDTag(pdb, tiMatchInfo, 0);
            
            if (dw != 0) {
                wsprintf(szAttr, "File Size: 0x%X", dw);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_CHECKSUM:
            dw = SdbReadDWORDTag(pdb, tiMatchInfo, 0);
            
            if (dw != 0) {
                wsprintf(szAttr, "File CheckSum: 0x%X", dw);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_COMPANY_NAME:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "Company Name: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_PRODUCT_NAME:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "Product Name: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_PRODUCT_VERSION:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "Product Version: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_FILE_DESCRIPTION:
            if (SdbReadStringTag(pdb, tiMatchInfo, g_wszData, MAX_DATA_SIZE * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                wsprintf(szAttr, "File Description: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        case TAG_BIN_FILE_VERSION:
            li.QuadPart = SdbReadQWORDTag(pdb, tiMatchInfo, 0);
            
            if (li.HighPart != 0 || li.LowPart != 0) {

                PrintBinVer(szStr, &li);
                
                wsprintf(szAttr, "Binary File Version: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            
            break;

        case TAG_BIN_PRODUCT_VERSION:
            li.QuadPart = SdbReadQWORDTag(pdb, tiMatchInfo, 0);
            
            if (li.HighPart != 0 || li.LowPart != 0) {

                PrintBinVer(szStr, &li);
                
                wsprintf(szAttr, "Binary Product Version: %s", szStr);
                AddAttr(szAttr, pMatch);
            }
            break;

        default:
            break;
        }
        tiMatchInfo = SdbGetNextChild(pdb, tiMatch, tiMatchInfo);
    }

    pMatch->pNext = pEntry->pFirstMatchingFile;

    pEntry->pFirstMatchingFile = pMatch;

    (pEntry->nMatchingFiles)++;

    return TRUE;
}

void
AddEntry(
    PDB   pdb,
    TAGID tiExe
    )
{
    TAGID     tiExeInfo;
    TAGID     tiSeverity, tiHelpId;
    char      szStr[MAX_NAME];
    TAG       tWhich;
    PDBENTRY  pEntry;

    tiExeInfo = SdbGetFirstChild(pdb, tiExe);

    pEntry = (PDBENTRY)Alloc(sizeof(DBENTRY));

    if (pEntry == NULL) {
        LogMsg("Cannot allocate %d bytes\n", sizeof(DBENTRY));
        return;
    }

    pEntry->pNext = g_pEntries;
    g_pEntries = pEntry;

    while (tiExeInfo != 0) {
        tWhich = SdbGetTagFromTagID(pdb, tiExeInfo);

        switch (tWhich) {

        case TAG_NAME:
            if (SdbReadStringTag(pdb, tiExeInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                pEntry->pszExeName = (char*)Alloc(lstrlen(szStr) + 1);

                if (pEntry->pszExeName) {
                    lstrcpy(pEntry->pszExeName, szStr);
                }
            }
            break;

        case TAG_APP_NAME:
            if (SdbReadStringTag(pdb, tiExeInfo, g_wszData, MAX_NAME * sizeof(WCHAR))) {
                wsprintf(szStr, "%ws", g_wszData);

                pEntry->pszAppName = (char*)Alloc(lstrlen(szStr) + 1);

                if (pEntry->pszAppName) {
                    lstrcpy(pEntry->pszAppName, szStr);
                }
            }
            break;

        case TAG_MATCHING_FILE:
            AddMatchingFile(pdb, tiExeInfo, pEntry);
            break;

        case TAG_APPHELP:
            pEntry->appHelp.bPresent = TRUE;
            
            tiSeverity = SdbFindFirstTag(pdb, tiExeInfo, TAG_PROBLEMSEVERITY);
            pEntry->appHelp.severity = (SEVERITY)SdbReadDWORDTag(pdb, tiSeverity, 0);

            tiHelpId = SdbFindFirstTag(pdb, tiExeInfo, TAG_HTMLHELPID);
            pEntry->appHelp.htmlHelpId = SdbReadDWORDTag(pdb, tiHelpId, 0);

            break;

        case TAG_SHIM_REF:
            AddFix(pdb, tiExeInfo, pEntry, FIX_SHIM);
            break;

        case TAG_PATCH_REF:
            AddFix(pdb, tiExeInfo, pEntry, FIX_PATCH);
            break;

        case TAG_LAYER:
            AddFix(pdb, tiExeInfo, pEntry, FIX_LAYER);
            break;

        case TAG_FLAG_MASK_USER:
            AddFlags(pdb, tiExeInfo, pEntry, FLAG_USER);
            break;

        case TAG_FLAG_MASK_KERNEL:
            AddFlags(pdb, tiExeInfo, pEntry, FLAG_KERNEL);
            break;

        case TAG_EXE_ID:
        {
            GUID  guid;
            PVOID p;

            p = SdbGetBinaryTagData(pdb, tiExeInfo);

            if (p != NULL) {
                memcpy(&guid, p, sizeof(GUID));
                
                wsprintf(pEntry->szGUID,
                         "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
                         guid.Data1,
                         guid.Data2,
                         guid.Data3,
                         guid.Data4[0],
                         guid.Data4[1],
                         guid.Data4[2],
                         guid.Data4[3],
                         guid.Data4[4],
                         guid.Data4[5],
                         guid.Data4[6],
                         guid.Data4[7]);
            }
            break;
        }

        default:
            break;
        }
        tiExeInfo = SdbGetNextChild(pdb, tiExe, tiExeInfo);
    }
    
    pEntry->bDisablePerMachine = CheckRegistry(HKEY_LOCAL_MACHINE, pEntry->szGUID);
    pEntry->bDisablePerUser = CheckRegistry(HKEY_CURRENT_USER, pEntry->szGUID);
}


PDBENTRY
GetDatabaseEntries(
    void
    )
{
    WCHAR wszShimDB[MAX_PATH] = L"";
    PDB   pdb;
    TAGID tiDatabase, tiLibrary, tiExe;

    GetSystemWindowsDirectoryW(wszShimDB, MAX_PATH);
    wcscat(wszShimDB, L"\\AppPatch\\sysmain.sdb");

    //
    // Open sysmain.sdb shim database
    //
    pdb = SdbOpenDatabase(wszShimDB, DOS_PATH);

    if (pdb == NULL) {
        LogMsg("Cannot open shim DB \"%ws\"\n", wszShimDB);
        goto Cleanup;
    }

    tiDatabase = SdbFindFirstTag(pdb, TAGID_ROOT, TAG_DATABASE);

    if (tiDatabase == 0) {
        LogMsg("Cannot find TAG_DATABASE\n");
        goto Cleanup;
    }

    tiLibrary = SdbFindFirstTag(pdb, tiDatabase, TAG_LIBRARY);

    if (tiLibrary == 0) {
        LogMsg("Cannot find TAG_LIBRARY\n");
        goto Cleanup;
    }

    ReadFixes(pdb, tiDatabase, tiLibrary);
    
    //
    // Loop through the EXEs.
    //
    tiExe = SdbFindFirstTag(pdb, tiDatabase, TAG_EXE);

    while (tiExe != 0) {
        AddEntry(pdb, tiExe);

        tiExe = SdbFindNextTag(pdb, tiDatabase, tiExe);
    }

Cleanup:
    if (pdb != NULL) {
        SdbCloseDatabase(pdb);
    }

    return g_pEntries;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowserwin2k\acbrowser.c ===
// BrowseAppCompat.cpp : Defines the entry point for the application.
//

#include "acBrowser.h"
#include "resource.h"

#include <commctrl.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

/*
 * Global Variables
 */

HINSTANCE g_hInstance;
HWND      g_hDlg;

HWND      g_hwndList;

HFONT     g_hFont;
int       g_nItems;

BOOL g_bEnable;
BOOL g_bDelete;


#define CHANGE_NOCHANGE 0
#define CHANGE_ENABLE   1
#define CHANGE_DISABLE  2
#define CHANGE_DELETE   3


#define COLUMN_APP      0
#define COLUMN_STATUS   1
#define COLUMN_CHANGE   2

typedef struct tagREGITEM {
    char*     pszApp;
    char*     pszShim;
    char*     pszAttr;
    int       nItem;
    BOOL      bShim;
    BOOL      bEnabled;
    int       change;
} REGITEM, *PREGITEM;


/*********************************************************************
* LogMsg
*
*********************************************************************/
void LogMsg(
    LPSTR pszFmt,
    ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

/*******************************************************************************
* CenterWindow
*
*  This function must be called at the WM_INIDIALOG in order to
*  move the dialog window centered in the client area of the
*  parent or owner window.
*******************************************************************************/
BOOL CenterWindow(
    HWND hWnd)
{
    RECT    rectWindow, rectParent, rectScreen;
    int     nCX, nCY;
    HWND    hParent;
    POINT   ptPoint;

    hParent =  GetParent(hWnd);
    if (hParent == NULL)
        hParent = GetDesktopWindow();

    GetWindowRect(hParent,            (LPRECT)&rectParent);
    GetWindowRect(hWnd,               (LPRECT)&rectWindow);
    GetWindowRect(GetDesktopWindow(), (LPRECT)&rectScreen);

    nCX = rectWindow.right  - rectWindow.left;
    nCY = rectWindow.bottom - rectWindow.top;

    ptPoint.x = ((rectParent.right  + rectParent.left) / 2) - (nCX / 2);
    ptPoint.y = ((rectParent.bottom + rectParent.top ) / 2) - (nCY / 2);

    if (ptPoint.x < rectScreen.left)
        ptPoint.x = rectScreen.left;
    if (ptPoint.x > rectScreen.right  - nCX)
        ptPoint.x = rectScreen.right  - nCX;
    if (ptPoint.y < rectScreen.top)
        ptPoint.y = rectScreen.top;
    if (ptPoint.y > rectScreen.bottom - nCY)
        ptPoint.y = rectScreen.bottom - nCY;

    if (GetWindowLong(hWnd, GWL_STYLE) & WS_CHILD)
        ScreenToClient(hParent, (LPPOINT)&ptPoint);

    if (!MoveWindow(hWnd, ptPoint.x, ptPoint.y, nCX, nCY, TRUE))
        return FALSE;

    return TRUE;
}

/*********************************************************************
* AddShimToList
*
*********************************************************************/
VOID AddShimToList(
    char* pszApp,
    char* pszShim,
    char* pszData,
    BOOL  bEnabled,
    BOOL  bShim)
{
    char*    pszAppAlloc;
    char*    pszShimAlloc;
    char*    pszDataAlloc;
    char     szDisp[128];
    PREGITEM pItem;
    LVITEM   lvi; 
    
    pszAppAlloc = (char*)HeapAlloc(GetProcessHeap(), 0, lstrlen(pszApp) + 1);

    if (pszAppAlloc == NULL) {
        LogMsg("AddApp: error trying to allocate %d bytes\n", lstrlen(pszApp) + 1);
        return;
    }
    lstrcpy(pszAppAlloc, pszApp);
    
    pszShimAlloc = (char*)HeapAlloc(GetProcessHeap(), 0, lstrlen(pszShim) + 1);

    if (pszShimAlloc == NULL) {
        HeapFree(GetProcessHeap(), 0, pszAppAlloc);
        LogMsg("AddApp: error trying to allocate %d bytes\n", lstrlen(pszShim) + 1);
        return;
    }
    lstrcpy(pszShimAlloc, pszShim);
    
    pszDataAlloc = (char*)HeapAlloc(GetProcessHeap(), 0, lstrlen(pszData) + 1);

    if (pszDataAlloc == NULL) {
        HeapFree(GetProcessHeap(), 0, pszAppAlloc);
        HeapFree(GetProcessHeap(), 0, pszShimAlloc);
        LogMsg("AddApp: error trying to allocate %d bytes\n", lstrlen(pszData) + 1);
        return;
    }
    lstrcpy(pszDataAlloc, pszData);
    
    pItem = (PREGITEM)HeapAlloc(GetProcessHeap(), 0, sizeof(REGITEM));
    
    if (pItem == NULL) {
        HeapFree(GetProcessHeap(), 0, pszAppAlloc);
        HeapFree(GetProcessHeap(), 0, pszShimAlloc);
        HeapFree(GetProcessHeap(), 0, pszDataAlloc);
        LogMsg("AddApp: error trying to allocate %d bytes\n", sizeof(REGITEM));
        return;
    }

    wsprintf(szDisp, "%s (%s)",pszAppAlloc ,pszShimAlloc);
    
    pItem->pszApp   = pszAppAlloc;
    pItem->pszShim  = pszShimAlloc;
    pItem->pszAttr  = pszDataAlloc;
    pItem->bEnabled = bEnabled;
    pItem->change   = CHANGE_NOCHANGE;
    pItem->bShim    = bShim;
    
    // Initialize LVITEM members that are common to all items.
    lvi.mask      = LVIF_TEXT | LVIF_PARAM;
    lvi.pszText   = szDisp;
    lvi.iItem     = g_nItems;
    lvi.iSubItem  = 0;
    lvi.lParam    = (LPARAM)pItem;

    pItem->nItem  = ListView_InsertItem(g_hwndList, &lvi);

    lvi.mask      = LVIF_TEXT;
    lvi.iItem     = g_nItems++;
    lvi.iSubItem  = COLUMN_STATUS;
    
    if (bShim) {
        lvi.pszText = (bEnabled ? "enabled" : "DISABLED");
    } else {
        lvi.pszText = "";
    }

    ListView_SetItem(g_hwndList, &lvi);
}

/*********************************************************************
* InsertColumnIntoListView
*
*********************************************************************/
VOID
InsertColumnIntoListView(
    LPSTR    lpszColumn,
    DWORD    dwSubItem,
    DWORD    widthPercent)
{
    LVCOLUMN  lvc;
    RECT      rcClient;
    DWORD     width;

    GetWindowRect(g_hwndList, &rcClient);
    
    width = rcClient.right - rcClient.left -
                4 * GetSystemMetrics(SM_CXBORDER) -
                GetSystemMetrics(SM_CXVSCROLL);
    
    width = width * widthPercent / 100;
    
    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.iSubItem = dwSubItem;
    lvc.cx       = width;
    lvc.pszText  = lpszColumn;
    
    ListView_InsertColumn(g_hwndList, dwSubItem, &lvc);
}

/*********************************************************************
* DoInitDialog
*
*********************************************************************/
VOID
DoInitDialog(
    HWND hdlg)
{
    g_hDlg = hdlg;

    CenterWindow(hdlg);

    g_hFont = CreateFont(15,
                         0, 0, 0, FW_EXTRALIGHT, 0, 0, 0, 0, 0,
                         0, 0, 0, (LPSTR)"Courier New");
    
    g_hwndList = GetDlgItem(hdlg, IDC_LIST);
    
    g_nItems = 0;

    SendDlgItemMessage(hdlg, IDC_ATTR_USED, WM_SETFONT, (WPARAM)g_hFont, 0);
    
    SetDlgItemText(hdlg,
                   IDC_ATTR_USED,
                   "Select a shim to see what attributes are used to identify the application");
    
    InsertColumnIntoListView("Application", COLUMN_APP,    60);
    InsertColumnIntoListView("Status",      COLUMN_STATUS, 20);
    InsertColumnIntoListView("Change",      COLUMN_CHANGE, 20);

    g_bEnable = TRUE;
    g_bDelete = TRUE;

    EnumShimmedApps_Win2000(AddShimToList, FALSE);
}

/*********************************************************************
* DoDeleteListItem
*
*********************************************************************/
VOID
DoDeleteListItem(
    LPARAM lParam)
{
    LPNMLISTVIEW pnmv = (LPNMLISTVIEW)lParam;

    if (pnmv->iSubItem == 0) {
        PREGITEM pItem = (PREGITEM)pnmv->lParam;

        HeapFree(GetProcessHeap(), 0, pItem->pszApp);
        HeapFree(GetProcessHeap(), 0, pItem->pszAttr);
        
        if (pItem->pszShim != NULL) {
            HeapFree(GetProcessHeap(), 0, pItem->pszShim);
        }
        pItem->pszApp  = NULL;
        pItem->pszAttr = NULL;
        pItem->pszShim = NULL;
    
        HeapFree(GetProcessHeap(), 0, pItem);
    }
}

/*********************************************************************
* DoSelectionChanged
*
*********************************************************************/
VOID
DoSelectionChanged(
    HWND   hdlg,
    LPARAM lParam)
{
    LVITEM   lvi;
    PREGITEM pItem;

    int nSel = ListView_GetSelectionMark(g_hwndList);

    if (nSel == -1)
        return;

    lvi.iItem = nSel;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pItem = (PREGITEM)lvi.lParam;

    SetDlgItemText(hdlg, IDC_ATTR_USED, pItem->pszAttr);

    if (!pItem->bShim) {
        EnableWindow(GetDlgItem(hdlg, IDC_ENABLE), FALSE);
        EnableWindow(GetDlgItem(hdlg, IDC_DELETE), FALSE);
    } else {
        EnableWindow(GetDlgItem(hdlg, IDC_ENABLE), TRUE);
        EnableWindow(GetDlgItem(hdlg, IDC_DELETE), TRUE);
        
        if (pItem->bEnabled) {
            switch (pItem->change) {
            case CHANGE_NOCHANGE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = FALSE;
                g_bDelete = TRUE;
                break;
            case CHANGE_DISABLE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = TRUE;
                g_bDelete = TRUE;
                break;
            case CHANGE_DELETE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
                SetDlgItemText(hdlg, IDC_DELETE, "Undo Dele&te");

                g_bEnable = FALSE;
                g_bDelete = FALSE;
                break;
            }
        } else {
            switch (pItem->change) {
            case CHANGE_NOCHANGE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = TRUE;
                g_bDelete = TRUE;
                break;
            case CHANGE_ENABLE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
                SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");

                g_bEnable = FALSE;
                g_bDelete = TRUE;
                break;
            case CHANGE_DELETE:
                SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
                SetDlgItemText(hdlg, IDC_DELETE, "Undo Dele&te");

                g_bEnable = TRUE;
                g_bDelete = FALSE;
                break;
            }
        }
    }
}

/*********************************************************************
* OnEnable
*
*********************************************************************/
VOID
OnEnable(
    HWND hdlg)
{
    PREGITEM pItem;
    int      nSel = ListView_GetSelectionMark(g_hwndList);

    LVITEM lvi;
    
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pItem = (PREGITEM)lvi.lParam;
    
    lvi.mask     = LVIF_TEXT;
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_CHANGE;
    
    if (g_bEnable) {
        lvi.pszText = (pItem->bEnabled ? "" : "enable");
        pItem->change = (pItem->bEnabled ? CHANGE_NOCHANGE : CHANGE_ENABLE);
        SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
    } else {
        lvi.pszText = (pItem->bEnabled ? "disable" : "");
        pItem->change = (pItem->bEnabled ? CHANGE_DISABLE : CHANGE_NOCHANGE);
        SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");
    }
    
    SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");
    g_bDelete = TRUE;

    g_bEnable = !g_bEnable;

    ListView_SetItem(g_hwndList, &lvi);
}

/*********************************************************************
* OnDelete
*
*********************************************************************/
VOID
OnDelete(
    HWND hdlg)
{
    PREGITEM pItem;
    LVITEM   lvi;
	int      nSel = ListView_GetSelectionMark(g_hwndList);
    
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    ListView_GetItem(g_hwndList, &lvi);

    pItem = (PREGITEM)lvi.lParam;
    
    lvi.mask     = LVIF_TEXT;
    lvi.iItem    = nSel;
    lvi.iSubItem = COLUMN_CHANGE;
    
    if (g_bDelete) {
        SetDlgItemText(hdlg, IDC_DELETE, "Undo Dele&te");
        lvi.pszText = "delete";
        pItem->change = CHANGE_DELETE;
    } else {
        SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");
        lvi.pszText = "";
        pItem->change = CHANGE_NOCHANGE;
    }
    
    if (pItem->bEnabled) {
        SetDlgItemText(hdlg, IDC_ENABLE, "&Disable");
    }
    g_bDelete = !g_bDelete;
    
    ListView_SetItem(g_hwndList, &lvi);
}

/*********************************************************************
* OnShowOnlyShims
*
*********************************************************************/
VOID
OnShowOnlyShims(
    HWND hdlg)
{
    BOOL bOnlyShims;
    
    bOnlyShims = (SendDlgItemMessage(hdlg,
                                     IDC_ONLY_SHIMS,
                                     BM_GETCHECK,
                                     0,
                                     0) == BST_CHECKED);
    
    SendMessage(g_hwndList, WM_SETREDRAW, FALSE, 0);
    
    g_nItems = 0;
    
    ListView_DeleteAllItems(g_hwndList);
    
    g_bEnable = TRUE;
    g_bDelete = TRUE;

    EnumShimmedApps_Win2000(AddShimToList, bOnlyShims);

    SendMessage(g_hwndList, WM_SETREDRAW, TRUE, 0);
}

/*********************************************************************
* OnApply
*
*********************************************************************/
VOID
OnApply(
    HWND hdlg)
{
    LVITEM   lvi;
    PREGITEM pItem;
    int      i;
    
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    for (i = 0; i < g_nItems; i++) {
        lvi.iItem = i;
        
        ListView_GetItem(g_hwndList, &lvi);

        pItem = (PREGITEM)lvi.lParam;

        if (pItem->change == CHANGE_NOCHANGE)
            continue;
    
        switch (pItem->change) {
        case CHANGE_ENABLE:
            EnableShim_Win2000(pItem->pszApp, pItem->pszShim);
            break;
        case CHANGE_DISABLE:
            DisableShim_Win2000(pItem->pszApp, pItem->pszShim);
            break;
        case CHANGE_DELETE:
            DeleteShim_Win2000(pItem->pszApp, pItem->pszShim);
            break;
        }
    }

    SetDlgItemText(hdlg, IDC_DELETE, "Dele&te");
    SetDlgItemText(hdlg, IDC_ENABLE, "&Enable");

    OnShowOnlyShims(hdlg);
}

/*********************************************************************
* OnPrint
*
*********************************************************************/

char g_szDisplay[1024 * 1024];

VOID
OnDisplayAll(
    HWND hdlg)
{
    LVITEM   lvi;
    PREGITEM pItem;
    char*    pszDisplay = g_szDisplay;
    int      i;
    
    lvi.iSubItem = COLUMN_APP;
    lvi.mask     = LVIF_PARAM;

    for (i = 0; i < g_nItems; i++) {
        lvi.iItem = i;
        
        ListView_GetItem(g_hwndList, &lvi);

        pItem = (PREGITEM)lvi.lParam;

        lstrcpy(pszDisplay, pItem->pszAttr);
        lstrcat(pszDisplay, "\r\n");
        pszDisplay += lstrlen(pszDisplay);
    }
    SetDlgItemText(hdlg, IDC_ATTR_USED, g_szDisplay);
}

/*********************************************************************
* BrowseAppCompatDlgProc
*
*********************************************************************/
INT_PTR CALLBACK
BrowseAppCompatDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int wCode = LOWORD(wParam);
    int wNotifyCode = HIWORD(wParam);

    switch (uMsg) {
    case WM_INITDIALOG:
        DoInitDialog(hdlg);
        break;

    case WM_NOTIFY:
        if (wParam == IDC_LIST) {
            LPNMHDR pnm = (LPNMHDR)lParam;

            switch (pnm->code) {
            case LVN_DELETEITEM:
                DoDeleteListItem(lParam);
                break;
            
            case LVN_ITEMCHANGED:
            case NM_CLICK:
                DoSelectionChanged(hdlg, lParam);
                break;
            
            default:
                break;
            }
        }
        break;

    case WM_COMMAND:
        switch (wCode) {
        
        case IDC_ENABLE:
            OnEnable(hdlg);
            break;
        
        case IDC_DELETE:
            OnDelete(hdlg);
            break;
        
        case IDC_APPLY:
            OnApply(hdlg);
            break;
        
        case IDC_ONLY_SHIMS:
            OnShowOnlyShims(hdlg);
            break;
        
        case IDC_DISPLAY_ALL:
            OnDisplayAll(hdlg);
            break;

        case IDCANCEL:
            EndDialog(hdlg, TRUE);
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    InitCommonControls();

    g_hInstance = hInstance;

    DialogBox(hInstance,
              MAKEINTRESOURCE(IDD_DIALOG),
              GetDesktopWindow(),
              BrowseAppCompatDlgProc);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowserwin2k\acbwin2000.c ===
#include "acBrowser.h"

#include "..\acFileAttr\acFileAttr.h"

typedef struct tagKEYHEADER{
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} KEYHEADER, *PKEYHEADER;


char g_szData[2048];

VOID
PrintHeader(
    KEYHEADER* pheader,
    char*      pszAppName,
    char*      pszShimData)
{
    char* pszOut = g_szData;

    lstrcpy(pszOut, "Application state: ");
    
    switch (pheader->AppType & APPTYPE_TYPE_MASK) {
    case APPTYPE_INC_NOBLOCK:
        lstrcat(pszOut, "Incompatible - no hard block\r\n");
        break;
    case APPTYPE_INC_HARDBLOCK:
        lstrcat(pszOut, "Incompatible - hard block\r\n");
        break;
    case APPTYPE_MINORPROBLEM:
        lstrcat(pszOut, "Minor problems\r\n");
        break;
    case APPTYPE_REINSTALL:
        lstrcat(pszOut, "Reinstall\r\n");
        break;
    case APPTYPE_VERSION:
        lstrcat(pszOut, "Version substitute\r\n");
        break;
    case APPTYPE_SHIM:
        lstrcat(pszOut, "Shim\r\n");
        break;
    default:
        lstrcat(pszOut, "AppsHelp\r\n");
        break;
    }
    
    pszOut = g_szData + lstrlen(g_szData);
    
    if (pszShimData == NULL) {
        wsprintf(pszOut, "Message ID: %d\r\n\r\n", pheader->MsgId);
    } else {
        wsprintf(pszOut, "Shim fix: %s\r\n\r\n", pszShimData);
    }

    pszOut = g_szData + lstrlen(g_szData);
    
    wsprintf(pszOut, "Attributes for %s:\r\n", pszAppName);
}

#define MAX_EXE_NAME        64
#define MAX_VALUE_LENGTH    64      // in most cases this is a number but
                                    // it can be a string as well
#define MAX_BLOB_SIZE       2048

BYTE g_data[MAX_BLOB_SIZE];

BOOL
EnumShimmedApps_Win2000(
    PFNADDSHIM pfnAddShim,
    BOOL       bOnlyShims)
{
    LONG     status;
    HKEY     hkey, hkeyApp;
    DWORD    cbSize;
    DWORD    cbData;
    DWORD    cbShimData;
    FILETIME ft;
    DWORD    dwType;
    char     szAppName[MAX_EXE_NAME];
    char     szValueName[MAX_VALUE_LENGTH];
    char     szShimValueName[128];
    char     szShimData[256];
    BOOL     bEnabled;
    DWORD    dwValue;
    
    KEYHEADER header;
   
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open AppCompatibility registry key\n");
        return FALSE;
    }
    
    // loop through all the binaries listed under the AppCompatibility key
    for (dwValue = 0; ; dwValue++) {
        
        DWORD dwV;

        // we'll only read binary names that are less then MAX_EXE_NAME
        // in size.
        cbSize = MAX_EXE_NAME;
        
        status = RegEnumKeyEx(
                        hkey,
                        dwValue,
                        szAppName,
                        &cbSize,
                        NULL,
                        NULL,
                        NULL,
                        &ft);

        // get out if no more entries
        if (status != ERROR_SUCCESS) {
            break;
        }
        
        // get the handle to the registry key for this app
        status = RegOpenKey(hkey,
                            szAppName,
                            &hkeyApp);
        
        // this should not fail but let's be cautious
        if (status != ERROR_SUCCESS) {
            LogMsg("Failed to open reg key for '%s'\n", szAppName);
            continue;
        }

        // loop through all the shims and AppsHelp entries for the
        // current app.
        for (dwV = 0; ; dwV++) {
            
            char* pszData;
            
            cbSize = MAX_VALUE_LENGTH;
            cbData = MAX_BLOB_SIZE;
            
            cbShimData = 256;

            status = RegEnumValue(
                            hkeyApp,
                            dwV,
                            szValueName,
                            &cbSize,
                            NULL,
                            &dwType,
                            (LPBYTE)&g_data,
                            &cbData);
            
            if (status != ERROR_SUCCESS) {
                break;
            }

            // we're only interested in the binary values
            if (dwType != REG_BINARY) {
                continue;
            }

            CopyMemory(&header, g_data, sizeof(KEYHEADER));

            // it must me a valid blob
            if (header.Size != sizeof(KEYHEADER)) {
                LogMsg("Invalid blob\n");
                continue;
            }            
            
            bEnabled = TRUE;

            // now let's look for an enabled shim entry
            wsprintf(szShimValueName, "DllPatch-%s", szValueName);

            status = RegQueryValueEx(
                            hkeyApp,
                            szShimValueName,
                            NULL,
                            &dwType,
                            (LPBYTE)szShimData,
                            &cbShimData);
        
            if (status != ERROR_SUCCESS) {
                
                // how about a disabled shim entry
                wsprintf(szShimValueName, "-DllPatch-%s", szValueName);

                status = RegQueryValueEx(
                                hkeyApp,
                                szShimValueName,
                                NULL,
                                &dwType,
                                (LPBYTE)szShimData,
                                &cbShimData);
        
                if (status != ERROR_SUCCESS) {
                    
                    // this is not a shim. If only shim entries are
                    // requested go to the next entry.
                    if (bOnlyShims) {
                        continue;
                    }
                    
                    // This is an AppsHelp entry.
                    PrintHeader(&header, szAppName, NULL);
                    pszData = g_szData + lstrlen(g_szData);
                    
                    if (BlobToString(g_data + sizeof(KEYHEADER),
                                     cbData - sizeof(KEYHEADER) - sizeof(DWORD),
                                     pszData)) {
                        (*pfnAddShim)(szAppName, szValueName, g_szData, TRUE, FALSE);
                    } else {
                        LogMsg("Failed to dump blob for AppsHelp entry: app '%s' entry '%s'\n",
                               szAppName, szValueName);
                    }
                    continue;
                }
                bEnabled = FALSE;
            }
            // This is a shim.
            PrintHeader(&header, szAppName, szShimData);
            pszData = g_szData + lstrlen(g_szData);
            
            if (BlobToString(g_data + sizeof(KEYHEADER),
                             cbData - sizeof(KEYHEADER) - sizeof(DWORD),
                             pszData)) {
                (*pfnAddShim)(szAppName, szValueName, g_szData, bEnabled, TRUE);
            } else {
                LogMsg("Failed to dump blob for shim entry: app '%s' entry '%s'\n",
                       szAppName, szValueName);
            }
        }
        
        RegCloseKey(hkeyApp);
    }

    RegCloseKey(hkey);

    return TRUE;
}

BOOL
EnableShim_Win2000(
    char* pszApp,
    char* pszShim)
{
    LONG     status;
    HKEY     hkey;
    char     szAppKey[128];
    char     szShimValueName[128];
    char     szData[256];
    DWORD    cbSize, dwType;
    BOOL     bRet = FALSE;
    
    wsprintf(szAppKey, "%s\\%s",
             "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
             pszApp);
    
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        szAppKey,
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open registry key %s\n", szAppKey);
        return FALSE;
    }
    
    wsprintf(szShimValueName, "-DllPatch-%s", pszShim);
    
    cbSize = 256;
    status = RegQueryValueEx(hkey,
                             szShimValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)szData,
                             &cbSize);
    
    if (status != ERROR_SUCCESS || dwType != REG_SZ || cbSize >= 256) {
        LogMsg("Error reading key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    status = RegDeleteValue(hkey, szShimValueName);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't delete key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    wsprintf(szShimValueName, "DllPatch-%s", pszShim);

    status = RegSetValueEx(hkey,
                           szShimValueName,
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           cbSize);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't set value key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    bRet = TRUE;

Cleanup:    
    RegCloseKey(hkey);
    return bRet;
}

BOOL
DisableShim_Win2000(
    char* pszApp,
    char* pszShim)
{
    LONG     status;
    HKEY     hkey;
    char     szAppKey[128];
    char     szShimValueName[128];
    char     szData[256];
    DWORD    cbSize, dwType;
    BOOL     bRet = FALSE;
    
    wsprintf(szAppKey, "%s\\%s",
             "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
             pszApp);
    
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        szAppKey,
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open registry key %s\n", szAppKey);
        return FALSE;
    }
    
    wsprintf(szShimValueName, "DllPatch-%s", pszShim);
    
    cbSize = 256;
    status = RegQueryValueEx(hkey,
                             szShimValueName,
                             NULL,
                             &dwType,
                             (LPBYTE)szData,
                             &cbSize);
    
    if (status != ERROR_SUCCESS || dwType != REG_SZ || cbSize >= 256) {
        LogMsg("Error reading key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    status = RegDeleteValue(hkey, szShimValueName);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't delete key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    wsprintf(szShimValueName, "-DllPatch-%s", pszShim);

    status = RegSetValueEx(hkey,
                           szShimValueName,
                           0,
                           REG_SZ,
                           (LPBYTE)szData,
                           cbSize);
    
    if (status != ERROR_SUCCESS) {
        LogMsg("Couldn't set value key %s\n", szShimValueName);
        goto Cleanup;
    }
    
    bRet = TRUE;

Cleanup:    
    RegCloseKey(hkey);
    return bRet;
}

BOOL
DeleteShim_Win2000(
    char* pszApp,
    char* pszShim)
{
    LONG     status;
    HKEY     hkey;
    char     szAppKey[128];
    char     szShimValueName[128];
    
    wsprintf(szAppKey, "%s\\%s",
             "System\\CurrentControlSet\\Control\\Session Manager\\AppCompatibility",
             pszApp);
    
    status = RegOpenKey(HKEY_LOCAL_MACHINE,
                        szAppKey,
                        &hkey);

    if (status != ERROR_SUCCESS) {
        LogMsg("Failed to open registry key %s\n", szAppKey);
        return FALSE;
    }
    
    wsprintf(szShimValueName, "DllPatch-%s", pszShim);
    status = RegDeleteValue(hkey, szShimValueName);
    
    wsprintf(szShimValueName, "-DllPatch-%s", pszShim);
    status = RegDeleteValue(hkey, szShimValueName);
    
    RegCloseKey(hkey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acfileattr\acfileattr.h ===
#ifndef _ACFILEATTR_H
#define _ACFILEATTR_H

#include "windows.h"

//
// These are the attribute IDs for all the attributes
//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,

    // add new versions here

    VTID_LASTID
};

#ifdef __cplusplus
extern "C"
{
#endif

HANDLE
ReadFileAttributes(
    LPCSTR pszFile,
    int*   pnCount);

VOID
CleanupFileManager(
    HANDLE hFileMgr);

int
GetAttrIndex(
    DWORD Id);

DWORD
GetAttrId(
    int nAttrInd);

BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd);

PSTR
GetAttrName(
    int nAttrInd);

PSTR
GetAttrNameXML(
    int nAttrInd);

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd);

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect);

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd);

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob);

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff);

#ifdef __cplusplus
}
#endif


LPVOID Alloc(SIZE_T cbSize);
BOOL   Free(LPVOID p);

#endif // _ACFILEATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acbrowserwin2k\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BrowseAppCompat.rc
//
#define IDD_DIALOG1                     101
#define IDD_DIALOG                      101
#define IDC_LIST                        1000
#define IDC_ENABLE                      1002
#define IDC_DELETE                      1003
#define IDC_APPLY                       1004
#define IDC_EDIT1                       1005
#define IDC_ATTR_USED                   1005
#define IDC_ONLY_SHIMS                  1006
#define IDC_DISPLAY_ALL                 1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acfileattr\attr.c ===
#include "acFileAttr.h"
#include "attr.h"
#include "version.h"

#include <assert.h>
#include <imagehlp.h>
#include <stdio.h>

// the global array with all the file attributes

FILEATTR g_arrFileAttr[] =
{
    {VTID_FILESIZE,         "File Size",                    "SIZE",                     QueryFileSize,         BlobToStringLong,       DumpDWORD},
    {VTID_EXETYPE,          "Module Type",                  "MODULETYPE*",              QueryModuleType,       BlobToStringDWORD,      DumpDWORD},
    {VTID_BINFILEVER,       "Binary File Version",          "BIN_FILE_VERSION",         QueryBinFileVer,       BlobToStringBinVer,     DumpBinVer},
    {VTID_BINPRODUCTVER,    "Binary Product Version",       "BIN_PRODUCT_VERSION",      QueryBinProductVer,    BlobToStringBinVer,     DumpBinVer},
    {VTID_FILEDATEHI,       "File Date (HI)",               "VERFILEDATEHI",            QueryFileDateHi,       BlobToStringDWORD,      DumpDWORD},
    {VTID_FILEDATELO,       "File Date (LO)",               "VERFILEDATELO",            QueryFileDateLo,       BlobToStringDWORD,      DumpDWORD},
    {VTID_FILEVEROS,        "File OS Version",              "VERFILEOS",                QueryFileVerOs,        BlobToStringDWORD,      DumpDWORD},
    {VTID_FILEVERTYPE,      "File Type",                    "VERFILETYPE",              QueryFileVerType,      BlobToStringDWORD,      DumpDWORD},
    {VTID_CHECKSUM,         "File CheckSum",                "CHECKSUM",                 QueryFileCheckSum,     BlobToStringDWORD,      DumpDWORD},
    {VTID_PECHECKSUM,       "File Header CheckSum",         "PECHECKSUM",               QueryFilePECheckSum,   BlobToStringDWORD,      DumpDWORD},
    {VTID_COMPANYNAME,      "Company Name",                 "COMPANY_NAME",             QueryCompanyName,      BlobToStringString,     DumpString},
    {VTID_PRODUCTVERSION,   "Product Version",              "PRODUCT_VERSION",          QueryProductVersion,   BlobToStringString,     DumpString},
    {VTID_PRODUCTNAME,      "Product Name",                 "PRODUCT_NAME",             QueryProductName,      BlobToStringString,     DumpString},
    {VTID_FILEDESCRIPTION,  "File Description",             "FILE_DESCRIPTION",         QueryFileDescription,  BlobToStringString,     DumpString},
    {VTID_FILEVERSION,      "File Version",                 "FILEVERSION",              QueryFileVersion,      BlobToStringString,     DumpString},
    {VTID_ORIGINALFILENAME, "Original File Name",           "ORIGINALFILENAME",         QueryOriginalFileName, BlobToStringString,     DumpString},
    {VTID_INTERNALNAME,     "Internal Name",                "INTERNALNAME",             QueryInternalName,     BlobToStringString,     DumpString},
    {VTID_LEGALCOPYRIGHT,   "Legal Copyright",              "LEGALCOPYRIGHT",           QueryLegalCopyright,   BlobToStringString,     DumpString},
    {VTID_16BITDESCRIPTION, "16 Bit Description",           "S16BITDESCRIPTION",        Query16BitDescription, BlobToStringString,     DumpString},
    {VTID_UPTOBINPRODUCTVER,"Up To Binary Product Version", "UPTO_BIN_PRODUCT_VERSION", QueryBinProductVer,    BlobToStringUpToBinVer, DumpUpToBinVer}
};

#define FAIL_IF_NO_VERSION()                                            \
{                                                                       \
    if (pMgr->ver.FixedInfoSize < sizeof(VS_FIXEDFILEINFO)) {           \
        LogMsg("No version info\n");                                    \
        return FALSE;                                                   \
    }                                                                   \
}

#define ALLOC_VALUE_AND_RETURN()                                        \
{                                                                       \
    pFileAttr->pszValue = (PSTR)Alloc(lstrlen(szBuffer) + 1);           \
                                                                        \
    if (pFileAttr->pszValue == NULL) {                                  \
        LogMsg("QueryAttr: memory allocation error\n");                 \
        return FALSE;                                                   \
    }                                                                   \
                                                                        \
    lstrcpy(pFileAttr->pszValue, szBuffer);                             \
                                                                        \
    pFileAttr->dwFlags = ATTR_FLAG_AVAILABLE;                           \
                                                                        \
    return TRUE;                                                        \
}

#define QUERYENTRY(szEntryName)                                         \
{                                                                       \
    pFileAttr->pszValue = QueryVersionEntry(&pMgr->ver, szEntryName);   \
                                                                        \
    if (pFileAttr->pszValue == NULL) {                                  \
        LogMsg("QueryEntry: attribute %s N/A\n", szEntryName);          \
        return FALSE;                                                   \
    }                                                                   \
    pFileAttr->dwFlags = ATTR_FLAG_AVAILABLE;                           \
                                                                        \
    return TRUE;                                                        \
}

#if DBG

void LogMsgDbg(
    LPSTR pszFmt, ... )
{
    CHAR gszT[1024];
    va_list arglist;

    va_start(arglist, pszFmt);
    _vsnprintf(gszT, 1023, pszFmt, arglist);
    gszT[1023] = 0;
    va_end(arglist);
    
    OutputDebugString(gszT);
}

#endif // DBG


// dump to blob functions

int
DumpDWORD(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = sizeof(DWORD);

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = pFileAttr->dwValue;
    return (3 * sizeof(DWORD));
}

int
DumpString(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    int   strLen, nWideChars;
    WCHAR wszOut[256];

    strLen = lstrlen(pFileAttr->pszValue);
    
    nWideChars = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pFileAttr->pszValue,
                    strLen,
                    wszOut,
                    256);
                
    wszOut[nWideChars] = 0;

    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = (nWideChars + 1) * sizeof(WCHAR);

    pBlob += sizeof(DWORD);

    CopyMemory(pBlob, wszOut, (nWideChars + 1) * sizeof(WCHAR));
    
    return (2 * sizeof(DWORD) + (nWideChars + 1) * sizeof(WCHAR));
}

int
DumpBinVer(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = 8 * sizeof(WORD);

    pBlob += sizeof(DWORD);

    CopyMemory(pBlob, pFileAttr->wValue, 4 * sizeof(WORD));

    pBlob += (4 * sizeof(WORD));

    CopyMemory(pBlob, pFileAttr->wMask, 4 * sizeof(WORD));
    
    return (8 * sizeof(WORD) + 2 * sizeof(DWORD));
}

int
DumpUpToBinVer(
    DWORD          dwId,
    PFILEATTRVALUE pFileAttr,
    BYTE*          pBlob)
{
    *(DWORD*)pBlob = dwId;

    pBlob += sizeof(DWORD);

    *(DWORD*)pBlob = 4 * sizeof(WORD);

    pBlob += sizeof(DWORD);

    CopyMemory(pBlob, pFileAttr->wValue, 4 * sizeof(WORD));

    return (4 * sizeof(WORD) + 2 * sizeof(DWORD));
}


// blob to string functions

int
BlobToStringBinVer(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != 8 * sizeof(WORD)) {
        LogMsg("BlobToStringBinVer: invalid blob\n");
        return -1;
    }

    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "Ver %d.%d.%d.%d Mask %04X.%04X.%04X.%04X\r\n",
             *((WORD*)pBlob + 3),
             *((WORD*)pBlob + 2),
             *((WORD*)pBlob + 1),
             *((WORD*)pBlob + 0),
             *((WORD*)pBlob + 7),
             *((WORD*)pBlob + 6),
             *((WORD*)pBlob + 5),
             *((WORD*)pBlob + 4));

    return sizeof(DWORD) + 8 * sizeof(WORD);
}

int
BlobToStringUpToBinVer(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != 4 * sizeof(WORD)) {
        LogMsg("BlobToStringUpToBinVer: invalid blob\n");
        return -1;
    }

    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "Ver %d.%d.%d.%d\r\n",
             *((WORD*)pBlob + 3),
             *((WORD*)pBlob + 2),
             *((WORD*)pBlob + 1),
             *((WORD*)pBlob + 0));

    return sizeof(DWORD) + 4 * sizeof(WORD);
}

int
BlobToStringDWORD(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != sizeof(DWORD)) {
        LogMsg("BlobToStringDWORD: invalid blob\n");
        return -1;
    }
    
    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "0x%X\r\n", *(DWORD*)pBlob);
    
    return 2 * sizeof(DWORD);
}

int
BlobToStringLong(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    if (dwSize != sizeof(DWORD)) {
        LogMsg("BlobToStringLong: invalid blob\n");
        return -1;
    }
    
    pBlob += sizeof(DWORD);
        
    wsprintf(pszOut, "%d\r\n", *(ULONG*)pBlob);
    
    return 2 * sizeof(DWORD);
}

int
BlobToStringString(
    BYTE* pBlob,
    char* pszOut)
{
    DWORD dwSize;
    
    // read the size first
    dwSize = *(DWORD*)pBlob;

    pBlob += sizeof(DWORD);

    WideCharToMultiByte(
                CP_ACP,
                0,
                (LPCWSTR)pBlob,
                (int)dwSize,
                pszOut,
                (int)dwSize,
                NULL,
                NULL);
    
    lstrcat(pszOut, "\r\n");
    
    return sizeof(DWORD) + (int)dwSize;
}


// query functions

BOOL
QueryFileSize(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char            szBuffer[64];
    HANDLE          findHandle;
    WIN32_FIND_DATA findData;

    findHandle = FindFirstFile(pMgr->ver.pszFile, &findData);
    
    if (findHandle == INVALID_HANDLE_VALUE) {
        LogMsg("QueryFileSize: file not found\n");
        return FALSE;
    }
    
    pFileAttr->dwValue = findData.nFileSizeLow;
    
    FindClose(findHandle);

    wsprintf(szBuffer, "%d", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryModuleType(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    // not implemented
    
    return FALSE;
}

BOOL
QueryBinFileVer(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    ULONGLONG binFileVer;
    char      szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    *((PDWORD)(&binFileVer)) = pMgr->ver.FixedInfo->dwFileVersionLS;
    *(((PDWORD)(&binFileVer)) + 1) = pMgr->ver.FixedInfo->dwFileVersionMS;

    CopyMemory(pFileAttr->wValue, &binFileVer, 4 * sizeof(WORD));
    
    wsprintf(szBuffer, "%d.%d.%d.%d",
             pFileAttr->wValue[3],
             pFileAttr->wValue[2],
             pFileAttr->wValue[1],
             pFileAttr->wValue[0]);
    
    pFileAttr->wMask[0] = pFileAttr->wMask[1] = pFileAttr->wMask[2] = pFileAttr->wMask[3] = 0xFFFF;
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryBinProductVer(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    ULONGLONG binProdVer;
    char      szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    *((PDWORD)(&binProdVer)) = pMgr->ver.FixedInfo->dwProductVersionLS;
    *(((PDWORD)(&binProdVer)) + 1) = pMgr->ver.FixedInfo->dwProductVersionMS;

    CopyMemory(pFileAttr->wValue, &binProdVer, 4 * sizeof(WORD));
    
    wsprintf(szBuffer, "%d.%d.%d.%d",
             pFileAttr->wValue[3],
             pFileAttr->wValue[2],
             pFileAttr->wValue[1],
             pFileAttr->wValue[0]);
    
    pFileAttr->wMask[0] = pFileAttr->wMask[1] = pFileAttr->wMask[2] = pFileAttr->wMask[3] = 0xFFFF;
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryFileDateHi(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileDateMS;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryFileDateLo(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileDateLS;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryFileVerOs(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileOS;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL QueryFileVerType(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    FAIL_IF_NO_VERSION();
    
    pFileAttr->dwValue = pMgr->ver.FixedInfo->dwFileType;

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

// ComputeFileCheckSum
//
//   computes the check sum for 4096 bytes starting at offset 512.
//   The offset and the size of the chunk are modified if the
//   file size is too small.
DWORD
ComputeFileCheckSum(
    PSTR             pszFile,
    WIN32_FIND_DATA* pFindData)
{
    INT    i,size     = 4096;
    DWORD  startAddr  = 512;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PCHAR  buffer     = NULL;
    DWORD  checkSum   = 0;
    DWORD  dontCare;

    if (pFindData->nFileSizeLow < (ULONG)size) {
        //
        // File size is less than 4096. We set the start address to 0 and set the size for the checksum
        // to the actual file size.
        //
        startAddr = 0;
        size = pFindData->nFileSizeLow;
    
    } else if (startAddr + size > pFindData->nFileSizeLow) {
        //
        // File size is too small. We set the start address so that size of checksum can be 4096 bytes
        //
        startAddr = pFindData->nFileSizeLow - size;
    }
    
    if (size <= 3) {
        //
        // we need at least 3 bytes to be able to do something here.
        //
        return 0;
    }
    
    __try {
        buffer = (PCHAR)HeapAlloc(GetProcessHeap(), 0, size);
        
        if (buffer == NULL) {
            __leave;
        }
        
        fileHandle = CreateFile(pszFile,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL);
        
        if (fileHandle == INVALID_HANDLE_VALUE) {
            __leave;
        }

        if (SetFilePointer(fileHandle, startAddr, NULL, FILE_BEGIN) != startAddr) {
            __leave;
        }

        if (!ReadFile(fileHandle, buffer, size, &dontCare, NULL)) {
            __leave;
        }
        
        for (i = 0; i<(size - 3); i+=4) {
            checkSum += *((PDWORD) (buffer + i));
            checkSum = _rotr(checkSum ,1);
        }
    }
    __finally {
        if (fileHandle != INVALID_HANDLE_VALUE) {
            CloseHandle (fileHandle);
        }
        if (buffer != NULL) {
            HeapFree(GetProcessHeap(), 0, buffer);
        }
    }
    return checkSum;
}


BOOL QueryFileCheckSum(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    WIN32_FIND_DATA findData;
    HANDLE          findHandle;
    char            szBuffer[64];

    findHandle = FindFirstFile(pMgr->ver.pszFile, &findData);
    
    if (findHandle == INVALID_HANDLE_VALUE) {

        LogMsg("QueryFileCheckSum: Cannot find file %s\n",
               pMgr->ver.pszFile);
        
        return FALSE;
    }
    
    pFileAttr->dwValue = ComputeFileCheckSum(pMgr->ver.pszFile, &findData);
    
    FindClose(findHandle);

    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

// GetImageNtHeader
//
//   This function returns the address of the NT Header.
//   Returns the address of the NT Header.
PIMAGE_NT_HEADERS
GetImageNtHeader(
    IN PVOID Base)
{
    PIMAGE_NT_HEADERS NtHeaders;

    if (Base != NULL && Base != (PVOID)-1) {
        if (((PIMAGE_DOS_HEADER)Base)->e_magic == IMAGE_DOS_SIGNATURE) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PCHAR)Base + ((PIMAGE_DOS_HEADER)Base)->e_lfanew);
            if (NtHeaders->Signature == IMAGE_NT_SIGNATURE) {
                return NtHeaders;
            }
        }
    }
    
    return NULL;
}

BOOL
GetHeaderCheckSum(
    PFILEATTRMGR pMgr,
    DWORD* pdwCheckSum)
{
    HANDLE              fileHandle;
    DWORD               bytesRead;
    IMAGE_DOS_HEADER    dh;
    LOADED_IMAGE        image;
    DWORD               sign;
    PWORD               signNE = (PWORD)&sign;
    BOOL                result = FALSE;

    *pdwCheckSum = 0;

    fileHandle = CreateFile(pMgr->ver.pszFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL);
    
    if (fileHandle == INVALID_HANDLE_VALUE) {
        return FALSE;
    }
    
    __try {
        __try {
            if (!ReadFile(fileHandle, &dh, sizeof(IMAGE_DOS_HEADER), &bytesRead, NULL) ||
                bytesRead != sizeof (IMAGE_DOS_HEADER)) {
                __leave;
            }
            
            if (dh.e_magic != IMAGE_DOS_SIGNATURE) {
                __leave;
            }
            
            if (SetFilePointer(fileHandle, dh.e_lfanew, NULL, FILE_BEGIN) != (DWORD)dh.e_lfanew) {
                __leave;
            }
            
            if (!ReadFile(fileHandle, &sign, sizeof(DWORD), &bytesRead, NULL) ||
                bytesRead != sizeof (DWORD)) {
                __leave;
            }
            
            CloseHandle(fileHandle);
            fileHandle = INVALID_HANDLE_VALUE;

            if (sign == IMAGE_NT_SIGNATURE) {

                if (MapAndLoad(pMgr->ver.pszFile, NULL, &image, FALSE, TRUE)) {
                    
                    PIMAGE_NT_HEADERS NtHeaders;
                    
                    __try {

                        NtHeaders = GetImageNtHeader(image.MappedAddress);
                        
                        if (NtHeaders != NULL) {
                            if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) {
                                *pdwCheckSum = ((PIMAGE_NT_HEADERS32)NtHeaders)->OptionalHeader.CheckSum;
                            } else if (NtHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC) {
                                *pdwCheckSum = ((PIMAGE_NT_HEADERS64)NtHeaders)->OptionalHeader.CheckSum;
                            }
                            result = TRUE;
                        }
                    }
                    __except (1) {
                        LogMsg("Access violation while examining %s\n", pMgr->ver.pszFile);
                    }

                    UnMapAndLoad(&image);
                }
                
            }
        }
        __finally {
            if (fileHandle != INVALID_HANDLE_VALUE) {
                CloseHandle(fileHandle);
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        CloseHandle(fileHandle);
        result = FALSE;
    }
    
    return result;
}

BOOL
QueryFilePECheckSum(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    char szBuffer[64];

    if (!GetHeaderCheckSum(pMgr, &pFileAttr->dwValue) || pFileAttr->dwValue == 0) {
        LogMsg("QueryFilePECheckSum: Cannot get the header check sum for %s\n",
               pMgr->ver.pszFile);
        
        return FALSE;
    }
    
    wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);
    
    ALLOC_VALUE_AND_RETURN();
}

BOOL
QueryCompanyName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("COMPANYNAME");
}

BOOL
QueryProductVersion(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("PRODUCTVERSION");
}

BOOL
QueryProductName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("PRODUCTNAME");
}

BOOL
QueryFileDescription(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("FILEDESCRIPTION");
}

BOOL
QueryFileVersion(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("FILEVERSION");
}

BOOL
QueryOriginalFileName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("ORIGINALFILENAME");
}

BOOL
QueryInternalName(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("INTERNALNAME");
}

BOOL
QueryLegalCopyright(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    FAIL_IF_NO_VERSION();
    QUERYENTRY("LEGALCOPYRIGHT");
}

BOOL
Query16BitDescription(
    PFILEATTRMGR   pMgr, 
    PFILEATTRVALUE pFileAttr)
{
    //char szBuffer[64];
    
    pFileAttr->dwValue = 0;
    //wsprintf(szBuffer, "0x%X", pFileAttr->dwValue);

    return FALSE;
    
    //ALLOC_VALUE_AND_RETURN();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acfileattr\acfileattr.c ===
#include "acFileAttr.h"
#include "attr.h"
#include "version.h"

#include <assert.h>

extern FILEATTR g_arrFileAttr[];

LPVOID
Alloc(
    SIZE_T cbSize)
{
    return HeapAlloc(GetProcessHeap(), 0, cbSize);
}

BOOL
Free(
    LPVOID p)
{
    return HeapFree(GetProcessHeap(), 0, p);
}



BOOL APIENTRY
DllMain(
    HANDLE hModule, 
    DWORD  ul_reason, 
    LPVOID lpReserved)
{
    return TRUE;
}

VOID
CleanupFileManager(
    PFILEATTRMGR pMgr)
{
    int i;

    for (i = 0; i < VTID_LASTID - 2; i++) {
        Free(pMgr->arrAttr[i].pszValue);
        
        pMgr->arrAttr[i].pszValue = NULL;
        
        pMgr->arrAttr[i].dwFlags = 0;
        pMgr->arrAttr[i].dwValue = 0;
    }
    DeleteVersionStruct(&pMgr->ver);

    Free(pMgr);
}

HANDLE
ReadFileAttributes(
    LPCSTR pszFile,
    int*   pnCount
    )
{
    int i;
    
    PFILEATTRMGR pMgr = (PFILEATTRMGR)Alloc(sizeof(FILEATTRMGR));

    if (pMgr == NULL) {
        LogMsg("ReadFileAttributes: Failed to allocate %d bytes\n",
               sizeof(FILEATTRMGR));
        *pnCount = 0;
        return NULL;
    }

    ZeroMemory(pMgr, sizeof(FILEATTRMGR));
    
    pMgr->ver.pszFile = (PSTR)pszFile;
    
    // initialize the version information

    InitVersionStruct(&pMgr->ver);

    // query the values for each attribute

    for (i = 0; i < VTID_LASTID - 2; i++) {
        g_arrFileAttr[i].QueryValue(pMgr, pMgr->arrAttr + i);
    }

    // Post processing
    
    if (pMgr->arrAttr[VTID_FILEDATEHI - VTID_REQFILE - 1].dwValue == 0 &&
        pMgr->arrAttr[VTID_FILEDATELO - VTID_REQFILE - 1].dwValue == 0) {

        pMgr->arrAttr[VTID_FILEDATEHI - VTID_REQFILE - 1].dwFlags = 0;
        pMgr->arrAttr[VTID_FILEDATELO - VTID_REQFILE - 1].dwFlags = 0;
    }

    // mark that the initialization was successful

    pMgr->bInitialized = TRUE;

    *pnCount = i;
    
    return pMgr;
}

int
GetAttrIndex(
    DWORD Id)
{
    int nInd;

    for (nInd = 0; nInd < VTID_LASTID - 2; nInd++) {
        if (g_arrFileAttr[nInd].dwId == Id) {
            return nInd;
        }
    }
    return -1;
}

DWORD
GetAttrId(
    int nAttrInd)
{
    return g_arrFileAttr[nAttrInd].dwId;
}


BOOL
IsAttrAvailable(
    HANDLE hFileMgr,
    int    nAttrInd)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return (pMgr->arrAttr[nAttrInd].dwFlags & ATTR_FLAG_AVAILABLE);
}

PSTR
GetAttrName(
    int nAttrInd)
{
    return g_arrFileAttr[nAttrInd].pszDisplayName;
}

PSTR
GetAttrNameXML(
    int nAttrInd)
{
    return g_arrFileAttr[nAttrInd].pszNameXML;
}

PSTR
GetAttrValue(
    HANDLE hFileMgr,
    int    nAttrInd)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return pMgr->arrAttr[nAttrInd].pszValue;
}

BOOL
SelectAttr(
    HANDLE hFileMgr,
    int    nAttrInd,
    BOOL   bSelect)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    if (!(pMgr->arrAttr[nAttrInd].dwFlags & ATTR_FLAG_AVAILABLE)) {
        LogMsg("Attribute %s not available. Cannot be selected\n",
               g_arrFileAttr[nAttrInd].pszDisplayName);
        return FALSE;
    }
    
    if (bSelect) {
        pMgr->arrAttr[nAttrInd].dwFlags |= ATTR_FLAG_SELECTED;
    } else {
        pMgr->arrAttr[nAttrInd].dwFlags &= ~ATTR_FLAG_SELECTED;
    }
    
    return TRUE;
}

BOOL
IsAttrSelected(
    HANDLE hFileMgr,
    int    nAttrInd)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return (pMgr->arrAttr[nAttrInd].dwFlags & ATTR_FLAG_SELECTED);
}

int
Dump(
    HANDLE hFileMgr,
    int    nAttrInd,
    BYTE*  pBlob)
{
    PFILEATTRMGR pMgr = (PFILEATTRMGR)hFileMgr;

    return g_arrFileAttr[nAttrInd].DumpToBlob(nAttrInd + VTID_REQFILE + 1,
                                              pMgr->arrAttr + nAttrInd,
                                              pBlob);
}

BOOL
BlobToString(
    BYTE* pBlob,
    DWORD cbSize,
    char* pszBuff)
{
    
    DWORD attrId;
    DWORD cbRet;

    pszBuff += lstrlen(pszBuff);
    
    attrId = *(DWORD*)pBlob;
    
    while (attrId) {

        if (attrId >= VTID_LASTID) {
            LogMsg("Unsupported attribute %d\n", attrId);
            return FALSE;
        }

        if (attrId == VTID_REQFILE) {

            pBlob += sizeof(DWORD);
            
            cbRet = *(DWORD*)pBlob;
            
            if (!cbRet) {
                // should never happen
                cbRet = 1;
            }
            pBlob += sizeof(DWORD);

            wsprintf(pszBuff, "\r\nAttributes for %ws:\r\n", pBlob);
            pszBuff += lstrlen(pszBuff);
            
            pBlob += cbRet;

        } else {

            wsprintf(pszBuff, "  %-22s   ", g_arrFileAttr[attrId - VTID_REQFILE - 1].pszDisplayName);
            pszBuff += lstrlen(pszBuff);
            
            pBlob += sizeof(DWORD);
        
            cbRet = g_arrFileAttr[attrId - VTID_REQFILE - 1].BlobToString(pBlob, pszBuff);

            pszBuff += lstrlen(pszBuff);
            pBlob += cbRet;
        }
        attrId = *(DWORD*)pBlob;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acfileattr\version.h ===
#ifndef _VERSION_H
#define _VERSION_H

#include "windows.h"
#include "attr.h"

PSTR
QueryVersionEntry(
    IN OUT PVERSION_STRUCT pVer,
    IN     PSTR            pszField);

BOOL
InitVersionStruct(
    IN OUT PVERSION_STRUCT pVer);

VOID
DeleteVersionStruct(
    IN PVERSION_STRUCT pVer);


#endif // _VERSION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\capphelpwizard.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    CAppHelpWizard.cpp

Abstract:

    Code for the AppHelp Wizard
    
Author:

    kinshu created  July 2, 2001
    
Notes:
    
    The name of the AppHelp message in the library section is made same as the
    HTMLHelp id for that apphelp message as in the entry
    
    Apphelp messages are not shared and each apphelped entry has an exclusive apphelp
    message in the library
    
    E.g of XML for soft blocked AppHelped entry:
    
    
    <?xml version="1.0" encoding="UTF-16"?>
    <DATABASE NAME="New Database(1)" ID="{780BE9F6-B750-404B-9BF1-ECA7B407B592}">
    	<LIBRARY>
    		<MESSAGE NAME="1">
    			<SUMMARY>
    				Hello World!!!!
    			</SUMMARY>
    		</MESSAGE>
    	</LIBRARY>
    	<APP NAME="New Application" VENDOR="Vendor Name">
    		<EXE NAME="w.exe" ID="{31490b6d-6202-4bbf-9b92-2edf209b3ccc}" BIN_FILE_VERSION="5.1.2467.0" BIN_PRODUCT_VERSION="5.1.2467.0" PRODUCT_VERSION="5.1.2467.0" FILE_VERSION="5.1.2467.0 (lab06_N.010419-2241)">
    			<APPHELP MESSAGE="1" BLOCK="NO" HTMLHELPID="1" DETAILS_URL="www.microsoft.com"/>
    		</EXE>
    	</APP>
    </DATABASE>
    
    Part of the .sdb created for the above XML:
    
    0x00000134 | 0x7007 | EXE            | LIST | Size 0x0000006C
    0x0000013A | 0x6001 | NAME           | STRINGREF | w.exe
    0x00000140 | 0x6006 | APP_NAME       | STRINGREF | New Application
    0x00000146 | 0x6005 | VENDOR         | STRINGREF | Vendor Name
    0x0000014C | 0x9004 | EXE_ID(GUID)   | BINARY | Size 0x00000010 | {31490b6d-6202-4bbf-9b92-2edf209b3ccc}
    0x00000162 | 0x700D | APPHELP        | LIST | Size 0x00000012
      0x00000168 | 0x4017 | FLAGS          | DWORD | 0x00000001
      0x0000016E | 0x4010 | PROBLEM_SEVERITY  | DWORD | 0x00000001
      0x00000174 | 0x4015 | HTMLHELPID     | DWORD | 0x00000001
    -end- APPHELP
    0x0000017A | 0x7008 | MATCHING_FILE  | LIST | Size 0x00000026
      0x00000180 | 0x6001 | NAME           | STRINGREF | *
      0x00000186 | 0x6011 | PRODUCT_VERSION  | STRINGREF | 5.1.2467.0
      0x0000018C | 0x5002 | BIN_FILE_VERSION  | QWORD | 0x0005000109A30000
      0x00000196 | 0x5003 | BIN_PRODUCT_VERSION  | QWORD | 0x0005000109A30000
      0x000001A0 | 0x6013 | FILE_VERSION   | STRINGREF | 5.1.2467.0 (lab06_N.010419-2241)
    -end- MATCHING_FILE
  -end- EXE
  0x000001A6 | 0x700D | APPHELP        | LIST | Size 0x0000001E
    0x000001AC | 0x4015 | HTMLHELPID     | DWORD | 0x00000001
    0x000001B2 | 0x700E | LINK           | LIST | Size 0x00000006
      0x000001B8 | 0x6019 | LINK_URL       | STRINGREF | www.microsoft.com
    -end- LINK
    0x000001BE | 0x601B | APPHELP_TITLE  | STRINGREF | New Application
    0x000001C4 | 0x6018 | PROBLEM_DETAILS  | STRINGREF | Hello World!!!!
  -end- APPHELP

    
Revision History:

--*/


#include "precomp.h"

/////////////////////// Defines ///////////////////////////////////////////////

// The first page of the wizard. Gets the app info, app name, vendor name, exe path
#define PAGE_GETAPP_INFO                0               

// The second page of the wizard
#define PAGE_GET_MATCH_FILES            1 

// The third page of the wizard. Gets the type of apphelp-soft or hard bloc
#define PAGE_GETMSG_TYPE                2 

// The last page of the wizard. Gets the message and the URL
#define PAGE_GETMSG_INFORMATION         3 

// Total number of pages in the wizard
#define NUM_PAGES                       4

// The maximum length of a apphelp URL in chars
#define MAX_URL_LENGTH                  1023

// The maximum length of a apphelp message in chars
#define MAX_MESSAGE_LENGTH              1023

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Externs //////////////////////////////////////////////

extern CShimWizard* g_pCurrentWizard;
extern HINSTANCE    g_hInstance;
extern DATABASE     GlobalDataBase;

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Function declarations ////////////////////////////////

BOOL
DeleteAppHelp(
    DWORD nHelpID
    );

///////////////////////////////////////////////////////////////////////////////

BOOL  
CAppHelpWizard::BeginWizard(
    IN  HWND        hParent,
    IN  PDBENTRY    pEntry,
    IN  PDATABASE   pDatabase
    )
/*++
    
    CAppHelpWizard::BeginWizard
        
    Desc:   Starts up the wizard. Initializes the various prop-sheet parameters 
            and calls the wizard
            
    Params:
        IN  HWND        hParent     : Parent for the wizard window
        IN  PDBENTRY    pEntry      : Entry for which AppHelp has to be created or modified
        IN  PDATABASE   pDatabase   : Database in which pEntry resides
           
    Return: 
        TRUE:   The user pressed Finish
        FALSE:  The user pressed Cancel
--*/
{
    m_pDatabase = pDatabase;

    PROPSHEETPAGE Pages[NUM_PAGES];

    if (pEntry == NULL) {
        //
        // Create a new fix.
        //
        ZeroMemory(&m_Entry, sizeof(m_Entry));

        GUID Guid;

        CoCreateGuid(&Guid);

        StringCchPrintf(m_Entry.szGUID,
                        ARRAYSIZE(m_Entry.szGUID),
                        TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                        Guid.Data1,
                        Guid.Data2,
                        Guid.Data3,
                        Guid.Data4[0],
                        Guid.Data4[1],
                        Guid.Data4[2],
                        Guid.Data4[3],
                        Guid.Data4[4],
                        Guid.Data4[5],
                        Guid.Data4[6],
                        Guid.Data4[7]);

        m_bEditing = FALSE;

    } else {
        //
        // Edit the passed fix.
        //
        m_bEditing = TRUE;

        //
        // If we are editing then set m_Entry as *pEntry. The operator is overloaded
        // All throughout the wizard we only work on m_pEntry
        //
        m_Entry = *pEntry;
    }

    //
    // Setup wizard variables
    //
    g_pCurrentWizard = this;
    g_pCurrentWizard->m_uType = TYPE_APPHELPWIZARD;

    //
    // begin the wizard
    //
    PROPSHEETHEADER Header;

    Header.dwSize       = sizeof(PROPSHEETHEADER);
    Header.dwFlags      = PSH_WIZARD97 | PSH_HEADER |  PSH_WATERMARK | PSH_PROPSHEETPAGE; 
    Header.hwndParent   = hParent;
    Header.hInstance    = g_hInstance;
    Header.pszCaption   = MAKEINTRESOURCE(IDS_CUSTOMAPPHELP);
    Header.nStartPage   = 0;
    Header.ppsp         = Pages;
    Header.nPages       = NUM_PAGES;
    Header.pszbmHeader  = MAKEINTRESOURCE(IDB_WIZBMP);

    if (m_bEditing) {
        //
        // If we are editing then, put Finish button on all pages
        //
        Header.dwFlags |= PSH_WIZARDHASFINISH;
    }

    Pages[PAGE_GETAPP_INFO].dwSize                      = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GETAPP_INFO].dwFlags                     = PSP_DEFAULT| PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GETAPP_INFO].hInstance                   = g_hInstance;
    Pages[PAGE_GETAPP_INFO].pszTemplate                 = MAKEINTRESOURCE(IDD_HELPWIZ_APPINFO);
    Pages[PAGE_GETAPP_INFO].pfnDlgProc                  = GetAppInfo;
    Pages[PAGE_GETAPP_INFO].pszHeaderTitle              = MAKEINTRESOURCE(IDS_GIVEAPPINFO);
    Pages[PAGE_GETAPP_INFO].pszHeaderSubTitle           = MAKEINTRESOURCE(IDS_GIVEAPPINFOSUBHEADING);
            
    Pages[PAGE_GET_MATCH_FILES].dwSize                  = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GET_MATCH_FILES].dwFlags                 = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GET_MATCH_FILES].hInstance               = g_hInstance;
    Pages[PAGE_GET_MATCH_FILES].pszTemplate             = MAKEINTRESOURCE(IDD_FIXWIZ_MATCHINGINFO);
    Pages[PAGE_GET_MATCH_FILES].pfnDlgProc              = SelectFiles;
    Pages[PAGE_GET_MATCH_FILES].pszHeaderTitle          = MAKEINTRESOURCE(IDS_MATCHINFO);
    Pages[PAGE_GET_MATCH_FILES].pszHeaderSubTitle       = MAKEINTRESOURCE(IDS_MATCHINFO_SUBHEADING);

    Pages[PAGE_GETMSG_TYPE].dwSize                      = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GETMSG_TYPE].dwFlags                     = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GETMSG_TYPE].hInstance                   = g_hInstance;
    Pages[PAGE_GETMSG_TYPE].pszTemplate                 = MAKEINTRESOURCE(IDD_HELPWIZ_TYPE);
    Pages[PAGE_GETMSG_TYPE].pfnDlgProc                  = GetMessageType;
    Pages[PAGE_GETMSG_TYPE].pszHeaderTitle              = MAKEINTRESOURCE(IDS_MESSAGETYPE);
    Pages[PAGE_GETMSG_TYPE].pszHeaderSubTitle           = MAKEINTRESOURCE(IDS_MESSAGETYPE_SUBHEADING);

    Pages[PAGE_GETMSG_INFORMATION].dwSize               = sizeof(PROPSHEETPAGE);
    Pages[PAGE_GETMSG_INFORMATION].dwFlags              = PSP_DEFAULT|PSP_USEHEADERTITLE|PSP_USEHEADERSUBTITLE;
    Pages[PAGE_GETMSG_INFORMATION].hInstance            = g_hInstance;
    Pages[PAGE_GETMSG_INFORMATION].pszTemplate          = MAKEINTRESOURCE(IDD_HELPWIZ_MESSAGE);
    Pages[PAGE_GETMSG_INFORMATION].pfnDlgProc           = GetMessageInformation;
    Pages[PAGE_GETMSG_INFORMATION].pszHeaderTitle       = MAKEINTRESOURCE(IDS_MESSAGEINFO);
    Pages[PAGE_GETMSG_INFORMATION].pszHeaderSubTitle    = MAKEINTRESOURCE(IDS_MESSAGEINFO_SUBHEADING);

    BOOL bReturn = FALSE;

    if (0 < PropertySheet(&Header)) {
        //
        // Finish Pressed
        //
        bReturn = TRUE;

    } else {
        //
        // Cancel  pressed, we might have to delete the new apphelp in the Database.
        //
        bReturn = FALSE;

        if (nPresentHelpId != -1) {
            //
            // There is some apphelp that has been entered in the database
            //
            if(!g_pCurrentWizard->m_pDatabase) {
                assert(FALSE);
                goto End;
            }

            g_pCurrentWizard->m_Entry.appHelp.bPresent  = FALSE;
            g_pCurrentWizard->m_Entry.appHelp.bBlock    = FALSE;

            DeleteAppHelp(g_pCurrentWizard->m_pDatabase,
                          g_pCurrentWizard->m_pDatabase->m_nMAXHELPID);

            nPresentHelpId = -1;

            //
            // Decrement the maximum help id, so that the next apphelp for this database
            // can use that id
            //
            --(g_pCurrentWizard->m_pDatabase->m_nMAXHELPID);
        }
    }

End:

    ENABLEWINDOW(g_hDlg, TRUE);

    return bReturn;
}


/*++---------------------------------------------------------------------------
    All the wizard page routines
    ---------------------------------------------------------------------------
--*/

INT_PTR
CALLBACK
GetAppInfo(
    IN  HWND   hDlg, 
    IN  UINT   uMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam
    )
/*++

    GetAppInfo
    
    Desc:   Handler for the first page of the wizard.
    
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return
--*/
{

    switch (uMsg) {
    
    case WM_INITDIALOG:
        {
            HWND hParent = GetParent(hDlg);

            CenterWindow(GetParent(hParent), hParent);

            if (g_pCurrentWizard->m_bEditing 
                && g_pCurrentWizard->m_Entry.appHelp.bPresent) {
                //
                // We are editing an existing apphelp
                //
                SetWindowText(hParent, CSTRING(IDS_CUSTOMAPPHELP_EDIT));

            } else if (g_pCurrentWizard->m_bEditing 
                       && !g_pCurrentWizard->m_Entry.appHelp.bPresent) {
                //
                // We are adding a new apphelp to an existing entry, which contains some fix
                //
                SetWindowText(hParent, CSTRING(IDS_CUSTOMAPPHELP_ADD));

            } else {
                //
                // Creating a new apphelp entry
                //
                SetWindowText(hParent, CSTRING(IDS_CUSTOMAPPHELP));
            }

            //
            // Limit the length of the text boxes
            //
            SendMessage(GetDlgItem(hDlg, IDC_APPNAME),
                        EM_LIMITTEXT,
                        (WPARAM)LIMIT_APP_NAME,
                        (LPARAM)0);

            SendMessage(GetDlgItem(hDlg, IDC_VENDOR),
                        EM_LIMITTEXT,
                        (WPARAM)MAX_VENDOR_LENGTH,
                        (LPARAM)0);

            SendMessage(GetDlgItem(hDlg, IDC_EXEPATH),
                        EM_LIMITTEXT,
                        (WPARAM)MAX_PATH - 1,
                        (LPARAM)0);

            if (g_pCurrentWizard->m_bEditing) {
                //
                // If we are editing a fix, make the App. and exe path text fields read only
                //
                SendMessage(GetDlgItem(hDlg, IDC_APPNAME), EM_SETREADONLY, TRUE, 0);
                SendMessage(GetDlgItem(hDlg, IDC_EXEPATH), EM_SETREADONLY, TRUE, 0);

                ENABLEWINDOW(GetDlgItem(hDlg, IDC_BROWSE), FALSE);
            }

            //
            // Set the text for the app name field
            //
            if (g_pCurrentWizard->m_Entry.strAppName.Length() > 0) {
                SetDlgItemText(hDlg, IDC_APPNAME, g_pCurrentWizard->m_Entry.strAppName);
            } else {
                SetDlgItemText(hDlg, IDC_APPNAME, GetString(IDS_DEFAULT_APP_NAME));
                SendMessage(GetDlgItem(hDlg, IDC_APPNAME), EM_SETSEL, 0,-1);
            }

            //
            // Set the text for the vendor name field
            //
            if (g_pCurrentWizard->m_Entry.strVendor.Length() > 0) {

                SetDlgItemText(hDlg, 
                               IDC_VENDOR, 
                               g_pCurrentWizard->m_Entry.strVendor);
            } else {
                SetDlgItemText(hDlg, IDC_VENDOR, GetString(IDS_DEFAULT_VENDOR_NAME));
            }

            //
            // Set the text for the entry name field
            //
            if (g_pCurrentWizard->m_Entry.strExeName.Length() > 0) {

                SetDlgItemText(hDlg, 
                               IDC_EXEPATH, 
                               g_pCurrentWizard->m_Entry.strExeName);
            }
            
            SHAutoComplete(GetDlgItem(hDlg, IDC_EXEPATH), AUTOCOMPLETE);
            
            //
            // Force proper Next button state.
            //
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_APPNAME, EN_CHANGE), 0);
            break;
        }

    case WM_NOTIFY:
        {
            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr == NULL) {
                break;
            }

            switch (pHdr->code) {
            case PSN_SETACTIVE:

                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_EXEPATH, EN_CHANGE), 0);
                break;

            case PSN_WIZFINISH:
            case PSN_WIZNEXT:
                {
                    TCHAR szTemp[MAX_PATH];
                    TCHAR szEXEPath[MAX_PATH];
                    TCHAR szPathTemp[MAX_PATH];

                    *szTemp = *szEXEPath = *szPathTemp = 0;

                    GetDlgItemText(hDlg, IDC_APPNAME, szTemp, ARRAYSIZE(szTemp));
                    CSTRING::Trim(szTemp);

                    if (!IsValidAppName(szTemp)) {
                        //
                        // The app name contains invalid chars
                        //
                        DisplayInvalidAppNameMessage(hDlg);
                
                        SetFocus(GetDlgItem(hDlg, IDC_APPNAME));
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
                        return -1;
                    }

                    g_pCurrentWizard->m_Entry.strAppName = szTemp;

                    GetDlgItemText(hDlg, IDC_EXEPATH, szEXEPath, ARRAYSIZE(szEXEPath));
                    CSTRING::Trim(szEXEPath);

                    *szPathTemp = 0;

                    //
                    // Check if the file exists. We check for this only when we are creating 
                    // a new fix and not when we are editing an existing fix
                    //
                    if (!g_pCurrentWizard->m_bEditing) {

                        HANDLE hFile = CreateFile(szEXEPath,
                                                  0,
                                                  0,
                                                  NULL,
                                                  OPEN_EXISTING,
                                                  FILE_ATTRIBUTE_NORMAL,
                                                  NULL);

                        if (INVALID_HANDLE_VALUE == hFile) {
                            //
                            // File does not exist
                            //
                            MessageBox(hDlg,
                                       CSTRING(IDS_INVALIDEXE),
                                       g_szAppName,
                                       MB_OK | MB_ICONWARNING);

                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
                            return -1;
                        }

                        CloseHandle(hFile);

                        //
                        // Set the full path
                        //
                        g_pCurrentWizard->m_Entry.strFullpath = szEXEPath;
                        g_pCurrentWizard->m_Entry.strFullpath.ConvertToLongFileName();

                        //
                        // Set the default mask for the matching attributes to be used
                        //
                        g_pCurrentWizard->dwMaskOfMainEntry = DEFAULT_MASK;

                        //
                        // Set the entry name that will be written in the xml
                        //
                        SafeCpyN(szPathTemp, (PCTSTR)g_pCurrentWizard->m_Entry.strFullpath, ARRAYSIZE(szPathTemp));
                        PathStripPath(szPathTemp);
                        g_pCurrentWizard->m_Entry.strExeName = szPathTemp;

                    } else if (g_pCurrentWizard->m_Entry.strFullpath.Length() == 0) {
                        //
                        // Since we do not have the complete path, 
                        // this SDB was loaded from the disk
                        //
                        g_pCurrentWizard->m_Entry.strFullpath = szEXEPath;
                    }

                    GetDlgItemText(hDlg, IDC_VENDOR, szTemp, ARRAYSIZE(szTemp));

                    //
                    // Set the vendor information
                    //
                    if (CSTRING::Trim(szTemp)) {
                        g_pCurrentWizard->m_Entry.strVendor = szTemp;
                    } else {
                        g_pCurrentWizard->m_Entry.strVendor = GetString(IDS_DEFAULT_VENDOR_NAME);
                    }

                    break;
                }
            }

            break;
        }

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
        case IDC_EXEPATH:
        case IDC_APPNAME:
            
            //
            // Check if all the fields are filled up properly.
            // We enable disable the Next/Finish button here.
            //
            // The vendor name field is not mandatory
            //
            //
            if (EN_CHANGE == HIWORD(wParam)) {

                TCHAR   szTemp[MAX_PATH];
                DWORD   dwFlags = 0;
                BOOL    bEnable = FALSE;

                *szTemp = 0;

                GetDlgItemText(hDlg, IDC_APPNAME, szTemp, ARRAYSIZE(szTemp));

                bEnable = ValidInput(szTemp);

                GetDlgItemText(hDlg, IDC_EXEPATH, szTemp, ARRAYSIZE(szTemp));
                bEnable &= ValidInput(szTemp);

                if (bEnable) {

                    dwFlags |= PSWIZB_NEXT;

                    if (g_pCurrentWizard->m_bEditing) {
                        dwFlags |= PSWIZB_FINISH;
                    }

                } else {

                    if (g_pCurrentWizard->m_bEditing) {
                        dwFlags |= PSWIZB_DISABLEDFINISH;
                    }
                }

                SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, dwFlags);
            }

            break;

        case IDC_BROWSE:
            {
                CSTRING szFilename;
                TCHAR   szBuffer[64]   = TEXT("");
                HWND    hwndFocus       = GetFocus();

                GetString(IDS_EXEFILTER, szBuffer, ARRAYSIZE(szBuffer));

                if (GetFileName(hDlg,
                                CSTRING(IDS_FINDEXECUTABLE),
                                szBuffer,
                                TEXT(""),
                                CSTRING(IDS_EXE_EXT),
                                OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST,
                                TRUE,
                                szFilename)) {

                    SetDlgItemText(hDlg, IDC_EXEPATH, szFilename);

                    //
                    // Force proper Next button state.
                    //
                    SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_EXEPATH, EN_CHANGE), 0);
                }

                SetFocus(hwndFocus);
                break;
            }
        }
    }

    return FALSE;
}

INT_PTR
CALLBACK
GetMessageType(
    IN  HWND   hDlg, 
    IN  UINT   uMsg, 
    IN  WPARAM wParam, 
    IN  LPARAM lParam
    )
/*++
    
    GetMessageType

    Desc:   Handler for the third wizard page. This routine collects the type 
            of the apphelp message. One of soft block or hard block.
            These are set in @pEntry.apphelp 
            
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return            
--*/
{
    switch (uMsg) {
    case WM_INITDIALOG:

        //
        // Set the type of the app help radio button
        //
        if (g_pCurrentWizard->m_Entry.appHelp.bBlock == FALSE || g_pCurrentWizard->m_Entry.appHelp.bPresent == FALSE) {
            SendMessage(GetDlgItem(hDlg, IDC_NOBLOCK), BM_SETCHECK, 1, 0);
        } else {
            SendMessage(GetDlgItem(hDlg, IDC_BLOCK), BM_SETCHECK, 1, 0);
        }

        return TRUE;
        
    case WM_NOTIFY:
        {
            NMHDR* pHdr = (NMHDR*)lParam;

            if (pHdr == NULL) {
                break;
            }

            switch (pHdr->code) {
            case PSN_WIZFINISH:   
            case PSN_WIZNEXT:
                {
                    int iReturn = SendMessage(GetDlgItem(hDlg, IDC_NOBLOCK),
                                              BM_GETCHECK,
                                              1,
                                              0);

                    if (iReturn == BST_CHECKED) {
                        //
                        // Soft block
                        //
                        g_pCurrentWizard->m_Entry.appHelp.bBlock = FALSE;
                    } else {
                        //
                        // Hard block
                        //
                        g_pCurrentWizard->m_Entry.appHelp.bBlock = TRUE;
                    }

                    //
                    // Set the severity depending upon type of block
                    //
                    if (g_pCurrentWizard->m_Entry.appHelp.bBlock) {
                        g_pCurrentWizard->m_Entry.appHelp.severity = APPTYPE_INC_HARDBLOCK;
                    } else {
                        g_pCurrentWizard->m_Entry.appHelp.severity = APPTYPE_INC_NOBLOCK;
                    }

                    break;
                }

            case PSN_SETACTIVE:
                {   
                    DWORD dwFlags = PSWIZB_NEXT | PSWIZB_BACK;

                    //
                    // Set finish buttton status appropriately if we are editing
                    //
                    if (g_pCurrentWizard->m_bEditing) {
                        
                        if (g_pCurrentWizard->m_Entry.appHelp.bPresent) {
                            dwFlags |= PSWIZB_FINISH;
                        } else {
                            dwFlags |= PSWIZB_DISABLEDFINISH;
                        }
                    }

                    //
                    // Set the buttons
                    //
                    SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, dwFlags);
                    return TRUE;
                }
            }

            break;    
        }
    }

    return FALSE;
}

INT_PTR 
CALLBACK 
GetMessageInformation(
    IN  HWND    hDlg, 
    IN  UINT    uMsg, 
    IN  WPARAM  wParam, 
    IN  LPARAM  lParam
    )
/*++

    GetMessageInformation

    Desc:   Handler for the last wizard page. This routine collects the apphelp message
            and the url for the apphelp. Creates a new apphelp message and puts the 
            apphelp message inside the database.
            
            When we are editing a apphelp, the previous apphelp needs to be removed

                
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return            
--*/
{

    switch (uMsg) {
    case WM_INITDIALOG:
        {
            //
            // Set the maximum length of the text boxes
            //
            SendMessage(GetDlgItem(hDlg, IDC_URL),
                        EM_LIMITTEXT,
                        (WPARAM)MAX_URL_LENGTH,
                        (LPARAM)0);

            SendMessage(GetDlgItem(hDlg, IDC_MSG_SUMMARY),
                        EM_LIMITTEXT,
                        (WPARAM)MAX_MESSAGE_LENGTH,
                        (LPARAM)0);

            if (g_pCurrentWizard->m_bEditing && g_pCurrentWizard->m_Entry.appHelp.bPresent) {

                PAPPHELP pAppHelp= g_pCurrentWizard->m_Entry.appHelp.pAppHelpinLib;

                if (pAppHelp == NULL) {
                    //
                    // This is an error. We should have had a proper value..
                    //
                    assert(FALSE);
                    Dbg(dlError, "[GetMessageInformation] WM_INITDIALOG: pApphelp is NULL");
                    break;
                }

                if (pAppHelp->strURL.Length()) {
                    SetDlgItemText(hDlg, IDC_URL, pAppHelp->strURL);
                }

                SetDlgItemText(hDlg, IDC_MSG_SUMMARY, pAppHelp->strMessage);
            }

            //
            // Force proper Next/Finish button state.
            //
            SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_MSG_SUMMARY, EN_CHANGE), 0);
            break;
        }

    case WM_NOTIFY:
        {
            NMHDR * pHdr = (NMHDR*)lParam;

            switch (pHdr->code) {
            case PSN_SETACTIVE:

                //
                // Force proper Next/Finish button state
                //
                SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDC_MSG_SUMMARY, EN_CHANGE), 0);
                break;

            case PSN_WIZFINISH:

                if (!OnAppHelpFinish(hDlg)) {
                    //
                    // We failed most probably because the message input was not valid
                    //
                    MessageBox(hDlg, GetString(IDS_INVALID_APPHELP_MESSAGE), g_szAppName, MB_ICONWARNING);

                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT,-1);
                    return -1;
                }

                return TRUE;   
            }
        }

        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
        case IDC_MSG_SUMMARY:

            if (EN_CHANGE == HIWORD(wParam)) {

                BOOL    bEnable = (GetWindowTextLength(GetDlgItem(hDlg,
                                                                  IDC_MSG_SUMMARY)) > 0) ? TRUE:FALSE;
                DWORD   dwFlags = PSWIZB_BACK;

                if (bEnable) {
                    dwFlags |= PSWIZB_FINISH;
                } else {

                    if (g_pCurrentWizard->m_bEditing) {
                        dwFlags |= PSWIZB_DISABLEDFINISH;
                    }
                }

                ENABLEWINDOW(GetDlgItem(hDlg, IDC_TESTRUN), bEnable);

                SendMessage(GetParent(hDlg), PSM_SETWIZBUTTONS, 0, dwFlags);
            }

            break;

        case IDC_TESTRUN:
            {
                
                if (g_bAdmin == FALSE) {
    
                    //
                    // Test run will need to call sdbinst.exe which will not run if we are
                    // not an admin
                    //
                    MessageBox(hDlg, 
                               GetString(IDS_ERRORNOTADMIN), 
                               g_szAppName, 
                               MB_ICONINFORMATION);
                    break;
                
                }
                
                //
                // Save the apphelp of the entry so that we can revert back after test run.
                // After test run, the database and the entry should be in the same state as
                // it was before test run. Any apphelp message added to the database should be 
                // removed and any apphelp properties that were changed for the entry should be 
                // reverted
                //
                APPHELP AppHelpPrev = g_pCurrentWizard->m_Entry.appHelp;

                //
                // Add apphelp info to the library and set the fields of the entry
                //
                if (!OnAppHelpTestRun(hDlg)) {
                    //
                    // We failed most probably because the message input was not valid
                    //
                    MessageBox(hDlg, GetString(IDS_INVALID_APPHELP_MESSAGE), g_szAppName, MB_ICONWARNING);
                    break;
                }

                TestRun(&g_pCurrentWizard->m_Entry,
                        &g_pCurrentWizard->m_Entry.strFullpath,
                        NULL,
                        hDlg);

                //
                // <HACK>This is a hack!!!. TestRun launches a process using CreateProcess
                // and then the modal wizard starts behaving like a modeless wizard
                //
                ENABLEWINDOW(g_hDlg, FALSE);

                //
                // We have to delete the apphelp message that has been added to the library.
                //
                if (((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId != -1) {

                    if (g_pCurrentWizard->m_pDatabase == NULL) {
                        assert(FALSE);
                        break;
                    }
                    
                    DeleteAppHelp(g_pCurrentWizard->m_pDatabase, 
                                  g_pCurrentWizard->m_pDatabase->m_nMAXHELPID);

                    g_pCurrentWizard->m_Entry.appHelp.bPresent  = FALSE;
                    g_pCurrentWizard->m_Entry.appHelp.bBlock    = FALSE;
                    --(g_pCurrentWizard->m_pDatabase->m_nMAXHELPID);

                    ((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId = -1;
                }

                //
                // Revert the apphelp properties. This is necessary for edit mode as 
                // OnAppHelpTestRun will make changes to g_pCurrentWizard->m_Entry.appHelp.
                //
                g_pCurrentWizard->m_Entry.appHelp = AppHelpPrev;

                SetActiveWindow(hDlg);
                SetFocus(hDlg);
            }   

            break;
        }
    }
    
    return FALSE;
}

BOOL
DeleteAppHelp(
    IN  PDATABASE   pDatabase,
    IN  DWORD       nHelpID
    )
/*++

    DeleteAppHelp
    
    Desc:   Deletes the AppHelp message with ID of nHelpID from database pDatabase
    
    Params:
        IN  PDATABASE   pDatabase   : The database in which the apphelp message lives
        IN  DWORD       nHelpID     : ID of the apphelp message that has to be deleted
    Return:
        TRUE:   The apphelp message was deleted
        FALSE:  Otherwise
--*/
{
    if (pDatabase == NULL) {
        assert(FALSE);
        return FALSE;
    }

    PAPPHELP pAppHelp   = pDatabase->pAppHelp;
    PAPPHELP pPrev      = NULL;

    while (pAppHelp) {

        if (pAppHelp->HTMLHELPID == nHelpID) {

            if (pPrev == NULL) {
                pDatabase->pAppHelp = pDatabase->pAppHelp->pNext;
            } else {
                pPrev->pNext = pAppHelp->pNext;
            }

            delete pAppHelp;
            return TRUE;

        } else {
            pPrev       = pAppHelp;
            pAppHelp    = pAppHelp->pNext;
        }
    }

    return FALSE;
}

BOOL
OnAppHelpTestRun(
    IN  HWND    hDlg
    )
/*++
    
    OnAppHelpTestRun

    Desc:   Handles the test run case. Lets OnAppHelpFinish handle it.
            This routine is invoked when the user presses Test Run
    
    Params:
        IN  HWND    hDlg: The wizard page containing the Test-Run button
        
--*/
{
    return OnAppHelpFinish(hDlg, TRUE);
}

BOOL
OnAppHelpFinish(
    IN  HWND    hDlg,
    IN  BOOL    bTestRun // (FALSE)
    )
/*++

    OnAppHelpFinish
    
    Desc:   Handles the user's pressing Finish button in the wizard
            Also is called by the routine that handles the pressing of Test Run button
            
    Params: 
        IN  HWND   hDlg                 : The wizard page 
        IN  BOOL    bTestRun (FALSE)    : Whether this routine is invoked because of 
            pressing Test-Run or Finish
        
    Return: void
--*/            
{
    K_SIZE  k_szTemp    = MAX_MESSAGE_LENGTH + 1;
    PTSTR   pszTemp     = new TCHAR[k_szTemp];
    BOOL    bOk         = TRUE;

    if (pszTemp == NULL) {
        bOk = FALSE;
        goto End;
    }

    *pszTemp  = 0;
    GetDlgItemText(hDlg, IDC_MSG_SUMMARY, pszTemp, k_szTemp);
    
    if (ValidInput(pszTemp) == FALSE) {
        bOk = FALSE;
        goto End;
    }

    //
    // If we are in editing mode we have to remove the previous AppHelp
    // from the Lib. But NOT if this function is being called because of test run !!
    //
    if (g_pCurrentWizard->m_bEditing && !bTestRun) {

        if (g_pCurrentWizard->m_Entry.appHelp.bPresent) {

            DeleteAppHelp(g_pCurrentWizard->m_pDatabase, 
                          g_pCurrentWizard->m_Entry.appHelp.HTMLHELPID);
        }
    }

    //
    // Create a new apphelp message that we will put in the lib of the database.
    // The entry being apphelped will point to this though its Apphelp.pAppHelpinLib
    //
    PAPPHELP pAppHelp = NULL;

    pAppHelp = new APPHELP;

    if (pAppHelp == NULL) {
        MEM_ERR;
        bOk = FALSE;
        goto End;
    }

    assert(g_pCurrentWizard->m_pDatabase);

    //
    // Give it the next apphelp message id
    //
    pAppHelp->HTMLHELPID = ++(g_pCurrentWizard->m_pDatabase->m_nMAXHELPID);

    pAppHelp->strMessage = pszTemp;
    pAppHelp->strMessage.Trim();

    *pszTemp  = 0;
    GetDlgItemText(hDlg, IDC_URL, pszTemp, k_szTemp);
    pAppHelp->strURL = pszTemp;
    pAppHelp->strURL.Trim();

    //
    // Add the APPHELP message in the Library.
    //
    pAppHelp->pNext = g_pCurrentWizard->m_pDatabase->pAppHelp;
    g_pCurrentWizard->m_pDatabase->pAppHelp = pAppHelp;

    //
    // Indicate that we have added a new apphelp message in the database. If during an 
    // Apphelp wizard invocation, no apphelp message was added in the database
    // then (CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId should be equal 
    // to -1
    //
    ((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId = pAppHelp->HTMLHELPID;

    //
    // Add the AppHelp fields for the entry
    //    
    g_pCurrentWizard->m_Entry.appHelp.bPresent      = TRUE;
    g_pCurrentWizard->m_Entry.appHelp.pAppHelpinLib = pAppHelp;
    g_pCurrentWizard->m_Entry.appHelp.HTMLHELPID    = ((CAppHelpWizard*)g_pCurrentWizard)->nPresentHelpId;

End:
    if (pszTemp) {
        delete[] pszTemp;
        pszTemp = NULL;
    }

    return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acfileattr\version.c ===
#include "version.h"
#include "acFileAttr.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <imagehlp.h>

// InitVersionStruct
//
//   Reads the version information for the specified file
BOOL
InitVersionStruct(
    IN OUT PVERSION_STRUCT pVer)
{
    DWORD dwNull = 0;
    
    //
    // Allocate enough memory for the version stamp
    //

    pVer->dwSize = GetFileVersionInfoSize(pVer->pszFile, &dwNull);
    
    if (pVer->dwSize == 0) {
        LogMsg("File %s does not have version info\n", pVer->pszFile);
        return FALSE;
    }

    pVer->VersionBuffer = (PBYTE)Alloc(pVer->dwSize);
    
    if (pVer->VersionBuffer == NULL) {
        
        LogMsg("InitVersionStruct: failed to allocate %d bytes\n", pVer->dwSize);
        return FALSE;
    }
    
    //
    // Now get the version info from the file
    //

    if (!GetFileVersionInfo(
             pVer->pszFile,
             0,
             pVer->dwSize,
             pVer->VersionBuffer)) {
        
        LogMsg("GetFileVersionInfo failed with 0x%x for file %s\n",
              GetLastError(),
              pVer->pszFile);
        
        DeleteVersionStruct(pVer);
        return FALSE;
    }

    // Extract the fixed info

    VerQueryValue(
        pVer->VersionBuffer,
        "\\",
        (LPVOID*)&pVer->FixedInfo,
        &pVer->FixedInfoSize);

    return TRUE;
}

// DeleteVersionStruct
//
//   Delete all the memory allocated for this version structure
VOID
DeleteVersionStruct(
    IN PVERSION_STRUCT pVer)
{
    if (pVer != NULL && pVer->VersionBuffer != NULL) {
        
        Free(pVer->VersionBuffer);
        pVer->VersionBuffer = NULL;
        
        ZeroMemory(pVer, sizeof(VERSION_STRUCT));
    }
}



static DWORD g_adwLangs[] = {0x000004B0, 0x000004E4, 0x040904B0, 0x040904E4, 0};

#define MAX_VERSION_STRING  256

// QueryVersionEntry
//
//   Queries the file's version structure returning the
//   value for a specific entry
PSTR
QueryVersionEntry(
    IN OUT PVERSION_STRUCT pVer,
    IN     PSTR            pszField)
{
    TCHAR  szTemp[MAX_VERSION_STRING] = "";
    TCHAR* szReturn = NULL;
    int    i;
    UINT   unLen;

    for (i = 0; g_adwLangs[i]; ++i) {

        sprintf(szTemp, "\\StringFileInfo\\%08X\\%s", g_adwLangs[i], pszField);
        
        if (VerQueryValue(pVer->VersionBuffer, szTemp, (PVOID*)&szReturn, &unLen)) {
            char* pszValue;

            pszValue = Alloc(lstrlen(szReturn) + 1);
            
            if (pszValue == NULL) {
                LogMsg("QueryVersionEntry: failed to allocate %d bytes\n",
                       lstrlen(szReturn) + 1);
                return NULL;
            }
            lstrcpy(pszValue, szReturn);
            return pszValue;
        }
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\compatadmin.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    CompatAdmin.h

Abstract:

    Main Header for the application
        
Author:

    kinshu created  July 2, 2001

--*/

#ifndef _COMPATADMIN_H
#define _COMPATADMIN_H

#include <windows.h>
#include <tchar.h>
#include <Shlwapi.h>
#include <Shellapi.h>
#include <commctrl.h>
#include <Commdlg.h>
#include <Sddl.h>
#include <Winbase.h>
#include "resource.h"
#include "HtmlHelp.h"
#include <strsafe.h>

extern "C" {
#include "shimdb.h"
}

//////////////////////// Externs //////////////////////////////////////////////

class  DatabaseTree;

extern TCHAR                    g_szAppName[];
extern HWND                     g_hDlg;
extern DWORD                    ATTRIBUTE_COUNT;
extern BOOL                     g_bUpdateInstalledRequired;
extern HWND                     g_hdlgQueryDB;
extern HWND                     g_hdlgSearchDB;
extern BOOL                     g_bExpert;
extern BOOL                     g_bAdmin;
extern DatabaseTree             DBTree;
extern struct _tagClipBoard     gClipBoard;
extern struct tagDataBaseList   DataBaseList;
extern struct tagDataBaseList   InstalledDataBaseList;

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Defines //////////////////////////////////////////////

// The type of module. Will specify either inclusion or exclusion
#define INCLUDE  1
#define EXCLUDE  0

//
// Indexes for HKEY array on which we are listening for events. The events are used for automatically refreshing
// the list of installed and per-user
#define IND_PERUSER   0
#define IND_ALLUSERS  1

// Number of spaces that a tab corresponds to. This is used when we are formatting the XML
// before writing it to the disk.
#define TAB_SIZE    4

// Make sure  that both LIMIT_APP_NAME and LIMIT_LAYER_NAME have the same value
// Used for limiting the text filed in the UI
#define LIMIT_APP_NAME      128
#define LIMIT_LAYER_NAME    128
#define MAX_VENDOR_LENGTH   100


// Defines for the event types. These are the events which are shown in the event window. Main-menu>View>Events
#define EVENT_ENTRY_COPYOK          0
#define EVENT_SYSTEM_RENAME         1
#define EVENT_CONFLICT_ENTRY        2    
#define EVENT_LAYER_COPYOK          3

// The number of file names that we will show in the MRU list
#define MAX_MRU_COUNT               5

//
// The file name where we are going to save the shim log. 
// This is created in %windir%/AppPatch
#define SHIM_FILE_LOG_NAME  TEXT("CompatAdmin.log")

// Auto-complete flag passed on to SHAutoComplete()
#define AUTOCOMPLETE  SHACF_FILESYSTEM | SHACF_AUTOSUGGEST_FORCE_ON

// Select style passed to TREEVIEW_SHOW
#define TVSELECT_STYLE      TVGN_CARET

// Select and show the tree item
//*******************************************************************************
#define TREEVIEW_SHOW(hwndTree, hItem, flags)                                   \
{                                                                               \
    TreeView_Select(hwndTree, hItem, TVSELECT_STYLE);                           \
    TreeView_EnsureVisible(hwndTree, hItem);                                    \
}
//*******************************************************************************

//
// Add a trailing '\'to a path, if it does not exist
//*******************************************************************************
#define ADD_PATH_SEPARATOR(szStr, nSize)                                        \
{                                                                               \
    INT iLength = lstrlen(szStr);                                               \
    if ((iLength < nSize - 1 && iLength > 0)                                    \
        && szStr[iLength - 1] != TEXT('\\')) {                                  \
        StringCchCat(szStr, nSize, TEXT("\\"));                                  \
    }                                                                           \
}                                             
//*******************************************************************************

// Enable or disable a tool bar button
//*******************************************************************************
#define EnableToolBarButton(hwndTB, id, bEnable)                                \
SendMessage(hwndTB, TB_ENABLEBUTTON, (WPARAM)id, (LPARAM) MAKELONG(bEnable, 0));
//******************************************************************************
                                  
//
// Gets the size of a file when we already have PATTRINFO. This is needed
// when we have to sort the files generated while using "Auto-Generate" matching
// files option in the fix or app help wizard. We sort the files are use only the
// first MAX_AUTO_MATCH files
//*******************************************************************************
#define GET_SIZE_ATTRIBUTE(pAttrInfo, dwAttrCount, dwSize)                      \
{                                                                               \
    for (DWORD dwIndex = 0; dwIndex < dwAttrCount; dwIndex++) {                 \
                                                                                \
        if (pAttrInfo[dwIndex].tAttrID == TAG_SIZE                              \
            && (pAttrInfo[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE)) {            \
                                                                                \
            dwSize = pAttrInfo[dwIndex].dwAttr;                                 \
            break;                                                              \
        }                                                                       \
    }                                                                           \
}
//*******************************************************************************

//*******************************************************************************
#define REGCLOSEKEY(hKey)                                                       \
{                                                                               \
    if (hKey) {                                                                 \
        RegCloseKey(hKey);                                                      \
        hKey = NULL;                                                            \
    }                                                                           \
}
//*******************************************************************************

//*******************************************************************************
#define ENABLEWINDOW(hwnd,bEnable)                                              \
{                                                                               \
    HWND hWndTemp = hwnd;                                                       \
    if (hWndTemp) {                                                             \
        EnableWindow(hWndTemp, bEnable);                                        \
    } else {                                                                    \
        assert(FALSE);                                                          \
    }                                                                           \
}
//*******************************************************************************

// IDs for the MRU items. Make sure that we do not get any control or menu with these ids
#define ID_FILE_FIRST_MRU               351
#define ID_FILE_MRU1                    ID_FILE_FIRST_MRU
#define ID_FILE_MRU2                    (ID_FILE_FIRST_MRU + 1)
#define ID_FILE_MRU3                    (ID_FILE_FIRST_MRU + 2)
#define ID_FILE_MRU4                    (ID_FILE_FIRST_MRU + 3)
#define ID_FILE_MRU5                    (ID_FILE_FIRST_MRU + 4)

// The key in the registry where we store our display settings
#define DISPLAY_KEY  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\CompatAdmin\\Display")

// The key in the registry where we store our MRU file names
#define MRU_KEY  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\CompatAdmin\\MRU")

// The base key. At least this should be present on all systems, even if we just loaded the OS
#define KEY_BASE TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

//
// The default mask for attributes that we choose. By default we choose these attributes:
// TAG_BIN_FILE_VERSION, TAG_BIN_PRODUCT_VERSION, TAG_PRODUCT_VERSION, TAG_FILE_VERSION, TAG_COMPANY_NAME,TAG_PRODUCT_NAME
#define DEFAULT_MASK 0x3B8L 

// The various user defined message types
#define WM_USER_MATCHINGTREE_REFRESH        WM_USER + 1024
#define WM_USER_DOTHESEARCH                 WM_USER + 1025
#define WM_USER_ACTIVATE                    WM_USER + 1026
#define WM_USER_REPAINT_TREEITEM            WM_USER + 1030
#define WM_USER_LOAD_COMMANDLINE_DATABASES  WM_USER + 1031
#define WM_USER_POPULATECONTENTSLIST        WM_USER + 1032
#define WM_USER_REPAINT_LISTITEM            WM_USER + 1034
#define WM_USER_UPDATEINSTALLED             WM_USER + 1035
#define WM_USER_UPDATEPERUSER               WM_USER + 1036
#define WM_USER_GETSQL                      WM_USER + 1037
#define WM_USER_NEWMATCH                    WM_USER + 1038
#define WM_USER_NEWFILE                     WM_USER + 1039
#define WM_USER_NEWQDB                      WM_USER + 1041
#define WM_USER_TESTRUN_NODIALOG            WM_USER + 1042


// Defines for the Images
#define IMAGE_SHIM          0
#define IMAGE_APPHELP       1
#define IMAGE_LAYERS        2
#define IMAGE_PATCHES       3
#define IMAGE_MATCHINFO     4
#define IMAGE_MATCHGROUP    5
#define IMAGE_WARNING       6
#define IMAGE_GLOBAL        7
#define IMAGE_WORKING       8
#define IMAGE_COMMANDLINE   9
#define IMAGE_INCLUDE       10
#define IMAGE_EXCLUDE       11
#define IMAGE_APP           12
#define IMAGE_INSTALLED     13
#define IMAGE_DATABASE      14
#define IMAGE_SINGLEAPP     15
#define IMAGE_ALLUSERS      16
#define IMAGE_SINGLEUSER    17
#define IMAGE_APPLICATION   18
#define IMAGE_EVENT_ERROR   19
#define IMAGE_EVENT_WARNING 20
#define IMAGE_EVENT_INFO    21
#define IMAGE_LAST          24 //Last global image index. 

// Images for the tool bar
#define IMAGE_TB_NEW        0
#define IMAGE_TB_OPEN       1
#define IMAGE_TB_SAVE       2
#define IMAGE_TB_NEWFIX     3
#define IMAGE_TB_NEWAPPHELP 4
#define IMAGE_TB_NEWMODE    5
#define IMAGE_TB_RUN        6
#define IMAGE_TB_SEARCH     7
#define IMAGE_TB_QUERY      8

// Id for the tool bar in the main window, which we create dynamically
#define ID_TOOLBAR  5555

//
// Max. length of the SQL. This string is of the form 'SELECT ... FROM ... [WHERE ...]'
// Note that the actual length of the final SQL will be more than the sum of the text in the 
// select and the where text fields, because it will include the key words like SELECT, WHERE, FROM
// and also the name of the databases like SYSTEM_DB etc.
// So we made it as 2096
#define MAX_SQL_LENGTH  2096

//
// Debugging spew
typedef enum 
{    
    dlNone     = 0,
    dlPrint,
    dlError,
    dlWarning,
    dlInfo

} DEBUGLEVEL;

//
// Defines for mapping into strsafe functions
//
#define SafeCpyN(pszDest, pszSource, nDestSize) StringCchCopy(pszDest, nDestSize, pszSource)

///////////////////////////////////////////////////////////////////////////////

/*++
!!!!!!!!!!!!!!! Warning !!!!!!!!!!!!!!!!!!

    Do not change the values for the DATABASE_TYPE_* enums. They should be powers of 2
    
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    

    The types of various data structures and some GUI tree items. In tree views 
    we have lParams associated with the tree items. All data structures have 
    a type field, which is the first field. So that if we have a pointer/lParam 
    and if the value of the pointer is greater than TYPE_NULL, then we typecast 
    it to PDS_TYPE and see if the type field is any of our known data structures
     
--*/

typedef unsigned (__stdcall *PTHREAD_START)(PVOID);

typedef const size_t K_SIZE;

typedef enum {

    TYPE_UNKNOWN            = 0,
    DATABASE_TYPE_GLOBAL    = 0x01,         // The global/system database i.e. %windir%\AppPatch\Sysmain.sdb
    DATABASE_TYPE_INSTALLED = 0x02,         // An installed database
    DATABASE_TYPE_WORKING   = 0x04,         // A working/custom database

    FIX_SHIM,                               // Type for SHIM_FIX
    FIX_PATCH,                              // Type for PATCH_FIX
    FIX_LAYER,                              // Type for LAYER_FIX
    FIX_FLAG,                               // Type for FLAG_FIX

    FIX_LIST_SHIM,                          // Type for SHIM_FIX_LIST
    FIX_LIST_PATCH,                         // Type for PATCH_FIX_LIST
    FIX_LIST_LAYER,                         // Type for LAYER_FIX_LIST
    FIX_LIST_FLAG,                          // Type for FLAG_FIX_LIST 

    TYPE_GUI_APPS,                          // lParam for "Applications" Tree item
    TYPE_GUI_SHIMS,                         // lParam for "Compatibility Fixes" Tree item
    TYPE_GUI_MATCHING_FILES,                // lParam for "Compatibility Modes" Tree item 
    TYPE_GUI_LAYERS,                        // lParam for "Compatibility Modes" Tree item 
    TYPE_GUI_PATCHES,                       // lParam for "Compatibility Patches" Tree item 
    
    TYPE_GUI_COMMANDLINE,                   // lParam for "Commandline" Tree item 
    TYPE_GUI_INCLUDE,                       // lParam for an included module tree item
    TYPE_GUI_EXCLUDE,                       // lParam for an excluded module tree item
    
    TYPE_GUI_DATABASE_WORKING_ALL,          // lParam for "Custom Database" Tree item 
    TYPE_GUI_DATABASE_INSTALLED_ALL,        // lParam for "Installed Database" Tree item 

    TYPE_APPHELP_ENTRY,                     // Type for APPHELP
    TYPE_ENTRY,                             // Type for DBENTRY
    TYPE_MATCHING_FILE,                     // Type for MATCHINGFILE 
    TYPE_MATCHING_ATTRIBUTE,                // An attribute item that appears under the matching file tree item

    TYPE_NULL //NOTE: This should be the last in the enum !!

} TYPE;

typedef enum {

    FLAG_USER,
    FLAG_KERNEL

} FLAGTYPE;

//
// Source type where the cut or copy was performed
//
typedef enum {

    LIB_TREE = 0,           // The data base tree (LHS)
    ENTRY_TREE,             // The entry tree (RHS)
    ENTRY_LIST              // The contents list (RHS) 

}SOURCE_TYPE;

typedef enum {
    APPTYPE_NONE,           // No apphelp has been added
    APPTYPE_INC_NOBLOCK,    // Soft blocked
    APPTYPE_INC_HARDBLOCK,  // Hard blocked
    APPTYPE_MINORPROBLEM,   // <Not used at the moment>
    APPTYPE_REINSTALL       // <Not used at the moment>
    
} SEVERITY;

/*++

    All data structures are sub classed from this, so all have a TYPE type member
    as their first member

--*/
typedef struct tagTYPE {
    TYPE type;
} DS_TYPE, *PDS_TYPE;

/*++

    Used for setting the background of controls that we show in a tab control

--*/
typedef HRESULT (*PFNEnableThemeDialogTexture)(HWND hwnd, DWORD dwFlags);

/*++

    Used when we are using the disk search option. MainMenu>Search>Search for fixed programs

--*/
typedef struct _MatchedEntry {

    CSTRING     strAppName;     // Name of the application
    CSTRING     strPath;        // The complete path of the program
    CSTRING     strDatabase;    // Name of the database
    CSTRING     strAction;      // Action type. Fixed with fixes, layers, or apphelp
    TCHAR       szGuid[128];    // Guid of the database in which the fixed program entry was found
    TAGID       tiExe;          // Tag id for the fixed program entry in the database in which it was found

} MATCHEDENTRY, *PMATCHEDENTRY;

/*++

    Used for customizing LUA shim

--*/
typedef struct tagLUAData 
{
    CSTRING strAllUserDir;
    CSTRING strPerUserDir;
    CSTRING strStaticList;
    CSTRING strDynamicList;
    CSTRING strExcludedExtensions;

    BOOL IsEmpty() 
    {
        return (strAllUserDir == NULL && 
                strPerUserDir == NULL && 
                strStaticList == NULL && 
                strDynamicList == NULL &&
                strExcludedExtensions == NULL);
    }

    BOOL IsEqual(tagLUAData & other) {

        return (strAllUserDir == other.strAllUserDir && 
                strPerUserDir == other.strPerUserDir && 
                strStaticList == other.strStaticList && 
                strDynamicList == other.strDynamicList &&
                strExcludedExtensions == other.strExcludedExtensions);
    }

    void Copy(tagLUAData & other) {

        strAllUserDir = other.strAllUserDir;
        strPerUserDir = other.strPerUserDir;
        strStaticList = other.strStaticList; 
        strDynamicList = other.strDynamicList;
        strExcludedExtensions = other.strExcludedExtensions;
    }

    void Copy(tagLUAData* pLuaDataOther)
    {
        assert(pLuaDataOther);

        if (pLuaDataOther == NULL) {
            return;
        }

        strAllUserDir = pLuaDataOther->strAllUserDir;
        strPerUserDir = pLuaDataOther->strPerUserDir;
        strStaticList = pLuaDataOther->strStaticList; 
        strDynamicList = pLuaDataOther->strDynamicList;
        strExcludedExtensions = pLuaDataOther->strExcludedExtensions;
    }

    void Free()
    {
        strStaticList.Release();
        strDynamicList.Release();
        strAllUserDir.Release();
        strPerUserDir.Release();
        strExcludedExtensions.Release();
    }

} LUADATA, *PLUADATA;

/*++

    A shim also known as a compatibility fix. In fact compatibility fix means any of
    shims, flags or patches. In the entry tree (RHS), if some exe has a patch, it is shown
    differently under "Compatibility Patches" tree item
 
--*/
typedef struct tagSHIM_FIX : public DS_TYPE {

    struct tagSHIM_FIX* pNext;              // The next shim
    CSTRING             strName;            // The name of the shim
    CSTRING             strDescription;     // The desciption of the shim
    CSTRING             strCommandLine;     // The commandline for the shim
    BOOL                bGeneral;           // Is this a general or a specific shim
    CSTRINGLIST         strlInExclude;      // List of include and exclude modules

    tagSHIM_FIX()
    {
        pNext       = NULL;
        bGeneral    = FALSE;
        type        = FIX_SHIM;
    }
    
} SHIM_FIX, *PSHIM_FIX;

/*++

    Contains a pointer to a shim and a pointer to a tagSHIM_FIX_LIST
    
--*/
typedef struct tagSHIM_FIX_LIST : public DS_TYPE {

    struct tagSHIM_FIX_LIST*    pNext;              // The next tagSHIM_FIX_LIST
    PSHIM_FIX                   pShimFix;           // Pointer to a shim
    CSTRING                     strCommandLine;     // Any command line  
    CSTRINGLIST                 strlInExclude;      // Any include-exclude modules
    PLUADATA                    pLuaData;           // Lua data

    tagSHIM_FIX_LIST()
    {
        pNext       = NULL;
        pShimFix    = NULL;
        pLuaData    = NULL;
        type        = FIX_LIST_SHIM;
    }
    
} SHIM_FIX_LIST, *PSHIM_FIX_LIST;

void
DeleteShimFixList(
    PSHIM_FIX_LIST psl
    );

/*++

    A compatibility flag
    
--*/
typedef struct tagFLAG_FIX : public DS_TYPE {
    
    struct tagFLAG_FIX* pNext;              // Pointer to the next flag
    CSTRING             strName;            // Name of the flag
    CSTRING             strDescription;     // Description for the flag
    CSTRING             strCommandLine;     // Command line for the flag
    ULONGLONG           ullMask;            // <Not used at the moment>
    FLAGTYPE            flagType;           // Type, one of: FLAG_USER, FLAG_KERNEL
    BOOL                bGeneral;           // General or specific

    tagFLAG_FIX()
    {
        pNext       = NULL;
        type        = FIX_FLAG;
        bGeneral    = FALSE;
    }   
    
} FLAG_FIX, *PFLAG_FIX;

/*++

    Contains a pointer to a flag and a pointer to a tagFLAG_FIX_LIST
    
--*/
typedef struct tagFLAG_FIX_LIST : public DS_TYPE {

    struct tagFLAG_FIX_LIST* pNext;                  // The next tagFLAG_FIX_LIST
    PFLAG_FIX                pFlagFix;               // Pointer to a flag
    CSTRING                  strCommandLine;         // Any command lines for this flag

    tagFLAG_FIX_LIST()
    {
        pNext       = NULL;
        pFlagFix    = NULL;
        type        = FIX_LIST_FLAG;
    }

} FLAG_FIX_LIST, *PFLAG_FIX_LIST;

void
DeleteFlagFixList(
    PFLAG_FIX_LIST pfl
    );

/*++

    A layer. Also known as a compatibility mode. A layer is a collection of shims and 
    flags. Shims and flags when they appear in a layer can have a different command lines
    and include-exclude paramteres than what they originallyy have. Note that flags do 
    not have include-exclude parameters. That is why SHIM_FIX_LIST has a strCommandLine
    and a strlInExclude and FLAG_FIX_LIST has a strCommandLine 
    
--*/

typedef struct tagLAYER_FIX : public DS_TYPE {
    
    struct tagLAYER_FIX* pNext;         // The next layer
    CSTRING              strName;       // The name of the layer
    PSHIM_FIX_LIST       pShimFixList;  // List of shims for this layer
    PFLAG_FIX_LIST       pFlagFixList;  // List of flags for this layer
    BOOL                 bCustom;       // Is this a custom layer (created in a custom database), or does it live in the system database
    UINT                 uShimCount;    // Number of shims and flags in this layer

    tagLAYER_FIX(BOOL bCustomType)
    {
        pFlagFixList = NULL;
        pNext        = NULL;
        pShimFixList = NULL;
        type         = FIX_LAYER;
        bCustom      = bCustomType;
        uShimCount   = 0; 
    }

    tagLAYER_FIX& operator = (tagLAYER_FIX& temp)
    {
        //
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        // CAUTION: DO NOT MODIFY THE pNext MEMBER.
        //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        //

        strName = temp.strName;

        //
        // First copy the flags
        //
        DeleteFlagFixList(pFlagFixList);
        pFlagFixList = NULL;

        DeleteShimFixList(pShimFixList);
        pShimFixList = NULL;

        PFLAG_FIX_LIST pfl = temp.pFlagFixList;

        while (pfl) {
            
            PFLAG_FIX_LIST pflNew = new FLAG_FIX_LIST;

            if (pflNew == NULL) {

                MEM_ERR;
                return *this;
            }

            pflNew->pFlagFix        = pfl->pFlagFix;
            pflNew->strCommandLine  = pfl->strCommandLine;

            pflNew->pNext = pFlagFixList;
            pFlagFixList  = pflNew;

            pfl = pfl->pNext;
        }

        //
        // Now copy the shims
        //
        PSHIM_FIX_LIST psfl = temp.pShimFixList;
        
        while (psfl) {

            PSHIM_FIX_LIST pNew = new SHIM_FIX_LIST;

            if (pNew == NULL) {

                MEM_ERR;
                return *this;
            }
            
            pNew->pShimFix       = psfl->pShimFix;
            pNew->strCommandLine = psfl->strCommandLine;
            pNew->strlInExclude  = psfl->strlInExclude;

            if (psfl->pLuaData) {

                pNew->pLuaData = new LUADATA;

                if (pNew->pLuaData) {
                    pNew->pLuaData->Copy(psfl->pLuaData);
                } else {
                    MEM_ERR;
                }
            }
            
            pNew->pNext = pShimFixList;
            pShimFixList  = pNew;

            psfl = psfl->pNext;
        }

        return *this;
    } 

} LAYER_FIX, *PLAYER_FIX;

/*++

    Contains a pointer to a layer and a pointer to a tagLAYER_FIX_LIST
    
--*/

typedef struct tagLAYER_FIX_LIST : public DS_TYPE {

    struct tagLAYER_FIX_LIST*   pNext;      // The next tagLAYER_FIX_LIST
    PLAYER_FIX                  pLayerFix;  // The layer to which this tagLAYER_FIX_LIST points 

    tagLAYER_FIX_LIST()
    {
        pLayerFix   = NULL;
        pNext       = NULL;
        type        = FIX_LIST_LAYER;
    }

} LAYER_FIX_LIST, *PLAYER_FIX_LIST;

/*++

    A compatibility patch
    
--*/
typedef struct tagPATCH_FIX : public DS_TYPE {

    struct tagPATCH_FIX*    pNext;          // The next patch
    CSTRING                 strName;        // Name of this patch
    CSTRING                 strDescription; // Description for this patch

    tagPATCH_FIX()
    {
        pNext   = NULL;
        type    = FIX_PATCH;
    }

} PATCH_FIX, *PPATCH_FIX;

/*++

    Contains a pointer to a patch and a pointer to a tagPATCH_FIX_LIST
    
--*/
typedef struct tagPATCH_FIX_LIST : public DS_TYPE {

    struct tagPATCH_FIX_LIST*   pNext;
    PPATCH_FIX                  pPatchFix;

    tagPATCH_FIX_LIST()
    {
        pNext = NULL;
        pPatchFix = NULL;
        type = FIX_LIST_PATCH;
    }

} PATCH_FIX_LIST, *PPATCH_FIX_LIST;

/*++

NOTE:     The same APPHELP strcuture is used by the apphelp in the Library and the one in the 
          DBENTRY. This structure represents the union of the fields used at these two different 
          places.
          
          Before the comments  you will see E, D, B.
          
          E:    Used when in the context of an entry
          D:    Used when in the context of a database
          B:    Applicable to both
--*/

typedef struct tagAPPHELP : public DS_TYPE {
    
    union{
        struct tagAPPHELP *pNext;           // D: Pointer to the next apphelp message in the database
        struct tagAPPHELP *pAppHelpinLib;   // E: Pointer to the apphelp message in the database for this entry
    };

    BOOL     bPresent;                      // E: Is the entry apphelped. If this is false, all other fields have invalid value
    SEVERITY severity;                      // E: The severity
    CSTRING  strMsgName;                    // D: The name of the message
    CSTRING  strMessage;                    // D: The text for the apphelp message
    CSTRING  strURL;                        // D: The URL for this apphelp message
    UINT     HTMLHELPID;                    // B: The id for this message
    BOOL     bBlock;                        // E: Whether no block or hard block. This is determined by the type of severity
    
    tagAPPHELP()
    {
        type = TYPE_APPHELP_ENTRY;
    }

} APPHELP, *PAPPHELP;

/*++
    Extended ATTRINFO so that we can use CSTRING
--*/
typedef struct tagATTRINFO_NEW : public ATTRINFO
{
    CSTRING strValue;

    tagATTRINFO_NEW()
    {
        this->dwFlags = 0;
        this->ullAttr = 0;
    }

} ATTRINFO_NEW, *PATTRINFO_NEW;

/*++
    Array of PATTRINFO_NEW. Each matching file has a set of attributes and this is 
    specified by this data structure
--*/
typedef struct tagATTRIBUTE_LIST
{
    
    PATTRINFO_NEW       pAttribute;

    tagATTRIBUTE_LIST()
    {
        pAttribute = new ATTRINFO_NEW[ATTRIBUTE_COUNT];

        if (pAttribute == NULL) {
            MEM_ERR;
            return;
        }

        ZeroMemory(pAttribute, sizeof (ATTRINFO_NEW) * ATTRIBUTE_COUNT);
    }

    tagATTRIBUTE_LIST& operator =(tagATTRIBUTE_LIST& SecondList)
    {
        PATTRINFO_NEW pSecondList = SecondList.pAttribute;

        for (DWORD dwIndex = 0; dwIndex < ATTRIBUTE_COUNT; ++dwIndex) {

            pAttribute[dwIndex].tAttrID   = pSecondList[dwIndex].tAttrID;
            pAttribute[dwIndex].dwFlags   = pSecondList[dwIndex].dwFlags;
            pAttribute[dwIndex].ullAttr   = pSecondList[dwIndex].ullAttr;

            if (GETTAGTYPE(pAttribute[dwIndex].tAttrID) == TAG_TYPE_STRINGREF 
                && (pAttribute[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE)) {

                if (pSecondList[dwIndex].lpAttr) {
                    pAttribute[dwIndex].strValue = pSecondList[dwIndex].lpAttr;
                    pAttribute[dwIndex].lpAttr   = pAttribute[dwIndex].strValue.pszString;
                }
            }
        }

        return *this;
    }

    tagATTRIBUTE_LIST& operator =(PATTRINFO pSecondList)
    {
        for (DWORD dwIndex = 0; dwIndex < ATTRIBUTE_COUNT; ++dwIndex) {

             pAttribute[dwIndex].tAttrID   = pSecondList[dwIndex].tAttrID;
             pAttribute[dwIndex].dwFlags   = pSecondList[dwIndex].dwFlags;
             pAttribute[dwIndex].ullAttr   = pSecondList[dwIndex].ullAttr;

            if (GETTAGTYPE(pAttribute[dwIndex].tAttrID) == TAG_TYPE_STRINGREF 
                && (pAttribute[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE)) {

                if (pSecondList[dwIndex].lpAttr) {
                    pAttribute[dwIndex].strValue = pSecondList[dwIndex].lpAttr;
                    pAttribute[dwIndex].lpAttr   = pAttribute[dwIndex].strValue.pszString;
                }
            }
        }
        

        return *this;
    }

    ~tagATTRIBUTE_LIST()
    {
        if (pAttribute) {
            delete[] pAttribute;
        }

        pAttribute = NULL;
    }



} ATTRIBUTELIST, *PATTRIBUTELIST;

int
TagToIndex(
    IN  TAG tag 
    );

/*++
    A matching file. Each entry can contain a list of matching files that are used
    to uniquely identify this entry
--*/

typedef struct tagMATCHINGFILE : public DS_TYPE {

    struct tagMATCHINGFILE* pNext;          // The next matching file
    DWORD                   dwMask;         // Which attributes have been selected to be used.
    CSTRING                 strMatchName;   // The name of the matching file. * means the file being fixed. Otherwise it will be only the file name and not the complete path.
    CSTRING                 strFullName;    // The full name if available. 
    ATTRIBUTELIST           attributeList;  // The attribute list for the matching file. The dwMask will determine which one of them are actually used

    tagMATCHINGFILE()
    {
        pNext       = NULL;
        type        = TYPE_MATCHING_FILE;
        dwMask      = DEFAULT_MASK;
    }
                                                                          
    BOOL operator == (struct tagMATCHINGFILE &val)
    /*++
    Desc:
    
        Two matching files are said to be similar if there does not any exist any attribute
        that has different values in these two matching files
    --*/
    {                                                                     
        BOOL bEqual = TRUE;

        if (strMatchName != val.strMatchName) {
            return FALSE;
        }
        
        for (DWORD dwIndex = 0; dwIndex < ATTRIBUTE_COUNT; ++dwIndex) {
            
            int iPos = TagToIndex(attributeList.pAttribute[dwIndex].tAttrID);

            if (iPos == -1) {

                continue;
            }

            //
            // Do both the files use these attributes ?
            //
            if ((dwMask & (1 << (iPos + 1))) 
                 && (val.dwMask & (1 << (iPos + 1))) 
                 && attributeList.pAttribute[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE  
                 && val.attributeList.pAttribute[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE)  {

                //
                // Both of them use this attribute
                //
                switch (GETTAGTYPE(attributeList.pAttribute[dwIndex].tAttrID)) {
                case TAG_TYPE_DWORD:

                    bEqual = (attributeList.pAttribute[dwIndex].dwAttr == val.attributeList.pAttribute[dwIndex].dwAttr);
                    break;

                case TAG_TYPE_QWORD:

                    bEqual = (attributeList.pAttribute[dwIndex].ullAttr == val.attributeList.pAttribute[dwIndex].ullAttr);
                    break;

                case TAG_TYPE_STRINGREF:

                    bEqual = (lstrcmpi(attributeList.pAttribute[dwIndex].lpAttr, 
                                       val.attributeList.pAttribute[dwIndex].lpAttr) == 0);
                    break;
                }

                if (bEqual == FALSE) {
                    return FALSE;
                }
            }
        }

        //
        // everything matches.
        //
        return TRUE;
    }

} MATCHINGFILE, *PMATCHINGFILE;

void
DeletePatchFixList(
    PPATCH_FIX_LIST pPat
    );

void
DeleteLayerFixList(
    PLAYER_FIX_LIST pll
    );

void
DeleteFlagFixList(
    PFLAG_FIX_LIST pfl
    );

void
DeleteMatchingFiles(
    PMATCHINGFILE pMatch
    );


/*++
    Data strcuture to represent a fixed program
    
    We keep the data structure in this way:
    
    There is a linked list of applications. An application is a DBENTRY. Each 
    application contains a pointer to the next application as well (through 
    pNext) as a pointer to a DBENTRY that has the same strAppName (through 
    pSameAppExe). This second DBENTRY is now called as an entry in this application 
    and will contain a pointer to the next entry. So we have effectively a linked 
    list of linked lists. So an application is the first member of a linked list B. 
    All such linked lists of type B are linked together (through pNext)to create a 
    linked list A which is the linked list of applications
    
--*/
typedef struct tagDBENTRY : public DS_TYPE {
    
    struct tagDBENTRY*  pNext;              // Pointer to the next application, in case this entry is an application
    struct tagDBENTRY*  pSameAppExe;        // Pointer to the next entry for this application.
                                            
    TAGID               tiExe;              // TAGID for the entry as in the database
                                            
    CSTRING             strExeName;         // The name of the exe being fixed. This will be file name only
    CSTRING             strFullpath;        // Full path, if available
    CSTRING             strAppName;         // Application name
    CSTRING             strVendor;          // Vendor name, can be NULL
    TCHAR               szGUID[128];        // GUID for this entry
                                            
    PSHIM_FIX_LIST      pFirstShim;         // The list of shims that have been applied to this entry
    PPATCH_FIX_LIST     pFirstPatch;        // The list of patches that have been applied to this entry
    PLAYER_FIX_LIST     pFirstLayer;        // The list of layers that have been applied to this entry
    PFLAG_FIX_LIST      pFirstFlag;         // The list of flags that have been applied to this entry
                                            
    APPHELP             appHelp;            // Apphelp information for this entry
                        
    PMATCHINGFILE       pFirstMatchingFile; // The first matching file for this entry
    int                 nMatchingFiles;     // Number of matching files for this entry
                        
    BOOL                bDisablePerUser;    //  Not used at the moment. Is this fix entry disabled for the present user?
    BOOL                bDisablePerMachine; // Is this fix entry disabled on this machine
                        
    HTREEITEM           hItemExe;           // HITEM for the exe as in the entry tree

    tagDBENTRY()
    {
        tiExe                   = TAGID_NULL;

        pFirstFlag              = NULL;
        pFirstLayer             = NULL;
        pFirstMatchingFile      = NULL;
        pFirstPatch             = NULL;
        pFirstShim              = NULL;
        pNext                   = NULL;
        pSameAppExe             = NULL;
        
        *szGUID                 = 0;
        
        appHelp.bPresent        = FALSE;
        appHelp.pAppHelpinLib   = NULL;
        appHelp.severity        = APPTYPE_NONE;

        type                    = TYPE_ENTRY;
        hItemExe                = NULL;
        bDisablePerMachine      = FALSE;
        bDisablePerUser         = FALSE;
        nMatchingFiles          = 0;
    }

    ~tagDBENTRY()
    {
        Delete();
    }

    void
    Delete()
    {
        DeleteFlagFixList(pFirstFlag);
        pFirstFlag = NULL;

        DeleteLayerFixList(pFirstLayer);
        pFirstLayer = NULL;

        DeleteMatchingFiles(pFirstMatchingFile);
        pFirstMatchingFile = NULL;

        DeleteShimFixList(pFirstShim);
        pFirstShim = NULL;
        
        DeletePatchFixList(pFirstPatch);
        pFirstPatch = NULL;
    }
    
    struct tagDBENTRY& operator = (struct tagDBENTRY& temp)
    {
        Delete();

        //
        //********************************************************************************
        // Note that we are assuming that both the entries are in the same database.
        // So we do not move the layers and the apphelp, because they actually belong to the 
        // database. If we want to assign one DBENTRY to a DBENTRY in a different database
        // we will have to copy the apphelp from one database to another and set the pointes
        // of the apphelp in the entry correctly.
        // Also we will need to copy any custom layers and set the pointers correctly.
        //********************************************************************************
        //
        appHelp             = temp.appHelp;

        bDisablePerMachine  = temp.bDisablePerMachine;
        bDisablePerUser     = temp.bDisablePerUser;
        nMatchingFiles      = temp.nMatchingFiles;
        
        //
        // Copy flag list
        //
        PFLAG_FIX_LIST pffl = temp.pFirstFlag;
        
        while (pffl) {

            PFLAG_FIX_LIST pfflNew  = new FLAG_FIX_LIST;

            if (pfflNew == NULL) {
                MEM_ERR;
                return *this;
            }

            pfflNew->pFlagFix       = pffl->pFlagFix;
            pfflNew->strCommandLine = pffl->strCommandLine;
            pfflNew->pNext          = pFirstFlag;
            
            pFirstFlag = pfflNew;

            pffl = pffl->pNext;
        }

        //
        // Copy the layers list
        //
        PLAYER_FIX_LIST plfl = temp.pFirstLayer;

        while (plfl) {

            PLAYER_FIX_LIST pNew = new LAYER_FIX_LIST;

            if (pNew == NULL) {
                MEM_ERR;
                return *this;
            }

            assert(plfl->pLayerFix);
            pNew->pLayerFix  = plfl->pLayerFix;
            assert(pNew->pLayerFix);

            pNew->pNext      = pFirstLayer;
            
            pFirstLayer = pNew;

            plfl = plfl->pNext;
        }

        //
        // Copy the matching files
        //
        PMATCHINGFILE pMatch = temp.pFirstMatchingFile;
        
        while (pMatch) {

            PMATCHINGFILE pNew = new MATCHINGFILE;

            if (pNew == NULL) {
                MEM_ERR;
                return *this;
            }

            pNew->strMatchName      = pMatch->strMatchName;     
            pNew->strFullName       = pMatch->strFullName;      
            pNew->dwMask            = pMatch->dwMask;

            pNew->attributeList     = pMatch->attributeList;

            pNew->pNext = pFirstMatchingFile;
           
            pFirstMatchingFile= pNew;

            pMatch = pMatch->pNext;
        }

        //
        // Copy the patches
        //
        PPATCH_FIX_LIST ppfl = temp.pFirstPatch;

        while (ppfl) {

            PPATCH_FIX_LIST pNew = new PATCH_FIX_LIST;

            if (pNew == NULL) {
                MEM_ERR;
                return *this;
            }

            pNew->pPatchFix = ppfl->pPatchFix;
            pNew->pNext     = pFirstPatch;
            
            pFirstPatch = pNew;

            ppfl = ppfl->pNext;
        }

        //
        // Copy the shims 
        //
        PSHIM_FIX_LIST psfl = temp.pFirstShim;
        
        while (psfl) {

            PSHIM_FIX_LIST pNew = new SHIM_FIX_LIST;
            
            pNew->pShimFix       = psfl->pShimFix;
            pNew->strCommandLine = psfl->strCommandLine;
            pNew->strlInExclude  = psfl->strlInExclude;

            if (psfl->pLuaData) {

                pNew->pLuaData = new LUADATA;
                pNew->pLuaData->Copy(* (psfl->pLuaData));
            }
            
            pNew->pNext = pFirstShim;
            pFirstShim  = pNew;

            psfl = psfl->pNext;
        }
        
        strAppName  = temp.strAppName;
        strExeName  = temp.strExeName;
        strFullpath = temp.strFullpath;
        strVendor   = temp.strVendor;

        SafeCpyN(szGUID, temp.szGUID, ARRAYSIZE(szGUID));

        return *this;
    }

} DBENTRY, *PDBENTRY;

void
GetNextSDBFileName(
    CSTRING &strFileName,
    CSTRING &strDBName
    );
LPTSTR
GetString(
    UINT    iResource,
    TCHAR*  szStr   = NULL,
    int     nLength = 0
    );

/*++
    A data base
--*/
typedef struct DataBase : public DS_TYPE {


    struct DataBase* pNext;     // The next database. (If this is a part of a list)

    CSTRING     strName;        // The name of this database
    CSTRING     strPath;        // The complete path for this database
    TCHAR       szGUID[128];     // The GUID for this database
    PDBENTRY    pEntries;       // Pointer to the first DBENTRY for this database
    BOOL        bChanged;       // Has it changed since it was opened?
    BOOL        bReadOnly;      // Is this a read-only database?
                
    PLAYER_FIX  pLayerFixes;    // Pointer to the first layer
    PSHIM_FIX   pShimFixes;     // Pointer to the first shim. Note that only the system database can have shims
    PPATCH_FIX  pPatchFixes;    // Pointer to the first patch. Note that only the system database can have patches
    PFLAG_FIX   pFlagFixes;     // Pointer to the first flag. Note that only the system database can have flags
    PAPPHELP    pAppHelp;       // Pointer to the first apphelp message in the database. Valid only for custom databases

    HTREEITEM   hItemDB;        // HTREEITEM for this database in the db tree
    HTREEITEM   hItemAllApps;   // HTREEITEM for the "Applications" child tree item
    HTREEITEM   hItemAllLayers; // HTREEITEM for the "Compatibility Modes" child tree item
    DWORD       m_nMAXHELPID;   // This is the id of the message with the highest ID. Initially this is 0. Note that IDs start from 1 and not 0.

    UINT        uAppCount;      // Number of applications in this database
    UINT        uLayerCount;    // Number of layers in this database
    UINT        uShimCount;     // Number of shims and flags in this database


    DataBase(TYPE typeDB)
    {
        Init(typeDB);
    }

    void
    Init(TYPE typeDB)
    {
        type        = typeDB;

        pEntries    = NULL;
        pNext       = NULL;
        pFlagFixes  = NULL;
        pLayerFixes = NULL;
        pPatchFixes = NULL;
        pShimFixes  = NULL;
        pAppHelp    = NULL;

        uAppCount   = 0;  
        uLayerCount = 0;
        uShimCount  = 0;

        *szGUID      = 0;
        bChanged     = FALSE;

        if (typeDB == DATABASE_TYPE_INSTALLED) {
            bReadOnly = TRUE;
        } else {
            bReadOnly = FALSE;
        }

        if (type == DATABASE_TYPE_WORKING) {
            GetNextSDBFileName(strPath, strName);
        
        } else if (type == DATABASE_TYPE_GLOBAL) {
            
            TCHAR   szShimDB[MAX_PATH * 2];
            UINT    uResult = 0;    

            *szShimDB = 0;

            uResult = GetSystemWindowsDirectory(szShimDB, MAX_PATH);

            if (uResult > 0 && uResult < MAX_PATH) {

                ADD_PATH_SEPARATOR(szShimDB, ARRAYSIZE(szShimDB));
                StringCchCat(szShimDB, ARRAYSIZE(szShimDB), TEXT("AppPatch\\sysmain.sdb"));

                strName = GetString(IDS_CAPTION3);
            } else {
                assert(FALSE);
            }

            strPath = szShimDB;
            //
            // {11111111-1111-1111-1111-111111111111} is the GUID for the sysmain.sdb in XP
            // but not on win2k
            //
            SafeCpyN(szGUID, _T("{11111111-1111-1111-1111-111111111111}"), ARRAYSIZE(szGUID));
        }

        hItemDB         = NULL;       
        hItemAllApps    = NULL;  
        hItemAllLayers  = NULL;
        m_nMAXHELPID    = 0;
    }

} DATABASE, *PDATABASE;

void
CleanupDbSupport(
    PDATABASE pDataBase
    );

void
ValidateClipBoard(
    PDATABASE   pDataBase,
    LPVOID      pElementTobeDeleted  // Should be a PDBENTRY or a PLAYER_FIX
    );


/*++
    Linked list of databases
--*/
typedef struct tagDataBaseList {

    
    PDATABASE pDataBaseHead;    // The first database in the list

    tagDataBaseList()
    {
        pDataBaseHead = NULL;
    }

    void
    Add(
        PDATABASE pDataBaseNew
        )
    {
        if (pDataBaseNew == NULL) {
            return;
        }
        
        pDataBaseNew->pNext = pDataBaseHead;
        pDataBaseHead       = pDataBaseNew;
    }

    BOOL
    Remove(
        PDATABASE pDataBaseToRemove
        )
    {
        PDATABASE pPrev = NULL;

        for (PDATABASE pTemp = pDataBaseHead; pTemp; pPrev = pTemp, pTemp = pTemp->pNext){

            if (pTemp == pDataBaseToRemove) {

                if (pPrev == NULL) {
                    //First Entry
                    pDataBaseHead = pTemp->pNext;
                } else {
                    pPrev->pNext = pTemp->pNext;
                }

                //
                // Remove any entries for this database that might be in our CLIPBOARD
                //
                ValidateClipBoard(pDataBaseToRemove, NULL);

                CleanupDbSupport(pTemp);
                delete pTemp;
                break;
            }
        }
        
        if (pTemp == NULL){
            return FALSE;
        }

        return TRUE;        
    }

    void
    RemoveAll()
    {
        PDATABASE pDBNext = NULL;

        while (pDataBaseHead) {

            pDBNext = pDataBaseHead->pNext;

            //
            // Remove any entries for this database that might be in our CLIPBOARD
            //
            ValidateClipBoard(pDataBaseHead, NULL);

            CleanupDbSupport(pDataBaseHead);
            delete pDataBaseHead;
            pDataBaseHead   = pDBNext;
        }
    }

    PDATABASE
    FindDB(
        IN  PDATABASE pDatabase
        )
    {
        PDATABASE pDatabaseIndex = pDataBaseHead;

        while (pDatabaseIndex) {

            if (pDatabaseIndex == pDatabase) {
                break;
            }

            pDatabaseIndex = pDatabaseIndex->pNext;
        }

        return pDatabaseIndex;
    }   

    PDATABASE
    FindDBByGuid(
        IN  PCTSTR  pszGuid
        )
    {
        PDATABASE pDatabaseIndex = pDataBaseHead;

        while (pDatabaseIndex) {

            if (lstrcmp(pDatabaseIndex->szGUID, pszGuid) == 0) {
                break;
            }

            pDatabaseIndex = pDatabaseIndex->pNext;
        }

        return pDatabaseIndex;
    }


}DATABASELIST, * PDATABASELIST;

/*++
    Item in our clip-board data structure are of this type
--*/
typedef struct tagCopyStruct{

    
    BOOL            bRemoveEntry;   // Should the entry be actually removed. Not used as yet
    LPVOID          lpData;         // The pointer to the data structure that has been copied/cut
    HTREEITEM       hItem;          // The tree item for the above

    tagCopyStruct*  pNext;

    tagCopyStruct()
    {
        hItem           = NULL;
        bRemoveEntry    = FALSE;
    }

} CopyStruct;

/*++
    Our clipboard data structure
--*/
typedef struct _tagClipBoard {

    PDATABASE       pDataBase;      // The database from where we did some cut-copy. This will be the active database when we did cut or copy
    TYPE            type;           // The type of the data structure that was copied or cut. There can be more than on item and all of them will be of the same type
    SOURCE_TYPE     SourceType;     // Either of LIB_TREE, ENTRY_TREE, ENTRY_LIST.  
    CopyStruct*     pClipBoardHead; // The pointer to the first element in the clipboard

     _tagClipBoard()
     {
         pClipBoardHead = NULL;
     }

     void
     Add(CopyStruct* pNew)
     {
         pNew->pNext    = pClipBoardHead;
         pClipBoardHead = pNew;
     }

     void
     RemoveAll()
     {
         CopyStruct* pTemp = NULL;

         while (pClipBoardHead) {

             pTemp = pClipBoardHead->pNext;
             delete  pClipBoardHead;
             pClipBoardHead =  pTemp;

         }
     }

     BOOL
     CheckAndRemove(LPVOID lpData)
     {
     /*++
     Return:
        TRUE    if the param was found in the clipboard.
        FALSE   otherwise
     --*/
         CopyStruct* pTemp = pClipBoardHead;
         CopyStruct* pPrev = NULL;

         while (pTemp) {

             if (pTemp->lpData == lpData) {

                 if (pPrev == NULL) {
                     pClipBoardHead = pTemp->pNext;
                 } else {
                     pPrev->pNext = pTemp->pNext;
                 }

                 delete pTemp;
                 return TRUE;
             }

             pPrev = pTemp;
             pTemp = pTemp->pNext;
         }

         return FALSE;
     }
} CLIPBOARD;

//
// Used for sorting of columns in some list view
//
typedef struct _tagColSort
{
    HWND    hwndList;       // The handle to the list view, in which we want to perform the sort
    INT     iCol;           // The column that we want to do the sort on
    LONG    lSortColMask;   // The mask that specifies what columns are sorted in what manner, so that we can toggle the sorting

} COLSORT;

TYPE
ConvertLparam2Type(
    LPARAM lParam
    );

TYPE
ConvertLpVoid2Type(
    LPVOID lpVoid
    );


TYPE
GetItemType(
    HWND hwndTree,
    HTREEITEM hItem
    );

BOOL
RemoveLayer(
    PDATABASE  pDataBase,
    PLAYER_FIX pLayerToRemove,
    HTREEITEM* pHItem
    );

void
DoTheCut(
    PDATABASE       pDataBase,
    TYPE            type,
    SOURCE_TYPE     SourceType,  
    LPVOID          lpData, // To be removed       
    HTREEITEM       hItem,
    BOOL            bDelete
    );

BOOL
RemoveApp(
    PDATABASE pDataBase,
    PDBENTRY pApp
    );

void
RemoveAllApps(
    PDATABASE pDataBase
    );

void
RemoveAllLayers(
    PDATABASE pDataBase
    );

DWORD 
WIN_MSG(
    void
    );

BOOL
CheckForSDB(
    void
    );

BOOL
PasteMultipleLayers(
    PDATABASE pDataBaseTo
    );

BOOL
PasteShimsFlags(
    PDATABASE pDataBaseTo
    );

BOOL
PasteMultipleApps(
    PDATABASE pDataBaseTo
    );

void
ListViewSelectAll(
    HWND hwndList
    );

void
ListViewInvertSelection(
    HWND hwndList
    );

BOOL
DeleteMatchingFile(
    PMATCHINGFILE*  ppMatchFirst,
    PMATCHINGFILE   pMatchToDelete,
    HWND            hwndTree,  
    HTREEITEM       hItem  
    );

BOOL
CheckInstalled(
    PCTSTR  szPath,
    PCTSTR  szGUID
    );

void
SetStatus(
    PCTSTR  pszMessage
    );

void
SetStatus(
    INT iCode
    );


void
SetStatusStringDBTree(
    HTREEITEM hItem
    );

void
SetStatusStringEntryTree(
    HTREEITEM hItem
    );

void
GetDescriptionString(
    LPARAM      lParam,
    CSTRING&    strDesc,
    HWND        hwndToolTip,
    PCTSTR      pszCaption      = NULL,
    HTREEITEM   hItem           = NULL,
    HWND        hwnd            = NULL,
    INT         iIndexListView  = -1
    );

BOOL
SaveDisplaySettings(
    void
    );

UINT
GetAppEntryCount(
    PDBENTRY pEntry
    );

void
AddToMRU(
    CSTRING& strPath
    );

TCHAR*
FormatMRUString(
    PCTSTR  pszPath,
    INT     iIndex,
    PTSTR   szRetPath,
    UINT    cchRetPath     
    );

void
RefreshMRUMenu(
    void
    );

BOOL
LoadDataBase(
    TCHAR*  szPath   
    );

INT
GetLayerCount(
    LPARAM lp,
    TYPE   type
    );
INT
GetPatchCount(
    LPARAM lp,
    TYPE   type
    );

BOOL
GetFileContents(
    PCTSTR pszFileName,
    PWSTR* ppwszFileContents
    );

INT
GetShimFlagCount(
    LPARAM lp,
    TYPE   type
    );

INT
GetMatchCount(
    PDBENTRY pEntry
    );

LPWSTR 
GetNextLine(
    LPWSTR pwszBuffer
    );

INT
Atoi(
    PCTSTR pszStr,
    BOOL*  bValid
    );

BOOL
CheckIfInstalledDB(
    PCTSTR  szGuid
    );

BOOL
CheckIfContains(
    PCTSTR  pszString,
    PTSTR   pszMatch
    );

INT
ShowMainEntries(
    HWND hdlg
    );

INT_PTR 
CALLBACK 
HandleConflictEntry(
    HWND    hdlg, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

BOOL
IsUnique(
    PDATABASE   pDatabase,
    PCTSTR      szName,
    UINT        uType
    );

PTSTR
GetUniqueName(
    PDATABASE   pDatabase,
    PCTSTR      szExistingName,
    PTSTR       szBuffer,
    INT         cchBuffer,
    TYPE        type
    );

BOOL
NotCompletePath(
    PCTSTR  pszFileName
    );

void
TreeDeleteAll(
    HWND hwndTree
    );
void
AddSingleEntry(
    HWND hwndTree,
    PDBENTRY pEntry
    );

BOOL
FormatDate(
    PSYSTEMTIME pSysTime,
    TCHAR*      szDate,
    UINT        cchDate
    );

void
TrimLeadingSpaces(
    LPCWSTR& pwsz
    );

void
TrimTrailingSpaces(
    LPWSTR pwsz
    );

LPWSTR GetNextToken(
    LPWSTR pwsz
    );

PDBENTRY
GetAppForEntry(
    PDATABASE   pDatabase,
    PDBENTRY    pEntryToCheck
    );

void
SetStatus(
    HWND    hwndStatus,
    PCTSTR  pszMessage
    );

void
SetStatus(
    HWND    hwndStatus,
    INT     iCode
    );
void
UpdateEntryTreeView(
    PDBENTRY    pEntry,
    HWND        hwndTree
    );

void
GetDescription(
    HWND        hwndTree,
    HTREEITEM   hItem,
    LPARAM      itemlParam,
    CSTRING&    strDesc
    );

BOOL
AppendEvent(
    INT     iType,
    TCHAR*  szTimestamp,
    TCHAR*  szMsg,
    BOOL    bAddToFile = FALSE
    );

PSHIM_FIX_LIST
IsLUARedirectFSPresent(
    PDBENTRY pEntry
    );

BOOL
GetDbGuid(
    OUT TCHAR*      pszGuid,    
    IN  INT         cchpszGuid,
    IN  PDB         pdb
    );

BOOL
LookUpEntryProperties(
    PDB         pdb,
    TAGID       tiExe,
    BOOL*       pbLayers,
    BOOL*       pbShims,
    BOOL*       pbPatches,
    BOOL*       pbFlags,
    BOOL*       pbAppHelp,
    CSTRING&    strAppName
    );

void
UpdateControls(
    void
    );

BOOL
ShimFlagExistsInLayer(
    LPVOID      lpData,
    PLAYER_FIX  plf,
    TYPE        type
    );

BOOL
IsShimInlayer(
    PLAYER_FIX      plf,
    PSHIM_FIX       psf,
    CSTRING*        pstrCommandLine,
    CSTRINGLIST*    pstrlInEx
    );

BOOL
IsFlagInlayer(
    PLAYER_FIX      plf,
    PFLAG_FIX       pff,
    CSTRING*        pstrCommandLine         
    );

int CALLBACK
CompareItemsEx(
    LPARAM lParam1,
    LPARAM lParam2, 
    LPARAM lParam
    );

void
PreprocessForSaveAs(
    PDATABASE pDatabase
    );

BOOL
SaveListViewToFile(
    HWND    hwndList, 
    INT     iCols,    
    PCTSTR  pszFile,  
    PCTSTR  pszHeader
    );

BOOL
IsShimInEntry(
    PCTSTR      szShimName,
    PDBENTRY    pEntry
    );

void
ShowShimLog(
    void
    );

BOOL
ReplaceChar(
    PTSTR   pszString,
    TCHAR   chCharToFind,
    TCHAR   chReplaceBy
    );

int
CDECL
MSGF(
    HWND    hwndParent,
    PCTSTR  pszCaption,
    UINT    uType,
    PCTSTR  pszFormat,
    ...
    );

void 
Dbg(DEBUGLEVEL  debugLevel, 
    LPSTR       pszFmt 
    ...);

BOOL
GetDatabaseEntries(
    LPCTSTR     szFullPath,
    PDATABASE   pDataBase
    );


BOOL ReadMainDataBase();

BOOL SaveDataBase(
    PDATABASE   pDataBase,
    CSTRING&    strFileName);

LPVOID
FindFix(
    PCTSTR      pszFixName,
    TYPE        fixType,
    PDATABASE   pDataBase = NULL
    );


BOOL
GetFileName(
    HWND        hWnd,
    LPCTSTR     szTitle,
    LPCTSTR     szFilter,
    LPCTSTR     szDefaultFile, 
    LPCTSTR     szDefExt, 
    DWORD       dwFlags, 
    BOOL        bOpen, 
    CSTRING&    szStr,
    BOOL        bDoNotVerifySDB = FALSE
    );

BOOL
TestRun(
    PDBENTRY        pEntry, 
    CSTRING*        pszFile, 
    CSTRING*        pszCommandLine,
    HWND            hwndParent,
    CSTRINGLIST*    strlXML         = NULL
    );

UINT
LookupFileImage(
    HIMAGELIST  g_hImageList,
    LPCTSTR     szFilename,
    UINT        uDefault,
    UINT*       puArray,
    UINT        uArrayCount // No. of elements it can hold
    );

BOOL
InvokeCompiler(
    CSTRING& szInCommandLine
    );

BOOL
GetXML(
    PDBENTRY        pEntry,
    BOOL            bComplete, // Save just this entry or all entries following this.
    CSTRINGLIST*    strlXML,
    PDATABASE       pDataBase
    );

VOID
FormatVersion(
    ULONGLONG   ullBinVer,
    PTSTR       pszText,
    INT         chBuffSize
    );

BOOL
SaveDataBaseAs(
    PDATABASE pDataBase
    );


BOOL
SetDisabledStatus(
    HKEY   hKeyRoot, 
    PCTSTR pszGuid,
    BOOL   bDisable
    );

BOOL
RemoveEntry(
    PDATABASE   pDataBase,
    PDBENTRY    pEntryToRemove,
    PDBENTRY    pApp,
    BOOL        bRepaint = TRUE
    );

void
SetCaption(
    BOOL        bIncludeDataBaseName    = TRUE,
    PDATABASE   pDataBase               = NULL,
    BOOL        bOnlyTreeItem           = FALSE  
    );

void
InsertColumnIntoListView(
    HWND    hWnd,
    LPTSTR  lpszColumn,
    INT     iCol,
    DWORD   widthPercent
    );

BOOL
InstallDatabase(
    CSTRING&    strPath,    
    PCTSTR      szOptions,  
    BOOL        bShowDialog 
    );

void
FlushCache(
    void
    );

BOOL
DeleteAppHelp(
    PDATABASE   pDatabase,
    DWORD       nHelpID
    );

void
CenterWindow(
    HWND hParent,
    HWND hWnd
    );
BOOL
CheckIfConflictingEntry(
    PDATABASE   pDataBase,
    PDBENTRY    pEntry,
    PDBENTRY    pEntryBeingEdited,
    PDBENTRY*   ppEntryFound = NULL,
    PDBENTRY*   ppAppFound   = NULL
    );

PDBENTRY
AddExeInApp(
    PDBENTRY    pEntry,
    BOOL*       pbNew,
    PDATABASE   pDataBase
    );


BOOL
CloseDataBase(
    PDATABASE pDataBase
    );

BOOL
CheckAndSave(
    PDATABASE pDataBase
    );

void
EnableTabBackground(
    HWND hDlg
    );


void
TreeDeleteAll(
    HWND hwndTree
    );

BOOL
CloseAllDatabases(
    void
    );

INT_PTR
CALLBACK 
HandlePromptLayer(
    HWND    hdlg, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

INT_PTR
CALLBACK 
HandleConflictAppLayer(
    HWND    hdlg, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

BOOL
PasteSingleEntry(
    PDBENTRY    pEntryToPaste,
    PDATABASE   pDataBaseTo
    );

BOOL
PasteAllApps(
    PDATABASE pDataBaseTo
    );

INT
PasteSingleApp(
    PDBENTRY    pApptoPaste,
    PDATABASE   pDataBaseTo,
    PDATABASE   pDataBaseFrom,   
    BOOL        bAllExes,
    PCTSTR      szNewAppName = NULL
    );

BOOL
PasteAllLayers(
    PDATABASE pDataBaseTo
    );

INT
PasteLayer(
    PLAYER_FIX      plf,
    PDATABASE       pDataBaseTo,
    BOOL            bForcePaste     = FALSE,
    OUT PLAYER_FIX* pplfNewInserted = NULL,
    BOOL            bShow           = FALSE
    );

BOOL
PasteAppHelpMessage(
    PAPPHELP    pAppHelp,
    PDATABASE   pDataBaseTo,
    PAPPHELP*   ppAppHelpInLib = NULL
    );

INT
Tokenize(
    PCTSTR          szString,
    INT             cchLength,
    PCTSTR          szDelims,
    CSTRINGLIST&    strlTokens
    );

INT 
CopyShimFixList(
    PSHIM_FIX_LIST* ppsflDest,
    PSHIM_FIX_LIST* ppsflSrc
    );

void
ShowInlineHelp(
    LPCTSTR pszInlineHelpHtmlFile
    );

PTSTR
GetSpace(
    PTSTR   pszSpace, 
    INT     iSpaces, 
    INT     iBufSzie
    );

BOOL
ValidInput(
    PCTSTR  pszStr
    );

PDATABASE
GetCurrentDB(
    void
    );

BOOL
IsValidAppName(
    PCTSTR  pszAppName
    );

void
DisplayInvalidAppNameMessage(
    HWND hdlg
    );

#endif // _COMPATADMIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\acfileattr\attr.h ===
#ifndef _ATTR_H
#define _ATTR_H

#include "windows.h"

#include "acFileAttr.h"

#if DBG
    void LogMsgDbg(LPSTR pszFmt, ...);
    
    #define LogMsg  LogMsgDbg
#else
    #define LogMsg
#endif // DBG

struct tagFILEATTR;
struct tagFILEATTRMGR;

typedef struct tagFILEATTRVALUE {
    char*           pszValue;           // allocated
    DWORD           dwFlags;
    DWORD           dwValue;            // in case it has a DWORD value
    WORD            wValue[4];          // for Bin Ver cases
    WORD            wMask[4];           // for mask Bin Ver cases
} FILEATTRVALUE, *PFILEATTRVALUE;

typedef struct tagVERSION_STRUCT {
    PSTR                pszFile;                // the name of the file
    UINT                dwSize;                 // the size of the version structure
    PBYTE               VersionBuffer;          // the buffer filled by GetFileVersionInfo
    VS_FIXEDFILEINFO*   FixedInfo;
    UINT                FixedInfoSize;

} VERSION_STRUCT, *PVERSION_STRUCT;

typedef struct tagFILEATTRMGR {

    FILEATTRVALUE   arrAttr[VTID_LASTID - 2];
    VERSION_STRUCT  ver;
    BOOL            bInitialized;

} FILEATTRMGR, *PFILEATTRMGR;


typedef BOOL (*PFNQUERYVALUE)(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
typedef int  (*PFNBLOBTOSTRING)(BYTE* pBlob, char* pszOut);
typedef int  (*PFNDUMPTOBLOB)(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);

#define ATTR_FLAG_AVAILABLE     0x00000001
#define ATTR_FLAG_SELECTED      0x00000002

typedef struct tagFILEATTR {
    DWORD           dwId;
    char*           pszDisplayName;
    char*           pszNameXML;
    PFNQUERYVALUE   QueryValue;
    PFNBLOBTOSTRING BlobToString;
    PFNDUMPTOBLOB   DumpToBlob;
} FILEATTR, *PFILEATTR;



// query functions

BOOL QueryFileSize(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryModuleType(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryBinFileVer(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryBinProductVer(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileDateHi(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileDateLo(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileVerOs(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileVerType(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileCheckSum(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFilePECheckSum(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryCompanyName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryProductVersion(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryProductName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileDescription(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryFileVersion(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryOriginalFileName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryInternalName(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL QueryLegalCopyright(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);
BOOL Query16BitDescription(PFILEATTRMGR pMgr, PFILEATTRVALUE pFileAttr);


// dumping to blob functions

int DumpDWORD(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);
int DumpBinVer(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);
int DumpString(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);
int DumpUpToBinVer(DWORD dwId, PFILEATTRVALUE pFileAttr, BYTE* pBlob);



// blob to string functions:

int BlobToStringDWORD(BYTE* pBlob, char* pszOut);
int BlobToStringLong(BYTE* pBlob, char* pszOut);
int BlobToStringBinVer(BYTE* pBlob, char* pszOut);
int BlobToStringString(BYTE* pBlob, char* pszOut);
int BlobToStringUpToBinVer(BYTE* pBlob, char* pszOut);



#endif // _ATTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\compatadminver.h ===
//
// Normally when you make a change you change the 3rd digit in the version number,
// ie, COMPATADMIN_BIN_VERSION_DIGIT3 unless you are making major changes.
//
// Example: changing from 3.0.88.0 to 3.0.89.0
//

#define COMPATADMIN_BIN_VERSION_DIGIT1 3
#define COMPATADMIN_BIN_VERSION_DIGIT2 0

//
// Increase me when you update the code unless you are making major changes!
//
#define COMPATADMIN_BIN_VERSION_DIGIT3 96

#define COMPATADMIN_BIN_VERSION_DIGIT4 0

#define COMPATADMIN_BIN_VERSION COMPATADMIN_BIN_VERSION_DIGIT1,COMPATADMIN_BIN_VERSION_DIGIT2,COMPATADMIN_BIN_VERSION_DIGIT3,COMPATADMIN_BIN_VERSION_DIGIT4
#define COMPATADMIN_STRING_VERSION_HELPER(x) #x
#define COMPATADMIN_STRING_VERSION(x) COMPATADMIN_STRING_VERSION_HELPER(x)

#define COMPATADMIN_BIN_VERSION_HELP COMPATADMIN_BIN_VERSION_DIGIT1.COMPATADMIN_BIN_VERSION_DIGIT2.COMPATADMIN_BIN_VERSION_DIGIT3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\capphelpwizard.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    CAppHelpWizard.h

Abstract:

    Header for the Apphelp Wizard code. CAppHelpWizard.cpp
        
Author:

    kinshu created  July 2,2001

--*/



#ifndef  __CAPPHELPWIZARD_H
#define  __CAPPHELPWIZARD_H

/*++

    class CAppHelpWizard: public CShimWizard
    
	Desc:	The Apphelp wizard object. We create a object of this class and call 
            BeginWizard() to start the wizard
            
    Members:
        UINT        nPresentHelpId: Did we add an app  help message into the library during 
            the course of the wizard invocation? 
            If yes this will contain the number for that. If not this will be -1
            When we remove the apphelp message from the database (say when we do a testrun, then 
            we add a apphelp message into the database and we have to remove that when we
            end testrun), then we again set this to -1
--*/

class CAppHelpWizard: public CShimWizard {
public:

    
    UINT        nPresentHelpId;

    BOOL
    BeginWizard(
        HWND        hParent,
        PDBENTRY    pEntry,
        PDATABASE   m_pDatabase
        );

    CAppHelpWizard()
    {
        nPresentHelpId  = -1;
        
    }

};
 
BOOL 
CALLBACK 
SelectFiles(
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

BOOL 
CALLBACK 
GetAppInfo(
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

BOOL 
CALLBACK 
GetMessageType (
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

BOOL 
CALLBACK 
GetMessageInformation (
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

BOOL
OnAppHelpTestRun(
    HWND    hDlg
    );

BOOL
OnAppHelpFinish(
    HWND    hDlg,
    BOOL    bTestRun = FALSE
    );      

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\appcompat\tools\compatadminxp\compatadmin.cpp ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    CompatAdmin.cpp

Abstract:

    This module handles most of the GUI for the application. It contains the message loop and 
    WinMain
    
Notes:          
    
    1. Has a global try catch, so if the Program AVs we will get a "Out of Memory" Error
    2. This is a Unicode app
    3. The code was written with tab size of 4
    4. Please go through the data strctures and their explainations as in CompatAdmin.h
    5. The documentation in the code assumes that you are familiar with the basic understanding of 
        the SdbApis and the lay out of the xml that is compiled into the .sdb database format
    6. Tools/stuff you should use or know about:    
        a) shimdbc      :   Shim database compiler. Compiles a xml into database. Owner: markder, vadimb
        b) dumpsdb      :   Used to view a .sdb as a text file. Owner: dmunsil
        c) sdbapis      :   All our sdb apis. Owner: dmunsil
        d) shimengine   :   The shim infrastructure core component. Owner: clupu
    
Usage:
    
    CompatAdmin.exe [/x]. The /x switch is for enabling expert mode. In expert mode
    we show the non-general shims as well and the parameters for shims and flags can be 
    configured
    
Author:

    kinshu created  July 2, 2001
    
Revision History:
--*/

#include "precomp.h"
#include <richedit.h>

//////////////////////// Extern variables /////////////////////////////////////

extern DATABASE     GlobalDataBase;
extern PDATABASE    g_pPresentDataBase;
extern BOOL         g_bEntryConflictDonotShow;
extern HWND         g_hdlgSearchDB;

///////////////////////////////////////////////////////////////////////////////


//////////////////////// Defines //////////////////////////////////////////////

#define STR_NEW_LINE_CHARS  TEXT("\r\n")
#define STR_APPPATCH_CUSTOM TEXT("AppPatch\\Custom\\")

// Buffer allocation size in TCHARS for the common dialog that lets us open multiple files
#define MAX_BUFF_OPENMULTIPLE_FILES MAX_PATH * 10

// Width and height of the buttons in the toolbar
#define IMAGE_WIDTH   24
#define IMAGE_HEIGHT  24
    
// Number of buttons in the toolbar. This includes the separators as well.
#define BUTTON_COUNT  11

//
// Defines for the context menus (position)
#define MENU_CONTEXT_DATABASE       0 
#define MENU_CONTEXT_APP_LAYER      1
#define MENU_CONTEXT_FIX            2
#define MENU_CONTEXT_LIST           4
#define MENU_CONTEXT_DATABASE_ALL   5

// defines for the colums used in the event dialog
#define EVENTS_COLUMN_TIME  0
#define EVENTS_COLUMN_MSG   1

//
// Number of controls in the main window which have to be resized. This is passed as a
// paramreter to BeginDeferWindowPos()
#define MAIN_WINDOW_CONTROL_COUNT   6

// We need to cleanup if we are checking for leaks
#define HELP_BOUND_CHECK            1   

// Maximum number of chars that we show for the file name in MRU. Does not include the extension
#define MAX_FILE_SHOW           20

// Maximum number of chars that we show for the drive and dir of the path in MRU
#define MAX_DIR_SHOW            20

// Maximum length of a string that can be shown as the File menu MRU.
#define MAX_LENGTH_MRU_MENUITEM  (MAX_FILE_SHOW + MAX_DIR_SHOW + 4) // 4 is for the extension .sdb

// The redraw type passed to DeferWindowPos() in OnMoveSplitter()
#define REDRAW_TYPE SWP_NOZORDER | SWP_NOACTIVATE

///////////////////////////////////////////////////////////////////////////////


//////////////////////// Global Variables /////////////////////////////////////

//
// We are going to delete the contents of the entry tree by callign TreeDeleteAll().
// We need to handle this because we should not be processing any TVN_SELTCHANGE 
// messages when we are deleting the entry tree. If we have by mistake delete the contents 
// of the LPARAM of a entry tree and then we delete the entry tree, that item can get the 
// focus and then we will try to make use of the LPARAM of the tree item and this can cause
// an access violation as the item has been deleted already. As a general rule, delete 
// the tree item first and then delete the data structure that is referenced by some
// pointer that is in the LPARAM for the tree item
// 
BOOL        g_bDeletingEntryTree;

//
// If we have some wizard window open then we do not want that we should be able
// to change the present database by double clicking the search or query results
BOOL        g_bSomeWizardActive;

// The clipboad
CLIPBOARD   gClipBoard; 

//
// We do not want the installed database list to be updated when we are installing a 
// database in the process of test run
BOOL        g_bUpdateInstalledRequired = TRUE;

// The index of the item that is presently selected in the Contents List
INT         g_iContentsListSelectIndex = -1;

//
// This will contain the function pointer of the original tree view proc. We are subclassing
// both of the tree views
WNDPROC     g_PrevTreeProc = NULL;

//
// This will contain the function pointer of the original list view proc. We are subclassing
// the list views
WNDPROC     g_PrevListProc = NULL;

//
// The array of the keys on which we will be listening for changes. Used for automatic update of
// the per-user compatibility list and the installed databases list
HKEY        g_hKeyNotify[2];

// Event Handles to wait for the Per User and All Users settings to change
HANDLE      g_arrhEventNotify[2]; 

// Handle to the toolbar
HWND        g_hwndToolBar;   

// Stringlist that holds the most recently used files. 
CSTRINGLIST g_strlMRU;

// The name of the application  
TCHAR       g_szAppName[128];

// Misc. data to be passed to dialogs as arg (when we are already using the LPARAM)
TCHAR       g_szData[1024]; 

//The new URL should now point to the location from where we can get the SP3 
TCHAR       g_szW2KUrl[] = TEXT("http://www.microsoft.com/windows2000/downloads/tools/appcompat/");

// URL for the toolkit. Shown in the description window when we do not have any other description
// Bonus !
TCHAR       g_szToolkitURL[] = _T("http://msdn.microsoft.com/compatibility");

// Is service pack greater than 2
BOOL        g_fSPGreaterThan2;

// The accelerator handle
HACCEL      g_hAccelerator;

// Are we on Win2000
BOOL        g_bWin2K = FALSE;

//Specifies whether the contents of ClipBoard are because of cut or copy. 
BOOL        g_bIsCut = FALSE; 

// The module handle
HINSTANCE   g_hInstance;

// The handle to the main dialog window
HWND        g_hDlg;

// Handle to the window of the entry tree, displayed in the contents pane
HWND        g_hwndEntryTree;

// Handle to the window of the contents list, displayed in the contemts pane
HWND        g_hwndContentsList;

// Handle to the status bar
HWND        g_hwndStatus;

// Handle to In-place edit control for the DB tree and the contents list
HWND        g_hwndEditText;

//
// Handle to the image list. This image list is used by all except the matching wizard page,
// and the toolbar
HIMAGELIST  g_hImageList;

// BUGBUG: Bad stuff, use a map instead
UINT        g_uImageRedirector[1024];

// EXE selected in the Entry Tree 
PDBENTRY    g_pSelEntry;    

// First EXE of the  Selected App in the DataBase Tree
PDBENTRY    g_pEntrySelApp;

// Spefies if the contents list is visible, FALSE implies the entry tree is visible
BOOL        g_bIsContentListVisible;

//
// The width, height of the main dialog window. Used when we handle WM_SIZE
int         g_cWidth;
int         g_cHeight;

// The X position where the mouse was last pressed.
int         g_iMousePressedX;

// If the mouse is pressed: used when we handle the split bar
BOOL        g_bDrag;

// Whether the system apps, tree item has been expanded.
BOOL        g_bMainAppExpanded = FALSE;

// Used for giving default names to the .SDB files in the DataBase constructor
UINT        g_uNextDataBaseIndex = 1; 

// Used for painting the split bar.
RECT        g_rectBar;                

// The db tree that constitutes the root-pane. This is the LHS tree control
DatabaseTree DBTree;

//
// Used to tell if the description window is shown. Is true by default. User can make it 
// false using menu
BOOL        g_bDescWndOn = TRUE;

// The list control for the events dialog
HWND        g_hwndEventsWnd;

// The event count. This is used as the index into the event list view.
INT         g_iEventCount;

// Buffer used to update the content of the richedit description window
TCHAR       g_szDesc[1024];

// Handle to rich edit control
HWND        g_hwndRichEdit;

//
// The expert mode. Is the /x switch on? In expert mode the user can see all the shims and flags 
// and can change the paramters of the shims     
BOOL        g_bExpert; 

// Does the user have admin rights
BOOL        g_bAdmin = TRUE;

// The handle to the thread that handles the updates to the installed databases 
// and the per-user settings
HANDLE      g_hThreadWait;

// Help cookie that is returned while initializing and is used when uninitalizing
DWORD       g_dwCookie = 0;

//
// The path of CompatAdmin. This is required so that we can load the help file appropriately.
// Buffer size is made MAX_PATH + 1, becasue GetModuleFileName does not NULL terminate.
TCHAR    g_szAppPath[MAX_PATH + 1];

// The critical section that controls which call to ShowMainEntries(); gets through.
CRITICAL_SECTION    g_critsectShowMain;

// The critical section that guards the variable that tells us if somebody is already trying to 
// populate the global app list.
CRITICAL_SECTION    s_csExpanding;

//
// The critical section that protects the installed database datastructure.
// The installed datastructure is iterated when we are querying the datastructure and 
// the query is done in a separate thread
CRITICAL_SECTION    g_csInstalledList;

// Is somebody trying to populate the main database entries
BOOL    g_bExpanding = FALSE;

// The presently selected database
PDATABASE g_pPresentDataBase;

// Height and width of the event window
static int          s_cEventWidth;
static int          s_cEventHeight;

// The imagelist for the toolbar
static HIMAGELIST   s_hImageListToolBar;

// The hot imagelist for the toolbar
static HIMAGELIST   s_hImageListToolBarHot;

// If we are about to exit CompatAdmin. It will surely exit now.
static BOOL         s_bProcessExiting; 

///////////////////////////////////////////////////////////////////////////////

//////////////////////// Function Declarations ////////////////////////////////

INT
GetContentsListIndex(
    HWND    hwndList,
    LPARAM  lParam
    );
void
HandleMRUActivation(
    WPARAM wCode
    );

BOOL
EndListViewLabelEdit(
    LPARAM lparam
    );

void
OnEntryTreeSelChange(
    LPARAM lParam
    );

void
ShowExcludeStatusMessage(
    HWND    hwndTree,
    HTREEITEM   hItem
    );

void
ShowIncludeStatusMessage(
    HWND    hwndTree,
    HTREEITEM   hItem
    );

void
ShowEventsWindow(
    void
    );

void
SetStatusDBItems(
    IN  HTREEITEM hItem
    );

void
OnExitCleanup(
    void
    );

void
EventsWindowSize(
    HWND    hDlf
    );

void
ShowHelp(
    HWND    hdlg,
    WPARAM  wCode
    );

INT_PTR 
CALLBACK
EventDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT
ShowMainEntries(
    HWND hdlg
    );

BOOL
HandleDBTreeSelChange(
    HTREEITEM hItem
    );

void
CopyToClipBoard(
    WPARAM wCode
    );

void
LuapCleanup(
    void
    );

BOOL
LoadInstalledDataBases(
    void
    );

INT
LoadSpecificInstalledDatabaseGuid(
    PCTSTR  pszGuid
    );

void
ContextMenuExeTree(
    LPARAM lParam
    );

void
SetTBButtonStatus(
    HWND hwndTB
    );

void
SetTBButtonStatus(
    HWND hwndTB,
    HWND hwndControl
    );

void
DrawSplitter(
    HWND hdlg
    );

BOOL
AddRegistryKeys(
    void
    );

void
ShowToolBarToolTips(
    HWND    hdlg,
    LPARAM  lParam
    );

INT_PTR 
CALLBACK
QueryDBDlg(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

DWORD 
WINAPI
ThreadEventKeyNotify(
    PVOID pVoid
    );

void
PasteFromClipBoard(
    void
    );

void
AddMRUToFileMenu(
    HMENU  hmenuFile 
    );

LRESULT 
CALLBACK 
ListViewProc(
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

LRESULT 
CALLBACK 
TreeViewProc(
    HWND    hWnd, 
    UINT    uMsg, 
    WPARAM  wParam, 
    LPARAM  lParam
    );

void
LoadDisplaySettings(
    void
    );

void 
OnMoveSplitter(
    HWND    hwnd,
    LPARAM  lParam,
    BOOL    bDoTheDrag,
    INT     iDiff
    );

INT_PTR 
CALLBACK
MsgBoxDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
CheckProperSP(
    void
    );

void
LoadPerUserSettings(
    void
    );

void
PopulateContentsList(
    HTREEITEM hItem
    );

void
CreateNewAppHelp(
    void
    );

void
ModifyAppHelp(
    void
    );

void
CreateNewAppFix(
    void
    );

void
ModifyAppFix(
    void
    );

void
CreateNewLayer(
    void
    );

void
OnDelete(
    );
void
CreateNewDatabase(
    void
    );

void
DatabaseSaveAll(
    void
    );

void
OnDatabaseClose(
    void
    );

void
ChangeEnableStatus(
    void
    );

BOOL
ModifyLayer(
    void
    );

void
OnRename(
    void
    );

void
ProcessSwitches(
    void
    );

INT_PTR 
CALLBACK
ShowDBPropertiesDlgProc(
    HWND   hdlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

///////////////////////////////////////////////////////////////////////////////

void
HandlePopUp(
    IN  HWND   hDlg,
    IN  WPARAM wParam, 
    IN  LPARAM lParam
    )
/*++
    HandlePopUp
    
    Desc:   Handles pop down menu (WM_INITMENUPOPUP). Disables items as necessary
    
    Params:
        IN  HWND   hDlg:    The window that received WM_INITMENUPOPUP     
        IN  WPARAM wParam:  As with WM_INITMENUPOPUP
        IN  LPARAM lParam:  As with WM_INITMENUPOPUP
        
    Notes:  The tool bar buttons are NOT diasbled/enabled in this routine. For that the function
            SetTBButtonStatus() is used
--*/
{                                      
    HWND            hwndFocus           = GetFocus();
    PDATABASE       pCurrentSelectedDB  = GetCurrentDB();

    //
    // SelectAll, Invert Selection
    //
    int     iEnable = MF_GRAYED;
    HMENU   hMenu   = (HMENU)wParam;

    if (g_bIsContentListVisible
        && ListView_GetItemCount(g_hwndContentsList) > 0 
        && hwndFocus == g_hwndContentsList) {

        iEnable = MF_ENABLED;
    }

    EnableMenuItem(hMenu, ID_EDIT_SELECTALL, iEnable);
    EnableMenuItem(hMenu, ID_EDIT_INVERTSELECTION, iEnable);

    //
    // Change Status menu item
    //
    HTREEITEM   hItem               = TreeView_GetSelection(DBTree.m_hLibraryTree);
    TYPE        typeSelectedItemDB  = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItem);

    MENUITEMINFO Info = {0};

    Info.cbSize = sizeof(MENUITEMINFO);
    Info.fMask  = MIIM_STRING;
    

    if (g_pSelEntry && g_pSelEntry->bDisablePerMachine == FALSE) {
        Info.dwTypeData = GetString(IDS_DISABLE);
    } else {
        Info.dwTypeData = GetString(IDS_ENABLE);
    }

    SetMenuItemInfo(hMenu, ID_FIX_CHANGEENABLESTATUS, MF_BYCOMMAND, &Info);

    //
    // Set the text for edit/add apphelp
    //
    if (g_pSelEntry && g_pSelEntry->appHelp.bPresent) {
        Info.dwTypeData = GetString(IDS_EDITAPPHELP);
    } else {
        Info.dwTypeData = GetString(IDS_CREATEAPPHELP);
    }

    SetMenuItemInfo(hMenu, ID_MODIFY_APPHELPMESSAGE, MF_BYCOMMAND, &Info);

    //
    // Set the text for edit/add app fix
    //
    if (g_pSelEntry && 
        (g_pSelEntry->pFirstFlag 
         || g_pSelEntry->pFirstLayer 
         || g_pSelEntry->pFirstPatch 
         || g_pSelEntry->pFirstShim)) {

        Info.dwTypeData = GetString(IDS_EDITFIX);

    } else {
        Info.dwTypeData = GetString(IDS_CREATEFIX);
    }

    SetMenuItemInfo(hMenu, ID_MODIFY_APPLICATIONFIX, MF_BYCOMMAND, &Info);

    //
    // Set the  text and id for install/uninstall menu item
    //
    Info.fMask = MIIM_STRING;

    if (pCurrentSelectedDB && pCurrentSelectedDB->type != DATABASE_TYPE_WORKING) {
        Info.dwTypeData = GetString(IDS_MENU_UINSTALL);
    } else {
        Info.dwTypeData = GetString(IDS_MENU_INSTALL);
    }

    SetMenuItemInfo(hMenu, ID_DATABASE_INSTALL_UNINSTALL, MF_BYCOMMAND, &Info);

    BOOL bReadOnly = (pCurrentSelectedDB && pCurrentSelectedDB->type != DATABASE_TYPE_WORKING);

    if (pCurrentSelectedDB == NULL) {
        bReadOnly = TRUE;
    }

    //
    // Close
    //
    iEnable = (pCurrentSelectedDB && pCurrentSelectedDB->type == DATABASE_TYPE_WORKING) ? MF_ENABLED : MF_GRAYED ;
    EnableMenuItem(hMenu, ID_DATABASE_CLOSE, iEnable);

    //
    // Disable the items for the global and Installed databases
    //
    iEnable = (bReadOnly) ? MF_GRAYED : MF_ENABLED;
    
    EnableMenuItem(hMenu, ID_FILE_SAVE, iEnable);
    EnableMenuItem(hMenu, ID_FILE_SAVEAS, iEnable);
    
    EnableMenuItem(hMenu, ID_FIX_CREATEANAPPLICATIONFIX, iEnable);
    EnableMenuItem(hMenu, ID_FIX_CREATENEWLAYER, iEnable);

    //
    // AppHelp mechanism is not supported in win2k
    //
    EnableMenuItem(hMenu, 
                   ID_FIX_CREATEANEWAPPHELPMESSAGE, 
                   (g_bWin2K) ? MF_GRAYED : iEnable);

    //
    // Save all and close all
    //
    if (!bReadOnly || typeSelectedItemDB == TYPE_GUI_DATABASE_WORKING_ALL) {
        iEnable =  MF_ENABLED;
    } else {
        iEnable = MF_GRAYED;
    }

    EnableMenuItem(hMenu, ID_DATABASE_SAVEALL, iEnable);
    EnableMenuItem(hMenu, ID_DATABASE_CLOSEALL, iEnable);

    //
    // Paste menu item
    //
    if (bReadOnly) {
        EnableMenuItem(hMenu, ID_EDIT_PASTE, MF_GRAYED);
    } else {        
         
        int iEnablePaste =  (gClipBoard.pClipBoardHead) ? MF_ENABLED : MF_GRAYED;

        if (iEnablePaste == MF_ENABLED) {
            //
            // Check if the item that we have in the clipboard can be pasted in the item that we have got selected
            //
            if (gClipBoard.type == FIX_SHIM || gClipBoard.type == FIX_FLAG) {
        
                //
                // The focus should be on the db tree and a layer should be selected 
                // in the db tree or the focus should be on the contents list and then
                // the root of all layes should be selected in the dbtree or a layer should
                // be selected.
                //
                if (hwndFocus == DBTree.m_hLibraryTree 
                    && typeSelectedItemDB == FIX_LAYER) {
    
                    iEnablePaste = MF_ENABLED;
    
                } else if (hwndFocus == g_hwndContentsList 
                           && (typeSelectedItemDB == FIX_LAYER
                               || typeSelectedItemDB == TYPE_GUI_LAYERS)) {
                    //
                    // We have focus on the contents list, we can paste shims if a layer is selected
                    // or the root of all layers is selected in the db tree
                    //
                    iEnablePaste = MF_ENABLED;
    
                } else {
                    iEnablePaste = MF_GRAYED;
                }
    
            } else if (gClipBoard.type == FIX_LAYER || gClipBoard.type == TYPE_GUI_LAYERS) {
                //
                // In the db tree we should have a database or the all layers item selected
                //
                if (typeSelectedItemDB == TYPE_GUI_LAYERS || typeSelectedItemDB == DATABASE_TYPE_WORKING) {
                    iEnablePaste = MF_ENABLED;
                } else {
                    iEnablePaste = MF_GRAYED;
                }
            } else if (gClipBoard.type == TYPE_ENTRY) {
                //
                // If we have copied an entry from the entry tree, in the db tree the focus can be 
                // on a database, an application, or all application node
                //
                if (typeSelectedItemDB == DATABASE_TYPE_WORKING 
                    || (typeSelectedItemDB == TYPE_ENTRY && gClipBoard.SourceType == ENTRY_TREE)
                    || typeSelectedItemDB == TYPE_GUI_APPS) {
    
                    iEnablePaste = MF_ENABLED;
                } else {
                    iEnablePaste = MF_GRAYED;
                }
            }
        }

        EnableMenuItem(hMenu, ID_EDIT_PASTE, iEnablePaste);
    }
    
    BOOL      bEnableCopy   = FALSE, bEnableModify = FALSE;
    HWND      hwndGetFocus  = GetFocus();
    HTREEITEM hItemSelected = NULL;
    TYPE      type          = TYPE_UNKNOWN;

    //
    // First get the type of the selected tree item and the corresponding type
    //
    if (hwndGetFocus == DBTree.m_hLibraryTree || hwndFocus == g_hwndEntryTree) {
        //
        // For the db tree or the entry tree
        //
        hItemSelected = TreeView_GetSelection(hwndGetFocus);
        type          = (TYPE)GetItemType(hwndGetFocus, hItemSelected);

    } else {
        //
        // For the contents list, the tree item is the item that is selected in the db tree
        //
        hItemSelected = TreeView_GetSelection(DBTree.m_hLibraryTree);
        type = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItemSelected);
    }

    //
    // Copy will be enabled only if the presently selected item is copy-able
    //
    if (hwndGetFocus == DBTree.m_hLibraryTree) {
        //
        // For the db tree
        //
        if (hItemSelected) {

            if (type == TYPE_ENTRY 
                || type == FIX_LAYER 
                || type == FIX_SHIM 
                || type == FIX_FLAG
                || type == TYPE_GUI_APPS 
                || type == TYPE_GUI_LAYERS) {
                    
                bEnableCopy = TRUE;
            }
        }

    } else if (hwndGetFocus == g_hwndEntryTree) {
        //
        // For the entry tree
        //  
        if (hItemSelected) {

            if (type == TYPE_ENTRY) {
                bEnableCopy = TRUE;
            }
        }

    } else if (hwndFocus == g_hwndContentsList) {
        //
        // For the contents list
        //
        if (type == TYPE_GUI_APPS 
            || type == TYPE_GUI_LAYERS
            || type == FIX_LAYER
            || type == TYPE_GUI_SHIMS) {         
            //
            // Make sure atleast one is selected
            //
            if (ListView_GetSelectedCount(g_hwndContentsList) > 0) {
                bEnableCopy = TRUE;
            }
        }
    }

    iEnable = (bEnableCopy && pCurrentSelectedDB) ? MF_ENABLED : MF_GRAYED;
    EnableMenuItem(hMenu, ID_EDIT_COPY, iEnable);

    iEnable = (bReadOnly) ? MF_GRAYED : iEnable;

    //
    // Cut Menu
    //
    if (bReadOnly) {
        iEnable = MF_GRAYED;
    }

    if (hwndFocus == DBTree.m_hLibraryTree) {

        if (type == TYPE_GUI_SHIMS || type == FIX_SHIM || type == FIX_FLAG) {
            iEnable = MF_GRAYED;
        }
    } else if (hwndFocus == g_hwndContentsList) {
        //
        // Cut is not available for the shims
        //
        if (type == TYPE_GUI_SHIMS || type == FIX_LAYER) {
            iEnable = MF_GRAYED;
        }
    }

    EnableMenuItem(hMenu, ID_EDIT_CUT, iEnable);

    //
    // Delete Menu
    //            
    if (hwndFocus == g_hwndEntryTree) {
        //
        // For the entry tree, If the db is not readonly, everything except the commandline for the shim and the 
        // in-exclude items are prone to deletion
        //
        if (bReadOnly 
            || type == TYPE_GUI_COMMANDLINE 
            || type == TYPE_GUI_EXCLUDE 
            || type == TYPE_GUI_INCLUDE
            || g_pSelEntry == NULL) { 

            EnableMenuItem(hMenu, ID_EDIT_DELETE, MF_GRAYED); 

        } else {
            EnableMenuItem(hMenu, ID_EDIT_DELETE, MF_ENABLED);
        }

    } else {
        //
        // If we are not on the entry tree, then what can be cut can be deleted as well
        //
        EnableMenuItem(hMenu, ID_EDIT_DELETE, iEnable);
    }

    EnableMenuItem(hMenu, ID_MODIFY_APPLICATIONFIX,     MF_GRAYED);
    EnableMenuItem(hMenu, ID_MODIFY_APPHELPMESSAGE,     MF_GRAYED);
    EnableMenuItem(hMenu, ID_MODIFY_COMPATIBILITYMODE,  MF_GRAYED);

    //
    // Modify Menu
    //
    if (!bReadOnly && hwndGetFocus == g_hwndEntryTree && type == TYPE_ENTRY) {

        EnableMenuItem(hMenu, ID_MODIFY_APPLICATIONFIX, MF_ENABLED);

        //
        // AppHelp mechanism is not supported in win2k
        //
        EnableMenuItem(hMenu, 
                       ID_MODIFY_APPHELPMESSAGE, 
                       (g_bWin2K) ? MF_GRAYED : MF_ENABLED);
    }

    if (!bReadOnly && hwndGetFocus == DBTree.m_hLibraryTree && type == FIX_LAYER) {
        EnableMenuItem(hMenu, ID_MODIFY_COMPATIBILITYMODE,  MF_ENABLED);
    }

    //
    // Install / Un-install menu should be enabled iff we are not on the system db and g_pPresentDatabase is valid
    //
    iEnable = (pCurrentSelectedDB && (pCurrentSelectedDB->type != DATABASE_TYPE_GLOBAL)) ?  MF_ENABLED : MF_GRAYED;
    EnableMenuItem(hMenu, ID_DATABASE_INSTALL_UNINSTALL, iEnable);

    //
    // If no entry has been selected
    //
    iEnable = (g_pSelEntry == NULL) ? MF_GRAYED : MF_ENABLED;

    EnableMenuItem(hMenu, ID_FIX_CHANGEENABLESTATUS, iEnable);
    EnableMenuItem(hMenu, ID_FIX_EXECUTEAPPLICATION, iEnable);

    //
    // Rename
    //
    iEnable = MF_GRAYED;

    if (!bReadOnly && (hwndGetFocus == DBTree.m_hLibraryTree)) {

        if (type == TYPE_ENTRY || type == FIX_LAYER || type == DATABASE_TYPE_WORKING) {
            iEnable = MF_ENABLED;
        }

    } else if (!bReadOnly && (hwndGetFocus == g_hwndContentsList)) {

        if (type == TYPE_GUI_APPS 
            || type == TYPE_GUI_LAYERS) {

            iEnable = MF_ENABLED;
        }
    }

    EnableMenuItem(hMenu, ID_EDIT_RENAME, iEnable);

    //
    // Configure LUA. Can be true when on entry-fix only
    //
    iEnable = !bReadOnly 
                && (hwndFocus == g_hwndEntryTree) 
                && (type == TYPE_ENTRY)  
                && IsLUARedirectFSPresent(g_pSelEntry) ? MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, ID_EDIT_CONFIGURELUA, iEnable);

    //
    // The db properties. We do not want this to be enabled, if we are on the
    // system database and somebody else is trying to load the exe entries of the 
    // system datbase.
    // The reason is that for showing the properties we will
    // have to load the system database exe entries and we do not want 2 threads to load
    // the system database entries
    //
    (pCurrentSelectedDB && !(pCurrentSelectedDB->type == DATABASE_TYPE_GLOBAL && g_bExpanding)) ? 
        (iEnable) = MF_ENABLED : MF_GRAYED;

    EnableMenuItem(hMenu, ID_FILE_PROPERTIES, iEnable);
}

void
DoInstallUnInstall(
    void
    )
/*++
    DoInstallUninstall

	Desc:	Will install or uinstall the presently selected database, depending
            upon if the present database is a workign database or an installed
            database

	Params:
        void

	Return:
        void
--*/
{
    
    BOOL        bReturn             = FALSE;
    PDATABASE   pDatabaseTemp       = NULL;
    PDATABASE   pPresentDatabase    = GetCurrentDB();

    if (pPresentDatabase == NULL) {
        Dbg(dlError, "[DoInstallUnInstall], pPresentDatabase is NULL %d ");
        return;
    }

    //
    // Non admins cannot do a install-uintsall because we need to invoke 
    // sdbinst.exe and sdbinst.exe cannot be invoked if we
    // do not have admin rights
    //
    if (g_bAdmin == FALSE) {

        MessageBox(g_hDlg, 
                   GetString(IDS_ERRORNOTADMIN), 
                   g_szAppName, 
                   MB_ICONINFORMATION);
        return;
    }
     
    if (pPresentDatabase->type == DATABASE_TYPE_INSTALLED) {

        //
        // This will uninstall the database
        //
        bReturn =  InstallDatabase(CSTRING(pPresentDatabase->strPath), 
                                   TEXT("-u -q"), 
                                   TRUE);

        if (bReturn) {

            pDatabaseTemp = InstalledDataBaseList.FindDB(pPresentDatabase);

            if (pDatabaseTemp) {
                DBTree.RemoveDataBase(pDatabaseTemp->hItemDB, DATABASE_TYPE_INSTALLED, FALSE);
                InstalledDataBaseList.Remove(pDatabaseTemp);
            } else {
                assert(FALSE);
            }
        }

    } else {

        //
        // Check if we have the complete path of the database, that is this has at least been saved once earlier
        // Also check if this is presently dirty, we prompt the user to save the database
        //
        if (NotCompletePath(pPresentDatabase->strPath) || 
            pPresentDatabase->bChanged) {

            MessageBox(g_hDlg,
                       GetString(IDS_NOTSAVEDBEFOREINSTALL),
                       g_szAppName,
                       MB_ICONINFORMATION);
            return;
        }

        //
        // Install the database
        //
        bReturn = InstallDatabase(CSTRING(pPresentDatabase->strPath), 
                                  TEXT("-q"), 
                                  TRUE);

        if (bReturn == TRUE) {
            //
            // Check if we have this database already in the DB tree view
            //
            pDatabaseTemp = InstalledDataBaseList.FindDBByGuid(pPresentDatabase->szGUID);

            if (pDatabaseTemp) {
                //
                // Remove the pre-exising database
                //
                DBTree.RemoveDataBase(pDatabaseTemp->hItemDB, DATABASE_TYPE_INSTALLED, FALSE);
                InstalledDataBaseList.Remove(pDatabaseTemp);
            }

            //
            // Load the newly installed database
            //
            LoadSpecificInstalledDatabaseGuid(pPresentDatabase->szGUID);
        }
    }

    SetFocus(g_hDlg);
}

BOOL 
SearchGroupForSID(
    IN  DWORD dwGroup, 
    OUT BOOL* pfIsMember
    )
/*++
    SearchGroupForSID

	Desc:	Checks if the current user is a part of a group 

	Params:
        IN  DWORD dwGroup:      Is the user a part of this group
        
        OUT BOOL* pfIsMember:   Will be true if the user is a member of the specified group
            FALSE otherwise

	Return: 
        TRUE:   The value in pfIsMember is valid, the function executed successfully
        FALSE:  Otherwise
--*/
{
    PSID                     pSID       = NULL;
    SID_IDENTIFIER_AUTHORITY SIDAuth    = SECURITY_NT_AUTHORITY;
    BOOL                     fRes       = TRUE;

    if (!AllocateAndInitializeSid(&SIDAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  dwGroup,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  0,
                                  &pSID)) {

        fRes = FALSE;
    }

    if (!CheckTokenMembership(NULL, pSID, pfIsMember)) {
        fRes = FALSE;
    }

    if (pSID) {
        FreeSid(pSID);
        pSID = NULL;
    }
    
    return fRes;
}

BOOL 
IsAdmin(
    OUT BOOL* pbGuest
    )
/*++

    IsAdmin 

	Desc:	Checks if the current user has administrative rights

	Params: 
        OUT BOOL* pbGuest: Is this is a guest account

	Return:
        TRUE:   The current user has admin rights
        FALSE:  Otherwise
--*/
{
    BOOL bIsAdmin = FALSE, bReturn = TRUE;

    if (pbGuest) {
        *pbGuest = TRUE;
    }

    bReturn =   SearchGroupForSID(DOMAIN_ALIAS_RID_ADMINS, &bIsAdmin);

    if (pbGuest) {
        bReturn &=  SearchGroupForSID(DOMAIN_ALIAS_RID_GUESTS, pbGuest);
    }

    if (bReturn == FALSE) {
        Dbg(dlError, "[IsAdmin] SearchGroupForSID failed");

        return FALSE;
    }

    return (bIsAdmin);
}
     

void
SetCaption(
    IN  BOOL        bIncludeDataBaseName,   // (TRUE)
    IN  PDATABASE   pDataBase,              // (NULL)
    IN  BOOL        bOnlyTreeItem           // (FALSE)
    )

/*++
    SetCaption
    
    Desc:   Sets the caption of the main dialog. It may also set the text of the 
            database item in the tree if it is needed. 
            This will be needed when we have 
            a) Changed the name of the database
            b) We have changed the "save" status of the database so the "*" will 
                either need to be added or removed.
                
    Params:
        IN  BOOL        bIncludeDataBaseName (TRUE): Should the name of the database be
            included in the caption? This will be false when we have focus on say the 
            "Installed databases" or "Working databases" or "Per-User Settings" tree items
            in the database tree (lhs)
            
        IN  PDATABASE   pDataBase (NULL): If this is NULL, we will set caption 
            for the present database. Note that in some circumstances like when 
            we have the focus on "Installed databases" or "Working databases" 
            or "Per-User Settings" tree items in the database tree (lhs), 
            g_pPresentDataBase will be NULL.
            
        IN  BOOL        bOnlyTreeItem (FALSE): Do we only want to change the text for
            the database tree item? This will be true when we handle rename for 
            the database. This is used when we do a cut and we only want to indicate that 
            the database from which we did a cut has changed by changing its tree label. 
            At the time of cut our selected database will be the database 
            in which we are doing the paste and we do not want to change the window caption
--*/
{
    CSTRING strDefaultCaption(IDS_DEFCAPTION);

    if (pDataBase == NULL) {
        pDataBase  = g_pPresentDataBase;
    }

    if (bIncludeDataBaseName) {

        CSTRING strCaption;
        CSTRING strDBItemCaption;

        if (pDataBase && (pDataBase->type == DATABASE_TYPE_WORKING)) {
    
            if (pDataBase->bChanged) {
                
                strCaption.Sprintf(TEXT("%s - %s [%s] *"),
                                   strDefaultCaption.pszString,
                                   pDataBase->strName.pszString,
                                   pDataBase->strPath.pszString);

                strDBItemCaption.Sprintf(TEXT("%s [%s] *"),
                                         pDataBase->strName.pszString,
                                         pDataBase->strPath.pszString);

            } else {

                strCaption.Sprintf(TEXT("%s - %s [%s]"),
                                   strDefaultCaption.pszString,
                                   pDataBase->strName.pszString,
                                   pDataBase->strPath.pszString);

                strDBItemCaption.Sprintf(TEXT("%s [%s]"),
                                         pDataBase->strName.pszString,
                                         pDataBase->strPath.pszString);

            }

            //
            // Change the text for the database in the DB Tree
            //
            TVITEM Item;

            Item.mask       = TVIF_TEXT;
            Item.pszText    = strDBItemCaption;
            Item.hItem      = pDataBase->hItemDB;

            TreeView_SetItem(DBTree.m_hLibraryTree, &Item);

            if (bOnlyTreeItem) {
                return;
            }

        } else if (pDataBase && (pDataBase->type == DATABASE_TYPE_INSTALLED)) {

            strCaption.Sprintf(TEXT("%s - %s "), strDefaultCaption.pszString, 
                               GetString(IDS_CAPTION2));

            strCaption.Strcat(GetString(IDS_READONLY));

        } else if (pDataBase && (pDataBase->type == DATABASE_TYPE_GLOBAL)) {

            strCaption.Sprintf(TEXT("%s - %s "), strDefaultCaption.pszString, 
                               GetString(IDS_CAPTION3));

            strCaption.Strcat(GetString(IDS_READONLY));
        }
    
        SetWindowText(g_hDlg, strCaption);
        
    } else {
        //
        // The focus is on one of the items for which the caption of the 
        // main dialog should be the name of the app only. e.g. of such items
        // are: The "System Database" item, the "Installed Databases" item etc. 
        //
        SetWindowText(g_hDlg, (LPCTSTR)strDefaultCaption);
    }
}

void
Dbg(
    IN  DEBUGLEVEL  debugLevel,
    IN  LPSTR       pszFmt
    ...
    )
/*++
    LogMsg
    
    Desc:   Debugging spew
    
    Params:
        IN  DEBUGLEVEL  debugLevel: The debugging level. See values in DEBUGLEVEL enum
        IN  LPSTR pszFmt          : Format string that has to be passed to va_start
    
    Return:
        void
--*/
{   
    K_SIZE  k_sz        = 1024;
    CHAR    szMessage[k_sz];
    va_list arglist;

    va_start(arglist, pszFmt);
    StringCchVPrintfA(szMessage, k_sz, pszFmt, arglist);

    va_end(arglist);

    switch (debugLevel) {
        case dlPrint:
            DbgPrint("[MSG ] ");
            break;

        case dlError:
            DbgPrint("[FAIL] ");
            break;

        case dlWarning:
            DbgPrint("[WARN] ");
            break;

        case dlInfo:
            DbgPrint("[INFO] ");
            break;

        default:
            DbgPrint("[XXXX] ");
            break;
        }
    
    DbgPrint(szMessage);
    DbgPrint("\n");
}


void
InsertColumnIntoListView(
    IN  HWND   hWnd,
    IN  LPTSTR lpszColumn,
    IN  INT    iCol,
    IN  DWORD  widthPercent
    )
/*++

    InsertColumnIntoListView
    
	Desc:	Inserts a new column to the list view

	Params:
        IN  HWND   hWnd:            Handle to the list view
        IN  LPTSTR lpszColumn:      The heading of the column to be added
        IN  INT    iCol:            The sub item, first is 0
        IN  DWORD  widthPercent:    The percentage width of this column

	Return:
        void
--*/
{
    LVCOLUMN  lvc;
    RECT      rcClient;
    DWORD     width;

    GetWindowRect(hWnd, &rcClient);
    
    width = rcClient.right - rcClient.left - GetSystemMetrics(SM_CXVSCROLL);
    
    width = width * widthPercent / 100;
    
    lvc.mask     = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    lvc.fmt      = LVCFMT_LEFT;
    lvc.iSubItem = iCol;
    lvc.cx       = width;
    lvc.pszText  = lpszColumn;
    
    ListView_InsertColumn(hWnd, iCol, &lvc);
}

UINT
LookupFileImage(
    IN      HIMAGELIST hImageList,
    IN      LPCTSTR szFilename,
    IN      UINT    uDefault,
    IN  OUT UINT    *puArray,
    IN      UINT    uArrayCount
    )
/*++ 

    <TODO>: Re-write this code to use a map
    
    LookupFileImage

	Desc:  Adds the icon for the  file szFilename in imagelist hImageList

	Params:
        IN      HIMAGELIST hImageList:  The imagelist in which we want to add the
            icon for the file
            
        IN      LPCTSTR szFilename:     Path of the file
        IN      UINT    uDefault:       Default icon to be loaded if no icon is found
        IN  OUT UINT    *puArray:       The array that stores the mapping between the 
            index of the icon in the system imagelist and that in the imagelist specified
            by hImageList. puArray[X] == A means that the image with Info.iIcon is stored 
            at index A in the local imagelist hImageList. It is assumed that caller 
            will have a puArray, hImageList pair
        
        IN      UINT    uArrayCount:    Number of elements that can be stored in
            puArray

	Return: Index of the image in hImageList
--*/
{
    SHFILEINFO  Info;
    HIMAGELIST  hList;
    UINT        uImage = 0;
    INT         iPos = 0;

    ZeroMemory(&Info, sizeof(Info));

    hList = (HIMAGELIST)SHGetFileInfo(szFilename,
                                      FILE_ATTRIBUTE_NORMAL,
                                      &Info,
                                      sizeof(Info),
                                      SHGFI_ICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES);

   if (hList && Info.hIcon) {

        if (puArray == NULL || Info.iIcon >= uArrayCount) {
            uImage = ImageList_AddIcon(hImageList, Info.hIcon);
            goto End;
        }

        if (puArray[Info.iIcon] == 0) {

             iPos = ImageList_AddIcon(hImageList, Info.hIcon);

             if (iPos != -1) {
                 puArray[Info.iIcon] = iPos;
             }
        }

        uImage = puArray[Info.iIcon];

    } else {
        uImage = uDefault;
    }

End:

    if (Info.hIcon) {
        DestroyIcon(Info.hIcon);
    }

    ImageList_Destroy(hList);

    return uImage;
}

void
AddSingleEntry(
    IN  HWND        hwndTree,
    IN  PDBENTRY    pEntry
    )
/*++
    
    AddSingleEntry
    
    Desc:   Adds a single exe entry to the Exe Tree.
            Entries are sorted by name in the tree
    
    Params:
        IN  HWND        hwndTree:   The entry tree, this should be g_hwndEntryTree always.
        IN  PDBENTRY    pEntry:     The entry that has to be shown in the entry tree
        
    Notes:  The entry tree will eventually show all the entries for an app.
            The entries are sorted by name in non-descending order
--*/
{
    HTREEITEM       hItemExe;
    HTREEITEM       hMatchItem;
    HTREEITEM       hItemMatchingFiles;
    HTREEITEM       hItemShims;
    HTREEITEM       hItemSingleShim;
    PMATCHINGFILE   pMatch;
    TVINSERTSTRUCT  is;
    TCHAR           szText[MAX_PATH];
    UINT            uImage; // Image to be displayed in the tree

    if (hwndTree == NULL || pEntry == NULL) {
        Dbg(dlError, "[AddSingleEntry] Invalid arguments");
        return;
    }
    
    *szText = 0;

    SafeCpyN(szText, (LPCTSTR)pEntry->strExeName, ARRAYSIZE(szText));
    
    //
    // Get the image for the entry
    //
    if (pEntry->bDisablePerUser || pEntry->bDisablePerMachine) {
        uImage =IMAGE_WARNING;
    } else {

        uImage = LookupFileImage(g_hImageList, 
                                 pEntry->strExeName,
                                 IMAGE_APPLICATION, 
                                 g_uImageRedirector, 
                                 ARRAYSIZE(g_uImageRedirector));
    }
    
    is.hParent             = TVI_ROOT;
    is.hInsertAfter        = TVI_SORT;
    is.item.mask           = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    is.item.stateMask      = TVIS_EXPANDED;
    is.item.lParam         = (LPARAM)pEntry;
    is.item.pszText        = szText;
    is.item.iImage         = uImage;
    is.item.iSelectedImage = uImage;

    //
    // Insert the item for the entry
    //
    pEntry->hItemExe = hItemExe = TreeView_InsertItem(hwndTree, &is);

    TreeView_SetItemState(hwndTree, hItemExe, TVIS_BOLD, TVIS_BOLD);
    
    //
    // Add apphelp item if apphelp is present
    //
    if (pEntry->appHelp.bPresent) {

        TCHAR szAppHelpType[128];

        *szAppHelpType = 0;
        
        switch(pEntry->appHelp.severity) {
        case APPTYPE_NONE: 

            GetString(IDS_NONE, szAppHelpType, ARRAYSIZE(szAppHelpType));
            break;

        case APPTYPE_INC_NOBLOCK:

            GetString(IDS_NOBLOCK, szAppHelpType, ARRAYSIZE(szAppHelpType));
            break;

        case APPTYPE_INC_HARDBLOCK: 

            GetString(IDS_HARDBLOCK, szAppHelpType, ARRAYSIZE(szAppHelpType));
            break;

        case APPTYPE_MINORPROBLEM: 

            GetString(IDS_MINORPROBLEM, szAppHelpType, ARRAYSIZE(szAppHelpType));
            break;

        case APPTYPE_REINSTALL: 
        
            GetString(IDS_REINSTALL, szAppHelpType, ARRAYSIZE(szAppHelpType));
            break;
        }

        *szText = 0;
        if (StringCchPrintf(szText, 
                            ARRAYSIZE(szText),  
                            TEXT("%s - %s"), 
                            CSTRING(IDS_APPHELP).pszString, 
                            szAppHelpType) != S_OK) {

            Dbg(dlError, "[AddSingleEntry]: szText has insufficent space");
        }

        is.hParent             = hItemExe;
        is.item.lParam         = (LPARAM)pEntry->appHelp.pAppHelpinLib;
        is.item.pszText        = szText;
        is.item.iImage         = IMAGE_APPHELP;
        is.item.iSelectedImage = IMAGE_APPHELP;

        TreeView_InsertItem(hwndTree, &is);
    }

    //
    // Add any shims or flags that are applied to the entry
    //
    if (pEntry->pFirstShim || pEntry->pFirstFlag) {
        //
        // For the user the shims and the flags are the same and so we do not
        // distinguish between shims and flags in the UI
        //
        is.hParent             = hItemExe;
        is.hInsertAfter        = TVI_SORT;
        is.item.lParam         = (TYPE)TYPE_GUI_SHIMS;
        is.item.pszText        = GetString(IDS_COMPATFIXES);
        is.item.iImage         = IMAGE_SHIM;
        is.item.iSelectedImage = IMAGE_SHIM;

        hItemShims = TreeView_InsertItem(hwndTree, &is);
        
        is.hParent = hItemShims;
        
        PSHIM_FIX_LIST pFixList = pEntry->pFirstShim;

        //
        // Add all the shims for this entry
        //
        while (pFixList) {

            CSTRING strCommand;

            if (pFixList->pShimFix == NULL) {
                Dbg(dlError, "[AddSingleEntry]: pFixList->pShimFix == NULL");
                goto Next_Shim;
            }

            is.hParent             = hItemShims;
            is.item.lParam         = (LPARAM)pFixList->pShimFix;
            is.item.pszText        = pFixList->pShimFix->strName;
            is.item.iImage         = IMAGE_SHIM;
            is.item.iSelectedImage = IMAGE_SHIM;

            hItemSingleShim = TreeView_InsertItem(hwndTree, &is);

            //
            // Now add the include exclude list (Expert Mode only)
            //
            if (g_bExpert && (!pFixList->strlInExclude.IsEmpty() 
                              || !pFixList->pShimFix->strlInExclude.IsEmpty())) {

                is.hParent      = hItemSingleShim;
                //
                // Include-Exclude lists are not shown in a sorted manner and are shown as is..
                //
                is.hInsertAfter = TVI_LAST;
                
                PSTRLIST listTemp;
                
                if (pFixList->strlInExclude.m_pHead) {
                    listTemp = pFixList->strlInExclude.m_pHead;
                } else {
                    listTemp = pFixList->pShimFix->strlInExclude.m_pHead;
                }
    
                while (listTemp) {
    
                    if (listTemp->data == INCLUDE) {
    
                        is.item.iImage         = IMAGE_INCLUDE;
                        is.item.iSelectedImage = IMAGE_INCLUDE;
                        is.item.lParam         = TYPE_GUI_INCLUDE;

                    } else {
    
                        is.item.iImage         = IMAGE_EXCLUDE;
                        is.item.iSelectedImage = IMAGE_EXCLUDE;
                        is.item.lParam         = TYPE_GUI_EXCLUDE;
                    }
    
                    is.item.pszText = (LPTSTR)listTemp->szStr;
                    listTemp        = listTemp->pNext;
    
                    TreeView_InsertItem(hwndTree, &is);
                }
            }

            //
            // Now add the command line
            //
            if (g_bExpert && pFixList->strCommandLine.Length()) {

                strCommand.Sprintf(CSTRING(IDS_COMMANDLINE), 
                                   pFixList->strCommandLine); 

            } else if (g_bExpert && pFixList->pShimFix->strCommandLine.Length()) {

                strCommand.Sprintf(CSTRING(IDS_COMMANDLINE), 
                                   pFixList->pShimFix->strCommandLine);
            }

            if (strCommand.Length()) {

                is.hParent             = hItemSingleShim;
                is.item.lParam         = TYPE_GUI_COMMANDLINE;
                is.item.pszText        = strCommand;
                is.item.iImage         = IMAGE_COMMANDLINE;
                is.item.iSelectedImage = IMAGE_COMMANDLINE;

                TreeView_InsertItem(hwndTree, &is);
            }

            //
            // This might have got changed if we had a InExclude list as they have to 
            // be shown as is
            //
            is.hInsertAfter = TVI_SORT;

        Next_Shim:
            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(hwndTree, hItemShims, TVE_EXPAND);    
    }
    
    //
    // Add any patches for this entry
    //
    if (pEntry->pFirstPatch) {
        
        HTREEITEM hItemPatches;
        
        is.hParent             = hItemExe;
        is.hInsertAfter        = TVI_SORT;
        is.item.lParam         = (TYPE)TYPE_GUI_PATCHES;
        is.item.pszText        = GetString(IDS_COMPATPATCHES);
        is.item.iImage         = IMAGE_PATCHES;
        is.item.iSelectedImage = IMAGE_PATCHES;

        hItemPatches = TreeView_InsertItem(hwndTree, &is);
        
        is.hParent = hItemPatches;
        
        PPATCH_FIX_LIST pFixList = pEntry->pFirstPatch;

        while (pFixList) {

            if (pFixList->pPatchFix == NULL) {
                Dbg(dlError, "[AddSingleEntry]: pFixList->pPatchFix == NULL");
                goto Next_Patch;
            }
            
            is.item.lParam  = (LPARAM)pFixList->pPatchFix;
            is.item.pszText = pFixList->pPatchFix->strName;
            
            TreeView_InsertItem(hwndTree, &is);

        Next_Patch:

            pFixList = pFixList->pNext;
        }
        
        TreeView_Expand(hwndTree, hItemPatches, TVE_EXPAND);    
    }

    //
    // Add all the flags for this entry
    //
    if (pEntry->pFirstFlag) {
        
        
        is.hParent             = hItemShims;
        is.hInsertAfter        = TVI_SORT;
        is.item.iImage         = IMAGE_SHIM;
        is.item.iSelectedImage = IMAGE_SHIM;
        
        PFLAG_FIX_LIST  pFixList = pEntry->pFirstFlag;
        HTREEITEM       hItemSingleFlag = NULL;
        CSTRING         strCommand;

        while (pFixList) {

            if (pFixList->pFlagFix == NULL) {
                Dbg(dlError, "[AddSingleEntry]: pFixList->pFlagFix == NULL");
                goto Next_Flag;
            }

            is.item.lParam  = (LPARAM)pFixList->pFlagFix;
            is.item.pszText = pFixList->pFlagFix->strName;
            
            hItemSingleFlag = TreeView_InsertItem(hwndTree, &is);
            
            //
            // Now add the command line
            //
            strCommand.Release();

            if (g_bExpert) {

                if (pFixList->strCommandLine.Length()) {

                   strCommand.Sprintf(CSTRING(IDS_COMMANDLINE), 
                                      pFixList->strCommandLine);

                } else if (pFixList->pFlagFix->strCommandLine.Length()) {

                    strCommand.Sprintf(CSTRING(IDS_COMMANDLINE), 
                                       pFixList->pFlagFix->strCommandLine);
                }
    
                if (strCommand.Length()) {
    
                    is.hParent             = hItemSingleFlag;
                    is.item.lParam         = TYPE_GUI_COMMANDLINE;
                    is.item.pszText        = strCommand;
                    is.item.iImage         = IMAGE_COMMANDLINE;
                    is.item.iSelectedImage = IMAGE_COMMANDLINE;

                    TreeView_InsertItem(hwndTree, &is);
                }
            }
            
        Next_Flag:

            pFixList = pFixList->pNext;
        }
            
        TreeView_Expand(hwndTree, hItemShims, TVE_EXPAND);
    }
    
    //
    // Add any layers that are applied to the entry
    //
    if (pEntry->pFirstLayer) {
        
        HTREEITEM hItemLayers;
        
        is.hParent             = hItemExe;
        is.hInsertAfter        = TVI_SORT;
        is.item.lParam         = TYPE_GUI_LAYERS;
        is.item.pszText        = GetString(IDS_COMPATMODES);
        is.item.iImage         = IMAGE_LAYERS;
        is.item.iSelectedImage = IMAGE_LAYERS;

        hItemLayers = TreeView_InsertItem(hwndTree, &is);
        
        is.hParent = hItemLayers;
        
        PLAYER_FIX_LIST pFixList = pEntry->pFirstLayer;

        while (pFixList) {

            if (pFixList->pLayerFix == NULL) {
                Dbg(dlError, "[AddSingleEntry]: pFixList->pLayerFix == NULL");
                goto Next_Layer;
            }
            
            is.item.pszText = pFixList->pLayerFix->strName.pszString;
            is.item.lParam  = (LPARAM)pFixList->pLayerFix;
            
            TreeView_InsertItem(hwndTree, &is);

        Next_Layer:

            pFixList = pFixList->pNext;
        }

        TreeView_Expand(hwndTree, hItemLayers, TVE_EXPAND);      
    }

    //
    // There will be atleast one matching file the program itself
    //
    pMatch = pEntry->pFirstMatchingFile;

    is.hParent             = hItemExe;
    is.item.lParam         = TYPE_GUI_MATCHING_FILES;
    is.item.pszText        = GetString(IDS_MATCHINGFILES);
    is.item.iImage         = IMAGE_MATCHGROUP;
    is.item.iSelectedImage = IMAGE_MATCHGROUP;

    hItemMatchingFiles = TreeView_InsertItem(hwndTree, &is);

    //
    // Add all the matching files for this entry
    //
    while (pMatch) {
        
        TCHAR* pszMatchName;

        if (lstrcmpi(pMatch->strMatchName, TEXT("*")) == 0) {
            pszMatchName = pEntry->strExeName;
        } else {
            pszMatchName = pMatch->strMatchName;
        }

        uImage = LookupFileImage(g_hImageList, 
                                 pszMatchName, 
                                 IMAGE_APPLICATION, 
                                 g_uImageRedirector, 
                                 ARRAYSIZE(g_uImageRedirector));

        is.hInsertAfter        = TVI_SORT;
        is.hParent             = hItemMatchingFiles;
        is.item.pszText        = pszMatchName;
        is.item.iImage         = uImage;
        is.item.iSelectedImage = uImage;
        is.item.lParam         = (LPARAM)pMatch;

        hMatchItem = TreeView_InsertItem(hwndTree, &is);

        is.hParent             = hMatchItem;                                         
        is.hInsertAfter        = TVI_LAST;                                           
        is.item.iImage         = IMAGE_MATCHINFO;                                        
        is.item.iSelectedImage = IMAGE_MATCHINFO;
                                                                                          
        //                                                                                
        // Add the individual attributes of the matching file                          
        //
        PATTRINFO_NEW pAttr = pMatch->attributeList.pAttribute;

        if (pAttr == NULL) {
            Dbg(dlError, "[AddSingleEntry]: pAttr == NULL");
            goto Next_MatchingFile;
        }

        for (DWORD dwIndex = 0; dwIndex <  ATTRIBUTE_COUNT; ++dwIndex) {

            *szText = 0;

            DWORD dwPos = TagToIndex(pAttr[dwIndex].tAttrID);

            if ((pAttr[dwIndex].dwFlags & ATTRIBUTE_AVAILABLE) 
                && dwPos != -1 
                && (pMatch->dwMask  & (1 << (dwPos + 1)))) {

                switch (pAttr[dwIndex].tAttrID) {
                
                case TAG_BIN_PRODUCT_VERSION:
                case TAG_BIN_FILE_VERSION:
                case TAG_UPTO_BIN_PRODUCT_VERSION:
                case TAG_UPTO_BIN_FILE_VERSION:
                    {
                        //
                        // Do our own formatting because SdbFormatAttribute does not 
                        // show X.FFFF.FFFF.FFFF properly
                        // TODO: Remove this once SdbFormatAttribute is corrected
                        //
                        size_t  cchRemaining = 0;
                        TCHAR*  pchEnd       = NULL;

                        if (StringCchPrintfEx(szText,
                                              ARRAYSIZE(szText), 
                                              &pchEnd,
                                              &cchRemaining,
                                              0,
                                              TEXT("%s="), SdbTagToString(pAttr[dwIndex].tAttrID)) != S_OK) {
                            //
                            // Insufficient space
                            //
                            Dbg(dlError, "[AddSingleEntry] Do not have sufficient space in buffer");
                            break;
                        }

                        FormatVersion(pAttr[dwIndex].ullAttr, pchEnd, cchRemaining);
                        break;
                    }

                default:
                    SdbFormatAttribute(&pAttr[dwIndex], szText, sizeof(szText)/sizeof(TCHAR));
                }

                is.item.pszText        = szText;
                is.item.lParam         = TYPE_NULL + 1 + (1 << (dwPos + 1));

                TreeView_InsertItem(hwndTree, &is);
            }
        }

        TreeView_Expand(hwndTree, hMatchItem, TVE_EXPAND);

    Next_MatchingFile:

        pMatch = pMatch->pNext;
    }

    TreeView_Expand(hwndTree, hItemMatchingFiles, TVE_EXPAND);
    TreeView_Expand(hwndTree, hItemExe, TVE_EXPAND);
}

void
UpdateEntryTreeView(
    IN  PDBENTRY pApps,
    IN  HWND     hwndTree
    )
/*++
    UpdateEntryTreeView

	Desc:	Shows the entries for the App: pApps in the tree

	Params:
        IN  PDBENTRY pApps:     The app
        IN  HWND     hwndTree:  The handle to a tree

	Return:
        void
--*/
{
    TCHAR       szStatus[MAX_PATH];
    PDBENTRY    pEntry;
    UINT        uCount;

    if (pApps == NULL || hwndTree == NULL) {
        Dbg(dlError, "[UpdateEntryTreeView] Invalid arguments");
        return;
    }

    //
    // Now we are going to show the entry tree on the right hand side
    // instead of the contents list
    //
    g_bIsContentListVisible = FALSE;

    //
    // Remove all the images of the preceeding app's entries and matching files.
    //
    if (hwndTree == g_hwndEntryTree) {

        ZeroMemory(g_uImageRedirector, sizeof(g_uImageRedirector));

        //
        // Remove the images added by the previous app.
        //
        ImageList_SetImageCount(g_hImageList, IMAGE_LAST);

        ShowWindow(g_hwndContentsList, SW_HIDE);
        ShowWindow(g_hwndEntryTree, SW_SHOWNORMAL);
    }

    TreeDeleteAll(hwndTree);

    //
    // We need to set WM_SETREDRAW false after calling TreeDeleteAll because
    // TreeDeleteAll will first set WM_SETREDRAW false before removing the tree items 
    // and then will again set it to true. But since we want to make 
    // WM_SETREDRAW false, we must explicitely set it to FALSE *AFTER* calling
    // TreeDeleteAll()
    //
    SendMessage(hwndTree, WM_SETREDRAW, FALSE, 0);

    pEntry = pApps;
    uCount = 0;

    //
    // Add all the entries for this application to the entry tree
    //
    while(pEntry) {
        
        AddSingleEntry(hwndTree, pEntry);
        uCount++;
        pEntry = pEntry->pSameAppExe;
    }

    SendMessage(hwndTree, WM_NCPAINT, 1, 0);
    SendMessage(hwndTree, WM_SETREDRAW, TRUE, 0);

    //
    // Select the first item
    //
    HTREEITEM hItem= TreeView_GetChild(hwndTree, TVI_ROOT);

    if (hItem) {
        TreeView_SelectItem(hwndTree, hItem);
    }

    //
    // Because tree view has a bug and sometimes the scroll bars are not painted properly
    //
    SendMessage(hwndTree, WM_NCPAINT, 1, 0);
    
    *szStatus = 0;

    StringCchPrintf(szStatus,
                    ARRAYSIZE(szStatus),
                    GetString(IDS_STA_ENTRYCOUNT), 
                    pApps->strAppName.pszString, 
                    uCount);

    SetStatus(szStatus);
}

BOOL
CheckAndSave(
    IN  PDATABASE pDataBase
    )
/*++

    CheckAndSave
    
    Desc:   Saves a database if it is not saved
    
    Params: 
        IN  PDATABASE pDataBase. The database that has to be saved.
    
    Return: 
        TRUE:   If the database was properly saved
        FALSE:  If there were errors while saving. Error can be because of read-only file
                or if the XML is invalid.
                if the user pressed cancel, we return FALSE
--*/
{
    CSTRING strDBName;

    if (pDataBase == NULL) {
        Dbg(dlError, "Invalid parameter passed %X", pDataBase);
        return FALSE;
    }

    if (pDataBase && pDataBase->bChanged && pDataBase->type == DATABASE_TYPE_WORKING) {
        
        strDBName.Sprintf(CSTRING(IDS_ASKSAVE).pszString, 
                          pDataBase->strName);

        int nResult = MessageBox(g_hDlg,
                                 strDBName,
                                 g_szAppName,
                                 MB_YESNOCANCEL | MB_ICONWARNING);

        if (nResult == IDCANCEL) {
            return FALSE;
        }

        if (nResult == IDYES) {

            BOOL bReturn;

            //
            // We check here that do we have the complete path of the .sdb?
            // When we create a new database then we actually give it a name
            // like Untitled_x, where x is an integer starting from 1.
            // So if this is a new database, then we have to prompt for the file
            // name in which this database has to be saved into
            //
            if (NotCompletePath(pDataBase->strPath)) {
                bReturn = SaveDataBaseAs(pDataBase);
            } else {
                bReturn = SaveDataBase(pDataBase, pDataBase->strPath);
            }

            if (!bReturn) {
                return FALSE;
            }
            
            pDataBase->bChanged = FALSE;
            SetCaption();
        }
    }

    return TRUE;
}

void
SetDefaultDescription(
    void
    )
/*++
    SetDefaultDescription

	Desc:	Sets the text for the rich edit control when we have focus on a non-shim/non-flag
            tree/list item or the shim/flag does not have a description 

	Params:
        void

	Return:
        void
--*/
{
    CHARFORMAT  cf;
    HWND        hwndRichEdit = GetDlgItem(g_hDlg, IDC_DESCRIPTION);
    TCHAR       szCaption[128];
    TCHAR       szToolkit[256];

    *szCaption = *szToolkit = 0;

    //
    // Handle "No Information case"
    //
    SafeCpyN(szCaption, GetString(IDS_NODESC), ARRAYSIZE(szCaption));
    SafeCpyN(szToolkit, GetString(IDS_LATEST_TOOLKIT), ARRAYSIZE(szToolkit));

    StringCchPrintf(g_szDesc,
                    ARRAYSIZE(g_szDesc),
                    TEXT("%s\r\n\r\n%s"),
                    szCaption,
                    szToolkit);

    SetWindowText(hwndRichEdit, g_szDesc);

    memset(&cf, 0, sizeof(CHARFORMAT));

    cf.cbSize      = sizeof(CHARFORMAT);
    cf.dwMask      = CFM_COLOR | CFM_BOLD | CFM_UNDERLINE | CFM_LINK;
    cf.crTextColor = RGB(0, 0, 0);
    cf.dwEffects   = 0;

    SendMessage(hwndRichEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    
    CHARRANGE cr;

    cr.cpMin = 0;
    cr.cpMax = wcslen(szCaption);
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&cr);
    
    memset(&cf, 0, sizeof(CHARFORMAT));

    cf.cbSize      = sizeof(CHARFORMAT);
    cf.dwMask      = CFM_COLOR | CFM_BOLD;
    cf.crTextColor = RGB(0, 0, 127);
    cf.dwEffects   = CFE_BOLD;

    SendMessage(hwndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);

    cr.cpMin = 4 + wcslen(szCaption);
    cr.cpMax = 4 + wcslen(szCaption) + wcslen(szToolkit);
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&cr);
    
    memset(&cf, 0, sizeof(CHARFORMAT));

    cf.cbSize      = sizeof(CHARFORMAT);
    cf.dwMask      = CFM_COLOR | CFM_BOLD | CFM_LINK | CFM_UNDERLINE;
    cf.crTextColor = RGB(0, 0, 255);
    cf.dwEffects   = CFE_LINK | CFE_UNDERLINE;

    SendMessage(hwndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
    
    SendMessage(hwndRichEdit, EM_SETEVENTMASK, 0, ENM_LINK);

    cr.cpMin = 0;
    cr.cpMax = 0;
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&cr);
}

void
SetDescription(
    IN  PCTSTR pszCaption,
    IN  PCTSTR pszTip
    )
/*++
    SetDescription

	Desc:	Sets the text for the rich edit descripotion window

	Params:
        IN  TCHAR* pszCaption:  The caption. This will be shown in the first line of the rich edit control
        IN  TCHAR* pszTip:      The remaining text for the rich edit control

	Return:
        void
--*/
{
    CHARFORMAT   cf;
    HWND         hwndRichEdit = GetDlgItem(g_hDlg, IDC_DESCRIPTION);

    if (pszCaption == NULL) {
        SetDefaultDescription();
        return;
    }
    
    //
    // We have a valid caption, there is a shim whose description has to be shown or may be some
    // apphelp whose message and URL we want to show
    //
    StringCchPrintf(g_szDesc, ARRAYSIZE(g_szDesc), TEXT("%s\r\n\r\n%s"), pszCaption, pszTip);

    SetWindowText(hwndRichEdit, g_szDesc);

    memset(&cf, 0, sizeof(CHARFORMAT));

    cf.cbSize      = sizeof(CHARFORMAT);
    cf.dwMask      = CFM_COLOR | CFM_BOLD | CFM_UNDERLINE;
    cf.crTextColor = RGB(0, 0, 0);
    cf.dwEffects   = 0;

    SendMessage(hwndRichEdit, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    
    CHARRANGE cr;

    cr.cpMin = 0;
    cr.cpMax = wcslen(pszCaption);
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&cr);
    
    memset(&cf, 0, sizeof(CHARFORMAT));

    cf.cbSize      = sizeof(CHARFORMAT);
    cf.dwMask      = CFM_COLOR | CFM_BOLD;
    cf.crTextColor = RGB(0, 0, 127);
    cf.dwEffects   = CFE_BOLD;

    SendMessage(hwndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
    
    SendMessage(hwndRichEdit, EM_SETEVENTMASK, 0, 0);

    cr.cpMin = 0;
    cr.cpMax = 0;
    SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&cr);
}

BOOL
HandleNotifyContentsList(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++
    HandleNotifyContentsList
    
    Desc:   Handles the notification messages for the contents list (RHS)
    
    Params: 
        IN  HWND    hdlg:      The main dialog box for the app
        IN  LPARAM  lParam:  The lParam associated with WM_NOTIFY
    
--*/
{   
    LPNMHDR      pnm = (LPNMHDR)lParam;
    LV_DISPINFO* pnmv = (LV_DISPINFO FAR *)lParam;
    
    if (pnmv == NULL) {
        Dbg(dlError, "Invalid Input parameter lParam == NULL");
        return FALSE;
    }

    switch (pnm->code) {

    case LVN_BEGINLABELEDIT:
    {
        g_hwndEditText = (HWND)SendMessage(g_hwndContentsList,
                                           LVM_GETEDITCONTROL,
                                           0,
                                           0);

        if (g_hwndEditText) {

            SendMessage(g_hwndEditText,
                        EM_LIMITTEXT,           
                        (WPARAM)LIMIT_APP_NAME,
                        0);
        }

        break;
    }

    case LVN_ENDLABELEDIT:

        EndListViewLabelEdit(lParam);
        break;

    case LVN_KEYDOWN:
        {
            NMLVKEYDOWN FAR *plvkd = (NMLVKEYDOWN FAR*)lParam;

            if (plvkd && plvkd->wVKey == 13) {
                //
                // Enter was pressed. We will send it the double click message.
                //
                NMITEMACTIVATE nmactivate;

                nmactivate.hdr.hwndFrom = g_hwndContentsList;
                nmactivate.hdr.idFrom   = IDC_CONTENTSLIST;
                nmactivate.hdr.code     = NM_DBLCLK;
                nmactivate.iItem        = g_iContentsListSelectIndex;

                SendMessage(GetParent(g_hwndContentsList), 
                            WM_NOTIFY,
                            IDC_ENTRY, 
                            (LPARAM)&nmactivate);
            }
        }
        
        break;

    case LVN_ITEMCHANGED:
        {
            LPNMLISTVIEW pnmlv = (LPNMLISTVIEW)lParam;

            if (pnmlv && (pnmlv->uChanged & LVIF_STATE)) {

                if (pnmlv->uNewState & LVIS_SELECTED) {

                    g_iContentsListSelectIndex = pnmlv->iItem;
        
                    TCHAR szText[256];

                    *szText = 0;
        
                    LVITEM lvItem;

                    lvItem.mask         = TVIF_PARAM | LVIF_TEXT;
                    lvItem.iItem        = pnmlv->iItem;
                    lvItem.iSubItem     = 0;
                    lvItem.pszText      = szText;
                    lvItem.cchTextMax   = ARRAYSIZE(szText);
        
                    if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {
                        Dbg(dlWarning, "[HandleNotifyContentsList] could not get listview item");
                        break;
                    }
        
                    if (GetFocus() == g_hwndContentsList) {
                        
                        //
                        // Set the text in the status bar, as if we had selected the corresponding 
                        // htreeitem in the db tree.
                        //
                        HTREEITEM   hItemInDBTree = DBTree.FindChild(TreeView_GetSelection(DBTree.m_hLibraryTree),
                                                                     lvItem.lParam);
        
                        SetStatusStringDBTree(hItemInDBTree);
                    }
        
                    //
                    // BUGBUG:  This is only required if we ever show the databases in
                    //          the contents list. Presently we do not show them in the
                    //          contents list.
                    //
                    TYPE type = ConvertLparam2Type(lvItem.lParam);

                    if (type == DATABASE_TYPE_INSTALLED || type == DATABASE_TYPE_WORKING) {
                        g_pPresentDataBase = (PDATABASE) lvItem.lParam;
                    }
        
                    CSTRING strToolTip;
        
                    GetDescriptionString(lvItem.lParam,
                                         strToolTip,
                                         NULL,
                                         szText,
                                         NULL,
                                         g_hwndContentsList,
                                         pnmlv->iItem);

                    if (strToolTip.Length() > 0) {
                        SetDescription(szText, strToolTip.pszString);
                    } else {
                        SetDescription(NULL, TEXT(""));
                    }
                }
            }
            
            break;
        }

    case NM_DBLCLK:
        {
            LPNMITEMACTIVATE lpnmitem = (LPNMITEMACTIVATE)lParam;

            if (lpnmitem == NULL) {
                break;
            }

            LVITEM lvItem;

            lvItem.mask     = TVIF_PARAM;
            lvItem.iItem    = lpnmitem->iItem;
            lvItem.iSubItem = 0;

            if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {
                break;
            }

            TYPE type = ConvertLparam2Type(lvItem.lParam);

            if (type == TYPE_ENTRY 
                || type == FIX_LAYER 
                || type == FIX_SHIM) {

                HTREEITEM hItem = DBTree.FindChild(TreeView_GetSelection(DBTree.m_hLibraryTree),
                                                    lvItem.lParam);                            
                if (hItem) {
                    TreeView_SelectItem(DBTree.m_hLibraryTree, hItem);
                }
            }

            break;
        }
        
    default: return FALSE;
    }

    return TRUE;
}

BOOL
HandleNotifyDBTree(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++
    HandleNotifyDBTree
    
    Desc:   Handles the notification messages for the db tree (LHS)
    
    Params: 
        IN  HWND hdlg:      The main dialog box for the app
        IN  LPARAM lParam:  The lParam associated with WM_NOTIFY
    
--*/
{
    LPNMHDR         pnm     = (LPNMHDR)lParam;
    LPNMTREEVIEW    pnmtv   = (LPNMTREEVIEW)lParam;

    switch (pnm->code) {
    case NM_RCLICK:
        {
            
            HWND            hwndTree = pnm->hwndFrom;
            TVHITTESTINFO   ht;

            GetCursorPos(&ht.pt);
            ScreenToClient(hwndTree, &ht.pt);

            TreeView_HitTest(hwndTree, &ht);

            if (0 != ht.hItem) {
                TreeView_SelectItem(hwndTree, ht.hItem);
            }

            break;
        }
        
    case TVN_SELCHANGED:
        {
            //
            // Warning: Do not change the code so that we do a post message for UpdateEntryTreeView
            //
            // BOOL DatabaseTree::AddNewExe() Selects an app and assumes that the entry tree will be 
            // populated with correct values after TreeView_SelectItem() returns
            //
            TCHAR   szText[256];
            CSTRING strDesc;
            LPARAM  lParamTreeItem;
            
            if (pnmtv == NULL) {
                break;
            }

            *szText = 0;

            if(pnmtv->itemNew.hItem != 0) {

                HandleDBTreeSelChange(pnmtv->itemNew.hItem);

                CTree::GetTreeItemText(DBTree.m_hLibraryTree, 
                                       pnmtv->itemNew.hItem, 
                                       szText, 
                                       ARRAYSIZE(szText));
                
                DBTree.GetLParam(pnmtv->itemNew.hItem, &lParamTreeItem);

                //
                // Get the description string
                //
                GetDescriptionString(lParamTreeItem, 
                                     strDesc,
                                     NULL, 
                                     szText, 
                                     pnmtv->itemNew.hItem, 
                                     DBTree.m_hLibraryTree); 
    
                if (strDesc.Length() > 0) {
                    SetDescription(szText, strDesc.pszString);
                } else {
                    SetDescription(NULL, TEXT(""));
                }
            }

            SetStatusStringDBTree(pnmtv->itemNew.hItem);
            //
            // Some buttons need to be disabled/enabled depending upon
            // what database we are on
            //
            SetTBButtonStatus(g_hwndToolBar, DBTree.m_hLibraryTree);
            
            break;
        }

    case TVN_ITEMEXPANDING:
        {
            if (pnmtv->action & TVE_EXPAND) {

                if (pnmtv->itemNew.hItem == GlobalDataBase.hItemAllApps 
                    && !g_bMainAppExpanded) {
                    
                    //
                    // If we have  not already loaded the apps for the main database then 
                    // load it. When we start up we load only the library section of the main
                    // database and the layers in the main database. There are lots
                    // of apps in the system database and loading them at start up time
                    // will take some time and also consume lots of memory. Also
                    // normally people will not need to look at the system database
                    //
                    SetCursor(LoadCursor(NULL, IDC_WAIT));

                    INT iResult = ShowMainEntries(hdlg);

                    if (iResult == -1) {

                        //
                        // It is being loaded by somebody else. If we are using the query 
                        // database feature then there we have a modeless window that 
                        // creates a thread that calls ShowMainEntries(). We 
                        // do not want that we should have two threads calling
                        // ShowMainEntries() at any given time
                        //
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, TRUE);

                        //
                        // The status message for the main dialog is changed to normal
                        // when we finish ShowMainEntries()
                        //
                        SetStatus(g_hwndStatus, CSTRING(IDS_LOADINGMAIN));
                        SetCursor(LoadCursor(NULL, IDC_WAIT));

                    } else {
                        SetCursor(LoadCursor(NULL, IDC_ARROW));
                    }
                }
            }
            
            break;
        }

    case TVN_BEGINLABELEDIT:
        {                        
            if (g_pPresentDataBase == NULL || g_pPresentDataBase->type != DATABASE_TYPE_WORKING) {
                return TRUE;
            }
            
            LPNMTVDISPINFO ptvdi = (LPNMTVDISPINFO)lParam;
        
            if (ptvdi == NULL) {
                break;
            }
        
            HTREEITEM hItem = ptvdi->item.hItem;
        
            if (hItem == NULL) {
                break;
            }
            
            TYPE type = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItem); 
        
            switch(type) {
            case TYPE_ENTRY:
            case FIX_LAYER:
            case DATABASE_TYPE_WORKING:
                
                g_hwndEditText = (HWND)SendMessage(DBTree.m_hLibraryTree, 
                                                   TVM_GETEDITCONTROL, 
                                                   0, 
                                                   0);
                break;

            default: return TRUE;
            }
        
            if (g_hwndEditText) {

                SendMessage(g_hwndEditText, EM_LIMITTEXT, (WPARAM)LIMIT_APP_NAME, (LPARAM)0);

            } else {
                break;
            }
        
            if (type == DATABASE_TYPE_WORKING) {
                
                SetWindowText(g_hwndEditText, g_pPresentDataBase->strName);
                //
                // Select the text
                //
                SendMessage(g_hwndEditText, EM_SETSEL, (WPARAM)0, (LPARAM)-1);
                
            }

            return FALSE; // Allow the editting
            break;
        }

    case TVN_ENDLABELEDIT:
        {
            g_hwndEditText = NULL;

            LPNMTVDISPINFO ptvdi = (LPNMTVDISPINFO)lParam;
            BOOL fValid = TRUE;

            if (ptvdi == NULL || g_pPresentDataBase == NULL) {
                Dbg(dlError, "[HandleNotifyDBTree] ptvdi == NULL || g_pPresentDataBase == NULL");
                break;
            }

            HTREEITEM hItem = ptvdi->item.hItem;

            if (hItem == NULL) {
                break;
            }

            if (ptvdi->item.pszText == NULL) {
                fValid = FALSE;
                goto end;
            }
            
            TYPE type = (TYPE)GetItemType(DBTree.m_hLibraryTree, ptvdi->item.hItem); 
            TCHAR szText[256];

            *szText = 0;

            SafeCpyN(szText, ptvdi->item.pszText, ARRAYSIZE(szText));

            if (CSTRING::Trim(szText) == 0) {
                fValid = FALSE;
                goto end;
            }

            switch (type) {
            case TYPE_ENTRY:
                {
                    PDBENTRY pEntry = (PDBENTRY)ptvdi->item.lParam;
                    PDBENTRY pApp   = g_pPresentDataBase->pEntries;

                    if (!IsValidAppName(szText)) {
                        //
                        // The app name contains invalid chars
                        //
                        DisplayInvalidAppNameMessage(g_hDlg);
                        break;
                    }

                    while (pApp) {

                        if (pApp->strAppName == szText) {
                            //
                            // There already exists an app of the same name 
                            // in the present database
                            //
                            MessageBox(g_hDlg, 
                                       GetString(IDS_SAMEAPPEXISTS), 
                                       g_szAppName, 
                                       MB_ICONWARNING);
                            fValid = FALSE;
                        }

                        pApp = pApp->pNext;
                    }

                    while (pEntry) {
                        pEntry->strAppName  = szText;
                        pEntry              = pEntry->pSameAppExe;
                    }
                }

                break;

            case FIX_LAYER:
                {   
                    PLAYER_FIX plf = (PLAYER_FIX)ptvdi->item.lParam;
                    
                    if (plf == NULL) {
                        assert(FALSE);
                        break;
                    }

                    if (FindFix(szText, FIX_LAYER, g_pPresentDataBase)) {
                        //
                        // A layer of this name already exists in the system database
                        // or the present database
                        //
                        MessageBox(g_hDlg, 
                                   GetString(IDS_LAYEREXISTS), 
                                   g_szAppName, 
                                   MB_ICONWARNING);

                        return FALSE;
                    }

                    plf->strName = szText;
                }

                break;

            case DATABASE_TYPE_WORKING:
                
                g_pPresentDataBase->strName = szText;
                break;

            default: fValid = FALSE;
            }

end:
            INT_PTR iStyle = GetWindowLongPtr(DBTree.m_hLibraryTree, GWL_STYLE);
            iStyle &= ~TVS_EDITLABELS;

            //
            // Disable label editing. We need to do this, other
            // wise whenever we have focus on some tree item after some time
            // the edit box will appear there. We want that to appear only if we 
            // actually want to rename the stuff. The rename menu will be enabled
            // only for items that can be renamed. We cannot rename anything that is in
            // the system or the installed database
            //
            SetWindowLongPtr(DBTree.m_hLibraryTree, GWL_STYLE, iStyle);

            if (fValid) {
                //
                // The handler for this message will now do the actual renaming of the tree
                // item
                //
                g_pPresentDataBase->bChanged;
                PostMessage(hdlg, 
                            WM_USER_REPAINT_TREEITEM, 
                            (WPARAM)ptvdi->item.hItem, 
                            (LPARAM)ptvdi->item.lParam);
                

            } else {
                return FALSE;
            }

            break;
        }
        
    default: return FALSE;
    }

    return TRUE;
}

void
HandleNotifyExeTree(
    IN  HWND    hdlg,
    IN  LPARAM  lParam
    )
/*++
    HandleNotifyExeTree
    
    Desc:   Handles the notification messages for the entry tree (RHS)
    
    Params: 
        IN  HWND hdlg:      The main dialog box for the app
        IN  LPARAM lParam:  The lParam associated with WM_NOTIFY
--*/
{
    LPNMHDR pnm = (LPNMHDR)lParam;

    if (pnm == NULL) {
        assert(FALSE);
        Dbg(dlError, "[HandleNotifyExeTree] pnm == NULL");
        return;
    }

    switch (pnm->code) {
    
    case NM_RCLICK:
        {
            
            HWND hwndTree = pnm->hwndFrom;
            TVHITTESTINFO   ht;

            GetCursorPos(&ht.pt);
            ScreenToClient(hwndTree, &ht.pt);

            TreeView_HitTest(hwndTree, &ht);

            if (0 != ht.hItem) {
                TreeView_SelectItem(hwndTree, ht.hItem);
            }
            
            break;
        }
    
    case TVN_SELCHANGED:

        if (g_bDeletingEntryTree == FALSE) {
            OnEntryTreeSelChange(lParam);
        } else {
            Dbg(dlWarning, "HandleNotifyExeTree : Got TVN_SELCHANGED for entry tree when we were deleting the entry tree");
        }
        
        break;
    }
}

BOOL
GetFileName(
    IN  HWND        hWnd,
    IN  LPCTSTR     szTitle,
    IN  LPCTSTR     szFilter,
    IN  LPCTSTR     szDefaultFile, 
    IN  LPCTSTR     szDefExt, 
    IN  DWORD       dwFlags, 
    IN  BOOL        bOpen, 
    OUT CSTRING&    szStr,
    IN  BOOL        bDoNotVerifySDB // DEF = FALSE
    )
/*++
    Desc:   Wrapper for GetOpenFileName() and GetSaveFileName()
    
    Params:
        IN  HWND        hWnd:                       Parent for the dialog
        IN  LPCTSTR     szTitle:
        IN  LPCTSTR     szFilter:
        IN  LPCTSTR     szDefaultFile: 
        IN  LPCTSTR     szDefExt:
        IN  DWORD       dwFlags:
        IN  BOOL        bOpen:                      Whether we should show the open or save dialog
        OUT CSTRING&    szStr:                      This variable stores the name of the file
        IN  BOOL        bDoNotVerifySDB (FALSE):    When we use this routine to 
            get the file name with bOpen == FALSE, then this varible 
            determines whether we should check and add a .sdb at the end 
            of the file name, in case there is none.
--*/
{
    OPENFILENAME ofn;
    TCHAR        szFilename[MAX_PATH_BUFFSIZE];
    BOOL         bResult;

    ZeroMemory(&ofn, sizeof(OPENFILENAME));

    SafeCpyN(szFilename, szDefaultFile, ARRAYSIZE(szFilename));

    ofn.lStructSize         = sizeof(OPENFILENAME);
    ofn.hwndOwner           = hWnd;
    ofn.hInstance           = g_hInstance;
    ofn.lpstrFilter         = szFilter;
    ofn.lpstrFile           = szFilename;
    ofn.nMaxFile            = MAX_PATH;
    ofn.lpstrInitialDir     = szDefaultFile;
    ofn.lpstrTitle          = szTitle;
    ofn.Flags               = dwFlags | OFN_NOREADONLYRETURN | OFN_HIDEREADONLY;
    ofn.lpstrDefExt         = szDefExt;
    ofn.lpstrCustomFilter   = NULL;
    ofn.nMaxCustFilter      = 0;
    ofn.nFilterIndex        = 0;

    
    BOOL valid = FALSE; // Whether path is too long / ends with .SDB or not. Applicable for save mode only
    
    while (!valid) {

        if (bOpen) {
            bResult = GetOpenFileName(&ofn);
        } else {
            bResult = GetSaveFileName(&ofn);
        }

        if (!bResult) {
            return FALSE;
        }

        szStr = szFilename;

        if (bOpen || bDoNotVerifySDB) {
            return TRUE;
        }

        //
        // Do stuff to make sure that the file being saved has a .SDB extension
        // and the filename is not too long so that a .SDB file name cannot
        // not get appended to it.
        //
        if (szStr.Length() == 0) {
            continue;
        }

        if (!szStr.EndsWith(TEXT(".sdb"))) {

            if (szStr.Length() <= (MAX_PATH - 1 - 4)) {
                szStr.Strcat(TEXT(".sdb"));
                valid = TRUE;
            }

        } else {
            valid = TRUE;
        }

        if (!valid) {
            
            //
            // The path did not have a .sdb extension and we were not able to append one, because it was 
            // a long path
            //
            CSTRING message(IDS_PATHENTERED1);
            
            message.Strcat(szStr);
            message.Strcat(GetString(IDS_PATHENTERED2));
            
            MessageBox(hWnd, message, g_szAppName, MB_ICONWARNING);
        }
    }

    return TRUE;
}

BOOL 
OpenDatabaseFiles(
    IN  HWND hdlg
    )
/*++
    OpenDatabaseFiles

	Desc:	Shows the open common dialog box and opens the database file(s) 
            selected

	Params:
        IN  HWND hdlg:  Parent for the open common dialog box

	Return:
        TRUE:   The user selected a sdb file and at least one sdb was opened,
                or highlighted because it was already opened.
                
        FALSE:  Otherwise
--*/
{   
    OPENFILENAME    ofn;
    TCHAR           szCaption[128];
    TCHAR           szFilter[128];
    TCHAR           szExt[8];
    CSTRINGLIST     strlPaths;
    TCHAR           szFullPath[MAX_PATH * 2];
    PSTRLIST        pstrlIndex                  = NULL;
    BOOL            bRemaining                  = TRUE;
    PCTSTR          pszIndex                    = NULL;
    INT             iIndexToInsert              = 0;
    INT             iLengthFileName             = 0;
    BOOL            bOk                         = FALSE;
    PTSTR           pszFilesList                = NULL;
    K_SIZE          k_pszFilesList              = MAX_BUFF_OPENMULTIPLE_FILES;

    pszFilesList = new TCHAR[k_pszFilesList];

    if (pszFilesList == NULL) {
        MEM_ERR;
        goto End;
    }

    *szCaption = *pszFilesList = *szFilter = *szExt = 0;

    GetString(IDS_OPENDATABASE, szCaption, ARRAYSIZE(szCaption));

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hdlg;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = GetString(IDS_FILTER, szFilter, ARRAYSIZE(szFilter));
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0;
    ofn.nFilterIndex      = 0;
    ofn.lpstrFile         = pszFilesList;
    ofn.nMaxFile          = k_pszFilesList;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = NULL;
    ofn.lpstrTitle        = szCaption;
    ofn.Flags             = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_ALLOWMULTISELECT | OFN_EXPLORER;
    ofn.lpstrDefExt       = GetString(IDS_FILTER, szExt, ARRAYSIZE(szExt));

    if (GetOpenFileName(&ofn)) {
        
        //
        // If the database is a big one, then the open dialog box stays put, so
        // we update the controls forcibly
        //
        UpdateControls();

        if (pszFilesList[ofn.nFileOffset - 1] == 0) {
            //
            // User has selected more than one file
            //
            SafeCpyN(szFullPath, pszFilesList, MAX_PATH);

            ADD_PATH_SEPARATOR(szFullPath, ARRAYSIZE(szFullPath));

            iIndexToInsert = lstrlen(szFullPath);
        }

        //
        // Point to the first file
        // 
        pszIndex = pszFilesList + ofn.nFileOffset;

        while (bRemaining) {

            if (pszFilesList[ofn.nFileOffset - 1] != 0) {
                //
                // User has selected only a single file
                //
                bRemaining = FALSE;

                SafeCpyN(szFullPath, pszFilesList, MAX_PATH);

            } else {

                iLengthFileName = lstrlen(pszIndex);

                if (*(pszIndex + iLengthFileName + 1) == 0) {
                    //
                    // This is the last component
                    //
                    bRemaining = FALSE;
                }
    
                SafeCpyN(szFullPath + iIndexToInsert, pszIndex, ARRAYSIZE(szFullPath) - iIndexToInsert);
            }

            //
            // Test to see if we have the database open already. 
            // If it is open, we just highlight that and return
            //
            PDATABASE pDataBase = DataBaseList.pDataBaseHead;
    
            while (pDataBase) {
    
                if (pDataBase->strPath == szFullPath) {
    
                    TreeView_SelectItem(DBTree.m_hLibraryTree, pDataBase->hItemDB);
                    bOk = TRUE;
                    goto Next_File;
                }
    
                pDataBase = pDataBase->pNext;
            }
    
            //
            // Read the database
            //
            pDataBase = new DATABASE(DATABASE_TYPE_WORKING);
    
            if (pDataBase == NULL) {
                MEM_ERR;
                return FALSE;
            }
    
            BOOL bReturn = GetDatabaseEntries(szFullPath, pDataBase);
    
            if (!bReturn) {
                //
                // Cleanup has  been called in GetDatabaseEntries
                //
                delete pDataBase;            
                pDataBase = NULL;
    
                goto Next_File;
            }
    
            if (!DBTree.AddWorking(pDataBase)) {
    
                CleanupDbSupport(pDataBase);
    
                delete pDataBase;
                pDataBase = NULL;
    
                goto Next_File;
            }

            if (g_pPresentDataBase) {
                //
                // g_PresentDataBase is set properly in GetDatabaseEntries. This will be set to pDatabase
                //
                AddToMRU(g_pPresentDataBase->strPath);
                bOk = TRUE;
            }

Next_File:
            if (bRemaining) {
                pszIndex = pszIndex + iLengthFileName + 1;
            }
        }

    } else {

        if (CommDlgExtendedError() == FNERR_BUFFERTOOSMALL) {
            //
            // We cannot select so many files at one go...
            //
            MessageBox(hdlg, GetString(IDS_TOO_MANYFILES), g_szAppName, MB_ICONINFORMATION);
            bOk = FALSE;
        }
    }

End:

    if (pszFilesList) {
        delete[] pszFilesList;
        pszFilesList = NULL;
    }

    RefreshMRUMenu();
    SetCaption();

    return bOk;
}

BOOL
SaveMRUList(
    void
    )
/*++
    
    SaveMRUList
    
    Desc:   Saves the list of MRU files in the registry.
            Should be called just before exiting. When this is called we are sure
            that we are going to exit, databases have already been closed
--*/
{   
    HKEY    hKey    = NULL, hSubKey = NULL;
    BOOL    bOk     = TRUE;
    DWORD   dwDisposition; 

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                      APPCOMPAT_KEY_PATH,
                                      0,
                                      KEY_READ,
                                      &hKey)) {

        assert(FALSE);
        bOk =  FALSE;
        goto End;
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(hKey,
                                        TEXT("CompatAdmin"),
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hSubKey,
                                        &dwDisposition)) {

        
        REGCLOSEKEY(hKey);

        Dbg(dlError, "[SaveMRUList] Could not create key for CompatAdmin");

        bOk = FALSE;
        goto End;
    }

    REGCLOSEKEY(hKey);
    hKey = hSubKey;

    SHDeleteKey(hKey, TEXT("MRU"));

    if (ERROR_SUCCESS != RegCreateKeyEx(hKey,
                                        TEXT("MRU"),
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hSubKey,
                                        &dwDisposition)) {
        REGCLOSEKEY(hKey);

        Dbg(dlError, "[SaveMRUList] Could not create key for MRU");

        bOk = FALSE;
        goto End;
    }

    REGCLOSEKEY(hKey);
    hKey = hSubKey;

    UINT    uCount = 0;
    TCHAR   szCount[3];

    *szCount = 0;

    PSTRLIST pStrListHead = g_strlMRU.m_pHead;

    while (pStrListHead && uCount < MAX_MRU_COUNT) {
        //
        // Now add this to the registry.
        //
        *szCount = 0;

        if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                           _itot(uCount, szCount, 10), 
                                           0,
                                           REG_SZ,       
                                           (LPBYTE)pStrListHead->szStr.pszString,
                                           (pStrListHead->szStr.Length() + 1) * sizeof(TCHAR))) {

            REGCLOSEKEY(hKey);

            Dbg(dlError, "[SaveMRUList] Could not save MRU settings");

            bOk = FALSE;
            goto End;
        }

        ++uCount;
        pStrListHead = pStrListHead->pNext;
    }

    REGCLOSEKEY(hKey);

End:

    return bOk;
}

BOOL
SaveDisplaySettings(
    void
    )
/*++
    SaveDisplaySettings
    
    Desc:   Saves the display settings in the registry
    
    Return: 
        FALSE:  If there was some error
        TRUE:   Otherwise
--*/
{
    HKEY    hKey = NULL, hSubKey = NULL;
    DWORD   dwDisposition; 
    RECT    r, rectDBTree;
    DWORD   dwPos;
    BOOL    bOk = TRUE;

    if (IsIconic(g_hDlg)) {
        //
        // We do not want to save the settings when we are minimized
        //
        return TRUE;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                      APPCOMPAT_KEY_PATH,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not open key for APPCOMPAT_KEY_PATH");
        goto End;
    }

    if (ERROR_SUCCESS != RegCreateKeyEx(hKey,
                                        TEXT("CompatAdmin"),
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hSubKey,
                                        &dwDisposition)) {
        
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not create key for CompatAdmin");
        goto End;
    }

    REGCLOSEKEY(hKey);
    hKey = hSubKey;

    if (ERROR_SUCCESS != RegCreateKeyEx(hKey,
                                        TEXT("Display"),
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hSubKey,
                                        &dwDisposition)) {
        
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not create key for Display");         
        goto End;
    }

    REGCLOSEKEY(hKey);
    hKey = hSubKey;

    //
    // Now save the settings in the key
    //

    //
    // Fist the left-top
    //  
    GetWindowRect(g_hDlg, &r);

    dwPos = r.left;

    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                       TEXT("LEFT"), 
                                       0,      
                                       REG_DWORD,       
                                       (CONST BYTE*)&dwPos,
                                       sizeof(DWORD))) {
        
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not save value for left");
        goto End;
    }

    dwPos = r.top;

    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                        TEXT("TOP"), 
                                        0,      
                                        REG_DWORD,       
                                        (CONST BYTE*)&dwPos,
                                        sizeof(DWORD))) {

        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not save value for top");
        goto End;
    }

    //
    // Then the right bottom
    //
    dwPos = r.right;

    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                       TEXT("RIGHT"), 
                                       0,      
                                       REG_DWORD,       
                                       (CONST BYTE*)&dwPos,
                                       sizeof(DWORD))) {
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not save value for right");
        goto End;
    }

    dwPos = r.bottom;

    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                       TEXT("BOTTOM"), 
                                       0,      
                                       REG_DWORD,       
                                       (CONST BYTE*)&dwPos,
                                       sizeof(DWORD))) {
        
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not save value for bottom");
        goto End;
    }

    //
    // Percentage Width of the db tree next.
    //
    GetWindowRect(DBTree.m_hLibraryTree, &rectDBTree);
    dwPos = (rectDBTree.right-rectDBTree.left) ;

    if (ERROR_SUCCESS != RegSetValueEx(hKey,
                                       TEXT("DBTREE-WIDTH"), 
                                       0,      
                                       REG_DWORD,       
                                       (CONST BYTE*)&dwPos,
                                       sizeof(DWORD))) {
        
        bOk = FALSE;
        Dbg(dlError, "[SaveMRUList] Could not save value for DBTREE-WIDTH");
        goto End;
    }
    
End:
    
    REGCLOSEKEY(hKey);

    return bOk;    
}

void
LoadDisplaySettings(
    void
    )
/*++
    LoadDisplaySettings
    
    Desc:   Loads the positional settings from the registry.
            Also adjusts the splitter bar.
            
    Warn:   Even if we do some error handling and bail out, make sure that this routine
            calls MoveWindow() for the main dialog window so that it gets a WM_SIZE
            We arrange the controls on the handler of WM_SIZE, so it is important 
            that it gets a WM_SIZE from here
    
--*/
{   
    RECT            r, rectDBTree;
    DWORD           dwType              = 0;
    DWORD           cbData              = 0;
    DWORD           dwFinalDBWidth      = 0;
    DWORD           dwInitialWidth      = 0;
    DWORD           dwInitialHeight     = 0;
    HKEY            hKey                = NULL;
    LONG            lResult             = -1;
    MENUITEMINFO    mii                 = {0};
    
    //
    // Set the default width, height and postition etc. If this is the first 
    // time that the user is running CompatAdmin, CompatAdmin will start with 
    // these settings. The next time the user runs CompatAdmin, we will make 
    // the position and size as it was the last time the user ran it
    //
    dwInitialHeight = GetSystemMetrics(SM_CYSCREEN) / 2 + 100;
    dwInitialWidth  = GetSystemMetrics(SM_CXSCREEN) / 2 + 200;

    r.left      = 0;
    r.top       = 0;
    r.right     = r.left + dwInitialWidth;
    r.bottom    = r.top  + dwInitialHeight;
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                      DISPLAY_KEY,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        dwType  = REG_DWORD;
        cbData  = sizeof(DWORD);

        lResult = RegQueryValueEx(hKey,
                                  TEXT("LEFT"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&r.left,
                                  &cbData);

        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD) {
            goto End;
        }

        lResult = RegQueryValueEx(hKey,
                                  TEXT("TOP"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&r.top,
                                  &cbData);

        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD) {
            goto End;
        }

        lResult = RegQueryValueEx(hKey,
                                  TEXT("RIGHT"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&r.right,
                                  &cbData);

        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD) {
            goto End;
        }

        lResult = RegQueryValueEx(hKey,
                                  TEXT("BOTTOM"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&r.bottom,
                                  &cbData);

        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD) {
            goto End;
        }
        
        lResult = RegQueryValueEx(hKey,
                                  TEXT("DBTREE-WIDTH"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwFinalDBWidth,
                                  &cbData);

        if (lResult != ERROR_SUCCESS || dwType != REG_DWORD) {
            goto End;
        }
    }

    //
    // We are doing this so that we do get a WM_SIZE now. Otherwise the controls do 
    // not appear properly
    //
    MoveWindow(g_hDlg,
               r.left,
               r.top,
               r.right - r.left,
               r.bottom - r.top,
               TRUE);
    

    if (dwFinalDBWidth != 0) {

        GetWindowRect(DBTree.m_hLibraryTree, &rectDBTree);

        dwInitialWidth = rectDBTree.right - rectDBTree.left;

        LPARAM lParam = rectDBTree.top + 2;

        lParam = lParam << 16;  // The y pos of the imaginary mouse
        lParam |= rectDBTree.right + 2;    //The x pos of the imaginary mouse 

        //
        // Position the split bar proerply
        //
        OnMoveSplitter(g_hDlg, lParam, TRUE, dwFinalDBWidth - dwInitialWidth);
    }

End:    
    REGCLOSEKEY(hKey);
}

INT
LoadSpecificInstalledDatabasePath(
    IN  PCTSTR  pszPath
    )
/*++
    LoadSpecificInstalledDatabasePath
    
    Desc:   Loads an installed database from the AppPatch\custom directory
            and shows that on UI
            
    Params:
        IN  PCTSTR  pszPath:    The full path of the database in the AppPatch\custom directory
            that we want to load
            
    Return:
        0:  There was some critical error, like memory allocation failure, 
            could not add to the UI etc
            
        -1: The database does not exist at the specified location
        
        1:  Successful
        
    *****************************************************************************************        
    Warning:    This routine is called by LoadInstalledDataBases(...), which has done a 
                EnterCriticalSection(&g_csInstalledList) before calling this, so do not do a 
                EnterCriticalSection(&g_csInstalledList) anywhere in this routine
    *****************************************************************************************        
--*/
{
    INT         iReturn             = 1;
    PDATABASE   pOldPresentDatabase = NULL;
    PDATABASE   pDataBase           = NULL;    
    BOOL        bReturn             = FALSE;
    HCURSOR     hCursor;
    
    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    pDataBase = new DATABASE(DATABASE_TYPE_INSTALLED);

    if (pDataBase == NULL) {

        MEM_ERR;
        iReturn = 0;
        goto End;
    }

    //
    // NOTE:    If GetDatabaseEntries() returns succeeds then it set the g_pPresentDataBase to pDataBase,
    //          so after it returns successfully, the g_pPresentDataBase is changed. 
    //
    pOldPresentDatabase = g_pPresentDataBase;

    bReturn = GetDatabaseEntries(pszPath, pDataBase);

    g_pPresentDataBase = pOldPresentDatabase;

    if (bReturn == FALSE) {

        if (pDataBase) {
            //
            // Cleanup done in GetDatabaseEntries()
            //
            delete pDataBase;
        }

        //
        // User might have manually deleted the file
        //
        return -1;
    }

    InstalledDataBaseList.Add(pDataBase);

    if (!DBTree.AddInstalled(pDataBase)) {
        InstalledDataBaseList.Remove(pDataBase);

        if (pDataBase) {
            delete pDataBase;
            pDataBase = NULL;
        }

        iReturn = 0;
    }

End:
    hCursor ? SetCursor(hCursor) : SetCursor(LoadCursor(NULL, IDC_ARROW));

    return iReturn;
}

INT
LoadSpecificInstalledDatabaseGuid(
    IN  PCTSTR  pszGuid
    )
/*++
    LoadSpecificInstalledDatabaseGuid
    
    Desc:   Loads an installed database given a GUID
            
    Params:
        IN  PCTSTR  pszGuid:    The guid of the database that we want to load
            
    Return:
        0:  Failure
        Otherwise returns LoadSpecificInstalledDatabasePath(...)
*/        
{
    TCHAR       szPath[MAX_PATH * 2];
    INT         iLength             = 0;
    INT         ichSizeRemaining    = 0;
    UINT        uResult             = 0;

    *szPath = 0;

    if (pszGuid == NULL) {
        assert(FALSE);
        Dbg(dlError, "LoadSpecificInstalledDatabaseGuid NULL Guid passed");
        return 0;
    }

    uResult = GetSystemWindowsDirectory(szPath, MAX_PATH);

    if (uResult == 0  || uResult >= MAX_PATH) {
        Dbg(dlError, "LoadSpecificInstalledDatabaseGuid GetSystemWindowsDirectory failed");
        return 0;
    }

    ADD_PATH_SEPARATOR(szPath, ARRAYSIZE(szPath));

    iLength = lstrlen(szPath);

    ichSizeRemaining = ARRAYSIZE(szPath) - iLength;

    StringCchPrintf(szPath + iLength, ichSizeRemaining, TEXT("AppPatch\\Custom\\%s.sdb"), pszGuid);

    return LoadSpecificInstalledDatabasePath(szPath);
}

BOOL
LoadInstalledDataBases(
    void
    )
/*++
    LoadInstalledDataBases

	Desc:	First of all removes the list of installed databases, and re-loads it
            
	Params:
        void

	Return:
        TRUE:   If the list of databases could be reloaded
        FALSE:  Otherwise
--*/    
{   
    TCHAR       szFileName[MAX_PATH];
    TCHAR       szwName[MAX_PATH];
    DWORD       dwchSizeSubKeyName;
    HKEY        hKey = NULL, hSubKey = NULL;
    LPARAM      lParam;
    PDATABASE   pOldPresentDatabase = NULL;
    BOOL        bOk                 = TRUE;

    *szFileName =  0;

    SetCursor(LoadCursor(NULL, IDC_WAIT));

    EnterCriticalSection(&g_csInstalledList);
    
    //
    // Remove the Installed Database All Items
    //
    if (DBTree.m_hItemAllInstalled) {

        TreeView_DeleteItem(DBTree.m_hLibraryTree, DBTree.m_hItemAllInstalled);
        InstalledDataBaseList.RemoveAll();
        DBTree.m_hItemAllInstalled = NULL;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      APPCOMPAT_KEY_PATH_INSTALLEDSDB,
                                      0,
                                      KEY_READ,
                                      &hKey)) {
        bOk = FALSE;
        Dbg(dlWarning, "[LoadInstalledDataBases] Could not open APPCOMPAT_KEY_PATH_INSTALLEDSDB");
        goto End;
    }

    DWORD dwIndex = 0;

    while (TRUE) {

        dwchSizeSubKeyName = ARRAYSIZE(szwName);
        *szwName = 0;

        if (ERROR_SUCCESS != RegEnumKeyEx(hKey,
                                          dwIndex++,
                                          szwName,
                                          &dwchSizeSubKeyName,
                                          0,
                                          0,
                                          0,
                                          0)) {
            break;
        }

        if (ERROR_SUCCESS != RegOpenKeyEx(hKey,
                                          szwName,
                                          0,
                                          KEY_READ,
                                          &hSubKey)) {
            
            bOk = FALSE;
            goto End;
        }

        *szFileName = 0;

        DWORD   dwType          = REG_SZ;
        DWORD   dwFileNameSize  = sizeof(szFileName);
        LONG    lResult         = 0;

        lResult = RegQueryValueEx(hSubKey,
                                  TEXT("DatabasePath"),
                                  0,
                                  &dwType,
                                  (LPBYTE)szFileName,
                                  &dwFileNameSize);


        if (lResult != ERROR_SUCCESS || dwType != REG_SZ) {
            bOk =  FALSE;
            goto End;
        }

        if (LoadSpecificInstalledDatabasePath(szFileName) == 0) {
            bOk = FALSE;
            goto End;
        }

        REGCLOSEKEY(hSubKey);
        hSubKey = NULL;
    }

End:

    REGCLOSEKEY(hKey);

    if (hSubKey) {
        REGCLOSEKEY(hSubKey);
        hSubKey = NULL;
    }

    LeaveCriticalSection(&g_csInstalledList);

    if (g_hdlgSearchDB || g_hdlgQueryDB) {
        
        //
        // Either the query or the search window is open, we should prompt
        // that for installed databases, some results might now show up correctly as the 
        // entire list has been refreshed.
        // The database and entries now will have different pointer values
        //
        MessageBox(g_hDlg, 
                   GetString(IDS_SOMESEARCHWINDOW), 
                   g_szAppName, 
                   MB_ICONINFORMATION);
    }
    
    SetCursor(LoadCursor(NULL, IDC_ARROW));

    return bOk;
}

void
SetImageList(
    void
    )
/*++
    
    SetImageList
    
    Desc:   Create our global ImageList and  Add images to the ImageList and associate it 
            with the tree controls
            
--*/
{           
    g_hImageList = ImageList_Create(16, 16, ILC_COLOR32 | ILC_MASK, 30, 1);

    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FIXES)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_HELP)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MODE)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_PATCHES)));
    
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ATTRIBUTE)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MATCHHEAD)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DISABLED)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_GLOBAL)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_LOCAL)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_CMDLINE)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_INCLUDE)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_EXCLUDE)));
    

    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APP)));
    
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_INSTALLED)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_DATABASE)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_SINGLEAPP)));

    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICONALLUSERS)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICONSINGLEUSER)));

    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_FILE)));

    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_EV_ERROR)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_EV_WARNING)));
    ImageList_AddIcon(g_hImageList, LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_EV_INFO)));
}   

HWND 
InitToolBar(
    IN  HWND hwndParent
    )
/*++

    InitToolBar
    
	Desc:	Creates the tool bar for the app

	Params:
        IN  HWND hwndParent:    The parent for the tool bar

	Return: The handle to the tool bar window   
--*/
{ 
    HWND        hwndTB; 
    TBBUTTON    tbbAr[BUTTON_COUNT]; 
    DEVMODE     dm;

    //
    // Create a toolbar that has a ToolTip associated with it. 
    //
    hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, 
                            TOOLBARCLASSNAME,
                            NULL, 
                            WS_CHILD | WS_CLIPCHILDREN | TBSTYLE_TOOLTIPS 
                            | CCS_ADJUSTABLE | TBSTYLE_LIST | TBSTYLE_TRANSPARENT 
                            | TBSTYLE_FLAT,

                            0, 
                            0, 
                            0, 
                            0, 
                            hwndParent, 
                            (HMENU)ID_TOOLBAR, 
                            g_hInstance, 
                            NULL); 
    
    //
    // Send the TB_BUTTONSTRUCTSIZE message, which is required for 
    // backward compatibility
    //
    SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0); 

    //
    // Add the strings for the tool bar buttons text
    //
    int iIndexes[] = {

        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_NEW)),
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_OPEN)),
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_SAVE)),
       
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_CREATEFIX)),
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_CREATEAPPHELP)),
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_CREATEMODE)),
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_RUN)),
        
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_SEARCH)),
        SendMessage(hwndTB, TB_ADDSTRING, 0, (LPARAM)GetString(IDS_TB_QUERY)),
    };
    
    dm.dmSize = sizeof(dm);

    EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &dm);

    if (dm.dmBitsPerPel >= 32) {
        //
        // The  present settings can support >= 32 bit colors
        //

        //
        // Create the imagelist for the toolbar and set the bitmap
        //
        s_hImageListToolBar = ImageList_Create(IMAGE_WIDTH, 
                                               IMAGE_HEIGHT, 
                                               ILC_COLOR32 | ILC_MASK, 
                                               8, 
                                               1);

        ImageList_Add(s_hImageListToolBar, 
                      LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR)), 
                      NULL);

        SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)(HIMAGELIST)s_hImageListToolBar);

        //
        // Create the hot imagelist for the toolbar and set the bitmap
        //
        s_hImageListToolBarHot = ImageList_Create(IMAGE_WIDTH, 
                                                  IMAGE_HEIGHT, 
                                                  ILC_COLOR32 | ILC_MASK, 
                                                  8, 
                                                  1);

        ImageList_Add(s_hImageListToolBarHot, 
                      LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_TOOLBAR_HOT)), 
                      NULL);

        SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)(HIMAGELIST)s_hImageListToolBarHot);

    } else {
        //
        // The  present settings cannot support >= 32 bit colors
        //

        //
        // Get the normal imagelist for the tool bar when we are on low colors
        //
        s_hImageListToolBar = ImageList_LoadImage(g_hInstance,
                                                  MAKEINTRESOURCE(IDB_256NORMAL),
                                                  IMAGE_WIDTH,
                                                  0,
                                                  CLR_DEFAULT,
                                                  IMAGE_BITMAP,
                                                  LR_CREATEDIBSECTION);

        SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)(HIMAGELIST)s_hImageListToolBar);

        //
        // Get the hot imagelist for the tool bar when we are on low colors
        //
        s_hImageListToolBarHot = ImageList_LoadImage(g_hInstance,
                                                  MAKEINTRESOURCE(IDB_256HOT),
                                                  IMAGE_WIDTH,
                                                  0,
                                                  CLR_DEFAULT,
                                                  IMAGE_BITMAP,
                                                  LR_CREATEDIBSECTION);

        SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)(HIMAGELIST)s_hImageListToolBarHot);
    }

    INT iIndex = 0, iStringIndex = 0;

    // New DataBase 
    tbbAr[iIndex].iBitmap      = IMAGE_TB_NEW; 
    tbbAr[iIndex].idCommand    = ID_FILE_NEW; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];

    // Open Database
    tbbAr[iIndex].iBitmap      = IMAGE_TB_OPEN; 
    tbbAr[iIndex].idCommand    = ID_FILE_OPEN; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];

    // Save Database
    tbbAr[iIndex].iBitmap      = IMAGE_TB_SAVE; 
    tbbAr[iIndex].idCommand    = ID_FILE_SAVE; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];
    
    // Add the separator        
    tbbAr[iIndex].iBitmap      = 0;
    tbbAr[iIndex].idCommand    = 0; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SEP;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = 0;

    // Create Fix
    tbbAr[iIndex].iBitmap      = IMAGE_TB_NEWFIX; 
    tbbAr[iIndex].idCommand    = ID_FIX_CREATEANAPPLICATIONFIX; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];

    // Create AppHelp
    tbbAr[iIndex].iBitmap      = IMAGE_TB_NEWAPPHELP; 
    tbbAr[iIndex].idCommand    = ID_FIX_CREATEANEWAPPHELPMESSAGE; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];

    // Create mode
    tbbAr[iIndex].iBitmap      = IMAGE_TB_NEWMODE; 
    tbbAr[iIndex].idCommand    = ID_FIX_CREATENEWLAYER;
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];

    // Run
    tbbAr[iIndex].iBitmap      = IMAGE_TB_RUN; 
    tbbAr[iIndex].idCommand    = ID_FIX_EXECUTEAPPLICATION; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];

    // Add the separator        
    tbbAr[iIndex].iBitmap      = 0;
    tbbAr[iIndex].idCommand    = 0; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SEP;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = 0;

    // Search
    tbbAr[iIndex].iBitmap      = IMAGE_TB_SEARCH; 
    tbbAr[iIndex].idCommand    = ID_TOOLS_SEARCHFORFIXES; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex++];
    
    // Query
    tbbAr[iIndex].iBitmap      = IMAGE_TB_QUERY; 
    tbbAr[iIndex].idCommand    = ID_SEARCH_QUERYDATABASE; 
    tbbAr[iIndex].fsState      = TBSTATE_ENABLED; 
    tbbAr[iIndex].fsStyle      = BTNS_SHOWTEXT;
    tbbAr[iIndex].dwData       = 0; 
    tbbAr[iIndex++].iString    = iIndexes[iStringIndex];
    
    SendMessage(hwndTB, TB_ADDBUTTONS, BUTTON_COUNT, (LPARAM) (LPTBBUTTON)tbbAr);

    SendMessage(hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_MIXEDBUTTONS);
    
    SendMessage(hwndTB, TB_AUTOSIZE, 0, 0); 
    ShowWindow(hwndTB, SW_SHOWNORMAL);
    
    return hwndTB; 
} 

void
DoInitDialog(
    IN  HWND hdlg
    )
/*++
    
    DoInitDialog
    
    Desc:   Does a lot of initialization stuff, loads up the library section of the 
            system database.
            Also sets up the status bar, loads the list of installed databases,
            loads the display settings
            
    Params:
        IN  HWND hdlg:  The main dialog.
--*/
{
    HICON       hIcon;
    HMENU       hMenu, hSubMenu;
    RECT        r;
    RECT        rectMainClient, rect;
    PDATABASE   pCurrentDatabase = NULL;

    GetClientRect(hdlg, &rectMainClient);

    //
    // Check if the APPCOMPAT keys are there if not add them.
    //
    AddRegistryKeys();

    SetImageList();

    g_hwndToolBar = InitToolBar(hdlg);

    GetWindowRect(g_hwndToolBar, &rect);

    INT iHeightToolbar = rect.bottom - rect.top;

    g_hwndStatus = CreateWindowEx(0,                   
                                  STATUSCLASSNAME,
                                  (LPCTSTR) NULL,         
                                  SBARS_SIZEGRIP |        
                                  WS_CHILD | WS_VISIBLE,  
                                  0, 
                                  0, 
                                  0, 
                                  0,             
                                  hdlg,                   
                                  (HMENU)IDC_STATUSBAR,   
                                  g_hInstance,            
                                  NULL);                  

    GetWindowRect(g_hwndStatus, &rect);

    INT iHeightStatusbar = rect.bottom - rect.top;

    DBTree.Init(hdlg, iHeightToolbar, iHeightStatusbar, &rectMainClient);

    g_hDlg = hdlg;

    g_hwndEntryTree = GetDlgItem(hdlg, IDC_ENTRY);
    TreeView_SetImageList(g_hwndEntryTree, g_hImageList, TVSIL_NORMAL);

    g_hwndContentsList = GetDlgItem(hdlg, IDC_CONTENTSLIST);

    ListView_SetImageList(g_hwndContentsList, g_hImageList, LVSIL_SMALL);
    ListView_SetExtendedListViewStyleEx(g_hwndContentsList, 
                                        0,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT | LVS_EX_INFOTIP);

    g_hwndRichEdit = GetDlgItem(hdlg, IDC_DESCRIPTION);

    //
    // Show the app icon.
    //
    hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APPICON));

    SetClassLongPtr(hdlg, GCLP_HICON, (LONG_PTR)hIcon);
    
    hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MENU));
    
    //
    // Get the file sub menu
    //
    hSubMenu = GetSubMenu(hMenu, 0);
    AddMRUToFileMenu(hSubMenu);     

    SetMenu(hdlg, hMenu);
    
    GetWindowRect(hdlg, &r);

    g_cWidth    = r.right - r.left;
    g_cHeight   = r.bottom - r.top;

    if (!ReadMainDataBase()) {
        
        MessageBox(g_hDlg, 
                   GetString(IDS_UNABLETO_OPEN),
                   g_szAppName,
                   MB_ICONERROR);

        PostQuitMessage(0);
        return;
    }

    DBTree.PopulateLibraryTreeGlobal();        
    
    //
    // Load the Installed databases
    //
    LoadInstalledDataBases();

    //
    // Create the first empty database, and initialize pCurrentDatabase
    //
    pCurrentDatabase = new DATABASE(DATABASE_TYPE_WORKING);

    if (pCurrentDatabase == NULL) {
        MEM_ERR;
        return;
    } 

    DataBaseList.Add(pCurrentDatabase);
    
    pCurrentDatabase->bChanged      = FALSE;
    g_pEntrySelApp                  = NULL;
    g_pSelEntry                     = NULL;

    //
    // Increase the index. The next new database will have the default path of say UNTITLED_2.SDB
    //
    ++g_uNextDataBaseIndex;

    SetCaption();
    
    //
    // Now update the screen
    //
    DBTree.AddWorking(pCurrentDatabase);
    
    SetCaption();
    
    //
    // Set the new procs for the tree views and the content list, to handle the tab.
    //
    g_PrevTreeProc = (WNDPROC)GetWindowLongPtr(g_hwndEntryTree, GWLP_WNDPROC);
    g_PrevListProc = (WNDPROC)GetWindowLongPtr(g_hwndContentsList, GWLP_WNDPROC);

    SetWindowLongPtr(g_hwndEntryTree, GWLP_WNDPROC,(LONG_PTR) TreeViewProc);
    SetWindowLongPtr(DBTree.m_hLibraryTree, GWLP_WNDPROC,(LONG_PTR) TreeViewProc);
    SetWindowLongPtr(g_hwndContentsList, GWLP_WNDPROC,(LONG_PTR) ListViewProc);

    //
    // The events for the per-user and the installed datbase  modifications
    //
    g_arrhEventNotify[IND_PERUSER]  = CreateEvent(NULL, FALSE, FALSE, NULL);
    g_arrhEventNotify[IND_ALLUSERS] = CreateEvent(NULL, FALSE, FALSE, NULL);

    //
    // Listen for changes in the per-user settings
    //
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     APPCOMPAT_KEY_PATH,
                     0,
                     KEY_READ,
                     &g_hKeyNotify[IND_PERUSER]) == ERROR_SUCCESS) {
        
        RegNotifyChangeKeyValue(g_hKeyNotify[IND_PERUSER], 
                                TRUE, 
                                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                g_arrhEventNotify[IND_PERUSER],
                                TRUE);
    }
    
    //
    // Listen for installation or un-installation of databases
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     APPCOMPAT_KEY_PATH_INSTALLEDSDB,
                     0,
                     KEY_READ,
                     &g_hKeyNotify[IND_ALLUSERS]) == ERROR_SUCCESS) {
        
        RegNotifyChangeKeyValue(g_hKeyNotify[IND_ALLUSERS], 
                                TRUE, 
                                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_LAST_SET,
                                g_arrhEventNotify[IND_ALLUSERS],
                                TRUE);
    }

    //
    // Create the thread that will do the action if the registry keys on which we 
    // are listening gets modified
    //
    if (g_hKeyNotify[IND_PERUSER] || g_hKeyNotify[IND_ALLUSERS]) {

        DWORD dwId;

        g_hThreadWait = (HANDLE)_beginthreadex(NULL, 0, (PTHREAD_START)ThreadEventKeyNotify, NULL, 0, (unsigned int*)&dwId);
    }
    
    //
    // Size the main app window as it was the last time CompatAdmin was used and position the 
    // split bar just as it was the last time
    //
    LoadDisplaySettings();

    //
    // We will always have focus on a working database, so set the status bar to that
    //
    SetStatus(IDS_STA_WORKINGDB);

    //
    // Initialize html help
    //
    HtmlHelp(NULL, NULL, HH_INITIALIZE, (DWORD_PTR)&g_dwCookie);
}

void
HandleSizing(
    IN  HWND hDlg
    )
/*++
    
    HandleSizing

	Desc:	Handles the WM_SIZE for the main app dialog

	Params:
        IN  HWND hDlg:      The main dialog window

	Return:
        void

--*/
{
    int     nWidth;
    int     nHeight;
    int     nStatusbarTop;
    int     nWidthEntryTree; // Width of the entry tree, contents list and the rich edit
    RECT    rDlg;

    if (g_cWidth == 0 || g_cHeight == 0) {
        return;
    }

    GetWindowRect(hDlg, &rDlg);

    nWidth  = rDlg.right - rDlg.left;
    nHeight = rDlg.bottom - rDlg.top;

    int deltaW = nWidth - g_cWidth;
    int deltaH = nHeight - g_cHeight;

    HWND hwnd;
    RECT r;
    LONG height;

    HDWP hdwp = BeginDeferWindowPos(MAIN_WINDOW_CONTROL_COUNT);

    if (hdwp == NULL) {
        //
        // NULL indicates that insufficient system resources are available to 
        // allocate the structure. To get extended error information, call GetLastError.
        //
        assert(FALSE);
        goto End;
    }

    //
    // Status Bar
    //
    hwnd = GetDlgItem(hDlg, IDC_STATUSBAR);
    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   nStatusbarTop = r.top + deltaH,
                   r.right - r.left + deltaW,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);
    
    //
    // DataBase Tree
    //
    hwnd = GetDlgItem(hDlg, IDC_LIBRARY);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   r.right - r.left,
                   nStatusbarTop - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    height = r.bottom - r.top + deltaH;

    if (g_bDescWndOn) {
        height -= 100;
    }
    
    //
    // Entry Tree. NOTE that the the code for sizing the contents list and the 
    // rich edit control should immediately follow the code for resizing the 
    // entry tree
    //
    hwnd = GetDlgItem(hDlg, IDC_ENTRY);

    GetWindowRect(hwnd, &r);

    //
    // Note that we must calculate the width this way  before 
    // we Map the coords of the Entry tree wrt to the dialog box.
    // I had to get the width this way and forcibly set the width rather than
    // using r.right - r.left + deltaW where r is the mapped cords of the entry
    // tree, because there were some problems with 640x480 resol, in which
    // the entry tree, contents list and the rich edit control were getting out
    // of the dialog box on their right hand side. So we have to make sure that 
    // they do not overrun the dialog box anyway anytime
    //
    nWidthEntryTree = rDlg.right - r.left - GetSystemMetrics(SM_CXBORDER) - 1;
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);
    
    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   nWidthEntryTree,
                   height,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // Contents list.
    //
    hwnd = GetDlgItem(hDlg, IDC_CONTENTSLIST);
    
    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   nWidthEntryTree,
                   height,
                   SWP_NOZORDER | SWP_NOACTIVATE);

    
    //
    // Description control
    //
    hwnd = GetDlgItem(hDlg, IDC_DESCRIPTION);

    if (g_bDescWndOn) {

        DeferWindowPos(hdwp,
                       hwnd,
                       NULL,
                       r.left,
                       r.top + height,
                       nWidthEntryTree,
                       100,
                       SWP_NOZORDER | SWP_NOACTIVATE);

    } else {

        DeferWindowPos(hdwp,
                       hwnd,
                       NULL,
                       0,
                       0,
                       0,
                       0,
                       SWP_NOZORDER | SWP_NOACTIVATE);
    }
    

    //
    // ToolBar
    //
    hwnd = GetDlgItem(hDlg, ID_TOOLBAR);
    
    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, hDlg, (LPPOINT)&r, 2);

    DeferWindowPos(hdwp,
                   hwnd,
                   NULL,
                   r.left,
                   r.top,
                   r.right - r.left + deltaW,
                   r.bottom - r.top,
                   SWP_NOZORDER | SWP_NOACTIVATE);
                                          
    EndDeferWindowPos(hdwp);

    //
    // The rich edit sometimes does not paint itself properly
    //
    hwnd = GetDlgItem(hDlg, IDC_DESCRIPTION);
    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);

    //
    // Set the column width of the list view appropriately to cover the width of the list view
    //
    ListView_SetColumnWidth(GetDlgItem(hDlg, IDC_CONTENTSLIST), 0, LVSCW_AUTOSIZE_USEHEADER);

    InvalidateRect(hDlg, NULL, TRUE);
    UpdateWindow(hDlg);

    g_cWidth    = nWidth;
    g_cHeight   = nHeight;

End:
    return;
}

void
ContextMenuContentsList(
    IN  LPARAM lParam
    )
/*++
    
    ContextMenuContentsList
    
    Desc:   Pops up the context menu when we right click on the contents list.
            This is the list view that shows up in the RHS
            
    Params:
        IN  LPARAM lParam: the lParam of WM_CONTEXTMENU.
            Horizontal and vertical position of the cursor, in screen coordinates,
            at the time of the mouse click. 
--*/
{
    
    TYPE    type;
    UINT    uX = LOWORD(lParam);
    UINT    uY = HIWORD(lParam);
    
    HMENU hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_CONTEXT));

    if (hMenu == NULL) {
        return;
    }

    HMENU hContextMenu = NULL;

    //
    // BUGBUG:  This is only required if we ever show the databases in
    //          the contents list. Presently we do not show them in the
    //          contents list.
    //
    LPARAM  lParamOfSelectedItem = NULL;
    LVITEM  lvi;

    lvi.mask        = LVIF_PARAM;
    lvi.iItem       = ListView_GetSelectionMark(g_hwndContentsList);
    lvi.iSubItem    = 0;

    if (!ListView_GetItem(g_hwndContentsList, &lvi)) {
        assert(FALSE);
        goto End;
    }

    type = ConvertLparam2Type(lvi.lParam);

    if (type == DATABASE_TYPE_INSTALLED || type == DATABASE_TYPE_WORKING) {
        //
        // If we ever decide to show the datbases in the context list
        // presently we do not
        //
        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_DATABASE);
    } else {
        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_LIST);
    }

    TrackPopupMenuEx(hContextMenu,
                     TPM_LEFTALIGN | TPM_TOPALIGN,
                     uX,
                     uY,
                     g_hDlg,
                     NULL);
End:
    DestroyMenu(hMenu);
}


void
ContextMenuExeTree(
    IN  LPARAM lParam
    )
/*++
    
    ContextMenuExeTree
    
    Desc:   Pops up the context menu when we right click on the contents tree.
            This is the tree view that shows up in the RHS
            
    Params:
        IN  LPARAM lParam: the lParam of WM_CONTEXTMENU.
            Horizontal and vertical position of the cursor, in screen coordinates, 
            at the time of the mouse click. 
--*/
{
    UINT  uX = LOWORD(lParam);
    UINT  uY = HIWORD(lParam);

    HTREEITEM hItem =  TreeView_GetSelection(g_hwndEntryTree);

    if ((TYPE)GetItemType(g_hwndEntryTree, hItem) != TYPE_ENTRY) {
        return;
    }

    HMENU hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_CONTEXT));

    if (hMenu == NULL) {
        return;
    }

    HMENU hContextMenu = NULL;

    hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_FIX);

    TrackPopupMenuEx(hContextMenu,
                     TPM_LEFTALIGN | TPM_TOPALIGN,
                     uX,
                     uY,
                     g_hDlg,
                     NULL);

    DestroyMenu(hMenu);
}

void
ContextMenuLib(
    IN  LPARAM lParam
    )
/*++
    
    ContextMenuLib
    
    Desc:   Pops up the context menu when we right click on the db tree.
            This is the tree view that shows up in the LHS
            
    Params:
        IN  LPARAM lParam: the lParam of WM_CONTEXTMENU.
            Horizontal and vertical position of the cursor, 
            in screen coordinates, at the time of the mouse click. 
--*/
{
    UINT  uX = LOWORD(lParam);
    UINT  uY = HIWORD(lParam);
    
    HMENU hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_CONTEXT)), hContextMenu = NULL;

    if (hMenu == NULL) {
        return;
    }

    HTREEITEM hItemSelected = TreeView_GetSelection(DBTree.m_hLibraryTree);

    if (hItemSelected == NULL) {
        goto END;
    }

    TYPE type = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItemSelected);

    switch (type) {
    
    case DATABASE_TYPE_INSTALLED:
    case DATABASE_TYPE_GLOBAL:
    case DATABASE_TYPE_WORKING:

        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_DATABASE);
        break;

    case FIX_SHIM:
    case FIX_FLAG:
    case FIX_LAYER:

        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_APP_LAYER);

        if (type == FIX_LAYER) {

            //
            // A layer can be modified as well.
            //
            InsertMenu(hContextMenu, 
                       ID_EDIT_RENAME, 
                       MF_BYCOMMAND, 
                       ID_MODIFY_COMPATIBILITYMODE,
                       CSTRING(IDS_MODIFY));
        }

        break;

    case TYPE_ENTRY:

        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_APP_LAYER);
        break;

    case TYPE_GUI_APPS:
    case TYPE_GUI_LAYERS:

        //
        // We cannot rename if the focus is on the root of applications or layers
        //
        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_APP_LAYER);
        EnableMenuItem(hContextMenu, ID_EDIT_RENAME, MF_GRAYED);
        break;
    
    case TYPE_GUI_DATABASE_WORKING_ALL:
        
        hContextMenu = GetSubMenu(hMenu, MENU_CONTEXT_DATABASE_ALL);
        break;
    }

    if (hContextMenu  == NULL) {
        goto END;
    }
    
    TrackPopupMenuEx(hContextMenu,
                     TPM_LEFTALIGN | TPM_TOPALIGN,
                     uX,
                     uY,
                     g_hDlg,
                     NULL);

END:
    DestroyMenu(hMenu);
}

BOOL
HandleDBTreeSelChange(
    IN  HTREEITEM hItem
    )
/*++

    HandleDBTreeSelChange
    
    Desc:   Handles the TVN_SELCHANGE for the database tree (LHS)
    
    Params: 
        IN  HTREEITEM hItem: The newly selected tree item
        
    Return:
        FALSE:  If some error occurs, like invalid hItem
        TRUE:   Otherwise

    Notes:  A new item has been selected. If  this item is an app, 
            then we set the g_pSelEntry and  set the focus to the first entry of the EXE tree.
    
            Anyway we move till we find a DATABASE HTREEITEM and if the type of the database is  
            TYPE_DATABASE_WORKING, then we check if the database is the same as the 
            g_pPresentDataBase. 
    
            If not then we change the g_pPresentDataBase, and also 
            delete all the items on the  EXE Tree. and set both the g_pSelEntry and the 
            g_pEntrySelApp to NULL.
--*/
{   
    HTREEITEM   hItemTemp   = hItem;
    PDATABASE   pDataBase   = NULL;
    LPARAM      lParam;
    PDBENTRY    pApp;
    TYPE        type;

    type = TYPE_UNKNOWN;

    //
    // If the selected item is not an app/entry then we need to disable the run  
    // and the change enable status options. We do this by making the pointers to the currently 
    // selected app or entry as NULL so that everybody knows that we are not on an app
    //
    type = GetItemType(DBTree.m_hLibraryTree, hItem);

    if (type != TYPE_ENTRY) {
        //
        // We are not on some application node
        //
        g_pSelEntry     = NULL;
        g_pEntrySelApp  = NULL;
    }

    while (hItemTemp) {
        
        if (!DBTree.GetLParam(hItemTemp, &lParam)) {
            return FALSE;
        }

        type = (TYPE)lParam;

        if (type > TYPE_NULL) {
            type = ((PDS_TYPE)lParam)->type;
        }

        if (type == DATABASE_TYPE_WORKING 
            || type == DATABASE_TYPE_INSTALLED 
            || type == DATABASE_TYPE_GLOBAL) {
           
            pDataBase           = (PDATABASE)lParam;
            g_pPresentDataBase  = pDataBase;

            SetCaption();
            break;

        } else {
            hItemTemp = TreeView_GetParent(DBTree.m_hLibraryTree, hItemTemp);
        }
    }

    if (hItemTemp == NULL) {
        
        //
        // Selected item is above the database, such as the "Working DataBases" Item etc.
        //
        g_pPresentDataBase = NULL;
        g_pEntrySelApp = g_pSelEntry = NULL;
        SetCaption(FALSE);
    }

    if (hItemTemp == NULL) {
        TreeDeleteAll(g_hwndEntryTree);
        g_pEntrySelApp = g_pSelEntry = NULL;
    }

    //
    // If the selected item is an app then we have to update the g_hwndEntryTree
    //
    if (!DBTree.GetLParam(hItem, &lParam)) {
        return FALSE;
    }

    type = (TYPE)lParam;

    if (type > TYPE_NULL) {

        type = ((PDS_TYPE)lParam)->type;

        if (type == TYPE_ENTRY) {

            pApp = (PDBENTRY)lParam;
            
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            UpdateEntryTreeView(pApp, g_hwndEntryTree);
            SetCursor(LoadCursor(NULL, IDC_ARROW));

            g_pEntrySelApp = pApp;
        }
    }

    if (hItem == GlobalDataBase.hItemAllApps && !g_bMainAppExpanded) {
        //
        // We have clicked on the "Applications" tree item of the main database
        // and we have not loaded the exe entries of the main database as
        // yet, so let's do it now
        //
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        INT iResult = ShowMainEntries(g_hDlg);

        if (iResult == -1) {
            //
            // It is being loaded by somebody else. If we are using the query 
            // database feature then there we have a modeless window that 
            // creates a thread that calls ShowMainEntries(). We 
            // do not want that we should have two threads calling
            // ShowMainEntries() at any given time
            //
            
            //
            // The status message for the main dialog is changed to normal
            // when we finish ShowMainEntries()
            //
            SetStatus(g_hwndStatus, CSTRING(IDS_LOADINGMAIN));
            
            return TRUE;

        } else {
            SetCursor(LoadCursor(NULL, IDC_ARROW));
        }
    }

    if (type != TYPE_ENTRY) {
        
        //
        // The entry tree will need to be shown if type == TYPE_ENTRY
        //
        PostMessage(g_hDlg, WM_USER_POPULATECONTENTSLIST, 0, (LPARAM)hItem);
    }
    
    return TRUE;

}

void
UpdateDescWindowStatus(
    void
    )
/*++

    UpdateDescWindowStatus
    
    Desc:   Shows/hides the rich edit control aka Description window. 
            This will depend on the value of g_bDescWndOn. 
            If this is TRUE, we need to show the control otherwise 
            hide it
--*/
{
    HWND hwnd;
    RECT r;
    LONG height;

    hwnd = GetDlgItem(g_hDlg, IDC_LIBRARY);
    GetWindowRect(hwnd, &r);

    height = r.bottom - r.top;
    
    if (g_bDescWndOn) {
        height -= 100;
    }
    
    //
    // ENTRY TREE
    //
    hwnd = GetDlgItem(g_hDlg, IDC_ENTRY);

    GetWindowRect(hwnd, &r);
    MapWindowPoints(NULL, g_hDlg, (LPPOINT)&r, 2);

    MoveWindow(hwnd,
               r.left,
               r.top,
               r.right - r.left,
               height,
               TRUE);

    //
    // Contents list.
    //
    hwnd = GetDlgItem(g_hDlg, IDC_CONTENTSLIST);
    
    MoveWindow(hwnd,
               r.left,
               r.top,
               r.right - r.left,
               height,
               TRUE);
    
    hwnd = GetDlgItem(g_hDlg, IDC_DESCRIPTION);
    
    if (g_bDescWndOn) {

        MoveWindow(hwnd,
                   r.left,
                   r.top + height + 1,
                   r.right - r.left,
                   100,
                   TRUE);
        //
        // We need to show the control again if it was hidden.
        //
        ShowWindow(hwnd, SW_SHOWNORMAL);

    } else {

        MoveWindow(hwnd,
                   0,
                   0,
                   0,
                   0,
                   TRUE);
        //
        // We need to hide the control so that the tab ordering
        // is done properly
        //
        ShowWindow(hwnd, SW_HIDE);
    }
}

INT_PTR CALLBACK
CompatAdminDlgProc(
    IN  HWND   hdlg,
    IN  UINT   uMsg,
    IN  WPARAM wParam,
    IN  LPARAM lParam
    )
/*++
    
    CompatAdminDlgProc
    
    Desc:   The main message handler for the app. This routine handles the 
            messages for the main modeless dialog box
                
    Params: Standard dialog handler parameters
        
        IN  HWND   hDlg 
        IN  UINT   uMsg 
        IN  WPARAM wParam 
        IN  LPARAM lParam
        
    Return: Standard dialog handler return            
--*/

{
    UINT uMRUSelPos     = 0;
    int  wCode          = LOWORD(wParam);
    int  wNotifyCode    = HIWORD(wParam);

    switch (uMsg) {
        
    case WM_INITDIALOG:
        
        ProcessSwitches();

        InitializeCriticalSection(&g_critsectShowMain);
        InitializeCriticalSection(&s_csExpanding);
        InitializeCriticalSection(&g_csInstalledList);

        DoInitDialog(hdlg);

        //
        // Load any databases that were passed through the command line
        //
        PostMessage(hdlg, WM_USER_LOAD_COMMANDLINE_DATABASES, 0, 0);

        //
        // Load per-user settings.
        //
        LoadPerUserSettings();

        SetFocus(DBTree.m_hLibraryTree);
        break;
    
    case WM_USER_LOAD_COMMANDLINE_DATABASES:
        {
            int iArgc = 0;
            
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            
            LPWSTR* arParams = CommandLineToArgvW(GetCommandLineW(), &iArgc);
            
            if (arParams) {
    
                for (int iIndex = 1; iIndex < iArgc; ++iIndex) {
    
                    if (arParams[iIndex][0] == TEXT('-') || arParams[iIndex][0] == TEXT('/')) {
                        //
                        // Ignore the switches
                        //
                        continue;
                    }

                    LoadDataBase(arParams[iIndex]);
                }
            
                GlobalFree(arParams);
                arParams = NULL;
            }

            SetCursor(LoadCursor(NULL, IDC_ARROW));
            break;
        }

    case WM_USER_ACTIVATE:
        //
        // Some thread asked us to become the active window
        //
        SetActiveWindow(hdlg);
        SetFocus(hdlg);
        break;

    case WM_USER_UPDATEPERUSER:

        LoadPerUserSettings();
        break;

    case WM_USER_UPDATEINSTALLED:
        
        //
        // We should not update the list if we are doing a test run.
        // Note that because of this, if the installed database list gets changed when
        // we are doing a test run, we will not be able to see the changes, till the
        // next time we will have to refresh the list
        //
        if (!g_bUpdateInstalledRequired) {
            g_bUpdateInstalledRequired = TRUE;
            break;
        }

        LoadInstalledDataBases();
        break;

    case WM_USER_POPULATECONTENTSLIST:

        PopulateContentsList((HTREEITEM)lParam);
        break;

    case WM_INITMENUPOPUP:

        HandlePopUp(hdlg, wParam, lParam);
        break;
    
    case WM_USER_REPAINT_LISTITEM:
        {
            //
            // Here we will actually do the renaming of items of
            // the items in the contents list view
            //  
            LVITEM lvItem;
    
            lvItem.iItem    = (INT)wParam;
            lvItem.iSubItem = 0;
            lvItem.mask     = LVIF_PARAM;
    
            if (!ListView_GetItem(g_hwndContentsList, &lvItem)) {
                break;
            }
    
            TYPE   type = ConvertLparam2Type(lvItem.lParam);
            TCHAR* pchText = NULL;
    
            switch (type) {
            case TYPE_ENTRY:

                pchText = ((PDBENTRY)lParam)->strAppName.pszString;
                break;

            case FIX_LAYER:

                pchText = ((PLAYER_FIX)lParam)->strName.pszString;
                break;
            }
    
            ListView_SetItemText(g_hwndContentsList, lvItem.iItem, 0, pchText);
            break;
        }
    
    case WM_USER_REPAINT_TREEITEM:
        {
            //
            // Here we will actually do the renaming of items of
            // the items in the db tree (LHS)
            //
            HTREEITEM hItem     = (HTREEITEM)wParam;
            TCHAR*    pszText   = NULL;
            TYPE      type      = (TYPE)GetItemType(DBTree.m_hLibraryTree, hItem);
            
            switch (type) {
            case TYPE_ENTRY:

                pszText = ((PDBENTRY)lParam)->strAppName.pszString;
                break;

            case FIX_LAYER:

                pszText = ((PLAYER_FIX)lParam)->strName.pszString;
                break;
            }
            
            
            TVITEM Item;

            Item.mask       = TVIF_TEXT;
            Item.pszText    = pszText;
            Item.hItem      = hItem;

            TreeView_SetItem(DBTree.m_hLibraryTree, &Item);
    
            if (g_pPresentDataBase) {
                g_pPresentDataBase->bChanged = TRUE;

                //
                // We might need to change the caption to show that 
                // the database has changed. i.e. put a * there
                //
                SetCaption();
            }
            
            break;
        }
    
    case WM_CONTEXTMENU:
        {    
            HWND hWnd = (HWND)wParam;
            
            if (hWnd == g_hwndEntryTree) {          
                ContextMenuExeTree(lParam);

            } else if (hWnd == DBTree.m_hLibraryTree) {
                ContextMenuLib(lParam);    

            } else if (hWnd == g_hwndContentsList) {
                ContextMenuContentsList(lParam);
            }
            
            break;
        }
    
    case WM_LBUTTONDOWN:
        {
            RECT rectDBTree, rectEntryTree;
            
            GetWindowRect(GetDlgItem(hdlg, IDC_LIBRARY), &rectDBTree);
            MapWindowPoints(NULL, hdlg, (LPPOINT)&rectDBTree, 2);
    
            GetWindowRect(GetDlgItem(hdlg, IDC_ENTRY), &rectEntryTree);
            MapWindowPoints(NULL, hdlg, (LPPOINT)&rectEntryTree, 2);
    
            int iMX = (int)LOWORD(lParam);
            int iMY = (int)HIWORD(lParam);
    
            //
            // Check if we are on top of the split bar
            // 
            if (iMX > rectDBTree.right &&
                iMX < rectEntryTree.left &&
                iMY > rectDBTree.top &&
                iMY < rectDBTree.bottom) {
                
                SetCapture(hdlg);
                g_bDrag = TRUE;
                //
                // We need this to calculate how much and in which 
                // direction we are moving the split bar
                //
                g_iMousePressedX = iMX;
                
                SetCursor(LoadCursor(NULL, IDC_SIZEWE));
            
            } else {
                g_bDrag = FALSE;
            }
            
            break;
        }
    
    case WM_MOUSEMOVE:
        
        //
        // If g_bDrag is true then this routine will drag the split bar,
        // otherwise it will change the cursor to an WE arrow if we are on top
        // of the split bar
        // 
        OnMoveSplitter(hdlg,
                       lParam,
                       (wParam & MK_LBUTTON) && g_bDrag,
                       LOWORD(lParam) - g_iMousePressedX);
        
        
        break;

    case WM_LBUTTONUP:
        
        if (g_bDrag) {

            g_bDrag = FALSE;
            ReleaseCapture();

            //
            // Set the column width of the list view appropriately to cover the width 
            // of the list view
            //
            ListView_SetColumnWidth(g_hwndContentsList, 
                                    0, 
                                    LVSCW_AUTOSIZE_USEHEADER);
        }

        break;

    case WM_NOTIFY:
        {
            LPNMTREEVIEW pnmtv      = (LPNMTREEVIEW)lParam;
            LPNMHDR      lpnmhdr    = (LPNMHDR)lParam;
    
            if (lpnmhdr == NULL) {
                break;
            }
    
            if (lpnmhdr->code == TTN_GETDISPINFO) {
                ShowToolBarToolTips(hdlg, lParam);
                break;
            }
    
            if (lpnmhdr->idFrom == IDC_ENTRY) {
                HandleNotifyExeTree(hdlg, lParam);
                break;
            }
    
            if (lpnmhdr->idFrom == IDC_LIBRARY) {
                return HandleNotifyDBTree(hdlg, lParam);
            }
    
            if (lpnmhdr->idFrom == IDC_CONTENTSLIST) {
                return HandleNotifyContentsList(hdlg, lParam);
            }
            
            if (lpnmhdr->idFrom == IDC_DESCRIPTION) {

                if (lpnmhdr->code == EN_LINK) {
                    
                    ENLINK* penl = (ENLINK*)lParam;
    
                    if (penl->msg == WM_LBUTTONUP) {
                        
                        SHELLEXECUTEINFO sei = { 0 };
    
                        sei.cbSize = sizeof(SHELLEXECUTEINFO);
                        sei.fMask  = SEE_MASK_DOENVSUBST;
                        sei.hwnd   = hdlg;
                        sei.nShow  = SW_SHOWNORMAL;
                        sei.lpFile = g_szToolkitURL;
    
                        //
                        // Get more information about CompatAdmin stuff
                        //
                        ShellExecuteEx(&sei);
                    }
                }
            }
            
            break;
        }

    case WM_SIZE:

        if (wParam != SIZE_MINIMIZED) {

            HandleSizing(hdlg);

            if (wParam == SIZE_RESTORED) {
                
                //
                // We might have got minimized because some other
                // app came at the top. So when we again become
                // the top-level window, the user pressed alt-tab or clicked
                // on the icon in the taskbar then we should show the other
                // modeless dialog boxes as well, if they were visible earlier
                //
                if (g_hdlgSearchDB) {
                     ShowWindow(g_hdlgSearchDB, SW_RESTORE);
                }

                if (g_hdlgQueryDB) {
                    ShowWindow(g_hdlgQueryDB, SW_RESTORE);
                }

                if (g_hwndEventsWnd) {
                    ShowWindow(g_hwndEventsWnd, SW_RESTORE);
                }

                RECT    r;

                if (g_hwndToolBar) {
                    //
                    // This is required to handle the case when we restore
                    // the window after minimizing and changing the theme
                    //
                    SendMessage(g_hwndToolBar, WM_SIZE, wParam, lParam);
                    SendMessage(g_hwndStatus, WM_SIZE, wParam, lParam);
                }
            }

        } else {
            //
            // If the main app window is getting minimized the other modeless
            // dialog boxes should also get minimized. We have to handled it this
            // way because our modeless dialog boxes have the desktop as their parent
            // This was needed so that we could tab between our main window and 
            // the other windows
            //
            if (g_hdlgSearchDB) {
                 ShowWindow(g_hdlgSearchDB, SW_MINIMIZE);
            }

            if (g_hdlgQueryDB) {
                ShowWindow(g_hdlgQueryDB, SW_MINIMIZE);
            }

            if (g_hwndEventsWnd) {
                ShowWindow(g_hwndEventsWnd, SW_MINIMIZE);
            }

            return FALSE;
        }
        
        break;
    
    case WM_CLOSE:

        SendMessage(hdlg, WM_COMMAND, (WPARAM)ID_FILE_EXIT, 0);
        break;

    case WM_PAINT:

        DrawSplitter(hdlg);
        return FALSE;
            
    case WM_GETMINMAXINFO:
        {
            //
            // Limit the minimum size of the app window
            //
            MINMAXINFO* pmmi = (MINMAXINFO*)lParam;
    
            pmmi->ptMinTrackSize.x = 300;
            pmmi->ptMinTrackSize.y = 300;
    
            return 0;
        }

    case WM_COMMAND:
        
        switch (wCode) {
    
        case ID_FILE_MRU1:
        case ID_FILE_MRU2:
        case ID_FILE_MRU3:
        case ID_FILE_MRU4:
        case ID_FILE_MRU5:
                
            HandleMRUActivation(wCode);
            break;
    
        case ID_FILE_OPEN:

            OpenDatabaseFiles(hdlg);
            break;
        
        case ID_FIX_CREATEANEWAPPHELPMESSAGE:
            
            g_bSomeWizardActive = TRUE;
            CreateNewAppHelp();
            g_bSomeWizardActive = FALSE;
            break;
    
        case ID_MODIFY_APPHELPMESSAGE:
            
            g_bSomeWizardActive = TRUE;
            ModifyAppHelp();
            g_bSomeWizardActive = FALSE;
            break;
    
        case ID_FIX_CREATEANAPPLICATIONFIX:

            g_bSomeWizardActive = TRUE;
            CreateNewAppFix();
            g_bSomeWizardActive = FALSE;
            
            break;
        
        case ID_FIX_EXECUTEAPPLICATION:
            
            if (g_bAdmin == FALSE) {
                //
                // Non admins cannot do a test run because we need to invoke sdbinst.exe
                // to install the test database and sdbinst.exe cannot be invoked if we
                // do not have admin rights
                //
                MessageBox(hdlg, 
                           GetString(IDS_ERRORNOTADMIN), 
                           g_szAppName, 
                           MB_ICONINFORMATION);
                break;
            }

            if (g_pSelEntry) {

                TestRun(g_pSelEntry, &g_pSelEntry->strFullpath, NULL, g_hDlg);

                SetActiveWindow(hdlg);
                SetFocus(hdlg);
            }
            
            break;
        
        case ID_FIX_CHANGEENABLESTATUS:
            
            if (g_bAdmin) {
                ChangeEnableStatus();
            } else {
                //
                // Non admins cannot change the enable-disable status
                // because they do not have rights to HKLM reg key
                //
                MessageBox(hdlg, 
                           GetString(IDS_ERRORNOTADMIN), 
                           g_szAppName,
                           MB_ICONINFORMATION);
            }
            
            break;
    
        case ID_MODIFY_APPLICATIONFIX:

            g_bSomeWizardActive = TRUE;
            ModifyAppFix();
            g_bSomeWizardActive = FALSE;
            break;
    
        case ID_FIX_CREATENEWLAYER:

            g_bSomeWizardActive = TRUE;
            CreateNewLayer();
            g_bSomeWizardActive = FALSE;
            break;

        case ID_FILE_SAVE:
            {
                BOOL bReturn;
                
                if (g_pPresentDataBase && 
                    (g_pPresentDataBase->bChanged 
                     || NotCompletePath(g_pPresentDataBase->strPath))) {
    
                    //
                    // Error message will be displayed in the SaveDataBase func.
                    //
                    if (NotCompletePath(g_pPresentDataBase->strPath)) {
                        bReturn = SaveDataBaseAs(g_pPresentDataBase);
                    } else {
                        bReturn = SaveDataBase(g_pPresentDataBase, g_pPresentDataBase->strPath);
                    }
                }

                break;
            }

        case ID_VIEW_EVENTS:

            ShowEventsWindow();
            break;

        case ID_HELP_INDEX:
        case ID_HELP_SEARCH:
        case ID_HELP_TOPICS:
            
            ShowHelp(hdlg, wCode);
            break;

        case ID_HELP_ABOUT:

            ShellAbout(hdlg,
                       GetString(IDS_APPLICATION_NAME),
                       NULL,
                       LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_APPICON)));
            break;
    
        case ID_DATABASE_INSTALL_UNINSTALL:
            
            DoInstallUnInstall();
            break;
        
        case ID_FILE_SAVEAS:

            PreprocessForSaveAs(g_pPresentDataBase);
            SaveDataBaseAs(g_pPresentDataBase);
            break;             
    
        case IDCANCEL:

            TreeView_EndEditLabelNow(DBTree.m_hLibraryTree, TRUE);
            break;
    
        case ID_FILE_EXIT:
    
            TreeView_Expand(DBTree.m_hLibraryTree, DBTree.m_hItemGlobal, TVE_COLLAPSE);
            
            if (!CloseAllDatabases()) {
                //
                // Select the database that the user refused to save. (Pressed CANCEL)
                //
                TreeView_SelectItem(DBTree.m_hLibraryTree, g_pPresentDataBase->hItemDB);

            } else {

                s_bProcessExiting = TRUE;
    
                SaveDisplaySettings();       
                SaveMRUList();
                
                CoUninitialize();
    
                DestroyWindow(hdlg);
                PostQuitMessage(0);

                HtmlHelp(NULL, NULL, HH_CLOSE_ALL, 0) ;
                HtmlHelp(NULL, NULL, HH_UNINITIALIZE, (DWORD)g_dwCookie); 

                g_hDlg = NULL;

                #ifdef HELP_BOUND_CHECK
                    OnExitCleanup();
                #endif
            }

            break;
    
        case ID_EDIT_DELETE:

            OnDelete();
            break;
    
        case ID_FILE_PROPERTIES:
    
            DialogBoxParam(g_hInstance,
                           MAKEINTRESOURCE(IDD_DBPROPERTIES),
                           g_hDlg,
                           ShowDBPropertiesDlgProc,
                           (LPARAM)g_pPresentDataBase);
            break;
    
        case ID_FILE_NEW:
            
            CreateNewDatabase();
            break;
        
        case ID_TOOLS_SEARCHFORFIXES:
            {
                if (g_hdlgSearchDB) {
                    //
                    // We must not allow more than one instance of 
                    // the search window, because we use some global variables there.
                    // If it is already there set the focus to the search window
                    //
                    ShowWindow(g_hdlgSearchDB, SW_SHOWNORMAL);
                    SetFocus(g_hdlgSearchDB);

                } else {
                    //
                    // This object is deleted in the WM_DESTROY of the search dialog box.
                    // Note that this has to be allocated on the heap, because this object 
                    // is used in the UI for the search dialog, which is implemented as
                    // a modeless dialog box. So the lifetime of this object exceeds that
                    // of the block in which it is defined
                    //
                    CSearch* pSearch =  new CSearch;

                    if (pSearch == NULL) {
                        MEM_ERR;
                        break;
                    }

                    pSearch->Begin();
                }

                break;
            }
    
        case ID_DATABASE_CLOSE:

            OnDatabaseClose();
            break;
    
        case ID_SEARCH_QUERYDATABASE:

            if (g_hdlgQueryDB) {
                //
                // We must not allow more than one instance of 
                // the query window, because we use some global variables there.
                // If it is already there set the focus to the search window
                //
                ShowWindow(g_hdlgQueryDB, SW_SHOWNORMAL);
                SetFocus(g_hdlgQueryDB);

            } else {

                HWND hwnd = CreateDialog(g_hInstance, 
                                         MAKEINTRESOURCE(IDD_QDB), 
                                         GetDesktopWindow(), 
                                         QueryDBDlg);

                ShowWindow(hwnd, SW_SHOWNORMAL);
            }

            break;
    
        case ID_DATABASE_CLOSEALL:
            {
                
                HTREEITEM 