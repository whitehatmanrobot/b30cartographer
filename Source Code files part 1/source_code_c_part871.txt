ed thru the entire list and got back to the
     *   head, this will insert the new entry at the tail.)
     */
    InsertTailList( Next, &pTimer->Links );
    pTimer->Flags |= TIMER_ENABLED;

    /*
     *  Update timer if needed.
     *  (If we just added this entry to the head of the list, the timer
     *   needs to be set.  Also, if fSetTimer is TRUE, then this entry was
     *   removed by _TimerRemove and was the head entry, so set the timer.)
     */
    if ( pThread->TimerHead.Flink == &pTimer->Links || fSetTimer ) {
        Status = _TimerSet( pThread );
        if ( !NT_SUCCESS(Status) )
            goto badset;
    }

    /*
     *  Unlock timer semaphore
     */
    RtlLeaveCriticalSection( &TimerCritSec );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     *  timer set failed
     *  timer create failed
     *  timer initialization failed
     */
badset:
    RtlLeaveCriticalSection( &TimerCritSec );
    ASSERT( Status == STATUS_SUCCESS );
    return( Status );
}


/*******************************************************************************
 *
 *  IcaTimerCancel
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 *
 ******************************************************************************/

BOOLEAN
IcaTimerCancel( HANDLE TimerHandle )
{
    PCLIBTIMERTHREAD pThread;
    PCLIBTIMER pTimer;
    BOOLEAN fCanceled = FALSE;

    /*
     *  Lock timer semaphore
     */
    RtlEnterCriticalSection( &TimerCritSec );

    /*
     *  Get timer pointer
     */
    pTimer = (PCLIBTIMER) TimerHandle;
    pThread = pTimer->pThread;

    /*
     * Remove timer if it is enabled
     */
    if ( (pTimer->Flags & TIMER_ENABLED) ) {
        _TimerRemove( pThread, pTimer, TRUE );
        fCanceled = TRUE;
    }

    /*
     *  Unlock timer semaphore
     */
    RtlLeaveCriticalSection( &TimerCritSec );

    return( fCanceled );
}




/*******************************************************************************
 *
 *  IcaTimerClose
 *
 *  cancel the specified timer
 *
 *
 *  ENTRY:
 *     TimerHandle (input)
 *        timer handle
 *
 *  EXIT:
 *     TRUE  : timer was actually canceled
 *     FALSE : timer was not armed
 *
 *
 ******************************************************************************/

BOOLEAN
IcaTimerClose( HANDLE TimerHandle )
{
    BOOLEAN fCanceled;

    /*
     * Cancel timer if it is enabled
     */
    fCanceled = IcaTimerCancel( TimerHandle );

    /*
     * Free timer memory
     */
    MemFree( TimerHandle );

    return( fCanceled );
}


/*******************************************************************************
 *
 *  _TimerSet
 *
 *  set the timer
 *
 *  NOTE: timer semaphore must be locked
 *
 *
 *  ENTRY:
 *     pThread (input)
 *         pointer to timer thread structure
 *
 *  EXIT:
 *     NO_ERROR : successful
 *
 *
 ******************************************************************************/

NTSTATUS
_TimerSet( PCLIBTIMERTHREAD pThread )
{
    PCLIBTIMER pTimer;
    LARGE_INTEGER Time;
    // the following is roughly 1 year in 100 nanosecond increments
    static LARGE_INTEGER LongWaitTime = { 0, 0x00010000 };

    /*
     *  Get ExpireTime for next timer entry or 'large' value if none
     */
    if ( pThread->TimerHead.Flink != &pThread->TimerHead ) {
        pTimer = CONTAINING_RECORD( pThread->TimerHead.Flink, CLIBTIMER, Links );
        Time = pTimer->ExpireTime;
    } else {
        LARGE_INTEGER CurrentTime;

        NtQuerySystemTime( &CurrentTime );
        Time = RtlLargeIntegerAdd( CurrentTime, LongWaitTime );
    }

    /*
     *  Set the timer
     */
    return( NtSetTimer( pThread->hTimer, &Time, NULL, NULL, FALSE, 0, NULL ) );
}


/*******************************************************************************
 *
 *  _TimerRemove
 *
 *  remove the specified timer from the timer list
 *  and optionally set the time for the next timer to trigger
 *
 *  NOTE: timer semaphore must be locked
 *
 *
 *  ENTRY:
 *     pThread (input)
 *         pointer to timer thread structure
 *     pTimer (input)
 *        timer entry pointer
 *     SetTimer (input)
 *        BOOLEAN which indicates if _TimerSet should be called
 *
 *  EXIT:
 *     TRUE : timer needs to be set (removed entry was head of list)
 *     FALSE : timer does not need to be set
 *
 *
 ******************************************************************************/

BOOLEAN
_TimerRemove( PCLIBTIMERTHREAD pThread, PCLIBTIMER pTimer, BOOLEAN fSetTimer )
{
    BOOLEAN fSetNeeded = FALSE;
    NTSTATUS Status;

    /*
     *  See if timer is currently enabled
     */
    if ( (pTimer->Flags & TIMER_ENABLED) ) {

        /*
         *  Unlink the entry from the timer list and clear enabled flag
         */
        RemoveEntryList( &pTimer->Links );
        pTimer->Flags &= ~TIMER_ENABLED;

        /*
         *  If we removed the head entry, then set the timer
         *  or indicate to caller that it needs to be set.
         */
        if ( pTimer->Links.Blink == &pThread->TimerHead ) {
            if ( fSetTimer ) {
                Status = _TimerSet( pThread );
                ASSERT( Status == STATUS_SUCCESS );
            } else {
                fSetNeeded = TRUE;
            }
        }
    }

    return( fSetNeeded );
}


/*******************************************************************************
 *
 *  _TimerThread
 *
 *
 * ENTRY:
 *     pThread (input)
 *         pointer to timer thread structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

DWORD
_TimerThread( PCLIBTIMERTHREAD pThread )
{
    PCLIBTIMER pTimer;
    PCLIBTIMERFUNC pFunc;
    PVOID pParam;
    LARGE_INTEGER CurrentTime;
    NTSTATUS Status;

    for (;;) {

        /*
         *  Wait on timer
         */
        Status = NtWaitForSingleObject( pThread->hTimer, TRUE, NULL );

        /*
         *  Check for an error
         */
        if ( Status != STATUS_WAIT_0 )
            break;

        /*
         *  Lock semaphore
         */
        RtlEnterCriticalSection( &TimerCritSec );

        /*
         *  Make sure a timer entry exists
         */
        if ( IsListEmpty( &pThread->TimerHead ) ) {
            Status = _TimerSet( pThread );
            ASSERT( Status == STATUS_SUCCESS );
            RtlLeaveCriticalSection( &TimerCritSec );
            continue;
        }

        /*
         *  Make sure the head entry should be removed now.
         *  (The timer may have been triggered while the
         *   head entry was being removed.)
         */
        pTimer = CONTAINING_RECORD( pThread->TimerHead.Flink, CLIBTIMER, Links );
        NtQuerySystemTime( &CurrentTime );
        if ( RtlLargeIntegerGreaterThan( pTimer->ExpireTime, CurrentTime ) ) {
            Status = _TimerSet( pThread );
            ASSERT( Status == STATUS_SUCCESS );
            RtlLeaveCriticalSection( &TimerCritSec );
            continue;
        }

        /*
         * Remove the entry and indicate it is no longer enabled
         */
        RemoveEntryList( &pTimer->Links );
        pTimer->Flags &= ~TIMER_ENABLED;

        /*
         *  Set the timer for next time
         */
        Status = _TimerSet( pThread );
        ASSERT( Status == STATUS_SUCCESS );

        /*
         *  Get all the data we need out of the timer structure
         */
        pFunc  = pTimer->pFunc;
        pParam = pTimer->pParam;

        /*
         *  Unload semaphore
         */
        RtlLeaveCriticalSection( &TimerCritSec );

        /*
         *  Call timer function
         */
        if ( pFunc ) {
            (*pFunc)( pParam );
        }
    }

    pThread->hTimerThread = NULL;
    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\wininit.c ===
/*************************************************************************
*
* wininit.c
*
* Window station init and destroy routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

/*
 *  Local data
 */
#define LOGOFF_TIMER 120000L
#define MODULE_SIZE 1024    /* Default size for retrive of module data */
#define VDDATA_LENGTH 1024

/*
 *  Internal Procedures
 */
VOID StartLogonTimers( PWINSTATION );
VOID IdleTimeout( ULONG );
VOID LogonTimeout( ULONG );
VOID IdleLogoffTimeout( ULONG );
VOID LogoffTimeout( ULONG );


/*******************************************************************************
 *
 *  StartLogonTimers
 *
 *  This routine is called when an user is logged on.
 *  Timers are started for idle input and total logon time.
 *
 * ENTRY:
 *   None.
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID
StartLogonTimers( PWINSTATION pWinStation )
{
    int Status;
    ULONG Timer;
    BOOL bValidHelpSession;

    // for Session0 and any console sessions, timeouts don't make sense
    if ( ( pWinStation->LogonId != 0 ) && ( pWinStation->LogonId != USER_SHARED_DATA->ActiveConsoleId  ) ) {

        if( TSIsSessionHelpSession(pWinStation, &bValidHelpSession) ) {
            ASSERT( TRUE == bValidHelpSession );
            return;
        }

        if ( Timer = pWinStation->Config.Config.User.MaxIdleTime ) {
            if ( !pWinStation->fIdleTimer ) {
                Status = IcaTimerCreate( 0, &pWinStation->hIdleTimer );
                if ( NT_SUCCESS( Status ) )
                    pWinStation->fIdleTimer = TRUE;
                else
                    DBGPRINT(( "StartLogonTimers - failed to create idle timer \n" ));
            }
            if ( pWinStation->fIdleTimer )
                IcaTimerStart( pWinStation->hIdleTimer, IdleTimeout,
                            LongToPtr( pWinStation->LogonId ), Timer );
        }

        if ( Timer = pWinStation->Config.Config.User.MaxConnectionTime ) {
            if ( !pWinStation->fLogonTimer ) {
                Status = IcaTimerCreate( 0, &pWinStation->hLogonTimer );
                if ( NT_SUCCESS( Status ) )
                    pWinStation->fLogonTimer = TRUE;
                else
                    DBGPRINT(( "StartLogonTimers - failed to create logon timer \n" ));
            }
            if ( pWinStation->fLogonTimer )
                IcaTimerStart( pWinStation->hLogonTimer, LogonTimeout,
                            LongToPtr( pWinStation->LogonId ), Timer );
        }
    }
}


/*******************************************************************************
 *
 *  IdleTimeout
 *
 *  This routine is called when the idle timer expires.
 *  Send the user a warning message and start timer to logoff in 2 minutes.
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID IdleTimeout( ULONG LogonId )
{
    LARGE_INTEGER liT;
    ULONG ulTimeDelta;
    ICA_STACK_LAST_INPUT_TIME Ica_Stack_Last_Input_Time;
    NTSTATUS Status;
    ULONG cbReturned;
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation ) 
        return;

    if ( !pWinStation->hStack )
        goto done;

    if ( !pWinStation->fIdleTimer )
        goto done;

    //  Check for availability
    if ( pWinStation->pWsx && 
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME,
                                NULL,
                                0,
                                &Ica_Stack_Last_Input_Time,
                                sizeof( Ica_Stack_Last_Input_Time ),
                                &cbReturned );
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    /*
     *  Check if there was input during the idle time
     */
    NtQuerySystemTime( &liT );
    // calculate delta in time & convert from 100ns unit to milliseconds
    liT = RtlExtendedLargeIntegerDivide(
            RtlLargeIntegerSubtract( liT, Ica_Stack_Last_Input_Time.LastInputTime ),
            10000, NULL );
    ulTimeDelta = (ULONG)liT.LowTime;

    TRACE((hTrace,TC_ICASRV,TT_API1, "IdleTimeout: delta = %d, max idle = %d\n", ulTimeDelta,
                                 pWinStation->Config.Config.User.MaxIdleTime ));

    if ( ulTimeDelta < pWinStation->Config.Config.User.MaxIdleTime ) {
        IcaTimerStart( pWinStation->hIdleTimer, IdleTimeout, LongToPtr( LogonId ),
                      pWinStation->Config.Config.User.MaxIdleTime - ulTimeDelta );
    } else {
        TCHAR szTitle[128];
        TCHAR szMsg[256];
        int cchTitle, cchMessage;

        IcaTimerStart( pWinStation->hIdleTimer, IdleLogoffTimeout,
                       LongToPtr( LogonId ), LOGOFF_TIMER );


        if ( !(cchTitle = LoadString(hModuleWin, STR_CITRIX_IDLE_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR))) )
           goto done;
        if ( pWinStation->Config.Config.User.fResetBroken )
        {

            if ( !(cchMessage = LoadString(hModuleWin, STR_CITRIX_IDLE_MSG_LOGOFF, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
               goto done;
        }
        else
        {
            if ( !(cchMessage = LoadString(hModuleWin, STR_CITRIX_IDLE_MSG_DISCON, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
               goto done;

        }

        msg.u.SendMessage.pTitle = szTitle;
        msg.u.SendMessage.TitleLength = (cchTitle+1) * sizeof(TCHAR);
        msg.u.SendMessage.pMessage = szMsg;
        msg.u.SendMessage.MessageLength = (cchMessage+1) * sizeof(TCHAR);
        msg.u.SendMessage.Style = MB_OK | MB_ICONSTOP;
        msg.u.SendMessage.Timeout = (ULONG)LOGOFF_TIMER/1000;
        msg.u.SendMessage.Response = 0;
        msg.u.SendMessage.DoNotWait = TRUE;
        msg.u.SendMessage.DoNotWaitForCorrectDesktop = FALSE;
        
        // since we dont care abou response, or message delievery status;
        msg.u.SendMessage.pStatus = NULL;
        msg.u.SendMessage.pResponse = NULL;
        msg.u.SendMessage.hEvent = NULL;


        msg.ApiNumber = SMWinStationDoMessage;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

    }
done:
    ReleaseWinStation( pWinStation );
}

/*******************************************************************************
 *
 *  LogonTimeout
 *
 *  This routine is called when the logon timer expires.
 *  Send the user a warning message and start timer to logoff in 2 minutes.
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID LogonTimeout( ULONG LogonId )
{
    TCHAR szTitle[128];
    TCHAR szMsg[256];
    PWINSTATION pWinStation;
    NTSTATUS Status;
    WINSTATION_APIMSG msg;
    int cchTitle, cchMsg;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation )
        return;

    if ( !pWinStation->fLogonTimer)
        goto done;

    if ( !(cchTitle = LoadString(hModuleWin, STR_CITRIX_LOGON_TITLE, szTitle, sizeof(szTitle)/sizeof(TCHAR)) ))
        goto done;
    if ( pWinStation->Config.Config.User.fResetBroken )
    {
        if ( !(cchMsg = LoadString(hModuleWin, STR_CITRIX_LOGON_MSG_LOGOFF, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
            goto done;
    }
    else
    {
        if ( !(cchMsg = LoadString(hModuleWin, STR_CITRIX_LOGON_MSG_DISCON, szMsg, sizeof(szMsg)/sizeof(TCHAR)) ))
            goto done;
    }

    msg.u.SendMessage.pTitle = szTitle;
    msg.u.SendMessage.TitleLength = ( cchTitle+1 ) * sizeof(TCHAR);
    msg.u.SendMessage.pMessage = szMsg;
    msg.u.SendMessage.MessageLength = ( cchMsg+1 ) * sizeof(TCHAR);
    msg.u.SendMessage.Style = MB_OK | MB_ICONSTOP;
    msg.u.SendMessage.Timeout = (ULONG)LOGOFF_TIMER/1000;
    msg.u.SendMessage.Response = 0;
    msg.u.SendMessage.DoNotWait = TRUE;
    msg.u.SendMessage.DoNotWaitForCorrectDesktop = FALSE;

    // since we dont care abou response, or message delievery status;
    msg.u.SendMessage.pStatus = NULL;
    msg.u.SendMessage.pResponse = NULL;
    msg.u.SendMessage.hEvent = NULL;


    msg.ApiNumber = SMWinStationDoMessage;
    Status = SendWinStationCommand( pWinStation, &msg, 0 );

    IcaTimerStart( pWinStation->hLogonTimer, LogoffTimeout,
                   LongToPtr( LogonId ), LOGOFF_TIMER );
    if (pWinStation->fIdleTimer) {
        pWinStation->fIdleTimer = FALSE;
        IcaTimerClose( pWinStation->hIdleTimer );
    }
done:
    ReleaseWinStation( pWinStation );
}



/*******************************************************************************
 *
 *  IdleLogoffTimeout
 *
 *  This routine is called when the logoff timer expires.
 *  Check for input before logging user off
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID IdleLogoffTimeout( ULONG LogonId )
{
    LARGE_INTEGER liT;
    ULONG ulTimeDelta;
    ICA_STACK_LAST_INPUT_TIME Ica_Stack_Last_Input_Time;
    NTSTATUS Status;
    ULONG cbReturned;
    PWINSTATION pWinStation;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation ) 
        return;

    if ( !pWinStation->hStack )
        goto done;

    if ( !pWinStation->fIdleTimer )
        goto done;

    //  Check for availability
    if ( pWinStation->pWsx && 
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pWinStation->hStack,
                                IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME,
                                NULL,
                                0,
                                &Ica_Stack_Last_Input_Time,
                                sizeof( Ica_Stack_Last_Input_Time ),
                                &cbReturned );
    }
    else {
        Status = STATUS_INVALID_PARAMETER;
    }

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    NtQuerySystemTime( &liT );
    liT = RtlExtendedLargeIntegerDivide(
            RtlLargeIntegerSubtract( liT, Ica_Stack_Last_Input_Time.LastInputTime ),
            10000, NULL );
    ulTimeDelta = (ULONG)liT.LowTime;

    TRACE((hTrace,TC_ICASRV,TT_API1, "IdleTimeout: delta = %d, max idle = %d\n", ulTimeDelta,
                                                          LOGOFF_TIMER ));

    if ( ulTimeDelta < LOGOFF_TIMER ) {
        IcaTimerStart( pWinStation->hIdleTimer, IdleTimeout, LongToPtr( LogonId ),
                    pWinStation->Config.Config.User.MaxIdleTime - ulTimeDelta );
    } else
        LogoffTimeout( LogonId );

done:
    ReleaseWinStation( pWinStation );
}



/*******************************************************************************
 *
 *  LogoffTimeout
 *
 *  This routine is called when the logoff timer expires.
 *  Log user off and disconnect the winstation.
 *
 * ENTRY:
 *   LogonId - LogonId to logout
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID LogoffTimeout(ULONG LogonId)
{
    PWINSTATION pWinStation;

    pWinStation = FindWinStationById( LogonId, FALSE );

    if ( !pWinStation ) 
        return;

    //
    // Report disconnect reason back to client
    //
    if(pWinStation->WinStationName[0] &&
       pWinStation->pWsx &&
       pWinStation->pWsx->pWsxSetErrorInfo &&
       pWinStation->pWsxContext)
    {
        ULONG discReason = 0;
        if(pWinStation->fIdleTimer)
        {
            discReason = TS_ERRINFO_IDLE_TIMEOUT;
        }
        else if(pWinStation->fLogonTimer)
        {
            discReason = TS_ERRINFO_LOGON_TIMEOUT;
        }

        if(discReason)
        {
            pWinStation->pWsx->pWsxSetErrorInfo(
                               pWinStation->pWsxContext,
                               discReason,
                               FALSE); //stack lock not held
        }
    }

    if ( pWinStation->Config.Config.User.fResetBroken ) {
        ReleaseWinStation( pWinStation );
        QueueWinStationReset( LogonId );
    }
    else {
        ReleaseWinStation( pWinStation );
        QueueWinStationDisconnect( LogonId );
    }
}


/*******************************************************************************
 *
 *  DisconnectTimeout
 *
 *  This routine is called when the disconnect timer expires.
 *  Reset the winstation.
 *
 * ENTRY:
 *   LogonId
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID DisconnectTimeout( ULONG LogonId )
{
    //This timer pops for a disconnected session
    //so there is no need to report an error back to
    //the client
    QueueWinStationReset( LogonId );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\winget.c ===
/****************************************************************************/
// winget.c
//
// TermSrv RPC query handler.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "rpcwire.h"
#include "conntfy.h" // for GetLockedState

#include <winsock2.h>
#include <ws2tcpip.h>

#define MODULE_SIZE 1024
extern WCHAR g_DigProductId[CLIENT_PRODUCT_ID_LENGTH];

// Extern function
extern NTSTATUS _CheckCallerLocalAndSystem(VOID);

/*=============================================================================
==   Private functions
=============================================================================*/
NTSTATUS xxxGetUserToken(PWINSTATION, WINSTATIONUSERTOKEN UNALIGNED *, ULONG);


/*=============================================================================
==   Functions Used
=============================================================================*/
NTSTATUS xxxWinStationQueryInformation(ULONG, WINSTATIONINFOCLASS,
        PVOID, ULONG, PULONG);

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

NTSTATUS
RpcCheckSystemClientEx(
    PWINSTATION pWinStation
    );

NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    );

BOOLEAN
ValidWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen);

BOOLEAN
IsCallerAllowedPasswordAccess(VOID);

//
// Query client's IP Address.
//
extern NTSTATUS
xxxQueryRemoteAddress(
    PWINSTATION pWinStation,
    PWINSTATIONREMOTEADDRESS pRemoteAddress
    )
{
    struct sockaddr_in6 addr6;
    ULONG   AddrBytesReturned;
    NTSTATUS Status;

    if( pWinStation->State != State_Active && pWinStation->State != State_Connected )
    {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
    }
    else
    {
        Status = IcaStackIoControl( pWinStation->hStack,
                                    IOCTL_TS_STACK_QUERY_REMOTEADDRESS,
                                    pWinStation->pEndpoint,
                                    pWinStation->EndpointLength,
                                    &addr6,
                                    sizeof( addr6 ),
                                    &AddrBytesReturned
                                );

        if( NT_SUCCESS(Status) )
        {
            pRemoteAddress->sin_family = addr6.sin6_family;
            if( AF_INET == addr6.sin6_family )
            {
                struct sockaddr_in* pAddr = (struct sockaddr_in *)&addr6;

                pRemoteAddress->ipv4.sin_port = pAddr->sin_port;
                pRemoteAddress->ipv4.in_addr = pAddr->sin_addr.s_addr;
            }
            else
            {
                // Support of IPV6 is for next release.
                Status = STATUS_NOT_SUPPORTED;
            }
        }
    }

    return Status;
}


ULONG GetLoadMetrics(PWINSTATIONLOADINDICATORDATA pLIData)
{
    SYSTEM_PERFORMANCE_INFORMATION SysPerfInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorInfo[MAX_PROCESSORS];
    SYSTEM_BASIC_INFORMATION BasicInfo;

    LARGE_INTEGER TotalCPU = {0, 0};
    LARGE_INTEGER IdleCPU = {0, 0};
    LARGE_INTEGER TotalCPUDelta = {0, 0};
    LARGE_INTEGER IdleCPUDelta = {0, 0};
    ULONG         AvgIdleCPU, AvgBusyCPU, CPUConstrainedSessions;

    ULONG RemainingSessions = 0;
    LOADFACTORTYPE LoadFactor = ErrorConstraint;
    ULONG MinSessions;
    ULONG NumWinStations;
    NTSTATUS StatusPerf, StatusProc, StatusBasic;
    ULONG i;

    // Initialize additional data area
    memset(pLIData->reserved, 0, sizeof(pLIData->reserved));

    // Determine the number of active winstations in the system.  If there
    // aren't any, just assume 1 so we don't have to special case the logic
    // too much.  Note that this code counts the console.
    if (WinStationTotalCount > IdleWinStationPoolCount)
        NumWinStations = WinStationTotalCount - IdleWinStationPoolCount;
    else
        NumWinStations = 1;

    TRACE((hTrace, TC_LOAD, TT_API1,
           "Session Statistics: Total [%ld], Idle [%ld], Disc [%ld]\n",
           WinStationTotalCount, IdleWinStationPoolCount, WinStationDiscCount));

    //
    // Get basic info like total memory, etc.
    //
    StatusBasic = NtQuerySystemInformation(SystemBasicInformation,
                                           &BasicInfo, sizeof(BasicInfo),
                                           NULL);

    //
    // Get resource (memory) utilization metrics
    //
    StatusPerf = NtQuerySystemInformation(SystemPerformanceInformation,
                                          &SysPerfInfo, sizeof(SysPerfInfo), 
                                          NULL);

    //
    // Get CPU utilization metrics
    //
    StatusProc = NtQuerySystemInformation(SystemProcessorPerformanceInformation,
                                          ProcessorInfo, 
                                          sizeof(ProcessorInfo),
                                          NULL);

    if (gLB.fInitialized && 
        NT_SUCCESS(StatusPerf) && 
        NT_SUCCESS(StatusProc) &&
        NT_SUCCESS(StatusBasic)) {

        ULONG DefaultPagedPool, DefaultPtes, DefaultCommit;
        ULONG CommitAvailable;

        //
        // Determine resource usage for all sessions, subtracting out the 
        // resources required by the base system.  Readjust the base 
        // calculations if they become nonsensical.
        //
    
        // total committment and average consumption
        CommitAvailable = (ULONG)(SysPerfInfo.CommitLimit - SysPerfInfo.CommittedPages);
        if (gLB.BaselineCommit < SysPerfInfo.CommittedPages) {
            gLB.CommitUsed = (ULONG)(SysPerfInfo.CommittedPages - gLB.BaselineCommit);
            gLB.AvgCommitPerUser = max(gLB.CommitUsed / NumWinStations, 
                                       gLB.MinCommitPerUser);
            DefaultCommit = FALSE;
        }
        else {
            gLB.CommitUsed = 0;
            gLB.AvgCommitPerUser = gLB.MinCommitPerUser;
            gLB.BaselineCommit = (ULONG)(SysPerfInfo.CommittedPages);
            DefaultCommit = TRUE;
        }
                    
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Commit:       Base [%6ld], Used [%6ld], Avail: [%6ld], AvgPerUser: [%6ld]%s\n", 
               gLB.BaselineCommit,
               gLB.CommitUsed, 
               CommitAvailable, 
               gLB.AvgCommitPerUser,
               DefaultCommit ? "*" : ""));
    
        // total system PTEs used and average consumption
        if (gLB.BaselineFreePtes > SysPerfInfo.FreeSystemPtes) {
            gLB.PtesUsed = gLB.BaselineFreePtes - SysPerfInfo.FreeSystemPtes;
            gLB.AvgPtesPerUser = max(gLB.PtesUsed / NumWinStations, 
                                     gLB.MinPtesPerUser);
            DefaultPtes = FALSE;
        }
        else {
            gLB.PtesUsed = 0;
            gLB.AvgPtesPerUser = gLB.MinPtesPerUser;
            gLB.BaselineFreePtes = SysPerfInfo.FreeSystemPtes;
            DefaultPtes = TRUE;
        }

        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Ptes:         Base [%6ld], Used [%6ld], Avail: [%6ld], AvgPerUser: [%6ld]%s\n", 
               gLB.BaselineFreePtes, 
               gLB.PtesUsed, 
               SysPerfInfo.FreeSystemPtes, 
               gLB.AvgPtesPerUser,
               DefaultPtes ? "*" : ""));                
                    
        // paged pool used and average consumption
        if (gLB.BaselinePagedPool < SysPerfInfo.PagedPoolPages) {
            gLB.PagedPoolUsed = SysPerfInfo.PagedPoolPages - gLB.BaselinePagedPool;
            gLB.AvgPagedPoolPerUser = max(gLB.PagedPoolUsed / NumWinStations, 
                                          gLB.MinPagedPoolPerUser);
            DefaultPagedPool = FALSE;
        }
        else {
            gLB.PagedPoolUsed = 0;
            gLB.AvgPagedPoolPerUser = gLB.MinPagedPoolPerUser;
            gLB.BaselinePagedPool = SysPerfInfo.PagedPoolPages;
            DefaultPagedPool = TRUE;            
        }

        TRACE((hTrace, TC_LOAD, TT_API1,
               "   PagedPool:    Base [%6ld], Used [%6ld], Avail: [%6ld], AvgPerUser: [%6ld]%s\n", 
               gLB.BaselinePagedPool,
               gLB.PagedPoolUsed, 
               SysPerfInfo.AvailablePagedPoolPages, 
               gLB.AvgPagedPoolPerUser,
               DefaultPagedPool ? "*" : ""));
            
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Session Raw: Commit  [%4ld], Pte    [%4ld], Paged    [%4ld]\n",
               CommitAvailable / gLB.AvgCommitPerUser,
               SysPerfInfo.FreeSystemPtes / gLB.AvgPtesPerUser,
               SysPerfInfo.AvailablePagedPoolPages / gLB.AvgPagedPoolPerUser));

        // Sum up individual CPU usage
        for (i = 0; i < gLB.NumProcessors; i++) {
            IdleCPU.QuadPart += ProcessorInfo[i].IdleTime.QuadPart;
            TotalCPU.QuadPart += ProcessorInfo[i].KernelTime.QuadPart +
                                 ProcessorInfo[i].UserTime.QuadPart;
        }
    
        // Determine CPU deltas for this period
        IdleCPUDelta.QuadPart = IdleCPU.QuadPart - gLB.IdleCPU.QuadPart;
        TotalCPUDelta.QuadPart = TotalCPU.QuadPart - gLB.TotalCPU.QuadPart;
        gLB.IdleCPU.QuadPart = IdleCPU.QuadPart;
        gLB.TotalCPU.QuadPart = TotalCPU.QuadPart;

        // Determine what portion of 255 units we are idle
        AvgIdleCPU = (ULONG) (TotalCPUDelta.QuadPart ? 
                              ((IdleCPUDelta.QuadPart << 8) / TotalCPUDelta.QuadPart) 
                              : 0);

        //
        // Exponential smoothing: 
        //     gLB.AvgIdleCPU = (ULONG) (alpha * gLB.AvgIdleCPU + (1 - alpha) * AvgIdleCPU)
        //
        // When Alpha = 0.75, the equation simplifies to the following:
        //
        gLB.AvgIdleCPU = (3 * gLB.AvgIdleCPU + AvgIdleCPU) >> 2 ;

        // Based on current smoothed CPU usage, calculate how much a session uses
        // on average and extrapolate to max CPU constrained sessions.
        AvgBusyCPU = 255 - gLB.AvgIdleCPU;
        if ((AvgBusyCPU > 0) && (AvgBusyCPU <= 255))
            CPUConstrainedSessions = (NumWinStations << 8) / AvgBusyCPU;
        else
            CPUConstrainedSessions = 0xFFFFFFFF;

        // Now flip it to remaining CPU constrained sessions.  We never let this
        // number hit zero since it doesn't mean session creation will fail.
        if (CPUConstrainedSessions > NumWinStations)
            CPUConstrainedSessions -= NumWinStations;
        else
            CPUConstrainedSessions = 1;

        // Bias the averages a bit to account for growth in the existing sessions
        gLB.AvgCommitPerUser += (ULONG) (gLB.AvgCommitPerUser >> SimGrowthBias);
        gLB.AvgPtesPerUser += (ULONG) (gLB.AvgPtesPerUser >> SimGrowthBias);
        gLB.AvgPagedPoolPerUser += (ULONG) (gLB.AvgPagedPoolPerUser >> SimGrowthBias);
        
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   Session Avg: Commit  [%4ld], Pte    [%4ld], Paged    [%4ld]\n",
               CommitAvailable / gLB.AvgCommitPerUser,
               SysPerfInfo.FreeSystemPtes / gLB.AvgPtesPerUser,
               SysPerfInfo.AvailablePagedPoolPages / gLB.AvgPagedPoolPerUser));
    
        
        TRACE((hTrace, TC_LOAD, TT_API1,
               "   CPU Idle:    Current [%4ld], Avg    [%4ld], Est      [%4ld]\n",
               (AvgIdleCPU * 100) / 255, 
               (gLB.AvgIdleCPU * 100) / 255, 
               CPUConstrainedSessions));
    
        //
        // Find the most constrained resource!  Failure on any one of these 
        // items means we will not be likely to start a session.
        //
    
        // Commit Constraint (TODO: needs refinement, doesn't consider paging
        RemainingSessions = CommitAvailable / gLB.AvgCommitPerUser ;
        LoadFactor = AvailablePagesConstraint;
        pLIData->reserved[AvailablePagesConstraint] = RemainingSessions;
            
        // Free System PTEs Constraint
        MinSessions = SysPerfInfo.FreeSystemPtes / gLB.AvgPtesPerUser;
        if (MinSessions < RemainingSessions) {
            RemainingSessions = MinSessions;
            LoadFactor = SystemPtesConstraint;
        }
        pLIData->reserved[SystemPtesConstraint] = MinSessions;
    
        // Paged Pool Constraint
        MinSessions = SysPerfInfo.AvailablePagedPoolPages / gLB.AvgPagedPoolPerUser;
        if (MinSessions < RemainingSessions) {
            RemainingSessions = MinSessions;
            LoadFactor = PagedPoolConstraint;
        }
        pLIData->reserved[PagedPoolConstraint] = MinSessions;
        
        gLB.RemainingSessions = RemainingSessions;

        //
        // Add in constraints that are good indicators of application performance.
        // We will likely create a session if these resources are low, but the
        // user experience will suffer.

        // CPU Contraint
        if (CPUConstrainedSessions < RemainingSessions) {
            LoadFactor = CPUConstraint;
            RemainingSessions = CPUConstrainedSessions;
        }
        pLIData->reserved[CPUConstraint] = MinSessions;

                
        gLB.EstimatedSessions = RemainingSessions;
    
    
        TRACE((hTrace, TC_LOAD, TT_API1,
               "Remaining Sessions:   Raw: [%4ld], Est: [%4ld], Factor = %s, Commit = %ld\n\n",
               gLB.RemainingSessions, gLB.EstimatedSessions,
               LoadFactor == AvailablePagesConstraint ? "Available Memory" :
              (LoadFactor == SystemPtesConstraint     ? "SystemPtes"       :
              (LoadFactor == PagedPoolConstraint      ? "PagedPool"        :
              (LoadFactor == CPUConstraint            ? "CPU"              :
               "Unknown!"))), SysPerfInfo.CommittedPages
              ));
        
        //
        // Return data to caller
        //
        pLIData->RemainingSessionCapacity = gLB.EstimatedSessions;
        pLIData->RawSessionCapacity = gLB.RemainingSessions;
        pLIData->LoadFactor = LoadFactor;
        pLIData->TotalSessions = NumWinStations;
        pLIData->DisconnectedSessions = WinStationDiscCount;

        // Had to split this up for WIN64 alignment issues
        pLIData->IdleCPU.HighPart = IdleCPUDelta.HighPart;
        pLIData->IdleCPU.LowPart = IdleCPUDelta.LowPart;
        pLIData->TotalCPU.HighPart = TotalCPUDelta.HighPart;
        pLIData->TotalCPU.LowPart = TotalCPUDelta.LowPart;
    }

    // The load metrics failed to intialize! Set the capacity sky high to still
    // allow access to the server.
    else {
        RemainingSessions = 0xFFFFFFFF;
        pLIData->RemainingSessionCapacity = RemainingSessions;
        pLIData->RawSessionCapacity = RemainingSessions;
        pLIData->LoadFactor = ErrorConstraint;
        pLIData->TotalSessions = NumWinStations;
        pLIData->DisconnectedSessions = WinStationDiscCount;
        
        // Had to split this up for WIN64 alignment issues
        pLIData->IdleCPU.HighPart = 0;
        pLIData->IdleCPU.LowPart = 99;
        pLIData->TotalCPU.HighPart = 0;
        pLIData->TotalCPU.LowPart = 100;
        
        TRACE((hTrace, TC_LOAD, TT_ERROR,
               "GetLoadMetrics failed: init [%ld], Proc [%lx], Perf [%lx], Basic [%lx]!\n",
               gLB.fInitialized, StatusProc, StatusPerf, StatusBasic));
    }

    return RemainingSessions;
}


/*******************************************************************************
 *  xxxWinStationQueryInformation
 *
 *    Query window station information  (worker routine)
 *
 * ENTRY:
 *    LogonId (input)
 *       Session ID corresponding to the session.
 *    WinStationInformationClass (input)
 *       Specifies the type of information to get from the specified window
 *       station object.
 *    pWinStationInformation (output)
 *       A pointer to a buffer that contains information to get for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *    pReturnLength (output)
 *         Specifies the amount returned in the buffer
 ******************************************************************************/
NTSTATUS xxxWinStationQueryInformation(
        ULONG LogonId,
        WINSTATIONINFOCLASS WinStationInformationClass,
        PVOID pWinStationInformation,
        ULONG WinStationInformationLength,
        PULONG pReturnLength)
{
    NTSTATUS Status = STATUS_SUCCESS;
    HINSTANCE hInstance;
    PWINSTATION pWinStation = NULL;
    ULONG cbReturned;
    ICA_STACK_LAST_INPUT_TIME       Ica_Stack_Last_Input_Time;
    WINSTATION_APIMSG WMsg;
    PWINSTATIONVIDEODATA pVideoData;
    HANDLE hVirtual;
    ULONG i;

    *pReturnLength = 0;

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationQueryInformation LogonId=%d, Class=%d\n",
            LogonId, (ULONG)WinStationInformationClass));

    /*
     * Find the WinStation
     * Return error if not found or currently terminating.
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if (pWinStation == NULL)
        return STATUS_CTX_WINSTATION_NOT_FOUND;
    if (pWinStation->Terminating) {
        ReleaseWinStation(pWinStation);
        return STATUS_CTX_CLOSE_PENDING;
    }

    /*
     * Verify that client has QUERY access
     */
    Status = RpcCheckClientAccess(pWinStation, WINSTATION_QUERY, FALSE);
    if (!NT_SUCCESS(Status)) {
        ReleaseWinStation(pWinStation);
        return Status;
    }

    switch ( WinStationInformationClass ) {
    
        case WinStationLoadIndicator:
        {
            PWINSTATIONLOADINDICATORDATA pLIData = 
                (PWINSTATIONLOADINDICATORDATA) pWinStationInformation;
    
            if (WinStationInformationLength >= sizeof(WINSTATIONLOADINDICATORDATA)) {
                GetLoadMetrics(pLIData);

                *pReturnLength = sizeof(WINSTATIONLOADINDICATORDATA);
            }
            else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

        case WinStationInformation:
        {
            if (!ValidWireBuffer(WinStationInformationClass,
                     pWinStationInformation,
                     WinStationInformationLength))
            {
                Status = STATUS_INVALID_USER_BUFFER;
            }
            else
            {
                WINSTATIONINFORMATION           *pInfo;
                PROTOCOLSTATUS                  *pIca_Stack_Query_Status;

                pInfo = MemAlloc( sizeof( WINSTATIONINFORMATION ) ) ;

                if ( pInfo )
                {
                        pIca_Stack_Query_Status = MemAlloc( sizeof( PROTOCOLSTATUS ) );
                        if ( pIca_Stack_Query_Status  )
                        {
                            TCHAR         *szUserName = NULL, *szDomainName = NULL;
                            DWORD         dwUserSize = MAX_PATH, dwDomainSize = MAX_PATH;
                            SID_NAME_USE  TypeOfAccount;
                            BOOL          LookupResult;

                            memset( pInfo, 0, sizeof( PWINSTATIONINFORMATION ) );
                            wcscpy( pInfo->WinStationName, pWinStation->WinStationName );
                            memcpy( pInfo->Domain, pWinStation->Domain, sizeof( pInfo->Domain ) );
                            memcpy( pInfo->UserName, pWinStation->UserName, sizeof( pInfo->UserName ) );

                            // Since the Username stored maybe stale, query the Username again
                            // Intentionally we do not fail if we are not able to allocate szUserName and szDomainName
                            // This is because we can send the cached credentials in that case

                            szUserName = MemAlloc(MAX_PATH);
                            if ( szUserName ) {

                                szDomainName = MemAlloc(MAX_PATH);
                                if ( szDomainName ) {

                                    LookupResult = LookupAccountSid(NULL, 
                                                                    pWinStation->pUserSid, 
                                                                    szUserName, 
                                                                    &dwUserSize, 
                                                                    szDomainName, 
                                                                    &dwDomainSize, 
                                                                    &TypeOfAccount);

                                    if (LookupResult) {
    
                                        // Re-copy and update WINSTATION struct if the Username or Domain has changed  
                                        if ( (szUserName) && (lstrcmpi(pWinStation->UserName, szUserName)) ) {
                                            memcpy( pInfo->UserName, szUserName, sizeof(pInfo->UserName) );
                                            memcpy( pWinStation->UserName, szUserName, sizeof(pWinStation->UserName) );
                                        } 
                                        if ( (szDomainName) && (lstrcmpi(pWinStation->Domain, szDomainName)) ) {
                                            memcpy( pInfo->Domain, szDomainName, sizeof(pInfo->Domain) );
                                            memcpy( pWinStation->Domain, szDomainName, sizeof(pWinStation->Domain) );
                                        } 
                                    }
                                }
                            }

                            if (szUserName != NULL) {
                                MemFree(szUserName);
                            }

                            if (szDomainName != NULL) {
                                MemFree(szDomainName);
                            }
  
                            pInfo->ConnectState = pWinStation->State;
                            pInfo->LogonId = pWinStation->LogonId;
                            pInfo->ConnectTime = pWinStation->ConnectTime;
                            pInfo->DisconnectTime = pWinStation->DisconnectTime;
                            pInfo->LogonTime = pWinStation->LogonTime;
    
                            if ( pWinStation->hStack && !pWinStation->fOwnsConsoleTerminal ) {
    
                                //  Check for availability
                                if ( pWinStation->pWsx &&
                                        pWinStation->pWsx->pWsxIcaStackIoControl ) {

                                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                                            pWinStation->pWsxContext,
                                                            pWinStation->hIca,
                                                            pWinStation->hStack,
                                                            IOCTL_ICA_STACK_QUERY_LAST_INPUT_TIME,
                                                            NULL,
                                                            0,
                                                            &Ica_Stack_Last_Input_Time,
                                                            sizeof( Ica_Stack_Last_Input_Time ),
                                                            &cbReturned );


                                    if ( !NT_SUCCESS( Status ) )
                                    {
                                        MemFree( pInfo );                  
                                        MemFree( pIca_Stack_Query_Status );
                                        break;
                                    }
    
                                    pInfo->LastInputTime = Ica_Stack_Last_Input_Time.LastInputTime;                    
                                }
    
                                //  Check for availability
                                if ( pWinStation->pWsx &&
                                        pWinStation->pWsx->pWsxIcaStackIoControl ) {



                                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(

                                                            pWinStation->pWsxContext,
                                                            pWinStation->hIca,
                                                            pWinStation->hStack,
                                                            IOCTL_ICA_STACK_QUERY_STATUS,
                                                            NULL,
                                                            0,
                                                            pIca_Stack_Query_Status,
                                                            sizeof( PROTOCOLSTATUS ),
                                                            &cbReturned );

                                    if ( !NT_SUCCESS( Status ) )
                                    {
                                        MemFree( pInfo );                  
                                        MemFree( pIca_Stack_Query_Status );
                                        break;
                                    }
    
                                    pInfo->Status = *pIca_Stack_Query_Status;
                                }
    
                                /*
                                 * The thinwire cache data is down in WIN32
                                 */
                                if ( pWinStation->pWin32Context ) {
                                    WMsg.ApiNumber = SMWinStationThinwireStats;

    
                                    Status = SendWinStationCommand( pWinStation, &WMsg, gbServer?5:1 );

                                    if ( Status == STATUS_SUCCESS ) {
                                        pInfo->Status.Cache = WMsg.u.ThinwireStats.Stats;
                                        pWinStation->Cache =  WMsg.u.ThinwireStats.Stats;
                                    } else {
                                        pInfo->Status.Cache = pWinStation->Cache;

                                    }
                                    Status = STATUS_SUCCESS; // ignore errors getting TW stats
                                }
                            } else {
                                /*
                                 * This makes winadmin Idle time happy.
                                 */
                                (VOID) NtQuerySystemTime( &(pInfo->LastInputTime) );                
                            }
    
                            (VOID) NtQuerySystemTime( &pInfo->CurrentTime );
    
                            CopyInWireBuf(WinStationInformationClass,
                                          (PVOID)pInfo,
                                          pWinStationInformation);
                            *pReturnLength = WinStationInformationLength;
    
                            MemFree( pIca_Stack_Query_Status );
                        }
                        else
                        {
                            Status = STATUS_NO_MEMORY;
                        }
                    MemFree(pInfo);
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }
        break;


        case WinStationConfiguration:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)) {
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Config.Config,
                          pWinStationInformation);

            if (RpcCheckSystemClientEx( pWinStation ) != STATUS_SUCCESS) {
                PWINSTACONFIGWIREW p = pWinStationInformation;
                PUSERCONFIGW u = (PUSERCONFIGW)((PCHAR)p + p->UserConfig.Offset);
                RtlSecureZeroMemory( &u->Password, sizeof(u->Password) );
            }

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationWd:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Config.Wd,
                          pWinStationInformation);

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationPd:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Config.Pd[0],
                          pWinStationInformation);

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationCd:
            if ( WinStationInformationLength > sizeof(CDCONFIG) )
                WinStationInformationLength = sizeof(CDCONFIG);

            memcpy( pWinStationInformation,
                    &pWinStation->Config.Cd,
                    WinStationInformationLength );

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationPdParams:
        {
            if (!ValidWireBuffer(WinStationInformationClass,
                 pWinStationInformation,
                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }
            else
            {
                PDPARAMS *pPdParams;
    
                pPdParams = MemAlloc( sizeof( PDPARAMS ) );
    
                if (pPdParams)
                {

                    CopyOutWireBuf(WinStationInformationClass,
                               (PVOID) pPdParams,
                               pWinStationInformation);
    
                    /*
                     * Based on PDClass, this can query any PD
                     */
                    if ( pWinStation->hStack &&
                         pWinStation->pWsx &&
                         pWinStation->pWsx->pWsxIcaStackIoControl ) {
        
                        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                                pWinStation->pWsxContext,
                                                pWinStation->hIca,
                                                pWinStation->hStack,
                                                IOCTL_ICA_STACK_QUERY_PARAMS,
                                                pPdParams,
                                                sizeof(PDPARAMS ),
                                                pPdParams,
                                                sizeof( PDPARAMS ),
                                                pReturnLength );
        
                        /*
                         * If we get an error in the idle/disconnected state,
                         * or if this is a session on the local console.
                         * then just clear the return buffer and return success.
                         */
                        if ( !NT_SUCCESS( Status ) ) {
                            if ((pWinStation->fOwnsConsoleTerminal) || 
                                    (pWinStation->State != State_Active &&
                                    pWinStation->State != State_Connected )) {
                                memset(pPdParams, 0, sizeof(PDPARAMS));
                                *pReturnLength = WinStationInformationLength;
                                Status = STATUS_SUCCESS;
                            }
                        }
                    } else {
                        memset( (PVOID)pPdParams, 0, sizeof(PDPARAMS) );
                        *pReturnLength = WinStationInformationLength;
                        Status = STATUS_SUCCESS;
                    }
        
                    if (NT_SUCCESS(Status)) {
                        CopyInWireBuf(WinStationInformationClass,
                                      (PVOID)pPdParams,
                                      pWinStationInformation);
                    }
        
                    *pReturnLength = WinStationInformationLength;
        
                    MemFree( pPdParams );

                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }
        }
        break;


        case WinStationClient:
            if (!ValidWireBuffer(WinStationInformationClass,
                                 pWinStationInformation,
                                 WinStationInformationLength)){
                Status = STATUS_INVALID_USER_BUFFER;
                break;
            }

            CopyInWireBuf(WinStationInformationClass,
                          (PVOID)&pWinStation->Client,
                          pWinStationInformation);

            // if caller is not allow to see it, then scrub the password
            if ( !IsCallerAllowedPasswordAccess() ) {
                PWINSTATIONCLIENT pWSClient = (PWINSTATIONCLIENT)pWinStationInformation;
                PBYTE pStart;
                PBYTE pEnd;
                ULONG ulMaxToScrub;

                pEnd = (PBYTE) ( pWinStationInformation ) + WinStationInformationLength;
                if ((ULONG_PTR) pEnd > (ULONG_PTR)pWSClient->Password) {
                    ulMaxToScrub =  (ULONG)((ULONG_PTR) pEnd - (ULONG_PTR)pWSClient->Password);
                    if (ulMaxToScrub > sizeof(pWSClient->Password))
                        ulMaxToScrub = sizeof(pWSClient->Password);
                    memset(pWSClient->Password, 0,ulMaxToScrub);
                }
            }

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationModules:
            //  Check for availability
            if (pWinStation->hStack &&
                    pWinStation->pWsx &&
                    pWinStation->pWsx->pWsxIcaStackIoControl) {
                ULONG b = (ULONG) IsCallerAllowedPasswordAccess();

                Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                        pWinStation->pWsxContext,
                                        pWinStation->hIca,
                                        pWinStation->hStack,
                                        IOCTL_ICA_STACK_QUERY_MODULE_DATA,
                                        (PVOID) &b,
                                        sizeof(b),
                                        pWinStationInformation,
                                        WinStationInformationLength,
                                        pReturnLength );
            } else {
                memset( pWinStationInformation, 0, WinStationInformationLength );
                Status = STATUS_SUCCESS;
            }
            break;


        case WinStationCreateData:
            if ( WinStationInformationLength > sizeof(WINSTATIONCREATE) )
                WinStationInformationLength = sizeof(WINSTATIONCREATE);

            memcpy( pWinStationInformation,
                    &pWinStation->Config.Create,
                    WinStationInformationLength );

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationPrinter:
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;


        case WinStationUserToken:
            if ( WinStationInformationLength < sizeof(WINSTATIONUSERTOKEN) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            /*
             * Check it for WINSTATION_ALL_ACCESS. This will generate an
             * access audit if on.
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_ALL_ACCESS, FALSE );
            if ( !NT_SUCCESS( Status ) ) {
                break;
            }

            //
            // Make sure only system mode callers can get this token.
            //
            // A Token is a very dangerous thing to allow someone to
            // get a hold of, since they can create processes that
            // have the tokens subject context.
            //
            Status = RpcCheckSystemClientNoLogonId( pWinStation );
            if (!NT_SUCCESS(Status)) {
                break;
            }

            Status = xxxGetUserToken(
                              pWinStation,
                              (WINSTATIONUSERTOKEN UNALIGNED *)pWinStationInformation,
                              WinStationInformationLength
                              );

            *pReturnLength = sizeof(WINSTATIONUSERTOKEN);
            break;


        case WinStationVideoData:
            if ( !pWinStation->LogonId || !pWinStation->hStack ) {
                Status = STATUS_PROCEDURE_NOT_FOUND;
                break;
            }

            if ( WinStationInformationLength < sizeof(WINSTATIONVIDEODATA) ) {
                 Status = STATUS_BUFFER_TOO_SMALL;
                 break;
            }

            pVideoData = (PWINSTATIONVIDEODATA) pWinStationInformation;

            pVideoData->HResolution = pWinStation->Client.HRes;
            pVideoData->VResolution = pWinStation->Client.VRes;
            pVideoData->fColorDepth = pWinStation->Client.ColorDepth;

            *pReturnLength = sizeof(WINSTATIONVIDEODATA);
            break;


        case WinStationVirtualData:
            if ( !pWinStation->hStack ) {
                Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

          if ( WinStationInformationLength < sizeof(VIRTUALCHANNELNAME) ) {
                 Status = STATUS_BUFFER_TOO_SMALL;
                 break;
            }

            /*
             *  Open virtual channel handle
             */
            Status = IcaChannelOpen( pWinStation->hIca,
                                     Channel_Virtual,
                                     pWinStationInformation,
                                &hVirtual );
            if ( !NT_SUCCESS( Status ) )
                break;

            /*
             *  Query client virtual channel data
             */
            Status = IcaChannelIoControl( hVirtual,
                                          IOCTL_ICA_VIRTUAL_QUERY_MODULE_DATA,
                                          NULL,
                                          0,
                                          pWinStationInformation,
                                          WinStationInformationLength,
                                          pReturnLength );

            /*
             *  Close virtual channel
             */
            IcaChannelClose(hVirtual);
            break;


        case WinStationLoadBalanceSessionTarget:
            // This query requests the target session ID for a
            // client redirected from another server in a load balancing
            // cluster. Returns -1 for no redirection. This call is
            // normally made only by WinLogon.

            if ( WinStationInformationLength < sizeof(ULONG) ) {
                 Status = STATUS_BUFFER_TOO_SMALL;
                 break;
            }

            if (WinStationInformationLength > sizeof(ULONG))
                WinStationInformationLength = sizeof(ULONG);

            if (!pWinStation->bRequestedSessionIDFieldValid)
                *((ULONG *)pWinStationInformation) = (ULONG)-1;
            else
                *((ULONG *)pWinStationInformation) =
                        pWinStation->RequestedSessionID;

            *pReturnLength = WinStationInformationLength;
            break;


        case WinStationShadowInfo:
        {
            PWINSTATIONSHADOW pWinstationShadow;
    
            if (WinStationInformationLength >= sizeof(WINSTATIONSHADOW)) {

                pWinstationShadow = (PWINSTATIONSHADOW) pWinStationInformation;

                if ( pWinStation->State == State_Shadow ) {

                    // The current state is Shadow so it's a viewer
                    pWinstationShadow->ShadowState = State_Shadowing;

                } else if ( pWinStation->State == State_Active &&
                            !IsListEmpty(&pWinStation->ShadowHead) ) {

                    // Active and being shadowed
                    pWinstationShadow->ShadowState = State_Shadowed;

                } else {

                    pWinstationShadow->ShadowState = State_NoShadow;
                }

                pWinstationShadow->ShadowClass  = pWinStation->Config.Config.User.Shadow;
                pWinstationShadow->SessionId    = LogonId;
                pWinstationShadow->ProtocolType = pWinStation->Client.ProtocolType;


                *pReturnLength = sizeof(WINSTATIONSHADOW);
            }
            else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

        case WinStationDigProductId:
        {
            PWINSTATIONPRODID pWinStationProdId;
   
            if ( WinStationInformationLength >= sizeof(WINSTATIONPRODID) )
            {
              pWinStationProdId  = (PWINSTATIONPRODID)pWinStationInformation;
              memcpy( pWinStationProdId->DigProductId, g_DigProductId, sizeof( g_DigProductId ));
              memcpy( pWinStationProdId->ClientDigProductId, pWinStation->Client.clientDigProductId, sizeof( pWinStation->Client.clientDigProductId ));
              pWinStationProdId->curentSessionId = pWinStation->LogonId;
              pWinStationProdId->ClientSessionId = pWinStation->Client.ClientSessionId;

              *pReturnLength = WinStationInformationLength;
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

        case WinStationLockedState:
        {
            BOOL bLockedState;
            if ( pWinStationInformation &&  (WinStationInformationLength >= sizeof(bLockedState)))
            {
                Status = GetLockedState(pWinStation, &bLockedState);
                *(LPBOOL)pWinStationInformation = bLockedState;
                *pReturnLength = sizeof(bLockedState);
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case WinStationRemoteAddress:
        {
            PWINSTATIONREMOTEADDRESS pRemoteAddress = (PWINSTATIONREMOTEADDRESS) pWinStationInformation;

            if( WinStationInformationLength >= sizeof(WINSTATIONREMOTEADDRESS) )
            {
                Status = xxxQueryRemoteAddress( pWinStation, pRemoteAddress );
            }
            else
            {
                *pReturnLength = sizeof(WINSTATIONREMOTEADDRESS);
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        
            break;
        }

        case WinStationIdleTime:
        {   // Return the idle time for the winstation.
            LASTINPUTINFO LastInputInfo;
            ULONG         Now;

            // Check on validity of the parameters.
            if ( (pWinStationInformation) && (WinStationInformationLength >= sizeof(ULONG)) )  {
                // Get last input info on this winstation.
                LastInputInfo.cbSize = sizeof(LASTINPUTINFO);
                if (!GetLastInputInfo(&LastInputInfo)) {
                    // Failed. Set the output to 0.
                    *((ULONG *)pWinStationInformation) = 0;                
                }
                else {
                    // Find out how much time has passed since the system was booted.
                    Now = GetTickCount();

                    // The current time may be less than the last input time due to 49.71 days wrap-around.
                    if (Now < LastInputInfo.dwTime) {
                        // If this is the case, we really don't know whether session was idle for more than
                        // 49 days or the last input time for the session is close to MAX_LONG and the wrap-
                        // around occurred. Better to report lesser time here.
                        *((ULONG *)pWinStationInformation) = MAXULONG - LastInputInfo.dwTime + Now;                
                    }
                    else {
                        // If current time is greater, then the idle time just the difference between the 
                        // current time and the last input time.
                        *((ULONG *)pWinStationInformation) = Now - LastInputInfo.dwTime;                
                    }
                }
                *pReturnLength = sizeof(ULONG);
            }                        
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case WinStationLastReconnectType:
        {

            if ( pWinStationInformation &&  (WinStationInformationLength >= sizeof(ULONG)))
            {
                *((ULONG *)pWinStationInformation) = pWinStation->LastReconnectType;
                *pReturnLength = sizeof(ULONG);
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case WinStationMprNotifyInfo:
        {
            pExtendedClientCredentials pMprNotifyInfo;

            // Only System can query this information

            Status = _CheckCallerLocalAndSystem();
            if (Status != STATUS_SUCCESS) {
                break;
            }

            if (WinStationInformationLength >= sizeof(ExtendedClientCredentials)) {

                pMprNotifyInfo = (pExtendedClientCredentials) pWinStationInformation;

                *pMprNotifyInfo = g_MprNotifyInfo;
                *pReturnLength = sizeof(ExtendedClientCredentials);

                // Erase the sensitive information now since its no longer needed in TermSrv
                RtlSecureZeroMemory( g_MprNotifyInfo.Domain, wcslen(g_MprNotifyInfo.Domain) * sizeof(WCHAR) );
                RtlSecureZeroMemory( g_MprNotifyInfo.UserName, wcslen(g_MprNotifyInfo.UserName) * sizeof(WCHAR) );
                RtlSecureZeroMemory( g_MprNotifyInfo.Password, wcslen(g_MprNotifyInfo.Password) * sizeof(WCHAR) );

            } else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        }
        break;

        case WinStationExecSrvSystemPipe:
        {

            if ( pWinStationInformation &&  (WinStationInformationLength >= EXECSRVPIPENAMELEN*sizeof(WCHAR) ) )
            {
                memcpy( pWinStationInformation, &pWinStation->ExecSrvSystemPipe, WinStationInformationLength );
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }

            break;
        }

        case WinStationSDRedirectedSmartCardLogon:
        {
            // Only System can query this information

            Status = _CheckCallerLocalAndSystem();
            if (Status != STATUS_SUCCESS) {
                break;
            }

            if ( pWinStationInformation &&  (WinStationInformationLength >= sizeof(BOOLEAN)))
            {
                *((ULONG *)pWinStationInformation) = pWinStation->fSDRedirectedSmartCardLogon;
                *pReturnLength = sizeof(BOOLEAN);

                // Reset the flag here
                pWinStation->fSDRedirectedSmartCardLogon = FALSE;
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        case WinStationIsAdminLoggedOn:
        {
            // Only System can query this information
    
            Status = _CheckCallerLocalAndSystem();
            if (Status != STATUS_SUCCESS) {
                break;
            }
    
            if ( pWinStationInformation &&  (WinStationInformationLength >= sizeof(BOOLEAN)))
            {
                *((ULONG *)pWinStationInformation) = pWinStation->fUserIsAdmin;
                *pReturnLength = sizeof(BOOLEAN);
            }
            else 
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }

        default:
            /*
             * Fail the call
             */
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    ReleaseWinStation(pWinStation);

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationQueryInformation "
            "LogonId=%d, Class=%d, Status=0x%x\n",
            LogonId, (ULONG)WinStationInformationClass, Status));

    return Status;
}


/*****************************************************************************
 *  xxxGetUserToken
 *
 *   Duplicate the users token into the process space of the caller
 *   if they are an admin.
 *
 * ENTRY:
 *   p (input/output)
 *     Argument buffer
 *
 *   Length (input)
 *     Size of argument buffer
 ****************************************************************************/
NTSTATUS xxxGetUserToken(
        PWINSTATION pWinStation,
        WINSTATIONUSERTOKEN UNALIGNED *p,
        ULONG Size)
{
    NTSTATUS Status;
    HANDLE RemoteToken;
    HANDLE RemoteProcess = NULL;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjA;

    // Determine if the caller is an admin

    //
    // If the token is not NULL, duplicate it into the callers
    // process space.
    //
    if (pWinStation->UserToken == NULL) {
        return STATUS_NO_TOKEN;
    }

    InitializeObjectAttributes(&ObjA, NULL, 0, NULL, NULL);
    ClientId.UniqueProcess = p->ProcessId;
    ClientId.UniqueThread = p->ThreadId;

    Status = NtOpenProcess(
            &RemoteProcess,
            PROCESS_ALL_ACCESS,
            &ObjA,
            &ClientId);

    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TermSrv GETTOKEN: Error 0x%x "
                "opening remote process %d\n", Status,p->ProcessId));
        return Status;
    }

    Status = NtDuplicateObject(
            NtCurrentProcess(),
            pWinStation->UserToken,
            RemoteProcess,
            &RemoteToken,
            0,
            0,
            DUPLICATE_SAME_ACCESS);

    if (!NT_SUCCESS(Status)) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TermSrv GETTOKEN: Error 0x%x "
                "duplicating UserToken\n", Status));
        NtClose( RemoteProcess );
        return Status;
    }

    p->UserToken = RemoteToken;
    NtClose(RemoteProcess);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\winsta.c ===
//****************************************************************************/
// winsta.c
//
// TermSrv session and session stack related code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "icaevent.h"
#include "tsappcmp.h" // for TermsrvAppInstallMode
#include <msaudite.h>

#include "sessdir.h"

#include <allproc.h>
#include <userenv.h>

#include <winsock2.h>

#include "conntfy.h"
#include "tsremdsk.h"
#include <ws2tcpip.h>

#include <Accctrl.h>
#include <Aclapi.h>

#include "tssec.h"

//
// Autoreconnect security headers
//
#include <md5.h>
#include <hmac.h>

// performance flags
#include "tsperf.h"

// DoS attack Filters
#include "filters.h"

#ifndef MAX_WORD
#define MAX_WORD            0xffff
#endif

//
// SIGN_BYPASS_OPTION #define should be removed before WIN64 SHIPS!!!!!
//
#ifdef _WIN64
#define SIGN_BYPASS_OPTION
#endif

/*
 * Local defines
 */
#define SETUP_REG_PATH L"\\Registry\\Machine\\System\\Setup"

#define REG_WINDOWS_KEY TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define MAXIMUM_WAIT_WINSTATIONS ((MAXIMUM_WAIT_OBJECTS >> 1) - 1)
#define MAX_STRING_BYTES 512

#define MAX_ALLOWED_PASSWORD_LEN 126


BOOL gbFirtsConnectionThread = TRUE;
WINSTATIONCONFIG2 gConsoleConfig;
WCHAR g_DigProductId[CLIENT_PRODUCT_ID_LENGTH];

RECONNECT_INFO ConsoleReconnectInfo;


ULONG gLogoffTimeout = 90; /*90 seconds default value for logoff timeout*/

/*
 * Globals to support load balancing.  Since this is queried frequently we can't
 * afford to lock the winstation list and count them up.  Note that they are
 * modified only when we have the WinStationListLock to avoid mutual exclusion
 * issues.
 */
ULONG WinStationTotalCount = 0;
ULONG WinStationDiscCount = 0;
LOAD_BALANCING_METRICS gLB;
BOOL g_fGetLocalIP = FALSE;

/*
 * External procedures defined
 */


VOID     StartAllWinStations(HKEY);
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
NTSTATUS WinStationCreateWorker(PWINSTATIONNAME pWinStationName, PULONG pLogonId, BOOLEAN fStartWinStation );
VOID     WinStationTerminate( PWINSTATION );
VOID     WinStationDeleteWorker( PWINSTATION );
NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN );
NTSTATUS WinStationDoReconnect( PWINSTATION, PRECONNECT_INFO );
BOOL     CopyReconnectInfo(PWINSTATION, PRECONNECT_INFO);
VOID     CleanupReconnect( PRECONNECT_INFO );
NTSTATUS WinStationExceptionFilter( PWSTR, PEXCEPTION_POINTERS );
NTSTATUS IcaWinStationNameFromLogonId( ULONG, PWINSTATIONNAME );
VOID     WriteErrorLogEntry(
            IN  NTSTATUS NtStatusCode,
            IN  PVOID    pRawData,
            IN  ULONG    RawDataLength
            );

NTSTATUS CheckIdleWinstation(VOID);
BOOL IsKernelDebuggerAttached();


/*
 * Internal procedures defined
 */
NTSTATUS WinStationTerminateThread( PVOID );
NTSTATUS WinStationIdleControlThread( PVOID );
NTSTATUS WinStationConnectThread( ULONG );
NTSTATUS WinStationTransferThread( PVOID );
NTSTATUS ConnectSmWinStationApiPort( VOID );
NTSTATUS IcaRegWinStationEnumerate( PULONG, PWINSTATIONNAME, PULONG );
NTSTATUS WinStationStart( PWINSTATION );
NTSTATUS StartWinStationDeviceAndStack(PWINSTATION pWinStation);
NTSTATUS WinStationCreateComplete(PWINSTATION pWinStation);
BOOL     WinStationTerminateProcesses( PWINSTATION, ULONG *pNumTerminated );
VOID     WinStationDeleteProc( PREFLOCK );
VOID     WinStationZombieProc( PREFLOCK );
NTSTATUS SetRefLockDeleteProc( PREFLOCK, PREFLOCKDELETEPROCEDURE );

VOID     WsxBrokenConnection( PWINSTATION );
NTSTATUS TerminateProcessAndWait( HANDLE, HANDLE, ULONG );
VOID     ResetAutoReconnectInfo( PWINSTATION );
ULONG    WinStationShutdownReset( PVOID );
ULONG WinStationLogoff( PVOID );
NTSTATUS DoForWinStationGroup( PULONG, ULONG, LPTHREAD_START_ROUTINE );
NTSTATUS LogoffWinStation( PWINSTATION, ULONG );
PWINSTATION FindIdleWinStation( VOID );

ULONG CountWinStationType(
    PWINSTATIONNAME pListenName,
    BOOLEAN bActiveOnly,
    BOOLEAN bLockHeld);


NTSTATUS
_CloseEndpoint(
    IN PWINSTATIONCONFIG2 pWinStationConfig,
    IN PVOID pEndpoint,
    IN ULONG EndpointLength,
    IN PWINSTATION pWinStation,
    IN BOOLEAN bNeedStack
    );

NTSTATUS _VerifyStackModules(PWINSTATION);

NTSTATUS _ImpersonateClient(HANDLE, HANDLE *);

WinstationRegUnLoadKey(HKEY hKey, LPWSTR lpSubKey);

ULONG WinstationCountUserSessions(PSID, ULONG);

BOOLEAN WinStationCheckConsoleSession(VOID);

NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError);


VOID
WinStationSetMaxOustandingConnections();

VOID ReadDoSParametersFromRegistry( HKEY hKeyTermSrv );

NTSTATUS GetProductIdFromRegistry( WCHAR* DigProductId, DWORD dwSize );


/*
 * External procedures used
 */
NTSTATUS WinStationInitRPC( VOID );
NTSTATUS WinStationInitLPC( VOID );
RPC_STATUS RegisterRPCInterface( BOOL bReregister );
NTSTATUS WinStationStopAllShadows( PWINSTATION );
VOID NotifySystemEvent( ULONG );
NTSTATUS SendWinStationCommand( PWINSTATION, PWINSTATION_APIMSG, ULONG );
NTSTATUS RpcCheckClientAccess( PWINSTATION, ACCESS_MASK, BOOLEAN );
NTSTATUS WinStationSecurityInit( VOID );
VOID DisconnectTimeout( ULONG LogonId );
PWSEXTENSION FindWinStationExtensionDll( PWSTR, ULONG );

PSECURITY_DESCRIPTOR
WinStationGetSecurityDescriptor(
    PWINSTATION pWinStation
    );

VOID
WinStationFreeSecurityDescriptor(
    PWINSTATION pWinStation
    );

NTSTATUS
WinStationInheritSecurityDescriptor(
    PVOID pSecurityDescriptor,
    PWINSTATION pTargetWinStation
    );

NTSTATUS
ReadWinStationSecurityDescriptor(
    PWINSTATION pWinStation
    );

NTSTATUS
WinStationKeepAlive();

NTSTATUS
WinStationReadRegistryWorker();

void
PostErrorValueEvent(
    unsigned EventCode, DWORD ErrVal);

BOOL
Filter_AddOutstandingConnection(
        IN HANDLE   pContext,
        IN PVOID    pEndpoint,
        IN ULONG    EndpointLength,
        OUT PBYTE   pin_addr,
        OUT PUINT   puAddrSize,
        OUT BOOLEAN *pbBlocked
    );

BOOL
Filter_RemoveOutstandingConnection(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Filter_CompareConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
    );

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Filter_CompareFailedConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
    );

PVOID
Filter_AllocateConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    );

PVOID
Filter_AllocateConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    );

VOID
Filter_FreeConnectionEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
    );

BOOL
FindFirstListeningWinStationName( 
    PWINSTATIONNAMEW pListenName, 
    PWINSTATIONCONFIG2 pConfig );

typedef struct _TRANSFER_INFO {
    ULONG LogonId;
    PVOID pEndpoint;
    ULONG EndpointLength;
} TRANSFER_INFO, *PTRANSFER_INFO;

VOID     AuditEvent( PWINSTATION pWinstation, ULONG EventId );
VOID AuditShutdownEvent(VOID);

NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    );

//
//From regapi.dll
//
BOOLEAN RegIsTimeZoneRedirectionEnabled();

/*
 * Local variables
 */
RTL_CRITICAL_SECTION WinStationListLock;
RTL_CRITICAL_SECTION WinStationListenersLock;
RTL_CRITICAL_SECTION WinStationStartCsrLock;
RTL_CRITICAL_SECTION TimerCritSec;
RTL_CRITICAL_SECTION WinStationZombieLock;
RTL_CRITICAL_SECTION UserProfileLock;
RTL_CRITICAL_SECTION ConsoleLock;
RTL_RESOURCE WinStationSecurityLock;

// This synchronization counter prevents WinStationIdleControlThread from
// Trying to create a console session when  there is not one. There are two 
// Situations where we do no want it to create such session:
// - At initialization time before we create session Zero which is the initial
// console session.
// - During reconnect in the window were we just disconnected the console session
// (so there is no console session) but we know we are we going to reconnect
// an other session to the console.

ULONG gConsoleCreationDisable = 1;


LIST_ENTRY WinStationListHead;    // protected by WinStationListLock
LIST_ENTRY SystemEventHead;       // protected by WinStationListLock
LIST_ENTRY ZombieListHead;
ULONG LogonId;
LARGE_INTEGER TimeoutZero;
HANDLE WinStationEvent = NULL;
HANDLE WinStationIdleControlEvent = NULL;
HANDLE ConsoleLogoffEvent = NULL;
HANDLE g_hMachineGPEvent=NULL;
static HANDLE WinStationApiPort = NULL;
BOOLEAN StopOnDown = FALSE;
HANDLE hTrace = NULL;
//BOOLEAN ShutdownTerminateNoWait = FALSE;
ULONG ShutDownFromSessionID = 0;

// IdleWinStationPoolCount made 0 -- change necessiated by DoS attack prevention logic added to TS
ULONG IdleWinStationPoolCount = 0;

ULONG_PTR gMinPerSessionPageCommitMB = 20;
#define REG_MIN_PERSESSION_PAGECOMMIT L"MinPerSessionPageCommit"

PVOID glpAddress;

ULONG_PTR gMinPerSessionPageCommit;

typedef struct _TS_OUTSTANDINGCONNECTION {
    ULONGLONG  blockUntilTime;
    ULONG      NumOutStandingConnect;
    UINT       uAddrSize;
    BYTE       addr[16];
    struct _TS_OUTSTANDINGCONNECTION *pNext;
} TS_OUTSTANDINGCONNECTION, *PTS_OUTSTANDINGCONNECTION;

PTS_OUTSTANDINGCONNECTION   g_pBlockedConnections = NULL;

// Table used to keep track of Outstanding connections (DoS)
RTL_GENERIC_TABLE           gOutStandingConnections;

RTL_CRITICAL_SECTION        FilterLock;
ULONG MaxOutStandingConnect;
ULONG NumOutStandingConnect;
ULONG MaxSingleOutStandingConnect;      // maximum number of outstanding connections from a single IP
ULONG DelayConnectionTime = 30*1000;

//
// DoS 
// If a bad IP (attacker) has 'MaxFailedConnect' # of failed Pre Auth in 'TimeLimitForFailedConnections' ms, block the IP for 'DoSBlockTime' ms
//

ULONG MaxFailedConnect;                 // max number of PreAuth failed connections from a single IP
ULONG DoSBlockTime;                     // Block IP for this much time, if they fail PreAuth simulate 5 mins block for now
ULONG TimeLimitForFailedConnections;    
ULONG CleanupTimeout;                   // Timeout to fire a routine to cleanup our Bad IP addr table for DoS

SYSTEMTIME LastLoggedDelayConnection;
ULONGLONG LastLoggedBlockedConnection = 0;
BOOLEAN gbNeverLoggedDelayConnection = TRUE;

HANDLE hConnectEvent;

BOOLEAN gbWinSockInitialized = FALSE;

/*
 * Global data
 */
extern BOOL g_fAppCompat;
extern BOOL g_SafeBootWithNetwork;

RTL_CRITICAL_SECTION g_AuthzCritSection;


extern HANDLE gReadyEventHandle;


extern BOOLEAN RegDenyTSConnectionsPolicy();
//extern BOOLEAN IsPreAuthEnabled(POLICY_TS_MACHINE *p );
extern DWORD WaitForTSConnectionsPolicyChanges( BOOLEAN bWaitForAccept, HANDLE hEvent );
extern void  InitializeConsoleClientData( PWINSTATIONCLIENTW  pWC );

// defines in REGAPI
extern BOOLEAN    RegGetMachinePolicyEx( 
            BOOLEAN             forcePolicyRead,
            FILETIME            *pTime ,    
            PPOLICY_TS_MACHINE  pPolicy );

extern BOOLEAN RegIsMachineInHelpMode();


// Global TermSrv counter values
DWORD g_TermSrvTotalSessions;
DWORD g_TermSrvDiscSessions;
DWORD g_TermSrvReconSessions;

DWORD g_TermSrvSuccTotalLogons;
DWORD g_TermSrvSuccRemoteLogons;
DWORD g_TermSrvSuccLocalLogons;
DWORD g_TermSrvSuccSession0Logons;

// Global system SID

PSID gSystemSid = NULL;
PSID gAdminSid = NULL;
PSID gAnonymousSid = NULL;

BOOLEAN g_fDenyTSConnectionsPolicy = 0;

POLICY_TS_MACHINE   g_MachinePolicy;

/****************************************************************************/
// IsEmbedded
//
// Service-load-time initialization.
/****************************************************************************/
BOOL IsEmbedded()
{
    static int fResult = -1;
    
    if(fResult == -1)
    {
        OSVERSIONINFOEX ovix;
        BOOL b;
        
        fResult = 0;

        ovix.dwOSVersionInfoSize = sizeof(ovix);
        b = GetVersionEx((LPOSVERSIONINFO) &ovix);
        ASSERT(b);
        if(b && (ovix.wSuiteMask & VER_SUITE_EMBEDDEDNT))
        {
            fResult = 1;
        }
    }
    
    return (fResult == 1);
}

/****************************************************************************/
// InitTermSrv
//
// Service-load-time initialization.
/****************************************************************************/
NTSTATUS InitTermSrv(HKEY hKeyTermSrv)
{
    NTSTATUS Status;
    DWORD dwLen;
    DWORD dwType;
    ULONG  szBuffer[MAX_PATH/sizeof(ULONG)];
    FILETIME    policyTime;
    WSADATA wsaData;

#define MAX_DEFAULT_CONNECTIONS 50
#define MAX_CONNECT_LOW_THRESHOLD 5
#define MAX_SINGLE_CONNECT_THRESHOLD_DIFF 5
#define MAX_DEFAULT_CONNECTIONS_PRO 3
#define MAX_DEFAULT_SINGLE_CONNECTIONS_PRO 2


    ASSERT(hKeyTermSrv != NULL);

    g_TermSrvTotalSessions = 0;
    g_TermSrvDiscSessions = 0;
    g_TermSrvReconSessions = 0;

    g_TermSrvSuccTotalLogons = 0;
    g_TermSrvSuccRemoteLogons = 0;
    g_TermSrvSuccLocalLogons = 0;
    g_TermSrvSuccSession0Logons = 0;

    // Set default value for maximum simultaneous connection attempts
    WinStationSetMaxOustandingConnections();

    NumOutStandingConnect = 0;
    hConnectEvent = NULL;

    ShutdownInProgress = FALSE;
    //ShutdownTerminateNoWait = FALSE;
    ShutDownFromSessionID = 0;

    // don't bother saving the policy time, the thread that waits for policy update will save it's own copy at the
    // cost of running the 1st time around. Alternatively, I need to use another global var for the policy update value.
    RegGetMachinePolicyEx( TRUE, &policyTime, &g_MachinePolicy );
    
    // see if keep alive is required, then IOCTL it to TermDD
    WinStationKeepAlive();

    Status = RtlInitializeCriticalSection( &FilterLock );
    ASSERT( NT_SUCCESS( Status ));
    if (!NT_SUCCESS(Status)) {
        goto badFilterLock;
    }

    // Table to keep track of OutStanding Sessions
    RtlInitializeGenericTable( &gOutStandingConnections,
                               Filter_CompareConnectionEntry,
                               Filter_AllocateConnectionEntry,
                               Filter_FreeConnectionEntry,
                               NULL );

    //
    // Following code is for PreAuthenticating client + DoS attack - commented out for now 
    //
    #if 0

        // Lock to serialize access to list of sessions which failed PreAuthentication (DoS attack) 
        Status = RtlInitializeCriticalSection( &DoSLock );
        if (!NT_SUCCESS(Status)) {
            goto badFilterLock;
        }
    
        // Table to keep track of sessions which failed PreAuthentication
        RtlInitializeGenericTable( &gFailedConnections,
                                   Filter_CompareFailedConnectionEntry,
                                   Filter_AllocateConnectionEntry,
                                   Filter_FreeConnectionEntry,
                                   NULL );

    #endif 

    Status = RtlInitializeCriticalSection( &ConsoleLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
       goto badConsoleLock;
    }

    Status = RtlInitializeCriticalSection( &UserProfileLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badUserProfileLock;
    }

    Status = RtlInitializeCriticalSection( &WinStationListLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badWinstationListLock;
    }

    if (gbListenerOff) {
        Status = RtlInitializeCriticalSection( &WinStationListenersLock );
        ASSERT( NT_SUCCESS( Status ) );
        if (!NT_SUCCESS(Status)) {
            goto badWinStationListenersLock;
        }
    }

    Status = RtlInitializeCriticalSection( &WinStationZombieLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badWinStationZombieLock;
    }

    Status = RtlInitializeCriticalSection( &TimerCritSec );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badTimerCritsec;
    }

    Status = RtlInitializeCriticalSection( &g_AuthzCritSection );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badAuthzCritSection;
    }

    InitializeListHead( &WinStationListHead );
    InitializeListHead( &SystemEventHead );
    InitializeListHead( &ZombieListHead );

    Status = InitializeConsoleNotification ();
    if (!NT_SUCCESS(Status)) {
        goto badinitStartCsrLock;
    }

    Status = RtlInitializeCriticalSection( &WinStationStartCsrLock );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badinitStartCsrLock;
    }

    Status = LCInitialize(
        g_bPersonalTS ? LC_INIT_LIMITED : LC_INIT_ALL,
        g_fAppCompat
        );

    if (!NT_SUCCESS(Status)) {
        goto badLcInit;
    }

    //
    // Listener winstations always get LogonId above 65536 and are
    // assigned by Terminal Server. LogonId's for sessions are
    // generated by mm in the range 0-65535
    //
    LogonId = MAX_WORD + 1;

    TimeoutZero = RtlConvertLongToLargeInteger( 0 );
    Status = NtCreateEvent( &WinStationEvent, EVENT_ALL_ACCESS, NULL,
                   NotificationEvent, FALSE );
    Status = NtCreateEvent( &WinStationIdleControlEvent, EVENT_ALL_ACCESS, NULL,
                   SynchronizationEvent, FALSE );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badEvent;
    }

    Status = NtCreateEvent( &ConsoleLogoffEvent, EVENT_ALL_ACCESS, NULL,
                   NotificationEvent, TRUE );
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badEvent;
    }

    /*
     * Initialize WinStation security
     */

    RtlAcquireResourceExclusive(&WinStationSecurityLock, TRUE);
    Status = WinStationSecurityInit();
    RtlReleaseResource(&WinStationSecurityLock);
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badInitSecurity;
    }

    Status = WinStationInitLPC();
    ASSERT( NT_SUCCESS( Status ) );
    if (!NT_SUCCESS(Status)) {
        goto badInitLPC;
    }

    //
    // Read the registry to determine if maximum outstanding connections
    // policy is turned on and the value for it
    //

    //
    // Get MaxOutstandingCon string value
    //
    dwLen = sizeof(MaxOutStandingConnect);
    if (RegQueryValueEx(hKeyTermSrv, MAX_OUTSTD_CONNECT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            MaxOutStandingConnect = *(PULONG)szBuffer;
        }
    }

    dwLen = sizeof(MaxSingleOutStandingConnect);
    if (RegQueryValueEx(hKeyTermSrv, MAX_SINGLE_OUTSTD_CONNECT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            MaxSingleOutStandingConnect = *(PULONG)szBuffer;
        }
    }

    //ReadDoSParametersFromRegistry(hKeyTermSrv);

    dwLen = sizeof(gLogoffTimeout);
    if (RegQueryValueEx(hKeyTermSrv, LOGOFF_TIMEOUT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        gLogoffTimeout = *(PULONG)szBuffer;
    }

    //
    // Read the logoff timeout value. This timeout is used by termsrv to force terminate
    // winlogon, if winlogon does not complete logoff after ExitWindows message was sent to him
    //




    //
    //  set max number of outstanding connection from single IP
    //
    if ( MaxOutStandingConnect < MAX_SINGLE_CONNECT_THRESHOLD_DIFF*5)
    {
        MaxSingleOutStandingConnect = MaxOutStandingConnect - 1;
    } else {
        MaxSingleOutStandingConnect = MaxOutStandingConnect - MAX_SINGLE_CONNECT_THRESHOLD_DIFF;
    }

    //
    // Create the connect Event
    //
    if (MaxOutStandingConnect != 0) {
        hConnectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (hConnectEvent == NULL) {
            MaxOutStandingConnect = 0;
        }
    }

    //
    // Initialize winsock
    //


    // Ask for Winsock version 2.2.
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) == 0) {
        gbWinSockInitialized = TRUE;
    }

    //
    // Initialize the Cleanup Timer used to cleanup the Bad IP addr for DoS attacks
    // Just create the timer, do not start it now - it will be started when there is a entry in the table
    // Not used now but may be turned on at a later state 
    // Status = IcaTimerCreate( 0, &hCleanupTimer );

    return(Status);

    /*
     * Clean up on failure. Clean up is not implemented for
     * all cases of failure. However most of it will be done implicitly
     * by the exit from termsrv process. Failure at this point means anyway
     * there will be no multi-user feature.
     */

badInitLPC: // Cleanup code not implemented
badInitSecurity:
badEvent:
    if (WinStationEvent != NULL)
        NtClose(WinStationEvent);
    if (WinStationIdleControlEvent != NULL)
        NtClose(WinStationIdleControlEvent);
    if (ConsoleLogoffEvent != NULL)
        NtClose(ConsoleLogoffEvent);
badLcInit:
    RtlDeleteCriticalSection( &WinStationStartCsrLock );
badinitStartCsrLock:
    RtlDeleteCriticalSection( &TimerCritSec );
badTimerCritsec:
badWinStationZombieLock:
    if (gbListenerOff) {
        RtlDeleteCriticalSection( &WinStationListenersLock );
    }
badWinStationListenersLock:
    RtlDeleteCriticalSection( &WinStationListLock );
badWinstationListLock:
    RtlDeleteCriticalSection( &UserProfileLock );
badUserProfileLock:
    RtlDeleteCriticalSection( &ConsoleLock );
badAuthzCritSection:
    RtlDeleteCriticalSection( &g_AuthzCritSection );
badConsoleLock:
    RtlDeleteCriticalSection( &FilterLock );
badFilterLock:
    return Status;
}

/*******************************************************************************
 *
 * GroupPOlicyChangeStartSalem()
 *
 *  This routine is called by timer to start Salem.
 * 
 * Entry: 
 *      None, not using any input parameter, refer to WAITORTIMERCALLBACK
 *      for function declaration.
 *
 *
*******************************************************************************/
VOID CALLBACK
GroupPOlicyChangeStartSalem( PVOID lParm, BOOLEAN TimerOrWait )
{
    // Policy might change during wait, check if policy still allow
    // to get help from local machine, if so, startup Salem.
    if( TSIsMachinePolicyAllowHelp() && RegIsMachineInHelpMode() ) {
        TSStartupSalem();
    }

    return;
}

/*******************************************************************************
 *
 * GroupPolicyNotifyThread
 * Entry: 
 *      nothing
 *
 *
*******************************************************************************/
DWORD GroupPolicyNotifyThread(DWORD notUsed )
{
    DWORD       dwError;
    BOOL        rc;
    HANDLE      hEvent;
    BOOLEAN     bWaitForAccept;
    BOOLEAN     bSystemStartup;

    HANDLE      hStartupSalemTimer = NULL;
    HANDLE      hStartupSalemTimerQueue = NULL;
    BOOL        bTimerStatus;

    static      FILETIME    timeOfLastPolicyRead = { 0 , 0 } ;

    rc = RegisterGPNotification( g_hMachineGPEvent, TRUE);

    if (rc) {
        hEvent = g_hMachineGPEvent;
    } else {
        // TS can still run with the default set of config data, besides
        // if there were any machine group policy data, TS got them on the
        // last reboot cycle.
        //
        hEvent = NULL;
    }

    hStartupSalemTimerQueue = CreateTimerQueue();
    if( NULL == hStartupSalemTimerQueue ) {
        // non-critical, we just can't startup Salem to punch firewall or
        // ICS port.
        DBGPRINT(("TERMSRV: Error %d in CreateTimerQueue\n", GetLastError()));
    }

    //
    // At the beginning the listeners are not started.
    // So wait (or test) for the connections to be accepted.
    //
    bWaitForAccept = TRUE;
    bSystemStartup = TRUE;


    //
    // Query and set the global flag before entering any wait.
    //
    g_fDenyTSConnectionsPolicy = RegDenyTSConnectionsPolicy();


    while (TRUE) {

        dwError = WaitForTSConnectionsPolicyChanges( bWaitForAccept, hEvent );

        if( hStartupSalemTimerQueue && (dwError == WAIT_OBJECT_0 || dwError == WAIT_OBJECT_0 + 1) ) {
            // refer to WaitForTSConnectionsPolicyChanges() for return code.
            if( hStartupSalemTimer != NULL ) {
                // Delete the timer-queue timer and wait for callback to complete
                DeleteTimerQueueTimer( 
                                hStartupSalemTimerQueue, 
                                hStartupSalemTimer, 
                                INVALID_HANDLE_VALUE 
                            ); 
                hStartupSalemTimer = NULL;
            }

            //
            // Delay startup Salem, user might change mind or policy might change especially
            // domain policy.
            //
            bTimerStatus = CreateTimerQueueTimer(
                                    &hStartupSalemTimer,
                                    hStartupSalemTimerQueue,
                                    GroupPOlicyChangeStartSalem,
                                    NULL,
                                    DELAY_STARTUP_SALEM_TIME,
                                    0,
                                    WT_EXECUTEONLYONCE
                                );

            if( FALSE == bTimerStatus ) {
                // non-critical, we just can't startup Salem to punch firewall or
                // ICS port.
                DBGPRINT(("TERMSRV: Error %d in CreateTimerQueueTimer\n", GetLastError()));
            }
        }

        //
        // Both GP changes and reg changes can affect this one.
        //
        g_fDenyTSConnectionsPolicy = RegDenyTSConnectionsPolicy();

        if (dwError == WAIT_OBJECT_0) {

            //
            // A change in the TS connections policy has occurred.
            //
            if (bWaitForAccept) {

                // are the connections really accepted?
                if (!(g_fDenyTSConnectionsPolicy &&
                      !(TSIsMachinePolicyAllowHelp() && RegIsMachineInHelpMode()))) {

                    // Start the listeners.
                    if ( bSystemStartup ) {
                        // the first time, start all listeners
                        StartStopListeners(NULL, TRUE);
                    } else {
                        // after the first time, use this function to start
                        // listeners only as needed.
                        WinStationReadRegistryWorker();
                    }

                    // Switch to a wait for denied connections.
                    bWaitForAccept = FALSE;

                    bSystemStartup = FALSE;
                }

            } else {

                // are the connections really denied?
                if (g_fDenyTSConnectionsPolicy &&
                    !(TSIsMachinePolicyAllowHelp() && RegIsMachineInHelpMode())) {
                    // Stop the listeners.
                    StartStopListeners(NULL, FALSE);

                    // Switch to a wait for accepted connections.
                    bWaitForAccept = TRUE;
                }

            }

        } else if (dwError == WAIT_OBJECT_0 + 1) {

            //
            // We got notified that the GP has changed.
            //
            if ( RegGetMachinePolicyEx( FALSE, & timeOfLastPolicyRead,  &g_MachinePolicy ) )
            {
                // there has been a change, go ahead with the actual updates
                WinStationReadRegistryWorker();

                // Also update the session directory settings if on an app 
                // server.
                if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
                    UpdateSessionDirectory(0);
                }

                RegisterRPCInterface( TRUE );
            }

        } else {

            // should we not do something else?
            Sleep( 5000 );
            continue;
        }

    }

    if (rc) {
        UnregisterGPNotification(g_hMachineGPEvent);
    }

    if( hStartupSalemTimerQueue ) {
        if( hStartupSalemTimer != NULL ) {
            // Delete the timer-queue timer and wait for callback to complete
            DeleteTimerQueueTimer( 
                            hStartupSalemTimerQueue, 
                            hStartupSalemTimer, 
                            INVALID_HANDLE_VALUE 
                        ); 
        }

        DeleteTimerQueueEx( hStartupSalemTimerQueue, NULL );
    }

    return 0;
}

/*******************************************************************************
 *
 *  StartAllWinStations
 *
 *   Get list of configured WinStations from the registry,
 *   start the Console, and then start all remaining WinStations.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

void StartAllWinStations(HKEY hKeyTermSrv)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyPath;
    HANDLE KeyHandle;
    UNICODE_STRING ValueName;
#define VALUE_BUFFER_SIZE (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + 256 * sizeof(WCHAR))
    CHAR ValueBuffer[VALUE_BUFFER_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
    DWORD ThreadId;
    NTSTATUS Status;
    DWORD ValueType;
    DWORD ValueSize;
#define AUTOSTARTTIME 600000

    ASSERT(hKeyTermSrv != NULL);

    /*
     * Initialize the number of idle winstations and gMinPerSessionPageCommitMB,
     * if this value is in the registry.
     */
    ValueSize = sizeof(IdleWinStationPoolCount);
    Status = RegQueryValueEx(hKeyTermSrv,
                              REG_CITRIX_IDLEWINSTATIONPOOLCOUNT,
                              NULL,
                              &ValueType,
                              (LPBYTE) &ValueBuffer,
                              &ValueSize );
    if ( Status == ERROR_SUCCESS ) {
        IdleWinStationPoolCount = *(PULONG)ValueBuffer;
    }

    // IdleWinStationPoolCount made 0 -- change necessiated by DoS attack prevention logic added to TS
    // Also Idle WinStations are not very useful anymore because CSR and Winlogon is started much later than before
    // So set it to Zero here, irrespective of what its value is in the Registry
    IdleWinStationPoolCount = 0;
    
    //get the product id from registry for use in detecting shadow loop
     GetProductIdFromRegistry( g_DigProductId, sizeof( g_DigProductId ) );



    //Terminal Service needs to skip Memory check in Embedded images 
    //when the TS service starts
    //bug #246972
    if(!IsEmbedded()) {
        
        ValueSize = sizeof(gMinPerSessionPageCommitMB);
        Status = RegQueryValueEx(hKeyTermSrv,
                                  REG_MIN_PERSESSION_PAGECOMMIT,
                                  NULL,
                                  &ValueType,
                                  (LPBYTE) &ValueBuffer,
                                  &ValueSize );
        if ( Status == ERROR_SUCCESS ) {
            gMinPerSessionPageCommitMB = *(PULONG)ValueBuffer;
        }

        gMinPerSessionPageCommit = gMinPerSessionPageCommitMB * 1024 * 1024;
        Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                          &glpAddress,
                                          0,
                                          &gMinPerSessionPageCommit,
                                          MEM_RESERVE,
                                          PAGE_READWRITE
                                        );
        ASSERT( NT_SUCCESS( Status ) );

    }

    /*
     * Open connection to our WinStationApiPort.  This will be used to
     * queue requests to our API thread instead of doing them inline.
     */
    Status = ConnectSmWinStationApiPort();
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Create Console WinStation first
     */
    Status = WinStationCreateWorker( L"Console", NULL, TRUE );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(("INIT: Failed to create Console WinStation, status=0x%08x\n", Status));
    } else {
        /*
         * From now on,WinStationIdleControlThread can create console sessions if needed
         */
        InterlockedDecrement(&gConsoleCreationDisable);

    }


    /*
     * Open the Setup key and look for the valuename "SystemSetupInProgress".
     * If found and it has a value of TRUE (non-zero), then setup is in
     * progress and we skip starting WinStations other than the Console.
     */
    RtlInitUnicodeString( &KeyPath, SETUP_REG_PATH );
    InitializeObjectAttributes( &ObjectAttributes, &KeyPath,
                                OBJ_CASE_INSENSITIVE, NULL, NULL );
    Status = NtOpenKey( &KeyHandle, GENERIC_READ, &ObjectAttributes );
    if ( NT_SUCCESS( Status ) ) {
        RtlInitUnicodeString( &ValueName, L"SystemSetupInProgress" );
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)ValueBuffer;
        Status = NtQueryValueKey( KeyHandle,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  (PVOID)KeyValueInfo,
                                  VALUE_BUFFER_SIZE,
                                  &ValueLength );
        NtClose( KeyHandle );
        if ( NT_SUCCESS( Status ) ) {
            ASSERT( ValueLength < VALUE_BUFFER_SIZE );
            if ( KeyValueInfo->Type == REG_DWORD &&
                 KeyValueInfo->DataLength == sizeof(ULONG) &&
                 *(PULONG)(KeyValueInfo->Data) != 0 ) {
                return;
            }
        }
    }

    /*
     * Start a policy notfiy thread.
     *
     */
    {
        HANDLE  hGroupPolicyNotifyThread;
        DWORD   dwID;
        
        g_hMachineGPEvent = CreateEvent (NULL, FALSE, FALSE, 
            TEXT("TermSrv:  machine GP event"));

        if (g_hMachineGPEvent) 
        {
            hGroupPolicyNotifyThread = CreateThread (
                NULL, 0, (LPTHREAD_START_ROUTINE) GroupPolicyNotifyThread,
                0, 0, &dwID);
            if ( hGroupPolicyNotifyThread )
            {
                NtClose( hGroupPolicyNotifyThread );
            }
        }
    }

    /*
     * If necessary, create the thread in charge of the regulation of the idle sessions
     */
    {
        HANDLE hIdleControlThread = CreateThread( NULL,
                                            0,              // use Default stack size of the svchost process
                    (LPTHREAD_START_ROUTINE)WinStationIdleControlThread,
                                            NULL,
                                            THREAD_SET_INFORMATION,
                                            &ThreadId );
        if (hIdleControlThread)  {
            NtClose(hIdleControlThread);
        }
    }

    /*
     * Finally, create the terminate thread
     */
    {
    HANDLE hTerminateThread = CreateThread( NULL,
                                            0,      // use Default stack size of the svchost process
                    (LPTHREAD_START_ROUTINE)WinStationTerminateThread,
                                            NULL,
                                            THREAD_SET_INFORMATION,
                                            &ThreadId );
    if ( hTerminateThread )
        NtClose( hTerminateThread );
    }
}


/*******************************************************************************
 *
 *  StartStopListeners
 *
 *   Get list of configured WinStations from the registry,
 *   and start the WinStations.
 *
 * ENTRY:
 *    bStart
 *      if TRUE start the listeners.
 *      if FALSE stop the listeners if no connections related to them exist
 *      anymore. However we do this only on PRO and PER as on a server we         
 *      don't mind keeping the listeners.
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/
BOOL StartStopListeners(LPWSTR WinStationName, BOOLEAN bStart)
{
    ULONG i;
    ULONG WinStationCount, ByteCount;
    PWINSTATIONNAME pBuffer;
    PWINSTATIONNAME pWinStationName;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    BOOL     bReturn = FALSE;

    if (bStart) {

        /*
         * Get list of WinStations from registry
         */
        pBuffer = NULL;
        WinStationCount = 0;
        Status = IcaRegWinStationEnumerate( &WinStationCount, NULL, &ByteCount );
        if ( NT_SUCCESS(Status) ) {
            pBuffer = pWinStationName = MemAlloc( ByteCount );
            WinStationCount = (ULONG) -1;
            if (pBuffer) {
                IcaRegWinStationEnumerate( &WinStationCount,
                                           pWinStationName,
                                           &ByteCount );
            }
        }

        /*
         * Now create all remaining WinStations defined in registry
         * Note that every 4th WinStation we do the WinStationCreate inline
         * instead of queueing it.  This is so we don't create an excess
         * number of API threads right off the bat.
         */
        if ( pBuffer ) {
            for ( i = 0; i < WinStationCount; i++ ) {

                if ( _wcsicmp( pWinStationName, L"Console" ) ) {

                    if ( i % 4 )
                        QueueWinStationCreate( pWinStationName );
                    else { // Don't queue more than 4 at a time
                        (void) WinStationCreateWorker( pWinStationName, NULL, TRUE );
                    }
                }
                (char *)pWinStationName += sizeof(WINSTATIONNAME);
            }

            MemFree( pBuffer );
        }

        bReturn = TRUE;

    } else {

        if ( !gbListenerOff ) {
            return FALSE;
        }

        ENTERCRIT( &WinStationListenersLock );

        // Test if TS connections are denied or not in case we are called from a
        // terminate or a disconnect.

        if ( g_fDenyTSConnectionsPolicy  &&
             // Performance, we only want to check if policy enable help when connection is denied
             (!TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp()) ) {

            ULONG ulLogonId;

            if( WinStationName ) {

                // note that this function doesn't handle renamed listeners
                WinStationCount = CountWinStationType( WinStationName, TRUE, FALSE );

                if ( WinStationCount == 0 ) {

                    pWinStation = FindWinStationByName( WinStationName, FALSE );

                    if ( pWinStation ) {

                        ulLogonId = pWinStation->LogonId;

                        ReleaseWinStation( pWinStation );

                         // reset it and don't recreate it
                        WinStationResetWorker( ulLogonId, TRUE, FALSE, FALSE );
                    }
                }

            } else {

                // terminate all listeners

searchagain:
                Head = &WinStationListHead;
                ENTERCRIT( &WinStationListLock );

                for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

                    pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

                    //
                    // Only check listening winstations
                    //
                    if ( (pWinStation->Flags & WSF_LISTEN) &&
                         !(pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {

                        ulLogonId = pWinStation->LogonId;

                        // note that this function doesn't handle renamed listeners
                        WinStationCount = CountWinStationType( pWinStation->WinStationName, TRUE, TRUE );

                        if ( WinStationCount == 0 ) {

                            LEAVECRIT( &WinStationListLock );

                            // reset it and don't recreate it
                            WinStationResetWorker( ulLogonId, TRUE, FALSE, FALSE );
                            goto searchagain;
                        }

                    }
                }
                LEAVECRIT( &WinStationListLock );
            }

            bReturn = TRUE;

        }
        LEAVECRIT( &WinStationListenersLock );

    }

    return bReturn;
}


/*******************************************************************************
 *  WinStationIdleControlThread
 *
 *   This routine will control the number of idle sessions.
 ******************************************************************************/
NTSTATUS WinStationIdleControlThread(PVOID Parameter)
{
    ULONG i;
    NTSTATUS    Status = STATUS_SUCCESS;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    ULONG       IdleCount = 0;
    ULONG       j;
    LARGE_INTEGER Timeout;
    PLARGE_INTEGER pTimeout;
    ULONG ulSleepDuration;
    ULONG ulRetries = 0;

    ulSleepDuration = 60*1000; // 1 minute
    pTimeout = NULL;


    /*
     * Now create the pool of idle WinStations waiting for a connection.
     * we need to wait for termsrv to be fully up, otherwise Winlogon will
     * fail its RPC call to termsrv (WaitForConnectWorker).
     */

    if (gReadyEventHandle != NULL) {
        WaitForSingleObject(gReadyEventHandle, (DWORD)-1);
    }

    for ( i = 0; i < IdleWinStationPoolCount; i++ ) {
        (void) WinStationCreateWorker( NULL, NULL, FALSE );
    }

    Timeout = RtlEnlargedIntegerMultiply( ulSleepDuration, -10000);

    if (WinStationIdleControlEvent != NULL)
    {
        while (TRUE)
        {

            Status = NtWaitForSingleObject(WinStationIdleControlEvent,FALSE, pTimeout);

            if ( !NT_SUCCESS(Status) && (Status != STATUS_TIMEOUT)) {
                Sleep(1000);     // don't eat too much CPU
                continue;
            }
            pTimeout = &Timeout;
            /*
             * See if we need to create a console session
             * If if we fail creating a console session, we'll set a timeout so that we will
             * retry .
             */
            ENTERCRIT( &ConsoleLock );

            if (gConsoleCreationDisable == 0) {
                if (WinStationCheckConsoleSession()) {
                    pTimeout = NULL;
                }
            } 

            LEAVECRIT( &ConsoleLock );

            /*
             * Now count the number of IDLE WinStations and ensure there
             * are enough available.
             */
            if (IdleWinStationPoolCount != 0) {
                ENTERCRIT( &WinStationListLock );
                IdleCount = 0;
                Head = &WinStationListHead;
                for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
                    pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
                    if ( pWinStation->Flags & WSF_IDLE )
                        IdleCount++;
                }
                LEAVECRIT( &WinStationListLock );

                for ( j = IdleCount; j < IdleWinStationPoolCount; j++ ) {
                    WinStationCreateWorker( NULL, NULL, FALSE );
                }
            }
        }
    }
    return STATUS_SUCCESS;
}


#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715) // Not all control paths return (due to infinite loop)
#endif
/*******************************************************************************
 *  WinStationTerminateThread
 *
 *   This routine will wait for WinStation processes to terminate,
 *   and will then reset the corresponding WinStation.
 ******************************************************************************/
NTSTATUS WinStationTerminateThread(PVOID Parameter)
{
    LONG ThreadIndex = (LONG)(INT_PTR)Parameter;
    LONG WinStationIndex;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    LONG EventCount;
    LONG EventIndex, i;
    int WaitCount;
    int HandleCount;
    int HandleArraySize = 0;
    PHANDLE pHandleArray = NULL;
    PULONG pIdArray = NULL;
    ULONG ThreadsNeeded;
    ULONG ThreadsRunning = 1;
    ULONG j;
    NTSTATUS Status;
    LARGE_INTEGER Timeout;
    PLARGE_INTEGER pTimeout;
    ULONG ulSleepDuration;
    HANDLE DupHandle;

    /*
     * We need some timer values for the diferent cases of failure in
     * the thread's loop:
     * - If we fail creating a new WinstationterminateThread,
     * then we will do a WaitFormulpipleObjects with a timer instead of a wait without
     * time out. This will give a new chance to create the thread when timout is over.
     * if we fail allocating a new buffer to extend handle array, we will wait a timeout
     * duration before we retry.
     */

    ulSleepDuration = 3*60*1000;
    Timeout = RtlEnlargedIntegerMultiply( ulSleepDuration, -10000);

    /*
     * Loop forever waiting for WinStation processes to terminate
     */
    for ( ; ; ) {

        /*
         * Determine number of WinStations
         */
        pTimeout = NULL;
        WaitCount = 0;
        Head = &WinStationListHead;
        ENTERCRIT( &WinStationListLock );
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink )
            WaitCount++;

        /*
         * If there are more than the maximum number of objects that
         * can be specified to NtWaitForMultipleObjects, then determine
         * if we must start up additional thread(s).
         */
        if ( WaitCount > MAXIMUM_WAIT_WINSTATIONS ) {
            ThreadsNeeded = (WaitCount + MAXIMUM_WAIT_WINSTATIONS - 1) /
                                MAXIMUM_WAIT_WINSTATIONS;
            WaitCount = MAXIMUM_WAIT_WINSTATIONS;
            if ( ThreadIndex == 0 && ThreadsNeeded > ThreadsRunning ) {
                LEAVECRIT( &WinStationListLock );
                for ( j = ThreadsRunning; j < ThreadsNeeded; j++ ) {
                    DWORD ThreadId;
                    HANDLE Handle;

                    Handle = CreateThread( NULL,
                                           0,       // use Default stack size of the svchost process
                                           (LPTHREAD_START_ROUTINE)
                                               WinStationTerminateThread,
                                           ULongToPtr( j * MAXIMUM_WAIT_WINSTATIONS ),
                                           THREAD_SET_INFORMATION,
                                           &ThreadId );
                    if ( !Handle ) {
                       pTimeout = &Timeout;
                       break;
                    }

                    // makarp: 182597 - close handle to the thread.
                    CloseHandle(Handle);

                    ThreadsRunning++;
                }
                ENTERCRIT( &WinStationListLock );
            }
        }

        /*
         * If we need a larger handle array, then release the
         * WinStationList lock, allocate the new handle array,
         * and go start the loop again.
         */
        HandleCount = (WaitCount << 1) + 1;
        ASSERT( HandleCount < MAXIMUM_WAIT_OBJECTS );
        if ( HandleCount > HandleArraySize ||
             HandleCount < HandleArraySize - 10 ) {
            LEAVECRIT( &WinStationListLock );
            if ( pHandleArray ){
               MemFree( pHandleArray );
            }

            pHandleArray = MemAlloc( HandleCount * sizeof(HANDLE) );
            if ( pIdArray ) {
               MemFree( pIdArray );
            }

            pIdArray = MemAlloc( HandleCount * sizeof(ULONG) );


            /* makarp: check for allocation failures #182597 */
            if (!pIdArray || !pHandleArray) {

                if (pIdArray) {
                   MemFree(pIdArray);
                   pIdArray = NULL;
                }
                if (pHandleArray){
                   MemFree(pHandleArray);
                   pHandleArray = NULL;
                }

                HandleArraySize = 0;

                Sleep(ulSleepDuration);
                continue;
            }

            HandleArraySize = HandleCount;
            continue;
        }

        /*
         * Build list of handles to wait on
         */
        EventCount = 0;
        pIdArray[EventCount] = 0;
        pHandleArray[EventCount++] = WinStationEvent;
        WinStationIndex = 0;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            if ( WinStationIndex++ < ThreadIndex )
                continue;
            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
            if ( !pWinStation->LogonId ) // no waiting on console
                continue;
            if ( pWinStation->Starting )
                continue;
            if  (pWinStation->Terminating) {
                continue;
            }

            /*
             * Do not use handles to subsystem and initial command. These handles may get closed in Winstation
             * Terminate routine and there is no easy way to synchronize this with Terminate routine using those
             * handles. So, duplicated those handles. 
             *
             * NOTE: If the duplication of the handles fails below, the winstation remains unmonitored. 
             */

            // Duplicate the subsystem process handle.
            DupHandle = NULL;
            if ( pWinStation->WindowsSubSysProcess ) {
                Status = NtDuplicateObject( NtCurrentProcess(),
                                            pWinStation->WindowsSubSysProcess,
                                            NtCurrentProcess(),
                                            &DupHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS );
                if (NT_SUCCESS(Status)) {
                    pIdArray[EventCount] = pWinStation->LogonId;
                    pHandleArray[EventCount++] = DupHandle;
                }
            }

            // Duplicate the initial command process handle.
            DupHandle = NULL;
            if ( pWinStation->InitialCommandProcess ) {
                Status = NtDuplicateObject( NtCurrentProcess(),
                                            pWinStation->InitialCommandProcess,
                                            NtCurrentProcess(),
                                            &DupHandle,
                                            0,
                                            0,
                                            DUPLICATE_SAME_ACCESS );
                if (NT_SUCCESS(Status)) {
                    pIdArray[EventCount] = pWinStation->LogonId;
                    pHandleArray[EventCount++] = DupHandle;
                }
            }

            if ( WinStationIndex - ThreadIndex >= WaitCount )
                break;
        }

        /*
         * Reset WinStationEvent and release the WinStationList lock
         */
        NtResetEvent( WinStationEvent, NULL );
        LEAVECRIT( &WinStationListLock );

        /*
         * Wait for WinStationEvent to trigger (meaning that the
         * WinStationList has changed), or for one of the existing
         * Win32 subsystems or initial commands to terminate.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateThread, Waiting for initial command exit (ArraySize=%d)\n", EventCount ));

        Status = NtWaitForMultipleObjects( EventCount, pHandleArray, WaitAny,
                                           FALSE, pTimeout );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateThread, WaitForMultipleObjects, rc=%x\n", Status ));

        /*
         * Cleanup the handles array immediately. Close the duplicated handles. Just make sure we are closing a valid handle.
         * Do not close the handle[0]. It's WinstationEvent handle.
         */
        for ( i = 1; i < EventCount; i++) {
            if (pHandleArray[i]) {
                NtClose(pHandleArray[i]);
                pHandleArray[i] = NULL;
            }
        }

        if ( !NT_SUCCESS(Status) || Status >= EventCount ) { //WinStationVerifyHandles();
            continue;
        }

        /*
         * If WinStationEvent triggered, then just go recompute handle list
         */
        if ( (EventIndex = Status) == STATUS_WAIT_0 )
            continue;

        /*
         * Find the WinStation for the process that terminated and
         * mark it as terminating.  This prevents us from waiting
         * on that WinStation's processes next time through the loop.
         * (NOTE: The 'Terminating' field is protected by the global
         * WinStationListLock instead of the WinStation mutex.)
         */
        Head = &WinStationListHead;
        ENTERCRIT( &WinStationListLock );
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
            if ( pWinStation->LogonId == pIdArray[EventIndex] ) {
                pWinStation->Terminating = TRUE;
                break;
            }
        }

        LEAVECRIT( &WinStationListLock );

        /*
         * Wake up the WinStationIdleControlThread
         */
        NtSetEvent(WinStationIdleControlEvent, NULL);

        /*
         * If there are multiple terminate threads, cause the other
         * threads to wakeup in order to recompute their wait lists.
         */
        NtSetEvent( WinStationEvent, NULL );

        /*
         * One of the initial command processes has terminated,
         * queue a request to reset the WinStation.
         */
        QueueWinStationReset( pIdArray[EventIndex]);
    }

    // make the compiler happy
    return STATUS_SUCCESS;
}
#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


/*******************************************************************************
 *  InvalidateTerminateWaitList
 *
 *   Wakes up WinStationTerminateThread to force it to reinitialize its
 *   wait list. Used when we detect that the initial process was ntsd,
 *   and we change the initial process to WinLogon.
 *
 * ENTRY:
 *    The WinStationListLock must not be held.
 ******************************************************************************/
VOID InvalidateTerminateWaitList(void)
{
    ENTERCRIT( &WinStationListLock );
    NtSetEvent( WinStationEvent, NULL );
    LEAVECRIT( &WinStationListLock );
}


/*******************************************************************************
 *  WinStationConnectThread
 *
 *   This routine will wait for and process incoming connections
 *   for a specified WinStation.
 ******************************************************************************/
NTSTATUS WinStationConnectThread(ULONG Parameter)
{
    typedef struct _TRANSFERTHREAD {
        LIST_ENTRY Entry;
        HANDLE hThread;
    } TRANSFERTHREAD, *PTRANSFERTHREAD;

    LIST_ENTRY TransferThreadList;
    PTRANSFERTHREAD pTransferThread;
    PLIST_ENTRY Next;

    PWINSTATION pListenWinStation;
    PVOID pEndpoint = NULL;
    ULONG EndpointLength;
    ULONG WinStationCount;
    ULONG TransferThreadCount;
    BOOLEAN rc;
    BOOLEAN bConnectSuccess = FALSE;
    BOOLEAN bTerminate = FALSE;
    NTSTATUS Status;
    SYSTEMTIME currentSystemTime;

#define MODULE_SIZE 1024
#define _WAIT_ERROR_LIMIT 10
    ULONG WaitErrorLimit = _WAIT_ERROR_LIMIT; // # of consecutive errors allowed

    /*
     * Initialize list of transfer threads
     */
    InitializeListHead( &TransferThreadList );

    /*
     * Find and lock the WinStation
     */
    pListenWinStation = FindWinStationById( Parameter, FALSE );
    if ( pListenWinStation == NULL ) {
        return( STATUS_ACCESS_DENIED );
    }

    /*
     * Ensure only authorized Session Driver and Video Driver stack
     * modules will be loaded as a result of this connection thread.
     *
     * If any module fails verification, mark the WinStation in the
     * DOWN state and exit WITHOUT error.
     *
     * NOTE:
     * The silent exit is very much intentional so as not to aid in
     * a third party's attempt to circumvent this security measure.
     */

    Status = _VerifyStackModules( pListenWinStation );
    if ( Status != STATUS_SUCCESS ) {
        pListenWinStation->State = State_Down;
        ReleaseWinStation( pListenWinStation );
        return( STATUS_SUCCESS );
    }


    /*
     * Indicate we got this far successfully.
     */
    pListenWinStation->CreateStatus = STATUS_SUCCESS;

    /*
     * Load the WinStation extension dll for this WinStation.
     * Note that we don't save the result in pListenWinStation->pWsx
     * since we don't want to make callouts to it for the
     * listen WinStation.
     */
    (VOID) FindWinStationExtensionDll( pListenWinStation->Config.Wd.WsxDLL,
                                       pListenWinStation->Config.Wd.WdFlag );


    /*
     * Do not start accepting client connections before termsrv is totaly UP
     */
    if (gReadyEventHandle != NULL) {
        WaitForSingleObject(gReadyEventHandle, (DWORD)-1);
    }

    /*
     * for perf reason termsrv startup is delayed. We the need to also delay
     * accepting connections so that if a console logon hapened before termsrv
     * was up, we get the delayed logon notification before we accept a 
     * client connection.
     */

    if (gbFirtsConnectionThread) {
        Sleep(5*1000);
        gbFirtsConnectionThread = FALSE;
    }


    // Get the local IP address enabled for rdp for Session Directory Use
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer && !g_fGetLocalIP) {
        ULONG LocalIPAddress, LocalIPAddressLength;
        struct sockaddr_in6 addr6;

        Status = IcaStackQueryLocalAddress( pListenWinStation->hStack,
                                       pListenWinStation->WinStationName,
                                       &pListenWinStation->Config,
                                       NULL,
                                       (PVOID)&addr6,
                                       sizeof(addr6),
                                       &LocalIPAddressLength );

        if( NT_SUCCESS(Status) )
        {
            g_fGetLocalIP = TRUE;
            if( AF_INET == addr6.sin6_family )
            {
                struct sockaddr_in* pAddr = (struct sockaddr_in *)&addr6;

                LocalIPAddress =  pAddr->sin_addr.s_addr;
            }
            else
            {
                // Support of IPV6 is for next release.
                ;
            }
            if (g_LocalIPAddress != LocalIPAddress) {
                g_LocalIPAddress = LocalIPAddress;
                UpdateSessionDirectory(0);
            }
        }

    }    

    /*
     * Loop waiting for connection requests and passing them off
     * to an idle WinStation.
     */
    for ( ; ; ) {

        /*
         *  Abort retries if this listener has been terminated
         */
        if ( pListenWinStation->Terminating ) {
            break;
        }

        /*
         * Allocate an endpoint buffer
         */
        pEndpoint = MemAlloc( MODULE_SIZE );
        if ( !pEndpoint ) {
            Status = STATUS_NO_MEMORY;

            // Sleep for 30 seconds and try again.  Listener thread should not exit
            // simply just in low memory condition
            UnlockWinStation(pListenWinStation);

            Sleep(30000);

            if (!RelockWinStation(pListenWinStation))
                break;

            continue;
        }

        /*
         * Unlock listen WinStation while we wait for a connection
         */
        UnlockWinStation( pListenWinStation );

        /*
         * Check if # outstanding connections reaches max value
         * If so, wait for the event when the connection # drops
         * below the max.  There is a timeout value of 30 seconds
         * for the wait
         */
        if (hConnectEvent != NULL) {
            if (NumOutStandingConnect > MaxOutStandingConnect) {
                DWORD rc;

                // Event log we have exceeded max outstanding connections. but not more than
                // once in a day.

                GetSystemTime(&currentSystemTime);
                if ( currentSystemTime.wYear != LastLoggedDelayConnection.wYear  ||
                     currentSystemTime.wMonth != LastLoggedDelayConnection.wMonth  ||
                     currentSystemTime.wDay != LastLoggedDelayConnection.wDay    ||
                     gbNeverLoggedDelayConnection
                    ) {
                    gbNeverLoggedDelayConnection = FALSE;
                    LastLoggedDelayConnection = currentSystemTime;
                    WriteErrorLogEntry(EVENT_TOO_MANY_CONNECTIONS,
                            pListenWinStation->WinStationName,
                            sizeof(pListenWinStation->WinStationName));
                }


                // manual reset the ConnectEvent before wait
                ResetEvent(hConnectEvent);
                rc = WAIT_TIMEOUT;

                // wait for Connect Event for 30 secs
                while (rc == WAIT_TIMEOUT) {
                    rc = WaitForSingleObject(hConnectEvent, DelayConnectionTime);
                    if (NumOutStandingConnect <= MaxOutStandingConnect) {
                        break;
                    }
                    if (rc == WAIT_TIMEOUT) {
                        KdPrint(("TermSrv: Reached 30 secs timeout\n"));
                    }
                    else {
                        KdPrint(("TermSrv: WaitForSingleObject return status=%x\n", rc));
                    }
                }

            }
        }

        /*
         *  Wait for connection
         */
        Status = IcaStackConnectionWait( pListenWinStation->hStack,
                                         pListenWinStation->WinStationName,
                                         &pListenWinStation->Config,
                                         NULL,
                                         pEndpoint,
                                         MODULE_SIZE,
                                         &EndpointLength );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            MemFree( pEndpoint );
            pEndpoint = MemAlloc( EndpointLength );
            if ( !pEndpoint ) {
                Status = STATUS_NO_MEMORY;

                // Sleep for 30 seconds and try again.  Listener thread should not exit
                // simply just in low memory condition
                Sleep(30000);

                if (!RelockWinStation( pListenWinStation ))
                    break;

                continue;


            }

            Status = IcaStackConnectionWait( pListenWinStation->hStack,
                                             pListenWinStation->WinStationName,
                                             &pListenWinStation->Config,
                                             NULL,
                                             pEndpoint,
                                             EndpointLength,
                                             &EndpointLength );
        }

        /*
         * If ConnectionWait was not successful,
         * check to see if the consecutive error limit has been reached.
         */
        if ( !NT_SUCCESS( Status ) ) {
            MemFree( pEndpoint );
            pEndpoint = NULL;
            
            if (Status == STATUS_SHARING_VIOLATION && _wcsicmp(pListenWinStation->Config.Pd[0].Create.PdName, L"tcp") == 0)
            {
                /*
                 * This status means that our port is opened by some other process.
                 * Lets log an event about this.
                 */
                 static BOOL bPortTakenEventlogged = FALSE;
                 if (!bPortTakenEventlogged)
                 {
                    PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, WSAEADDRINUSE);
                    bPortTakenEventlogged = TRUE;
                 }
            }

            /*
             * If status is DEVICE_DOES_NOT_EXIST, then we want to wait before retrying
             * otherwise, this prioritary thread will take all the CPU trying 10 times
             * lo load the listener stack. Such an error takes time to be fixed (either
             * changing the NIC or going into tscc to have the NIC GUID table updated.
             */
            if ((Status == STATUS_DEVICE_DOES_NOT_EXIST) || (!bConnectSuccess) || (Status == STATUS_INVALID_ADDRESS_COMPONENT) ) {

                Sleep(30000);
            }

            if ( WaitErrorLimit--) {
                if (!RelockWinStation( pListenWinStation ))
                    break;

                /*
                 * If we have had a successful connection,
                 * then skip the stack close/reopen since this would
                 * terminate any existing connections.
                 */
                if ( !bConnectSuccess ) {
                    /*
                     * What we really need is a function to unload the
                     * stack drivers but leave the stack handle open.
                     */
                    Status = IcaStackClose( pListenWinStation->hStack );
                    ASSERT( NT_SUCCESS( Status ) );
		    pListenWinStation->hStack = NULL;
                    Status = IcaStackOpen( pListenWinStation->hIca,
                                           Stack_Primary,
                                           (PROC)WsxStackIoControl,
                                           pListenWinStation,
                                           &pListenWinStation->hStack );
                    if ( !NT_SUCCESS( Status ) ) {
                        pListenWinStation->State = State_Down;
                        break;
                    }
                }

                continue;
            }
            else {

                // Sleep for 30 seconds and try again.  Listener thread should not exit
                Sleep(30000);

                if (!RelockWinStation( pListenWinStation ))
                    break;

                // Reset the error count
                WaitErrorLimit = _WAIT_ERROR_LIMIT;

                continue;
            }

        } else {
            bConnectSuccess = TRUE;
            WaitErrorLimit = _WAIT_ERROR_LIMIT;
        }

        /*
         * Check for Shutdown and MaxInstance
         */
        rc = RelockWinStation( pListenWinStation );
        if ( !rc ) {
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                     pEndpoint,
                                     EndpointLength,
                                     pListenWinStation,
                                     TRUE ); // Use a temporary stack
            MemFree( pEndpoint );
            pEndpoint = NULL;
            break;
        }

        /*
         * Reject all connections if a shutdown is in progress
         */
        if ( ShutdownInProgress ) {
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                     pEndpoint,
                                     EndpointLength,
                                     pListenWinStation,
                                     TRUE ); // Use a temporary stack
            MemFree( pEndpoint );
            pEndpoint = NULL;

            continue;
        }

         /*
          * Reject all connections if user or the Group-Policy has disabled accepting connections
          */
         if ( g_fDenyTSConnectionsPolicy ) 
         {

            //
            // Performance, we only want to check if policy enable help when connection is denied
            //
            if( !TSIsMachineInHelpMode() || !TSIsMachinePolicyAllowHelp() )
            {
                 Status = _CloseEndpoint( &pListenWinStation->Config,
                                          pEndpoint,
                                          EndpointLength,
                                          pListenWinStation,
                                          TRUE ); // Use a temporary stack
                 MemFree( pEndpoint );
                 pEndpoint = NULL;

                 if ( gbListenerOff ) {
                     //
                     // if there are no more connections associated
                     // to this listener, then terminate it.
                     //
                     // note that this function doesn't handle renamed listeners
                     WinStationCount = CountWinStationType( pListenWinStation->WinStationName, TRUE, FALSE );

                     if ( WinStationCount == 0 ) {
                         bTerminate = TRUE;
                         break;
                     }
                 }

                 Sleep( 5000 ); // sleep for 5 seconds, defense against
                                // denial of service attacks.
                 continue;
            }
         }


        /*
         * Check to see how many transfer threads we have active.
         * If more than the MaxInstance count, we won't start any more.
         */
        TransferThreadCount = 0;
        Next = TransferThreadList.Flink;
        while ( Next != &TransferThreadList ) {
            pTransferThread = CONTAINING_RECORD( Next, TRANSFERTHREAD, Entry );
            Next = Next->Flink;

            /*
             * If thread is still active, bump the thread count
             */
            if ( WaitForSingleObject( pTransferThread->hThread, 0 ) != 0 ) {
                TransferThreadCount++;

            /*
             * Thread has exited, so close the thread handle and free memory
             */
            } else {
                RemoveEntryList( &pTransferThread->Entry );
                CloseHandle( pTransferThread->hThread );
                MemFree( pTransferThread );
            }
        }

        /*
         * If this is not a single-instance connection
         * and there is a MaxInstance count specified,
         * then check whether the MaxInstance limit will be exceeded.
         */
        if ( !(pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) &&
             pListenWinStation->Config.Create.MaxInstanceCount != (ULONG)-1 ) {
            ULONG Count;

            /*
             * Count number of currently active WinStations
             */
            WinStationCount = CountWinStationType( pListenWinStation->WinStationName, FALSE, FALSE );

            /*
             * Get larger of WinStation and TransferThread count
             */
            Count = max( WinStationCount, TransferThreadCount );

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Count %d\n", Count ));
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: MaxInstanceCount %d\n", pListenWinStation->Config.Create.MaxInstanceCount ));

            if ( pListenWinStation->Config.Create.MaxInstanceCount <= Count ) {
                Status = _CloseEndpoint( &pListenWinStation->Config,
                                         pEndpoint,
                                         EndpointLength,
                                         pListenWinStation,
                                         TRUE ); // Use a temporary stack
                MemFree( pEndpoint );
                pEndpoint = NULL;

                continue;
            }
        }
        UnlockWinStation( pListenWinStation );

        /*
         * Increment the counter of pending connections.
         */

        InterlockedIncrement( &NumOutStandingConnect );

        /*
         * If this is a single instance connection,
         * then handle the transfer of the connection endpoint to
         * an idle WinStation directly.
         */
        if ( pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
            Status = TransferConnectionToIdleWinStation( pListenWinStation,
                                                          pEndpoint,
                                                          EndpointLength,
                                                          NULL );
            pEndpoint = NULL;

            /*
             * If the transfer was successful, then for a single instance
             * connection, we must now exit the wait for connect loop.
             */
            if ( NT_SUCCESS( Status ) ) {
                RelockWinStation( pListenWinStation );
                break;
            }
            else
            {
                bConnectSuccess = FALSE;
            }


        /*
         * For non-single instance WinStations, let the worker thread
         * handle the connection handoff so this thread can go back
         * and listen for another connection immediately.
         */
        } else {
            PTRANSFER_INFO pInfo;
            DWORD ThreadId;
            HANDLE hTransferThread;
            BOOLEAN bTransferThreadCreated = FALSE;

            pInfo = MemAlloc( sizeof(*pInfo) );
            pTransferThread = MemAlloc( sizeof(*pTransferThread) );

            if (pInfo && pTransferThread) {

                pInfo->LogonId = pListenWinStation->LogonId;
                pInfo->pEndpoint = pEndpoint;
                pInfo->EndpointLength = EndpointLength;

                pTransferThread->hThread = CreateThread(
                              NULL,
                              0,        // use Default stack size of the svchost process
                              (LPTHREAD_START_ROUTINE)WinStationTransferThread,
                              (PVOID)pInfo,
                              0,
                              &ThreadId
                              );

                if ( pTransferThread->hThread ) {
                    bTransferThreadCreated = TRUE;
                    InsertTailList( &TransferThreadList, &pTransferThread->Entry );
                }

            }

            if (!bTransferThreadCreated) {
                if (pInfo) {
                    MemFree( pInfo );
                }

                if (pTransferThread) {
                    MemFree( pTransferThread );
                }

                TransferConnectionToIdleWinStation( pListenWinStation,
                                                     pEndpoint,
                                                     EndpointLength,
                                                     NULL );
            }

            pEndpoint = NULL;
        }

        /*
         * Relock the listen WinStation
         */
        if (!RelockWinStation( pListenWinStation ) )
            break;

    } // for - wait for connection

    /*
     * Clean up the transfer thread list.
     * (There's no need to wait for them to exit.)
     */
    Next = TransferThreadList.Flink;
    while ( Next != &TransferThreadList ) {
        pTransferThread = CONTAINING_RECORD( Next, TRANSFERTHREAD, Entry );
        Next = Next->Flink;
        RemoveEntryList( &pTransferThread->Entry );
        CloseHandle( pTransferThread->hThread );
        MemFree( pTransferThread );
    }

    /*
     * If after exiting the connect loop above, the WinStation is marked down,
     * then write the error status to the event log.
     */
    if ( pListenWinStation->State == State_Down ) {
        ReleaseWinStation( pListenWinStation );

        if ( Status != STATUS_CTX_CLOSE_PENDING ) {
            PostErrorValueEvent(EVENT_TS_LISTNER_WINSTATION_ISDOWN, Status);
        }
    } else {
        /*
         * If not a single-instance transport release the WinStation;
         * otherwise, delete the listener WinStation.
         */
        if (!(pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) &&
            !bTerminate) {
            ReleaseWinStation( pListenWinStation );

        } else {
            /*
             * Mark the listen winstation as being deleted.
             * If a reset/delete operation is already in progress
             * on this winstation, then don't proceed with the delete.
             */
            if ( pListenWinStation->Flags & (WSF_RESET | WSF_DELETE) ) {
                ReleaseWinStation( pListenWinStation );
                Status = STATUS_CTX_WINSTATION_BUSY;
            } else {
                pListenWinStation->Flags |= WSF_DELETE;

                /*
                 * Make sure this WinStation is ready to delete
                 */
                WinStationTerminate( pListenWinStation );

                /*
                 * Call the WinStationDelete worker
                 */
                WinStationDeleteWorker( pListenWinStation );
            }
        }
    }


    return Status;
}


/*******************************************************************************
 *  WinStationTransferThread
 ******************************************************************************/
NTSTATUS WinStationTransferThread(PVOID Parameter)
{
    PTRANSFER_INFO pInfo;
    PWINSTATION pListenWinStation;
    NTSTATUS Status;

    /*
     * Find and lock the listen WinStation
     * (We MUST do this so that it doesn't get deleted while
     *  we are attempting to transfer the new connection.)
     */
    pInfo = (PTRANSFER_INFO)Parameter;
    pListenWinStation = FindWinStationById( pInfo->LogonId, FALSE );
    if ( pListenWinStation == NULL ) {
        MemFree( pInfo );

        if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
            if (hConnectEvent != NULL)
            {
                SetEvent(hConnectEvent);
            }
        }

        return( STATUS_ACCESS_DENIED );

    }

    /*
     * Unlock the listen WinStation but hold a reference to it.
     */
    UnlockWinStation( pListenWinStation );

    /*
     * Transfer the connection to an idle WinStation
     */
    Status = TransferConnectionToIdleWinStation( pListenWinStation,
                                                  pInfo->pEndpoint,
                                                  pInfo->EndpointLength,
                                                  NULL );

    /*
     * Relock and release the listen WinStation
     */
    RelockWinStation( pListenWinStation );
    ReleaseWinStation( pListenWinStation );

    MemFree(pInfo);

    return Status;
}


NTSTATUS TransferConnectionToIdleWinStation(
        PWINSTATION pListenWinStation,
        PVOID pEndpoint,
        ULONG EndpointLength,
        PICA_STACK_ADDRESS pStackAddress)
{
    PWINSTATION pTargetWinStation = NULL;
    ULONG ReturnLength;
    BOOLEAN rc;
    BOOLEAN CreatedIdle = FALSE;
    BOOLEAN ConnectionAccepted = FALSE;
    NTSTATUS Status;
    ICA_TRACE Trace;
    LS_STATUS_CODE LlsStatus;
    NT_LS_DATA LsData;

    BOOLEAN bBlockThis;

    PWCHAR pListenName;
    PWINSTATIONCONFIG2 pConfig;
    BOOL bPolicyAllowHelp;

    BYTE in_addr[16];
    UINT uAddrSize, index;
    BOOL bSuccessAdded = FALSE;
    WINSTATIONNAME szDefaultConfigWinstationName;
    BOOL bCanCallout;

    // error code we need to pass back to client
    NTSTATUS StatusCallback = STATUS_SUCCESS;   

    // Flag to detemine if session is a RA login
    BOOL bSessionIsHelpSession;
    BOOL bValidRAConnect;
    // Flag to determine if we can Queue the winstation for Reset - used in Error paths 
    BOOL bQueueForReset = FALSE;
    BOOL bBlocked = FALSE;

    //
    // Check AllowGetHelp policy is enabled and salem has pending help session
    //
    bPolicyAllowHelp = TSIsMachinePolicyAllowHelp() & TSIsMachineInHelpMode();

    if( g_fDenyTSConnectionsPolicy && !bPolicyAllowHelp )
    {
        //
        // Close the connection if TS policy deny connection and 
        // help is disabled.
        //
        TRACE((hTrace, TC_ICASRV, TT_ERROR, 
               "TERMSRV: Denying TS connection due to GP\n"));
        if ( pListenWinStation && pEndpoint ) {
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                 pEndpoint,
                                 EndpointLength,
                                 pListenWinStation,
                                 TRUE ); // Use a temporary stack
            MemFree(pEndpoint);
            pEndpoint = NULL;

            if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
            {
                if (hConnectEvent != NULL)
                {
                    SetEvent(hConnectEvent);
                }
            }
        }
        return STATUS_CTX_WINSTATION_ACCESS_DENIED;
    }



    //
    //  check for rejected connections
    //  This includes many pending Sessions as well as sessions failing PreAuthentication
    //
    if( pListenWinStation )
    {
        uAddrSize = sizeof( in_addr );

        bSuccessAdded = Filter_AddOutstandingConnection(
                 pListenWinStation->hStack,
                 pEndpoint,
                 EndpointLength,
                 in_addr,
                 &uAddrSize,
                 &bBlockThis
                 );

        //
        //  connection blocked, close and exit
        //
        if ( bBlockThis )
        {
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                   "TERMSRV: Excessive number of pending connections\n"));

            if ( bSuccessAdded )
            {
                Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
            }
            Status = _CloseEndpoint( &pListenWinStation->Config,
                                     pEndpoint,
                                     EndpointLength,
                                     pListenWinStation,
                                     TRUE ); // Use a temporary stack
            MemFree( pEndpoint );
            pEndpoint = NULL;

            if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
            {
                if (hConnectEvent != NULL)
                {
                    SetEvent(hConnectEvent);
                }
            }
    
            return STATUS_CTX_WINSTATION_ACCESS_DENIED;
        }

        // Look to see if this connection is to be blocked because of repeated Failure of PreAuthentication
        // No PreAuthentication for now - this code will be needed later when we add PreAuthentication feature
        #if 0
        
            ENTERCRIT( &DoSLock );
            bBlocked = Filter_CheckIfBlocked( in_addr, uAddrSize ) ;
            LEAVECRIT( &DoSLock );
    
            if (bBlocked) {

                TRACE((hTrace, TC_ICASRV, TT_ERROR,
                       "TERMSRV: Excessive number of connections which failed PreAuthentication. \n"));
    
                if ( bSuccessAdded ) {
                    Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
                }
                Status = _CloseEndpoint( &pListenWinStation->Config,
                                         pEndpoint,
                                         EndpointLength,
                                         pListenWinStation,
                                         TRUE ); // Use a temporary stack
                MemFree( pEndpoint );
                pEndpoint = NULL;
    
                if( InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect ) {

                    if (hConnectEvent != NULL) {
                        SetEvent(hConnectEvent);
                    }
                }
        
                return STATUS_CTX_WINSTATION_ACCESS_DENIED;
            }

        #endif 
    }
    else
    {
        // Make sure variable 
        bBlockThis = FALSE;
        bSuccessAdded = FALSE;
    }

    //
    // 

    /*
     * Now find an idle WinStation to transfer this connection to.
     * If there is not one available, then we attempt to create one.
     * if this also fails, then we have no choice but to close
     * the connection endpoint and wait again.
     */
    pTargetWinStation = FindIdleWinStation();
    if ( pTargetWinStation == NULL ) {
        /*
         * Create another idle WinStation but do not start it as yet
         */
        Status = WinStationCreateWorker( NULL, NULL, FALSE );
        if ( NT_SUCCESS( Status ) )
            CreatedIdle = TRUE;

        pTargetWinStation = FindIdleWinStation();
        if ( pTargetWinStation == NULL ) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR, 
                   "TERMSRV: Could not get an idle WinStation!\n"));
            goto releaseresources;
        } 
    } 

    ASSERT( pTargetWinStation->Flags & WSF_IDLE );
    ASSERT( pTargetWinStation->WinStationName[0] == UNICODE_NULL );

    if ( pListenWinStation ) {
        pConfig = &(pListenWinStation->Config);
        pListenName = pListenWinStation->WinStationName;
    } else {
        //
        // For Whistler, callback is only for Salem, we can pick 
        // configuration from any listening winstation as
        // 1) All we need is HelpAssistant logon/shadow right, which
        //    is already in default.
        // 2) No listening winstation, system is either no pending help
        //    or not allow to get help, so we need to bail out.
        // 3) Additional check at the bottom to make sure login
        //    from callback is HelpAssistant only.
        //
        // If we going support this for the general case, we need
        // to take a default configuration, make connection and issue
        // a new IOCTL call into tdtcp.sys to determine NIC card/IP address 
        // that establish connection and from there, map to right winstation
        // configuration.

        //
        // Setup initial callback configuration, this is only
        // heruristic, we will reset the configuration after
        // determine which NIC is used to connect to TS client
        //
        bCanCallout = FindFirstListeningWinStationName(
                                            szDefaultConfigWinstationName,
                                            &pTargetWinStation->Config
                                        );

        if( FALSE == bCanCallout ) {
            // If no listening thread, connection is not active, don't allow
            // callback
            Status = STATUS_ACCESS_DENIED;
            // It's ok to go to releaseresources even if pConfig is not set
            // because in this case pListenWinStation and pEndpoint are NULL.
            goto releaseresources;
        }
        
        pListenName = szDefaultConfigWinstationName;
        pConfig = &(pTargetWinStation->Config);
    }

    /*
     * Check for MaxInstance
     */
    if ( !(pConfig->Pd[0].Create.PdFlag & PD_SINGLE_INST) ) {
        ULONG Count;

        Count = CountWinStationType( pListenName, FALSE, FALSE );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Count %d\n", Count ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: MaxInstanceCount %d\n",
                pConfig->Create.MaxInstanceCount));

        if ( pConfig->Create.MaxInstanceCount <= Count ) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR, 
                   "TERMSRV: Exceeded maximum instance count [%ld >= %ld]\n",
                   Count, pConfig->Create.MaxInstanceCount));
            goto releaseresources;
        }
    }

    /*
     * Copy the listen name to the target WinStation.
     * This is done to enable tracing on the new stack.
     *
     * Also, this is done BEFORE the connection accept so that if the
     * listen WinStation is reset before the accept completes, the
     * target WinStation will also be reset.
     */
    RtlCopyMemory( pTargetWinStation->ListenName,
                   pListenName,
                   sizeof(pTargetWinStation->ListenName) );

    /*
     *  Enable trace
     */
    
    RtlZeroMemory( &Trace , sizeof( ICA_TRACE ) );
    InitializeTrace( pTargetWinStation, FALSE, &Trace );

    /*
     *  Hook extensions for this target
     */
    pTargetWinStation->pWsx = FindWinStationExtensionDll(
            pConfig->Wd.WsxDLL,
            pConfig->Wd.WdFlag );

    /*
     *  Initialize winstation extension context structure
     */
    if (pTargetWinStation->pWsx &&
            pTargetWinStation->pWsx->pWsxWinStationInitialize) {
        Status = pTargetWinStation->pWsx->pWsxWinStationInitialize(
                &pTargetWinStation->pWsxContext);
        if (Status != STATUS_SUCCESS) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                   "TERMSRV: WsxWinStationInitialize failed [%lx]\n",
                   Status));
            goto badconnect;
        }
    }

    /*
     * Terminate Listen stack of single-instance transports now, so that
     * the underlying CancelIo doesn't disturb the Accept stack.
     */
    // this one can prevent from generalizing efficiently the transfer function
    if (pListenWinStation && (pListenWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST)) {
        IcaStackTerminate(pListenWinStation->hStack);
    }

    /*
     * Change state to ConnectQuery while we try to accept the connection
     */
    pTargetWinStation->State = State_ConnectQuery;
    NotifySystemEvent(WEVENT_STATECHANGE);

    /*
     * Since the ConnectionAccept may take a while, we have to unlock
     * the target WinStation before the call.  However, we set the
     * WSF_IDLEBUSY flag so that the WinStation does not appear idle.
     */
    pTargetWinStation->Flags |= WSF_IDLEBUSY;
    UnlockWinStation( pTargetWinStation );


    if ( !pListenWinStation && pStackAddress) {

        // must have extension DLL loaded
        if( !pTargetWinStation->pWsx || !pTargetWinStation->pWsx->pWsxIcaStackIoControl ) {
            Status = STATUS_UNSUCCESSFUL;
            goto badconnect;
        }

        //
        // Allocate an endpoint buffer
        //
        EndpointLength = MODULE_SIZE;
        pEndpoint = MemAlloc( MODULE_SIZE );
        if ( !pEndpoint ) {
            Status = STATUS_NO_MEMORY;
            goto badconnect;
        }

        Status = IcaStackConnectionRequest( pTargetWinStation->hStack,
                                         pTargetWinStation->ListenName,
                                         pConfig,
                                         pStackAddress,
                                         pEndpoint,
                                         EndpointLength,
                                         &ReturnLength );

        if ( Status == STATUS_BUFFER_TOO_SMALL ) {
            MemFree( pEndpoint );
            pEndpoint = MemAlloc( ReturnLength );
            if ( !pEndpoint ) {
                Status = STATUS_NO_MEMORY;
                goto badconnect;
            }
            EndpointLength = ReturnLength;

            Status = IcaStackConnectionRequest( pTargetWinStation->hStack,
                                                pTargetWinStation->ListenName,
                                                pConfig,
                                                pStackAddress,
                                                pEndpoint,
                                                EndpointLength,
                                                &ReturnLength );
        }

        if ( !NT_SUCCESS(Status) ) {
            // special error code to pass back to client
            StatusCallback = Status;
            goto badconnect;
        }

    }

    /*
     * Now accept the connection for the target WinStation
     * using the new endpoint.
     */
    Status = IcaStackConnectionAccept(pTargetWinStation->hIca,
                                      pTargetWinStation->hStack,
                                      pListenName,
                                      pConfig,
                                      pEndpoint,
                                      EndpointLength,
                                      NULL,
                                      0,
                                      &Trace);

    ConnectionAccepted = (Status == STATUS_SUCCESS);

    TRACE((hTrace,TC_ICASRV,TT_API1,
            "TERMSRV: IcaStackConnectionAccept, Status=0x%x\n", Status));

    if (NT_SUCCESS(Status)) {
        // In post-logon SD work, quering load balancing info has been moved
        // to WinStationNotifyLogonWorker
        // while this part of getting load balancing info is still here
        // because we rely on it to connect to the console
        TS_LOAD_BALANCE_INFO LBInfo;
        ULONG ReturnLength;
        
        // Get the client load balance capability info. 
        // Note we use _IcaStackIoControl() instead of IcaStackIoControl() or
        // WsxIcaStackIoControl() since we still have the stack lock.
        memset(&LBInfo, 0, sizeof(LBInfo));
        Status = _IcaStackIoControl(pTargetWinStation->hStack,
                IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                NULL, 0,
                &LBInfo, sizeof(LBInfo),
                &ReturnLength);

        // On non-success, we'll have FALSE for all of our entries, on
        // success valid values. So, save off the cluster info into the
        // WinStation struct now.
        pTargetWinStation->bClientSupportsRedirection =
                LBInfo.bClientSupportsRedirection;
        pTargetWinStation->bRequestedSessionIDFieldValid =
                LBInfo.bRequestedSessionIDFieldValid;
        pTargetWinStation->bClientRequireServerAddr =
                LBInfo.bClientRequireServerAddr;
        pTargetWinStation->RequestedSessionID = LBInfo.RequestedSessionID;


        /*
         * Attempt to license the client. Failure is fatal, do not let the
         * connection continue.
         */

        LCAssignPolicy(pTargetWinStation);

        Status = LCProcessConnectionProtocol(pTargetWinStation);

        TRACE((hTrace,TC_ICASRV,TT_API1,
                "TERMSRV: LCProcessConnectionProtocol, LogonId=%d, Status=0x%x\n",
                pTargetWinStation->LogonId, Status));

         // The stack was locked from successful IcaStackConnectionAccept(),
         // unlock it now.
        IcaStackUnlock(pTargetWinStation->hStack);
    }

    /*
     * Now relock the target WinStation
     */
    rc = RelockWinStation(pTargetWinStation);

    /*
     * If the connection accept was not successful,
     * then we have no choice but to close the connection endpoint
     * and go back and wait for another connection.
     */
    if (!NT_SUCCESS(Status) || !rc) {
        TRACE((hTrace, TC_ICASRV, TT_ERROR,
                "TERMSRV: Connection attempt failed, Status [%lx], rc [%lx]\n",
                Status, rc));
        goto badconnect;
    }

    /*
     *  Initialize client data
     */
    pTargetWinStation->Client.ClientSessionId = LOGONID_NONE;
    ZeroMemory( pTargetWinStation->Client.clientDigProductId, sizeof( pTargetWinStation->Client.clientDigProductId ));
    pTargetWinStation->Client.PerformanceFlags = TS_PERF_DISABLE_NOTHING;

    // Reset the client ActiveInputLocale info
    pTargetWinStation->Client.ActiveInputLocale = 0;

    if ( pTargetWinStation->pWsx && pTargetWinStation->pWsx->pWsxIcaStackIoControl ) {
        (void) pTargetWinStation->pWsx->pWsxIcaStackIoControl(
                              pTargetWinStation->pWsxContext,
                              pTargetWinStation->hIca,
                              pTargetWinStation->hStack,
                              IOCTL_ICA_STACK_QUERY_CLIENT,
                              NULL,
                              0,
                              &pTargetWinStation->Client,
                              sizeof(pTargetWinStation->Client),
                              &ReturnLength );
    }

    //
    // Clear helpassistant specific bits to indicate we still not sure
    // login user is a help assistant
    //
    pTargetWinStation->StateFlags &= ~WSF_ST_HELPSESSION_FLAGS;
    bSessionIsHelpSession = TSIsSessionHelpSession( pTargetWinStation, &bValidRAConnect );

    /*
     * We have to start this new WinStation.
     * Before doing so, lets see if GP or WMI requires us to pre-authenticate this client connection
     * No Pre Auth if this is a RA Session
     */

    // Note : g_PreAuthenticateClient is hard-coded to FALSE now -- we will call IsPreAuthEnabled later on when Preauth feature is included
    //        So the block below will not be entered for now 
    // g_PreAuthenticateClient = IsPreAuthEnabled( &g_MachinePolicy   );

    if ( (bSessionIsHelpSession == FALSE) && g_PreAuthenticateClient ) {

        pExtendedClientCredentials pPreAuthenticationCredentials = NULL; 
        ULONG BytesGot ; 

        pPreAuthenticationCredentials = MemAlloc( sizeof(ExtendedClientCredentials) ); 
        if ( pPreAuthenticationCredentials == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto badconnect;
        }
        
        RtlZeroMemory(pPreAuthenticationCredentials,sizeof(ExtendedClientCredentials));

        // Try WsxEscape first to get long credentials
        if ( pTargetWinStation->pWsx &&
             pTargetWinStation->pWsx->pWsxEscape ) { 

            Status = pTargetWinStation->pWsx->pWsxEscape( pTargetWinStation->pWsxContext,
                                                        GET_LONG_USERNAME,
                                                        NULL,
                                                        0,
                                                        pPreAuthenticationCredentials,
                                                        sizeof(ExtendedClientCredentials),
                                                        &BytesGot) ; 

        } else if ( pTargetWinStation->pWsx && pTargetWinStation->pWsx->pWsxIcaStackIoControl ) {

            // We must never be here for RDP client as we support WsxEscape
            RtlCopyMemory(pPreAuthenticationCredentials->Domain, pTargetWinStation->Client.Domain, sizeof(pTargetWinStation->Client.Domain));
            RtlCopyMemory(pPreAuthenticationCredentials->UserName, pTargetWinStation->Client.UserName, sizeof(pTargetWinStation->Client.UserName));
            RtlCopyMemory(pPreAuthenticationCredentials->Password, pTargetWinStation->Client.Password, sizeof(pTargetWinStation->Client.Password));
        }
        
        if (!NT_SUCCESS(Status)) {
            // WsxEscape for GET_LONG_USERNAME failed
            RtlSecureZeroMemory(pPreAuthenticationCredentials->Password, 
                sizeof(pPreAuthenticationCredentials->Password));
            MemFree(pPreAuthenticationCredentials);
            pPreAuthenticationCredentials = NULL;
            goto badconnect;
        } else {
            HANDLE hToken;
            BOOL   Result;

            // If the UserName is a UPN name, then explicitly set the Domain name to NULL 

            if ( wcschr(pPreAuthenticationCredentials->UserName, '@') != NULL ) {
                pPreAuthenticationCredentials->Domain[0] = L'\0';
            } 

            // If the password is bigger than max allowed password len, make it NULL

            if (wcslen(pPreAuthenticationCredentials->Password) > MAX_ALLOWED_PASSWORD_LEN) {
                pPreAuthenticationCredentials->Password[0] = L'\0';
            }

            Result = LogonUser(
                         pPreAuthenticationCredentials->UserName,
                         pPreAuthenticationCredentials->Domain,
                         pPreAuthenticationCredentials->Password,
                         LOGON32_LOGON_INTERACTIVE,     // Logon Type
                         LOGON32_PROVIDER_WINNT50,      // Logon Provider
                         &hToken                    // Token that represents the account
                         );
            
            RtlSecureZeroMemory(pPreAuthenticationCredentials->Password, 
                sizeof(pPreAuthenticationCredentials->Password));
            /*
             *  check for account restriction which indicates a blank password
             *  on the account that is correct though - allow this thru on console
             */

            if ( (!Result) && (GetLastError() == ERROR_ACCOUNT_RESTRICTION) ) {
                Result = TRUE;
            }

            if( !Result) {
                BOOL bSuccessfulAdded = TRUE ; 

                if (g_BlackListPolicy) {
                    bSuccessfulAdded = Filter_AddFailedConnection( in_addr, uAddrSize );
                }

                MemFree(pPreAuthenticationCredentials);
                pPreAuthenticationCredentials = NULL;
                goto badconnect;
            }

            // LogonUser Successful !

            /*
             * Close the token handle since we only needed to determine
             * if the account and password is still valid.
             */
            CloseHandle( hToken );
            MemFree(pPreAuthenticationCredentials);
            pPreAuthenticationCredentials = NULL;
        }

    } // if (bPreAuthenticateClient) 
    
    //Since we don't need the password anymore, clean it up
    RtlSecureZeroMemory(pTargetWinStation->Client.Password, 
        sizeof(pTargetWinStation->Client.Password));

    // Start the WinStation now if its not already started

    if ( (pTargetWinStation->InitialCommandProcess == NULL) && (pTargetWinStation->WindowsSubSysProcess == NULL) ) {
        Status = WinStationStart( pTargetWinStation ) ; 
        if (Status != STATUS_SUCCESS) {
            // Starting the winstation failed - close connection endpoint and go and wait for another connection
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: TransferConnectionToIdleWinStation: WinstationStart Failed : Connection attempt failed, Status [%lx]\n",Status ));
            goto badconnect;
        }

        Status = WinStationCreateComplete( pTargetWinStation) ; 
        if (Status != STATUS_SUCCESS) {
            //  WinstationCreateComplete failed - close connection endpoint and go and wait for another connection
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: TransferConnectionToIdleWinStation: WinstationCreateComplete Failed : Connection attempt failed, Status [%lx]\n",Status ));
            goto badconnect;

        } 
    } 

    ASSERT( pTargetWinStation->LogonId != -1 );

    pTargetWinStation->Flags &= ~WSF_IDLEBUSY;

    // From this point on, it is ok to Queue the WinStation for Reset in case of error
    bQueueForReset = TRUE;

    /*
     * The connection accept was successful, save the
     * new endpoint in the target WinStation, copy the config
     * parameters to the target WinStation, and reset the WSF_IDLE flag.
     */
    pTargetWinStation->pEndpoint      = pEndpoint;
    pTargetWinStation->EndpointLength = EndpointLength;
    if ( pListenWinStation ) 
        pTargetWinStation->Config = pListenWinStation->Config;
    pTargetWinStation->Flags &= ~WSF_IDLE;

    /*
     * Copy real name of Single-Instance transports
     */
    if ( pConfig->Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
         RtlCopyMemory( pTargetWinStation->WinStationName,
                       pTargetWinStation->ListenName,
                       sizeof(pTargetWinStation->WinStationName) );
    /*
     * Otherwise, build dynamic name from Listen name and target LogonId.
     */
    } else {
        int CopyCount;
        WINSTATIONNAME TempName;

//        swprintf( TempName, L"#%d", pTargetWinStation->LogonId );
        ASSERT(pTargetWinStation->LogonId > 0 && pTargetWinStation->LogonId < 65536);
        swprintf( TempName, L"#%d", pTargetWinStation->SessionSerialNumber );


        CopyCount = min( wcslen( pTargetWinStation->ListenName ),
                         sizeof( pTargetWinStation->WinStationName ) /
                            sizeof( pTargetWinStation->WinStationName[0] ) -
                                wcslen( TempName ) - 1 );
        wcsncpy( pTargetWinStation->WinStationName,
                 pTargetWinStation->ListenName,
                 CopyCount );
        wcscpy( &pTargetWinStation->WinStationName[CopyCount], TempName );
    }

    /*
     * Inherit the security descriptor from the listen WINSTATION to the
     * connected WINSTATION.
     */
    if ( pListenWinStation ) {
        RtlAcquireResourceShared(&WinStationSecurityLock, TRUE);
        Status = WinStationInheritSecurityDescriptor( pListenWinStation->pSecurityDescriptor,
                                             pTargetWinStation );
        RtlReleaseResource(&WinStationSecurityLock);
        if (Status != STATUS_SUCCESS) {
            // badconnect free pEndpoint, WinStationTerminate() will try to free this
            // end point again causing double free.
            pTargetWinStation->pEndpoint = NULL;
            goto badconnect;
        }
    } else {
        ReadWinStationSecurityDescriptor( pTargetWinStation );
    }
    //
    // For non-experience-aware clients give as close an experience
    // as win2k.
    //
    if (pTargetWinStation->Client.PerformanceFlags & TS_PERF_DEFAULT_NONPERFCLIENT_SETTING)
    {
        pTargetWinStation->Client.PerformanceFlags = TS_PERF_DISABLE_MENUANIMATIONS |
                                                     TS_PERF_DISABLE_THEMING |
                                                     TS_PERF_DISABLE_CURSOR_SHADOW;
    }

    if ( pTargetWinStation->Config.Config.User.fWallPaperDisabled )
    {
        pTargetWinStation->Client.PerformanceFlags |= TS_PERF_DISABLE_WALLPAPER;
    }

    if ( pTargetWinStation->Config.Config.User.fCursorBlinkDisabled )
    {
        pTargetWinStation->Client.PerformanceFlags |= TS_PERF_DISABLE_CURSORSETTINGS;
    }
    //
    // If TS policy denies connection, only way to comes to 
    // here is policy allow help, reject connection if logon
    // user is not salem help assistant.
    //
    if( TRUE == bSessionIsHelpSession )
    {
        //
        // If invalid ticket or policy deny help, we immediately disconnect
        //
        if( FALSE == bValidRAConnect || FALSE == bPolicyAllowHelp )
        {
            // Invalid ticket, disconnect immediately
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: Invalid RA login\n"));
            goto invalid_ra_connection;
        }
    }
    else if( !pListenWinStation && pStackAddress )
    {
        // 
        // Reverse Connect, parameter passed in pListenWinStation = NULL
        // and pStackAddress is not NULL, for normal connection,
        // pListenWinStation is not NULL but pStackAddress is NULL
        //

        //
        // Handle non-RA Reverse connection, Whistler revert connection
        // only allow RA login.
        //
        TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: Not/invalid Help Assistant logon\n"));
        goto invalid_ra_connection;
    }

    //
    // Connecting client must be either non-RA or valid RA connection.
    //

    //
    // Handle Safeboot with networking and TS deny non-RA connection,
    // safeboot with networking only allow RA connection.
    //
    // Disconnect client on following 
    //
    // 1) Safeboot with networking if not RA connect.
    // 2) Reverse connection if not RA connect.
    // 3) TS not accepting connection via policy setting if not RA connect.
    // 4) Not allowing help if RA connect.
    // 5) Invalid RA connection if RA connect.
    // 6) if Home edition and not RA commection
    //
    if( g_SafeBootWithNetwork || g_fDenyTSConnectionsPolicy || g_bPersonalWks)
    {
        if( FALSE == bSessionIsHelpSession )
        {
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: Policy or safeboot denied connection\n"));

            goto invalid_ra_connection;
        }
    }

    //
    // Only log Salem event for reverse connection
    //
    if( !pListenWinStation && pStackAddress )
    {
        ASSERT( TRUE == bSessionIsHelpSession );
        TSLogSalemReverseConnection(pTargetWinStation, pStackAddress);
    }


    /*
     * Set the connect event to wake up the target WinStation.
     */
    if (pTargetWinStation->ConnectEvent != NULL) {
        NtSetEvent( pTargetWinStation->ConnectEvent, NULL );
    }

    /*
     * Release target WinStation
     */

    if( pListenWinStation  )
    {

        if (bSuccessAdded) {  // If we could add this IP address to the per IP list then remember it.
            PREMEMBERED_CLIENT_ADDRESS pAddress;
            if ((uAddrSize != 0) && (pAddress = (PREMEMBERED_CLIENT_ADDRESS) MemAlloc( sizeof(REMEMBERED_CLIENT_ADDRESS) + uAddrSize -1 ))!= NULL  )
            {
                pAddress->length = uAddrSize;
                RtlCopyMemory( &pAddress->addr[0] , in_addr,uAddrSize );
                pTargetWinStation->pRememberedAddress = pAddress;

                // at this point we have a valid remote address. We'll cache this address.

                pTargetWinStation->pLastClientAddress = ( PREMEMBERED_CLIENT_ADDRESS )MemAlloc( sizeof( REMEMBERED_CLIENT_ADDRESS ) + uAddrSize - 1 );

                if( pTargetWinStation->pLastClientAddress != NULL )
                {
                    RtlCopyMemory( &pTargetWinStation->pLastClientAddress->addr[0] ,
                        &pTargetWinStation->pRememberedAddress->addr[0] ,
                        uAddrSize );

                    pTargetWinStation->pLastClientAddress->length = uAddrSize;

                }

            } else {
                Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
                if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
                {
                   if (hConnectEvent != NULL)
                   {
                       SetEvent(hConnectEvent);
                   }
                }

            }
        } else{ // We could not add this IP address to the pr IP list
            if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
            {
               if (hConnectEvent != NULL)
               {
                   SetEvent(hConnectEvent);
               }
            }
        }


    }


    ReleaseWinStation( pTargetWinStation );

    /*
     * If necessary, create another idle WinStation to replace the one being connected
     */
    NtSetEvent(WinStationIdleControlEvent, NULL);

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/
    
invalid_ra_connection:

    // badconnect free pEndpoint, WinStationTerminate() will try to free this
    // end point again causing double free.
    pTargetWinStation->pEndpoint = NULL;
    StatusCallback = STATUS_CTX_WINSTATION_ACCESS_DENIED;

    /*
     * Error during ConnectionAccept
     */
badconnect:
    /*
     * Clear the Listen name
     */
    if (pTargetWinStation) {
        RtlZeroMemory( pTargetWinStation->ListenName,
                       sizeof(pTargetWinStation->ListenName) );
    
        /*
         * Call WinStation rundown function before killing the stack
         */
        if (pTargetWinStation->pWsxContext) {
            if ( pTargetWinStation->pWsx &&
                 pTargetWinStation->pWsx->pWsxWinStationRundown ) {
                pTargetWinStation->pWsx->pWsxWinStationRundown( pTargetWinStation->pWsxContext );
            }
            pTargetWinStation->pWsxContext = NULL;
        }
        pTargetWinStation->pWsx = NULL;
    }


    /*
     * Release system resources.  This happens in two phases:
     *
     *  a.) The connection endpoint - since endpoints are not reference counted
     *      care must be taken to destroy the endpoint with the stack in which it
     *      was loaded.  In the event it was not loaded, we create a temporary
     *      stack to do the dirty work.
     *
     *  b.) The Winstation inself - if we had to create an idle winstation to
     *      handle this connection, it is destroyed.  Otherwise we just return
     *      it back to the idle pool.
     *
     */
releaseresources:
    
    /*
     * If we created a target WinStation, then use its stack to close the
     * endpoint since the stack may have a reference to it.
     */
    TRACE((hTrace, TC_ICASRV, TT_ERROR, 
           "TERMSRV: Closing Endpoint [0x%p], winsta = 0x%p, Accepted = %ld\n",
           pEndpoint, pTargetWinStation, ConnectionAccepted));

    if ((pTargetWinStation != NULL) && (ConnectionAccepted)) {
        Status = _CloseEndpoint( pConfig,
                                 pEndpoint,
                                 EndpointLength,
                                 pTargetWinStation,
                                 FALSE ); // Use the stack which already has
                                          // the endpoint loaded
    }

    /*
     * Otherwise, we failed before we got the endpoint loaded so close the
     * endpoint using a temporary stack.
     */
    else if ( pListenWinStation ) {
        // note that:
        // 1. if pListenWinStation is NULL then pEndpoint is NULL, so nothing to close;
        // 2. use the config of pListenWinStation in case pConfig is not set yet.
        Status = _CloseEndpoint( &pListenWinStation->Config,
                                 pEndpoint,
                                 EndpointLength,
                                 pListenWinStation,
                                 TRUE ); // Use a temporary stack
    }    

    if ( pEndpoint )
        MemFree( pEndpoint );

    pEndpoint = NULL;


    /*
     * Return the winstation if we got that far in the protocol sequence
     */
    if (pTargetWinStation != NULL) {
        
        /*
         * If we created a WinStation above because there were no IDLE
         * WinStations available, then we will now have an extra IDLE
         * WinStation.  In this case, reset the current IDLE WinStation.
         */
        if ( CreatedIdle ) {
            // clear this so it doesn't get selected as idle when unlocked
            pTargetWinStation->Flags &= ~WSF_IDLE;
            if ( bQueueForReset == TRUE ) {
                QueueWinStationReset( pTargetWinStation->LogonId );
                ReleaseWinStation( pTargetWinStation );
            } else {
                if ( !(pTargetWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {
                    pTargetWinStation->Flags |= WSF_DELETE;
                    WinStationTerminate( pTargetWinStation );
                    pTargetWinStation->State = State_Down;
                    //PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, Status);
                    WinStationDeleteWorker(pTargetWinStation);
                } else {
                    ReleaseWinStation(pTargetWinStation);
                }
            }
        }
    
        /*
         * Else return this WinStation to the idle pool after cleaning up the
         * stack.
         */
        else {

            //
            //  The licensing context needs to be freed and recreated to
            //  ensure it is cleaned up properly.
            //

            LCDestroyContext(pTargetWinStation);

            Status = LCCreateContext(pTargetWinStation);

            if (NT_SUCCESS(Status))
            {
                Status = IcaStackClose( pTargetWinStation->hStack );
                ASSERT( NT_SUCCESS( Status ) );
                pTargetWinStation->hStack = NULL;
                Status = IcaStackOpen( pTargetWinStation->hIca,
                                   Stack_Primary,
                                   (PROC)WsxStackIoControl,
                                   pTargetWinStation,
                                   &pTargetWinStation->hStack );
            }

            if (NT_SUCCESS(Status)) {
                pTargetWinStation->Flags |= WSF_IDLE;
                pTargetWinStation->Flags &= ~WSF_IDLEBUSY;
                RtlZeroMemory(pTargetWinStation->WinStationName, sizeof(pTargetWinStation->WinStationName));
                pTargetWinStation->State = State_Idle;
                NotifySystemEvent( WEVENT_STATECHANGE );
                ReleaseWinStation( pTargetWinStation );
            } else {
                pTargetWinStation->Flags &= ~WSF_IDLE;
                QueueWinStationReset( pTargetWinStation->LogonId);
                ReleaseWinStation( pTargetWinStation );
            }
        }
    }


    if ( pListenWinStation  )
    {

        if (bSuccessAdded) {
            Filter_RemoveOutstandingConnection( in_addr, uAddrSize );
        }
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
            if (hConnectEvent != NULL)
            {
                SetEvent(hConnectEvent);
            }
        }

    }

    // If error is due to call back, return meaningful error 
    // code.
    if( STATUS_SUCCESS != StatusCallback )
    {
        return StatusCallback;
    }

    return -1 /*STATUS_CTX_UNACCEPTED_CONNECTION*/;
}


/*******************************************************************************
 *  ConnectSmWinStationApiPort
 *
 *   Open a connection to the WinStationApiPort.  This will be used
 *   to queue requests to the Api Request thread instead of processing
 *   them in line.
 ******************************************************************************/
NTSTATUS ConnectSmWinStationApiPort()
{
    UNICODE_STRING PortName;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;
    WINSTATIONAPI_CONNECT_INFO info;
    ULONG ConnectInfoLength;
    NTSTATUS Status;

    /*
     * Set up the security quality of service parameters to use over the
     * port.  Use the most efficient (least overhead) - which is dynamic
     * rather than static tracking.
     */
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    RtlInitUnicodeString( &PortName, L"\\SmSsWinStationApiPort" );

    // Fill in the ConnectInfo structure with our access request mask
    info.Version = CITRIX_WINSTATIONAPI_VERSION;
    info.RequestedAccess = 0;
    ConnectInfoLength = sizeof(WINSTATIONAPI_CONNECT_INFO);

    Status = NtConnectPort( &WinStationApiPort,
                            &PortName,
                            &DynamicQos,
                            NULL,
                            NULL,
                            NULL, // Max message length [select default]
                            (PVOID)&info,
                            &ConnectInfoLength );

    if ( !NT_SUCCESS( Status ) ) {
        // Look at the returned INFO to see why if desired
        if ( ConnectInfoLength == sizeof(WINSTATIONAPI_CONNECT_INFO) ) {
            DBGPRINT(( "TERMSRV: Sm connect failed, Reason 0x%x\n",
                      info.AcceptStatus));
        }
        DBGPRINT(( "TERMSRV: Connect to SM failed %lx\n", Status ));
    }

    return Status;
}


/*******************************************************************************
 *  QueueWinStationCreate
 *
 *   Send a create message to the WinStationApiPort.
 *
 * ENTRY:
 *    pWinStationName (input)
 *       Pointer to WinStationName to be created
 ******************************************************************************/
NTSTATUS QueueWinStationCreate(PWINSTATIONNAME pWinStationName)
{
    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: QueueWinStationCreate: %S\n", pWinStationName ));

    /*
     * Initialize msg
     */
    msg.h.u1.s1.DataLength = sizeof(msg) - sizeof(PORT_MESSAGE);
    msg.h.u1.s1.TotalLength = sizeof(msg);
    msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    msg.h.u2.s2.DataInfoOffset = 0;
    msg.ApiNumber = SMWinStationCreate;
    msg.WaitForReply = FALSE;
    if ( pWinStationName ) {
        RtlCopyMemory( msg.u.Create.WinStationName, pWinStationName,
                       sizeof(msg.u.Create.WinStationName) );
    } else {
        RtlZeroMemory( msg.u.Create.WinStationName,
                       sizeof(msg.u.Create.WinStationName) );
    }

    /*
     * Send create message to our API request thread
     * but don't wait for a reply.
     */
    Status = NtRequestPort( WinStationApiPort, (PPORT_MESSAGE) &msg );
    ASSERT( NT_SUCCESS( Status ) );

    return Status;
}


/*******************************************************************************
 *  QueueWinStationReset
 *
 *   Send a reset message to the WinStationApiPort.
 *
 * ENTRY:
 *    LogonId (input)
 *       LogonId of WinStationName to reset
 ******************************************************************************/
NTSTATUS QueueWinStationReset(ULONG LogonId)
{

    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: QueueWinStationReset: %u\n", LogonId ));

    /*
     * Initialize msg
     */
    msg.h.u1.s1.DataLength = sizeof(msg) - sizeof(PORT_MESSAGE);
    msg.h.u1.s1.TotalLength = sizeof(msg);
    msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    msg.h.u2.s2.DataInfoOffset = 0;
    msg.ApiNumber = SMWinStationReset;
    msg.WaitForReply = FALSE;
    msg.u.Reset.LogonId = LogonId;

    /*
     * Send reset message to our API request thread
     * but don't wait for a reply.
     */
    Status = NtRequestPort( WinStationApiPort, (PPORT_MESSAGE) &msg );
    ASSERT( NT_SUCCESS( Status ) );

    return( Status );
}


/*******************************************************************************
 *  QueueWinStationDisconnect
 *
 *   Send a disconnect message to the WinStationApiPort.
 *
 * ENTRY:
 *    LogonId (input)
 *       LogonId of WinStationName to disconnect
 ******************************************************************************/
NTSTATUS QueueWinStationDisconnect(ULONG LogonId)
{
    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: QueueWinStationDisconnect: %u\n", LogonId ));

    /*
     * Initialize msg
     */
    msg.h.u1.s1.DataLength = sizeof(msg) - sizeof(PORT_MESSAGE);
    msg.h.u1.s1.TotalLength = sizeof(msg);
    msg.h.u2.s2.Type = 0; // Kernel will fill in message type
    msg.h.u2.s2.DataInfoOffset = 0;
    msg.ApiNumber = SMWinStationDisconnect;
    msg.WaitForReply = FALSE;
    msg.u.Reset.LogonId = LogonId;

    /*
     * Send disconnect message to our API request thread
     * but don't wait for a reply.
     */
    Status = NtRequestPort( WinStationApiPort, (PPORT_MESSAGE) &msg );
    ASSERT( NT_SUCCESS( Status ) );

    return( Status );
}


/*******************************************************************************
 *  IcaRegWinStationEnumerate
 *
 *   Enumerate all WinStations configured in the registry.
 *
 * ENTRY:
 *    pWinStationCount (input/output)
 *       count of WinStation names to return, on return the number of
 *       WinStation names actually returned in name buffer
 *    pWinStationName (output)
 *       pointer to buffer to return WinStation names
 *    pByteCount (input/output)
 *       size of WinStation name buffer, on return the number of
 *       bytes actually returned in the name buffer
 ******************************************************************************/
NTSTATUS IcaRegWinStationEnumerate(
        PULONG pWinStationCount,
        PWINSTATIONNAME pWinStationName,
        PULONG pByteCount)
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR PathBuffer[ 260 ];
    UNICODE_STRING KeyPath;
    HANDLE Handle;
    ULONG i;
    ULONG Count;

    wcscpy( PathBuffer, REG_NTAPI_CONTROL_TSERVER L"\\" REG_WINSTATIONS );
    RtlInitUnicodeString( &KeyPath, PathBuffer );

    InitializeObjectAttributes( &ObjectAttributes, &KeyPath,
                                OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey( &Handle, GENERIC_READ, &ObjectAttributes );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: NtOpenKey failed, rc=%x\n", Status ));
        return( Status );
    }

    Count = pWinStationName ?
            min( *pByteCount / sizeof(WINSTATIONNAME), *pWinStationCount ) :
            (ULONG) -1;
    *pWinStationCount = *pByteCount = 0;
    for ( i = 0; i < Count; i++ ) {
        WINSTATIONNAME WinStationName;
        UNICODE_STRING WinStationString;

        WinStationString.Length = 0;
        WinStationString.MaximumLength = sizeof(WinStationName);
        WinStationString.Buffer = WinStationName;
        Status = RtlpNtEnumerateSubKey( Handle, &WinStationString, i, NULL );
        if ( !NT_SUCCESS( Status ) ) {
            if ( Status != STATUS_NO_MORE_ENTRIES ) {
                DBGPRINT(( "TERMSRV: RtlpNtEnumerateSubKey failed, rc=%x\n", Status ));
            }
            break;
        }
        if ( pWinStationName ) {
            RtlCopyMemory( pWinStationName, WinStationName,
                           WinStationString.Length );
            pWinStationName[WinStationString.Length>>1] = UNICODE_NULL;
            (char*)pWinStationName += sizeof(WINSTATIONNAME);
        }
        (*pWinStationCount)++;
        *pByteCount += sizeof(WINSTATIONNAME);
    }

    NtClose( Handle );

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  WinStationCreateWorker
 *
 *   Worker routine to create/start a WinStation.
 *
 * ENTRY:
 *    pWinStationName (input) (optional)
 *       Pointer to WinStationName to be created
 *    pLogonId (output)
 *       location to return LogonId of new WinStation
 *    fStartWinStation (input)
 *       Tells if we need to Start the winstation after creating it 
 *
 *    NOTE: If a WinStation name is specified, then this will become the
 *          "listening" WinStation for the specified name.
 *          If a WinStation name is not specified, then this will become
 *          part of the free pool of idle/disconnected WinStations.
 ******************************************************************************/
NTSTATUS WinStationCreateWorker(
        PWINSTATIONNAME pWinStationName,
        PULONG pLogonId,
        BOOLEAN fStartWinStation
        ) 
{
    BOOL fConsole;
    PWINSTATION pWinStation = NULL;
    PWINSTATION pCurWinStation;
    NTSTATUS Status;
    UNICODE_STRING WinStationString;
    ULONG ReturnLength;
    
    /*
     * If system shutdown is in progress, then don't allow create
     */
    if ( ShutdownInProgress ) {
        Status = STATUS_ACCESS_DENIED;
        goto shutdown;
    }

    if (pWinStationName == NULL)
    {
        fConsole = FALSE;
    }
    else
    {
        fConsole = (_wcsicmp(pWinStationName, L"Console") == 0);
    }

    /*
     * If not the Console, then verify the WinStation name is defined
     * in the registry and that it is enabled.
     */
    if ( pWinStationName && !fConsole ) {
        Status = CheckWinStationEnable( pWinStationName );
        if ( Status != STATUS_SUCCESS ) {
            DBGPRINT(( "TERMSRV: WinStation '%ws' is disabled\n", pWinStationName ));
            goto disabled;
        }
    }

    /*
     * Allocate and initialize WinStation struct
     */
    if ( (pWinStation = MemAlloc( sizeof(WINSTATION) )) == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto nomem;
    }
    RtlZeroMemory( pWinStation, sizeof(WINSTATION) );
    pWinStation->Starting = TRUE;
    pWinStation->NeverConnected = TRUE;
    pWinStation->State = State_Init;
    pWinStation->pNewNotificationCredentials = NULL;
    pWinStation->fReconnectPending = FALSE;
    pWinStation->fReconnectingToConsole = FALSE;
    pWinStation->LastReconnectType = NeverReconnected;
    pWinStation->fDisallowAutoReconnect = FALSE;
    pWinStation->fSmartCardLogon = FALSE;
    pWinStation->fSDRedirectedSmartCardLogon = FALSE;
    memset( pWinStation->ExecSrvSystemPipe, 0, EXECSRVPIPENAMELEN*sizeof(WCHAR) );


    // Create the Session Initialized event which will be set when Winlogon calls after creating a Desktop
    pWinStation->SessionInitializedEvent = CreateEvent(NULL, 
                                                       TRUE,    // Manual Reset
                                                       FALSE,   // Initial State is non signaled
                                                       NULL);

    if (pWinStation->SessionInitializedEvent == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto nomem;
    }

    InitializeListHead( &pWinStation->ShadowHead );
    InitializeListHead( &pWinStation->Win32CommandHead );

    // Create the licensing context
    Status = LCCreateContext(pWinStation);
    if ( !NT_SUCCESS( Status ) )
        goto nolicensecontext;


    // Create and lock winstation mutex
    Status = InitRefLock( &pWinStation->Lock, WinStationDeleteProc );
    if ( !NT_SUCCESS( Status ) )
        goto nolock;

    /*
     * If a WinStation name was specified, see if it already exists
     * (on return, WinStationListLock will be locked).
     */
    if ( pWinStationName ) {
        if ( pCurWinStation = FindWinStationByName( pWinStationName, TRUE ) ) {
            ReleaseWinStation( pCurWinStation );
            LEAVECRIT( &WinStationListLock );
            Status = STATUS_CTX_WINSTATION_NAME_COLLISION;
            goto alreadyexists;
        }

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Creating WinStation %ws\n", pWinStationName ));
        LEAVECRIT( &WinStationListLock );
        wcscpy( pWinStation->WinStationName, pWinStationName );

        /*
         * If not the console, then this will become a "listen" WinStation
         */
        if ( !fConsole ) {

            pWinStation->Flags |= WSF_LISTEN;

            //
            // Listener winstations always get LogonId above 65536 and are
            // assigned by Terminal Server. LogonId's for sessions are
            // generated by mm in the range 0-65535
            //
            pWinStation->LogonId = LogonId++;
            ASSERT(pWinStation->LogonId >= 65536);

        } else {

            //
            // Console always get 0
            //
            pWinStation->LogonId = 0;
            pWinStation->fOwnsConsoleTerminal = TRUE;

        }

    /*
     * No WinStation name was specified.
     * This will be an idle WinStation waiting for a connection.
     */
    } else {
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Creating IDLE WinStation\n" ));
        pWinStation->Flags |= WSF_IDLE;
        pWinStation->LogonId = -1; // MM will asssign session IDs
    }

    /*
     *  Initialize WinStation configuration data
     */
#ifdef NO_CONSOLE_REGISTRY
    if ( pWinStation->LogonId ) {
#endif
        /*
         *  Read winstation configuration data from registry
         */
        if ( pWinStationName ) {
            Status = RegWinStationQueryEx( SERVERNAME_CURRENT,
                                         &g_MachinePolicy, 
                                         pWinStationName,
                                         &pWinStation->Config,
                                         sizeof(WINSTATIONCONFIG2),
                                         &ReturnLength, TRUE );
            if ( !NT_SUCCESS(Status) ) {
                goto badregdata;
            }

            if (pWinStation->Config.Wd.WdFlag & WDF_TSHARE)
            {
                pWinStation->Client.ProtocolType = PROTOCOL_RDP;
            }
            else if (pWinStation->Config.Wd.WdFlag & WDF_ICA)
            {
                pWinStation->Client.ProtocolType = PROTOCOL_ICA;
            }
            else
            {
                pWinStation->Client.ProtocolType = PROTOCOL_CONSOLE;
            }

            /*
             * Save console config for console sessions.
             */

            if (pWinStation->LogonId == 0) {
                gConsoleConfig = pWinStation->Config;

                // initalize client data, since there isn't any real rdp client sending anythhing to us
                InitializeConsoleClientData( & pWinStation->Client );

            }
        }
#ifdef NO_CONSOLE_REGISTRY
    } else {


        /*
         *  Hand craft the console configuration data
         */
        PWDCONFIG pWdConfig = &pWinStation->Config.Wd;
        PPDCONFIGW pPdConfig = &pWinStation->Config.Pd[0];

        wcscpy( pWdConfig->WdName, L"Console" );
        pWdConfig->WdFlag = WDF_NOT_IN_LIST;
        wcscpy( pPdConfig->Create.PdName, L"Console" );
        pPdConfig->Create.PdClass = PdConsole;
        pPdConfig->Create.PdFlag  = PD_USE_WD | PD_RELIABLE | PD_FRAME |
                                    PD_CONNECTION | PD_CONSOLE;

        RegQueryOEMId( (PBYTE) &pWinStation->Config.Config.OEMId,
                       sizeof(pWinStation->Config.Config.OEMId) );               

    }
#endif

    /*
     * Allocate LogonId and insert in WinStation list
     */
    ENTERCRIT( &WinStationListLock );
    InsertTailList( &WinStationListHead, &pWinStation->Links );
    LEAVECRIT( &WinStationListLock );

    if (pWinStation->LogonId == 0 || g_bPersonalTS) {
        
        // Create a named event for console session so that winmm can check if we
        // are remoting audio on the console itself.  Use a global event is for
        // fast check
        {
            BYTE bSA[SECURITY_DESCRIPTOR_MIN_LENGTH];
            PSECURITY_DESCRIPTOR pSD = &bSA;
            SECURITY_ATTRIBUTES SA;
            EXPLICIT_ACCESS ea[2];
            SID_IDENTIFIER_AUTHORITY siaWorld   = SECURITY_WORLD_SID_AUTHORITY;
            SID_IDENTIFIER_AUTHORITY siaNT      = SECURITY_NT_AUTHORITY;
            PSID pSidWorld;
            PSID pSidNT;
            PACL pNewDAcl;
            DWORD dwres;

            if ( AllocateAndInitializeSid( &siaWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidWorld))
            {
                if ( AllocateAndInitializeSid( &siaNT, 1, SECURITY_LOCAL_SYSTEM_RID, 0, 0, 0, 0, 0, 0, 0, &pSidNT))
                {
                    ZeroMemory(ea, sizeof(ea));
                    ea[0].grfAccessPermissions = SYNCHRONIZE;
                    ea[0].grfAccessMode = GRANT_ACCESS;
                    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
                    ea[0].Trustee.ptstrName = (LPTSTR)pSidWorld;
                    ea[1].grfAccessPermissions = GENERIC_ALL;
                    ea[1].grfAccessMode = GRANT_ACCESS;
                    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
                    ea[1].Trustee.ptstrName = (LPTSTR)pSidNT;

                    dwres = SetEntriesInAcl(2, ea, NULL, &pNewDAcl );
                    if ( ERROR_SUCCESS == dwres )
                    {
                      if (InitializeSecurityDescriptor(pSD,
                                                       SECURITY_DESCRIPTOR_REVISION))
                      {
                        if (SetSecurityDescriptorDacl(pSD, TRUE, pNewDAcl, FALSE ))
                        {
                            SA.nLength = sizeof( SA );
                            SA.lpSecurityDescriptor = pSD;
                            SA.bInheritHandle = FALSE;
                            pWinStation->hWinmmConsoleAudioEvent = 
                                   CreateEvent( &SA, TRUE, FALSE, L"Global\\WinMMConsoleAudioEvent");
                            if ( pWinStation->LogonId == 0 )
                            {
                                pWinStation->hRDPAudioDisabledEvent =
                                    CreateEvent( &SA, TRUE, FALSE, L"Global\\RDPAudioDisabledEvent");
                            } else {
                                pWinStation->hRDPAudioDisabledEvent = NULL;
                            }
                        }
                      }
                      LocalFree( pNewDAcl );
                    }
                    LocalFree( pSidNT );
                }
                LocalFree( pSidWorld );
            }
        }
    }
    else {
        pWinStation->hWinmmConsoleAudioEvent = NULL;
        pWinStation->hRDPAudioDisabledEvent = NULL;
    }

    /*
     * Start the WinStation's primary device and stack
     */

    Status = StartWinStationDeviceAndStack( pWinStation ) ;

    /*
     * Ignore errors from console, otherwise keep going
     */
    if ( ( pWinStation->LogonId ) && ( Status != STATUS_SUCCESS ) ) {
        goto starterror;
    }

    /*
     * Start the WinStation - do this only for the Listener and Console Sessions or if last param is TRUE
     * For idle winstations, we start the Csr and Winlogon later on when Transferring connection
     */

    if (( pWinStation->Flags & WSF_LISTEN ) || (pWinStation->LogonId == 0) || (fStartWinStation)) {

        Status = WinStationStart( pWinStation );

        /*
         * Ignore errors from console, otherwise keep going
         */
        if ( ( pWinStation->LogonId ) && ( Status != STATUS_SUCCESS ) )
            goto starterror;

        Status = WinStationCreateComplete( pWinStation ) ; 

        if (Status != STATUS_SUCCESS) {
            TRACE((hTrace, TC_ICASRV, TT_ERROR,
                    "TERMSRV: WinstationCreateComplete Failed : Connection attempt failed, Status [%lx]\n",Status ));
            goto starterror;
        } 
    }

    /*
     * Return LogonId to caller
     * At this point LogonId is really -1 for idle sessions because we delay the starting of Csr and winlogon
     */
    if ( pLogonId )
        *pLogonId = pWinStation->LogonId;

    pWinStation->Starting = FALSE;

    /*
     * Release WinStation now
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * WinStationStart returned error
     * WinStation kernel object could not be created
     */
starterror:
    if ( !(pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {
        if ( StopOnDown )
            DbgBreakPoint();
        pWinStation->Flags |= WSF_DELETE;
        WinStationTerminate( pWinStation );
        pWinStation->State = State_Down;
        PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, Status);
        WinStationDeleteWorker(pWinStation);
    } else {
        ReleaseWinStation( pWinStation );
    }



    return Status;

    /*
     * Error reading registry data
     */
badregdata:

    /*
     * WinStation name already exists
     */
alreadyexists:
    NtClose( pWinStation->Lock.Mutex );

    /*
     * Could not create WinStation lock
     */
nolock:
    LCDestroyContext(pWinStation);

    /*
     * Could not allocate licensing context
     */
nolicensecontext:

    /*
     * Close the session initialization event if created successfully.
     */
    if (pWinStation->SessionInitializedEvent) {
        CloseHandle(pWinStation->SessionInitializedEvent);
        pWinStation->SessionInitializedEvent = NULL;
    }

    /*
     * Could not allocate WinStation
     */
nomem:
    PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, Status);

    if (pWinStation) {
        MemFree(pWinStation);
    }

    /*
     * WinStation is disabled
     * System shutdown is in progress
     */
disabled:
shutdown:

    return Status;
}

/*******************************************************************************
 *  StartWinStationDeviceAndStack
 *      Open the primary Device and primary Stack of the WinStation.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to start
 ******************************************************************************/

NTSTATUS StartWinStationDeviceAndStack(PWINSTATION pWinStation)
{
    NTSTATUS Status = STATUS_SUCCESS; 
    ICA_TRACE Trace;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: StartWinStationDeviceAndStack, %S (LogonId=%d)\n",
           pWinStation->WinStationName, pWinStation->LogonId ));

    /*
     * If its a WSF_LISTEN WinStation, see if a specific ACL has
     * been set for it.
     *
     * This ACL will be inherited by WinStations that are
     * connected to from this thread.
     *
     * If not specific ACL has been set, the system default
     * will be used.
     */

    if (( pWinStation->Flags & WSF_LISTEN ) || (pWinStation->LogonId == 0)){

        ReadWinStationSecurityDescriptor( pWinStation );
    }

   /*
   * Open an instance of the TermDD device driver
   */
    Status = IcaOpen( &pWinStation->hIca );
    if ( !NT_SUCCESS( Status ) ) {
         DBGPRINT(( "TERMSRV StartWinStationDeviceAndStack : IcaOpen: Error 0x%x from IcaOpen, last error %d\n",
                   Status, GetLastError() ));
         goto done;
     }

    /*
     * Open a stack instance
     */
    Status = IcaStackOpen( pWinStation->hIca, Stack_Primary,
            (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack);

    if ( !NT_SUCCESS( Status ) ) {
        IcaClose( pWinStation->hIca );
        pWinStation->hIca = NULL;
        DBGPRINT(( "TERMSRV StartWinStationDeviceAndStack : IcaStackOpen: Error 0x%x from IcaStackOpen, last error %d\n",
                   Status, GetLastError() ));
        goto done;
    }

    /*
     *  Enable trace
     */
    RtlZeroMemory( &Trace , sizeof( ICA_TRACE ) );
    InitializeTrace( pWinStation, FALSE, &Trace );

done: 
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: StartWinStationDeviceAndStack, Status = 0x%x\n", Status)); 

    return Status; 
}


/*******************************************************************************
 *  WinStationStart
 *
 *   Start a WinStation.  This involves reading the
 *   execute list from the registry, loading the WinStation
 *   subsystems, and starting the initial program.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to start
 ******************************************************************************/
NTSTATUS WinStationStart(PWINSTATION pWinStation)
{
    OBJECT_ATTRIBUTES ObjA;
    LARGE_INTEGER Timeout;
    NTSTATUS Status;
    UNICODE_STRING InitialCommand;
    PUNICODE_STRING pInitialCommand;
    PWCHAR pExecuteBuffer = NULL;
    ULONG CommandSize;
    PWCHAR pszCsrStartEvent = NULL;
    PWCHAR pszReconEvent = NULL;
    UNICODE_STRING EventName;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationStart, %S (LogonId=%d)\n",
               pWinStation->WinStationName, pWinStation->LogonId ));

    // allocate memory

    pExecuteBuffer = MemAlloc( MAX_STRING_BYTES * sizeof(WCHAR) );
    if (pExecuteBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    pszCsrStartEvent = MemAlloc( MAX_PATH * sizeof(WCHAR) );
    if (pszCsrStartEvent == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    pszReconEvent = MemAlloc( MAX_PATH * sizeof(WCHAR) );
    if (pszReconEvent == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    /*
     * If this is a "listening" WinStation, then we don't load the
     * subsystems and initial command.  Instead we create a service
     * thread to wait for new connections and service them.
     */
    if ( pWinStation->Flags & WSF_LISTEN ) {
        DWORD ThreadId;

        pWinStation->hConnectThread = CreateThread(
                          NULL,
                          0,        // use Default stack size of the svchost process
                          (LPTHREAD_START_ROUTINE)WinStationConnectThread,
                          LongToPtr( pWinStation->LogonId ),
                          0,
                          &ThreadId
                          );

        pWinStation->CreateStatus = STATUS_SUCCESS;
        Status = pWinStation->CreateStatus;
        pWinStation->NeverConnected = FALSE;
        pWinStation->State = State_Listen;
        NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Load subsystems and initial command
     *
     * Session Manager starts the console itself, but returns the
     * process ID's.  For all others, this actually starts CSR
     * and winlogon.
     */
    } else {
        /*
         * Create event we will wait on below
         */
        if ( pWinStation->LogonId ) {

            InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
            Status = NtCreateEvent( &pWinStation->CreateEvent, EVENT_ALL_ACCESS, &ObjA,
                                    NotificationEvent, FALSE );
            if ( !NT_SUCCESS( Status ) )
                goto done; 
        }

        UnlockWinStation( pWinStation );

        /*
         * Check debugging options
         */
        Status = RegWinStationQueryValueW(
                     SERVERNAME_CURRENT,
                     pWinStation->WinStationName,
                     L"Execute",
                     pExecuteBuffer,
                     MAX_STRING_BYTES * sizeof(WCHAR),
                     &CommandSize );

        if ( !Status && CommandSize ) {
            RtlInitUnicodeString( &InitialCommand, pExecuteBuffer );
            pInitialCommand = &InitialCommand;
        } else {
            pInitialCommand = NULL;
        }

        /*
         * For now only do one winstation start at a time.  This is because of
         * WinStation space problems.  The Session manager maps it's self into
         * the WinStation space of the CSR it wants to start so the CSR inherits
         * the space.  That means only one CSR can be started at a time.
         */
        ENTERCRIT( &WinStationStartCsrLock );
        
        
        //Terminal Service needs to skip Memory check in Embedded images 
        //when the TS service starts
        //bug #246972
        if(!IsEmbedded()) {
            /*
             * Make sure we have enough resources to start a new session
             */

            Status = NtAllocateVirtualMemory( NtCurrentProcess(),
                                              &glpAddress,
                                              0,
                                              &gMinPerSessionPageCommit,
                                              MEM_COMMIT,
                                              PAGE_READWRITE
                                            );

            if (!NT_SUCCESS(Status)) {
                DBGPRINT(( "TERMSRV: NtAllocateVirtualMemory failed with Status %lx for Size %lx(MB)\n",Status,gMinPerSessionPageCommitMB));
                LEAVECRIT( &WinStationStartCsrLock );
                goto done;
            } else {

                Status = NtFreeVirtualMemory( NtCurrentProcess(),
                                              &glpAddress,
                                              &gMinPerSessionPageCommit,
                                              MEM_DECOMMIT
                                            );
                if (!NT_SUCCESS(Status)) {
                    DBGPRINT(( "TERMSRV: NtFreeVirtualMemory failed with Status %lx \n",Status));
                    ASSERT(NT_SUCCESS(Status));
                }
            }
        }


        Status = SmStartCsr( IcaSmApiPort,
                             &pWinStation->LogonId,
                             pInitialCommand,
                             (PULONG_PTR)&pWinStation->InitialCommandProcessId,
                             (PULONG_PTR)&pWinStation->WindowsSubSysProcessId );



        LEAVECRIT( &WinStationStartCsrLock );

        if ( !RelockWinStation( pWinStation ) )
            Status = STATUS_CTX_CLOSE_PENDING;

        if (  Status != STATUS_SUCCESS) {
            DBGPRINT(("TERMSRV: SmStartCsr failed\n"));
            goto done;
        }


        /*
         * Close handle to initial command process, if already opened
         */
        if ( pWinStation->InitialCommandProcess ) {
            NtClose( pWinStation->InitialCommandProcess );
            pWinStation->InitialCommandProcess = NULL;
        }

        /*
         * Open handle to initial command process
         */
        pWinStation->InitialCommandProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            (DWORD)(ULONG_PTR)(pWinStation->InitialCommandProcessId) );

        if ( pWinStation->InitialCommandProcess == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Logon %d cannot open Initial command process\n",
                      pWinStation->LogonId));
            Status = STATUS_ACCESS_DENIED;
            goto done;
        }


        /*
         * Open handle to WIN32 subsystem process
         */
        pWinStation->WindowsSubSysProcess = OpenProcess(
            PROCESS_ALL_ACCESS,
            FALSE,
            (DWORD)(ULONG_PTR)(pWinStation->WindowsSubSysProcessId) );

        if ( pWinStation->WindowsSubSysProcess == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Logon %d cannot open windows subsystem process\n",
                      pWinStation->LogonId));
            Status = STATUS_ACCESS_DENIED;
            goto done;
        }


        //
        // Terminal Server calls into Session Manager to create a new Hydra session.
        // The session manager creates and resume a new session and returns to Terminal
        // server the session id of the new session. There is a race condition where
        // CSR can resume and call into terminal server before terminal server can
        // store the session id in its internal structure. To prevent this CSR will
        // wait here on a named event which will be set by Terminal server once it
        // gets the sessionid for the newly created session
        // Create CsrStartEvent
        //
        if ( NT_SUCCESS( Status ) && pWinStation->LogonId ) {

            wsprintf(pszCsrStartEvent,
                L"\\Sessions\\%d\\BaseNamedObjects\\CsrStartEvent",pWinStation->LogonId);
            RtlInitUnicodeString( &EventName,pszCsrStartEvent);
            InitializeObjectAttributes( &ObjA, &EventName, OBJ_OPENIF, NULL, NULL );

            Status = NtCreateEvent( &(pWinStation->CsrStartEventHandle),
                                    EVENT_ALL_ACCESS,
                                    &ObjA,
                                    NotificationEvent,
                                    FALSE );

            if ( !NT_SUCCESS( Status ) ) {
                DBGPRINT(("TERMSRV: NtCreateEvent (%ws) failed (%lx)\n",pszCsrStartEvent, Status));
                ASSERT(FALSE);
                pWinStation->CsrStartEventHandle = NULL;
                goto done;
            }

            //
            //  Now that we have the sessionId(LogonId), set the CsrStartEvent so
            //  CSR can connect to TerminalServer
            //

            NtSetEvent(pWinStation->CsrStartEventHandle, NULL);
        }

        {
           //
           // Create ReconnectReadyEvent
           //
           if ( pWinStation->LogonId == 0 ) {
              wsprintf(pszReconEvent,
                   L"\\BaseNamedObjects\\ReconEvent");
           } else {
             wsprintf(pszReconEvent,
                  L"\\Sessions\\%d\\BaseNamedObjects\\ReconEvent",pWinStation->LogonId);
           }
           RtlInitUnicodeString( &EventName,pszReconEvent);
           InitializeObjectAttributes( &ObjA, &EventName, OBJ_OPENIF, NULL, NULL );

           Status = NtCreateEvent( &(pWinStation->hReconnectReadyEvent),
                                   EVENT_ALL_ACCESS,
                                   &ObjA,
                                   NotificationEvent,
                                   TRUE );

           if ( !NT_SUCCESS( Status ) ) {
               DBGPRINT(("TERMSRV: NtCreateEvent (%ws) failed (%lx)\n",pszReconEvent, Status));
               ASSERT(FALSE);
               pWinStation->hReconnectReadyEvent = NULL;
               goto done;
           }

        }

        /*
         * For console, create is always successful - but do we need to
         * crank up the stack for the console session?
         */
        if ( pWinStation->LogonId == 0 )
        {
            pWinStation->CreateStatus = STATUS_SUCCESS;
            Status = pWinStation->CreateStatus;
            pWinStation->NeverConnected = FALSE;
            pWinStation->State = State_Connected;

        /*
         * Wait for create event to be triggered and get create status
         */
        } else {
            Timeout = RtlEnlargedIntegerMultiply( 30000, -10000 );
            UnlockWinStation( pWinStation );
            Status = NtWaitForSingleObject( pWinStation->CreateEvent, FALSE, &Timeout );
            if ( !RelockWinStation( pWinStation ) )
                Status = STATUS_CTX_CLOSE_PENDING;
            if ( Status == STATUS_SUCCESS )
                Status = pWinStation->CreateStatus;

            NtClose( pWinStation->CreateEvent );
            pWinStation->CreateEvent = NULL;
        }
    }

done:
    
    if (pExecuteBuffer != NULL) {
        MemFree(pExecuteBuffer);
        pExecuteBuffer = NULL;
    }

    if (pszCsrStartEvent != NULL) {
        MemFree(pszCsrStartEvent);
        pszCsrStartEvent = NULL;
    }

    if (pszReconEvent != NULL) {
        MemFree(pszReconEvent);
        pszReconEvent = NULL;
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationStart Subsys PID=%d InitialProg PID=%d, Status=0x%x\n",
               pWinStation->WindowsSubSysProcessId,
               pWinStation->InitialCommandProcessId,
               Status ));

    return Status;
}

NTSTATUS WinStationCreateComplete(PWINSTATION pWinStation)
{

    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCreateComplete, %S (LogonId=%d)\n",
           pWinStation->WinStationName, pWinStation->LogonId ));

    // Increment the total number of sessions created since TermSrv started.
    // we don't count the console and listener sessions
    if (pWinStation->LogonId > 0 && pWinStation->LogonId < 65536) {
        pWinStation->SessionSerialNumber = (ULONG) InterlockedIncrement(&g_TermSrvTotalSessions);
    }

    if (!(pWinStation->Flags & WSF_LISTEN))
    {
        Status = InitializeSessionNotification(pWinStation);
        if ( !NT_SUCCESS( Status ) ) {
            goto done; 
        }
    }

    /*
     * Set WinStationEvent to indicate another WinStation has been created
     */
    ENTERCRIT( &WinStationListLock );
    NtSetEvent( WinStationEvent, NULL );
    
    // Keep track of total session count for Load Balancing Indicator but
    // don't count listen winstations
    if (!(pWinStation->Flags & WSF_LISTEN))
        WinStationTotalCount++;

    LEAVECRIT( &WinStationListLock );


    /*
     * Notify clients of WinStation create
     */

    NotifySystemEvent( WEVENT_CREATE );

done : 

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCreateComplete, %S (LogonId=%d) Status = 0x%x \n",
           pWinStation->WinStationName, pWinStation->LogonId, Status ));

    return Status ;
}


/*******************************************************************************
 *  WinStationRenameWorker
 *
 *   Worker routine to rename a WinStation.
 *
 * ENTRY:
 *    pWinStationNameOld (input)
 *       Pointer to old WinStationName
 *    pWinStationNameNew (input)
 *       Pointer to new WinStationName
 ******************************************************************************/
NTSTATUS WinStationRenameWorker(
        PWINSTATIONNAME pWinStationNameOld,
        ULONG           NameOldSize,
        PWINSTATIONNAME pWinStationNameNew,
        ULONG           NameNewSize)
{
    PWINSTATION pWinStation;
    PLIST_ENTRY Head, Next;
    NTSTATUS Status;
    ULONG ulNewNameLength;

    /*
     * Ensure new WinStation name is non-zero length
     */

    //
    // The new WinStationName is allocated by the RPC server stub and the
    // size is sent over by the client (this is part of the existing interface.
    // Therefore, it is sufficient to assert for the pWinStationNameNew to be
    // non-null AND the New size to be non-zero. If it asserts, this is a serious
    // problem with the rpc stub that should never happen in a released build.
    //
    // The old WinStationName also poses a problem. It is assumed in the code
    // that follows that the old WinStationName is NULL terminated. The RPC
    // interface does not say that. Which means the call to FindWinStation by
    // name can potentially AV.

    if (!( (pWinStationNameNew != 0 ) && (NameNewSize != 0 ) &&
           !IsBadWritePtr( pWinStationNameNew, NameNewSize ) ) ) {

       return( STATUS_CTX_WINSTATION_NAME_INVALID );
    }

    if (!( (pWinStationNameOld != 0 ) && (NameOldSize != 0 )
       && !IsBadReadPtr( pWinStationNameOld, NameOldSize ) &&
       !IsBadWritePtr( pWinStationNameOld, NameOldSize))) {

       return( STATUS_CTX_WINSTATION_NAME_INVALID );
    }

    /*
     * Find and lock the WinStation
     * (Note that we hold the WinStationList lock while changing the name.)
     */
    // We will add a NULL Terminator to the end of the old winstation name

    pWinStationNameOld[ NameOldSize - 1 ] = 0;
    pWinStationNameNew[ NameNewSize - 1 ] = 0;

    /*
     * Ensure new WinStation name is non-zero length and not too long
     */
    ulNewNameLength = wcslen( pWinStationNameNew );
    if ( ( ulNewNameLength == 0 ) || ( ulNewNameLength > WINSTATIONNAME_LENGTH ) )
        return( STATUS_CTX_WINSTATION_NAME_INVALID );


    pWinStation = FindWinStationByName( pWinStationNameOld, TRUE );

    if ( pWinStation == NULL ) {
        LEAVECRIT( &WinStationListLock );
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    /*
     * Verify that client has DELETE access
     */
    Status = RpcCheckClientAccess( pWinStation, DELETE, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        LEAVECRIT( &WinStationListLock );
        ReleaseWinStation( pWinStation );
        return( Status );
    }

    /*
     * Now search the WinStation list to see if the new WinStation name
     * is already used.  If so then this is an error.
     */
    Head = &WinStationListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        PWINSTATION pWinStationTemp;

        pWinStationTemp = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( !_wcsicmp( pWinStationTemp->WinStationName, pWinStationNameNew ) ) {
            LEAVECRIT( &WinStationListLock );
            ReleaseWinStation( pWinStation );
            return( STATUS_CTX_WINSTATION_NAME_COLLISION );
        }
    }

    /*
     * Free the old name and set the new one, then release
     * the WinStationList lock and the WinStation mutex.
     */
    wcsncpy( pWinStation->WinStationName, pWinStationNameNew, WINSTATIONNAME_LENGTH );
    pWinStation->WinStationName[ WINSTATIONNAME_LENGTH ] = 0;

    LEAVECRIT( &WinStationListLock );
    ReleaseWinStation( pWinStation );

    /*
     * Notify clients of WinStation rename
     */
    NotifySystemEvent( WEVENT_RENAME );

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  WinStationTerminate
 *
 *   Terminate a WinStation.  This involves causing the WinStation initial
 *   program to logoff, terminating the initial program, and terminating
 *   all subsystems.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to terminate
 ******************************************************************************/
VOID WinStationTerminate(PWINSTATION pWinStation)
{
    WINSTATION_APIMSG msg;
    LARGE_INTEGER Timeout;
    NTSTATUS Status = 0;
    BOOL AllExited = FALSE;
    BOOL bDoDisconnectFailed = FALSE;
    int i, iLoop;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationTerminate, %S (LogonId=%d)\n",
               pWinStation->WinStationName, pWinStation->LogonId ));


    //
    // Release filtered address
    //
    /*
    if (pWinStation->pRememberedAddress != NULL) {
        Filter_RemoveOutstandingConnection( &pWinStation->pRememberedAddress->addr[0], pWinStation->pRememberedAddress->length );
        MemFree(pWinStation->pRememberedAddress);
        pWinStation->pRememberedAddress = NULL;
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
           if (hConnectEvent != NULL)
           {
               SetEvent(hConnectEvent);
           }
        }


    }
    */

    if (pWinStation->fOwnsConsoleTerminal) {
       CopyReconnectInfo(pWinStation, &ConsoleReconnectInfo);

    }


    /*
     * If not already set, mark the WinStation as terminating.
     * This prevents our WinStation Terminate thread from waiting on
     * the initial program or Win32 subsystem processes.
     */
    ENTERCRIT( &WinStationListLock );
    if ( !pWinStation->Terminating ) {
        pWinStation->Terminating = TRUE;
        NtSetEvent( WinStationEvent, NULL );
    }

    if (!(pWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE)) {
        pWinStation->StateFlags |= WSF_ST_WINSTATIONTERMINATE;
    } else {
        DBGPRINT(("Termsrv: WinstationTerminate: Session %ld has already been terminated \n",pWinStation->LogonId));
        LEAVECRIT( &WinStationListLock );


        return;
    }
    LEAVECRIT( &WinStationListLock );

    /*
     *  If WinStation is idle waiting for a connection, signal connect event
     *  - this will return an error back to winlogon
     */
    if ( pWinStation->ConnectEvent ) {
        NtSetEvent( pWinStation->ConnectEvent, NULL );
    }

    /*
     * Stop any shadowing for this WinStation
     */
    WinStationStopAllShadows( pWinStation );

     /*
     * Tell Win32 to disconnect.
     * This puts up the disconnected desktop among other things.
     */
    if ( ( pWinStation->WinStationName[0] ) &&
         ( !pWinStation->NeverConnected ) &&
         ( !(pWinStation->Flags & WSF_LISTEN) ) &&
         ( !(pWinStation->Flags & WSF_DISCONNECT) ) &&
         ( !(pWinStation->StateFlags & WSF_ST_IN_DISCONNECT )) &&
         ( (pWinStation->StateFlags & WSF_ST_CONNECTED_TO_CSRSS) )  ) {

        msg.ApiNumber = SMWinStationDoDisconnect;
        msg.u.DoDisconnect.ConsoleShadowFlag = FALSE;

        /*
         * Insignia really wants the video driver to be notified before
         * the transport is closed.
         */
        pWinStation->StateFlags |= WSF_ST_IN_DISCONNECT;

        Status = SendWinStationCommand( pWinStation, &msg, 600 );
        

        if (!NT_SUCCESS(Status)) {
           bDoDisconnectFailed = TRUE;
        }else {
                              
            /*
             * Tell csrss to notify winlogon for the disconnect.
             */

            msg.ApiNumber = SMWinStationNotify;
            msg.WaitForReply = FALSE;
            msg.u.DoNotify.NotifyEvent = WinStation_Notify_Disconnect;
            Status = SendWinStationCommand( pWinStation, &msg, 0 );

            pWinStation->StateFlags &= ~WSF_ST_CONNECTED_TO_CSRSS;

        }
    }


    /*
     * In case, the winstation termination is called without logoff notification, we will have to 
     * carry out the post logoff licensing. 
     */
    if (pWinStation->StateFlags & WSF_ST_LICENSING) {
        (VOID)LCProcessConnectionLogoff(pWinStation);
        pWinStation->StateFlags &= ~WSF_ST_LICENSING;
    }


    /*
     *  Free Timers
     */
    if ( pWinStation->fIdleTimer ) {
        IcaTimerClose( pWinStation->hIdleTimer );
        pWinStation->fIdleTimer = FALSE;
    }
    if ( pWinStation->fLogonTimer ) {
        IcaTimerClose( pWinStation->hLogonTimer );
        pWinStation->fLogonTimer = FALSE;
    }
    if ( pWinStation->fDisconnectTimer ) {
        IcaTimerClose( pWinStation->hDisconnectTimer );
        pWinStation->fDisconnectTimer = FALSE;
    }

    /*
     *  Free events
     */
    if ((pWinStation->LogonId == 0 || g_bPersonalTS))
    {
        if ( pWinStation->hWinmmConsoleAudioEvent) {
            CloseHandle(pWinStation->hWinmmConsoleAudioEvent);
        }
        if ( pWinStation->hRDPAudioDisabledEvent) {
            CloseHandle(pWinStation->hRDPAudioDisabledEvent);
        }
    }

    /*
     * Notify clients of WinStation delete
     *
     * This mimics what happened in 1.6, but the state of the winstation hasn't changed
     * yet and it's still in the list, so it's not "deleted".  Maybe we should add
     * a State_Exiting.  Right now, it's marked down when it loses the LPC connection
     * with the CSR.  Later, it's removed from the list and another WEVENT_DELETE is sent.
     */
    NotifySystemEvent( WEVENT_DELETE );
    
    if (!(pWinStation->Flags & WSF_LISTEN))
    {
        UnlockWinStation(pWinStation);
        RemoveSessionNotification( pWinStation->LogonId, pWinStation->SessionSerialNumber );


        /*
         * WinStationDeleteWorker, deletes the lock, which is always called after WinStationTerminate.
         * therefore we should always succeed in Relock here.
         */
        RTL_VERIFY(RelockWinStation(pWinStation));
    }


    /*
     * Terminate ICA stack
     */

    if ( pWinStation->hStack && (!bDoDisconnectFailed)  ) {
        /*
         * Close the connection endpoint, if any
         */
        if ( pWinStation->pEndpoint ) {

            /*
             * First notify Wsx that connection is going away
             */
            WsxBrokenConnection( pWinStation );



            IcaStackConnectionClose( pWinStation->hStack,
                                     &pWinStation->Config,
                                     pWinStation->pEndpoint,
                                     pWinStation->EndpointLength
                                     );
            MemFree( pWinStation->pEndpoint );
            pWinStation->pEndpoint = NULL;
            pWinStation->EndpointLength = 0;
        }

        IcaStackTerminate( pWinStation->hStack );

    } else{
       pWinStation->StateFlags |= WSF_ST_DELAYED_STACK_TERMINATE;
    }

    /*
     * Flush the Win32 command queue.
     * If the Win32 command list is not empty, then loop through each
     * entry on the list and unlink it and trigger the wait event.
     */
    while ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {
        PLIST_ENTRY Head;
        PCOMMAND_ENTRY pCommand;

        Head = pWinStation->Win32CommandHead.Flink;
        pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );
        RemoveEntryList( &pCommand->Links );
        if ( !pCommand->pMsg->WaitForReply ) {
            ASSERT( pCommand->Event == NULL );
            MemFree( pCommand );
        } else {
            pCommand->Links.Flink = NULL;
            pCommand->pMsg->ReturnedStatus = STATUS_CTX_WINSTATION_BUSY;
            NtSetEvent( pCommand->Event, NULL );
        }
    }

    //
    // close CsrStartEvent
    //
    if (pWinStation->CsrStartEventHandle != NULL)   {
        NtClose(pWinStation->CsrStartEventHandle);
    }

    //
    // close hReconnectReadyEvent
    //
    if (pWinStation->hReconnectReadyEvent != NULL)   {
        NtClose(pWinStation->hReconnectReadyEvent);
    }


    /*
     * Force initial program to exit if it hasn't already
     */
    if ( pWinStation->InitialCommandProcess ) {
        DWORD WaitStatus;

        /*
         * If initial program has already exited, then we can skip this
         */
        WaitStatus = WaitForSingleObject( pWinStation->InitialCommandProcess, 0 );
        if ( WaitStatus != 0 ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Terminating initial command, LogonId=%d\n",
                      pWinStation->LogonId ));

            //
            // if we are asked to terminate winstation that initiated the shutdown
            // there is no point in sending SMWinStationExitWindows to this window, as its
            // winlogons main thread is already busy waiting for this (RpcWinStationShutdownSystem) lpc
            //.
            if (!ShutDownFromSessionID || ShutDownFromSessionID != pWinStation->LogonId)
            {
                 /*
                 * Tell the WinStation to logoff
                 */
                msg.ApiNumber = SMWinStationExitWindows;
                msg.u.ExitWindows.Flags = EWX_LOGOFF | EWX_FORCE;
                Status = SendWinStationCommand( pWinStation, &msg, 10 );
                if ( NT_SUCCESS( Status ) && ( pWinStation->InitialCommandProcess != NULL ) ) {
                    ULONG i;

                
                    if ( ShutDownFromSessionID )
                        Timeout = RtlEnlargedIntegerMultiply( 1, -10000 );
                    else
                        Timeout = RtlEnlargedIntegerMultiply( 2000, -10000 );

                    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for InitialCommand (ID=0x%x) to exit\n", pWinStation->InitialCommandProcessId ));


                    for ( i = 0; i < gLogoffTimeout; i++ ) {
                    
                        HANDLE CommandHandle = pWinStation->InitialCommandProcess;


                        UnlockWinStation( pWinStation );
                        Status = NtWaitForSingleObject( CommandHandle, FALSE, &Timeout );
                        RelockWinStation( pWinStation );
                        if ( Status == STATUS_SUCCESS )
                            break;

                        TRACE((hTrace,TC_ICASRV,TT_API1,  "." ));

                    }

                    TRACE((hTrace,TC_ICASRV,TT_API1, "\nTERMSRV: Wait for InitialCommand to exit, Status=0x%x\n", Status ));
                }
            }
            else
            {
                // we are not going to have to terminate winlogon for the session that initiated shutdown.
                Status = STATUS_UNSUCCESSFUL;
            }

            /*
             * If unable to connect to the WinStation, then we must use
             * the brute force method - just terminate the initial command.
             */
            if ( ( Status != STATUS_SUCCESS ) && ( pWinStation->InitialCommandProcess != NULL ) ) {

                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Waiting for InitialCommand to terminate\n" ));

                Status = TerminateProcessAndWait( pWinStation->InitialCommandProcessId,
                                                     pWinStation->InitialCommandProcess,
                                                     120 );
                if ( Status != STATUS_SUCCESS ) {
                    DBGPRINT(( "TERMSRV: InitialCommand failed to terminate, Status=%x\n", Status ));

               /*
                * We can fail terminating initial process if it is waiting
                * for a user validation in the Hard Error popup. In this case it is
                * Ok to proceceed as  sending SMWinStationTerminate message bellow
                * will trigger Win32k cleanup code that will dismiss the popup.
                */
                    ASSERT(pWinStation->WindowsSubSysProcess);
                }
            }
        }
    }

    /*
     * Now check to see if there are any remaining processes in
     * the system other than CSRSS with this SessionId.  If so, terminate them now.
     */

    for (i = 0 ; i < 45; i++) {

        ULONG NumTerminated = 0;
        AllExited = WinStationTerminateProcesses( pWinStation, &NumTerminated );

        /*
         * If we found any processes other than CSRSS that had to be terminated, we
         * have to re-enumerate all the process and make sure that no new processes
         * in this session were created in the windows between the call to NtQuerySystemInformation
         * and terminating all the found processes. If we only find CSRSS we don't have to
         * re-enumerate since CSRSS does not create any processes.
         */
        if (AllExited && (NumTerminated == 0)) {
            break;
        }

        /*
         * This is a hack to give enough time to processess to terminate
         */
        Sleep(2*1000);
    }


    if (pWinStation->WindowsSubSysProcess) {
        /*
         * Send terminate message to this subsystem
         */
        msg.ApiNumber = SMWinStationTerminate;
        /*
         * We used to not wait for this.  However, if the reverse LPC is
         * hung, the CSR is not going to exit anyway and we don't want
         * to silently forget about the WinStation.  (It takes up memory.)
         *
         * Also, if we kill the thread prematurely W32 is never going to exit.
         */
        Status = SendWinStationCommand( pWinStation, &msg, -1 );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Call to SMWinStationTerminate returned Status=0x%x\n", Status));


        if ((Status != STATUS_SUCCESS) && (Status != STATUS_CTX_CLOSE_PENDING)  ) {
            SetRefLockDeleteProc(&pWinStation->Lock, WinStationZombieProc);
        }

        /*
         * Now check to see if there are any remaining processes in
         * the system other than CSRSS with this SessionId.  If so, terminate them now.
         */

        
        for (i = 0 ; i < 45; i++) {

            ULONG NumTerminated = 0;
            AllExited = WinStationTerminateProcesses( pWinStation, &NumTerminated );

            /*
             * If we found any processes other than CSRSS that had to be terminated, we
             * have to re-enumerate all the process and make sure that no new processes
             * in this session were created in the windows between the call to NtQuerySystemInformation
             * and terminating all the found processes. If we only find CSRSS we don't have to
             * re-enumerate since CSRSS does not create any processes.
             */
            if (AllExited && (NumTerminated == 0)) {
                break;
            }

            /*
             * This is a hack to give enough time to processess to terminate
             */
            Sleep(2*1000);
        }


        /*
         * Force the windows subsystem to exit. Only terminate CSRSS it all other processes
         * have terminated
         */
        if ( AllExited ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: All process exited in Session %d\n",pWinStation->LogonId ));

            /*
             * Wait for the subsystem to exit
             */
            if ( NT_SUCCESS(Status) || ( Status == STATUS_CTX_WINSTATION_BUSY ) || (Status == STATUS_CTX_CLOSE_PENDING ) ) {

                ASSERT(!(pWinStation->Flags & WSF_LISTEN));
//                ENTERCRIT( &WinStationStartCsrLock );
//                Status = SmStopCsr( IcaSmApiPort,
//                                    pWinStation->LogonId );
//                LEAVECRIT( &WinStationStartCsrLock );


//                DBGPRINT(( "TERMSRV:   SmStopCsr on CSRSS for Session=%d returned Status=%x\n",
//                              pWinStation->LogonId, Status ));
//
//                ASSERT(NT_SUCCESS(Status));

//                if (!NT_SUCCESS(Status)) {
//                    DBGPRINT(( "TERMSRV:   SmStopCsr Failed for Session=%d returned Status=%x\n",
//                                                pWinStation->LogonId, Status ));
 //                   DbgBreakPoint();
                //}
            }
        } else {

            DBGPRINT(("TERMSRV: Did not terminate all the session processes\n"));
            SetRefLockDeleteProc(&pWinStation->Lock, WinStationZombieProc);

        //    DbgBreakPoint();
        }
    }

}

/*******************************************************************************
 *  WinStationTerminateProcesses
 *
 *   Terminate all processes executing on the specified WinStation
 ******************************************************************************/
BOOL WinStationTerminateProcesses(
        PWINSTATION pWinStation,
        ULONG *pNumTerminated)
{
    PCHAR pBuffer;
    ULONG ByteCount;
    NTSTATUS Status;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    UNICODE_STRING CsrssName;
    UNICODE_STRING NtsdName;
    BOOL retval = TRUE;
    WCHAR ProcessName[MAX_PATH];
    SYSTEM_SESSION_PROCESS_INFORMATION SessionProcessInfo;
    ULONG retlen = 0;

    ByteCount = 32 * 1024;

    *pNumTerminated = 0;

    SessionProcessInfo.SessionId = pWinStation->LogonId;
    
    for ( ; ; ) {
        if ( (pBuffer = MemAlloc( ByteCount )) == NULL )
            return (FALSE);

        SessionProcessInfo.Buffer = pBuffer;
        SessionProcessInfo.SizeOfBuf = ByteCount;

        /*
         *  get process info
         */

        Status = NtQuerySystemInformation(
                        SystemSessionProcessInformation,
                        &SessionProcessInfo,
                        sizeof(SessionProcessInfo),
                        &retlen );

        if ( NT_SUCCESS( Status ) )
            break;

        /*
         *  Make sure buffer is big enough
         */
        MemFree( pBuffer );
        if ( Status != STATUS_INFO_LENGTH_MISMATCH ) 
            return (FALSE);
        ByteCount *= 2;
    }

    if (retlen == 0) {
       MemFree(pBuffer);
       return TRUE;
    }

    RtlInitUnicodeString(&CsrssName,L"CSRSS");


    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pBuffer;
    for ( ; ; ) {
        HANDLE ProcessHandle;
        CLIENT_ID ClientId;
        OBJECT_ATTRIBUTES ObjA;

        if (RtlPrefixUnicodeString(&CsrssName,&(ProcessInfo->ImageName),TRUE)) {
            if (ProcessInfo->NextEntryOffset == 0)
                break;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
                    ((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);
            continue;
        }

        RtlInitUnicodeString(&NtsdName,L"ntsd");
        if (! RtlPrefixUnicodeString(&NtsdName,&(ProcessInfo->ImageName),TRUE) ) {
            // If we found any process other than CSRSS and ntsd.exe, bump the
            // the count
            (*pNumTerminated) += 1;
        }

        /*
         * Found a process with a matching LogonId.
         * Attempt to open the process and terminate it.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateProcesses, found processid 0x%x for LogonId %d\n",
                   ProcessInfo->UniqueProcessId, ProcessInfo->SessionId ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Process Name  %ws for LogonId %d\n",
                   ProcessInfo->ImageName.Buffer, ProcessInfo->SessionId ));

        ClientId.UniqueThread = 0;
        ClientId.UniqueProcess = (HANDLE)ProcessInfo->UniqueProcessId;

        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtOpenProcess( &ProcessHandle, PROCESS_ALL_ACCESS,
                                 &ObjA, &ClientId );
        if (!NT_SUCCESS(Status)) {
            DBGPRINT(("TERMSRV: Unable to open processid 0x%x, status=0x%x\n",
                       ProcessInfo->UniqueProcessId, Status ));
            retval = FALSE;
        } else {
            Status = TerminateProcessAndWait( ProcessInfo->UniqueProcessId,
                                             ProcessHandle, 60 );
            NtClose( ProcessHandle );
            if ( Status != STATUS_SUCCESS ) {
                DBGPRINT(("TERMSRV: Unable to terminate processid 0x%x, status=0x%x\n",
                           ProcessInfo->UniqueProcessId, Status ));

                retval = FALSE;
            }
        }

        if ( ProcessInfo->NextEntryOffset == 0 )
            break;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)
            ((ULONG_PTR)ProcessInfo + ProcessInfo->NextEntryOffset);
    }

    /*
     *  free buffer
     */
    MemFree( pBuffer );

    return retval;
}


/*******************************************************************************
 *  WinStationDeleteWorker
 *
 *   Delete a WinStation.
 ******************************************************************************/
VOID WinStationDeleteWorker(PWINSTATION pWinStation)
{
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDeleteWorker, %S (LogonId=%d)\n",
               pWinStation->WinStationName, pWinStation->LogonId ));

    /*
     * If this is the last reference, then
     * Initial program and all subsystems should be terminated by now.
     */
    ENTERCRIT( &WinStationListLock );
    ASSERT( (pWinStation->Links.Flink != NULL) &&  (pWinStation->Links.Blink != NULL));
    RemoveEntryList( &pWinStation->Links );
#if DBG
    pWinStation->Links.Flink = pWinStation->Links.Blink = NULL;
#endif

    // Keep track of total session count for Load Balancing Indicator but don't
    // track listen winstations
    if (!(pWinStation->Flags & WSF_LISTEN))
        WinStationTotalCount--;

    // If we're resetting a disconnected session then adjust LB counter
    if (pWinStation->State == State_Disconnected) {
        WinStationDiscCount--;
    }

    LEAVECRIT( &WinStationListLock );

    /*
     * Unlock WinStation and delete it
     */
    DeleteRefLock( &pWinStation->Lock );

    /*
     * Notify clients of deletion
     */
    NotifySystemEvent( WEVENT_DELETE );
}


/*******************************************************************************
 *  WinStationDeleteProc
 *
 *   Delete the WinStation containing the specified RefLock.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock of WinStation to delete
 ******************************************************************************/
VOID WinStationDeleteProc(PREFLOCK pLock)
{
    PWINSTATION pWinStation;
    ICA_TRACE IcaTrace;
    NTSTATUS Status = STATUS_SUCCESS;


    /* 
     * See if we need to wakeup IdleControlThread to maintain Console session
     */

    if ((USER_SHARED_DATA->ActiveConsoleId == -1) && (gConsoleCreationDisable == 0) ) {
        NtSetEvent(WinStationIdleControlEvent, NULL);
    }


    /*
     * Get a pointer to the containing WinStation
     */
    pWinStation = CONTAINING_RECORD( pLock, WINSTATION, Lock );

    /*
     * Release filtered address
     */

    if (pWinStation->pRememberedAddress != NULL) {
        Filter_RemoveOutstandingConnection( &pWinStation->pRememberedAddress->addr[0], pWinStation->pRememberedAddress->length );
        MemFree(pWinStation->pRememberedAddress);
        pWinStation->pRememberedAddress = NULL;
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
           if (hConnectEvent != NULL)
           {
               SetEvent(hConnectEvent);
           }
        }

    }

    /*
     * Release last remote ip address
     */

    if( pWinStation->pLastClientAddress != NULL )
    {
        MemFree( pWinStation->pLastClientAddress );
        pWinStation->pLastClientAddress = NULL;
    }

    /*
     * If this hasn't yet been cleaned up do it now.
     */
    if (pWinStation->ConnectEvent) {
        NtClose( pWinStation->ConnectEvent );
        pWinStation->ConnectEvent = NULL;
    }
    if (pWinStation->CreateEvent) {
        NtClose( pWinStation->CreateEvent );
        pWinStation->CreateEvent = NULL;
    }

    if (pWinStation->SessionInitializedEvent) {
        CloseHandle(pWinStation->SessionInitializedEvent);
        pWinStation->SessionInitializedEvent = NULL;
    }

    /*
     *  In the case where we timed out disconnecting the session we had
     *  to delay the stack unload till here to avoid situation where Win32k
     *  Display driver believe the session is still connected while the WD
     *  is already unloaded.
     */
    if ( pWinStation->hStack && (pWinStation->StateFlags & WSF_ST_DELAYED_STACK_TERMINATE) ) {
        pWinStation->StateFlags &= ~WSF_ST_DELAYED_STACK_TERMINATE;

        /*
         * Close the connection endpoint, if any
         */
        if ( pWinStation->pEndpoint ) {
            /*
             * First notify Wsx that connection is going away
             */
            WsxBrokenConnection( pWinStation );



            IcaStackConnectionClose( pWinStation->hStack,
                                   &pWinStation->Config,
                                   pWinStation->pEndpoint,
                                   pWinStation->EndpointLength
                                   );
            MemFree( pWinStation->pEndpoint );
            pWinStation->pEndpoint = NULL;
            pWinStation->EndpointLength = 0;
        }

        IcaStackTerminate( pWinStation->hStack );
    }
    
    /* close cdm */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxCdmDisconnect ) {
        pWinStation->pWsx->pWsxCdmDisconnect( pWinStation->pWsxContext,
                                              pWinStation->LogonId,
                                              pWinStation->hIca );
    }

    /*
     * Call WinStation rundown function before killing the stack
     */
    if ( pWinStation->pWsxContext ) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationRundown ) {
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
    }

    /*
     * Close ICA stack and device handles
     */
    if ( pWinStation->hStack ) {
        IcaStackClose( pWinStation->hStack );
        pWinStation->hStack = NULL;
    }

    if ( pWinStation->hIca ) {
        /* close trace */
        memset( &IcaTrace, 0, sizeof(IcaTrace) );
        (void) IcaIoControl( pWinStation->hIca, IOCTL_ICA_SET_TRACE,
                             &IcaTrace, sizeof(IcaTrace), NULL, 0, NULL );

        /* close handle */
        IcaClose( pWinStation->hIca );
        pWinStation->hIca = NULL;
    }

    /*
     * Close various ICA channel handles
     */
    if ( pWinStation->hIcaBeepChannel ) {
        (void) IcaChannelClose( pWinStation->hIcaBeepChannel );
        pWinStation->hIcaBeepChannel = NULL;
    }

    if ( pWinStation->hIcaThinwireChannel ) {
        (void) IcaChannelClose( pWinStation->hIcaThinwireChannel );
        pWinStation->hIcaThinwireChannel = NULL;
    }

    if ( pWinStation->hConnectThread ) {
        NtClose( pWinStation->hConnectThread );
        pWinStation->hConnectThread = NULL;
    }

    /*
     * Free security structures
     */
    WinStationFreeSecurityDescriptor( pWinStation );

    if ( pWinStation->pUserSid ) {
        pWinStation->pProfileSid = pWinStation->pUserSid;
        pWinStation->pUserSid = NULL;
    }

    if (pWinStation->pProfileSid) {
       WinstationUnloadProfile(pWinStation);
       MemFree( pWinStation->pProfileSid );
       pWinStation->pProfileSid = NULL;
    }

    /*
     * Cleanup UserToken
     */
    if ( pWinStation->UserToken ) {
        NtClose( pWinStation->UserToken );
        pWinStation->UserToken = NULL;
    }

    if (pWinStation->LogonId > 0) {
        ENTERCRIT( &WinStationStartCsrLock );
        Status = SmStopCsr( IcaSmApiPort, pWinStation->LogonId );
        LEAVECRIT( &WinStationStartCsrLock );
    }
    
    // Clean up the New Client Credentials struct for Long UserName
    if (pWinStation->pNewClientCredentials != NULL) {
        MemFree(pWinStation->pNewClientCredentials); 
        pWinStation->pNewClientCredentials = NULL;
    }

    // Clean up the updated Notification Credentials
    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    /*
     * Close the handles to the initial command process and sub-system process here.
     */
    if (pWinStation->WindowsSubSysProcess)  {
        NtClose( pWinStation->WindowsSubSysProcess );
        pWinStation->WindowsSubSysProcess = NULL;
    }

    // Close the InitialCommandProcess
    if (pWinStation->InitialCommandProcess) {
        NtClose( pWinStation->InitialCommandProcess );
        pWinStation->InitialCommandProcess = NULL;
    }

    /*
     * Cleanup licensing context
     */
    LCDestroyContext(pWinStation);

    TRACE((hTrace,TC_ICASRV,TT_API1,  "TERMSRV:   SmStopCsr on CSRSS for Session=%d returned Status=%x\n", pWinStation->LogonId, Status ));
    ASSERT(NT_SUCCESS(Status));

    if (!NT_SUCCESS(Status)) {
        DBGPRINT(( "TERMSRV:   SmStopCsr Failed for Session=%d returned Status=%x\n", pWinStation->LogonId, Status ));
 //     DbgBreakPoint();

        ENTERCRIT( &WinStationZombieLock );
        InsertTailList( &ZombieListHead, &pWinStation->Links );
        LEAVECRIT( &WinStationZombieLock );
        return;
    }

    /*
     * Zero WinStation name buffer
     */
    RtlZeroMemory( pWinStation->WinStationName, sizeof(pWinStation->WinStationName) );

    MemFree( pWinStation );
}


/*******************************************************************************
 *  WinStationZombieProc
 *
 *   Puts WinStation containing the specified RefLock in the zombie list.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock of WinStation to delete
 ******************************************************************************/
VOID WinStationZombieProc(PREFLOCK pLock)
{
    PWINSTATION pWinStation;

    pWinStation = CONTAINING_RECORD( pLock, WINSTATION, Lock );
    ENTERCRIT( &WinStationZombieLock );
    InsertTailList( &ZombieListHead, &pWinStation->Links );
    LEAVECRIT( &WinStationZombieLock );
}

/*******************************************************************************
 *  CopyReconnectInfo
 *
 *
 * ENTRY:
 ******************************************************************************/
BOOL CopyReconnectInfo(PWINSTATION pWinStation, PRECONNECT_INFO pReconnectInfo)
{
   NTSTATUS Status;

   RtlZeroMemory( pReconnectInfo, sizeof(*pReconnectInfo) );

   /*
    * Save WinStation name and configuration data.
    */
   RtlCopyMemory( pReconnectInfo->WinStationName,
                  pWinStation->WinStationName,
                  sizeof(WINSTATIONNAME) );
   RtlCopyMemory( pReconnectInfo->ListenName,
                  pWinStation->ListenName,
                  sizeof(WINSTATIONNAME) );
   RtlCopyMemory( pReconnectInfo->ProtocolName,
                  pWinStation->ProtocolName,
                  sizeof(pWinStation->ProtocolName) );
   RtlCopyMemory( pReconnectInfo->DisplayDriverName,
                  pWinStation->DisplayDriverName,
                  sizeof(pWinStation->DisplayDriverName) );
   pReconnectInfo->Config = pWinStation->Config;
   pReconnectInfo->Client = pWinStation->Client;

   /*
    * Open a new TS connection to temporarily attach the stack to.
    */
   Status = IcaOpen( &pReconnectInfo->hIca );
   if (Status != STATUS_SUCCESS ) {
      return FALSE;
   }

   Status = IcaStackDisconnect( pWinStation->hStack,
                                pReconnectInfo->hIca,
                                NULL );
   if ( !NT_SUCCESS( Status ) ){
      IcaClose( pReconnectInfo->hIca );
      pReconnectInfo->hIca = NULL;
      return FALSE;
   }

   /*
    * Save stack and endpoint data
    */
   pReconnectInfo->hStack = pWinStation->hStack;
   pReconnectInfo->pEndpoint = pWinStation->pEndpoint;
   pReconnectInfo->EndpointLength = pWinStation->EndpointLength;

   /*
    * Indicate no stack or connection endpoint for this WinStation
    */
   pWinStation->hStack = NULL;
   pWinStation->pEndpoint = NULL;
   pWinStation->EndpointLength = 0;

   /*
    * Reopen a stack for this WinStation
    */
   Status = IcaStackOpen( pWinStation->hIca, Stack_Primary,
           (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );

   /*
    * Save the licensing stuff to move to other winstation
    */
   if ( pWinStation->pWsx &&
        pWinStation->pWsx->pWsxDuplicateContext ) {
       pReconnectInfo->pWsx = pWinStation->pWsx;
       pWinStation->pWsx->pWsxDuplicateContext( pWinStation->pWsxContext,
               &pReconnectInfo->pWsxContext );
   }

   /*
    * Copy console owner info
    */
   pReconnectInfo->fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal;

   /*
    * Copy the notification Credentials to move to other winstation
    */
   if (pWinStation->pNewNotificationCredentials) {
       pReconnectInfo->pNotificationCredentials = pWinStation->pNewNotificationCredentials;
   } else {
       pReconnectInfo->pNotificationCredentials = NULL;
   }

   /*
    * Copy the remote client ip address to move to the other winstation
    */

   if( pReconnectInfo->pRememberedAddress != NULL )
   {
       MemFree( pReconnectInfo->pRememberedAddress );
       pReconnectInfo->pRememberedAddress = NULL;
   }

   if( pWinStation->pLastClientAddress != NULL )
   {
       pReconnectInfo->pRememberedAddress = ( PREMEMBERED_CLIENT_ADDRESS )MemAlloc( sizeof( REMEMBERED_CLIENT_ADDRESS ) + 
           pWinStation->pLastClientAddress->length - 1);

       if( pReconnectInfo->pRememberedAddress != NULL )
       {
           RtlCopyMemory( &pReconnectInfo->pRememberedAddress->addr[0] , 
               &pWinStation->pLastClientAddress->addr[0] ,
               pWinStation->pLastClientAddress->length
               );

           pReconnectInfo->pRememberedAddress->length = pWinStation->pLastClientAddress->length;
       }
               
   }
   
   return TRUE;

}

/*******************************************************************************
 *  WinStationDoDisconnect
 *
 *   Send disconnect message to a WinStation and optionally close connection
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to disconnect
 *    pReconnectInfo (input) OPTIONAL
 *       Pointer to RECONNECT_INFO buffer
 *       If NULL, this is a terminate disconnect.
 *
 * EXIT:
 *    STATUS_SUCCESS                - if successful
 *    STATUS_CTX_WINSTATION_BUSY    - if session is already disconnected, or busy
 ******************************************************************************/
NTSTATUS WinStationDoDisconnect(
        PWINSTATION pWinStation,
        PRECONNECT_INFO pReconnectInfo,
        BOOLEAN bSyncNotify)
{
    WINSTATION_APIMSG DisconnectMsg;
    NTSTATUS Status;
    ULONG ulTimeout;
    BOOLEAN fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal;
    FILETIME DiscTime;
    DWORD SessionID;
    BOOLEAN bInformSessionDirectory = FALSE;
    TS_AUTORECONNECTINFO SCAutoReconnectInfo;
    ULONG BytesGot;
    BOOLEAN     noTimeOutForConsoleOrSession0;

    // We need to prevent from WinStationDoDisconnect being called twice
    if ( pWinStation->State == State_Disconnected || pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)
    {
        // The session is already disconnected.
        // BUBUG a specific error code STATUS_CTX_SESSION_DICONNECTED would be better.
        return (STATUS_CTX_WINSTATION_BUSY);
    }
    pWinStation->StateFlags |=  WSF_ST_IN_DISCONNECT;

    // console session or session0 behave like the physical console, they are special, no time out.
    noTimeOutForConsoleOrSession0 = ( pWinStation->LogonId == 0 ) || (pWinStation->LogonId == (USER_SHARED_DATA->ActiveConsoleId) );

    if (! noTimeOutForConsoleOrSession0 )
    {
        /*
         *  Start disconnect timer if enabled
         */
        if ( ulTimeout = pWinStation->Config.Config.User.MaxDisconnectionTime ) {
            if ( !pWinStation->fDisconnectTimer ) {
                Status = IcaTimerCreate( 0, &pWinStation->hDisconnectTimer );
                if ( NT_SUCCESS( Status ) )
                    pWinStation->fDisconnectTimer = TRUE;
                else
                    DBGPRINT(("xxxWinStationDisconnect - failed to create timer \n"));
            }
            if ( pWinStation->fDisconnectTimer )
                IcaTimerStart( pWinStation->hDisconnectTimer, DisconnectTimeout,
                               LongToPtr( pWinStation->LogonId ), ulTimeout );
        }
    }

    /*
     * Stop any shadowing for this WinStation
     */
    WinStationStopAllShadows( pWinStation );

    /*
     * Tell Win32k about the disconnect
     */
    if (pWinStation->StateFlags & WSF_ST_CONNECTED_TO_CSRSS) {
        DisconnectMsg.ApiNumber = SMWinStationDoDisconnect;
        DisconnectMsg.u.DoDisconnect.ConsoleShadowFlag = FALSE;

        Status = SendWinStationCommand( pWinStation, &DisconnectMsg, 600 );
        if ( !NT_SUCCESS(Status) ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: CSR DoDisconnect failed LogonId=%d Status=0x%x\n",
                       pWinStation->LogonId, Status ));
            goto badwin32disconnect;
        } else {

            ULONG WaitTime = 0;

            /*
             * Tell csrss to notify winlogon for the disconnect.
             */
            if (pWinStation->UserName[0] != L'\0') {
               DisconnectMsg.WaitForReply = TRUE;
               WaitTime = 10;
            } else {
               DisconnectMsg.WaitForReply = FALSE;
            }
            DisconnectMsg.ApiNumber = SMWinStationNotify;
            if (bSyncNotify) {
               DisconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_SyncDisconnect;
            } else {
                DisconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_Disconnect;
            }
            Status = SendWinStationCommand( pWinStation, &DisconnectMsg, WaitTime );

            pWinStation->StateFlags &= ~WSF_ST_CONNECTED_TO_CSRSS;
            pWinStation->fOwnsConsoleTerminal = FALSE;
        }
    }

    /*
     * close cdm
     */
    if ( pWinStation->pWsx && pWinStation->pWsx->pWsxCdmDisconnect ) {
        pWinStation->pWsx->pWsxCdmDisconnect( pWinStation->pWsxContext,
                                              pWinStation->LogonId,
                                              pWinStation->hIca );
    }

    /*
     * If a reconnect info struct has been specified, then this is NOT
     * a terminate disconnect.  Save the current WinStation name,
     * WinStation and client configuration info, and license data.
     * Also disconnect the current stack and save the stack handle
     * and connection endpoint data.
     */
    if ( pReconnectInfo || fOwnsConsoleTerminal) {


        if ((pReconnectInfo == NULL) && fOwnsConsoleTerminal) {
            pReconnectInfo = &ConsoleReconnectInfo;
            if (ConsoleReconnectInfo.hIca) {
               CleanupReconnect(&ConsoleReconnectInfo);
               RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
            }
        }

        if (!CopyReconnectInfo(pWinStation, pReconnectInfo))
        {
            Status = STATUS_UNSUCCESSFUL;
            goto badstackopen;

        }
        
        /*
         * Copy console owner info
         */
        pReconnectInfo->fOwnsConsoleTerminal = fOwnsConsoleTerminal;

   /*
    * This is a terminate disconnect.
    * If there is a connection endpoint, then close it now.
    */
    } else if (pWinStation->pEndpoint ) {

        /*
         *  First grab any autoreconnect info state and save it
         *  in the winstation
         */

        TRACE((hTrace,TC_ICASRV,TT_API1,
               "TERMSRV: Disconnecting - grabbing SC autoreconnect from stack\n"));

        if (pWinStation->pWsx &&
            pWinStation->pWsx->pWsxEscape) {
            Status = pWinStation->pWsx->pWsxEscape(
                        pWinStation->pWsxContext,
                        GET_SC_AUTORECONNECT_INFO,
                        NULL,
                        0,
                        &SCAutoReconnectInfo,
                        sizeof(SCAutoReconnectInfo),
                        &BytesGot);

            if (NT_SUCCESS(Status)) {

                // 
                // Valid the length of the SC info and save it into the winstation
                // this will be used later on. We need to grab the info now
                // before the stack handle is closed as we won't be able to IOCTL
                // down to the stack at autoreconnect time.
                //

                if (SCAutoReconnectInfo.cbAutoReconnectInfo ==
                    sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits)) {

                    TRACE((hTrace,TC_ICASRV,TT_API1,
                           "TERMSRV: Disconnecting - got SC ARC from stack\n"));

                    pWinStation->AutoReconnectInfo.Valid = TRUE;
                    memcpy(&pWinStation->AutoReconnectInfo.ArcRandomBits,
                           &SCAutoReconnectInfo.AutoReconnectInfo,
                           sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits));
                }
                else {
                    TRACE((hTrace,TC_ICASRV,TT_ERROR,
                           "TERMSRV: Disconnecting - got invalid len SC ARC from stack\n"));
                    ResetAutoReconnectInfo(pWinStation);
                }
            }
            else {

                TRACE((hTrace,TC_ICASRV,TT_API1,
                       "TERMSRV: Disconnecting - did not get SC ARC from stack\n"));
                ResetAutoReconnectInfo(pWinStation);
            }
        }

        /*
         * First notify Wsx that connection is going away
         */
        WsxBrokenConnection( pWinStation );

        if (pWinStation->hStack != NULL) {
            Status = IcaStackConnectionClose( pWinStation->hStack,
                                              &pWinStation->Config,
                                              pWinStation->pEndpoint,
                                              pWinStation->EndpointLength );
            ASSERT( NT_SUCCESS(Status) );
            if ( !NT_SUCCESS(Status) ) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: StackConnectionClose failed LogonId=%d Status=0x%x\n",
                       pWinStation->LogonId, Status ));
            }
        }

        MemFree( pWinStation->pEndpoint );
        pWinStation->pEndpoint = NULL;
        pWinStation->EndpointLength = 0;

        /*
         * Close the stack and reopen it.
         * What we really need is a function to unload the stack drivers
         * but leave the stack handle open.
         */

        if (pWinStation->hStack != NULL) {
            Status = IcaStackClose( pWinStation->hStack );
            ASSERT( NT_SUCCESS( Status ) );
            pWinStation->hStack = NULL;
        }

        Status = IcaStackOpen( pWinStation->hIca, Stack_Primary,
                               (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );

        /*
         * Since this is a terminate disconnect, clear all client
         * license data and indicate it no longer holds a license.
         */
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxClearContext ) {
            pWinStation->pWsx->pWsxClearContext( pWinStation->pWsxContext );
        }
        /*
         * Session 0, we want to get rid of any protocol extension so that next remote
         * connection could happen with a different protocol.
         */
        if (pWinStation->LogonId == 0 ) {
            if ( pWinStation->pWsxContext ) {
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxWinStationRundown ) {
                    pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
                }
                pWinStation->pWsxContext = NULL;
            }
            pWinStation->pWsx = NULL;
            pWinStation->Client.ProtocolType = PROTOCOL_CONSOLE;
        }
    }

    /*
     *  Cancel timers
     */
    if ( pWinStation->fIdleTimer ) {
        pWinStation->fIdleTimer = FALSE;
        IcaTimerClose( pWinStation->hIdleTimer );
    }
    if ( pWinStation->fLogonTimer ) {
        pWinStation->fLogonTimer = FALSE;
        IcaTimerClose( pWinStation->hLogonTimer );
    }

    // Send Audit Information only for actual disconnects 
    if (pWinStation->UserName && (wcslen(pWinStation->UserName) > 0)) {
        AuditEvent( pWinStation, SE_AUDITID_SESSION_DISCONNECTED );
    }

    // before we change state to disconnect, we want to give repopulating thread
    // enough time to pick up winstation/report to SD, then this thread
    // can notify SD to change state to disconnect.
    // wait here before we ENTERCRIT() because repopulate thread
    // also doing the same sequence.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
        SessDirWaitForRepopulate();
    }

    {
        ENTERCRIT( &WinStationListLock );
        (VOID) NtQuerySystemTime( &pWinStation->DisconnectTime );

        if ((pWinStation->State == State_Active) || (pWinStation->State == 
                State_Shadow)) {
            // If the session was active or in a shadow state and is being
            // disconnected...
            //
            // Copy off the session ID and disconnection FileTime for the
            // session directory call below. We do not want to hold locks when
            // calling the directory interface.
            memcpy(&DiscTime, &pWinStation->DisconnectTime, sizeof(DiscTime));
            SessionID = pWinStation->LogonId;

            // Set flag that we need to notify the session directory.
            bInformSessionDirectory = TRUE;
        }

        pWinStation->State = State_Disconnected;
        RtlZeroMemory( pWinStation->WinStationName,
                       sizeof(pWinStation->WinStationName) );
        RtlZeroMemory( pWinStation->ListenName,
                       sizeof(pWinStation->ListenName) );

        // Keep track of disconnected session count for Load Balancing 
        // Indicator.
        WinStationDiscCount++;

        LEAVECRIT( &WinStationListLock );

        NotifySystemEvent( WEVENT_DISCONNECT | WEVENT_STATECHANGE );
    }

    // Call the session directory to inform of the disconnection.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer && bInformSessionDirectory)
        SessDirNotifyDisconnection(SessionID, DiscTime);

    TRACE((hTrace, TC_ICASRV, TT_API1, 
            "TERMSRV: WinStationDoDisconnect, rc=0x0\n" ));

    Status = NotifyDisconnect(pWinStation, fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(("NotifyConsoleDisconnect failed, SessionId = %d, Status = "
                "%d", pWinStation->LogonId, Status));
    }
    pWinStation->StateFlags &=  ~WSF_ST_IN_DISCONNECT;

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

badstackopen:
badwin32disconnect:
    TRACE((hTrace, TC_ICASRV, TT_API1, "TERMSRV: WinStationDoDisconnect, rc=0x%x\n", Status ));
    pWinStation->StateFlags &=  ~WSF_ST_IN_DISCONNECT;
    
    return Status;
}


/*******************************************************************************
 * ImperonateClient
 *
 *   Giving a client primary, make the calling thread impersonate the client
 *
 * ENTRY:
 *    ClientToken (input)
 *       A client primary token
 *    pImpersonationToken (output)
 *       Pointer to an impersonation token
 ******************************************************************************/
NTSTATUS _ImpersonateClient(HANDLE ClientToken, HANDLE *pImpersonationToken)
{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;

    //
    // ClientToken is a primary token - create an impersonation token
    // version of it so we can set it on our thread
    //
    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               pImpersonationToken );
    if ( !NT_SUCCESS( Status ) )
    {
        TRACE( ( hTrace, TC_ICASRV, TT_ERROR, "ImpersonateClient: cannot get impersonation token: 0x%x\n", Status ) );
        return( Status );
    }

    //
    // Impersonate the client
    //
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     ( PVOID )pImpersonationToken,
                                     ( ULONG )sizeof( HANDLE ) );
    if ( !NT_SUCCESS( Status ) )
    {
        TRACE( ( hTrace, TC_ICASRV, TT_ERROR, "ImpersonateClient: cannot impersonate client: 0x%x\n", Status ) );
    }

    return Status;
}

/*******************************************************************************
 *  WinStationDoReconnect
 *
 *   Send connect Api message to a WinStation.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to connect
 *    pReconnectInfo (input)
 *       Pointer to RECONNECT_INFO buffer
 ******************************************************************************/
NTSTATUS WinStationDoReconnect(
        PWINSTATION pWinStation,
        PRECONNECT_INFO pReconnectInfo)
{
    WINSTATION_APIMSG ReconnectMsg;
    NTSTATUS Status;
    BOOLEAN fDisableCdm;
    BOOLEAN fDisableCpm;
    BOOLEAN fDisableLPT;
    BOOLEAN fDisableCcm;
    BOOLEAN fDisableClip;
    SHADOWCLASS Shadow;
    NTSTATUS TempStatus;
    PWINSTATIONCONFIG2 pCurConfig = NULL;
    PWINSTATIONCLIENT pCurClient = NULL;

    // WinStation should not currently be connected
    ASSERT( pWinStation->pEndpoint == NULL );

    // Mark that Reconnect is still pending for this winstation
    pWinStation->fReconnectPending = TRUE; 

    // Check if we r going to reconnect a session to the Console - this Flag is used in SendWinStationCommand
    pWinStation->fReconnectingToConsole = pReconnectInfo->fOwnsConsoleTerminal ;

    // Save the shadow state
    Shadow = pWinStation->Config.Config.User.Shadow;

    //
    // Allocate and initialize CurConfig struct
    //

    if ( (pCurConfig = MemAlloc( sizeof(WINSTATIONCONFIG2) )) == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto nomem;
    }
    RtlZeroMemory( pCurConfig, sizeof(WINSTATIONCONFIG2) ); 

    //
    // Allocate and initialize CurClient struct
    //
    if ( (pCurClient = MemAlloc( sizeof(WINSTATIONCLIENT) )) == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto nomem;
    }
    RtlZeroMemory( pCurClient, sizeof(WINSTATIONCLIENT) ); 

    //
    // Config info has to be set prior to calling CSRSS. CSRSS notifies winlogon
    // which in turn sends reconnect messages to notification dlls. We query 
    // protocol info from termsrv notification dll which is stored in config
    // data
    //
    *pCurConfig = pWinStation->Config; 
    pWinStation->Config = pReconnectInfo->Config;

    *pCurClient = pWinStation->Client;
    pWinStation->Client = pReconnectInfo->Client;

    if ((pWinStation->LogonId == 0) && (pWinStation->UserName[0] == L'\0')) {
       ReconnectMsg.ApiNumber = SMWinStationNotify;
       ReconnectMsg.WaitForReply = TRUE;
       ReconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_PreReconnect;
       Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 60 );
    }

    /*
     * Unconditionally, we will send the PreReconnectDesktopSwitch event.
     */
    ReconnectMsg.ApiNumber = SMWinStationNotify;
    ReconnectMsg.WaitForReply = TRUE;
    ReconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_PreReconnectDesktopSwitch;
    Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 60 );

    /*
     * Close the current stack and reconnect the saved stack to this WinStation
     */
    if (pWinStation->hStack != NULL) {
        IcaStackClose( pWinStation->hStack );
        pWinStation->hStack = NULL;
    }

    Status = IcaStackReconnect( pReconnectInfo->hStack,
                                pWinStation->hIca,
                                pWinStation,
                                pWinStation->LogonId );
    if ( !NT_SUCCESS( Status ) ){
        pWinStation->Config = *pCurConfig;
        pWinStation->Client = *pCurClient;
        goto badstackreconnect;
    }

    /*
     * Save stack and endpoint data
     */
    pWinStation->hStack = pReconnectInfo->hStack;
    pWinStation->pEndpoint = pReconnectInfo->pEndpoint;
    pWinStation->EndpointLength = pReconnectInfo->EndpointLength;

    /* 
     * Save the notification Credentials in the new winstation
     */
    if (pReconnectInfo->pNotificationCredentials) {

        if (pWinStation->pNewNotificationCredentials == NULL) {
            pWinStation->pNewNotificationCredentials = MemAlloc(sizeof(CLIENTNOTIFICATIONCREDENTIALS)); 
            if (pWinStation->pNewNotificationCredentials == NULL) {
                Status = STATUS_NO_MEMORY ; 
                goto nomem ; 
            }
        }

        RtlCopyMemory( pWinStation->pNewNotificationCredentials->Domain,
                       pReconnectInfo->pNotificationCredentials->Domain,
                       sizeof(pReconnectInfo->pNotificationCredentials->Domain) );

        RtlCopyMemory( pWinStation->pNewNotificationCredentials->UserName,
                       pReconnectInfo->pNotificationCredentials->UserName,
                       sizeof(pReconnectInfo->pNotificationCredentials->UserName) );

    } else {
        pWinStation->pNewNotificationCredentials = NULL; 
    }

    pReconnectInfo->hStack = NULL;
    pReconnectInfo->pEndpoint = NULL;
    pReconnectInfo->EndpointLength = 0;
    pReconnectInfo->pNotificationCredentials = NULL;

    /*
     * Copy remote ip to winstation
     */

    if( pWinStation->pLastClientAddress != NULL )
    {
        MemFree( pWinStation->pLastClientAddress );
        pWinStation->pLastClientAddress = NULL;
    }

    if( pReconnectInfo->pRememberedAddress != NULL )
    {        
        pWinStation->pLastClientAddress = pReconnectInfo->pRememberedAddress;
        pReconnectInfo->pRememberedAddress = NULL;
    }      


    /*
     * Tell Win32k about the reconnect
     */
    ReconnectMsg.ApiNumber = SMWinStationDoReconnect;
    ReconnectMsg.u.DoReconnect.fMouse = (BOOLEAN)pReconnectInfo->Client.fMouse;
    ReconnectMsg.u.DoReconnect.fClientDoubleClickSupport =
                (BOOLEAN)pReconnectInfo->Client.fDoubleClickDetect;
    ReconnectMsg.u.DoReconnect.fEnableWindowsKey =
                (BOOLEAN)pReconnectInfo->Client.fEnableWindowsKey;
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.WinStationName,
                   pReconnectInfo->WinStationName,
                   sizeof(WINSTATIONNAME) );
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.AudioDriverName,
                   pReconnectInfo->Client.AudioDriverName,
                   sizeof( ReconnectMsg.u.DoReconnect.AudioDriverName ) );
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.DisplayDriverName,
                   pReconnectInfo->DisplayDriverName,
                   sizeof( ReconnectMsg.u.DoReconnect.DisplayDriverName ) );
    RtlCopyMemory( ReconnectMsg.u.DoReconnect.ProtocolName,
                   pReconnectInfo->ProtocolName,
                   sizeof( ReconnectMsg.u.DoReconnect.ProtocolName ) );

    /*
     * Set the display resolution information in the message for reconnection
     */
    ReconnectMsg.u.DoReconnect.HRes = pReconnectInfo->Client.HRes;
    ReconnectMsg.u.DoReconnect.VRes = pReconnectInfo->Client.VRes;
    ReconnectMsg.u.DoReconnect.ProtocolType = pReconnectInfo->Client.ProtocolType;
    ReconnectMsg.u.DoReconnect.fDynamicReconnect  = (BOOLEAN)(pWinStation->Config.Wd.WdFlag & WDF_DYNAMIC_RECONNECT );

    /*
     * Translate the color to the format excpected in winsrv
     */
    switch (pReconnectInfo->Client.ColorDepth) {
        case 1:
            ReconnectMsg.u.DoReconnect.ColorDepth=4 ; // 16 colors
            break;
        case 2:
            ReconnectMsg.u.DoReconnect.ColorDepth=8 ; // 256
            break;
        case 4:
            ReconnectMsg.u.DoReconnect.ColorDepth= 16;// 64K
            break;
        case 8:
            ReconnectMsg.u.DoReconnect.ColorDepth= 24;// 16M
            break;
#define DC_HICOLOR
#ifdef DC_HICOLOR
        case 16:
            ReconnectMsg.u.DoReconnect.ColorDepth= 15;// 32K
            break;
#endif
        default:
            ReconnectMsg.u.DoReconnect.ColorDepth=8 ;
            break;
    }

    ReconnectMsg.u.DoReconnect.KeyboardType        = pWinStation->Client.KeyboardType;
    ReconnectMsg.u.DoReconnect.KeyboardSubType     = pWinStation->Client.KeyboardSubType;
    ReconnectMsg.u.DoReconnect.KeyboardFunctionKey = pWinStation->Client.KeyboardFunctionKey;

    if (pWinStation->LogonId == 0 || g_bPersonalTS) {
        if (pWinStation->hWinmmConsoleAudioEvent) {
            if (pWinStation->Client.fRemoteConsoleAudio) {
                // set the remoting audio on console flag
                SetEvent(pWinStation->hWinmmConsoleAudioEvent);

            }
            else {
                // don't set the remoting audio on console flag
                ResetEvent(pWinStation->hWinmmConsoleAudioEvent);
            }
        }        
        if ( pWinStation->hRDPAudioDisabledEvent )
        {
            if ( pWinStation->Config.Config.User.fDisableCam )
            {
                SetEvent( pWinStation->hRDPAudioDisabledEvent );
            } else {
                ResetEvent( pWinStation->hRDPAudioDisabledEvent );
            }
        }
    }


    if (WaitForSingleObject(pWinStation->hReconnectReadyEvent, 45*1000) != WAIT_OBJECT_0) {
    
       DbgPrint("Wait Failed for hReconnectReadyEvent for Session %d\n", pWinStation->LogonId);
       SetEvent(pWinStation->hReconnectReadyEvent);
    }

    Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 600 );
    if ( !NT_SUCCESS(Status) ) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: CSR DoReconnect failed LogonId=%d Status=0x%x\n",
               pWinStation->LogonId, Status ));
        pWinStation->Config = *pCurConfig;
        pWinStation->Client = *pCurClient;
        goto badreconnect;
    } else {
        pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;
    }

    //
    // Update protocol and display driver names.
    //
    RtlCopyMemory( pWinStation->ProtocolName,
                   pReconnectInfo->ProtocolName,
                   sizeof(pWinStation->ProtocolName) );
    RtlCopyMemory( pWinStation->DisplayDriverName,
                   pReconnectInfo->DisplayDriverName,
                   sizeof(pWinStation->DisplayDriverName) );
    
    /*
     * Copy console owner info
     */
    pWinStation->fOwnsConsoleTerminal = pReconnectInfo->fOwnsConsoleTerminal;

    //
    // Set session time zone information.
    //
    if(pWinStation->LogonId != 0 && !pWinStation->fOwnsConsoleTerminal &&
        RegIsTimeZoneRedirectionEnabled())
    {
        WINSTATION_APIMSG TimezoneMsg;

        memset( &TimezoneMsg, 0, sizeof(TimezoneMsg) );
        TimezoneMsg.ApiNumber = SMWinStationSetTimeZone;
        memcpy(&(TimezoneMsg.u.SetTimeZone.TimeZone),&(pReconnectInfo->Client.ClientTimeZone),
                    sizeof(TS_TIME_ZONE_INFORMATION));
        SendWinStationCommand( pWinStation, &TimezoneMsg, 600 );
    }
    
    /*
     * Close temporary ICA connection that was opened for the reconnect
     */
    IcaClose( pReconnectInfo->hIca );
    pReconnectInfo->hIca = NULL;

    /*
     * Move all of the licensing stuff to the new WinStation
     */

    /*
     * we may not have pWsx if the ReconnectInfo is from a session
     * that was connected to the local console
     */
    if ( pReconnectInfo->pWsxContext ) {
        if ( pWinStation->pWsx == NULL ) {
            //
            // This means that we are reconnecting remotely to a session
            // that comes from the console. So create a new extension.
            //
            pWinStation->pWsx = FindWinStationExtensionDll(
                            pWinStation->Config.Wd.WsxDLL,
                            pWinStation->Config.Wd.WdFlag );

            //
            //  Initialize winstation extension context structure
            //
            if ( pWinStation->pWsx &&
                 pWinStation->pWsx->pWsxWinStationInitialize ) {
                Status = pWinStation->pWsx->pWsxWinStationInitialize( 
                        &pWinStation->pWsxContext);

                if (!NT_SUCCESS(Status)) {
                    pWinStation->pWsx = NULL;
                }
            }

            if ( pWinStation->pWsx &&
                 pWinStation->pWsx->pWsxWinStationReInitialize ) {
                WSX_INFO WsxInfo;

                WsxInfo.Version = WSX_INFO_VERSION_1;
                WsxInfo.hIca = pWinStation->hIca;
                WsxInfo.hStack = pWinStation->hStack;
                WsxInfo.SessionId = pWinStation->LogonId;
                WsxInfo.pDomain = pWinStation->Domain;
                WsxInfo.pUserName = pWinStation->UserName;

                Status = pWinStation->pWsx->pWsxWinStationReInitialize( 
                        pWinStation->pWsxContext, &WsxInfo );

                if (!NT_SUCCESS(Status)) {
                    pWinStation->pWsx = NULL;
                }
            }                    
        }

        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxCopyContext ) {
            pWinStation->pWsx->pWsxCopyContext( pWinStation->pWsxContext,
                                                pReconnectInfo->pWsxContext );
        }
        if ( pReconnectInfo->pWsx &&
             pReconnectInfo->pWsx->pWsxWinStationRundown ) {
            pReconnectInfo->pWsx->pWsxWinStationRundown( pReconnectInfo->pWsxContext );
        }
        pReconnectInfo->pWsxContext = NULL;

    } else { // pReconnectInfo->pWsxContext == NULL
        //
        // This means that we are reconnecting to the console.
        //
        if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxWinStationRundown ) {
            //
            // Reconnecting a remote session to the console.
            // Delete the extension.
            //
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
        pWinStation->pWsx = NULL;

        //
        // In the case where both are NULL, we are reconnecting 
        // to the console a session that comes from the console.
        //
    }

    //
    // Anytime we change state, we need to make sure session directory 
    // does not pick up wrong state.  
    // We need this because Repopulate release the lock before calling
    // SD so there might be small timing that we might send this reconnect
    // first because repopulate come back.
    //
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
        SessDirWaitForRepopulate();
    }

    RtlEnterCriticalSection( &WinStationListLock );
    if (pWinStation->UserName[0] != (WCHAR) 0) {
        pWinStation->State = State_Active;
    } else {
        pWinStation->State = State_Connected;
    }
    RtlCopyMemory( pWinStation->WinStationName,
                   pReconnectInfo->WinStationName,
                   sizeof(WINSTATIONNAME) );

    /*
     * Copy the original listen name for instance checking.
     */
    RtlCopyMemory( pWinStation->ListenName,
                   pReconnectInfo->ListenName,
                   sizeof(WINSTATIONNAME) );

    // Keep track of disconnected session count for Load Balancing Indicator
    WinStationDiscCount--;

    RtlLeaveCriticalSection( &WinStationListLock );

    /*
     * Disable virtual channel flags are from the transport setup.
     * Do not overwrite them.
     */
    fDisableCdm = (BOOLEAN) pWinStation->Config.Config.User.fDisableCdm;
    fDisableCpm = (BOOLEAN) pWinStation->Config.Config.User.fDisableCpm;
    fDisableLPT = (BOOLEAN) pWinStation->Config.Config.User.fDisableLPT;
    fDisableCcm = (BOOLEAN) pWinStation->Config.Config.User.fDisableCcm;
    fDisableClip = (BOOLEAN) pWinStation->Config.Config.User.fDisableClip;

    pWinStation->Config = pReconnectInfo->Config;

    pWinStation->Config.Config.User.fDisableCdm = fDisableCdm;
    pWinStation->Config.Config.User.fDisableCpm = fDisableCpm;
    pWinStation->Config.Config.User.fDisableLPT = fDisableLPT;
    pWinStation->Config.Config.User.fDisableCcm = fDisableCcm;
    pWinStation->Config.Config.User.fDisableClip = fDisableClip;
    pWinStation->Config.Config.User.Shadow = Shadow;

    /*
     * Disable virtual channels if needed.
     */
    VirtualChannelSecurity( pWinStation );
    
    /*
     * Notify the CDM channel of reconnection.
     */
    
    if ( pWinStation->pWsx &&
            pWinStation->pWsx->pWsxCdmConnect ) {
        (VOID) pWinStation->pWsx->pWsxCdmConnect( pWinStation->pWsxContext,
                                                      pWinStation->LogonId,
                                                      pWinStation->hIca );
    }

    /*
     * Reset any autoreconnect information prior to reconnection
     * as it is stale. New information will be generated by the stack
     * when login completes.
     */
    ResetAutoReconnectInfo(pWinStation);

    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxLogonNotify ) {

        PWCHAR pUserNameToSend, pDomainToSend ;
        
        // Use the New notification credentials sent from Gina for the call below if they are available
        if (pWinStation->pNewNotificationCredentials) {
            pUserNameToSend = pWinStation->pNewNotificationCredentials->UserName;
            pDomainToSend = pWinStation->pNewNotificationCredentials->Domain;
        } else {
            pUserNameToSend = pWinStation->UserName;
            pDomainToSend = pWinStation->Domain ;
        }

        Status = pWinStation->pWsx->pWsxLogonNotify( pWinStation->pWsxContext,
                                                   pWinStation->LogonId,
                                                   NULL,
                                                   pDomainToSend,
                                                   pUserNameToSend );

        if (pWinStation->pNewNotificationCredentials != NULL) {
            MemFree(pWinStation->pNewNotificationCredentials);
            pWinStation->pNewNotificationCredentials = NULL;
        }

        if(!NT_SUCCESS(Status)) {
            TRACE((hTrace, TC_ICASRV, TT_API1,
                   "TERMSRV: WinStationDoReconnect: LogonNotify rc=0x%x\n",
                   Status ));
        }
    }

    NotifySystemEvent( WEVENT_CONNECT | WEVENT_STATECHANGE );

    /*
     * Cleanup any allocated buffers.
     * The endpoint buffer was transfered to the WinStation above.
     */
    pReconnectInfo->pEndpoint = NULL;
    pReconnectInfo->EndpointLength = 0;

    /*
     * Set connect time and stop disconnect timer
     */
    NtQuerySystemTime(&pWinStation->ConnectTime);
    if (pWinStation->fDisconnectTimer) {
        pWinStation->fDisconnectTimer = FALSE;
        IcaTimerClose( pWinStation->hDisconnectTimer );
    }

    /*
     *  Start logon timers
     */
    StartLogonTimers(pWinStation);

    // Notify the session directory of the reconnection.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
        TSSD_ReconnectSessionInfo ReconnInfo;

        ReconnInfo.SessionID = pWinStation->LogonId;
        ReconnInfo.TSProtocol = pWinStation->Client.ProtocolType;
        ReconnInfo.ResolutionWidth = pWinStation->Client.HRes;
        ReconnInfo.ResolutionHeight = pWinStation->Client.VRes;
        ReconnInfo.ColorDepth = pWinStation->Client.ColorDepth;
        SessDirNotifyReconnection(pWinStation, &ReconnInfo);
    }

    TRACE((hTrace, TC_ICASRV, TT_API1, "TERMSRV: WinStationDoReconnect, rc=0x0\n" ));
    
    AuditEvent( pWinStation, SE_AUDITID_SESSION_RECONNECTED );

    /*
     * Tell csrss to notify winlogon for the reconnect then notify any process
     * that registred for notification.
     */

    ReconnectMsg.ApiNumber = SMWinStationNotify;
    ReconnectMsg.WaitForReply = FALSE;
    ReconnectMsg.u.DoNotify.NotifyEvent = WinStation_Notify_Reconnect;
    Status = SendWinStationCommand( pWinStation, &ReconnectMsg, 0 );

    Status = NotifyConnect(pWinStation, pWinStation->fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
            DBGPRINT(("NotifyConsoleConnect failed, SessionId = %d, Status = %d", pWinStation->LogonId, Status));
    }

    // Free up allocated Memory
    if (pCurConfig != NULL) {
        MemFree( pCurConfig );
        pCurConfig = NULL; 
    }
    if (pCurClient != NULL) {
        MemFree( pCurClient ); 
        pCurClient = NULL;
    }

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    // Since the winstation has reconnected, we can allow further autoreconnects
    pWinStation->fDisallowAutoReconnect = FALSE;

    // Reset ReconnectPending Flag
    pWinStation->fReconnectPending = FALSE; 
    pWinStation->fReconnectingToConsole = FALSE;

    return STATUS_SUCCESS;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * Failure from Win32 reconnect call.
     * Disconnect the stack again, and indicate the WinStation
     * does not have a stack or endpoint connection.
     */
badreconnect:
    TempStatus = IcaStackDisconnect( pWinStation->hStack,
                                     pReconnectInfo->hIca,
                                     NULL );
    //ASSERT( NT_SUCCESS( TempStatus ) );

    pReconnectInfo->hStack = pWinStation->hStack;
    pReconnectInfo->pEndpoint = pWinStation->pEndpoint;
    pReconnectInfo->EndpointLength = pWinStation->EndpointLength;
    pWinStation->hStack = NULL;
    pWinStation->pEndpoint = NULL;
    pWinStation->EndpointLength = 0;

badstackreconnect:
    TempStatus = IcaStackOpen( pWinStation->hIca, Stack_Primary,
                               (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );
    //ASSERT( NT_SUCCESS( TempStatus ) ); // don't know how to handle any error here

nomem:
    // Free up allocated Memory
    if (pCurConfig != NULL) {
        MemFree( pCurConfig );
        pCurConfig = NULL; 
    }
    if (pCurClient != NULL) {
        MemFree( pCurClient ); 
        pCurClient = NULL;
    }

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    TRACE((hTrace, TC_ICASRV, TT_API1, "TERMSRV: WinStationDoReconnect, rc=0x%x\n", Status ));

    // Reset ReconnectPending Flag
    pWinStation->fReconnectPending = FALSE; 
    pWinStation->fReconnectingToConsole = FALSE;

    return( Status );
}

/*******************************************************************************
 *  WsxBrokenConnection
 *
 *   Send broken connection notification to the WinStation extension DLL
 ******************************************************************************/
VOID WsxBrokenConnection(PWINSTATION pWinStation)
{
    /*
     * Only send notification if there is a reason
     */
    if ( pWinStation->BrokenReason ) {
        if ( pWinStation->pWsx && pWinStation->pWsx->pWsxBrokenConnection ) {
            ICA_BROKEN_CONNECTION Broken;

            Broken.Reason = pWinStation->BrokenReason;
            Broken.Source = pWinStation->BrokenSource;
            pWinStation->pWsx->pWsxBrokenConnection( pWinStation->pWsxContext,
                                                     pWinStation->hStack,
                                                     &Broken );
        }

        /*
         * Clear these once we have tried to send them
         */
        pWinStation->BrokenReason = 0;
        pWinStation->BrokenSource = 0;
    }
}


/*******************************************************************************
 *  CleanupReconnect
 *
 *   Cleanup the specified RECONNECT_INFO structure
 *
 * ENTRY:
 *    pReconnectInfo (input)
 *       Pointer to RECONNECT_INFO buffer
 ******************************************************************************/
VOID CleanupReconnect(PRECONNECT_INFO pReconnectInfo)
{
    NTSTATUS Status;

    /*
     * If there is a connection endpoint, then close it now.
     * When done, we also free the endpoint structure.
     */
    if ( (pReconnectInfo->pEndpoint != NULL) && (pReconnectInfo->hStack != NULL)) {
        Status = IcaStackConnectionClose( pReconnectInfo->hStack,
                                          &pReconnectInfo->Config,
                                          pReconnectInfo->pEndpoint,
                                          pReconnectInfo->EndpointLength );

        ASSERT( Status == STATUS_SUCCESS );
        MemFree( pReconnectInfo->pEndpoint );
        pReconnectInfo->pEndpoint = NULL;
    }

    if ( pReconnectInfo->pWsxContext ) {
        if ( pReconnectInfo->pWsx &&
             pReconnectInfo->pWsx->pWsxWinStationRundown ) {
            pReconnectInfo->pWsx->pWsxWinStationRundown( pReconnectInfo->pWsxContext );
        }
        pReconnectInfo->pWsxContext = NULL;
    }

    if ( pReconnectInfo->hStack ) {
        IcaStackClose( pReconnectInfo->hStack );
        pReconnectInfo->hStack = NULL;
    }

    if ( pReconnectInfo->hIca ) {
        IcaClose( pReconnectInfo->hIca );
        pReconnectInfo->hIca = NULL;
    }

    if( pReconnectInfo->pRememberedAddress != NULL )
    {
        MemFree( pReconnectInfo->pRememberedAddress );
        pReconnectInfo->pRememberedAddress = NULL;
    }
}


NTSTATUS _CloseEndpoint(
        IN PWINSTATIONCONFIG2 pWinStationConfig,
        IN PVOID pEndpoint,
        IN ULONG EndpointLength,
        IN PWINSTATION pWinStation,
        IN BOOLEAN bNeedStack)
{
    HANDLE hIca;
    HANDLE hStack;
    NTSTATUS Status;

    /*
     * Open a stack handle that we can use to close the specified endpoint.
     */

    TRACE((hTrace, TC_ICASRV, TT_ERROR, 
          "TERMSRV: _CloseEndpoint [%p] on %s stack\n", 
           pEndpoint, bNeedStack ? "Temporary" : "Primary"));

    if (bNeedStack) {
        Status = IcaOpen( &hIca );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaStackOpen( hIca, Stack_Primary, NULL, NULL, &hStack );
            if ( NT_SUCCESS( Status ) ) {
                Status = IcaStackConnectionClose( hStack,
                                                  pWinStationConfig,
                                                  pEndpoint,
                                                  EndpointLength );
                IcaStackClose( hStack );
            }
            IcaClose( hIca );
        }
    }

    else {
        Status = IcaStackConnectionClose( pWinStation->hStack,
                                          pWinStationConfig,
                                          pEndpoint,
                                          EndpointLength );
    }
    
    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace, TC_ICASRV, TT_ERROR, 
               "TERMSRV: _CloseEndpoint failed [%s], Status=%x\n", 
               bNeedStack ? "Temporary" : "Primary", Status ));
    }

    return Status;
}


/*******************************************************************************
 *  WinStationExceptionFilter
 *
 *   Handle exception from a WinStation thread
 *
 * ENTRY:
 *    pExceptionInfo (input)
 *       pointer to EXCEPTION_POINTERS struct
 *
 * EXIT:
 *    EXCEPTION_EXECUTE_HANDLER -- always
 ******************************************************************************/
NTSTATUS WinStationExceptionFilter(
        PWSTR OutputString,
        PEXCEPTION_POINTERS pexi)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    MUTANT_BASIC_INFORMATION MutexInfo;
    NTSTATUS Status;

    DbgPrint( "TERMSRV: %S\n", OutputString );
    DbgPrint( "TERMSRV: ExceptionRecord=%p ContextRecord=%p\n",
              pexi->ExceptionRecord, pexi->ContextRecord );
    DbgPrint( "TERMSRV: Exception code=%08x, flags=%08x, addr=%p, IP=%p\n",
              pexi->ExceptionRecord->ExceptionCode,
              pexi->ExceptionRecord->ExceptionFlags,
              pexi->ExceptionRecord->ExceptionAddress,
              CONTEXT_TO_PROGRAM_COUNTER(pexi->ContextRecord) );
#ifdef i386
    DbgPrint( "TERMSRV: esp=%p ebp=%p\n",
              pexi->ContextRecord->Esp, pexi->ContextRecord->Ebp );
#endif
    DbgBreakPoint();

    /*
     * Lock the global WinStation critsec if we don't already own it
     */
    if ( NtCurrentTeb()->ClientId.UniqueThread != WinStationListLock.OwningThread )
        ENTERCRIT( &WinStationListLock );

    /*
     * Search the WinStation list to see if we had any locked
     */
    Head = &WinStationListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        Status = NtQueryMutant( pWinStation->Lock.Mutex, MutantBasicInformation,
                                &MutexInfo, sizeof(MutexInfo), NULL );
        if ( NT_SUCCESS( Status ) && MutexInfo.OwnedByCaller ) {
            ReleaseWinStation( pWinStation );
            break;  // OK to quit now, we should never lock more than one
        }
    }

    LEAVECRIT( &WinStationListLock );

    return EXCEPTION_EXECUTE_HANDLER;
}


/*******************************************************************************
 *  GetProcessLogonId
 *
 *   Get LogonId for a process
 *
 * ENTRY:
 *    ProcessHandle (input)
 *       handle of process to get LogonId for
 *    pLogonId (output)
 *       location to return LogonId of process
 ******************************************************************************/
NTSTATUS GetProcessLogonId(HANDLE Process, PULONG pLogonId)
{
    NTSTATUS Status;
    PROCESS_SESSION_INFORMATION ProcessInfo;

    /*
     * Get the LogonId for the process
     */
    *pLogonId = 0;
    Status = NtQueryInformationProcess( Process, ProcessSessionInformation,
                                        &ProcessInfo, sizeof( ProcessInfo ),
                                        NULL );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: GetProcessLogonId, Process=%x, Status=%x\n",
                  Process, Status ));
        return( Status );
    }

    *pLogonId = ProcessInfo.SessionId;
    return Status;
}


/*******************************************************************************
 *  SetProcessLogonId
 *
 *   Set LogonId for a process
 *
 * ENTRY:
 *    ProcessHandle (input)
 *       handle of process to set LogonId for
 *    LogonId (output)
 *       LogonId to set for process
 ******************************************************************************/
NTSTATUS SetProcessLogonId(HANDLE Process, ULONG LogonId)
{
    NTSTATUS Status;
    PROCESS_SESSION_INFORMATION ProcessInfo;

    /*
     * Set the LogonId for the process
     */
    ProcessInfo.SessionId = LogonId;
    Status = NtSetInformationProcess( Process, ProcessSessionInformation,
                                      &ProcessInfo, sizeof( ProcessInfo ) );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: SetProcessLogonId, Process=%x, Status=%x\n",
                  Process, Status ));
        return Status;
    }

    return Status;
}


/*******************************************************************************
 *  FindWinStationById
 *
 *   Find and lock a WinStation given its LogonId
 *
 * ENTRY:
 *    LogonId (input)
 *       LogonId of WinStation to find
 *    LockList (input)
 *       BOOLEAN indicating whether WinStationListLock should be
 *       left locked on return
 *
 * EXIT:
 *    On success - Pointer to WinStation
 *    On failure - NULL
 ******************************************************************************/
PWINSTATION FindWinStationById(ULONG LogonId, BOOLEAN LockList)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    PWINSTATION pFoundWinStation = NULL;
    ULONG   uCount;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the given logonid.
     */
searchagain:
    uCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( pWinStation->LogonId == LogonId ) {
           uCount++;

            /*
             * Now try to lock the WinStation.
             */
            if (pFoundWinStation == NULL){
               if ( !LockRefLock( &pWinStation->Lock ) )
                  goto searchagain;
                  pFoundWinStation = pWinStation;
            }
#if DBG
#else
    break;
#endif
        }
    }

    ASSERT((uCount <= 1) || (LogonId== -1)  );

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    if ( !LockList )
        LEAVECRIT( &WinStationListLock );

    if (pFoundWinStation == NULL) {
        TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: FindWinStationById: %d (not found)\n", LogonId ));
    }


    return pFoundWinStation;
}

BOOL
FindFirstListeningWinStationName( PWINSTATIONNAMEW pListenName, PWINSTATIONCONFIG2 pConfig )
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    BOOL bFound = FALSE;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

searchagain:
    /*
     * Search the list for a WinStation with the given name.
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( pWinStation->Flags & WSF_LISTEN && pWinStation->Client.ProtocolType == PROTOCOL_RDP) {

            // try to lock winstation.
            if ( !LockRefLock( &pWinStation->Lock ) )
                goto searchagain;

            CopyMemory( pConfig, &(pWinStation->Config), sizeof(WINSTATIONCONFIG2) );
            lstrcpy( pListenName, pWinStation->WinStationName );
            ReleaseWinStation( pWinStation );
            bFound = TRUE;
        }
    }

    LEAVECRIT( &WinStationListLock );

    TRACE((hTrace,TC_ICASRV,TT_API3,"TERMSRV: FindFirstListeningWinStationName: %ws\n",
            (bFound) ? pListenName : L"Not Found" ));

    return bFound;
}

/*******************************************************************************
 *  FindWinStationByName
 *
 *   Find and lock a WinStation given its Name
 *
 * ENTRY:
 *    WinStationName (input)
 *       Name of WinStation to find
 *    LockList (input)
 *       BOOLEAN indicating whether WinStationListLock should be
 *       left locked on return
 *
 * EXIT:
 *    On success - Pointer to WinStation
 *    On failure - NULL
 ******************************************************************************/
PWINSTATION FindWinStationByName(LPWSTR WinStationName, BOOLEAN LockList)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the given name.
     */
searchagain:
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( !_wcsicmp( pWinStation->WinStationName, WinStationName ) ) {

            /*
             * Now try to lock the WinStation.  If this succeeds,
             * then ensure it still has the name we're searching for.
             */
            if ( !LockRefLock( &pWinStation->Lock ) )
                goto searchagain;
            if ( _wcsicmp( pWinStation->WinStationName, WinStationName ) ) {
                ReleaseWinStation( pWinStation );
                goto searchagain;
            }

            /*
             * If the WinStationList lock should not be held, then release it now.
             */
            if ( !LockList )
                LEAVECRIT( &WinStationListLock );

            TRACE((hTrace,TC_ICASRV,TT_API3,"TERMSRV: FindWinStationByName: %S, LogonId %u\n",
                    WinStationName, pWinStation->LogonId ));
            return( pWinStation );
        }
    }

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    if ( !LockList )
        LEAVECRIT( &WinStationListLock );

    TRACE((hTrace,TC_ICASRV,TT_API3,"TERMSRV: FindWinStationByName: %S, (not found)\n",
            WinStationName ));
    return NULL;
}


/*******************************************************************************
 *  FindIdleWinStation
 *
 *   Find and lock an idle WinStation
 *
 * EXIT:
 *    On success - Pointer to WinStation
 *    On failure - NULL
 ******************************************************************************/
PWINSTATION FindIdleWinStation()
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    BOOLEAN bFirstTime = TRUE;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for an idle WinStation
     */
searchagain:
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( (pWinStation->Flags & WSF_IDLE) &&
             !(pWinStation->Flags & WSF_IDLEBUSY) &&
             !pWinStation->Starting ) { 

            /*
             * Now try to lock the WinStation.  If this succeeds,
             * then ensure it is still marked as idle.
             */
            if ( !LockRefLock( &pWinStation->Lock ) ) {
                goto searchagain;
            }
            if ( !(pWinStation->Flags & WSF_IDLE) ||
                 (pWinStation->Flags & WSF_IDLEBUSY) ||
                 pWinStation->Starting ) {
                ReleaseWinStation( pWinStation );
                goto searchagain;
            }

            LEAVECRIT( &WinStationListLock );
            return( pWinStation );
        }
    }

    LEAVECRIT( &WinStationListLock );

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: FindIdleWinStation: (none found)\n" ));
    return NULL;
}


/*******************************************************************************
 *  CountWinStationType
 *
 *   Count the number of matching Winstation Listen Names
 *
 * ENTRY:
 *    Listen Name
 *
 *    bActiveOnly if TRUE, count only active WinStations
 *
 * EXIT:
 *    Number
 ******************************************************************************/
ULONG CountWinStationType(
    PWINSTATIONNAME pListenName,
    BOOLEAN bActiveOnly,
    BOOLEAN bLockHeld)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    ULONG Count = 0;

    Head = &WinStationListHead;

    if ( !bLockHeld ) {
        ENTERCRIT( &WinStationListLock );
    }

    /*
     * Search the list for an idle WinStation
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( !wcscmp( pWinStation->ListenName, pListenName ) ) {
            if ( !bActiveOnly )
                Count++;
            else if ( pWinStation->State == State_Active || pWinStation->State == State_Shadow )
                Count++;
        }
    }

    if ( !bLockHeld ) {
        LEAVECRIT( &WinStationListLock );
    }

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: CountWinstationType %d\n", Count ));
    return Count;
}


/*******************************************************************************
 *  IncrementReference
 *
 *   Increments refcount on a WinStation given a pointer
 *
 * NOTE:
 *    WinStationListLock must be locked on entry and will be locked on return.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to lock
 *
 ******************************************************************************/
void IncrementReference(PWINSTATION pWinStation)
{
    /*
     * increment the ref count on winstation.
     */

    InterlockedIncrement( &pWinStation->Lock.RefCount );
}


/*******************************************************************************
 *  InitRefLock
 *
 *   Initialize a RefLock and lock it.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to init
 *    pDeleteProcedure (input)
 *       Pointer to delete procedure for object
 ******************************************************************************/
NTSTATUS InitRefLock(PREFLOCK pLock, PREFLOCKDELETEPROCEDURE pDeleteProcedure)
{
    NTSTATUS Status;

    // Create and lock winstation mutex
    Status = NtCreateMutant( &pLock->Mutex, MUTANT_ALL_ACCESS, NULL, TRUE );
    if ( !NT_SUCCESS( Status ) )
        return( Status );

    pLock->RefCount = 1;
    pLock->Invalid = FALSE;
    pLock->pDeleteProcedure = pDeleteProcedure;

    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  SetRefLockDeleteProc
 *
 *   Cahnge a RefLock DeleteProc.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to init
 *    pDeleteProcedure (input)
 *       Pointer to delete procedure for object
 ******************************************************************************/
NTSTATUS SetRefLockDeleteProc(
        PREFLOCK pLock,
        PREFLOCKDELETEPROCEDURE pDeleteProcedure)
{
    pLock->pDeleteProcedure = pDeleteProcedure;
    return STATUS_SUCCESS;
}


/*******************************************************************************
 *  LockRefLock
 *
 *   Increment the reference count for a RefLock and lock it.
 *
 * NOTE:
 *    WinStationListLock must be locked on entry and will be locked on return.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to lock
 *
 * EXIT:
 *    TRUE - if object was locked successfully
 *    FALSE - otherwise
 ******************************************************************************/
BOOLEAN LockRefLock(PREFLOCK pLock)
{
    /*
     * Increment reference count for this RefLock.
     */
    InterlockedIncrement( &pLock->RefCount );

    /*
     * If mutex cannot be locked without blocking,
     * then unlock the WinStation list lock, wait for the mutex,
     * and relock the WinStation list lock.
     */
    if ( NtWaitForSingleObject( pLock->Mutex, FALSE, &TimeoutZero ) != STATUS_SUCCESS ) {
        LEAVECRIT( &WinStationListLock );
        NtWaitForSingleObject( pLock->Mutex, FALSE, NULL );
        ENTERCRIT( &WinStationListLock );

        /*
         * If the object is marked as invalid, it was removed while
         * we waited for the lock.  Release our lock and return FALSE,
         * indicating we were unable to lock it.
         */
        if ( pLock->Invalid ) {
            /*
             * Release the winstationlist lock because the Winstation
             * migth go away as a result of releasing its lock,
             */
            LEAVECRIT( &WinStationListLock );
            ReleaseRefLock( pLock );
            ENTERCRIT( &WinStationListLock );
            return FALSE;
        }
    }

    return TRUE;
}


/*******************************************************************************
 *  RelockRefLock
 *
 *   Relock a RefLock which has been unlocked but still has a reference.
 *
 * NOTE:
 *    Object must have been previously unlocked by calling UnlockRefLock.
 *
 * EXIT:
 *    TRUE - if object is still valid
 *    FALSE - if object was marked invalid while unlocked
 ******************************************************************************/
BOOLEAN RelockRefLock(PREFLOCK pLock)
{
    /*
     * Lock the mutex
     */
    NtWaitForSingleObject( pLock->Mutex, FALSE, NULL );

    /*
     * If the object is marked as invalid,
     * it was removed while it was unlocked so we return FALSE.
     */
    return !pLock->Invalid;
}


/*******************************************************************************
 *  UnlockRefLock
 *
 *   Unlock a RefLock but keep a reference to it (don't decrement
 *   the reference count).  Caller must use RelockWinRefLock
 *   to relock the object.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to unlock
 ******************************************************************************/
VOID UnlockRefLock(PREFLOCK pLock)
{
    NtReleaseMutant(pLock->Mutex, NULL);
}


/*******************************************************************************
 *  ReleaseRefLock
 *
 *   Unlock and dereference a RefLock.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to release
 ******************************************************************************/
VOID ReleaseRefLock(PREFLOCK pLock)
{
    ASSERT( pLock->RefCount > 0 );

    /*
     * If object has been marked invalid and we are the
     * last reference, then finish deleting it now.
     */
    if ( pLock->Invalid ) {
        ULONG RefCount;

        RefCount = InterlockedDecrement( &pLock->RefCount );
        NtReleaseMutant( pLock->Mutex, NULL );
        if ( RefCount == 0 ) {
            NtClose( pLock->Mutex );
            (*pLock->pDeleteProcedure)( pLock );
        }

    } else {
        InterlockedDecrement( &pLock->RefCount );
        NtReleaseMutant( pLock->Mutex, NULL );
    }
}


/*******************************************************************************
 *  DeleteRefLock
 *
 *   Unlock, dereference, and delete a RefLock.
 *
 * ENTRY:
 *    pLock (input)
 *       Pointer to RefLock to delete
 ******************************************************************************/
VOID DeleteRefLock(PREFLOCK pLock)
{
    ASSERT( pLock->RefCount > 0 );

    /*
     * If we are the last reference, then delete the object now
     */
    if ( InterlockedDecrement( &pLock->RefCount ) == 0 ) {
        NtReleaseMutant( pLock->Mutex, NULL );
        NtClose( pLock->Mutex );
        (*pLock->pDeleteProcedure)( pLock );

    /*
     * Otherwise, just mark the object invalid
     */
    } else {
        pLock->Invalid = TRUE;
        NtReleaseMutant( pLock->Mutex, NULL );
    }
}


BOOLEAN IsWinStationLockedByCaller(PWINSTATION pWinStation)
{
    MUTANT_BASIC_INFORMATION MutantInfo;
    NTSTATUS Status;

    Status = NtQueryMutant( pWinStation->Lock.Mutex,
                            MutantBasicInformation,
                            &MutantInfo,
                            sizeof(MutantInfo),
                            NULL );
    if ( NT_SUCCESS( Status ) )
        return MutantInfo.OwnedByCaller;

    return FALSE;
}


/*******************************************************************************
 *  WinStationEnumerateWorker
 *
 *   Enumerate the WinStation list and return LogonIds and WinStation
 *   names to the caller.
 *
 * NOTE:
 *   This version only returns one entry at a time.  There is no guarantee
 *   across calls that the list will not change, causing the users Index
 *   to miss an entry or get the same entry twice.
 *
 * ENTRY:
 *    pEntries (input/output)
 *       Pointer to number of entries to return/number actually returned
 *    pWin (output)
 *       Pointer to buffer to return entries
 *    pByteCount (input/output)
 *       Pointer to size of buffer/length of data returned in buffer
 *    pIndex (input/output)
 *       Pointer to WinStation index to return/next index
 ******************************************************************************/
NTSTATUS WinStationEnumerateWorker(
        PULONG pEntries,
        PLOGONID pWin,
        PULONG pByteCount,
        PULONG pIndex)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    ULONG WinStationIndex;
    ULONG MaxEntries, MaxByteCount;
    NTSTATUS Status;
    NTSTATUS Error = STATUS_NO_MORE_ENTRIES;

    WinStationIndex = 0;
    MaxEntries = *pEntries;
    MaxByteCount = *pByteCount;
    *pEntries = 0;
    *pByteCount = 0;
    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

        if ( *pEntries >= MaxEntries ||
             *pByteCount + sizeof(LOGONID) > MaxByteCount ) {
            break;
        }

        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        // 
        // If Session has not yet been fully Started, skip this session during Enumeration
        //
        if (pWinStation->LogonId == -1) {
            continue;
        }

        if ( *pIndex == WinStationIndex ) {
            (*pIndex)++;    // set Index to next entry

            /*
             * Verify that client has QUERY access before
             * returning it in the enumerate list.
             * (Note that RpcCheckClientAccess only references the WinStation
             *  to get the LogonId, so it is safe to call this routine without
             *  locking the WinStation since we hold the WinStationListLock
             *  which prevents the WinStation from being deleted.)
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, FALSE );
            if ( NT_SUCCESS( Status ) ) {
                Error = STATUS_SUCCESS;


                /*
                 * It's possible that the LPC client can go away while we
                 * are processing this call.  Its also possible that another
                 * server thread handles the LPC_PORT_CLOSED message and closes
                 * the port, which deletes the view memory, which is what
                 * pWin points to.  In this case the pWin references below
                 * will trap.  We catch this and just break out of the loop.
                 */
                try {
                    pWin->LogonId = pWinStation->LogonId;
                    if ( pWinStation->Terminating )
                        pWin->State = State_Down;
                    else
                        pWin->State = pWinStation->State;
                    wcscpy( pWin->WinStationName, pWinStation->WinStationName );
                } except( EXCEPTION_EXECUTE_HANDLER ) {
                    break;
                }
                pWin++;
                (*pEntries)++;
                *pByteCount += sizeof(LOGONID);
            }
        }
        WinStationIndex++;
    }

    LEAVECRIT( &WinStationListLock );
    return Error;
}


/*******************************************************************************
 *  LogonIdFromWinStationNameWorker
 *
 *   Return the LogonId for a given WinStation name.
 *
 * ENTRY:
 *    WinStationName (input)
 *       name of WinStation to query
 *    pLogonId (output)
 *       Pointer to location to return LogonId
 ******************************************************************************/
NTSTATUS LogonIdFromWinStationNameWorker(
        PWINSTATIONNAME WinStationName,
        ULONG  NameSize,
        PULONG pLogonId)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    UINT     uiLength;

    // make sure we don't go beyond the end of one of the two strings
    // (and work around bug #229753 : NameSize is in bytes, not a characters count)
    if (NameSize > sizeof(WINSTATIONNAME)) {
        uiLength = sizeof(WINSTATIONNAME)/sizeof(WCHAR);
    } else {
        uiLength = NameSize/sizeof(WCHAR);
    }

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        if ( !_wcsnicmp( pWinStation->WinStationName, WinStationName, uiLength ) ) {

            /*
             * If client doesn't have QUERY access, return NOT_FOUND error
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, FALSE );
            if ( !NT_SUCCESS( Status ) )
                break;
            *pLogonId = pWinStation->LogonId;
            LEAVECRIT( &WinStationListLock );
            return( STATUS_SUCCESS );
        }
    }

    LEAVECRIT( &WinStationListLock );
    return STATUS_CTX_WINSTATION_NOT_FOUND;
}


/*******************************************************************************
 *  IcaWinStationNameFromLogonId
 *
 *   Return the WinStation name for a given LogonId.
 *
 * ENTRY:
 *    LogonId (output)
 *       LogonId to query
 *    pWinStationName (input)
 *       pointer to location to return WinStation name
 ******************************************************************************/
NTSTATUS IcaWinStationNameFromLogonId(
        ULONG LogonId,
        PWINSTATIONNAME pWinStationName)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    NTSTATUS Status;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        if ( pWinStation->LogonId == LogonId ) {
            /*
             * If client doesn't have QUERY access, return NOT_FOUND error
             */
            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, FALSE );
            if ( !NT_SUCCESS( Status ) )
                break;
            wcscpy( pWinStationName, pWinStation->WinStationName );
            LEAVECRIT( &WinStationListLock );
            return( STATUS_SUCCESS );
        }
    }

    LEAVECRIT( &WinStationListLock );
    return STATUS_CTX_WINSTATION_NOT_FOUND;
}


NTSTATUS TerminateProcessAndWait(
        HANDLE ProcessId,
        HANDLE Process,
        ULONG Seconds)
{
    NTSTATUS Status;
    ULONG mSecs;
    LARGE_INTEGER Timeout;

    /*
     * Try to terminate the process
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: TerminateProcessAndWait, process=0x%x, ", ProcessId ));

    Status = NtTerminateProcess( Process, STATUS_SUCCESS );
    if ( !NT_SUCCESS( Status ) && Status != STATUS_PROCESS_IS_TERMINATING ) {
        DBGPRINT(("Terminate=0x%x\n", Status ));
        return( Status );
    }
    TRACE((hTrace,TC_ICASRV,TT_API1, "Terminate=0x%x, ", Status ));

    /*
     * Wait for the process to die
     */
    mSecs = Seconds * 1000;
    Timeout = RtlEnlargedIntegerMultiply( mSecs, -10000 );
    Status = NtWaitForSingleObject( Process, FALSE, &Timeout );

    TRACE((hTrace,TC_ICASRV,TT_API1, "Wait=0x%x\n", Status ));

    return Status;
}


/*****************************************************************************
 *  ShutdownLogoff
 *
 *   Worker function to handle logoff notify of WinStations when
 *   the system is being shutdown.
 *
 *   It is built from the code in WinStationReset
 *
 * ENTRY:
 *   Client LogonId (input)
 *     LogonId of the client Winstation doing the shutdown. This is so
 *     that he does not get reset.
 *   Flags (input)
 *     The shutdown flags.
 ****************************************************************************/
NTSTATUS ShutdownLogoff(ULONG ClientLogonId, ULONG Flags)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation, pConsole = NULL;
    PULONG Tmp;
    PULONG Ids = NULL;
    ULONG  IdCount = 0;
    ULONG  IdAllocCount = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "ShutdownLogoff: Called from WinStation %d Flags %x\n", ClientLogonId, Flags ));

    /*
     * Loop through all the WinStations getting the LogonId's
     * of active Winstations
     */
    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

        //
        // take a reference on the console
        //
        if ( pWinStation->fOwnsConsoleTerminal ) {
            if (!pConsole) {
                IncrementReference( pWinStation );
                pConsole = pWinStation;
            }
        }

        //
        // just skip :
        // - the caller's session
        // - the console (because winsrv!W32WinStationExitWindows would fail for the console)
        // - the listener
        //
        if ( ( pWinStation->LogonId == ClientLogonId ) ||
             ( pWinStation->LogonId == 0) ||
             ( pWinStation->Flags & WSF_LISTEN ) ) {
            // Skip this one, or it's a listen
            continue;
        }

        if ( IdCount >= IdAllocCount ) {
            // Reallocate the array
            IdAllocCount += 16;
            Tmp = RtlAllocateHeap( RtlProcessHeap(), 0, IdAllocCount * sizeof(ULONG) );
            if ( Tmp == NULL ) {
                Status = STATUS_NO_MEMORY;
                if ( Ids )
                    RtlFreeHeap( RtlProcessHeap(), 0, Ids );
                IdCount = 0;
                break;
            }
            if ( Ids ) {
               RtlCopyMemory( Tmp, Ids, IdCount*sizeof(ULONG) );
               RtlFreeHeap( RtlProcessHeap(), 0, Ids );
            }
            Ids = Tmp;
        }
        // Copy the LogonId into our array
        Ids[IdCount++] = pWinStation->LogonId;
    }

    //
    // We are protected by new winstations starting up by the shutdown
    // global flags.
    //
    // The actual WinStation reset routine will validate that the LogonId
    // is still valid
    //
    LEAVECRIT( &WinStationListLock );

    //
    // see if the console is being shadowed
    //
    if ( pConsole ) {
        RelockWinStation( pConsole );
        WinStationStopAllShadows( pConsole );
        ReleaseWinStation( pConsole );
    }

    if (IdCount !=0)
    {
        //
        // Ids[] holds the LogonId's of valid Winstations, IdCount is the number
        //

        /*
         * Now do the actual logout and/or reset of the WinStations.
         */
        if (Flags & WSD_LOGOFF) {
            Status = DoForWinStationGroup( Ids, IdCount,
                                           (LPTHREAD_START_ROUTINE) WinStationLogoff);
        }

        if (Flags & WSD_SHUTDOWN) {
            Status = DoForWinStationGroup( Ids, IdCount,
                                           (LPTHREAD_START_ROUTINE) WinStationShutdownReset);
        }
    }

    return Status;
}


/*****************************************************************************
 *  DoForWinStationGroup
 *
 *   Executes a function for each WinStation in the group.
 *   The group is passed as an array of LogonId's.
 *
 * ENTRY:
 *   Ids (input)
 *     Array of LogonId's of WinStations to reset
 *
 *   IdCount (input)
 *     Count of LogonId's in array
 *
 *   ThreadProc (input)
 *     The thread routine executed for each WinStation.
 ****************************************************************************/
NTSTATUS DoForWinStationGroup(
        PULONG Ids,
        ULONG  IdCount,
        LPTHREAD_START_ROUTINE ThreadProc)
{
    ULONG Index;
    NTSTATUS Status;
    LARGE_INTEGER Timeout;
    PHANDLE ThreadHandles = NULL;

    ThreadHandles = RtlAllocateHeap( RtlProcessHeap(), 0, IdCount * sizeof(HANDLE) );
    if( ThreadHandles == NULL ) {
        return( STATUS_NO_MEMORY );
    }

    /*
     * Wait a max of 60 seconds for thread to exit
     */
    Timeout = RtlEnlargedIntegerMultiply( 60000, -10000 );

    for( Index=0; Index < IdCount; Index++ ) {

        //
        // Here we create a thread to run the actual reset function.
        // Since we are holding the lists crit sect, the threads will
        // wait until we are done, then wake up when we release it
        //
        DWORD ThreadId;

        ThreadHandles[Index] = CreateThread( NULL,
                                             0,         // use Default stack size of the svchost process
                                             ThreadProc,
                                             LongToPtr( Ids[Index] ),  // LogonId
                                             THREAD_SET_INFORMATION,
                                             &ThreadId );
        if ( !ThreadHandles[Index] ) {
            ThreadHandles[Index] = (HANDLE)(-1);
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Shutdown: Could not create thread for WinStation %d Shutdown\n", Ids[Index]));
        }
    }

    //
    // Now wait for the threads to exit. Each will reset their
    // WinStation and be signal by the kernel when the thread is
    // exited.
    //
    for (Index=0; Index < IdCount; Index++) {
        if ( ThreadHandles[Index] != (HANDLE)(-1) ) {
            Status = NtWaitForSingleObject(
                         ThreadHandles[Index],
                         FALSE,   // Not alertable
                         &Timeout
                         );

            if( Status == STATUS_TIMEOUT ) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: DoForWinStationGroup: Timeout Waiting for Thread\n"));
            }
            else if (!NT_SUCCESS( Status ) ) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: DoForWinStationGroup: Error waiting for Thread Status 0x%x\n", Status));
            }
            NtClose( ThreadHandles[Index] );
        }
    }

    /* makarp:free the ThreadHandles. // #182609 */
    RtlFreeHeap( RtlProcessHeap(), 0, ThreadHandles );

    return STATUS_SUCCESS;
}


/*****************************************************************************
 *  WinStationShutdownReset
 *
 *   Reset a WinStation due to a system shutdown. Does not re-create
 *   it.
 *
 * ENTRY:
 *   ThreadArg (input)
 *     WinStation logonId
 ****************************************************************************/
ULONG WinStationShutdownReset(PVOID ThreadArg)
{
    ULONG LogonId = (ULONG)(INT_PTR)ThreadArg;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    ULONG ulIndex;
    BOOL bConnectDisconnectPending = TRUE;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: ShutdownReset, LogonId=%d\n", LogonId ));

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Console is a special case since it only logs off
     */
    if ( LogonId == 0 ) {
        Status = LogoffWinStation( pWinStation, (EWX_FORCE | EWX_LOGOFF) );
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Mark the winstation as being deleted.
     * If a reset/delete operation is already in progress
     * on this winstation, then don't proceed with the delete.
     * Also if there is a Connect/disconnect pending, give it
     * a chance to complete.
     */
    for (ulIndex=0; ulIndex < WINSTATION_WAIT_COMPLETE_RETRIES; ulIndex++) {

       if ( pWinStation->Flags & (WSF_RESET | WSF_DELETE) ) {
           ReleaseWinStation( pWinStation );
           Status = STATUS_CTX_WINSTATION_BUSY;
           goto done;
       }

       if ( pWinStation->Flags & (WSF_CONNECT | WSF_DISCONNECT) ) {
           LARGE_INTEGER Timeout;
           Timeout = RtlEnlargedIntegerMultiply( WINSTATION_WAIT_COMPLETE_DURATION, -10000 );
           UnlockWinStation( pWinStation );
           NtDelayExecution( FALSE, &Timeout );
           if ( !RelockWinStation( pWinStation ) ) {
               ReleaseWinStation( pWinStation );
               Status = STATUS_SUCCESS;
               goto done;
           }
       } else {
          bConnectDisconnectPending = FALSE;
          break;
       }
    }

    if ( bConnectDisconnectPending ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto done;
    }

    pWinStation->Flags |= WSF_DELETE;

    /*
     * If no broken reason/source have been set, then set them here.
     */
    if ( pWinStation->BrokenReason == 0 ) {
        pWinStation->BrokenReason = Broken_Terminate;
        pWinStation->BrokenSource = BrokenSource_Server;
    }

    /*
     * Make sure this WinStation is ready to delete
     */
    WinStationTerminate( pWinStation );

    /*
     * Call the WinStationDelete worker
     */
    WinStationDeleteWorker( pWinStation );
    Status = STATUS_SUCCESS;

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: ShutdownReset, Status=0x%x\n", Status ));
    ExitThread( 0 );
    return Status;
}


/*****************************************************************************
 *  WinStationLogoff
 *
 *   Logoff the WinStation via ExitWindows.
 *
 * ENTRY:
 *   ThreadArg (input)
 *     WinStation logonId
 ****************************************************************************/
ULONG WinStationLogoff(PVOID ThreadArg)
{
    ULONG LogonId = (ULONG)(INT_PTR)ThreadArg;
    PWINSTATION pWinStation;
    NTSTATUS Status;
    LARGE_INTEGER Timeout;

    /*
     * Wait a maximum of 1 min for the session to logoff
     */
    Timeout = RtlEnlargedIntegerMultiply( 60000, -10000 );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLogoff, LogonId=%d\n", LogonId ));

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
    } else {
        Status = LogoffWinStation( pWinStation, EWX_LOGOFF);

        if (ShutdownInProgress &&
                NT_SUCCESS(Status) &&
                ((pWinStation->State == State_Active) ||
                (pWinStation->State == State_Disconnected))) {

            UnlockWinStation( pWinStation );
            Status = NtWaitForSingleObject( pWinStation->InitialCommandProcess,
                                            FALSE,
                                            &Timeout );
            RelockWinStation( pWinStation );
        }

        ReleaseWinStation( pWinStation );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLogoff, Status=0x%x\n", Status ));
    ExitThread( 0 );
    return Status;
}


/*******************************************************************************
 *  ResetGroupByListener
 *
 *    Resets all active winstations on the supplied listen name.
 *
 * ENTRY:
 *    pListenName (input)
 *       Type of Winstation (e.g. tcp, ipx)
 ******************************************************************************/
VOID ResetGroupByListener(PWINSTATIONNAME pListenName)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for all active WinStation with the given ListenName.
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if (!wcscmp(pWinStation->ListenName, pListenName) &&
            (!(pWinStation->Flags & (WSF_RESET | WSF_LISTEN)))) {
            QueueWinStationReset(pWinStation->LogonId);
        }
    }

    LEAVECRIT( &WinStationListLock );
}


NTSTATUS LogoffWinStation(PWINSTATION pWinStation, ULONG ExitWindowsFlags)
{
    WINSTATION_APIMSG msg;
    NTSTATUS Status = 0;

    /*
     * Tell the WinStation to logoff
     */
    msg.ApiNumber = SMWinStationExitWindows;
    msg.u.ExitWindows.Flags = ExitWindowsFlags;
    Status = SendWinStationCommand( pWinStation, &msg, 0 );
    return Status;
}


/*****************************************************************************
 *
 *  This section of the file contains the impementation of the digital
 *  certification mechanism for the Stack and WinStation Extension DLLs.  This
 *  code is not in a separate file so that external symbols are not visible.
 *  All routines are declared static.
 *
 ****************************************************************************/

//
// For security reasons, the TRACE statements in the following routine are
// normally not included.  If you want to include them, uncomment the
// SIGN_DEBUG_WINSTA #define below.
//
// #define SIGN_DEBUG_WINSTA

#include <wincrypt.h>
#include <imagehlp.h>
#include <stddef.h>

#include "../../tscert/inc/pubblob.h"    // needed by certvfy.inc
#include "../../tscert/inc/certvfy.inc"  // VerifyFile()

//
//  The following are initialized by VfyInit.
//
static RTL_CRITICAL_SECTION VfyLock;
static WCHAR szSystemDir[ MAX_PATH + 1 ];
static WCHAR szDriverDir[ MAX_PATH + 1 ];

/*******************************************************************************
 *  ReportStackLoadFailure
 *
 *   Send a StackFailed message to the WinStationApiPort.
 *
 * ENTRY:
 *    Module (input)
 *       Name of Module to Log Error Against
 ******************************************************************************/
static NTSTATUS ReportStackLoadFailure(PWCHAR Module)
{
    HANDLE h;
    extern WCHAR gpszServiceName[];

    h = RegisterEventSource(NULL, gpszServiceName);
    if (h != NULL) {
        if (!ReportEventW(h,       // event log handle
                          EVENTLOG_ERROR_TYPE,   // event type
                          0,                     // category zero
                          EVENT_BAD_STACK_MODULE,// event identifier
                          NULL,                  // no user security identifier
                          1,                     // one substitution string
                          0,                     // no data
                          &Module,               // pointer to string array
                          NULL)                 // pointer to data
           ) {
            DBGPRINT(("ReportEvent Failed %ld. Event ID=%lx module=%ws\n",GetLastError(), EVENT_BAD_STACK_MODULE, Module));
        }

        DeregisterEventSource(h);
    } else {
        DBGPRINT(("Cannot RegisterEvent Source %ld Event ID=%lx module=%ws\n",GetLastError(), EVENT_BAD_STACK_MODULE, Module));
    }

    return STATUS_SUCCESS;
}


/******************************************************************************
 *  _VerifyStackModules
 *   Verifies the integrity of the stack modules and the authenticity
 *   of the digital signature.
 *
 * ENTRY:
 *   pWinStation (input)
 *     Pointer to a Listen Winstation.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *   STATUS_UNSUCCESSFUL - DLL integrity check, authenticity check failed
 *                         or registry stucture invalid
 *****************************************************************************/
static NTSTATUS _VerifyStackModules(IN PWINSTATION pWinStation)
{
    PWCHAR pszModulePath = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD KeyIndex;
    DWORD Error;
#ifdef SIGN_BYPASS_OPTION
    HKEY hKey;
#endif SIGN_BYPASS_OPTION
    HKEY hVidKey;
    HKEY hVidDriverKey;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE hServiceKey;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInfo;
    ULONG ValueLength;
#define VALUE_BUFFER_SZ (sizeof(KEY_VALUE_PARTIAL_INFORMATION) + \
                           256 * sizeof( WCHAR))
    PCHAR pValueBuffer = NULL;
    INT Entries;
    DWORD dwByteCount;
    PPDNAME pPdNames, p;
    INT i;
    DLLNAME WdDLL;


#ifdef SIGN_BYPASS_OPTION

    //
    // Check if Verification is to be bypassed
    //
    if ( RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            REG_CONTROL_TSERVER L"\\BypassVerification",
            0,
            KEY_READ,
            &hKey ) == ERROR_SUCCESS ) {
        RegCloseKey( hKey );
        Status = STATUS_SUCCESS;
        goto exit;
    }

#endif //SIGN_BYPASS_OPTION



#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "System Dir: %ws\n", szSystemDir ));
#endif // SIGN_DEBUG_WINSTA

    // allocate memory
    pszModulePath = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) ) ; 
    if (pszModulePath == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    pValueBuffer = MemAlloc( VALUE_BUFFER_SZ );
    if (pValueBuffer == NULL) {
        Status = STATUS_NO_MEMORY;
        goto exit;
    }

    //
    //  Verify the WSX DLL if defined
    //
    if ( pWinStation->Config.Wd.WsxDLL[0] != L'\0' ) {
        wcscpy( pszModulePath, szSystemDir );
        wcscat( pszModulePath, pWinStation->Config.Wd.WsxDLL );
        wcscat( pszModulePath, L".DLL" );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "==> WSX Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

        if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
            ReportStackLoadFailure(pszModulePath);
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
    }
    //
    //  Verify the WD
    //
    wcscpy( WdDLL, pWinStation->Config.Wd.WdDLL );
    wcscpy( pszModulePath, szDriverDir );
    wcscat( pszModulePath, WdDLL );
    wcscat( pszModulePath, L".SYS" );
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "==> WD Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

    if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
        ReportStackLoadFailure(pszModulePath);
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    //
    //  Verify the TD which is in Pd[0].  Always defined for Listen Stack.
    //
    wcscpy( pszModulePath, szDriverDir );
    wcscat( pszModulePath, pWinStation->Config.Pd[0].Create.PdDLL );
    wcscat( pszModulePath, L".SYS" );
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1, "==> WD Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

    if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
        ReportStackLoadFailure(pszModulePath);
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    //
    //  Enumerate the PDs for this WD and verify all the PDs.
    //  Can't depend on Pd[i] for this since optional PDs won't
    //  be present during Listen.
    //
    Entries = -1;
    dwByteCount = 0;
    i = 0;
    Error = RegPdEnumerate(
        NULL,
        WdDLL,
        FALSE,
        &i,
        &Entries,
        NULL,
        &dwByteCount );
#ifdef SIGN_DEBUG_WINSTA
    TRACE((hTrace,TC_ICASRV,TT_API1,
          "RegPdEnumerate 1 complete., Entries %d, Error %d\n", Entries, Error ));
#endif // SIGN_DEBUG_WINSTA
    
    if ( Error != ERROR_NO_MORE_ITEMS && Error != ERROR_CANTOPEN ) {
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }
    //
    //  T.Share doesn't have PDs, so check if none
    //
    if ( Entries ) {
        dwByteCount = sizeof(PDNAME) * Entries;
        pPdNames = MemAlloc( dwByteCount );
        if ( !pPdNames ) {
            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
        i = 0;
        Error = RegPdEnumerate(
            NULL,
            WdDLL,
            FALSE,
            &i,
            &Entries,
            pPdNames,
            &dwByteCount );
        if ( Error != ERROR_SUCCESS ) {

            /* makarp #182610 */
            MemFree( pPdNames );

            Status = STATUS_UNSUCCESSFUL;
            goto exit;
        }
        //
        // Open up the Registry entry for each named PD and pull out the value
        // of the PdDLL.  This is the name of the DLL to verify.
        //
        for ( i = 0, p = pPdNames; i < Entries;
                i++, (char*)p += sizeof(PDNAME) ) {
            HKEY hPdKey;
            PWCHAR pszPdDLL = NULL;
            PWCHAR pszRegPath = NULL;
            DWORD dwLen;
            DWORD dwType;

            // allocate memory
            pszPdDLL = MemAlloc( (MAX_PATH+1) * sizeof(WCHAR) );
            if (pszPdDLL == NULL) {
                MemFree( pPdNames );
                Status = STATUS_NO_MEMORY;
                goto exit;
            }

            pszRegPath = MemAlloc( (MAX_PATH+1) * sizeof(WCHAR) );
            if (pszRegPath == NULL) {
                MemFree( pszPdDLL );
                MemFree( pPdNames );
                Status = STATUS_NO_MEMORY;
                goto exit;
            }
            
            //
            // Build up the Registry Path to open the PD's key
            //
            wcscpy( pszRegPath, WD_REG_NAME );
            wcscat( pszRegPath, L"\\" );
            wcscat( pszRegPath, WdDLL );
            wcscat( pszRegPath, PD_REG_NAME L"\\" );
            wcscat( pszRegPath, p );
#ifdef SIGN_DEBUG_WINSTA
            TRACE((hTrace,TC_ICASRV,TT_API1, "PdKeyPath: %ws\n", pszRegPath ));
#endif // SIGN_DEBUG_WINSTA

            if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegPath, 0, KEY_READ,
                   &hPdKey ) != ERROR_SUCCESS ) {
                MemFree( pPdNames );
                MemFree( pszPdDLL );
                MemFree( pszRegPath );
                Status = STATUS_UNSUCCESSFUL;
                goto exit;
            }
            //
            // Get the name of the Pd DLL.
            //
            dwLen = (MAX_PATH + 1) * sizeof(WCHAR) ;
            if ( RegQueryValueEx( hPdKey,
                                  WIN_PDDLL,
                                  NULL,
                                  &dwType,
                                  (PCHAR) pszPdDLL,
                                  &dwLen ) != ERROR_SUCCESS ) {
                MemFree( pPdNames );
                MemFree( pszPdDLL );
                MemFree( pszRegPath );

                // makarp:182610
                RegCloseKey(hPdKey);

                Status = STATUS_UNSUCCESSFUL;
                goto exit;
            }

            // makarp:182610
            RegCloseKey(hPdKey);

            //
            // Build path to DLL and attempt verification
            //
            wcscpy( pszModulePath, szDriverDir );
            wcscat( pszModulePath, pszPdDLL );
            wcscat( pszModulePath, L".SYS" );
#ifdef SIGN_DEBUG_WINSTA
            TRACE((hTrace,TC_ICASRV,TT_API1, "==> PD Path: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

            if ( !VerifyFile( pszModulePath, &VfyLock ) &&
                    GetLastError() != ERROR_CANTOPEN ) {
                MemFree( pPdNames );
                MemFree( pszPdDLL );
                MemFree( pszRegPath );
                ReportStackLoadFailure(pszModulePath);
                Status = STATUS_UNSUCCESSFUL;
                goto exit;
            }
            MemFree( pszPdDLL );
            MemFree( pszRegPath );
        }
        MemFree( pPdNames );
    }

    //
    // for all keys under HKLM\System\CCS\Control\Terminal Server\VIDEO
    //  open the subkey \Device\Video0 and use that value as
    //  a string to open
    //  \REGISTRY\Machine\System\CCS\Services\vdtw30\Device0
    //   DLL name is in Value "Installed Display Drivers"
    //
    //  Open registry (LOCAL_MACHINE\System\CCS\Control\Terminal Server\VIDEO)
    //
    //  NOTE: All video driver DLLs are verified since there isn't any simple
    //  method to determine which one is used for this stack.
    //
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, VIDEO_REG_NAME, 0,
         KEY_ENUMERATE_SUB_KEYS, &hVidKey ) != ERROR_SUCCESS ) {
        Status = STATUS_UNSUCCESSFUL;
        goto exit;
    }

    for ( KeyIndex = 0 ;; KeyIndex++ ) {   // For all VIDEO subkeys
        PWCHAR pszVidDriverName = NULL;
        PWCHAR pszRegPath = NULL;
        PWCHAR pszDeviceKey = NULL;
        PWCHAR pszServiceKey = NULL;
        DWORD dwLen;
        DWORD dwType;

        // allocate memory
        pszVidDriverName = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszVidDriverName == NULL) {
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        pszRegPath = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszRegPath == NULL) {
            MemFree(pszVidDriverName);
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        pszDeviceKey = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszDeviceKey == NULL) {
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        pszServiceKey = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
        if (pszServiceKey == NULL) {
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            Status = STATUS_NO_MEMORY;
            goto exit;
        }

        //
        //  Get name of VIDEO driver subkey.  If end of subkeys, exit loop.
        //
        if ((Error = RegEnumKey( hVidKey, KeyIndex, pszVidDriverName,
                                 MAX_PATH+1))!= ERROR_SUCCESS ){
             
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);

            break;  // exit for loop
        }

        //
        // Build up the Registry Path to open the VgaCompatible Value
        //
        wcscpy( pszRegPath, VIDEO_REG_NAME L"\\" );
        wcscat( pszRegPath, pszVidDriverName );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "VidDriverKeyPath: %ws\n", pszRegPath ));
#endif // SIGN_DEBUG_WINSTA

        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegPath, 0, KEY_READ,
               &hVidDriverKey ) != ERROR_SUCCESS ) {
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }

        //
        // Don't like to use constant strings, but this is the way
        // WINSRV does it...
        //
        dwLen = (MAX_PATH + 1) * sizeof(WCHAR) ;               

        if ( RegQueryValueEx( hVidDriverKey,
                              L"VgaCompatible",
                              NULL,
                              &dwType,
                              (PCHAR) pszDeviceKey,
                              &dwLen ) != ERROR_SUCCESS ) {
            RegCloseKey( hVidDriverKey );
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "DeviceKey: %ws\n", pszDeviceKey ));
#endif // SIGN_DEBUG_WINSTA


        dwLen = (MAX_PATH + 1) * sizeof(WCHAR); 
        if ( RegQueryValueEx( hVidDriverKey,
                              pszDeviceKey,
                              NULL,
                              &dwType,
                              (PCHAR) pszServiceKey,
                              &dwLen ) != ERROR_SUCCESS ) {
            RegCloseKey( hVidDriverKey );
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }
        RegCloseKey( hVidDriverKey );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "ServiceKey: %ws\n", pszServiceKey ));
#endif // SIGN_DEBUG_WINSTA


        RtlInitUnicodeString( &KeyPath, pszServiceKey );
        InitializeObjectAttributes( &ObjectAttributes, &KeyPath,
                                    OBJ_CASE_INSENSITIVE, NULL, NULL );
        //
        // Must use NT Registry APIs since the ServiceKey key name from
        // the registry is in the form used by these APIs.
        //
        Status = NtOpenKey( &hServiceKey, GENERIC_READ, &ObjectAttributes );
        if ( !NT_SUCCESS( Status ) ) {
            DBGPRINT(( "TERMSRV: NtOpenKey failed, rc=%x\n", Status ));
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }

        //
        // Don't like to use constant strings, but this is the way
        // WINSRV does it...
        //
        RtlInitUnicodeString( &ValueName, L"InstalledDisplayDrivers" );
        KeyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)pValueBuffer;
        Status = NtQueryValueKey( hServiceKey,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  (PVOID)KeyValueInfo,
                                  VALUE_BUFFER_SZ,
                                  &ValueLength );
        NtClose( hServiceKey );
        if ( !NT_SUCCESS( Status ) ) {
            Status = STATUS_UNSUCCESSFUL;
            MemFree(pszVidDriverName);
            MemFree(pszRegPath);
            MemFree(pszDeviceKey);
            MemFree(pszServiceKey);
            goto closevidkey;
        }

        wcscpy( pszModulePath, szSystemDir );
        wcscat( pszModulePath, (PWCHAR)&KeyValueInfo->Data );
        wcscat( pszModulePath, L".DLL" );
#ifdef SIGN_DEBUG_WINSTA
        TRACE((hTrace,TC_ICASRV,TT_API1, "==> VidDriverDLLPath: %ws\n", pszModulePath ));
#endif // SIGN_DEBUG_WINSTA

        if ( !VerifyFile( pszModulePath, &VfyLock ) ) {
             ReportStackLoadFailure(pszModulePath);
             Status = STATUS_UNSUCCESSFUL;
             MemFree(pszVidDriverName);
             MemFree(pszRegPath);
             MemFree(pszDeviceKey);
             MemFree(pszServiceKey);
             goto closevidkey;
        }

        MemFree(pszVidDriverName);
        MemFree(pszRegPath);
        MemFree(pszDeviceKey);
        MemFree(pszServiceKey);

    } // for all VIDEO subkeys

closevidkey:
    RegCloseKey( hVidKey );

exit:
    if (pszModulePath != NULL) {
        MemFree(pszModulePath);
        pszModulePath = NULL;
    }
    if (pValueBuffer != NULL) {
        MemFree(pValueBuffer);
        pValueBuffer = NULL;
    }
    return Status;
}


/*******************************************************************************
 *  VfyInit
 *   Sets up environment for Stack DLL verification.
 ******************************************************************************/
NTSTATUS VfyInit()
{
    GetSystemDirectory( szSystemDir, sizeof( szSystemDir )/ sizeof(WCHAR));
    wcscat( szSystemDir, L"\\" );
    wcscpy( szDriverDir, szSystemDir );
    wcscat( szDriverDir, L"Drivers\\" );

    return RtlInitializeCriticalSection(&VfyLock);
}



VOID WinstationUnloadProfile(PWINSTATION pWinStation)
{
#if 0
    NTSTATUS NtStatus;
    UNICODE_STRING  UnicodeString;
    BOOL bResult;

    // if this is not the last session for this user, then we do nothing.
    if (WinstationCountUserSessions(pWinStation->pProfileSid, pWinStation->LogonId) != 0) {
        return;
    }

    // Get the user hive name from user Sid.
    NtStatus = RtlConvertSidToUnicodeString( &UnicodeString, pWinStation->pProfileSid, (BOOLEAN)TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        DBGPRINT(("TERMSRV: WinstationUnloadProfile couldn't convert Sid to string. \n"));
        return;
    }

    // Unload the user's hive.
    bResult = WinstationRegUnLoadKey(HKEY_USERS, UnicodeString.Buffer);
    if (!bResult) {
        DBGPRINT(("TERMSRV: WinstationUnloadProfile failed. \n"));
    }

    // free allocated string.
    RtlFreeUnicodeString(&UnicodeString);
#endif
}


BOOL WinstationRegUnLoadKey(HKEY hKey, LPWSTR lpSubKey)
{
    BOOL bResult = TRUE;
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    ENTERCRIT(&UserProfileLock);
    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status)) {

        error = RegUnLoadKey(hKey, lpSubKey);

        if ( error != ERROR_SUCCESS) {
            DBGPRINT(("TERMSRV: WinstationRegUnLoadKey RegUnLoadKey failed. \n"));
            bResult = FALSE;
        }

        //
        // Restore the privilege to its previous state
        //
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);
    } else {
        DBGPRINT(("TERMSRV: WinstationRegUnLoadKey adjust privilege failed. \n"));
        bResult = FALSE;
    }

    LEAVECRIT(&UserProfileLock);
    return bResult;
}


ULONG WinstationCountUserSessions(PSID pUserSid, ULONG CurrentLogonId)
{
   PLIST_ENTRY Head, Next;
   PWINSTATION pWinStation;
   ULONG Count = 0;
   PSID pSid;

   Head = &WinStationListHead;
   ENTERCRIT( &WinStationListLock );

   // Search the list for WinStations with a matching ListenName
   for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
       pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
       if (pWinStation->LogonId == CurrentLogonId) {
          continue;
       }
       if (pWinStation->pUserSid != NULL) {
          pSid =  pWinStation->pUserSid;
       } else {
          pSid = pWinStation->pProfileSid;
       }
       if ( (pSid != NULL) && RtlEqualSid( pSid, pUserSid ) ) {
           Count++;
       }
   }

   LEAVECRIT( &WinStationListLock );
   return Count;
}


PWINSTATION FindConsoleSession()
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    PWINSTATION pFoundWinStation = NULL;
    ULONG   uCount;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the Console Session.
     */
searchagain:
    uCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if ( pWinStation->fOwnsConsoleTerminal) {
           uCount++;

            /*
             * Now try to lock the WinStation.
             */
            if (pFoundWinStation == NULL){
               if ( !LockRefLock( &pWinStation->Lock ) )
                  goto searchagain;
                  pFoundWinStation = pWinStation;
            }
#if DBG
#else
    break;
#endif
        }
    }

    ASSERT((uCount <= 1));

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    LEAVECRIT( &WinStationListLock );

    return pFoundWinStation;
}


PWINSTATION FindIdleSessionZero()
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    PWINSTATION pFoundWinStation = NULL;
    ULONG   uCount;

    Head = &WinStationListHead;
    ENTERCRIT( &WinStationListLock );

    /*
     * Search the list for a WinStation with the Console Session.
     */
searchagain:
    uCount = 0;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {


        pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
        if (pWinStation->LogonId == 0) { 
           uCount++;

            /*
             * Now try to lock the WinStation.
             */
            if (pFoundWinStation == NULL){
               if ( !LockRefLock( &pWinStation->Lock ) )
                  goto searchagain;
                  pFoundWinStation = pWinStation;
            }
#if DBG
#else
    break;
#endif
        }
    }

    ASSERT((uCount <= 1));

    /*
     * If the WinStationList lock should not be held, then release it now.
     */
    LEAVECRIT( &WinStationListLock );

    if (pFoundWinStation != NULL) {
        if ((pFoundWinStation->State == State_Disconnected) && 
            (!pFoundWinStation->Flags) &&
            (pFoundWinStation->UserName[0] == L'\0') ) {
            return pFoundWinStation;
        } else {
            ReleaseWinStation(pFoundWinStation);
        }
    }
    return NULL;
}


BOOLEAN WinStationCheckConsoleSession(VOID)
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    // Check if there already is a console session
    pWinStation = FindConsoleSession();
    if (pWinStation != NULL) {
        ReleaseWinStation(pWinStation);
        return TRUE;
    } else {
        if (gConsoleCreationDisable > 0) {
            return FALSE;   
        }
    }


    //
    // See if we can use a disconnected session zero that is not in use
    //

    if (ConsoleReconnectInfo.hStack != NULL) {
        pWinStation = FindIdleSessionZero();

        if (gConsoleCreationDisable > 0) {
            if (pWinStation != NULL) {
                ReleaseWinStation(pWinStation);
            }
            return FALSE;
        }

        if (pWinStation != NULL) {

            NTSTATUS Status;


            pWinStation->Flags |= WSF_CONNECT;
            Status = WinStationDoReconnect(pWinStation, &ConsoleReconnectInfo); 
            pWinStation->Flags &= ~WSF_CONNECT;

            ReleaseWinStation(pWinStation);

            if (NT_SUCCESS(Status)) {
               RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
               return TRUE;
            }else{
                CleanupReconnect(&ConsoleReconnectInfo);
                RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
            }
        }

    }


    // We nead to create a new session to connect to the Console
    pWinStation = FindIdleWinStation();
    if (pWinStation == NULL) {
        WinStationCreateWorker( NULL, NULL, TRUE);
        pWinStation = FindIdleWinStation();
        if (pWinStation == NULL) {
            return FALSE;
        } 
    } 

    // It is possible that we may have found a idle winstation which is not yet started 
    // We shud Start the Winstation now in that case
    // To check this, check the Subsystem/Initial program is non null
    if ( (pWinStation->InitialCommandProcess == NULL) && (pWinStation->WindowsSubSysProcess == NULL) ) {

        // Protect this WinStation with WSF_IDLEBUSY flag because we want to use it (WinStationStart unlocks the winstation) 
        pWinStation->Flags |= WSF_IDLEBUSY; 

        Status = WinStationStart( pWinStation ) ; 
        if (Status != STATUS_SUCCESS) {
            // Starting the winstation failed - close connection endpoint and go and wait for another connection
            pWinStation->Flags &= ~WSF_IDLEBUSY;
            goto StartError;
        }
        pWinStation->Flags &= ~WSF_IDLEBUSY;

        Status = WinStationCreateComplete( pWinStation) ; 
        if (Status != STATUS_SUCCESS) {
            //  WinstationCreateComplete failed - close connection endpoint and go and wait for another connection
            goto StartError;
        } 
    }

    if (gConsoleCreationDisable > 0) {
        ReleaseWinStation(pWinStation);
        return FALSE;
    }

    // Set the session as owning the Console and wakeup the WaitForConnectWorker
    // Actually there is more to do than that and I will need to process LLS licensing here.
    pWinStation->fOwnsConsoleTerminal = TRUE;
    pWinStation->State = State_ConnectQuery;
    pWinStation->Flags &= ~WSF_IDLE;
    wcscpy(pWinStation->WinStationName, L"Console");

    CleanupReconnect(&ConsoleReconnectInfo);
    RtlZeroMemory(&ConsoleReconnectInfo,sizeof(RECONNECT_INFO));
    NtSetEvent( pWinStation->ConnectEvent, NULL );
    ReleaseWinStation(pWinStation);

    // If necessary, create another idle WinStation to replace the one being connected

    NtSetEvent(WinStationIdleControlEvent, NULL);

    return TRUE;

StartError:

    if ( !(pWinStation->Flags & (WSF_RESET | WSF_DELETE)) ) {
        pWinStation->Flags |= WSF_DELETE;
        WinStationTerminate( pWinStation );
        pWinStation->State = State_Down;                                                                                                                       
        //PostErrorValueEvent(EVENT_TS_WINSTATION_START_FAILED, Status);
        WinStationDeleteWorker(pWinStation);
    } else {
        ReleaseWinStation(pWinStation);
    }

    return FALSE;
}


/******************************************************************************
 * Tells win32k to load the console shadow mirroring driver
 *
 * ENTRY:
 *   pWinStation (input)
 *     Pointer to the console Winstation.
 *   pClientConfig (input)
 *     Pointer to the configuration of the shadow client.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *   STATUS_xxx     - error
 *****************************************************************************/
NTSTATUS ConsoleShadowStart( IN PWINSTATION pWinStation,
                             IN PWINSTATIONCONFIG2 pClientConfig,
                             IN PVOID pModuleData,
                             IN ULONG ModuleDataLength)
{
    NTSTATUS Status;
    WINSTATION_APIMSG WMsg;
    ULONG ReturnLength;

    TRACE((hTrace, TC_ICASRV, TT_API1, "CONSOLE REMOTING: LOAD DD\n"));

    Status = NtCreateEvent( &pWinStation->ShadowDisplayChangeEvent, EVENT_ALL_ACCESS,
                            NULL, NotificationEvent, FALSE );
    if ( !NT_SUCCESS( Status) ) {
        goto badevent;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->ShadowDisplayChangeEvent,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hDisplayChangeEvent,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto badevent;
    }

    /*
     *  Read Wd, Cd and Pd configuration data from registry
     */
    Status = RegConsoleShadowQuery( SERVERNAME_CURRENT,
                                 pWinStation->WinStationName,
                                 pClientConfig->Wd.WdPrefix,
                                 &pWinStation->Config,
                                 sizeof(WINSTATIONCONFIG2),
                                 &ReturnLength );
    if ( !NT_SUCCESS(Status) ) {
        goto badconfig;
    }


    /*
     * Build the Console Stack.
     * We need this special stack for the Console Shadow.
     */ 
    Status = IcaOpen( &pWinStation->hIca );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badopen;
    }

    Status = IcaStackOpen( pWinStation->hIca, Stack_Console,
                           (PROC)WsxStackIoControl, pWinStation, &pWinStation->hStack );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badstackopen;
    }


    DBGPRINT(("WinStationStart: pushing stack for console...\n"));

    /*
     * Load and initialize the WinStation extensions
     */
    pWinStation->pWsx = FindWinStationExtensionDll(
                                  pWinStation->Config.Wd.WsxDLL,
                                  pWinStation->Config.Wd.WdFlag );
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxWinStationInitialize )
    {
        Status = pWinStation->pWsx->pWsxWinStationInitialize(
                                      &pWinStation->pWsxContext );
    }

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badextension;
    }

    /*
     * Load the stack
     */
    Status = IcaPushConsoleStack( (HANDLE)(pWinStation->hStack),
                                  pWinStation->WinStationName,
                                  &pWinStation->Config,
                                  pModuleData,
                                  ModuleDataLength);

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV IcaOpen for console stack : Error 0x%x from IcaOpen, last error %d\n",
                  Status, GetLastError() ));
        goto badpushstack;
    }

    DBGPRINT(("WinStationStart: pushed stack for console\n"));



    /*
     * This code is based on that in WaitForConnectWorker (see wait.c)
     */
    if ( !(pWinStation->pWsx) ||
         !(pWinStation->pWsx->pWsxInitializeClientData) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, No pWsxInitializeClientData\n" ));
        Status = STATUS_CTX_SHADOW_INVALID;
        goto done;
    }

    pWinStation->State = State_Idle;

    /*
     * Open the beep channel (if not already) and duplicate it.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Beep,
                             NULL,
                             &pWinStation->hIcaBeepChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaBeepChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaBeepChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Open the thinwire channel (if not already) and duplicate it.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Virtual,
                             VIRTUAL_THINWIRE,
                             &pWinStation->hIcaThinwireChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaThinwireChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaThinwireChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_CHANNEL_ENABLE_SHADOW,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Video channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Video,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaVideoChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Keyboard channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Keyboard,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaKeyboardChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Mouse channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Mouse,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaMouseChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Command channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Command,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaCommandChannel );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Secure any virtual channels
     */
    VirtualChannelSecurity( pWinStation );

    /*
     * Get the client data
     */
    Status = pWinStation->pWsx->pWsxInitializeClientData(
                         pWinStation->pWsxContext,
                         pWinStation->hStack,
                         pWinStation->hIca,
                         pWinStation->hIcaThinwireChannel,
                         pWinStation->VideoModuleName,
                         sizeof(pWinStation->VideoModuleName),
                         &pWinStation->Config.Config.User,
                         &pWinStation->Client.HRes,
                         &pWinStation->Client.VRes,
                         &pWinStation->Client.ColorDepth,
                         &WMsg.u.DoConnect );
    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, InitializeClientData failed 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * Store WinStation name in connect msg
     */
    RtlCopyMemory( WMsg.u.DoConnect.WinStationName,
                   pWinStation->WinStationName,
                   sizeof(WINSTATIONNAME) );

    /*
     * Save screen resolution, and color depth
     */
    WMsg.u.DoConnect.HRes = pWinStation->Client.HRes;
    WMsg.u.DoConnect.VRes = pWinStation->Client.VRes;

    /*
     * Translate the color to the format excpected in winsrv
     */

    switch(pWinStation->Client.ColorDepth){
    case 1:
       WMsg.u.DoConnect.ColorDepth=4 ; // 16 colors
      break;
    case 2:
       WMsg.u.DoConnect.ColorDepth=8 ; // 256
       break;
    case 4:
       WMsg.u.DoConnect.ColorDepth= 16;// 64K
       break;
    case 8:
       WMsg.u.DoConnect.ColorDepth= 24;// 16M
       break;
#define DC_HICOLOR
#ifdef DC_HICOLOR
    case 16:
       WMsg.u.DoConnect.ColorDepth= 15;// 32K
       break;
#endif
    default:
       WMsg.u.DoConnect.ColorDepth=8 ;
       break;
    }

    /*
     * Tell Win32 about the connection
     */
    WMsg.ApiNumber = SMWinStationDoConnect;
    WMsg.u.DoConnect.ConsoleShadowFlag = TRUE;

    Status = SendWinStationCommand( pWinStation, &WMsg, 60 );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: SMWinStationDoConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    if ( !NT_SUCCESS( Status ) ) {
        DBGPRINT(( "TERMSRV: ConsoleShadowStart, LogonId=%d, SendWinStationCommand failed 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto done;
    }

    /*
     * This flag is important: without it, WinStationDoDisconnect won't let
     * Win32k know about the disconnection, so it can't unload the chained DD.
     */
    pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;

    /*
     * Set connect time
     */
    NtQuerySystemTime( &pWinStation->ConnectTime );

    /*
     * no need for logon timers here - we don't want to
     * stop the console session!
     */

    TRACE((hTrace, TC_ICASRV, TT_API1, "CONSOLE REMOTING: LOADED DD\n"));
    pWinStation->State = State_Active;

    return Status;

    /*
     * Error paths:
     */
done:
    // to undo the push stack, does the IcaStackClose below suffice?

    pWinStation->State = State_Active;

badpushstack:
    if (pWinStation->pWsxContext) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationRundown ) {
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
    }

badextension:
    pWinStation->pWsx = NULL;

    IcaStackClose( pWinStation->hStack );

badstackopen:
    IcaClose( pWinStation->hIca );

badopen:
    pWinStation->Config = gConsoleConfig;

badconfig:
    NtClose(pWinStation->ShadowDisplayChangeEvent);
    pWinStation->ShadowDisplayChangeEvent = NULL;

badevent:
    return Status;
}


/******************************************************************************
 * Tells win32k to unload the console shadow mirroring driver
 *
 * ENTRY:
 *   pWinStation (input)
 *     Pointer to the console Winstation.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *   STATUS_xxx     - error
 *****************************************************************************/
NTSTATUS ConsoleShadowStop(PWINSTATION pWinStation)
{
    WINSTATION_APIMSG ConsoleShadowStopMsg;
    NTSTATUS Status;

    /*
     * Tell Win32k to unload the chained DD
     */
    ConsoleShadowStopMsg.ApiNumber = SMWinStationDoDisconnect;
    ConsoleShadowStopMsg.u.DoDisconnect.ConsoleShadowFlag = TRUE;
    Status = SendWinStationCommand( pWinStation, &ConsoleShadowStopMsg, 600 );
    if ( !NT_SUCCESS(Status) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: CSR ConsoleShadowStop failed LogonId=%d Status=0x%x\n",
                   pWinStation->LogonId, Status ));
    }

    /*
     * No matter what happened, everything must be undone.
     */
    if (pWinStation->pWsxContext) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationRundown ) {
            pWinStation->pWsx->pWsxWinStationRundown( pWinStation->pWsxContext );
        }
        pWinStation->pWsxContext = NULL;
    }

    pWinStation->pWsx = NULL;

    IcaStackClose( pWinStation->hStack );

    IcaClose( pWinStation->hIca );

    /*
     * Close various ICA channel handles
     */
    if ( pWinStation->hIcaBeepChannel ) {
        (void) IcaChannelClose( pWinStation->hIcaBeepChannel );
        pWinStation->hIcaBeepChannel = NULL;
    }

    if ( pWinStation->hIcaThinwireChannel ) {
        (void) IcaChannelClose( pWinStation->hIcaThinwireChannel );
        pWinStation->hIcaThinwireChannel = NULL;
    }

    /*
     * Restore console config.
     */
    pWinStation->Config = gConsoleConfig;

    NtClose(pWinStation->ShadowDisplayChangeEvent);
    pWinStation->ShadowDisplayChangeEvent = NULL;

    return Status;
}



ULONG CodePairs[] = {

// Very general NT Status

    STATUS_SUCCESS,                 NO_ERROR,
    STATUS_NO_MEMORY,               ERROR_NOT_ENOUGH_MEMORY,
    STATUS_ACCESS_DENIED,           ERROR_ACCESS_DENIED,
    STATUS_INSUFFICIENT_RESOURCES,  ERROR_NO_SYSTEM_RESOURCES,
    STATUS_BUFFER_TOO_SMALL,        ERROR_INSUFFICIENT_BUFFER,
    STATUS_OBJECT_NAME_NOT_FOUND,   ERROR_FILE_NOT_FOUND,
    STATUS_NOT_SUPPORTED,           ERROR_NOT_SUPPORTED,
  
// RPC specific Status  
  
    RPC_NT_SERVER_UNAVAILABLE, RPC_S_SERVER_UNAVAILABLE,
    RPC_NT_INVALID_STRING_BINDING, RPC_S_INVALID_STRING_BINDING,
    RPC_NT_WRONG_KIND_OF_BINDING, RPC_S_WRONG_KIND_OF_BINDING,
    RPC_NT_PROTSEQ_NOT_SUPPORTED, RPC_S_PROTSEQ_NOT_SUPPORTED,
    RPC_NT_INVALID_RPC_PROTSEQ, RPC_S_INVALID_RPC_PROTSEQ,
    RPC_NT_INVALID_STRING_UUID, RPC_S_INVALID_STRING_UUID,
    RPC_NT_INVALID_ENDPOINT_FORMAT, RPC_S_INVALID_ENDPOINT_FORMAT,
    RPC_NT_INVALID_NET_ADDR, RPC_S_INVALID_NET_ADDR,
    RPC_NT_NO_ENDPOINT_FOUND, RPC_S_NO_ENDPOINT_FOUND,
    RPC_NT_INVALID_TIMEOUT, RPC_S_INVALID_TIMEOUT,
    RPC_NT_OBJECT_NOT_FOUND, RPC_S_OBJECT_NOT_FOUND,
    RPC_NT_ALREADY_REGISTERED, RPC_S_ALREADY_REGISTERED,
    RPC_NT_TYPE_ALREADY_REGISTERED, RPC_S_TYPE_ALREADY_REGISTERED,
    RPC_NT_ALREADY_LISTENING, RPC_S_ALREADY_LISTENING,
    RPC_NT_NO_PROTSEQS_REGISTERED, RPC_S_NO_PROTSEQS_REGISTERED,
    RPC_NT_NOT_LISTENING, RPC_S_NOT_LISTENING,
    RPC_NT_UNKNOWN_MGR_TYPE, RPC_S_UNKNOWN_MGR_TYPE,
    RPC_NT_UNKNOWN_IF, RPC_S_UNKNOWN_IF,
    RPC_NT_NO_BINDINGS, RPC_S_NO_BINDINGS,
    RPC_NT_NO_MORE_BINDINGS, RPC_S_NO_MORE_BINDINGS,
    RPC_NT_NO_PROTSEQS, RPC_S_NO_PROTSEQS,
    RPC_NT_CANT_CREATE_ENDPOINT, RPC_S_CANT_CREATE_ENDPOINT,
    RPC_NT_OUT_OF_RESOURCES, RPC_S_OUT_OF_RESOURCES,
    RPC_NT_SERVER_TOO_BUSY, RPC_S_SERVER_TOO_BUSY,
    RPC_NT_INVALID_NETWORK_OPTIONS, RPC_S_INVALID_NETWORK_OPTIONS,
    RPC_NT_NO_CALL_ACTIVE, RPC_S_NO_CALL_ACTIVE,
    RPC_NT_CALL_FAILED, RPC_S_CALL_FAILED,
    RPC_NT_CALL_FAILED_DNE, RPC_S_CALL_FAILED_DNE,
    RPC_NT_PROTOCOL_ERROR, RPC_S_PROTOCOL_ERROR,
    RPC_NT_UNSUPPORTED_TRANS_SYN, RPC_S_UNSUPPORTED_TRANS_SYN,
    RPC_NT_UNSUPPORTED_TYPE, RPC_S_UNSUPPORTED_TYPE,
    RPC_NT_INVALID_TAG, RPC_S_INVALID_TAG,
    RPC_NT_INVALID_BOUND, RPC_S_INVALID_BOUND,
    RPC_NT_NO_ENTRY_NAME, RPC_S_NO_ENTRY_NAME,
    RPC_NT_INVALID_NAME_SYNTAX, RPC_S_INVALID_NAME_SYNTAX,
    RPC_NT_UNSUPPORTED_NAME_SYNTAX, RPC_S_UNSUPPORTED_NAME_SYNTAX,
    RPC_NT_UUID_NO_ADDRESS, RPC_S_UUID_NO_ADDRESS,
    RPC_NT_DUPLICATE_ENDPOINT, RPC_S_DUPLICATE_ENDPOINT,
    RPC_NT_UNKNOWN_AUTHN_TYPE, RPC_S_UNKNOWN_AUTHN_TYPE,
    RPC_NT_MAX_CALLS_TOO_SMALL, RPC_S_MAX_CALLS_TOO_SMALL,
    RPC_NT_STRING_TOO_LONG, RPC_S_STRING_TOO_LONG,
    RPC_NT_PROTSEQ_NOT_FOUND, RPC_S_PROTSEQ_NOT_FOUND,
    RPC_NT_PROCNUM_OUT_OF_RANGE, RPC_S_PROCNUM_OUT_OF_RANGE,
    RPC_NT_BINDING_HAS_NO_AUTH, RPC_S_BINDING_HAS_NO_AUTH,
    RPC_NT_UNKNOWN_AUTHN_SERVICE, RPC_S_UNKNOWN_AUTHN_SERVICE,
    RPC_NT_UNKNOWN_AUTHN_LEVEL, RPC_S_UNKNOWN_AUTHN_LEVEL,
    RPC_NT_INVALID_AUTH_IDENTITY, RPC_S_INVALID_AUTH_IDENTITY,
    RPC_NT_UNKNOWN_AUTHZ_SERVICE, RPC_S_UNKNOWN_AUTHZ_SERVICE,
    RPC_NT_NOTHING_TO_EXPORT, RPC_S_NOTHING_TO_EXPORT,
    RPC_NT_INCOMPLETE_NAME, RPC_S_INCOMPLETE_NAME,
    RPC_NT_INVALID_VERS_OPTION, RPC_S_INVALID_VERS_OPTION,
    RPC_NT_NO_MORE_MEMBERS, RPC_S_NO_MORE_MEMBERS,
    RPC_NT_NOT_ALL_OBJS_UNEXPORTED, RPC_S_NOT_ALL_OBJS_UNEXPORTED,
    RPC_NT_INTERFACE_NOT_FOUND, RPC_S_INTERFACE_NOT_FOUND,
    RPC_NT_ENTRY_ALREADY_EXISTS, RPC_S_ENTRY_ALREADY_EXISTS,
    RPC_NT_ENTRY_NOT_FOUND, RPC_S_ENTRY_NOT_FOUND,
    RPC_NT_NAME_SERVICE_UNAVAILABLE, RPC_S_NAME_SERVICE_UNAVAILABLE,
    RPC_NT_INVALID_NAF_ID, RPC_S_INVALID_NAF_ID,
    RPC_NT_CANNOT_SUPPORT, RPC_S_CANNOT_SUPPORT,
    RPC_NT_NO_CONTEXT_AVAILABLE, RPC_S_NO_CONTEXT_AVAILABLE,
    RPC_NT_INTERNAL_ERROR, RPC_S_INTERNAL_ERROR,
    RPC_NT_ZERO_DIVIDE, RPC_S_ZERO_DIVIDE,
    RPC_NT_ADDRESS_ERROR, RPC_S_ADDRESS_ERROR,
    RPC_NT_FP_DIV_ZERO, RPC_S_FP_DIV_ZERO,
    RPC_NT_FP_UNDERFLOW, RPC_S_FP_UNDERFLOW,
    RPC_NT_FP_OVERFLOW, RPC_S_FP_OVERFLOW,
    RPC_NT_NO_MORE_ENTRIES, RPC_X_NO_MORE_ENTRIES,
    RPC_NT_SS_CHAR_TRANS_OPEN_FAIL, RPC_X_SS_CHAR_TRANS_OPEN_FAIL,
    RPC_NT_SS_CHAR_TRANS_SHORT_FILE, RPC_X_SS_CHAR_TRANS_SHORT_FILE,
    RPC_NT_SS_CONTEXT_MISMATCH, ERROR_INVALID_HANDLE,
    RPC_NT_SS_CONTEXT_DAMAGED, RPC_X_SS_CONTEXT_DAMAGED,
    RPC_NT_SS_HANDLES_MISMATCH, RPC_X_SS_HANDLES_MISMATCH,
    RPC_NT_SS_CANNOT_GET_CALL_HANDLE, RPC_X_SS_CANNOT_GET_CALL_HANDLE,
    RPC_NT_NULL_REF_POINTER, RPC_X_NULL_REF_POINTER,
    RPC_NT_ENUM_VALUE_OUT_OF_RANGE, RPC_X_ENUM_VALUE_OUT_OF_RANGE,
    RPC_NT_BYTE_COUNT_TOO_SMALL, RPC_X_BYTE_COUNT_TOO_SMALL,
    RPC_NT_BAD_STUB_DATA, RPC_X_BAD_STUB_DATA,
    RPC_NT_INVALID_OBJECT, RPC_S_INVALID_OBJECT,
    RPC_NT_GROUP_MEMBER_NOT_FOUND, RPC_S_GROUP_MEMBER_NOT_FOUND,
    RPC_NT_NO_INTERFACES, RPC_S_NO_INTERFACES,
    RPC_NT_CALL_CANCELLED, RPC_S_CALL_CANCELLED,
    RPC_NT_BINDING_INCOMPLETE, RPC_S_BINDING_INCOMPLETE,
    RPC_NT_COMM_FAILURE, RPC_S_COMM_FAILURE,
    RPC_NT_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,
    RPC_NT_NO_PRINC_NAME, RPC_S_NO_PRINC_NAME,
    RPC_NT_NOT_RPC_ERROR, RPC_S_NOT_RPC_ERROR,
    RPC_NT_UUID_LOCAL_ONLY, RPC_S_UUID_LOCAL_ONLY,
    RPC_NT_SEC_PKG_ERROR, RPC_S_SEC_PKG_ERROR,
    RPC_NT_NOT_CANCELLED, RPC_S_NOT_CANCELLED,
    RPC_NT_INVALID_ES_ACTION, RPC_X_INVALID_ES_ACTION,
    RPC_NT_WRONG_ES_VERSION, RPC_X_WRONG_ES_VERSION,
    RPC_NT_WRONG_STUB_VERSION, RPC_X_WRONG_STUB_VERSION,
    RPC_NT_INVALID_PIPE_OBJECT,    RPC_X_INVALID_PIPE_OBJECT,
    RPC_NT_WRONG_PIPE_VERSION,     RPC_X_WRONG_PIPE_VERSION,
    RPC_NT_SEND_INCOMPLETE,        RPC_S_SEND_INCOMPLETE,
    RPC_NT_INVALID_ASYNC_HANDLE,   RPC_S_INVALID_ASYNC_HANDLE,
    RPC_NT_INVALID_ASYNC_CALL,     RPC_S_INVALID_ASYNC_CALL,
    RPC_NT_PIPE_CLOSED,            RPC_X_PIPE_CLOSED,
    RPC_NT_PIPE_EMPTY,             RPC_X_PIPE_EMPTY,
    RPC_NT_PIPE_DISCIPLINE_ERROR,  RPC_X_PIPE_DISCIPLINE_ERROR,

 
    // Terminal Server Specific Status.

    STATUS_CTX_CLOSE_PENDING,               ERROR_CTX_CLOSE_PENDING,
    STATUS_CTX_NO_OUTBUF,                   ERROR_CTX_NO_OUTBUF,
    STATUS_CTX_MODEM_INF_NOT_FOUND,         ERROR_CTX_MODEM_INF_NOT_FOUND,
    STATUS_CTX_INVALID_MODEMNAME,           ERROR_CTX_INVALID_MODEMNAME,
    STATUS_CTX_RESPONSE_ERROR,              ERROR_CTX_MODEM_RESPONSE_ERROR,
    STATUS_CTX_MODEM_RESPONSE_TIMEOUT,      ERROR_CTX_MODEM_RESPONSE_TIMEOUT,
    STATUS_CTX_MODEM_RESPONSE_NO_CARRIER,   ERROR_CTX_MODEM_RESPONSE_NO_CARRIER,
    STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE,  ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE,
    STATUS_CTX_MODEM_RESPONSE_BUSY,         ERROR_CTX_MODEM_RESPONSE_BUSY,
    STATUS_CTX_MODEM_RESPONSE_VOICE,        ERROR_CTX_MODEM_RESPONSE_VOICE,
    STATUS_CTX_TD_ERROR,                    ERROR_CTX_TD_ERROR,
    STATUS_LPC_REPLY_LOST,                  ERROR_CONNECTION_ABORTED,
    STATUS_CTX_WINSTATION_NAME_INVALID,     ERROR_CTX_WINSTATION_NAME_INVALID,
    STATUS_CTX_WINSTATION_NOT_FOUND,        ERROR_CTX_WINSTATION_NOT_FOUND,
    STATUS_CTX_WINSTATION_NAME_COLLISION,   ERROR_CTX_WINSTATION_ALREADY_EXISTS,
    STATUS_CTX_WINSTATION_BUSY,             ERROR_CTX_WINSTATION_BUSY,
    STATUS_CTX_GRAPHICS_INVALID,            ERROR_CTX_GRAPHICS_INVALID,
    STATUS_CTX_BAD_VIDEO_MODE,              ERROR_CTX_BAD_VIDEO_MODE,
    STATUS_CTX_NOT_CONSOLE,                 ERROR_CTX_NOT_CONSOLE,
    STATUS_CTX_CLIENT_QUERY_TIMEOUT,        ERROR_CTX_CLIENT_QUERY_TIMEOUT,
    STATUS_CTX_CONSOLE_DISCONNECT,          ERROR_CTX_CONSOLE_DISCONNECT,
    STATUS_CTX_CONSOLE_CONNECT,             ERROR_CTX_CONSOLE_CONNECT,
    STATUS_CTX_SHADOW_DENIED,               ERROR_CTX_SHADOW_DENIED,
    STATUS_CTX_SHADOW_INVALID,              ERROR_CTX_SHADOW_INVALID,
    STATUS_CTX_SHADOW_DISABLED,             ERROR_CTX_SHADOW_DISABLED,
    STATUS_CTX_WINSTATION_ACCESS_DENIED,    ERROR_CTX_WINSTATION_ACCESS_DENIED,
    STATUS_CTX_INVALID_PD,                  ERROR_CTX_INVALID_PD,
    STATUS_CTX_PD_NOT_FOUND,                ERROR_CTX_PD_NOT_FOUND,
    STATUS_CTX_INVALID_WD,                  ERROR_CTX_INVALID_WD,
    STATUS_CTX_WD_NOT_FOUND,                ERROR_CTX_WD_NOT_FOUND,
    STATUS_CTX_CLIENT_LICENSE_IN_USE,       ERROR_CTX_CLIENT_LICENSE_IN_USE, 
    STATUS_CTX_CLIENT_LICENSE_NOT_SET,      ERROR_CTX_CLIENT_LICENSE_NOT_SET,
    STATUS_CTX_LICENSE_NOT_AVAILABLE,       ERROR_CTX_LICENSE_NOT_AVAILABLE, 
    STATUS_CTX_LICENSE_CLIENT_INVALID,      ERROR_CTX_LICENSE_CLIENT_INVALID,
    STATUS_CTX_LICENSE_EXPIRED,             ERROR_CTX_LICENSE_EXPIRED,       

};


/*
 * WinStationWinerrorToNtStatus
 * Translate a Windows error code into an NTSTATUS code.
 */

NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError)
{
    ULONG ulIndex;

    for (ulIndex = 0 ; ulIndex < sizeof(CodePairs)/sizeof(CodePairs[0]) ; ulIndex+=2) {
        if (CodePairs[ ulIndex+1 ] == ulWinError ) {
            return (NTSTATUS) CodePairs[ ulIndex];
        }
    }
    return STATUS_UNSUCCESSFUL;
}



/*
 * WinStationSetMaxOustandingConnections() set the default values
 * for the maximum number of outstanding connection connections.
 * Reads the registry configuration for it if it exists.
 */

VOID
WinStationSetMaxOustandingConnections()
{
    SYSTEM_BASIC_INFORMATION BasicInfo;
    HKEY hKey;
    NTSTATUS Status;
    BOOL bLargeMachine = FALSE;


    // Initialize date of last delayed connection that was logged into
    // event log. In order not to flood event log with what may not be a DOS
    // attack but just a normal regulation action, delayed connection are not
    // logged more than once in 24h.

    GetSystemTime(&LastLoggedDelayConnection);

    // Init the default values for maximum outstanding connection and
    // Maximumn outstanding connections from single IP address. For
    // Non server platforms these are fixed values.

    if (!gbServer) {
        MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS_PRO;
        MaxSingleOutStandingConnect = MAX_DEFAULT_SINGLE_CONNECTIONS_PRO;
    }  else {
        // Determine if this Machine has over 512Mb of memory
        // In order to set defaults Values (registry settings overide this anyway).
        // Default value are not changed for machines over 512 Mb : Session regulation
        // is trigered if we have 50 outstanding connection and we will wait 30 seconds
        // before acception new connections. For machines with less than 512 Mb, regulation
        // needs to be stronger : it is trigered at lower number of  outstanding connections and we will
        // wait 70 seconds before accepting new connections.

        MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS;

        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    NULL
                    );

        if (NT_SUCCESS(Status)) {
            if (BasicInfo.PageSize > 1024*1024) {
                MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS;
                DelayConnectionTime = 30*1000;

            }else{
                ULONG ulPagesPerMeg = 1024*1024/BasicInfo.PageSize;
                ULONG ulMemSizeInMegabytes = (ULONG)BasicInfo.NumberOfPhysicalPages/ulPagesPerMeg ;

                if (ulMemSizeInMegabytes >= 512) {
                    MaxOutStandingConnect = MAX_DEFAULT_CONNECTIONS;
                    DelayConnectionTime = 70*1000;
                } else if (ulMemSizeInMegabytes >= 256) {
                    MaxOutStandingConnect = 15;
                    DelayConnectionTime = 70*1000;

                } else if (ulMemSizeInMegabytes >= 128) {
                    MaxOutStandingConnect = 10;
                    DelayConnectionTime = 70*1000;
                } else {
                    MaxOutStandingConnect = 5;
                    DelayConnectionTime = 70*1000;
                }
            }
        }


        //
        //  set max number of outstanding connection from single IP
        //
        if ( MaxOutStandingConnect < MAX_SINGLE_CONNECT_THRESHOLD_DIFF*5)
        {
            MaxSingleOutStandingConnect = MaxOutStandingConnect - 1;
        } else {
            MaxSingleOutStandingConnect = MaxOutStandingConnect - MAX_SINGLE_CONNECT_THRESHOLD_DIFF;
        }
    }
    

}

/*
 * Make sure we can Preallocate an Idle session before allowing console disconnect.
 *
 */

NTSTATUS
CheckIdleWinstation()
{
    PWINSTATION pWinStation;
    NTSTATUS Status;
    pWinStation = FindIdleWinStation();

    if ( pWinStation == NULL ) {

        /*
         * Create another idle WinStation
         */
        Status = WinStationCreateWorker( NULL, NULL, TRUE );
        if ( NT_SUCCESS( Status ) ) {
            pWinStation = FindIdleWinStation();
            if ( pWinStation == NULL ) {
                return STATUS_INSUFFICIENT_RESOURCES;
            } 
        } else {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

    }

    ReleaseWinStation(pWinStation);
    return STATUS_SUCCESS;
}

NTSTATUS
InitializeWinStationSecurityLock(
    VOID
    )
{
    NTSTATUS Status ;

    try 
    {
        RtlInitializeResource( &WinStationSecurityLock );
        Status = STATUS_SUCCESS ;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Status = GetExceptionCode();
    }


    return Status;
}

//gets the product id from the registry
NTSTATUS 
GetProductIdFromRegistry( WCHAR* DigProductId, DWORD dwSize )
{
    HKEY hKey = NULL;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ZeroMemory( DigProductId, dwSize );
    
    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_WINDOWS_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS )
    {
        DWORD dwType = REG_SZ;
        if( RegQueryValueEx( hKey, 
                             L"ProductId", NULL, &dwType,
                             (LPBYTE)DigProductId, 
                             &dwSize
                             ) == ERROR_SUCCESS )
            status = STATUS_SUCCESS;
    }

    if (hKey)
      RegCloseKey( hKey );

    return status;
}

//
//  Gets the remote IP address of the connections
//  and supports statistics of how many outstanding connections
//  are there for this client, if the number of outstanding connections
//  reaches MaxSingleOutStandingConnections, *pbBlocked is returned FALSE
//  the functions returns TRUE on success
//
//  Paramters:
//      pContext
//      pEndpoint   - handle of this connection
//      EndpointLength - td layer needs the length
//      pin_addr    - returns remote IP address
//      pbBlocked   - returns TRUE if the connection has to be blocked, because of excessive number of
//                    outstanding connections
//
BOOL
Filter_AddOutstandingConnection(
        IN HANDLE   pContext,
        IN PVOID    pEndpoint,
        IN ULONG    EndpointLength,
        OUT PBYTE   pin_addr,
        OUT PUINT   puAddrSize,
        OUT BOOLEAN *pbBlocked
    )
{
    BOOL rv = FALSE;
    PTS_OUTSTANDINGCONNECTION pIter, pPrev;
    TS_OUTSTANDINGCONNECTION key;
    struct  sockaddr_in6 addr6;
    ULONG   AddrBytesReturned;
    NTSTATUS Status;
    PVOID   paddr;
    BOOL    bLocked = FALSE;
    PVOID   bSucc;
    BOOLEAN bNewElement;
    ULONGLONG currentTime;


    *pbBlocked = FALSE;

    Status = IcaStackIoControl(  pContext,
                                 IOCTL_TS_STACK_QUERY_REMOTEADDRESS,
                                 pEndpoint,
                                 EndpointLength,
                                 &addr6,
                                 sizeof( addr6 ),
                                 &AddrBytesReturned );
    if ( !NT_SUCCESS( Status ))
    {
        goto exitpt;
    }

    if ( AF_INET == addr6.sin6_family )
    {
        key.uAddrSize = 4;
        paddr = &(((struct sockaddr_in *)&addr6)->sin_addr.s_addr);
    } else if ( AF_INET6 == addr6.sin6_family )
    {
        key.uAddrSize = 16;
        paddr = &(addr6.sin6_addr);
    } else {
        ASSERT( 0 );
    }
    ASSERT ( *puAddrSize >= key.uAddrSize );

    RtlCopyMemory( pin_addr, paddr, key.uAddrSize );
    *puAddrSize = key.uAddrSize;

    ENTERCRIT( &FilterLock );
    bLocked = TRUE;

    //
    //  Check first in the outstanding connections
    //
    RtlCopyMemory( key.addr, paddr, key.uAddrSize );
    pIter = RtlLookupElementGenericTable( &gOutStandingConnections, &key );

    if ( NULL == pIter )
    {

        //
        //  check in the blocked connections list
        //
        pPrev = NULL;
        pIter = g_pBlockedConnections;
        while ( NULL != pIter )
        {
            if ( key.uAddrSize == pIter->uAddrSize &&
                 key.uAddrSize == RtlCompareMemory( pIter->addr, paddr, key.uAddrSize ))
            {
                break;
            }
            pPrev = pIter;
            pIter = pIter->pNext;
        }

        if ( NULL != pIter )
        {
            pIter->NumOutStandingConnect ++;
            //
            //  already blocked, check for exparation time
            //
            GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );
            if ( currentTime > pIter->blockUntilTime )
            {
                //
                // unblock, remove from list
                //
                pIter->blockUntilTime = 0;
                if ( NULL != pPrev )
                {
                    pPrev->pNext = pIter->pNext;
                } else {
                    g_pBlockedConnections = pIter->pNext;
                }

                bSucc = RtlInsertElementGenericTable( &gOutStandingConnections, pIter, sizeof( *pIter ), &bNewElement );
                if ( !bSucc )
                {
                    MemFree( pIter );
                    goto exitpt;
                }
                ASSERT( bNewElement );
                MemFree( pIter );

            } else {
                *pbBlocked = TRUE;
            }

        } else {
            //
            //  this will be a new connection
            //
            key.NumOutStandingConnect = 1;

            bSucc = RtlInsertElementGenericTable( &gOutStandingConnections, &key, sizeof( key ), &bNewElement );
            if ( !bSucc )
            {
                goto exitpt;
            }
            ASSERT( bNewElement );
        }
    } else {

        pIter->NumOutStandingConnect ++;
        //
        //  Check if we need to block this connection
        //
        if ( pIter->NumOutStandingConnect > MaxSingleOutStandingConnect )
        {
            *pbBlocked = TRUE;
            key.NumOutStandingConnect = pIter->NumOutStandingConnect;

            GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );
            // DelayConnectionTime is in ms
            // currentTime is in 100s ns
            key.blockUntilTime = currentTime + ((ULONGLONG)10000) * ((ULONGLONG)DelayConnectionTime);

            RtlDeleteElementGenericTable( &gOutStandingConnections, &key );

            //
            //  add to the blocked connections
            //
            pIter = MemAlloc( sizeof( *pIter ));
            if ( NULL == pIter )
            {
                goto exitpt;
            }

            RtlCopyMemory( pIter, &key, sizeof( *pIter ));
            pIter->pNext = g_pBlockedConnections;
            g_pBlockedConnections = pIter;

            //
            //  log at most one event on every 15 minutes
            //
            if ( LastLoggedBlockedConnection + ((ULONGLONG)10000) * (15 * 60 * 1000) < currentTime )
            {
                LastLoggedBlockedConnection = currentTime;
                WriteErrorLogEntry( EVENT_TOO_MANY_CONNECTIONS, &key.addr, key.uAddrSize );
            }
        }

    }

    rv = TRUE;

exitpt:

    if ( bLocked )
    {
        LEAVECRIT( &FilterLock );
    }

    return rv;
}

//
//  Removes outstanding connections added in AddOutStandingConnection
//
BOOL
Filter_RemoveOutstandingConnection(
        IN PBYTE    paddr,
        IN UINT     uAddrSize
        )
{
    PTS_OUTSTANDINGCONNECTION pIter, pPrev, pNext;
    TS_OUTSTANDINGCONNECTION key;
    ULONGLONG   currentTime;
    NTSTATUS    Status;
    ULONG       AddrBytesReturned;
#if DBG
    BOOL        bFound = FALSE;
#endif

    pPrev = NULL;
    GetSystemTimeAsFileTime( (LPFILETIME)&currentTime );

    key.uAddrSize = uAddrSize;
    RtlCopyMemory( key.addr, paddr, uAddrSize );

    ENTERCRIT( &FilterLock );

    pIter = RtlLookupElementGenericTable( &gOutStandingConnections, &key );
    if ( NULL != pIter )
    {
#if DBG
        bFound = TRUE;
#endif
        pIter->NumOutStandingConnect--;

        //
        //  cleanup connections w/o reference
        //
        if ( 0 == pIter->NumOutStandingConnect )
        {
            RtlDeleteElementGenericTable( &gOutStandingConnections, &key );
        }

    }

    //
    //  work through the blocked list
    //
    pIter = g_pBlockedConnections;

    while( pIter )
    {
        if ( uAddrSize == pIter->uAddrSize &&
             uAddrSize == RtlCompareMemory( pIter->addr, paddr, uAddrSize ))
        {
            ASSERT( 0 != pIter->NumOutStandingConnect );
            pIter->NumOutStandingConnect--;
#if DBG
            ASSERT( !bFound );
            bFound = TRUE;
#endif
        }

        //
        //  cleanup all connections w/o references
        //
        if ( 0 == pIter->NumOutStandingConnect &&
             currentTime > pIter->blockUntilTime )
        {
            if ( NULL == pPrev )
            {
                g_pBlockedConnections = pIter->pNext;
            } else {
                pPrev->pNext = pIter->pNext;
            }
            //
            //  remove item and advance to the next
            //
            pNext = pIter->pNext;
            MemFree( pIter );
            pIter = pNext;
        } else {
            //
            //  advance to the next item
            //
            pPrev = pIter;
            pIter = pIter->pNext;
        }

    }

    ASSERT( bFound );

    /*
     *  Decrement the number of outstanding connections.
     *  If connections drop back to max value, set the connect event.
     */
#if DBG
    //
    //  ensure proper cleanup
    //
    bFound = ( 0 == gOutStandingConnections.NumberGenericTableElements );
    for( pIter = g_pBlockedConnections; pIter; pIter = pIter->pNext )
    {
        bFound = bFound & ( 0 == pIter->NumOutStandingConnect );
    }

#endif

    LEAVECRIT( &FilterLock );

    return TRUE;
}

/*****************************************************************************
 *
 *  Filter_CompareConnectionEntry
 *
 *   Generic table support.Compare two connection entries
 *
 *
 ****************************************************************************/

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Filter_CompareConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
)
{
    PTS_OUTSTANDINGCONNECTION pFirst, pSecond;
    INT rc;

    pFirst = (PTS_OUTSTANDINGCONNECTION)FirstInstance;
    pSecond = (PTS_OUTSTANDINGCONNECTION)SecondInstance;

    if ( pFirst->uAddrSize < pSecond->uAddrSize )
    {
        return GenericLessThan;
    } else if ( pFirst->uAddrSize > pSecond->uAddrSize ) 
    {
        return GenericGreaterThan;
    }

    rc = memcmp( pFirst->addr, pSecond->addr, pFirst->uAddrSize );
    return ( rc < 0 )?GenericLessThan:
           ( rc > 0 )?GenericGreaterThan:
                      GenericEqual;
}

/*****************************************************************************
 *
 *  Filter_AllocateConnectionEntry
 *
 *   Generic table support. Allocates a new table entry
 *
 *
 ****************************************************************************/

PVOID
Filter_AllocateConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  CLONG                       ByteSize
    )
{
    return MemAlloc( ByteSize );
}

/*****************************************************************************
 *
 *  Filter_FreeConnectionEntry
 *
 *   Generic table support. frees a new table entry
 *
 *
 ****************************************************************************/

VOID
Filter_FreeConnectionEntry (
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       Buffer
    )
{
    MemFree( Buffer );
}

VOID
Filter_DestroyList(
    VOID
    )
{
    PTS_OUTSTANDINGCONNECTION p;
    TS_OUTSTANDINGCONNECTION con;

    while ( NULL != g_pBlockedConnections )
    {
        p = g_pBlockedConnections->pNext;
        MemFree( g_pBlockedConnections );
        g_pBlockedConnections = p;
    }

    while (p = RtlEnumerateGenericTable( &gOutStandingConnections, TRUE)) 
    {
        RtlCopyMemory( &con, p, sizeof( con ));
        RtlDeleteElementGenericTable( &gOutStandingConnections, &con);
    }
}

//
// ComputeHMACVerifier
// Compute the HMAC verifier from the random
// and the cookie
//
BOOL
ComputeHMACVerifier(
    PBYTE pCookie,     //IN - the shared secret
    LONG cbCookieLen,  //IN - the shared secret len
    PBYTE pRandom,     //IN - the session random
    LONG cbRandomLen,  //IN - the session random len
    PBYTE pVerifier,   //OUT- the verifier
    LONG cbVerifierLen //IN - the verifier buffer length
    )
{
    HMACMD5_CTX hmacctx;
    BOOL fRet = FALSE;

    ASSERT(cbVerifierLen >= MD5DIGESTLEN);

    if (!(pCookie &&
          cbCookieLen &&
          pRandom &&
          cbRandomLen &&
          pVerifier &&
          cbVerifierLen)) {
        goto bail_out;
    }

    HMACMD5Init(&hmacctx, pCookie, cbCookieLen);

    HMACMD5Update(&hmacctx, pRandom, cbRandomLen);
    HMACMD5Final(&hmacctx, pVerifier);

    fRet = TRUE;

bail_out:
    return fRet;
}


//
// Extract the session to reconnect to from the ARC info
// also do the necessary security checks
//
// Params:
//  pClientArcInfo - autoreconnect information from the client
//
// Returns:
//  If all security checks pass and pArc is valid then winstation
//  to reconnect to is returned. Else NULL
//
// NOTE: WinStation returned is left LOCKED.
//
PWINSTATION
GetWinStationFromArcInfo(
    PBYTE pClientRandom,
    LONG  cbClientRandomLen,
    PTS_AUTORECONNECTINFO pClientArcInfo
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PWINSTATION pWinStation = NULL;
    PWINSTATION pFoundWinStation = NULL;
    ARC_CS_PRIVATE_PACKET UNALIGNED* pCSArcInfo = NULL;
    BYTE arcSCclientBlob[ARC_SC_SECURITY_TOKEN_LEN];
    BYTE hmacVerifier[ARC_CS_SECURITY_TOKEN_LEN];
    PBYTE pServerArcBits = NULL;
    ULONG BytesGot = 0;
    TS_AUTORECONNECTINFO SCAutoReconnectInfo;

    TRACE((hTrace,TC_ICASRV,TT_API1,
           "TERMSRV: WinStation GetWinStationFromArcInfo pRandom:%p len:%d\n",
           pClientRandom, cbClientRandomLen));


    if (!pClientArcInfo) {
        goto error;
    }

    pCSArcInfo = (ARC_CS_PRIVATE_PACKET UNALIGNED*)pClientArcInfo->AutoReconnectInfo;

    if (!pCSArcInfo->cbLen ||
        pCSArcInfo->cbLen < sizeof(ARC_CS_PRIVATE_PACKET)) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR,
               "TERMSRV: GetWinStationFromArcInfo ARC length invalid bailing out\n"));
        goto error;
    }

    memset(arcSCclientBlob, 0, sizeof(arcSCclientBlob));
    pWinStation = FindWinStationById(pCSArcInfo->LogonId, FALSE);
    if (pWinStation) {

        TRACE((hTrace,TC_ICASRV,TT_API1,
               "TERMSRV: GetWinStationFromArcInfo found arc winstation: %d\n",
               pCSArcInfo->LogonId));
        //
        // Do security checks to ensure this is the same winstation
        // that was connected to the client
        //

        //
        // First obtain the last autoreconnect blob sent to the client
        // since we do an inline cookie update in rdpwd
        //

        if (pWinStation->AutoReconnectInfo.Valid) {
            pServerArcBits = pWinStation->AutoReconnectInfo.ArcRandomBits;

            Status = STATUS_SUCCESS;
        }
        else {
            if (pWinStation->pWsx &&
                pWinStation->pWsx->pWsxEscape) {

                if (pWinStation->Terminating ||
                    pWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE ||
                    !pWinStation->WinStationName[0]) {

                    TRACE((hTrace,TC_ICASRV,TT_ERROR,
                           "GetWinStationFromArcInfo skipping escape"
                           "to closed stack disconnected %d\n",
                           LogonId));

                    Status = STATUS_ACCESS_DENIED;
                    goto error;
                }

                Status = pWinStation->pWsx->pWsxEscape(
                                            pWinStation->pWsxContext,
                                            GET_SC_AUTORECONNECT_INFO,
                                            NULL,
                                            0,
                                            &SCAutoReconnectInfo,
                                            sizeof(SCAutoReconnectInfo),
                                            &BytesGot);

                if (NT_SUCCESS(Status)) {
                    ASSERT(SCAutoReconnectInfo.cbAutoReconnectInfo ==
                           ARC_SC_SECURITY_TOKEN_LEN);
                }

                pServerArcBits = SCAutoReconnectInfo.AutoReconnectInfo;
            }
        }
    }
    else {
        Status = STATUS_ACCESS_DENIED;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Ensure we got the correct length for the server->client
        // data
        // 
        ASSERT(pServerArcBits);

        //
        // Get random
        //
        if (ComputeHMACVerifier(pServerArcBits,
                            ARC_SC_SECURITY_TOKEN_LEN,
                            pClientRandom,
                            cbClientRandomLen,
                            (PBYTE)hmacVerifier,
                            sizeof(hmacVerifier))) {

            //
            // Check that the verifier matches that sent by the client
            //

            if (!memcmp(hmacVerifier,
                        pCSArcInfo->SecurityVerifier,
                        sizeof(pCSArcInfo->SecurityVerifier))) {

                TRACE((hTrace,TC_ICASRV,TT_API1,
                       "TERMSRV: WinStation ARC info matches - will autoreconnect\n"));

            }
            else {

                TRACE((hTrace,TC_ICASRV,TT_ERROR,
                       "TERMSRV: autoreconnect verifier does not match targid:%d!!!\n",
                       pWinStation->LogonId));

                //
                // Reset the autoreconnect info
                //
                pWinStation->AutoReconnectInfo.Valid = FALSE;
                memset(pWinStation->AutoReconnectInfo.ArcRandomBits, 0,
                       sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits));

                //
                // Log an event
                //
                PostErrorValueEvent(EVENT_AUTORECONNECT_AUTHENTICATION_FAILED, Status);

                //
                // Mark that no winstation target was found
                //
                goto error;
            }
        }
        pFoundWinStation = pWinStation;
    }

error:
    if ((NULL == pFoundWinStation) && pWinStation) {
        ReleaseWinStation(pWinStation);
        pWinStation = NULL;
    }

    return pFoundWinStation;
}

//
// Extract the session to reconnect to from the ARC info
// also do the necessary security checks
//
// Params:
//  pWinStation - winstation to reset autoreconnect info for
//
VOID
ResetAutoReconnectInfo( PWINSTATION pWinStation)
{
    pWinStation->AutoReconnectInfo.Valid = FALSE;
    memset(pWinStation->AutoReconnectInfo.ArcRandomBits, 0,
           sizeof(pWinStation->AutoReconnectInfo.ArcRandomBits));
}

/*****************************************************************************
 *
 *  Filter_CompareConnectionEntry
 *
 *   Generic table support.Compare two connection entries
 *
 *
 ****************************************************************************/

RTL_GENERIC_COMPARE_RESULTS
NTAPI
Filter_CompareFailedConnectionEntry(
    IN  struct _RTL_GENERIC_TABLE  *Table,
    IN  PVOID                       FirstInstance,
    IN  PVOID                       SecondInstance
)
{
    PTS_FAILEDCONNECTION pFirst, pSecond;
    INT rc;

    pFirst = (PTS_FAILEDCONNECTION)FirstInstance;
    pSecond = (PTS_FAILEDCONNECTION)SecondInstance;

    if ( pFirst->uAddrSize < pSecond->uAddrSize )
    {
        return GenericLessThan;
    } else if ( pFirst->uAddrSize > pSecond->uAddrSize ) 
    {
        return GenericGreaterThan;
    }

    rc = memcmp( pFirst->addr, pSecond->addr, pFirst->uAddrSize );
    return ( rc < 0 )?GenericLessThan:
           ( rc > 0 )?GenericGreaterThan:
                      GenericEqual;
}


VOID ReadDoSParametersFromRegistry( HKEY hKeyTermSrv )
{
    DWORD dwLen;
    DWORD dwType;
    ULONG TimeLimitForFailedConnectionsMins, DoSBlockTimeMins;
    ULONG  szBuffer[MAX_PATH/sizeof(ULONG)];

    // Set Default values if Reg values are not set
    MaxFailedConnect = 5;
    DoSBlockTime = 5 * 60 * 1000;
    TimeLimitForFailedConnections = 2 * 60 * 1000;
    g_BlackListPolicy = TRUE;

    //
    // Get DoS parameters from Registry 
    //
    dwLen = sizeof(MaxFailedConnect);
    if (RegQueryValueEx(hKeyTermSrv, MAX_FAILED_CONNECT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            MaxFailedConnect = *(PULONG)szBuffer;
        }
    }

    // Note - for the next 2 parameters, whatever is present in the registry is in minutes
    // So convert it into milliseconds after reading

    dwLen = sizeof(TimeLimitForFailedConnectionsMins);
    if (RegQueryValueEx(hKeyTermSrv, TIME_LIMIT_FAILED_CONNECT, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            TimeLimitForFailedConnectionsMins = *(PULONG)szBuffer;
            TimeLimitForFailedConnections =  TimeLimitForFailedConnectionsMins * 60 * 1000;
        }
    }

    dwLen = sizeof(DoSBlockTimeMins);
    if (RegQueryValueEx(hKeyTermSrv, DOS_BLOCK_TIME, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            DoSBlockTimeMins = *(PULONG)szBuffer;
            DoSBlockTime = DoSBlockTimeMins * 60 * 1000;
        }
    }

    // Table Cleanup time is twice the time within which a IP has to make "n" bad connections to get blocked
    // This should be in milliseconds
    CleanupTimeout = 2 * TimeLimitForFailedConnections; 

    dwLen = sizeof(g_BlackListPolicy);
    if (RegQueryValueEx(hKeyTermSrv, BLACK_LIST_POLICY, NULL, &dwType,
            (PCHAR)&szBuffer, &dwLen) == ERROR_SUCCESS) {
        if (*(PULONG)szBuffer > 0) {
            g_BlackListPolicy = *(PULONG)szBuffer;
        }
    }

}


/*******************************************************************************
 *  IsConfigValid
 *
 *   Check the validity of the Winstation Config struct.
 *   It's used for now for the machine-to-machine shadow as input from the
 *   shadower's machine should not be trusted and should be checked.
 *
 * ENTRY:
 *    IN  pConfig - Winstation config struct to be checked
 *
 * EXIT:
 *    STATUS_SUCCESS             - if the struct can be used
 *    Other status               - the check failed
 ******************************************************************************/
NTSTATUS IsConfigValid(PWINSTATIONCONFIG2 pConfig)
{
    ULONG i;
    NTSTATUS Status;
    PWCHAR pszModulePath = NULL;

    // Verify that each member of the config is valid

    //WINSTATIONCREATEW Create;
    // ULONG fEnableWinStation : 1;
    // ULONG MaxInstanceCount;

    //PDCONFIGW Pd[ MAX_PDCONFIG ];
    // PDCONFIG2W Create;
    //  PDNAMEW PdName;                     // descriptive name of PD
    //  SDCLASS SdClass;                    // type of PD
    //  DLLNAMEW PdDLL;                     // name of PD dll
    //  ULONG    PdFlag;                    // PD flags
    //  ULONG OutBufLength;                 // optimal output buffer length
    //  ULONG OutBufCount;                  // optimal number of output buffers
    //  ULONG OutBufDelay;                  // write delay in msecs
    //  ULONG InteractiveDelay;             // write delay during active input
    //  ULONG PortNumber;                   // network listen port number
    //  ULONG KeepAliveTimeout;             // network watchdog frequence
    // PDPARAMSW Params;
    //  SDCLASS SdClass;
    //  NETWORKCONFIGW Network;
    //   LONG LanAdapter;
    //   DEVICENAMEW NetworkName;
    //   ULONG Flags;
    //  ASYNCCONFIGW Async;
    //   DEVICENAMEW DeviceName;
    //   MODEMNAMEW ModemName;
    //   ULONG BaudRate;
    //   ULONG Parity;
    //   ULONG StopBits;
    //   ULONG ByteSize;
    //   ULONG fEnableDsrSensitivity: 1;
    //   ULONG fConnectionDriver: 1;
    //   FLOWCONTROLCONFIG FlowControl;
    //   CONNECTCONFIG Connect;
    //  NASICONFIGW Nasi;
    //   NASISPECIFICNAMEW    SpecificName;
    //   NASIUSERNAMEW        UserName;
    //   NASIPASSWORDW        PassWord;
    //   NASISESIONNAMEW      SessionName;
    //   NASIFILESERVERW      FileServer;
    //   BOOLEAN              GlobalSession;
    //  OEMTDCONFIGW OemTd;
    //   LONG Adapter;
    //   DEVICENAMEW DeviceName;
    //   ULONG Flags;

    // allocate the path string to verify dlls and drivers
    pszModulePath = MemAlloc( (MAX_PATH + 1) * sizeof(WCHAR) );
    if (pszModulePath == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    if ((lstrlen(szDriverDir) + DLLNAME_LENGTH + 4 > MAX_PATH) ||
        (lstrlen(szSystemDir) + DLLNAME_LENGTH + 4 > MAX_PATH)) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }


    for (i=0; i < MAX_PDCONFIG; i++) {

        PPDCONFIG pPdConfig;

        pPdConfig = &(pConfig->Pd[i]);

        if (pPdConfig->Create.SdClass == SdNone)
            break;

        Status = IsZeroterminateStringW(pPdConfig->Create.PdName, PDNAME_LENGTH + 1);
        if (!NT_SUCCESS(Status))
            goto done;

        Status = IsZeroterminateStringW(pPdConfig->Create.PdDLL, DLLNAME_LENGTH + 1);
        if (!NT_SUCCESS(Status))
            goto done;

        lstrcpyn(pszModulePath, szDriverDir, MAX_PATH+1);
        lstrcat(pszModulePath, pPdConfig->Create.PdDLL);
        lstrcat(pszModulePath, L".SYS");


        if (!VerifyFile(pszModulePath, &VfyLock)) {
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }

        switch(pPdConfig->Params.SdClass) {

        case SdNetwork:
            Status = IsZeroterminateStringW(pPdConfig->Params.Network.NetworkName, DEVICENAME_LENGTH + 1);
            if (!NT_SUCCESS(Status))
                goto done;
            break;

        case SdAsync:
            // needed ?
            Status = IsZeroterminateStringW(pPdConfig->Params.Async.DeviceName, DEVICENAME_LENGTH + 1);
            if (!NT_SUCCESS(Status))
                goto done;

            Status = IsZeroterminateStringW(pPdConfig->Params.Async.ModemName, MODEMNAME_LENGTH + 1);
            if (!NT_SUCCESS(Status))
                goto done;
            break;

        case SdNasi:
            // needed ?
            break;

        case SdOemTransport:
            // needed ?
            break;

        default:
            break;
        }
    }


    //WDCONFIGW Wd;
    // WDNAMEW WdName;
    // DLLNAMEW WdDLL;
    // DLLNAMEW WsxDLL;
    // ULONG WdFlag;
    // ULONG WdInputBufferLength;
    // DLLNAMEW CfgDLL;
    // WDPREFIXW WdPrefix;

    Status = IsZeroterminateStringW(pConfig->Wd.WdName, WDNAME_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;

    Status = IsZeroterminateStringW(pConfig->Wd.WdDLL, DLLNAME_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;

    // Verify the Wd
    lstrcpyn(pszModulePath, szDriverDir, MAX_PATH+1);
    lstrcat(pszModulePath, pConfig->Wd.WdDLL);
    lstrcat(pszModulePath, L".SYS");

    if (!VerifyFile(pszModulePath, &VfyLock)) {
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }


    Status = IsZeroterminateStringW(pConfig->Wd.WsxDLL, DLLNAME_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;

    // Verify the Wsx if defined
    if ( pConfig->Wd.WsxDLL[0] != L'\0' ) {

        lstrcpyn(pszModulePath, szSystemDir, MAX_PATH+1);
        lstrcat(pszModulePath, pConfig->Wd.WsxDLL);
        lstrcat(pszModulePath, L".DLL");

        if (!VerifyFile(pszModulePath, &VfyLock)) {
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }
    }


    Status = IsZeroterminateStringW(pConfig->Wd.CfgDLL, DLLNAME_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;

    Status = IsZeroterminateStringW(pConfig->Wd.WdPrefix, WDPREFIX_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;


    //CDCONFIGW Cd;
    // CDCLASS CdClass;
    // CDNAMEW CdName;
    // DLLNAMEW CdDLL;
    // ULONG CdFlag;
    //
    Status = IsZeroterminateStringW(pConfig->Cd.CdName, CDNAME_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;

    Status = IsZeroterminateStringW(pConfig->Cd.CdDLL, DLLNAME_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;


    //WINSTATIONCONFIGW   Config;
    // WCHAR Comment[ WINSTATIONCOMMENT_LENGTH + 1 ];
    // USERCONFIGW User;
    // char OEMId[4];                // WinFrame Server OEM Id
    //
    Status = IsZeroterminateStringW(pConfig->Config.Comment, WINSTATIONCOMMENT_LENGTH + 1);
    if (!NT_SUCCESS(Status))
        goto done;

done:
    if (pszModulePath)
        MemFree(pszModulePath);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\winset.c ===
/*************************************************************************
*
* winset.c
*
* Window station set APS
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop
#include "conntfy.h" // for SetLockedState

/*
 *  External Procedures
 */
NTSTATUS xxxWinStationSetInformation( ULONG, WINSTATIONINFOCLASS,
                                      PVOID, ULONG );
VOID _ReadUserProfile( PWCHAR, PWCHAR, PUSERCONFIG );
extern BOOL IsCallerSystem( VOID );
extern BOOL IsCallerAdmin( VOID );

/*
 * Internal Procedures used
 */
NTSTATUS _SetConfig( PWINSTATION, PWINSTATIONCONFIG, ULONG );
NTSTATUS _SetPdParams( PWINSTATION, PPDPARAMS, ULONG );
NTSTATUS _SetBeep( PWINSTATION, PBEEPINPUT, ULONG );
NTSTATUS WinStationShadowChangeMode( PWINSTATION, PWINSTATIONSHADOW, ULONG );

NTSTATUS FlushVirtualInput( PWINSTATION, VIRTUALCHANNELCLASS, ULONG );

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

NTSTATUS
CheckWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen,
                PVOID *ppLocalBuf,
                PULONG pLocalBufLen);

NTSTATUS
ValidateInputConfig( PWINSTATION pWinStation, PWINSTATIONCONFIG pConfig );
/*
 *  Global data
 */
typedef ULONG_PTR (*PFN)();
HMODULE ghNetApiDll = NULL;
PFN pNetGetAnyDCName = NULL;
PFN pNetApiBufferFree = NULL;

/*
 *  External data
 */



NTSTATUS 
_CheckCallerLocalAndSystem()
/*++

Checking caller is calling from local and also is running
under system context

--*/
{
    NTSTATUS Status;
    BOOL bRevert = FALSE;
    UINT        LocalFlag;

    Status = RpcImpersonateClient( NULL );
    if( Status != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",Status));
        Status = STATUS_CANNOT_IMPERSONATE;
        goto CLEANUPANDEXIT;
    }

    bRevert = TRUE;

    //
    // Inquire if local RPC call
    //
    Status = I_RpcBindingIsClientLocal(
                            0,    // Active RPC call we are servicing
                            &LocalFlag
                            );

    if( Status != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",Status));
        Status = STATUS_ACCESS_DENIED;
        goto CLEANUPANDEXIT;
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        Status = STATUS_ACCESS_DENIED;
        goto CLEANUPANDEXIT;
    }

    Status = (IsCallerSystem()) ? STATUS_SUCCESS : STATUS_ACCESS_DENIED;

CLEANUPANDEXIT:

    if( TRUE == bRevert ) {
        RpcRevertToSelf();
    }

    return Status;
}

/*******************************************************************************
 *
 *  xxxWinStationSetInformation
 *
 *    set window station information  (worker routine)
 *
 * ENTRY:
 *    pWinStation (input)
 *       pointer to citrix window station structure
 *    WinStationInformationClass (input)
 *       Specifies the type of information to set at the specified window
 *       station object.
 *    pWinStationInformation (input)
 *       A pointer to a buffer that contains information to set for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
xxxWinStationSetInformation( ULONG LogonId,
                             WINSTATIONINFOCLASS WinStationInformationClass,
                             PVOID pWinStationInformation,
                             ULONG WinStationInformationLength )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    ULONG cbReturned;
    WINSTATION_APIMSG msg;
    PWINSTATIONCONFIG pConfig;
    ULONG ConfigLength;
    PPDPARAMS pPdParams;
    ULONG PdParamsLength;
    RPC_STATUS RpcStatus;

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationSetInformation LogonId=%d, Class=%d\n",
            LogonId, (ULONG)WinStationInformationClass ));

    /*
     * Find the WinStation
     * Return error if not found or currently terminating.
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( !pWinStation )
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    if ( pWinStation->Terminating ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_CTX_CLOSE_PENDING );
    }

    /*
     * Verify that client has SET access
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_SET, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        return( Status );
    }

    switch ( WinStationInformationClass ) {

        case WinStationPdParams :

            Status = CheckWireBuffer(WinStationInformationClass,
                                     pWinStationInformation,
                                     WinStationInformationLength,
                                     &pPdParams,
                                     &PdParamsLength);

            if ( !NT_SUCCESS(Status) ) {
                break;
            }

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_SET_PARAMS,
                                            pPdParams,
                                            PdParamsLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }

            LocalFree((PVOID)pPdParams);
            break;


        case WinStationConfiguration :

            Status = CheckWireBuffer(WinStationInformationClass,
                                     pWinStationInformation,
                                     WinStationInformationLength,
                                     &pConfig,
                                     &ConfigLength);

            if ( !NT_SUCCESS(Status) ) {
                break;
            }

            Status = _SetConfig( pWinStation,
                                 pConfig,
                                 ConfigLength );

            LocalFree((PVOID)pConfig);
            break;

        case WinStationTrace :

            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
                Status = STATUS_CANNOT_IMPERSONATE;
                break;
            }

            if (!IsCallerAdmin() && !IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }
            RpcRevertToSelf();
            if (!NT_SUCCESS(Status)) {
                break;
            }


            if ( WinStationInformationLength < sizeof(ICA_TRACE) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            if ( pWinStation->hIca ) {
                Status = IcaIoControl( pWinStation->hIca,
                                       IOCTL_ICA_SET_TRACE,
                                       pWinStationInformation,
                                       WinStationInformationLength,
                                       NULL,
                                       0,
                                       NULL );
            }
            break;

        case WinStationSystemTrace :

            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
               Status = STATUS_CANNOT_IMPERSONATE;
               break;
            }

            if (!IsCallerAdmin() && !IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }
            RpcRevertToSelf();
            if (!NT_SUCCESS(Status)) {
                break;
            }

            if ( WinStationInformationLength < sizeof(ICA_TRACE) ) {
                Status = STATUS_BUFFER_TOO_SMALL;
                break;
            }

            /*
             *  Open ICA device driver
             */
            if ( hTrace == NULL ) {
                Status = IcaOpen( &hTrace );
                if ( !NT_SUCCESS(Status) )
                    hTrace = NULL;
            }

            if ( hTrace ) {
                Status = IcaIoControl( hTrace,
                                       IOCTL_ICA_SET_SYSTEM_TRACE,
                                       pWinStationInformation,
                                       WinStationInformationLength,
                                       NULL,
                                       0,
                                       NULL );
            }
            break;

        case WinStationPrinter :
            break;

    case WinStationBeep :

            if (WinStationInformationLength < sizeof(BEEPINPUT)) {
                Status =  STATUS_BUFFER_TOO_SMALL ;
                break;
            }
            Status = _SetBeep( pWinStation,
                              (PBEEPINPUT) pWinStationInformation,
                              WinStationInformationLength );
            break;

        case WinStationEncryptionOff :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_OFF,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        case WinStationEncryptionPerm :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_PERM,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        case WinStationSecureDesktopEnter :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_ENTER,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        case WinStationSecureDesktopExit :

            if ( pWinStation->hStack ) {
                //  Check for availability
                if ( pWinStation->pWsx &&
                     pWinStation->pWsx->pWsxIcaStackIoControl ) {

                    Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                            pWinStation->pWsxContext,
                                            pWinStation->hIca,
                                            pWinStation->hStack,
                                            IOCTL_ICA_STACK_ENCRYPTION_EXIT,
                                            pWinStationInformation,
                                            WinStationInformationLength,
                                            NULL,
                                            0,
                                            NULL );
                }
                else {
                    Status = STATUS_INVALID_INFO_CLASS;
                }
            }
            break;

        /*
         * Give focus to winlogon security desktop
         * -- used by progman.exe
         */
        case WinStationNtSecurity :

            /*
             * Tell the WinStation to Send Winlogon the CTR-ALT-DEL message
             */
            msg.ApiNumber = SMWinStationNtSecurity;
            Status = SendWinStationCommand( pWinStation, &msg, 0 );
            break;

        case WinStationClientData :
            //
            // Handles multiple client data items.  The data buffer
            // format is:
            //     ULONG                // Length of next data item
            //     WINSTATIONCLIENTDATA // Including variable length part
            //     ULONG                // Length of next data item
            //     WINSTATIONCLIENTDATA // Including variable length part
            //     etc
            //
            // WinStationInformationLength is the length of the entire
            // data buffer.  Keep processing client data items until
            // the buffer is exhausted.
            //
            if ( WinStationInformationLength < sizeof(ULONG) +
                                               sizeof(WINSTATIONCLIENTDATA) )
               {
               Status = STATUS_INFO_LENGTH_MISMATCH;
               break;
               }

            if ( pWinStation->hStack )
               {
               //  Check for availability
               if ( pWinStation->pWsx &&
                    pWinStation->pWsx->pWsxIcaStackIoControl )
                  {
                  ULONG CurLen;
                  ULONG LenUsed =0;
                  PBYTE CurPtr = (PBYTE)pWinStationInformation;

                  while (LenUsed + sizeof(ULONG) < WinStationInformationLength)
                     {
                     CurLen = *(ULONG UNALIGNED *)CurPtr;
                     LenUsed += sizeof(ULONG);
                     CurPtr += sizeof(ULONG);

                     if ( (LenUsed + CurLen >= LenUsed) &&
                          (LenUsed + CurLen <= WinStationInformationLength))
                        {
                        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                        pWinStation->pWsxContext,
                                        pWinStation->hIca,
                                        pWinStation->hStack,
                                        IOCTL_ICA_STACK_SET_CLIENT_DATA,
                                        CurPtr,
                                        CurLen,
                                        NULL,
                                        0,
                                        NULL );
                        LenUsed += CurLen;
                        CurPtr += CurLen;
                        }else
                        {
                        Status = STATUS_INVALID_USER_BUFFER;
                        break;
                        }
                     }
                  }
               else
                  {
                  Status = STATUS_INVALID_INFO_CLASS;
                  }
               }

            break;

       case WinStationInitialProgram :

            /*
             * Identify first program, non-consoles only
             */
            if ( LogonId != 0 ) {

                /*
                 * Tell the WinStation this is the initial program
                 */
                msg.ApiNumber = SMWinStationInitialProgram;
                Status = SendWinStationCommand( pWinStation, &msg, 0 );
            }
            break;

        case WinStationShadowInfo:
            Status = _CheckCallerLocalAndSystem();
            if( NT_SUCCESS(Status) ) {
                Status = WinStationShadowChangeMode( pWinStation,
                                                     (PWINSTATIONSHADOW) pWinStationInformation,
                                                     WinStationInformationLength );
            }
    
            break;

        case WinStationLockedState:
        {
            
            BOOL bLockedState;

            if (WinStationInformationLength == sizeof(bLockedState))
            {
                bLockedState = * (LPBOOL) pWinStationInformation;

                Status = SetLockedState (pWinStation, bLockedState);

            }
            else
            {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

        case WinStationDisallowAutoReconnect:
        {

            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
               Status = STATUS_CANNOT_IMPERSONATE;
               break;
            }

            if (!IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }
            RpcRevertToSelf();
            if (Status != STATUS_SUCCESS) {
                break;
            }
    
            if (WinStationInformationLength == sizeof(BOOLEAN)) {
                pWinStation->fDisallowAutoReconnect = * (PBOOLEAN) pWinStationInformation;
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

        case WinStationMprNotifyInfo: 
        {
            Status = _CheckCallerLocalAndSystem();
            if (Status != STATUS_SUCCESS) {
                break;
            }

            if (WinStationInformationLength == sizeof(ExtendedClientCredentials)) {

                pExtendedClientCredentials pMprInfo ;
                pMprInfo = (pExtendedClientCredentials) pWinStationInformation;

                wcsncpy(g_MprNotifyInfo.Domain, pMprInfo->Domain, EXTENDED_DOMAIN_LEN);
                g_MprNotifyInfo.Domain[EXTENDED_DOMAIN_LEN] = L'\0';

                wcsncpy(g_MprNotifyInfo.UserName, pMprInfo->UserName, EXTENDED_USERNAME_LEN);
                g_MprNotifyInfo.UserName[EXTENDED_USERNAME_LEN] = L'\0';

                wcsncpy(g_MprNotifyInfo.Password, pMprInfo->Password, EXTENDED_PASSWORD_LEN);
                g_MprNotifyInfo.Password[EXTENDED_PASSWORD_LEN] = L'\0';

            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        }

        case WinStationExecSrvSystemPipe:
            RpcStatus = RpcImpersonateClient( NULL );
            if( RpcStatus != RPC_S_OK ) {
               Status = STATUS_CANNOT_IMPERSONATE;
               break;
            }

            if (!IsCallerSystem()) {
                Status = STATUS_ACCESS_DENIED;
            }

            RpcRevertToSelf();
            if (Status != STATUS_SUCCESS) {
                break;
            }
    
            if ( WinStationInformationLength <= ( EXECSRVPIPENAMELEN * sizeof(WCHAR) ) ) {
                memcpy( pWinStation->ExecSrvSystemPipe, pWinStationInformation, WinStationInformationLength );
            }
    
            break;

       default:
            /*
             * Fail the call
             */
            Status = STATUS_INVALID_INFO_CLASS;
            break;
    }

    ReleaseWinStation( pWinStation );

    TRACE((hTrace,TC_ICASRV,TT_API2,"TERMSRV: WinStationSetInformation LogonId=%d, Class=%d, Status=0x%x\n",
            LogonId, (ULONG)WinStationInformationClass, Status));

    return( Status );
}


/*******************************************************************************
 *
 *  _SetConfig
 *
 *    Set window station configuration
 *    This API does not do a user policy or user pref merge between source and destination, 
 *    the caller of this API ( assuming the Set privilage is set) will be able to change the
 *    config data of an already active session, although only the shadow value has an impact (in practise).
 *    The rest of the values are only used upon login, nothing happens after login. The reason
 *    Shadow is different is becasue the shadow thread which uses the shadow info only start
 *    (and reads config data) when shadowing, so as logn as shadow session has not started, you
 *    can use this api to change the shadow value and have an impact on this session's behavior in 
 *    as far as shadow is concerned.
 *
 *
 * ENTRY:
 *    pWinStation (input)
 *       pointer to citrix window station structure
 *    pConfig (input)
 *       pointer to configuration structure
 *    Length (input)
 *       length of configuration structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetConfig( PWINSTATION pWinStation,
            PWINSTATIONCONFIG pConfig,
            ULONG Length )
{
    USERCONFIG          UserConfig;
    NTSTATUS Status;

    /*
     *  Validate length
     */
    if ( Length < sizeof(WINSTATIONCONFIG) )
        return( STATUS_BUFFER_TOO_SMALL );

    /*
     * Check the input configuration
     */
    Status = ValidateInputConfig(pWinStation, pConfig );
    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    /*
     *  Copy structure
     */
    pWinStation->Config.Config = *pConfig;

    /*
     *  Merge client data into winstation structure
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxInitializeUserConfig ) {
        pWinStation->pWsx->pWsxInitializeUserConfig( pWinStation->pWsxContext,
                                                pWinStation->hStack,
                                                pWinStation->hIcaThinwireChannel,
                                                &pWinStation->Config.Config.User,
                                                &pWinStation->Client.HRes,
                                                &pWinStation->Client.VRes,
                                                &pWinStation->Client.ColorDepth);
    }

#if NT2195 
    // in win2k, this could accomplish nothing since all of userconfigw data was already consumed 
    // by various TS modules at login time, changing them while a session was active had no impact. 
    // The same is true when you use TSCC to make a change, it warns you that changes will not affect
    // live sessions, etc.

    /*
     * If user is logged on -> merge user profile data
     */
    if ( pWinStation->UserName[0] ) {

        /*
         *  Read user profile data
         */
        _ReadUserProfile( pWinStation->Domain,
                          pWinStation->UserName,
                          &UserConfig );

        /*
         * Merge user config data into the winstation
         */
        MergeUserConfigData( pWinStation, &UserConfig );

    }
#endif


    /*
     *  Convert any "published app" to absolute path
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxConvertPublishedApp ) {
        (void) pWinStation->pWsx->pWsxConvertPublishedApp( pWinStation->pWsxContext,
                                                           &pWinStation->Config.Config.User);
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
ValidateInputConfig( PWINSTATION pWinStation, PWINSTATIONCONFIG pConfig )
{
    NTSTATUS Status = STATUS_SUCCESS;

    pConfig->User.UserName[ USERNAME_LENGTH ] = L'\0';
    pConfig->User.Domain[ DOMAIN_LENGTH ] = L'\0';
    pConfig->User.Password[ PASSWORD_LENGTH ] = L'\0';

    pConfig->User.WorkDirectory[ DIRECTORY_LENGTH ] = L'\0';
    pConfig->User.InitialProgram[ INITIALPROGRAM_LENGTH] = L'\0';

    pConfig->User.CallbackNumber[ CALLBACK_LENGTH ] = L'\0';

    /* fInheritSecurity */
    //BYTE MinEncryptionLevel;

    pConfig->User.NWLogonServer[ NASIFILESERVER_LENGTH] = L'\0';


    /* WinFrame Profile Path - Overrides standard profile path */
    pConfig->User.WFProfilePath[ DIRECTORY_LENGTH ] = L'\0';

    /* WinFrame Home Directory - Overrides standard Home Directory */
    pConfig->User.WFHomeDir[ DIRECTORY_LENGTH ] = L'\0';


    return Status;

}


/*******************************************************************************
 *
 *  _ReadUserProfile
 *
 *  This routine reads the user profile data from the registry
 *
 * ENTRY:
 *   pDomain (input)
 *      domain of user
 *   pUserName (input)
 *      user name to read
 *   pUserConfig (output)
 *      address to return user profile data
 *
 * EXIT:
 *   None.
 *
 ******************************************************************************/

VOID
_ReadUserProfile( PWCHAR pDomain, PWCHAR pUserName, PUSERCONFIG pUserConfig )
{
    PWCHAR pServerName;
    ULONG Length;
    LONG Error;

    /*
     * Get Domain Controller name and userconfig data.
     * If no userconfig data for user then get default values.
     */
    if ( ghNetApiDll == NULL ) {
        ghNetApiDll = LoadLibrary( L"NETAPI32" );
        if ( ghNetApiDll ) {
            pNetGetAnyDCName = GetProcAddress( ghNetApiDll, "NetGetAnyDCName" );
            pNetApiBufferFree = GetProcAddress( ghNetApiDll, "NetApiBufferFree" );
        }
    }

    /*
     * Check to make sure we got a server name
     */
    if ( pNetGetAnyDCName == NULL ||
         pNetGetAnyDCName( NULL, pDomain, (LPBYTE *)&pServerName ) != ERROR_SUCCESS )
        pServerName = NULL;

    /*
     *  Read user profile data
     */
    Error = RegUserConfigQuery( pServerName,
                                pUserName,
                                pUserConfig,
                                sizeof(USERCONFIG),
                                &Length );
    TRACE((hTrace,TC_ICASRV,TT_API1, "RegUserConfigQuery: \\\\%S\\%S, server %S, Error=%u\n",
               pDomain, pUserName, pServerName, Error ));

    if ( Error != ERROR_SUCCESS ) {
        Error = RegDefaultUserConfigQuery( pServerName, pUserConfig,
                                           sizeof(USERCONFIG), &Length );
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "RegDefaultUserConfigQuery, Error=%u\n", Error ));
    }

    /*
     *  Free memory
     */
    if ( pServerName && pNetApiBufferFree )
        pNetApiBufferFree( pServerName );
}


/*******************************************************************************
 *
 *  _SetBeep
 *
 *    Beep the WinStation
 *
 * ENTRY:
 *    pWinStation (input)
 *       pointer to citrix window station structure
 *    pBeepInput (input)
 *       pointer to Beep input structure
 *    Length (input)
 *       length of Beep input structure
 *
 * EXIT:
 *    STATUS_SUCCESS - no error
 *
 ******************************************************************************/

NTSTATUS
_SetBeep( PWINSTATION pWinStation,
          PBEEPINPUT  pBeepInput,
          ULONG Length)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BEEP_SET_PARAMETERS BeepParameters;
    IO_STATUS_BLOCK IoStatus;

    /*
     * Do the regular Beep, so you can support fancy Beeps from
     * sound cards.
     */
    if ( pWinStation->LogonId == 0 ) {
        if ( MessageBeep( pBeepInput->uType ) )
            return( STATUS_SUCCESS );
        else
            return( STATUS_UNSUCCESSFUL );
    }

    BeepParameters.Frequency = 440;
    BeepParameters.Duration = 125;

    if ( pWinStation->hIcaBeepChannel ) {
        Status = NtDeviceIoControlFile( pWinStation->hIcaBeepChannel,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &IoStatus,
                                        IOCTL_BEEP_SET,
                                        &BeepParameters,
                                        sizeof( BeepParameters ),
                                        NULL,
                                        0
                                      );
    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\wait.c ===
/*************************************************************************
*
* wait.c
*
* WinStation wait for connection routines
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include "conntfy.h"

// These are the maximum lengths of UserName, Password and Domain allowed by Winlogon
#define MAX_ALLOWED_USERNAME_LEN 255
#define MAX_ALLOWED_PASSWORD_LEN 126
#define MAX_ALLOWED_DOMAIN_LEN   255   



/*=============================================================================
==   Data
=============================================================================*/

NTSTATUS
WinStationInheritSecurityDescriptor(
    PVOID pSecurityDescriptor,
    PWINSTATION pTargetWinStation
    );
NTSTATUS
WaitForConsoleConnectWorker( PWINSTATION pWinStation );
BOOL
IsKernelDebuggerAttached();

//
//From regapi.dll
//
BOOLEAN RegIsTimeZoneRedirectionEnabled();

extern PSECURITY_DESCRIPTOR DefaultConsoleSecurityDescriptor;

extern WINSTATIONCONFIG2 gConsoleConfig;
extern HANDLE   WinStationIdleControlEvent;
extern RTL_CRITICAL_SECTION ConsoleLock;
extern RTL_RESOURCE WinStationSecurityLock;


/*****************************************************************************
 *
 *  WaitForConnectWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pWinStation (input)
 *      Pointer to our WinStation (locked)
 *
 *    Note, comes in locked and returned released.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WaitForConnectWorker( PWINSTATION pWinStation, HANDLE ClientProcessId )
{
    OBJECT_ATTRIBUTES ObjA;
    ULONG ReturnLength;
    BYTE version;
    ULONG Offset;
    ICA_STACK_LAST_ERROR tdlasterror;
    WINSTATION_APIMSG WMsg;
    BOOLEAN rc;
    NTSTATUS Status;
    BOOLEAN fOwnsConsoleTerminal = FALSE;
    ULONG BytesGot ; 

#define MODULE_SIZE 1024

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WaitForConnectWorker, LogonId=%d\n",
           pWinStation->LogonId ));


       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WaitForConnectWorker, LogonId=%d\n",pWinStation->LogonId ));

    /*
     * You only go through this API once
     */
    if ( !pWinStation->NeverConnected ) {
        ReleaseWinStation( pWinStation );
#ifdef DBG
        DbgBreakPoint();
#endif
        return( STATUS_ACCESS_DENIED );
    }

    // Should really be winlogon only here, however if ntsd is started
    // then the first time we know it's winlogon is here.

    /*
     * Ensure this is WinLogon calling
     */
    if ( ClientProcessId != pWinStation->InitialCommandProcessId ) {

        /*
         * If NTSD is started instead of winlogon, the InitialCommandProcessId is wrong.
         */
        if ( !pWinStation->InitialProcessSet ) {

            //  need to close handle if already opened
            if ( pWinStation->InitialCommandProcess ) {
                NtClose( pWinStation->InitialCommandProcess );
                pWinStation->InitialCommandProcess = NULL;
                InvalidateTerminateWaitList();
            }

            pWinStation->InitialCommandProcess = OpenProcess(
                PROCESS_ALL_ACCESS,
                FALSE,
                (DWORD)(UINT_PTR)ClientProcessId );

            if ( pWinStation->InitialCommandProcess == NULL ) {
                ReleaseWinStation( pWinStation );
                Status = STATUS_ACCESS_DENIED;
                goto done;
            }
            pWinStation->InitialCommandProcessId = ClientProcessId;
            pWinStation->InitialProcessSet = TRUE;

        }
        else {
            ReleaseWinStation( pWinStation );
            Status = STATUS_SUCCESS;
            goto done;
        }
    }
    else {
        /*
         * Only do this once
         */
        pWinStation->InitialProcessSet = TRUE;
    }

    /*
     * Console's work is done
     */


    /*
     * At this point the create is done.
     */
    if (pWinStation->CreateEvent != NULL) {
        NtSetEvent( pWinStation->CreateEvent, NULL );
    }


    /*
     * At this point The session may be terminating. If this is
     * the case, fail the call now.
     */

    if ( pWinStation->Terminating ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }


    /*
     * We are going to wait for a connect (Idle)
     */
    memset( &WMsg, 0, sizeof(WMsg) );
    pWinStation->State = State_Idle;
    NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Initialize connect event to wait on
     */
    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    Status = NtCreateEvent( &pWinStation->ConnectEvent, EVENT_ALL_ACCESS, &ObjA,
                            NotificationEvent, FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * OK, now wait for a connection
     */
    UnlockWinStation( pWinStation );
    Status = NtWaitForSingleObject( pWinStation->ConnectEvent, FALSE, NULL );
    rc = RelockWinStation( pWinStation );

    if ( !NT_SUCCESS(Status) ) {
        ReleaseWinStation( pWinStation );
        goto done;

    }

    fOwnsConsoleTerminal = pWinStation->fOwnsConsoleTerminal;

    if (pWinStation->ConnectEvent) {
        NtClose( pWinStation->ConnectEvent );
        pWinStation->ConnectEvent = NULL;
    }
    if ( !rc || pWinStation->Terminating ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }

    // if this is a connect to the console session, Do all the console specific.
    if (fOwnsConsoleTerminal) {
        Status = WaitForConsoleConnectWorker( pWinStation );
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Reset the broken connection Flag.
     *
     */

    pWinStation->StateFlags &= ~WSF_ST_BROKEN_CONNECTION;



    /*
     * Duplicate the beep channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Beep,
                             NULL,
                             &pWinStation->hIcaBeepChannel );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaBeepChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaBeepChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Duplicate the thinwire channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Virtual,
                             VIRTUAL_THINWIRE,
                             &pWinStation->hIcaThinwireChannel );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, IcaChannelOpen 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaThinwireChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaThinwireChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationWaitForConnect, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_CHANNEL_ENABLE_SHADOW,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Video channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Video,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaVideoChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Keyboard channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Keyboard,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaKeyboardChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Mouse channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Mouse,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaMouseChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Command channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Command,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaCommandChannel );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationOpenChannel, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }


    /*
     * Secure any virtual channels
     */
    VirtualChannelSecurity( pWinStation );

    // HACK? Yes int the sense that a tmp session is getting some attribs of session0 but no
    // in the sense that the purpose of the tmp session is to finally connect to session0 given our current design.
    //
    // Its possible that we are dealing with a tmp session here, due to the fact that user has
    // selected /CONSOLE and we will login into a tmp session and then reconnect to session0 after
    // we pass creds to session zero's winlogon.
    // So we have a prlblem here where login is talking place inside a temp session but the target is 
    // session0.
    // If TSCC was setup to use a specific creds for all remote session, we don't want to use that cred for the
    // tmp session since we really are tryint to get to session0, and TSCC's config for rdp sessions should not hold.
    // AraBern 09/13/2002

    if (pWinStation->bRequestedSessionIDFieldValid && ( pWinStation->RequestedSessionID  == 0 ) )
    {
        // we are dealing with a tmp session and we intend to connect to console session assuming
        // good login

        PWINSTATION pWinStation_0;

        if ( pWinStation_0 = FindWinStationById( 0, FALSE ) ) 
        {
            pWinStation->Config.Config.User.fInheritAutoLogon = 
                pWinStation_0->Config.Config.User.fInheritAutoLogon ;

            pWinStation->Config.Config.User.fPromptForPassword = 
                pWinStation_0->Config.Config.User.fPromptForPassword ;


            ReleaseWinStation( pWinStation_0 );
        }
    }


    /*
     *  Client specific connection extension completion
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxInitializeClientData ) {
         
        Status = pWinStation->pWsx->pWsxInitializeClientData( pWinStation->pWsxContext,
                                                              pWinStation->hStack,
                                                              pWinStation->hIca,
                                                              pWinStation->hIcaThinwireChannel,
                                                              pWinStation->VideoModuleName,
                                                              sizeof(pWinStation->VideoModuleName),
                                                              &pWinStation->Config.Config.User,
                                                              &pWinStation->Client.HRes,
                                                              &pWinStation->Client.VRes,
                                                              &pWinStation->Client.ColorDepth,
                                                              &WMsg.u.DoConnect );
        if ( !NT_SUCCESS( Status ) ) {
            ReleaseWinStation( pWinStation );
            goto done;
        }

        if (pWinStation->LogonId == 0 || g_bPersonalTS) {
            if (pWinStation->hWinmmConsoleAudioEvent) {
                if (pWinStation->Client.fRemoteConsoleAudio) {
                    // Set the console audio event - means console audio can be remoted
                    SetEvent(pWinStation->hWinmmConsoleAudioEvent);
                }
                else {
                    // Set the console audio event - means console audio can't be remoted
                    ResetEvent(pWinStation->hWinmmConsoleAudioEvent);
                }
            }            
        }
    }

        /* Get long UserNames and Password now */
    /* Do this only if Client autologon credentials are needed */
    /* If Server logon settings are going to Override Client logon settings, no need to do this at all */

    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxEscape && pWinStation->Config.Config.User.fInheritAutoLogon ) {

        pWinStation->pNewClientCredentials = MemAlloc( sizeof(ExtendedClientCredentials) ); 
        if (pWinStation->pNewClientCredentials == NULL) {
            ReleaseWinStation( pWinStation );
            Status = STATUS_NO_MEMORY;
            goto done; 
        }
         
        Status = pWinStation->pWsx->pWsxEscape( pWinStation->pWsxContext,
                                                GET_LONG_USERNAME,
                                                NULL,
                                                0,
                                                pWinStation->pNewClientCredentials,
                                                sizeof(ExtendedClientCredentials),
                                                &BytesGot) ; 

        if (NT_SUCCESS(Status)) {

            // WsxEscape for GET_LONG_USERNAME succeeded

            // Check if u need the ExtendedClientCredentials - the common case is short UserName and
            // short password - so optimize the common case

            if ( (wcslen(pWinStation->pNewClientCredentials->UserName) <= USERNAME_LENGTH) &&
                 (wcslen(pWinStation->pNewClientCredentials->Password) <= PASSWORD_LENGTH) &&
                 (wcslen(pWinStation->pNewClientCredentials->Domain) <= DOMAIN_LENGTH) ) {

                // We can use the old credentials itself
                MemFree(pWinStation->pNewClientCredentials);
                pWinStation->pNewClientCredentials = NULL ; 
            }
    
            // Winlogon does not allow > 126 chars for Password and > 255 chars for UserName and Domain in some code paths
            // So we have to use the old truncated credentials in case the extended credentials exceed these limits

            if (pWinStation->pNewClientCredentials != NULL) {
    
                if (wcslen(pWinStation->pNewClientCredentials->UserName) > MAX_ALLOWED_USERNAME_LEN) {
                    wcscpy(pWinStation->pNewClientCredentials->UserName, pWinStation->Config.Config.User.UserName);
                }
                if (wcslen(pWinStation->pNewClientCredentials->Password) > MAX_ALLOWED_PASSWORD_LEN) {
                    wcscpy(pWinStation->pNewClientCredentials->Password, pWinStation->Config.Config.User.Password); 
                }
                if (wcslen(pWinStation->pNewClientCredentials->Domain) > MAX_ALLOWED_DOMAIN_LEN) {
                    wcscpy(pWinStation->pNewClientCredentials->Domain, pWinStation->Config.Config.User.Domain);
                }
            }
        } else {
            // WsxEscape for GET_LONG_USERNAME failed
            MemFree(pWinStation->pNewClientCredentials);
            pWinStation->pNewClientCredentials = NULL ;
        }

    }

    /*
     * Store WinStation name in connect msg
     */
    RtlCopyMemory( WMsg.u.DoConnect.WinStationName,
                   pWinStation->WinStationName,
                   sizeof(WINSTATIONNAME) );

    /*
     * KLUDGE ALERT!!
     * The Wsx initializes AudioDriverName in the DoConnect struct.
     * However, we need to save it for later use during reconnect,
     * so we now copy it into the WinStation->Client struct.
     * (This field was NOT not initialized during the earlier
     * IOCTL_ICA_STACK_QUERY_CLIENT call.)
     */
    RtlCopyMemory( pWinStation->Client.AudioDriverName,
                   WMsg.u.DoConnect.AudioDriverName,
                   sizeof( pWinStation->Client.AudioDriverName ) );





    /*
     * Store protocol and Display driver name in WINSTATION since we may need them later for reconnect.
     */

    memset(pWinStation->ProtocolName, 0, sizeof(pWinStation->ProtocolName));
    memcpy(pWinStation->ProtocolName, WMsg.u.DoConnect.ProtocolName, sizeof(pWinStation->ProtocolName) - sizeof(WCHAR));

    memset(pWinStation->DisplayDriverName, 0, sizeof(pWinStation->DisplayDriverName));
    memcpy(pWinStation->DisplayDriverName, WMsg.u.DoConnect.DisplayDriverName, sizeof(pWinStation->DisplayDriverName) - sizeof(WCHAR));

    /*
     * Save protocol type, screen resolution, and color depth
     */
    WMsg.u.DoConnect.HRes = pWinStation->Client.HRes;
    WMsg.u.DoConnect.VRes = pWinStation->Client.VRes;
    WMsg.u.DoConnect.ProtocolType = pWinStation->Client.ProtocolType;

    /*
     * Translate the color to the format excpected in winsrv
     */

    switch(pWinStation->Client.ColorDepth){
    case 1:
       WMsg.u.DoConnect.ColorDepth=4 ; // 16 colors
      break;
    case 2:
       WMsg.u.DoConnect.ColorDepth=8 ; // 256
       break;
    case 4:
       WMsg.u.DoConnect.ColorDepth= 16;// 64K
       break;
    case 8:
       WMsg.u.DoConnect.ColorDepth= 24;// 16M
       break;
#define DC_HICOLOR
#ifdef DC_HICOLOR
    case 16:
       WMsg.u.DoConnect.ColorDepth= 15;// 32K
       break;
#endif
    default:
       WMsg.u.DoConnect.ColorDepth=8 ;
       break;
    }


    WMsg.u.DoConnect.KeyboardType        = pWinStation->Client.KeyboardType;
    WMsg.u.DoConnect.KeyboardSubType     = pWinStation->Client.KeyboardSubType;
    WMsg.u.DoConnect.KeyboardFunctionKey = pWinStation->Client.KeyboardFunctionKey;


    /*
     * Tell Win32 about the connection
     */

    WMsg.ApiNumber = SMWinStationDoConnect;

    Status = SendWinStationCommand( pWinStation, &WMsg, 600 );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: SMWinStationDoConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    } else {
        pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;

    }

    //
    //Set session time zone information.
    //
    if(pWinStation->LogonId != 0 && !pWinStation->fOwnsConsoleTerminal &&
        RegIsTimeZoneRedirectionEnabled())
    {
        WINSTATION_APIMSG TimezoneMsg;
        memset( &TimezoneMsg, 0, sizeof(TimezoneMsg) );

        TimezoneMsg.ApiNumber = SMWinStationSetTimeZone;
        memcpy(&(TimezoneMsg.u.SetTimeZone.TimeZone),&(pWinStation->Client.ClientTimeZone),
                    sizeof(TS_TIME_ZONE_INFORMATION));

       SendWinStationCommand( pWinStation, &TimezoneMsg, 600 );

    }

    /*
     * Indicate we're now connected. Only after succesful connection to Win32/CSR.
     */
    pWinStation->NeverConnected = FALSE;


    /*
     * Check if we received a broken connection indication while connecting to  to Win32/CSR.
     */

    if (pWinStation->StateFlags & WSF_ST_BROKEN_CONNECTION) {
        QueueWinStationReset(pWinStation->LogonId);
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation( pWinStation );
        goto done;
    }


    /*
     * Set connect time and start disconnect timer
     */
    NtQuerySystemTime( &pWinStation->ConnectTime );

    /*
     * Attempt to connect to the CdmRedirector
     * for Client Drive Mapping
     *
     * NOTE: We still init the WinStation even if Client Drive
     *       mapping does not connect.
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxCdmConnect ) {
        Status = pWinStation->pWsx->pWsxCdmConnect( pWinStation->pWsxContext,
                                                    pWinStation->LogonId,
                                                    pWinStation->hIca );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: CdmConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    Status = STATUS_SUCCESS;


    pWinStation->State = State_Connected;
    NotifySystemEvent( WEVENT_CONNECT | WEVENT_STATECHANGE );


    Status = NotifyConnect(pWinStation, fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(( "TERMSRV: NotifyConsoleConnect failed  Status= 0x%x\n", Status));
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );



done:

    /*
     * Failure here will cause Winlogon to terminate the session. If we are failing
     * the console session, let wake up the IdleControlThread, he may have to create
     * a new console session.
     */
    if (!NT_SUCCESS( Status ) && fOwnsConsoleTerminal) {
        NtSetEvent(WinStationIdleControlEvent, NULL);
    }


    return( Status );
}

// Since the physical console does not have a real client, init data to some defaults
void    InitializeConsoleClientData( PWINSTATIONCLIENTW  pWC )
{
    pWC->fTextOnly          = FALSE;
    pWC->fDisableCtrlAltDel = FALSE; 
    pWC->fMouse             = TRUE; 
    pWC->fDoubleClickDetect = FALSE; 
    pWC->fINetClient        = FALSE; 
    pWC->fPromptForPassword = FALSE;  
    pWC->fMaximizeShell     = TRUE; 
    pWC->fEnableWindowsKey  = TRUE; 
    pWC->fRemoteConsoleAudio= FALSE; 
    
    wcscpy( pWC->ClientName      , L"");
    wcscpy( pWC->Domain          , L"");                                     
    wcscpy( pWC->UserName        , L"");                                 
    wcscpy( pWC->Password        , L"");
    wcscpy( pWC->WorkDirectory   , L"");
    wcscpy( pWC->InitialProgram  , L"");                    
    
    pWC->SerialNumber            = 0;        // client computer unique serial number    
    pWC->EncryptionLevel         = 3;        // security level of encryption pd         
    pWC->ClientAddressFamily     = 0;                                             
    
    wcscpy( pWC->ClientAddress      , L"");
    
    pWC->HRes                    = 640;                                    
    pWC->VRes                    = 480;                                                           
    pWC->ColorDepth              = 0x2;                                                     
    pWC->ProtocolType            = PROTOCOL_CONSOLE ;
    pWC->KeyboardLayout          = 0;                                                  
    pWC->KeyboardType            = 0;                                                    
    pWC->KeyboardSubType         = 0;                                                 
    pWC->KeyboardFunctionKey     = 0;                                             
    
    wcscpy( pWC->imeFileName    , L"");
    wcscpy( pWC->ClientDirectory, L"");
    wcscpy( pWC->ClientLicense  , L"");
    wcscpy( pWC->ClientModem    , L"");
    
    pWC->ClientBuildNumber       = 0;                                               
    pWC->ClientHardwareId        = 0;    // client software serial number            
    pWC->ClientProductId         = 0;    // client software product id              
    pWC->OutBufCountHost         = 0;    // number of outbufs on host               
    pWC->OutBufCountClient       = 0;    // number of outbufs on client             
    pWC->OutBufLength            = 0;    // length of outbufs in bytes              
    
    wcscpy( pWC->AudioDriverName, L"" );

    pWC->ClientSessionId = LOGONID_NONE;
    
    {
        //This time zone information is invalid
        //using it we set BaseSrvpStaticServerData->TermsrvClientTimeZoneId to
        //TIME_ZONE_ID_INVALID!
        TS_TIME_ZONE_INFORMATION InvalidTZ={0,L"",
                {0,10,0,6/*this number makes it invalid; day numbers >5 not allowed*/,0,0,0,0},0,L"",
                {0,4,0,6/*this number makes it invalid*/,0,0,0,0},0};

        memcpy(&(pWC->ClientTimeZone), &InvalidTZ, 
            sizeof(TS_TIME_ZONE_INFORMATION));
    }

    pWC->clientDigProductId[0] = 0;
}

BOOLEAN gConsoleNeverConnected = TRUE;

NTSTATUS
WaitForConsoleConnectWorker( PWINSTATION pWinStation )
{
    OBJECT_ATTRIBUTES ObjA;
    ULONG ReturnLength;
    BYTE version;
    ULONG Offset;
    ICA_STACK_LAST_ERROR tdlasterror;
    WINSTATION_APIMSG WMsg;
    BOOLEAN rc;
    NTSTATUS Status;

#define MODULE_SIZE 1024

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WaitForConnectWorker, LogonId=%d\n",
           pWinStation->LogonId ));


       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d\n", pWinStation->LogonId ));

    if (pWinStation->LogonId == 0) {
        /*
         * We need to acquire console lock. UnLock winstation first to avoid deadlock.
         */

        UnlockWinStation( pWinStation );
        ENTERCRIT( &ConsoleLock );
        if (!RelockWinStation( pWinStation )) {
            LEAVECRIT( &ConsoleLock );
            return STATUS_CTX_WINSTATION_NOT_FOUND;
        }

        /*
         * You only go through this API once for console session.
         */
        if (!gConsoleNeverConnected) {
            LEAVECRIT( &ConsoleLock );
            return STATUS_SUCCESS;
        }
    }


    if (!pWinStation->pSecurityDescriptor && pWinStation->LogonId) {
        RtlAcquireResourceShared(&WinStationSecurityLock, TRUE);
        Status = RtlCopySecurityDescriptor(DefaultConsoleSecurityDescriptor,
                                              &(pWinStation->pSecurityDescriptor));
        RtlReleaseResource(&WinStationSecurityLock);
    }



    // Read console config, 
    // For the session 0, this was already initalized in WinStationCreateWorker()

    if (pWinStation->LogonId != 0) {

         pWinStation->Config = gConsoleConfig;

         // initalize client data, since there isn't any real rdp client sending anythhing to us
         InitializeConsoleClientData( & pWinStation->Client );
    }


    /*
     * We are going to wait for a connect (Idle)
     */
    memset( &WMsg, 0, sizeof(WMsg) );
    pWinStation->State = State_ConnectQuery;
    NotifySystemEvent( WEVENT_STATECHANGE );

    /*
     * Initialize connect event to wait on
     */
    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    if (pWinStation->ConnectEvent == NULL) {
        Status = NtCreateEvent( &pWinStation->ConnectEvent, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtCreateEvent 0x%x\n",
                      pWinStation->LogonId, Status  ));
            goto done;
        }

    }


    /*
     * Duplicate the beep channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    if (pWinStation->hIcaBeepChannel == NULL) {
        Status = IcaChannelOpen( pWinStation->hIca,
                                 Channel_Beep,
                                 NULL,
                                 &pWinStation->hIcaBeepChannel );

        if ( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, IcaChannelOpen 0x%x\n",
                      pWinStation->LogonId, Status  ));
            goto done;
        }
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaBeepChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaBeepChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Duplicate the thinwire channel.
     * This is one channel that both CSR and ICASRV have open.
     */
    if (pWinStation->hIcaThinwireChannel == NULL) {
        Status = IcaChannelOpen( pWinStation->hIca,
                                 Channel_Virtual,
                                 VIRTUAL_THINWIRE,
                                 &pWinStation->hIcaThinwireChannel );

        if ( !NT_SUCCESS( Status ) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, IcaChannelOpen 0x%x\n",
                      pWinStation->LogonId, Status  ));
            goto done;
        }
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                pWinStation->hIcaThinwireChannel,
                                pWinStation->WindowsSubSysProcess,
                                &WMsg.u.DoConnect.hIcaThinwireChannel,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    Status = IcaChannelIoControl( pWinStation->hIcaThinwireChannel,
                                  IOCTL_ICA_CHANNEL_ENABLE_SHADOW,
                                  NULL, 0, NULL, 0, NULL );
    ASSERT( NT_SUCCESS( Status ) );

    /*
     * Video channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Video,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaVideoChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Keyboard channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Keyboard,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaKeyboardChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Mouse channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Mouse,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaMouseChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }

    /*
     * Command channel
     */
    Status = WinStationOpenChannel( pWinStation->hIca,
                                    pWinStation->WindowsSubSysProcess,
                                    Channel_Command,
                                    NULL,
                                    &WMsg.u.DoConnect.hIcaCommandChannel );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker, LogonId=%d, NtDuplicateObject 0x%x\n",
                  pWinStation->LogonId, Status  ));
        goto done;
    }


    if (!pWinStation->LogonId) {
        goto SkipClientData;
    }
    /*
     * Secure any virtual channels
     */
    VirtualChannelSecurity( pWinStation );

   /*
     * Tell Win32 about the connection
     */

    WMsg.u.DoConnect.fEnableWindowsKey = (BOOLEAN) pWinStation->Client.fEnableWindowsKey;
SkipClientData:
    WMsg.ApiNumber = SMWinStationDoConnect;

    Status = SendWinStationCommand( pWinStation, &WMsg, 600 );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: SMWinStationDoConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WaitForConsoleConnectWorker SMWinStationDoConnect failed  Status= 0x%x\n", Status));
        goto done;
    } else {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WaitForConsoleConnectWorker SMWinStationDoConnect OK\n"));
        pWinStation->StateFlags |= WSF_ST_CONNECTED_TO_CSRSS;
        if (pWinStation->LogonId == 0) {
            gConsoleNeverConnected=FALSE;
        }

    }


    /*
     * Indicate we're now connected. Only after succesful connection to Win32/CSR.
     */
    pWinStation->NeverConnected = FALSE;


    /*
     * Check if we received a broken connection indication while connecting to  to Win32/CSR.
     */

    if (pWinStation->StateFlags & WSF_ST_BROKEN_CONNECTION) {
        QueueWinStationReset(pWinStation->LogonId);
        Status = STATUS_CTX_CLOSE_PENDING;
        goto done;
    }


    /*
     * Set connect time and start disconnect timer
     */
    NtQuerySystemTime( &pWinStation->ConnectTime );

    /*
     * Attempt to connect to the CdmRedirector
     * for Client Drive Mapping
     *
     * NOTE: We still init the WinStation even if Client Drive
     *       mapping does not connect.
     */
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxCdmConnect ) {
        Status = pWinStation->pWsx->pWsxCdmConnect( pWinStation->pWsxContext,
                                                    pWinStation->LogonId,
                                                    pWinStation->hIca );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: CdmConnect %d Status=0x%x\n",
           pWinStation->LogonId, Status));

    Status = STATUS_SUCCESS;

    /*
     *  Start logon timers
     */
    StartLogonTimers( pWinStation );

    pWinStation->State = State_Connected;
    NotifySystemEvent( WEVENT_CONNECT | WEVENT_STATECHANGE );

    Status = NotifyConnect(pWinStation, pWinStation->fOwnsConsoleTerminal);
    if ( !NT_SUCCESS(Status) ) {
        DBGPRINT(( "TERMSRV: NotifyConsoleConnect failed  Status= 0x%x\n", Status));
    }


done:
    //
    //  Set the licensing policy for the console session. This must be done
    //  to prevent a weird state when a console session goes remote. This must
    //  Done weither wi faill or succeed. Licensing code assumes the policy is
    //  set.
    //
    if (pWinStation->LogonId == 0) {
        LEAVECRIT( &ConsoleLock );
    }
    LCAssignPolicy(pWinStation);

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\wstlpc.c ===
/*************************************************************************
*
* wstlpc.c
*
* WinStation LPC Initialization and dispatch functions for NT ICA Server
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "precomp.h"
#pragma hdrstop

#include <rpc.h>
#include "icaevent.h"

/*
 * August 19, 1996 JohnR:
 *
 *  The ICASRV and WinStation API's have been now reorganized.
 *
 *  The main visible API's that client applications such as winadmin,
 *  winquery, and system components such as the spooler see are now
 *  based on RPC.
 *
 *  Internally where ICASRV communicates with WinStations, the reverse
 *  LPC is used. This is because the client of these API's is
 *  the WIN32K.SYS kernel mode module. Non-system mode callers of
 *  the LPC API's are no longer allowed, and must use RPC.
 */


typedef NTSTATUS (*PWINSTATION_API) (
    IN PLPC_CLIENT_CONTEXT pContext,
    IN OUT PWINSTATION_APIMSG ApiMsg
    );


/*
 * entry for the list that keeps track of currently active LPC contexts
 */
typedef struct _TERMSRVLPCCONTEXT {
    LIST_ENTRY Links;
    PVOID      pContext;
} TERMSRVLPCCONTEXT, *PTERMSRVLPCCONTEXT; 

LIST_ENTRY gTermsrvLpcListHead;


/*
 * External Functions
 */
NTSTATUS SendWinStationCommand( PWINSTATION, PWINSTATION_APIMSG, ULONG );
BOOL
IsKernelDebuggerAttached();

/*
 * Internal Functions
 */
VOID RemoveLpcContext(PVOID pContext);
BOOL GetSessionIdFromLpcContext(PLPC_CLIENT_CONTEXT pContext, PULONG pSessionId);
NTSTATUS WinStationLpcThread( IN PVOID ThreadParameter );
NTSTATUS WinStationLpcHandleConnectionRequest( PPORT_MESSAGE );
VOID     WinStationLpcClientHasTerminated( PLPC_CLIENT_CONTEXT );

NTSTATUS WinStationInternalCreate( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationInternalReset( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationInternalDisconnect( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationWCharLog( PLPC_CLIENT_CONTEXT pContext, PWINSTATION_APIMSG pMsg );
NTSTATUS WinStationGetSMCommand( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationBrokenConnection( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationIcaReplyMessage( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationIcaShadowHotkey( PLPC_CLIENT_CONTEXT, PWINSTATION_APIMSG );
NTSTATUS WinStationWindowInvalid( PLPC_CLIENT_CONTEXT pContext,PWINSTATION_APIMSG pMsg );

/*
 * External functions we call out to do the actual WinStation control
 */
NTSTATUS WinStationDisconnectWorker( ULONG, BOOLEAN, BOOLEAN );
NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN );
NTSTATUS WinStationExceptionFilter( PWSTR, PEXCEPTION_POINTERS );
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
PSECURITY_DESCRIPTOR BuildSystemOnlySecurityDescriptor();

/*
 * Local variables
 */
ULONG MinApiThreads;
ULONG MaxApiThreads;
ULONG NumApiThreads;
ULONG WaitingApiThreads;
RTL_CRITICAL_SECTION ApiThreadLock;
HANDLE SsWinStationLpcPort;
BOOLEAN ShutdownInProgress;
ULONG MessageId = 1;

/*
 * ICASRV WinStation LPC Dispatch Table
 *
 * If this table is changed, the table below must be modified too.
 */
PWINSTATION_API WinStationLpcDispatch[SMWinStationMaxApiNumber] = {

    WinStationInternalCreate,           // for ICASRV internal use only
    WinStationInternalReset,            // for ICASRV internal use only
    WinStationInternalDisconnect,       // for ICASRV internal use only
    WinStationWCharLog,                 // for ICASRV internal use only
    WinStationGetSMCommand,
    WinStationBrokenConnection,
    WinStationIcaReplyMessage,
    WinStationIcaShadowHotkey,
    NULL, // WinStationDoConnect,      // needed for connect and reconnect (I.E. InitMouse)
    NULL, // WinStationDoDisconnect,   // needed for disconnect (I.E. disable screen)
    NULL, // WinStationDoReconnect     // Reconnect
    NULL, // WinStationExitWindows,    // Logoff
    NULL, // WinStationTerminate,      // Terminate process (less gentle than logoff?)
    NULL, // WinStationNtSecurity,     // CTL-ALT-DEL screen
    NULL, // WinStationDoMessage,      // Message box
    NULL, // WinStationDoBreakPoint    // WinStation breakpoint
    NULL, // WinStationThinwireStats   // Get thinwire stats
    NULL, // WinStationShadowSetup,
    NULL, // WinStationShadowStart,
    NULL, // WinStationShadowStop,
    NULL, // WinStationShadowCleanup,
    NULL, // WinStationPassthruEnable,
    NULL, // WinStationPassthruDisable,
    NULL, // WinStationSetTimeZone,    // Set Time Zone
    NULL, // WinStationInitialProgram,
    NULL, // WinStationNtsdDebug,
    NULL, // WinStationBroadcastSystemMessage    // For PNP: This is the counter part to BroadcastSystemMessage on console
    NULL, // WinStationSendWindowMessage                   // General Window's SendMessage() API
    NULL, // SMWinStationNotify
    NULL, // SMWinStationDoLoadStringNMessage
    WinStationWindowInvalid
};

#if DBG
PSZ WinStationLpcName[SMWinStationMaxApiNumber] = {
    "WinStationInternalCreate",
    "WinStationInternalReset",
    "WinStationInternalDisconnect",
    "WinStationWCharLog",
    "WinStationGetSMCommand",
    "WinStationBrokenConnection",
    "WinStationIcaReplyMessage",
    "WinStationShadowHotkey",
    "WinStationDoConnect",
    "WinStationDoDisconnect",
    "WinStationDoReconnect",
    "WinStationExitWindows",
    "WinStationTerminate",
    "WinStationNtSecurity",
    "WinStationDoMessage",
    "WinStationDoBreakPoint",
    "WinStationThinwireStats",
    "WinStationShadowSetup",
    "WinStationShadowStart",
    "WinStationShadowStop",
    "WinStationShadowCleanup",
    "WinStationPassthruEnable",
    "WinStationPassthruDisable",
    "WinStationSetTimeZone",
    "WinStationInitialProgram",
    "WinStationNtsdDebug",
    "WinStationBroadcastSystemMessage",
    "WinStationSendWindowMessage",
    "SMWinStationNotify",
    "SMWinStationDoLoadStringNMessage",
    "WinStationWindowInvalid"
};

PSZ WinStationStateName[] = {
    "Active",
    "Connected",
    "ConnectQuery",
    "VirtualIO",
    "Disconnected",
    "Idle",
    "Off",
    "Reset",
    "Down",
    "Init",
};
#endif // DBG


/*****************************************************************************
 *
 *  WinStationInitLPC
 *
 *   Create the Session manager WinStation API LPC port and Thread
 *
 * ENTRY:
 *   No Parameters
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInitLPC()
{
    ULONG i;
    NTSTATUS st;
    ANSI_STRING Name;
    UNICODE_STRING UnicodeName;
    OBJECT_ATTRIBUTES ObjA;
    ULONG Length;
    SYSTEM_BASIC_INFORMATION SysInfo;
    PSECURITY_DESCRIPTOR SecurityDescriptor;

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WinSta: Init WinStation LPC Channels\n"));

    /*
     * Initialize PC context LIst
     */
    InitializeListHead(&gTermsrvLpcListHead);

    /*
     * create a security descriptor that allows only SYSTEM access
     */
    SecurityDescriptor = BuildSystemOnlySecurityDescriptor();

    if (!SecurityDescriptor)
    {
        return STATUS_NO_MEMORY;
    }

    /*
     * Create the port for the WIN32 CSRSS's to connect to.
     */
    RtlInitAnsiString( &Name, "\\SmSsWinStationApiPort" );
    st = RtlAnsiStringToUnicodeString( &UnicodeName, &Name, TRUE);
    if (!NT_SUCCESS(st))
    {
        MemFree( SecurityDescriptor );
        return st;

    }

    InitializeObjectAttributes( &ObjA, &UnicodeName, 0, NULL,
            SecurityDescriptor );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: Creating SsApiPort\n"));

    ASSERT( sizeof(WINSTATION_APIMSG) <= PORT_MAXIMUM_MESSAGE_LENGTH );

    st = NtCreatePort( &SsWinStationLpcPort,
                       &ObjA,
                       sizeof(WINSTATIONAPI_CONNECT_INFO),
                       sizeof(WINSTATION_APIMSG),
                       sizeof(WINSTATION_APIMSG) * 32 );

    RtlFreeUnicodeString(&UnicodeName);

    /*
     * Clean up security stuff
     */
    MemFree( SecurityDescriptor );

    if (!NT_SUCCESS(st))
    {
        return st;
    }



    /*
     * Determine min/max number of API threads we will support
     */
    if (g_bPersonalTS) {
        MinApiThreads = 1;
        MaxApiThreads = 100;
    }
    else {
        MinApiThreads = 3;
        st = NtQuerySystemInformation( SystemBasicInformation,
                                       &SysInfo, sizeof(SysInfo), &Length );
        if ( NT_SUCCESS( st ) )
            MaxApiThreads = 100; //  (3 + SysInfo.NumberOfProcessors * 2);
        else {
            DBGPRINT(( "TERMSRV: NtQuerySystemInfo failed, rc=0x%x\n", st ));
            MaxApiThreads = 100;
        }
    }
    NumApiThreads = 0;
    WaitingApiThreads = 0;
    st = RtlInitializeCriticalSection( &ApiThreadLock );
    if(!(NT_SUCCESS(st))) {
        return(st);
    }

    /*
     * Create Initial Set of Server Threads
     */
    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: Creating WinStation LPC Server Threads\n"));

    for ( i = 0; i < MinApiThreads; i++ ) {
        DWORD ThreadId;
        HANDLE Handle;

        Handle = CreateThread( NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)WinStationLpcThread,
                               NULL,
                               THREAD_SET_INFORMATION,
                               &ThreadId );
        if ( !Handle ) {
            return( STATUS_TOO_MANY_THREADS );
        } else {
            NtClose( Handle );
        }
    }

    RtlEnterCriticalSection( &ApiThreadLock );
    NumApiThreads += MinApiThreads;
    RtlLeaveCriticalSection( &ApiThreadLock );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: Done Creating Service API Service Threads\n" ));

    return STATUS_SUCCESS;
}


/*****************************************************************************
 *
 *  WinStationLpcThread
 *
 *   Main service thread for internal Winstation LPC connections.
 *
 * ENTRY:
 *    ThreadParameter (input)
 *      Not used standard NT ThreadCreate() parameter
 *
 * EXIT:
 *   Should never exit
 *
 ****************************************************************************/


NTSTATUS
WinStationLpcThread( IN PVOID ThreadParameter )
{
    WINSTATION_APIMSG ApiMsg;
    PWINSTATION_APIMSG ReplyMsg;
    PLPC_CLIENT_CONTEXT pContext;
    NTSTATUS Status;
    HANDLE Handle;

    ReplyMsg = NULL;

    /*
     * Loop forever processing API requests
     */
    for ( ; ; ) {

        /*
         * If there are more than the minimum number of API threads active,
         * and at least 1 waiting thread, then this thread will terminate.
         * But first, any pending reply message must be sent.
         */
        RtlEnterCriticalSection( &ApiThreadLock );
#ifdef notdef
        if ( NumApiThreads > MinApiThreads && WaitingApiThreads ) {
            NumApiThreads--;
            RtlLeaveCriticalSection( &ApiThreadLock );
            if ( ReplyMsg ) {
                (VOID) NtReplyPort( SsWinStationLpcPort,
                                    (PPORT_MESSAGE) ReplyMsg );
            }
            break;
        }
#endif

        /*
         * Increment the number of waiting threads and wait for an LPC request
         */
        WaitingApiThreads++;
        RtlLeaveCriticalSection( &ApiThreadLock );
        Status = NtReplyWaitReceivePort( SsWinStationLpcPort,
                                         (PVOID *) &pContext,
                                         (PPORT_MESSAGE) ReplyMsg,
                                         (PPORT_MESSAGE) &ApiMsg );
        RtlEnterCriticalSection( &ApiThreadLock );

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got a message\n" ));
        /*
         * If there are no more waiting threads,
         * then create a new API thread to process requests.
         */
        if ( --WaitingApiThreads == 0 && NumApiThreads < MaxApiThreads ) {
            DWORD ThreadId;

            NumApiThreads++;
            RtlLeaveCriticalSection( &ApiThreadLock );
            Handle = CreateThread( NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)WinStationLpcThread,
                                   NULL,
                                   THREAD_SET_INFORMATION,
                                   &ThreadId );

            if ( !Handle ) {
                RtlEnterCriticalSection( &ApiThreadLock );
                NumApiThreads--;
                RtlLeaveCriticalSection( &ApiThreadLock );
            } else {
               NtClose( Handle );
            }

        } else {
            RtlLeaveCriticalSection( &ApiThreadLock );
        }


        if ( !NT_SUCCESS(Status) ) {
            ReplyMsg = NULL;
            continue;
        }

        try {

            /*
             * Process connection request from a new client
             */
            if ( ApiMsg.h.u2.s2.Type == LPC_CONNECTION_REQUEST ) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got connection message\n" ));
                // CONNECT_INFO is in ApiMsg from NtReplyWaitReceivePort() when
                // a connection request is received. This differs from
                // NtListenPort() which passes separate pointers for CONNECT_INFO.

                WinStationLpcHandleConnectionRequest( (PPORT_MESSAGE)&ApiMsg );
                ReplyMsg = NULL;
                continue;
            }

            /*
             * Process port closed message
             */
            if ( ApiMsg.h.u2.s2.Type == LPC_PORT_CLOSED ) {
                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got PORT_CLOSED message pContext %p\n",
                          pContext));
                // NOTE: This function frees the CONTEXT struct
                WinStationLpcClientHasTerminated( pContext );
                ReplyMsg = NULL;
                continue;
            }

            ASSERT(sizeof(WinStationLpcDispatch)/sizeof(WinStationLpcDispatch[0]) == SMWinStationMaxApiNumber);
            ASSERT(sizeof(WinStationLpcName)/sizeof(WinStationLpcName[0]) == SMWinStationMaxApiNumber);

            /*
             * Process API request from client
             */
            ReplyMsg = &ApiMsg;
            if ((ULONG) ApiMsg.ApiNumber >= (ULONG)SMWinStationMaxApiNumber ) {
                DBGPRINT(( "TERMSRV: WinStation LPC Service Thread Bad API number %d\n",
                          ApiMsg.ApiNumber ));
                ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;

            } else {
                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStation LPC Service Thread got %s message\n",
                          WinStationLpcName[ApiMsg.ApiNumber] ));
                if ( WinStationLpcDispatch[ApiMsg.ApiNumber] ) {

                    // Save Msg for use by CheckClientAccess
                    NtCurrentTeb()->Win32ThreadInfo = &ApiMsg;

                    // The functions set ApiMsg.ReturnedStatus
                    Status = (WinStationLpcDispatch[ApiMsg.ApiNumber])( pContext, &ApiMsg );

                    // Clear thread Msg pointer
                    NtCurrentTeb()->Win32ThreadInfo = NULL;

                } else {
                    // This API is not implemented in Session Manager
                    ApiMsg.ReturnedStatus = STATUS_NOT_IMPLEMENTED;
                }

                /*
                 * If client does not expect a reply or reply is pending
                 * (will be sent asynchronously), then clear ReplyMsg pointer.
                 */
                if ( !ApiMsg.WaitForReply || Status == STATUS_PENDING )
                    ReplyMsg = NULL;
            }
        } except( WinStationExceptionFilter( L"WinStationLpcThread trapped!!",
                                             GetExceptionInformation() ) ) {
            ReplyMsg = NULL;
        }
    }

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationLpcHandleConnectionRequest
 *
 *   Handle connection requests and create our local data structures
 *
 * ENTRY:
 *    ConnectionRequest (input)
 *      NT LPC PORT_MESSAGE describing the request
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationLpcHandleConnectionRequest(
    IN PPORT_MESSAGE ConnectionRequest
    )
{
    NTSTATUS st;
    HANDLE CommunicationPort = NULL;
    BOOLEAN Accept;
    PWINSTATIONAPI_CONNECT_INFO info;
    REMOTE_PORT_VIEW ClientView;
    REMOTE_PORT_VIEW *pClientView = NULL;
    PORT_VIEW ServerView;
    PORT_VIEW * pServerView = NULL;
    LARGE_INTEGER SectionSize;
    HANDLE PortSection = NULL ;
    PWINSTATION pWinStation;
    PLPC_CLIENT_CONTEXT pContext = NULL;
    ULONG ClientLogonId;
    PTERMSRVLPCCONTEXT pLpcContextEntry = NULL;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLpcHandleConnectionRequest called\n" ));

    Accept = TRUE; // Assume we will accept

    // An undocumented NT LPC feature is that the CONNECT_INFO structure
    // follows the PORT_MESSAGE header when the connection request is
    // received through NtReplyWaitReceivePort(), which is useful since we
    // only have to maintain (1) thread for WinStation LPC API's, and
    // do not have to dedicated one to NtListenPort() just for connection
    // requests.

    if ( ConnectionRequest->u1.s1.DataLength != sizeof(WINSTATIONAPI_CONNECT_INFO) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WSTAPI: Bad CONNECTINFO length %d\n",
                   ConnectionRequest->u1.s1.DataLength ));
        Accept = FALSE;
    } else {

        info = (PWINSTATIONAPI_CONNECT_INFO)
                 ((ULONG_PTR)ConnectionRequest + sizeof(PORT_MESSAGE));

        //
        // We can set Accept to FALSE at anytime here for certain types
        // of requests and/or caller identities.
        //
        if ( ConnectionRequest->ClientViewSize == 0 ) {
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WSTAPI: Creating View memory\n" ));

            pServerView = &ServerView;

            // Setup Port memory for larger data transfers

            SectionSize.LowPart = WINSTATIONAPI_PORT_MEMORY_SIZE;
            SectionSize.HighPart = 0;

            st = NtCreateSection(&PortSection, SECTION_ALL_ACCESS, NULL,
                                 &SectionSize, PAGE_READWRITE, SEC_COMMIT, NULL);

            if (!NT_SUCCESS(st)) {
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error Creating Section 0x%x\n", st));
                Accept = FALSE;
                info->AcceptStatus = st;
            } else {
                ServerView.Length = sizeof(ServerView);
                ServerView.SectionHandle = PortSection;
                ServerView.SectionOffset = 0;
                ServerView.ViewSize = SectionSize.LowPart;
                ServerView.ViewBase = 0;
                ServerView.ViewRemoteBase = 0;
            }

        }


        if ( Accept ) {
            // Init the REMOTE_VIEW structure
            ClientView.Length = sizeof(ClientView);
            ClientView.ViewSize = 0;
            ClientView.ViewBase = 0;
            pClientView = &ClientView;

            info->AcceptStatus = STATUS_SUCCESS;

            if ( info->Version != CITRIX_WINSTATIONAPI_VERSION ) {
                info->AcceptStatus = 1; // Fill in bad version param code
                TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: WSTAPI: Bad Version %d\n", info->Version));
                Accept = FALSE;
            }

            // Add checks for info.RequestedAccess against the requesting
            // threads security rights for WinStation access. Use the Se* stuff
            // to do the checking and audit generation

            // On Security Access failure:
            // Accept = FALSE;
            // info->AcceptStatus = NT invalid rights message
        }

    }

    //
    // Get the ClientLogonId
    //
    if ( Accept ) {
        HANDLE ClientProcessHandle = NULL;
        OBJECT_ATTRIBUTES ObjA;

        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        st = NtOpenProcess( &ClientProcessHandle, GENERIC_READ,
                            &ObjA, &ConnectionRequest->ClientId );

        if (NT_SUCCESS(st)) {
            GetProcessLogonId( ClientProcessHandle, &ClientLogonId );
            NtClose( ClientProcessHandle );
        } else {
            Accept = FALSE;
            info->AcceptStatus = st;
        }
    }

    //
    // Allocate a context connection control block.
    // The address of this block is used as the
    // port context in all calls from a client process
    //

    if ( Accept ) {
        pContext = MemAlloc( sizeof(LPC_CLIENT_CONTEXT) );
        if ( pContext ) {
            pContext->CommunicationPort = NULL;
            pContext->AccessRights = info->RequestedAccess;
        } else {
            Accept = FALSE;
            info->AcceptStatus = STATUS_NO_MEMORY;
        }
    }

    // More undocumented NT. Many parameters are missing here and in ntlpcapi.h
    // from the documentation. The CONNECTION_INFO message is part
    // of the message body following PORT_MESSAGE, just like
    // NtReplyWaitReceivePort().

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WSTAPI: Calling AcceptConnectPort, Accept %d\n", Accept));
    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: pContext %p, ConnectionRequest %p, info %p\n",
              pContext, ConnectionRequest, info));

    if (!Accept) {
        pClientView = NULL;
        pServerView = NULL;
    }

    st = NtAcceptConnectPort(
            &CommunicationPort,
            (PVOID)pContext,
            ConnectionRequest,
            Accept,
            pServerView,
            pClientView
            );

    if (!NT_SUCCESS(st)) {
       if (PortSection != NULL) {
          NtClose(PortSection);
       }
       if (pContext != NULL) {
          MemFree( pContext );
       }
       return st;
    }

    // Close the PortSection (LPC will hold the reference now)
    if ( pServerView )
        NtClose(PortSection);

    // Insert the context before completing the connect because as soon
    // as the complete is done, the client thread can send a request and 
    // if this request is serviced by another LPC thread then the context
    // won't be found (WinStationBrokenConnection case, by instance).

    RtlEnterCriticalSection( &ApiThreadLock );

    pLpcContextEntry = MemAlloc(sizeof(TERMSRVLPCCONTEXT)); 
    if (pLpcContextEntry != NULL) {
        pLpcContextEntry->pContext = pContext;
        InsertTailList( &gTermsrvLpcListHead, &pLpcContextEntry->Links );
    }

	// Don't leave the critical section before you complete connection. Because if context switch occurs, there 
	// are chances that communication port might get distroyed and we might end up working on invalid handle. 

    if ( Accept ) {

       pContext->ClientViewBase = ClientView.ViewBase;
       pContext->ClientViewBounds = (PVOID)((ULONG_PTR)ClientView.ViewBase + ClientView.ViewSize);
       if ( pServerView ) {
           pContext->ViewBase = ServerView.ViewBase;
           pContext->ViewSize = ServerView.ViewSize;
           pContext->ViewRemoteBase = ServerView.ViewRemoteBase;
           TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: ViewBase %p, ViewSize 0x%x, ViewRemoteBase %p\n",
             pContext->ViewBase, pContext->ViewSize, pContext->ViewRemoteBase));
       } else {
           pContext->ViewBase = NULL;
           pContext->ViewSize = 0;
           pContext->ViewRemoteBase = NULL;
       }

       pContext->ClientLogonId = ClientLogonId;

       TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WSTAPI: Calling CompleteConnect port %p\n",CommunicationPort));
       pContext->CommunicationPort = CommunicationPort;
       st = NtCompleteConnectPort(CommunicationPort);

    }

    RtlLeaveCriticalSection( &ApiThreadLock );

    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: WinStation LPC Connection %sAccepted, Logonid %d pContext %p Status 0x%x\n",
              (Accept?"":"Not "), pContext->ClientLogonId, pContext, st));

    return( st );
}


/*****************************************************************************
 *
 *  WinStationLpcClientHasTerminated
 *
 *   Cleanup after an LPC communications channel has been closed.
 *
 * ENTRY:
 *    pContext (input)
 *       Pointer to our context structure describing the connnection
 *
 *    ClientId (input)
 *       Pointer to the NT LPC CLIENT_ID structure that describes the
 *       unique process and thread.
 *
 * EXIT:
 *   VOID
 *
 ****************************************************************************/

VOID
WinStationLpcClientHasTerminated(
    IN PLPC_CLIENT_CONTEXT pContext
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationLpcClientHasTerminated called, pContext %p\n",
              pContext));

    //
    //  We can be called here with a NULL pContext if the allocation failed
    //  in WinStationLpcHandleConnectionRequest()
    //
    if (!pContext) {
        return;
    }

    RemoveLpcContext(pContext);

    // Hack for #241885
    // This bug is due to client diying in the window beetween
    // server doing NtAcceptConnectPort() and  NtCompleteConnectPort().
    // This is an  LPC problem (we should not reveive LPC_PORT_CLOSED in such a window).
    // or possibly to the way termsrv uses undocumented LPC features to avoid
    // using a dedicated thread to do NtListenPort(). This is a temporary workaround
    // to avoid stress break.
    //
    // Close the communication port handle

   try {
     if (pContext->CommunicationPort == NULL) {
        return;
     }
     Status = NtClose( pContext->CommunicationPort );
     if (!NT_SUCCESS(Status)) {
        return;

     }
   } except( EXCEPTION_EXECUTE_HANDLER ) {
     return;

   }


    /*
     * Flush the Win32 command queue.
     * If the Win32 command list is not empty, then loop through each
     * entry on the list and unlink it and trigger the wait event.
     */
    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation != NULL ) {
        if ( pContext == pWinStation->pWin32Context ) {
            while ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {
                PLIST_ENTRY Head;
                PCOMMAND_ENTRY pCommand;

                Head = pWinStation->Win32CommandHead.Flink;
                pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );
                RemoveEntryList( &pCommand->Links );
                if ( !pCommand->pMsg->WaitForReply ) {
                    ASSERT( pCommand->Event == NULL );
                    MemFree( pCommand );
                } else {
                    pCommand->Links.Flink = NULL;
                    pCommand->pMsg->ReturnedStatus = STATUS_CTX_CLOSE_PENDING;
                    NtSetEvent( pCommand->Event, NULL );
                }
            }
            pWinStation->pWin32Context = NULL;
        }
        ReleaseWinStation( pWinStation );
    }

    // Free the context struct passed in by the LPC
    MemFree( pContext );
}


/*****************************************************************************
 *
 *  WinStationInternalCreate
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInternalCreate( PLPC_CLIENT_CONTEXT pContext,
                          PWINSTATION_APIMSG pMsg )
{
    WINSTATIONCREATEMSG *m = &pMsg->u.Create;

    /*
     * Call the create worker
     */
    if ( m->WinStationName[0] ) {
        pMsg->ReturnedStatus = WinStationCreateWorker( m->WinStationName,
                                                       &m->LogonId, 
                                                       TRUE );
    } else {
        pMsg->ReturnedStatus = WinStationCreateWorker( NULL,
                                                       &m->LogonId,
                                                       TRUE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCreate, Status=0x%x\n", pMsg->ReturnedStatus ));

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationInternalReset
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInternalReset( PLPC_CLIENT_CONTEXT pContext,
                         PWINSTATION_APIMSG pMsg )
{
    WINSTATIONRESETMSG *m = &pMsg->u.Reset;

    /*
     * Call the reset worker
     */
    pMsg->ReturnedStatus = WinStationResetWorker( m->LogonId, FALSE, FALSE, TRUE );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationReset, Status=0x%x\n", pMsg->ReturnedStatus ));

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationInternalDisconnect
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationInternalDisconnect( PLPC_CLIENT_CONTEXT pContext,
                              PWINSTATION_APIMSG pMsg )
{
    WINSTATIONDISCONNECTMSG *m = &pMsg->u.Disconnect;

    /*
     * Call the disconnect worker
     */
    pMsg->ReturnedStatus = WinStationDisconnectWorker( m->LogonId, FALSE, FALSE );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDisconnect, Status=0x%x\n", pMsg->ReturnedStatus ));

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationWCharLog
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationWCharLog( PLPC_CLIENT_CONTEXT pContext,
                              PWINSTATION_APIMSG pMsg )
{
    extern WCHAR gpszServiceName[];
    WINSTATIONWCHARLOG *m= &pMsg->u.WCharLog;
    PWCHAR ModulePath = m->Buffer;
    HANDLE h;

    h = RegisterEventSource(NULL, gpszServiceName);
    if (h != NULL)
       {
       ReportEvent(h, EVENTLOG_ERROR_TYPE, 0, EVENT_STACK_LOAD_FAILED, NULL, 1, 0, &ModulePath, NULL);
       DeregisterEventSource(h);
       }

    return( STATUS_SUCCESS );
}

/*****************************************************************************
 *
 *  WinStationGetSMCommand
 *
 *   This is the API that the Winstations call in order to get
 *   work to do. We send Winstations commands from SendWinStationCommand()
 *   once they have called this API.
 *
 *   NOTE: Only WinStations may call this command!
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationGetSMCommand( PLPC_CLIENT_CONTEXT pContext,
                        PWINSTATION_APIMSG pMsg )
{
    PLIST_ENTRY Head;
    PWINSTATION pWinStation;
    PCOMMAND_ENTRY pCommand;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand, LogonId=%d\n",
              pContext->ClientLogonId ));

    /*
     * Find and lock client WinStation
     */

    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand LogonId=%d not found\n",
                   pContext->ClientLogonId ));
        return( STATUS_SUCCESS );
    }

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand LogonId=%d wrong process id %d != %d\n",
                   pContext->ClientLogonId,
                   pMsg->h.ClientId.UniqueProcess,
                   pWinStation->WindowsSubSysProcessId ));
#if DBG
        DbgBreakPoint();
#endif
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * If the LPC context pointer has not been saved yet, do it now
     */
    if ( pWinStation->pWin32Context == NULL )
        pWinStation->pWin32Context = pContext;

    /*
     * If this message is a reply to a previous Win32 command,
     * then verify the reply is for the message on the head of the
     * Win32 command queue and complete the command processing.
     */
    if ( pMsg->WaitForReply ) {

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand wait for reply\n"));

        if ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand list entry\n"));

            Head = pWinStation->Win32CommandHead.Flink;
            pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );
            if ( pCommand->pMsg->MessageId == pMsg->MessageId ) {
                WINSTATION_APINUMBER ApiNumber;

                /*
                 * Copy reply msg back to command entry
                 * (make sure we preserve original API number)
                 */
                ApiNumber = pCommand->pMsg->ApiNumber;
                *pCommand->pMsg = *pMsg;
                pCommand->pMsg->ApiNumber = ApiNumber;

                TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand, LogonId=%d, Reply for Cmd %s, Status=0x%x\n",
                          pContext->ClientLogonId,
                          WinStationLpcName[pCommand->pMsg->ApiNumber],
                          pMsg->ReturnedStatus ));

                /*
                 * Unlink this command entry and
                 * trigger event to wakeup the waiter.
                 */
                RemoveEntryList( &pCommand->Links );
                pCommand->Links.Flink = NULL;
                NtSetEvent( pCommand->Event, NULL );
            }
            else {
                DBGPRINT(("TERMSRV: WinStationGetSMCommand, no cmd entry for MessageId 0x%x\n", pMsg->MessageId ));
            }
        }
        else {
            DBGPRINT(( "TERMSRV: WinStationGetSMCommand, cmd queue empty for MessageId 0x%x\n", pMsg->MessageId ));
        }
    }

    /*
     * If the head of the Win32 command queue is non-empty,
     * then send the first command in the queue to Win32.
     */
    if ( !IsListEmpty( &pWinStation->Win32CommandHead ) ) {

        Head = pWinStation->Win32CommandHead.Flink;
        pCommand = CONTAINING_RECORD( Head, COMMAND_ENTRY, Links );

        /*
         * Send the msg contained in the command entry, but be sure to use
         * the LPC PORT_MESSAGE fields from the original msg we received
         * since we are sending the command as an LPC reply message.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand, LogonId=%d, sending next cmd\n",
                  pWinStation->LogonId ));

#ifdef notdef // no longer needed - but good example of using view memory
        /*
         * Do connect needs to copy data to the view
         */
        if ( pCommand->pMsg->ApiNumber == SMWinStationDoConnect ) {

             pCommand->pMsg->u.DoConnect.VDInfoLength =
                   min ( pCommand->pMsg->u.DoConnect.VDInfoLength,
                         pContext->ViewSize );

             TRACE((hTrace,TC_ICASRV,TT_API1, "SMSS: WinStationGetSMCommand, Copying VD Info data %d\n", pCommand->pMsg->u.DoConnect.VDInfoLength ));
             RtlCopyMemory( pContext->ViewBase,
                            pCommand->pMsg->u.DoConnect.VDInfo,
                            pCommand->pMsg->u.DoConnect.VDInfoLength );
                            pCommand->pMsg->u.DoConnect.VDInfo = pContext->ViewRemoteBase;
        }
#endif

        /*
         * On DoMessage API copy to client view and free temp memory
         */
        if ( pCommand->pMsg->ApiNumber == SMWinStationDoMessage ) {

            PVOID pTitle;
            PVOID pMessage;

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: pulled SMWinStationDoMessage, copy to client view\n" ));

            // Get pointers to client view of memory

            pTitle = pContext->ViewBase;
            pMessage = (PVOID)((ULONG_PTR)pTitle + pCommand->pMsg->u.SendMessage.TitleLength);

            // Copy out the pTitle and pMessage strings to client view

            RtlMoveMemory( pTitle, pCommand->pMsg->u.SendMessage.pTitle,
                                   pCommand->pMsg->u.SendMessage.TitleLength );
            RtlMoveMemory( pMessage, pCommand->pMsg->u.SendMessage.pMessage,
                                   pCommand->pMsg->u.SendMessage.MessageLength );

            MemFree( pCommand->pMsg->u.SendMessage.pTitle );
            MemFree( pCommand->pMsg->u.SendMessage.pMessage );

            pCommand->pMsg->u.SendMessage.pTitle   =
                          (PVOID)(pContext->ViewRemoteBase);
            pCommand->pMsg->u.SendMessage.pMessage =
                          (PVOID) ((ULONG_PTR)pContext->ViewRemoteBase + pCommand->pMsg->u.SendMessage.TitleLength);

        } else if ( pCommand->pMsg->ApiNumber == SMWinStationDoLoadStringNMessage ) {

            PVOID pDomain;
            PVOID pUserName;

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: pulled SMWinStationDoLoadStringNMessage, copy to client view\n" ));

            // Get pointers to client view of memory

            pDomain = pContext->ViewBase;
            pUserName = (PVOID)((ULONG_PTR)pDomain + pCommand->pMsg->u.LoadStringMessage.DomainSize);

            // Copy out the pTitle and pMessage strings to client view

            RtlMoveMemory( pDomain, pCommand->pMsg->u.LoadStringMessage.pDomain,
                                   pCommand->pMsg->u.LoadStringMessage.DomainSize );
            RtlMoveMemory( pUserName, pCommand->pMsg->u.LoadStringMessage.pUserName,
                                   pCommand->pMsg->u.LoadStringMessage.UserNameSize );

            MemFree( pCommand->pMsg->u.LoadStringMessage.pDomain );
            MemFree( pCommand->pMsg->u.LoadStringMessage.pUserName );

            pCommand->pMsg->u.LoadStringMessage.pDomain   =
                          (PVOID)(pContext->ViewRemoteBase);
            pCommand->pMsg->u.LoadStringMessage.pUserName =
                          (PVOID) ((ULONG_PTR)pContext->ViewRemoteBase + pCommand->pMsg->u.LoadStringMessage.DomainSize);

        } else if ( pCommand->pMsg->ApiNumber == SMWinStationShadowStart ||
                    pCommand->pMsg->ApiNumber == SMWinStationShadowCleanup ) {

            PVOID pData;

            // Get pointers to client view of memory

            pData = pContext->ViewBase;

            // Copy out the Thinwire data to client view

            RtlMoveMemory( pData, pCommand->pMsg->u.ShadowStart.pThinwireData,
                           pCommand->pMsg->u.ShadowStart.ThinwireDataLength );

            MemFree( pCommand->pMsg->u.ShadowStart.pThinwireData );

            pCommand->pMsg->u.ShadowStart.pThinwireData =
                          (PVOID)(pContext->ViewRemoteBase);

        } else if ( pCommand->pMsg->ApiNumber == SMWinStationSendWindowMessage) {
             
            PVOID               pView;

            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pCommand->pMsg->u.sMsg.dataBuffer, 
                                    pCommand->pMsg->u.sMsg.bufferSize );
                                    
            MemFree( pCommand->pMsg->u.sMsg.dataBuffer );

            // Update msg
            pCommand->pMsg->u.sMsg.dataBuffer   = 
                            (PVOID)pContext->ViewRemoteBase;
            
        
        } else if ( pCommand->pMsg->ApiNumber == SMWinStationBroadcastSystemMessage) {
            
            PVOID               pView;
            
            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pCommand->pMsg->u.bMsg.dataBuffer, 
                                    pCommand->pMsg->u.bMsg.bufferSize );
            
            MemFree( pCommand->pMsg->u.bMsg.dataBuffer );
            
            // Update msg
            pCommand->pMsg->u.bMsg.dataBuffer   = 
                            (PVOID)pContext->ViewRemoteBase;
        
        }

        pCommand->pMsg->h = pMsg->h;
        NtReplyPort( pContext->CommunicationPort,
                     (PPORT_MESSAGE)pCommand->pMsg );

        /*
         * If no reply is expected, then unlink/free this command entry.
         */
        if ( !pCommand->pMsg->WaitForReply ) {
            RemoveEntryList( &pCommand->Links );
            ASSERT( pCommand->Event == NULL );
            MemFree( pCommand );
        }

    /*
     * The Win32 command queue is empty.  Save the port handle and port
     * message in the WinStation.  The next time a command is to be
     * sent to this WinStation, these will be used to send it.
     */
    } else {
        ASSERT( pWinStation->Win32CommandPort == NULL );
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationGetSMCommand queue empty port %p\n",
                    pContext->CommunicationPort));
        pWinStation->Win32CommandPort = pContext->CommunicationPort;
        pWinStation->Win32CommandPortMsg = pMsg->h;
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    /*
     * We ALWAYS return STATUS_PENDING so the msg dispatch routine
     * does not send a reply message now.  ALL replies to this message
     * are handled above or in the SendWinStationCommand() routine.
     */
    return( STATUS_PENDING );
}


/*****************************************************************************
 *
 *  WinStationBrokenConnection
 *
 *   API called from Winstation requesting a broken connection
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationBrokenConnection( PLPC_CLIENT_CONTEXT pContext,
                            PWINSTATION_APIMSG pMsg )
{
    WINSTATIONBROKENCONNECTIONMSG *m = &pMsg->u.Broken;
    BROKENCLASS Reason = (BROKENCLASS) m->Reason;
    PWINSTATION pWinStation;
    ULONG SessionId;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationBrokenConnection, LogonId=%d, Reason=%u\n",
               pContext->ClientLogonId, Reason ));

    /*
     * Indicate A reply will be returned to client
     */
    pMsg->WaitForReply = TRUE;


    /*
     * Make sure the context is still active and get session Id from it.
     */


    if (!GetSessionIdFromLpcContext(pContext, &SessionId)) {
        return STATUS_SUCCESS;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( SessionId, FALSE );
    if ( pWinStation == NULL )
        return( STATUS_SUCCESS );

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * If WinStation is already disconnected, then we're done
     */
    if ( !pWinStation->WinStationName[0] )  {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * If busy with something already, don't do this
     */
    if ( pWinStation->Flags ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_CTX_WINSTATION_BUSY );
    }

    /*
     * Save reason/source for this broken connection
     */
    pWinStation->BrokenReason = Reason;
    pWinStation->BrokenSource = m->Source;

    if ( pWinStation->NeverConnected ) {
        pWinStation->StateFlags |= WSF_ST_BROKEN_CONNECTION;
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }


    /*
     * if any of the following is TRUE;
     *  - the session is a Salem 'help assistant' session.
     *  - no user is logged on (logon time is 0)
     *  - reset is requested
     *  - unexpected broken connection and current user is
     *    setup to reset on broken connection
     * then queue a reset request
     */
    if (RtlLargeIntegerEqualToZero( pWinStation->LogonTime ) ||
        (Reason == Broken_Terminate) ||
         ((Reason == Broken_Unexpected) && pWinStation->Config.Config.User.fResetBroken) ||
         TSIsSessionHelpSession(pWinStation, NULL)) {
         
        QueueWinStationReset( pWinStation->LogonId);

    /*
     * Otherwise, disconnect the WinStation
     */
    } else {
    
        QueueWinStationDisconnect( pWinStation->LogonId );
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationIcaReplyMessage
 *
 *   API called from Winstation for user response to message box
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationIcaReplyMessage( PLPC_CLIENT_CONTEXT pContext,
                           PWINSTATION_APIMSG pMsg )
{
    PWINSTATION pWinStation;

    DBGPRINT(("TERMSRV: WinStationIcaReplyMessage, LogonId=%d\n",
               pContext->ClientLogonId ));

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationIcaReplyMessage, LogonId=%d\n",
               pContext->ClientLogonId ));

    /*
     * Indicate A reply will be returned to client
     */
    pMsg->WaitForReply = TRUE;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation == NULL )
        return( STATUS_SUCCESS );

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * Fill in response
     */
    *pMsg->u.ReplyMessage.pResponse = pMsg->u.ReplyMessage.Response;


    /*
     * Fill in the status of message delievery 
     */
    ASSERT(pMsg->u.ReplyMessage.pStatus);

    *pMsg->u.ReplyMessage.pStatus = pMsg->u.ReplyMessage.Status;


    /*
     * Release RPC thread
     */
    NtSetEvent( pMsg->u.ReplyMessage.hEvent, NULL );

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*****************************************************************************
 *
 *  WinStationIcaShadowHotkey
 *
 *   API called from Winstation that has received a shadow hotkey
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

NTSTATUS
WinStationIcaShadowHotkey( PLPC_CLIENT_CONTEXT pContext,
                           PWINSTATION_APIMSG pMsg )
{
    PWINSTATION pWinStation;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationIcaShadowHotkey, LogonId=%d\n",
               pContext->ClientLogonId ));

    /*
     * Indicate A reply will be returned to client
     */
    pMsg->WaitForReply = TRUE;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( pContext->ClientLogonId, FALSE );
    if ( pWinStation == NULL )
        return( STATUS_SUCCESS );

    /*
     * Ensure this is the Win32 subsystem calling
     */
    if ( pWinStation->WindowsSubSysProcessId &&
         pMsg->h.ClientId.UniqueProcess != pWinStation->WindowsSubSysProcessId ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_SUCCESS );
    }

    /*
     * Process the shadow hotkey.
     *
     * If the shadow client is still waiting for the target
     * to connect, then terminate the passthru stack now to break
     * out of the connection wait.  Also, set the shadow
     * broken event if it is non-NULL.
     */
    if ( pWinStation->hPassthruStack &&
         pWinStation->ShadowConnectionWait ) {
        IcaStackClose( pWinStation->hPassthruStack );
        pWinStation->hPassthruStack = NULL;
    }
    if ( pWinStation->ShadowBrokenEvent ) {
        NtSetEvent( pWinStation->ShadowBrokenEvent, NULL );
    }

    /*
     * Release WinStation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  SendWinStationCommand
 *
 *   Send a command to a WinStation and optionally wait for a reply.
 *
 *   NOTE: This works using a reverse LPC in which the WINSTATION must
 *         have sent a "request" to us for work to do. This prevents
 *         blocking the ICASRV while waiting on a WINSTATION that
 *         could be hung.
 *
 * ENTRY:
 *    pWinStation (input)
 *       Pointer to WinStation to send command to
 *    pMsg (input/output)
 *       Pointer to message to send
 *    WaitTime (input)
 *       Time in seconds to wait for a reply message
 *
 * EXIT:
 *    STATUS_SUCCESS - if successful
 *
 ******************************************************************************/

NTSTATUS
SendWinStationCommand( PWINSTATION pWinStation,
                       PWINSTATION_APIMSG pMsg,
                       ULONG WaitTime )
{
    OBJECT_ATTRIBUTES ObjA;
    COMMAND_ENTRY Command;
    PCOMMAND_ENTRY pCommand;
    NTSTATUS Status;
    BOOLEAN bFreeCommand = FALSE;
    BOOLEAN bTitlenMessageAllocated = FALSE;
    BOOLEAN bDomainUserNameAllocated = FALSE;
    
    //
    // These are only used by the SendWindowMessage and the
    // BroadcastSystemMessage APIs.
    //
    PVOID   pdataBuffer;
    

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, Cmd=%s, Timeout=%d\n",
              pWinStation->LogonId,
              WinStationLpcName[pMsg->ApiNumber],
              WaitTime ));

    ASSERT( IsWinStationLockedByCaller( pWinStation ) );

    // Do not send message to listener.
    if (pWinStation->Flags & WSF_LISTEN)
        return STATUS_ACCESS_DENIED;

    /*
     * Initialize the message id for this message
     */
    pMsg->MessageId = InterlockedIncrement(&MessageId);
    pMsg->ReturnedStatus = 0;
    pMsg->WaitForReply = (WaitTime != 0) ? TRUE : FALSE;

    /*
     * If we will wait for a reply, then create an event to wait on.
     * Since we will wait for a response, its OK to use the static
     * COMMAND entry above.
     */
    if ( pMsg->WaitForReply ) {
        pCommand = &Command;
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtCreateEvent( &pCommand->Event, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );
        if ( !NT_SUCCESS(Status) )
            return( Status );
        pCommand->pMsg = pMsg;

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand pCommand %p pCommand->pMsg %p\n", pCommand, pCommand->pMsg ));


    /*
     * We will not wait for a reply, but the WinStation is currently busy
     * processing a command.  Allocate a dynamic COMMAND entry which will
     * be linked into the the command list and sent when it reaches the
     * head of the list.
     */
    } else if ( pWinStation->Win32CommandPort == NULL ) {
        pCommand = MemAlloc( sizeof(*pCommand) + sizeof(*pMsg) );

        /* makarp; check for MemAlloc failures. #182622 */
        if (!pCommand) {
            return (STATUS_NO_MEMORY);
        }
        pCommand->Event = NULL;
        pCommand->pMsg = (PWINSTATION_APIMSG)(pCommand + 1);
        *pCommand->pMsg = *pMsg;
        Status = STATUS_SUCCESS;

    /*
     * We will not wait for a reply and the WinStation is NOT busy
     * with a command, so there is no need for a COMMAND entry.
     * The current message will be sent below.
     */
    } else {
        pCommand = NULL;
    }

    /*
     * On DoMessage API either copy message to client view or strdup strings.
     */
    if ( pMsg->ApiNumber == SMWinStationDoMessage ) {

        PVOID pTitle;
        PVOID pMessage;
        PLPC_CLIENT_CONTEXT pContext;

        //
        // assert some parameters
        //
        ASSERT(pMsg->u.SendMessage.DoNotWait == (pMsg->u.SendMessage.pStatus == NULL));
        ASSERT(pMsg->u.SendMessage.DoNotWait == (pMsg->u.SendMessage.hEvent == NULL));


        // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            bFreeCommand = TRUE;
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.SendMessage.TitleLength + pMsg->u.SendMessage.MessageLength) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            bFreeCommand = TRUE;
            goto done;
        }

        //  busy? then strdup string else copy to client view
        if ( pWinStation->Win32CommandPort ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pTitle = pContext->ViewBase;
            pMessage = (PVOID)((ULONG_PTR)pTitle + pMsg->u.SendMessage.TitleLength);

            // Copy out the pTitle and pMessage strings to client view
            RtlMoveMemory( pTitle, pMsg->u.SendMessage.pTitle, pMsg->u.SendMessage.TitleLength );
            RtlMoveMemory( pMessage, pMsg->u.SendMessage.pMessage, pMsg->u.SendMessage.MessageLength );

            // Update msg
            pMsg->u.SendMessage.pTitle   =
                          (PVOID)(pContext->ViewRemoteBase);
            pMsg->u.SendMessage.pMessage =
                          (PVOID) ((ULONG_PTR)pContext->ViewRemoteBase + pMsg->u.SendMessage.TitleLength);
        }
        else if ( pCommand )  {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC BUSY, queue for later processing\n" ));

            // Get pointers to temporary memory
            pTitle = MemAlloc( pMsg->u.SendMessage.TitleLength );
            if (pTitle == NULL) {
                Status = STATUS_NO_MEMORY;
                bFreeCommand = TRUE;
                goto done;
            }
            pMessage = MemAlloc( pMsg->u.SendMessage.MessageLength );
            if (pMessage == NULL) {
                Status = STATUS_NO_MEMORY;
                MemFree( pTitle );
                bFreeCommand = TRUE;
                goto done;
            }

            bTitlenMessageAllocated = TRUE;

            // Copy out the pTitle and pMessage strings to temp memory
            RtlMoveMemory( pTitle, pMsg->u.SendMessage.pTitle, pMsg->u.SendMessage.TitleLength );
            RtlMoveMemory( pMessage, pMsg->u.SendMessage.pMessage, pMsg->u.SendMessage.MessageLength );

            // Update msg
            pCommand->pMsg->u.SendMessage.pTitle = pTitle;
            pCommand->pMsg->u.SendMessage.pMessage = pMessage;
        }

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SMWinStationDoMessage pTitle   %S\n", pTitle ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SMWinStationDoMessage pMessage %S\n", pMessage ));

    } else if ( pMsg->ApiNumber == SMWinStationDoLoadStringNMessage) {

        PVOID pDomain;
        PVOID pUserName;
        PLPC_CLIENT_CONTEXT pContext;

        //
        // assert some parameters
        //
        ASSERT(pMsg->u.LoadStringMessage.DoNotWait == (pMsg->u.LoadStringMessage.pStatus == NULL));
        ASSERT(pMsg->u.LoadStringMessage.DoNotWait == (pMsg->u.LoadStringMessage.hEvent == NULL));


        // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            bFreeCommand = TRUE;
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.LoadStringMessage.DomainSize + pMsg->u.LoadStringMessage.UserNameSize) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            bFreeCommand = TRUE;
            goto done;
        }

        //  busy? then strdup string else copy to client view
        if ( pWinStation->Win32CommandPort ) {
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pDomain = pContext->ViewBase;
            pUserName = (PVOID)((ULONG_PTR)pDomain + pMsg->u.LoadStringMessage.DomainSize);

            // Copy out the pTitle and pMessage strings to client view
            RtlMoveMemory( pDomain, pMsg->u.LoadStringMessage.pDomain, pMsg->u.LoadStringMessage.DomainSize );
            RtlMoveMemory( pUserName, pMsg->u.LoadStringMessage.pUserName, pMsg->u.LoadStringMessage.UserNameSize );

            // Update msg
            pMsg->u.LoadStringMessage.pDomain   =
                          (PVOID)(pContext->ViewRemoteBase);
            pMsg->u.LoadStringMessage.pUserName =
                          (PVOID) ((ULONG_PTR)pContext->ViewRemoteBase + pMsg->u.LoadStringMessage.DomainSize);
        }
        else if ( pCommand )  {
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC BUSY, queue for later processing\n" ));

            // Get pointers to temporary memory
            pDomain = MemAlloc( pMsg->u.LoadStringMessage.DomainSize );
            if (pDomain == NULL) {
                Status = STATUS_NO_MEMORY;
                bFreeCommand = TRUE;
                goto done;
            }
            pUserName = MemAlloc( pMsg->u.LoadStringMessage.UserNameSize );
            if (pUserName == NULL) {
                Status = STATUS_NO_MEMORY;
                MemFree( pDomain );
                bFreeCommand = TRUE;
                goto done;
            }

            bDomainUserNameAllocated = TRUE;

            // Copy out the pTitle and pMessage strings to temp memory
            RtlMoveMemory( pDomain, pMsg->u.LoadStringMessage.pDomain, pMsg->u.LoadStringMessage.DomainSize );
            RtlMoveMemory( pUserName, pMsg->u.LoadStringMessage.pUserName, pMsg->u.LoadStringMessage.UserNameSize );

            // Update msg
            pCommand->pMsg->u.LoadStringMessage.pDomain = pDomain;
            pCommand->pMsg->u.LoadStringMessage.pUserName = pUserName;
        }

        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SMWinStationDoLoadStringNMessage pDomain   %S\n", pDomain ));
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SMWinStationDoLoadStringNMessage pUserName %S\n", pUserName ));

    } else if ( pMsg->ApiNumber == SMWinStationShadowStart ||
                pMsg->ApiNumber == SMWinStationShadowCleanup ) {

        PVOID pData;
        PLPC_CLIENT_CONTEXT pContext;

        // get winstation contect
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            bFreeCommand = TRUE;
            goto done;
        }



        // validate size of parameters
        if (( pMsg->u.ShadowStart.ThinwireDataLength) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            bFreeCommand = TRUE;
            goto done;
        }



        //  busy? then strdup string else copy to client view
        if ( pWinStation->Win32CommandPort ) {

            // Get pointers to client view of memory
            pData = pContext->ViewBase;

            // Copy out the ThinwireData to client view
            RtlCopyMemory( pData, pMsg->u.ShadowStart.pThinwireData,
                           pMsg->u.ShadowStart.ThinwireDataLength );

            // Update msg
            pMsg->u.ShadowStart.pThinwireData =
                          (PVOID) (pContext->ViewRemoteBase);
        }
        else if ( pCommand )  {

            // Get pointers to temporary memory
            pData = MemAlloc( pMsg->u.ShadowStart.ThinwireDataLength );
            if (pData == NULL) {
                Status = STATUS_NO_MEMORY;
                bFreeCommand = TRUE;
                goto done;
            }

            // Copy out the ThinwireData to temp memory
            RtlCopyMemory( pData, pMsg->u.ShadowStart.pThinwireData,
                           pMsg->u.ShadowStart.ThinwireDataLength );

            // Update msg
            pCommand->pMsg->u.ShadowStart.pThinwireData = pData;
        }
    }
    else if ( pMsg->ApiNumber == SMWinStationSendWindowMessage )// This msg always has WaitForReply=TRUE
    {
        PLPC_CLIENT_CONTEXT pContext;
        PVOID   pView;
        
         // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.sMsg.bufferSize ) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        //  if not busy? then copy to client view
        if ( pWinStation->Win32CommandPort ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pMsg->u.sMsg.dataBuffer, pMsg->u.sMsg.bufferSize );

            // Update msg
            pMsg->u.sMsg.dataBuffer   = (PVOID)pContext->ViewRemoteBase;
            
        }
        else if ( pCommand )    // this is on the stack, since this msg always has WaitForReply=TRUE
        {
            pdataBuffer = MemAlloc(pMsg->u.sMsg.bufferSize );
            if ( pdataBuffer == NULL )
            {
                Status = STATUS_NO_MEMORY;
                goto done;
            }
            
            // copy into tmp memory
            RtlMoveMemory(pdataBuffer, pMsg->u.sMsg.dataBuffer, pMsg->u.sMsg.bufferSize );
            
            pCommand->pMsg->u.sMsg.dataBuffer = pdataBuffer;
        }
            
    }
    else if ( pMsg->ApiNumber == SMWinStationBroadcastSystemMessage )// this msg always has WaitForReply=TRUE
    {
        PLPC_CLIENT_CONTEXT pContext;
        PVOID   pView;
        
         // get winstation context
        if ( (pContext = pWinStation->pWin32Context) == NULL ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR WinStationContext not valid\n" ));
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        // validate size of parameters
        if ((pMsg->u.bMsg.bufferSize ) > pContext->ViewSize ) {
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: SendWinStationCommand, ERROR Message or Title too long\n" ));
            Status = STATUS_INVALID_PARAMETER;
            // @@@
            // Do i need this? : bFreeCommand = TRUE;
            // Since we are waiting for a reply, then we have not allocated memory for pCommand,
            // hence, we don't need to set this flag.
            goto done;
        }

        //  if not busy? then copy to client view
        if ( pWinStation->Win32CommandPort ) {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand - WinStation LPC IDLE, process now\n" ));

            // Get pointers to client view of memory
            pView = pContext->ViewBase;

            RtlMoveMemory( pView, pMsg->u.bMsg.dataBuffer, pMsg->u.bMsg.bufferSize );

            // Update msg
            pMsg->u.bMsg.dataBuffer   = (PVOID)pContext->ViewRemoteBase;
            
        }
        else if ( pCommand )    // this is on the stack, since this msg always has WaitForReply=TRUE
        {
            pdataBuffer = MemAlloc(pMsg->u.bMsg.bufferSize );
            if ( pdataBuffer == NULL )
            {
                Status = STATUS_NO_MEMORY;
                goto done;
            }
            
            // copy into tmp memory
            RtlMoveMemory(pdataBuffer, pMsg->u.bMsg.dataBuffer, pMsg->u.bMsg.bufferSize );
            
            pCommand->pMsg->u.bMsg.dataBuffer = pdataBuffer;
        }
    }

    /*
     * If the WinStation is not currently busy processing a command,
     * then send this command now.
     */
    if ( pWinStation->Win32CommandPort ) {
        ASSERT( IsListEmpty( &pWinStation->Win32CommandHead ) );

        /*
         * Send the command msg, but be sure to use the LPC PORT_MESSAGE
         * fields saved from the original msg we received since we are
         * sending the command as an LPC reply message.
         */
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, sending cmd\n",
                  pWinStation->LogonId ));

        pMsg->h = pWinStation->Win32CommandPortMsg;
        Status = NtReplyPort( pWinStation->Win32CommandPort,
                              (PPORT_MESSAGE) pMsg );
        pWinStation->Win32CommandPort = NULL;
        if ( !NT_SUCCESS( Status ) )
            goto done;
    }

    /*
     * If we have a command entry, add it to the command list.
     */
    if ( pCommand )
        InsertTailList( &pWinStation->Win32CommandHead, &pCommand->Links );

    /*
     * If we need to wait for a reply, then do it now.
     */
    if ( pMsg->WaitForReply ) {
        ULONG mSecs;
        LARGE_INTEGER Timeout;

#if DBG
//        if ( (WaitTime != (ULONG)(-1)) && WaitTime < 120 ) // give plenty of time on debug builds
//            WaitTime = 120; 
#endif
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, waiting for response\n",
                  pWinStation->LogonId ));

WaitAgain : 

        if ( WaitTime != (ULONG)(-1) ) {
            mSecs = WaitTime * 1000;
            Timeout = RtlEnlargedIntegerMultiply( mSecs, -10000 );
        }
        UnlockWinStation( pWinStation );
        if ( WaitTime != (ULONG)(-1) ) {

            Status = NtWaitForSingleObject( pCommand->Event, FALSE, &Timeout );

        }
        else {
            DBGPRINT(("Waiting for command with no timeout\n"));
            Status = NtWaitForSingleObject( pCommand->Event, FALSE, NULL );
        }

        if ( !RelockWinStation( pWinStation ) )
            Status = STATUS_CTX_CLOSE_PENDING;


        if ( Status == STATUS_SUCCESS )
            Status = pMsg->ReturnedStatus;
        else if ( Status == STATUS_TIMEOUT ) {

            BOOLEAN DesiredOperation = FALSE; 
            Status = STATUS_CTX_WINSTATION_BUSY;
            
            // If this is a Connect/Reconnect/Disconnect operation and we timed out (for session owning the console, then we break here)
    
            DesiredOperation = ( ((pMsg->ApiNumber == SMWinStationDoConnect) || (pMsg->ApiNumber == SMWinStationDoDisconnect)) && (pWinStation->fOwnsConsoleTerminal) ) ||
                               ( (pMsg->ApiNumber == SMWinStationDoReconnect) && (pWinStation->fReconnectingToConsole) ); 

            if (DesiredOperation) {
                //#if DBG
                //    if (IsKernelDebuggerAttached()) {
                //        DbgPrint("SendWinStationCommand : LPC to Win32k timed out (Conn/Recon/Discon) for Session owning the Console. pMsg->ApiNumber = %d \n", pMsg->ApiNumber);
                //        DebugBreak();
                //    }
                //#endif
                goto WaitAgain;
            }

        }

        if ( pCommand->Links.Flink != NULL )
            RemoveEntryList( &pCommand->Links );


    }

done:
    if ( pCommand ) {
        if ( pCommand->Event ) {
            NtClose( pCommand->Event );
        }

        if ( !pMsg->WaitForReply && bFreeCommand ) {

            // makarp:182622
            if (bTitlenMessageAllocated)
            {
                ASSERT(pCommand->pMsg->u.SendMessage.pTitle);
                ASSERT(pCommand->pMsg->u.SendMessage.pMessage);

                MemFree(pCommand->pMsg->u.SendMessage.pTitle);
                MemFree(pCommand->pMsg->u.SendMessage.pMessage);
            }

            if (bDomainUserNameAllocated)
            {
                ASSERT(pCommand->pMsg->u.LoadStringMessage.pDomain);
                ASSERT(pCommand->pMsg->u.LoadStringMessage.pUserName);

                MemFree(pCommand->pMsg->u.LoadStringMessage.pDomain);
                MemFree(pCommand->pMsg->u.LoadStringMessage.pUserName);
            }

            MemFree( pCommand );

        }
        
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: SendWinStationCommand, LogonId=%d, Cmd=%s, Status=0x%x\n",
              pWinStation->LogonId,
              WinStationLpcName[pMsg->ApiNumber],
              Status ));

    return( Status );
}

NTSTATUS RemoveBadHwnd(ULONG hWnd, ULONG SessionId);

NTSTATUS
WinStationWindowInvalid( PLPC_CLIENT_CONTEXT pContext,
                         PWINSTATION_APIMSG pMsg )
{
    ASSERT(pMsg);
    ASSERT(pMsg->ApiNumber == SMWinStationWindowInvalid);
    ASSERT(pMsg->u.WindowInvalid.hWnd);

    UNREFERENCED_PARAMETER(pContext);
    
    return RemoveBadHwnd(pMsg->u.WindowInvalid.hWnd, pMsg->u.WindowInvalid.SessionId);
}


VOID RemoveLpcContext(PVOID pContext)
{
    PTERMSRVLPCCONTEXT pLpcContextEntry ; 
    PLIST_ENTRY Head, Next;
    BOOL bFoundContext = FALSE;


    Head = &gTermsrvLpcListHead;
    RtlEnterCriticalSection( &ApiThreadLock );

    /*
     * Search the list for a the same context .
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pLpcContextEntry = CONTAINING_RECORD( Next, TERMSRVLPCCONTEXT, Links );
        if ( pLpcContextEntry->pContext == pContext ) {
            RemoveEntryList(&pLpcContextEntry->Links);
            bFoundContext = TRUE;
            break;

        }
    }
    RtlLeaveCriticalSection( &ApiThreadLock );
    if (bFoundContext) {
        MemFree(pLpcContextEntry);
    }

}

BOOL GetSessionIdFromLpcContext(PLPC_CLIENT_CONTEXT pContext, 
                                PULONG pSessionId)
{
    PTERMSRVLPCCONTEXT pLpcContextEntry ; 
    PLIST_ENTRY Head, Next;
    BOOL bFoundContext = FALSE;


    Head = &gTermsrvLpcListHead;
    RtlEnterCriticalSection( &ApiThreadLock );

    /*
     * Search the list for a the same context .
     */
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pLpcContextEntry = CONTAINING_RECORD( Next, TERMSRVLPCCONTEXT, Links );
        if ( pLpcContextEntry->pContext == pContext ) {
            *pSessionId = pContext->ClientLogonId;
            bFoundContext = TRUE;
            break;

        }
    }
    RtlLeaveCriticalSection( &ApiThreadLock );
    return bFoundContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\assoc.h ===
//=================================================================
//
// assoc.h -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================

class CAssociation : public Provider
{
    public:

        CAssociation(
        LPCWSTR pwszClassName,
        LPCWSTR pwszNamespaceName,

        LPCWSTR pwszLeftClassName,
        LPCWSTR pwszRightClassName,

        LPCWSTR pwszLeftPropertyName,
        LPCWSTR pwszRightPropertyName
        );

        ~CAssociation();

        HRESULT ExecQuery(

            MethodContext* pMethodContext, 
            CFrameworkQuery &pQuery, 
            long lFlags 
        );

        HRESULT GetObject(

            CInstance* pInstance, 
            long lFlags,
            CFrameworkQuery &pQuery
        );

        HRESULT EnumerateInstances(

            MethodContext *pMethodContext,
            long lFlags /*= 0L*/
        );

    protected:
        
        bool IsInstance(const CInstance *pInstance);

        static HRESULT WINAPI StaticEnumerationCallback(

            Provider* pThat,
            CInstance* pInstance,
            MethodContext* pContext,
            void* pUserData
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT EnumerationCallback(

            CInstance *pRight, 
            MethodContext *pMethodContext, 
            void *pUserData
        );

        virtual HRESULT ValidateLeftObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT ValidateRightObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual BOOL AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return IsInstance(pLeft) && IsInstance(pRight);
        }

        virtual HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts
        );

        LPCWSTR m_pwszLeftClassName;
        LPCWSTR m_pwszRightClassName;

        LPCWSTR m_pwszLeftPropertyName;
        LPCWSTR m_pwszRightPropertyName;
};

/*
class CAssocSystemToOS : public CAssociation
{
    public:

        CAssocSystemToOS(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName

        );

        ~CAssocSystemToOS();

    protected:
        HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        );


};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\binding.cpp ===
//=================================================================
//
// binding.cpp -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================
#include <stdafx.h>
#include "precomp.h"
#include <assertbreak.h>

#include "Assoc.h"
#include "Binding.h"


bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2) 
{
   
   if (v1->vt == v2->vt) {
      switch (v1->vt) {
      case VT_BOOL: return (v1->boolVal == v2->boolVal);
      case VT_UI1:  return (v1->bVal == v2->bVal);
      case VT_I2:   return (v1->iVal == v2->iVal);
      case VT_I4:   return (v1->lVal == v2->lVal);
      case VT_R4:   return (v1->fltVal == v2->fltVal);
      case VT_R8:   return (v1->dblVal == v2->dblVal);
      case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
      default:
         ASSERT_BREAK(0);
      }
   }
   return false;
}

CBinding::CBinding(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName
)

: CAssociation (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName
)
{
    ASSERT_BREAK( ( pwszLeftBindingPropertyName != NULL ) && ( pwszRightBindingPropertyName != NULL) );

    m_pwszLeftBindingPropertyName = pwszLeftBindingPropertyName;
    m_pwszRightBindingPropertyName = pwszRightBindingPropertyName;
}

CBinding::~CBinding()
{
}

//========================
BOOL CBinding::AreRelated(

    const CInstance *pLeft,
    const CInstance *pRight
)
{
    BOOL bRet = FALSE;

    variant_t   LeftBindingPropertyValue,
                RightBindingPropertyValue;

    if (pLeft->GetVariant(m_pwszLeftBindingPropertyName, LeftBindingPropertyValue) &&
        pRight->GetVariant(m_pwszRightBindingPropertyName,  RightBindingPropertyValue) )
    {
        bRet = CompareVariantsNoCase(&LeftBindingPropertyValue, &RightBindingPropertyValue);
    }
    else
    {
        ASSERT_BREAK(0);
    }

    return bRet;
}

HRESULT CBinding::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH, %s FROM %s", m_pwszRightBindingPropertyName, m_pwszRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        NULL,
        pMethodContext,
        lefts);

    return hr;
}

HRESULT CBinding::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH, %s FROM %s", m_pwszLeftBindingPropertyName, m_pwszLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext);
}

HRESULT CBinding::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__RELPATH");
    csaProperties.Add(m_pwszLeftBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

HRESULT CBinding::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__RELPATH");
    csaProperties.Add(m_pwszRightBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

// =========================================================================================================


CBinding MyTerminalServiceToSetting(
    L"Win32_TerminalServiceToSetting",
    L"root\\cimv2",
    L"Win32_TerminalService",
    L"Win32_TerminalServiceSetting",
    L"Element",
    L"Setting",
    L"Name",
    L"ServerName"
);

CBinding MyTerminalTerminalSetting(
    L"Win32_TerminalTerminalSetting",
    L"root\\cimv2",
    L"Win32_Terminal",
    L"Win32_TerminalSetting",
    L"Element",
    L"Setting",
    L"TerminalName",
    L"TerminalName"

);

CBinding MyTSSessionDirectorySetting(
    L"Win32_TSSessionDirectorySetting",
    L"root\\cimv2",
    L"Win32_TerminalService",
    L"Win32_TSSessionDirectory",
    L"Element",
    L"Setting",
    L"Name",
    L"SessionDirectoryActive"
);

/*
CBinding MyTSPermissionsSetting(
    L"Win32_TSPermissionsSetting",
    L"root\\cimv2",
    L"Win32_Terminal",
    L"Win32_TSAccount",
    L"Element",
    L"Setting",
    L"TerminalName",
    L"AccountName"
);

CBinding MyTSNetworkAdapterListSetting(
    L"Win32_TSNetworkAdapterListSetting",
    L"root\\cimv2",
    L"Win32_NetworkAdapter",
    L"Win32_TSNetworkAdapterSetting",
    L"Element",
    L"Setting",
    L"DeviceID",
    L"TerminalName"
);

*/

/*

CBinding MyNetAdaptToNetAdaptConfig(
    L"Win32_NetworkAdapterSetting",
    L"root\\cimv2",
    L"Win32_NetworkAdapter",
    L"Win32_NetworkAdapterConfiguration",
    L"Element",
    L"Setting",
    IDS_Index,
    IDS_Index);

CBinding PageFileToPagefileSetting(
    L"Win32_PageFileElementSetting",
    L"root\\cimv2",
    L"Win32_PageFileUsage",
    L"Win32_PageFileSetting",
    L"Element",
    L"Setting",
    IDS_Name,
    IDS_Name);

CBinding MyPrinterSetting(
    L"Win32_PrinterSetting",
    L"root\\cimv2",
    L"Win32_Printer",
    L"Win32_PrinterConfiguration",
    L"Element",
    L"Setting",
    IDS_DeviceID,
    IDS_Name);

CBinding MyDiskToPartitionSet(
    L"Win32_DiskDriveToDiskPartition",
    L"root\\cimv2",
    L"Win32_DiskDrive",
    L"Win32_DiskPartition",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_Index,
    IDS_DiskIndex
);

CBinding assocPOTSModemToSerialPort(
    L"Win32_POTSModemToSerialPort",
    L"root\\cimv2",
    L"Win32_SerialPort",
    L"Win32_POTSModem",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_AttachedTo
);

CBinding OStoQFE(
    L"Win32_OperatingSystemQFE",
    L"root\\cimv2",
    L"Win32_OperatingSystem",
    L"Win32_QuickFixEngineering",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_CSName,
    IDS_CSName
);

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\binding.h ===
//=================================================================
//
// binding.h -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================

#pragma once
class CBinding : public CAssociation
{
    public:

        CBinding(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        ~CBinding();

    protected:

        BOOL AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts
        );

        HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        LPCWSTR m_pwszLeftBindingPropertyName;
        LPCWSTR m_pwszRightBindingPropertyName;
};

bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\wstrpc.c ===
/****************************************************************************/
// wstrpc.c
//
// TermSrv API RPC server code.
//
// Copyright (C) 1997-2000 Microsoft Corporation
/****************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <winuserp.h>

#define SECURITY_WIN32

#include <stdlib.h>
#include <time.h>
#include <tchar.h>
#include <lmaccess.h>
#include <lmerr.h>
#include <allproc.h>
#include <winsta.h>
#include <rpc.h>
#include <vdmdbg.h>
#include <dsrole.h>
#include <security.h>
#include <ntsecapi.h>
#include <lmapibuf.h>
#include "..\rpcwire.h"
#define INITGUID
#include "objbase.h"
#include "initguid.h"
#include <netcfgx.h>
#include "devguid.h"

#include <malloc.h>
#include <dsgetdc.h>
#include <winsock2.h>
#include <tdi.h>

#include <reason.h>

#include "tsremdsk.h"

/*
 * Include the RPC generated common header
 */
#include "tsrpc.h"

#include "icaevent.h"
#include "sessdir.h"

#include "conntfy.h"

#define REMOTE_DISCONNECT_TITLE_ID      23
#define REMOTE_DISCONNECT_MESSAGE_ID    24

#define  MIN_GAP_DATABASE_SIZE 100

#define MAX_IDS_LEN   256     // maximum length that the input parm can be

#define MAX_BUF  256
#define MAX_STRING_BYTES 512

//
// Winlogon defines
//
#define APPLICATION_NAME                    TEXT("Winlogon")
#define WINSTATIONS_DISABLED                TEXT("WinStationsDisabled")

#ifdef NTSDDEBUG
#define NTSDDBGPRINT(x) DbgPrint x
#else
#define NTSDDBGPRINT(x)
#endif

//
// Value passed to RPC runtime libraries for the maximum number of
// cached threads it will keep around. We can actually service more RPC
// calls than this, but it will delete threads when they are done.
//
#define MAX_WINSTATION_RPC_THREADS 1000

//
//This value is to restrict the number 
//of concurrent calls to WinStationWaitSystemEvent(), 
//We should keep it lower than MAX_WINSTATION_RPC_THREADS
//because this calls may block indefinitely, thus, if we don't do so, 
//it may render TS RPC service unresponsive for indefinite period of time.
//
#define MAX_SYSTEM_EVENTS 100


#ifdef notdef
// This validates the user pointer to be within the View memory region
#define ISPOINTERVALID_SERVER(pContext, p, length)              \
    (((ULONG)(p) >= (ULONG)(pContext)->ViewBase) &&       \
    ((char *)(p) + (length)) < (char *)((ULONG)(pContext)->ViewBase+pContext->ViewSize))
#endif


 //
 // Extern funcs, these three are from acl.c
extern VOID CleanUpSD(PSECURITY_DESCRIPTOR);
extern BOOL IsCallerSystem( VOID );
extern BOOL IsCallerAdmin( VOID );
extern BOOL IsCallerAnonymous( VOID );
extern BOOLEAN WinStationCheckConsoleSession(VOID);
extern NTSTATUS CheckIdleWinstation(VOID);

extern NTSTATUS WaitForConsoleConnectWorker( PWINSTATION pWinStation );

extern WCHAR gpszServiceName[];

extern BOOL g_fAppCompat;

extern ULONG MaxOutStandingConnect;
extern ULONG NumOutStandingConnect;
extern HANDLE hConnectEvent;


// TermSrv counter values
extern DWORD g_TermSrvTotalSessions;
extern DWORD g_TermSrvReconSessions;
extern DWORD g_TermSrvDiscSessions;

extern DWORD g_TermSrvSuccTotalLogons;
extern DWORD g_TermSrvSuccRemoteLogons;
extern DWORD g_TermSrvSuccLocalLogons;
extern DWORD g_TermSrvSuccSession0Logons;

extern PSID gSystemSid;
extern PSID gAdminSid;

extern HANDLE WinStationIdleControlEvent;

extern HANDLE ConsoleLogoffEvent;
extern RTL_CRITICAL_SECTION ConsoleLock;
extern ULONG gConsoleCreationDisable;

extern NTSTATUS
WinStationEnableSessionIo( 
    PWINSTATION pWinStation, 
    BOOL bEnable
);

extern NTSTATUS
_CheckShadowLoop(
    IN ULONG ClientLogonId,
    IN PWSTR pTargetServerName,
    IN ULONG TargetLogonId
    );

extern BOOL
Filter_RemoveOutstandingConnection(
        IN PBYTE    pin_addr,
        IN UINT     uAddrSize
        );

extern NTSTATUS
WinStationWinerrorToNtStatus(ULONG ulWinError);

typedef struct _SID_CACHE_LIST_ENTRY {
    LIST_ENTRY      ListEntry;
    HANDLE          ProcId;
    LARGE_INTEGER   CreateTime;
    PSID            pSid;
} SID_CACHE_LIST_ENTRY, *PSID_CACHE_LIST_ENTRY;

#define MAX_SID_CACHE_ENTRIES 4000
ULONG gMaxSidCacheEntries = 0;

#define REG_GUID_TABLE      REG_CONTROL_TSERVER L"\\lanatable\\"
#define LANA_ID             L"LanaId"


/*=============================================================================
==   Functions Defined
=============================================================================*/
VOID     NotifySystemEvent( ULONG );
VOID     CheckSidCacheSize();
RPC_STATUS RegisterRPCInterface( BOOL bReregister );

/*=============================================================================
==   External Functions used
=============================================================================*/

NTSTATUS WinStationEnumerateWorker( PULONG, PLOGONID, PULONG, PULONG );
NTSTATUS WinStationRenameWorker( PWINSTATIONNAME, ULONG, PWINSTATIONNAME, ULONG );
NTSTATUS xxxWinStationQueryInformation( ULONG, ULONG, PVOID, ULONG, PULONG );
NTSTATUS xxxWinStationSetInformation( ULONG, WINSTATIONINFOCLASS, PVOID, ULONG );
NTSTATUS LogonIdFromWinStationNameWorker( PWINSTATIONNAME, ULONG, PULONG );
NTSTATUS IcaWinStationNameFromLogonId( ULONG, PWINSTATIONNAME );
NTSTATUS WaitForConnectWorker( PWINSTATION pWinStation, HANDLE ClientProcessId );
DWORD xxxWinStationGenerateLicense( PWCHAR, ULONG, PCHAR, ULONG );
DWORD xxxWinStationInstallLicense( PCHAR, ULONG );
DWORD xxxWinStationEnumerateLicenses( PULONG, PULONG, PCHAR, PULONG );
DWORD xxxWinStationActivateLicense( PCHAR, ULONG, PWCHAR, ULONG );
DWORD xxxWinStationRemoveLicense( PCHAR, ULONG );
DWORD xxxWinStationSetPoolCount( PCHAR, ULONG );
DWORD xxxWinStationQueryUpdateRequired( PULONG );
NTSTATUS WinStationShadowWorker( ULONG, PWSTR, ULONG, ULONG, BYTE, USHORT );
NTSTATUS WinStationShadowTargetSetupWorker( BOOL, ULONG );
NTSTATUS WinStationShadowTargetWorker( BOOLEAN, BOOL, ULONG, PWINSTATIONCONFIG2, PICA_STACK_ADDRESS,
                                       PVOID, ULONG, PVOID, ULONG, PVOID );
NTSTATUS WinStationStopAllShadows( PWINSTATION );

VOID     WinStationTerminate( PWINSTATION );
VOID     WinStationDeleteWorker( PWINSTATION );
NTSTATUS WinStationDoDisconnect( PWINSTATION, PRECONNECT_INFO, BOOLEAN );
NTSTATUS WinStationDoReconnect( PWINSTATION, PRECONNECT_INFO );
VOID     CleanupReconnect( PRECONNECT_INFO );
NTSTATUS ShutdownLogoff( ULONG, ULONG );

NTSTATUS SelfRelativeToAbsoluteSD( PSECURITY_DESCRIPTOR,
                                   PSECURITY_DESCRIPTOR *, PULONG );
NTSTATUS QueueWinStationCreate( PWINSTATIONNAME );
ULONG    WinStationShutdownReset( PVOID );
NTSTATUS DoForWinStationGroup( PULONG, ULONG, LPTHREAD_START_ROUTINE );
NTSTATUS InitializeGAPPointersDatabase();
NTSTATUS IncreaseGAPPointersDatabaseSize();
NTSTATUS InsertPointerInGAPDatabase(PVOID Pointer);
VOID     ReleaseGAPPointersDatabase();
BOOLEAN  PointerIsInGAPDatabase(PVOID Pointer);
VOID     ValidateGAPPointersDatabase(ULONG n);
VOID     ResetAutoReconnectInfo( PWINSTATION );

NTSTATUS
GetSidFromProcessId(
    HANDLE          UniqueProcessId,
    LARGE_INTEGER   CreateTime,
    PSID            *ppProcessSid,
    BOOLEAN         ImpersonatingClient
    );

PSECURITY_DESCRIPTOR
WinStationGetSecurityDescriptor(
    PWINSTATION pWinStation
    );

NTSTATUS
WinStationConnectWorker(
    ULONG  ClientLogonId,
    ULONG  ConnectLogonId,
    ULONG  TargetLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize,
    BOOLEAN bWait,
    BOOLEAN bAutoReconnecting
    );

NTSTATUS
WinStationDisconnectWorker(
    ULONG LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc
    );

NTSTATUS
WinStationWaitSystemEventWorker(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    );

NTSTATUS
WinStationCallbackWorker(
    ULONG   LogonId,
    PWCHAR pPhoneNumber
    );

NTSTATUS
WinStationBreakPointWorker(
    ULONG   LogonId,
    BOOLEAN KernelFlag
    );

NTSTATUS
WinStationReadRegistryWorker(
    VOID
    );

NTSTATUS
ReInitializeSecurityWorker(
    VOID
    );

NTSTATUS
WinStationNotifyLogonWorker(
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    BOOLEAN fUserIsAdmin,
    DWORD   UserToken,
    PWCHAR  pDomain,
    DWORD   DomainSize,
    PWCHAR  pUserName,
    DWORD   UserNameSize,
    PWCHAR  pPassword,
    DWORD   PasswordSize,
    UCHAR   Seed,
    PCHAR   pUserConfig,
    DWORD   ConfigSize,
    BOOLEAN *pfIsRedirected
    );

NTSTATUS
WinStationNotifyLogoffWorker(
    DWORD   ClientLogonId,
    DWORD   ClientProcessId
    );

NTSTATUS
WinStationNotifyNewSession(
    DWORD   ClientLogonId
    );

NTSTATUS
WinStationShutdownSystemWorker(
    ULONG ClientLogonId,
    ULONG ShutdownFlags
    );

NTSTATUS
WinStationTerminateProcessWorker(
    ULONG ProcessId,
    ULONG ExitCode
    );

PSECURITY_DESCRIPTOR
BuildEveryOneAllowSD();

NTSTATUS AddUserAce( PWINSTATION );
NTSTATUS RemoveUserAce( PWINSTATION );
NTSTATUS ApplyWinStaMapping( PWINSTATION pWinStation );

NTSTATUS
RpcCheckClientAccess(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

NTSTATUS
RpcCheckClientAccessLocal(
    PWINSTATION pWinStation,
    ACCESS_MASK DesiredAccess,
    BOOLEAN AlreadyImpersonating
    );

_CheckConnectAccess(
    PWINSTATION pSourceWinStation,
    PSID   pClientSid,
    ULONG  ClientLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize
    );

NTSTATUS
RpcCheckSystemClient(
    ULONG LogonId
    );

NTSTATUS
RpcCheckSystemClientNoLogonId(
    PWINSTATION pWinStation
    );

NTSTATUS
RpcGetClientLogonId(
    PULONG pLogonId
    );

BOOL
ConfigurePerSessionSecurity(
    PWINSTATION pWinStation
    );

BOOL
IsCallerAdmin( VOID );

BOOL
IsCallerSystem( VOID );

BOOL
IsCallerAnonymous( VOID );

BOOLEAN
ValidWireBuffer(WINSTATIONINFOCLASS InfoClass,
                PVOID WireBuf,
                ULONG WireBufLen);

NTSTATUS
IsZeroterminateStringA(
    PBYTE pString,
    DWORD  dwLength
    );

NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    ) ;

NTSTATUS
IsConfigValid(
    PWINSTATIONCONFIG2 pConfig
    );

NTSTATUS
WinStationUpdateClientCachedCredentialsWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize,
    BOOLEAN     fSmartCard
    );

NTSTATUS 
WinStationFUSCanRemoteUserDisconnectWorker(
    DWORD       TargetLogonId,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize
    );

NTSTATUS 
WinStationCheckLoopBackWorker(
    DWORD       TargetLogonId,
    DWORD       ClientLogonId,
    PWCHAR      pTargetServerName,
    DWORD       NameSize
    );

NTSTATUS WinStationNotifyDisconnectPipeWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    );

NTSTATUS WinStationSessionInitializedWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    );

NTSTATUS WinStationCheckAccessWorker(
    ULONG       ClientLogonId,
    DWORD       UserToken,
    ULONG       TargetLogonId,
    ULONG       AccessMask
    );



/*=============================================================================
==   Internal Functions used
=============================================================================*/
VOID AuditShutdownEvent(VOID);
BOOL AuditingEnabled(VOID);

NTSTATUS LogoffWinStation( PWINSTATION, ULONG );

//
//Used by IsGinaVersionCurrent()
//
#define WLX_NEGOTIATE_NAME               "WlxNegotiate"
typedef BOOL (WINAPI * PWLX_NEGOTIATE)(DWORD, DWORD *);
BOOL IsGinaVersionCurrent();


#if DBG
void DumpOutLastErrorString()
{
    LPVOID lpMsgBuf;
    DWORD  error = GetLastError();

    DBGPRINT(("GetLastError() = 0x%lx \n", error ));

    FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            error,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
        );

    //
    // Process any inserts in lpMsgBuf.
    // ...
    // Display the string.
    //
    DBGPRINT(("%s\n", (LPCTSTR)lpMsgBuf ));

    //
    // Free the buffer.
    //
    LocalFree( lpMsgBuf );
}
#endif

#if DBG
#define DumpOutLastError    DumpOutLastErrorString()
#else
#define DumpOutLastError
#endif


/*=============================================================================
==   Data
=============================================================================*/
BOOLEAN gbPointersDatabaseIsValid = FALSE;
ULONG   gPointersDatabaseSize;
ULONG   gNbProcesses;
PVOID   *gPointersDatabase = NULL;

RTL_CRITICAL_SECTION    gRpcGetAllProcessesLock;
RTL_CRITICAL_SECTION    gRpcPointersDatabaseLock;
RTL_CRITICAL_SECTION    gRpcSidCacheLock;
BOOLEAN                 gbRpcGetAllProcessesOK;
BOOLEAN                 gbRpcSidCacheOK;

extern RTL_CRITICAL_SECTION WsxListLock;
extern LIST_ENTRY WsxListHead;
extern LIST_ENTRY WinStationListHead;    // protected by WinStationListLock

LIST_ENTRY gSidCacheHead;

BOOLEAN bConsoleConnected=FALSE;

extern POLICY_TS_MACHINE        g_MachinePolicy;    // declared in winsta.c


/*****************************************************************************
 *  WinStationInitRPC
 *
 *   Setup the RPC bindings, and listen for incoming requests.
 ****************************************************************************/
RPC_STATUS
WinStationInitRPC( VOID
    )
{
    RPC_STATUS Status;
    DWORD Result;
    RPC_BINDING_VECTOR *pBindingVector;

    TRACE((hTrace,TC_ICASRV,TT_API2,"RPC WinStationInitRPC\n"));

    //
    //  Initialize the Critical Sections that are
    //  necessary for RpcWinStationGetAllProcesses
    //
    gbRpcGetAllProcessesOK =
        ((NT_SUCCESS(RtlInitializeCriticalSection(&gRpcGetAllProcessesLock))
         && (NT_SUCCESS(RtlInitializeCriticalSection(&gRpcPointersDatabaseLock)))
        )? TRUE : FALSE);

    gbRpcSidCacheOK =
        NT_SUCCESS(RtlInitializeCriticalSection(&gRpcSidCacheLock)) ? TRUE :
        FALSE;
    InitializeListHead(&gSidCacheHead);

    // register the LPC (local only) interface
    Status = RpcServerUseProtseqEp(
                 L"ncalrpc",      // Protocol Sequence (LPC)
                 MAX_WINSTATION_RPC_THREADS,  // Maximum calls at one time
                 L"IcaApi",    // Endpoint
                 NULL          // Pass NULL for Security - RPC will take care of the correct Security based on Protocol Sequence used
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"IcaServ: Error %d RpcUseProtseqEp on ncalrpc\n",Status));
        return( Status );
    }

    //
    // register the Named pipes interface
    // (remote with NT domain authentication)
    //
    Status = RpcServerUseProtseqEp(
                 L"ncacn_np",     // Protocol Sequence
                 MAX_WINSTATION_RPC_THREADS,  // Maximum calls at one time
                 L"\\pipe\\Ctx_WinStation_API_service", // Endpoint
                 NULL             // Security
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcUseProtseqEp on ncacn_np\n",Status));
        return( Status );
    }

    // Register our interface handle
    Status = RegisterRPCInterface( FALSE );

    if( Status != RPC_S_OK ) {
        return( Status );
    }

    // By default, rpc will serialize access to context handles.  Since
    // the ICASRV needs to be able to have two threads access a context
    // handle at once, and it knows what it is doing, we will tell rpc
    // not to serialize access to context handles.


    // We cannot call this function as its effects are process wide, and since we are
    // part of SvcHost, other services also get affected with this call.
    // instead we will use context_handle_noserialize attribute in our acf files.
    //
    // I_RpcSsDontSerializeContext();

    // Now do the RPC listen to service calls
    Status = RpcServerListen(
                 1,     // Min calls
                 MAX_WINSTATION_RPC_THREADS,
                 TRUE   // fDontWait
                 );

    if( Status != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcServerListen\n",Status));
        return( Status );
    }

    return( 0 );
}


/*****************************************************************************
 *  RpcWinStationOpenServer
 *
 *   Function to open the server for WinStation API's.
 *
 *   The purpose of this function is the allocation of the
 *   RPC context handle for server side state information.
 ****************************************************************************/
BOOLEAN
RpcWinStationOpenServer(
    handle_t hBinding,
    DWORD    *pResult,
    HANDLE *phContext
    )
{
    PRPC_CLIENT_CONTEXT p;
    
    //
    // Allocate our open context structure
    //
    p = midl_user_allocate( sizeof(RPC_CLIENT_CONTEXT) );

    if( p == NULL ) {
        *pResult = (DWORD) STATUS_NO_MEMORY;
        return( FALSE );
    }

    //
    // zero it out
    //
    memset( p, 0, sizeof(RPC_CLIENT_CONTEXT) );

    //
    // Initialize it
    //
    p->pWaitEvent = NULL;

    //
    // Return the RPC context handle
    //
    *phContext = (PRPC_CLIENT_CONTEXT)p;

    // Return success
    *pResult = STATUS_SUCCESS;

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationCloseServer
 *
 *   Function to close the server for WinStation API's.
 *   This function is obsolete. use RpcWinstationCloseServerEx instead.
 *   Its kept here for compatibility with older (w2k) clients.
 ****************************************************************************/
BOOLEAN
RpcWinStationCloseServer(
    HANDLE hContext,
    DWORD  *pResult
    )
{
    PRPC_CLIENT_CONTEXT pContext = (PRPC_CLIENT_CONTEXT)hContext;
    ULONG EventFlags;
    NTSTATUS Status;
    
    if(!hContext)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    // Free the wait event block if one was allocated
    if ( pContext->pWaitEvent ) {
        WinStationWaitSystemEventWorker( hContext, WEVENT_NONE, &EventFlags );
    }

    *pResult = STATUS_SUCCESS;

    return( TRUE );
}

/*****************************************************************************
 *  RpcWinStationCloseServerEx
 *
 *   Function to close the server for WinStation API's.
 *   This function supersades the RpcWinStationCloseServer
 ****************************************************************************/
BOOLEAN
RpcWinStationCloseServerEx(
    HANDLE *phContext,
    DWORD  *pResult
    )
{
    PRPC_CLIENT_CONTEXT pContext = NULL;

    ULONG EventFlags;
    NTSTATUS Status;
    
    if(!phContext || !(*phContext))
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }
    
    pContext = (PRPC_CLIENT_CONTEXT)*phContext;

    // Free the wait event block if one was allocated
    if ( pContext->pWaitEvent ) {
        WinStationWaitSystemEventWorker( *phContext, WEVENT_NONE, &EventFlags );
    }

    Status = RpcSsContextLockExclusive(NULL, pContext);
    if (RPC_S_OK == Status)
    {
        midl_user_free(pContext);

        // This is required to signal the RPC that we are done with this context handle
        *phContext = NULL;

        *pResult = STATUS_SUCCESS;
        return( TRUE );
    }
    else
    {
        DbgPrint("-------------RpcWinStationCloseServerEx: failed to lock the Context exclusively, Status = 0x%X\n", Status);
        *pResult = Status;
        if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;
        return (FALSE);
    }
}


/*****************************************************************************
 * RpcIcaServerPing
 *
 * Called on an external ping to this Terminal Server.
 ****************************************************************************/
BOOLEAN
RpcIcaServerPing(
    HANDLE hServer,
    DWORD  *pResult
    )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1,"PING Received!\n"));
    
    *pResult = STATUS_SUCCESS;

    return( TRUE );
}


/*****************************************************************************
 *  RpcWinStationEnumerate
 *
 *   WinStationEnumerate API
 ****************************************************************************/
BOOLEAN
RpcWinStationEnumerate(
    HANDLE  hServer,
    DWORD   *pResult,
    PULONG  pEntries,
    PCHAR   pLogonId,
    PULONG  pByteCount,
    PULONG  pIndex
    )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    if (!pEntries || !pLogonId || !pByteCount || !pIndex) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    *pResult = WinStationEnumerateWorker(
                   pEntries,
                   (PLOGONID)pLogonId,
                   pByteCount,
                   pIndex
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationEnumerateProcesses
 *
 *   WinStationEnumerateProcesses API
 ****************************************************************************/
BOOLEAN
RpcWinStationEnumerateProcesses(
    HANDLE  hServer,
    DWORD   *pResult,
    PBYTE   pProcessBuffer,
    DWORD   ByteCount
    )
{
    PBYTE pSrcProcessBuffer = NULL;
    RPC_STATUS RpcStatus;
    NTSTATUS Status;

    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

#ifdef  _X86_ 

    RtlEnterCriticalSection(&gRpcGetAllProcessesLock);

    // Check if SID cache hasn't grown too much
    CheckSidCacheSize();

    //
    // Allocate a temporary buffer
    //
    pSrcProcessBuffer = MemAlloc (ByteCount);
    if (pSrcProcessBuffer == NULL)
    {
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
        *pResult = STATUS_NO_MEMORY;
        return FALSE;
    }

    //
    // Impersonate client
    //
    RpcStatus = RpcImpersonateClient( NULL );
    
    if( RpcStatus != RPC_S_OK ) {
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
        *pResult = STATUS_ACCESS_DENIED;
        return FALSE;
    }

    /*
     * Perform process enumeration.
     */
    *pResult = NtQuerySystemInformation( SystemProcessInformation,
                                         (PVOID)pSrcProcessBuffer,
                                         ByteCount,
                                         NULL);
    if ( *pResult == STATUS_SUCCESS ) {
        PSYSTEM_PROCESS_INFORMATION pSrcProcessInfo;
        PSYSTEM_PROCESS_INFORMATION pDestProcessInfo;
        PCITRIX_PROCESS_INFORMATION pDestCitrixInfo;
        ULONG   SessionId = INVALID_SESSIONID;
        PWINSTATION pWinStation = NULL;
        ULONG   TotalOffset;
        PSID    pSid;
        ULONG   SizeOfSid;
        PBYTE   pSrc, pDest;
        ULONG   i;
        ULONG   Size = 0;

        /*
         * Walk the returned buffer to calculate the required size.
         */
        pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pSrcProcessBuffer;
        TotalOffset = 0;
        do
        {
            Size += (SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION
                     + (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * pSrcProcessInfo->NumberOfThreads)
                     + pSrcProcessInfo->ImageName.Length
                    );
            //
            //  Get the Sid (will be remembered in the Sid cache)
            //  Maybe it would be better to add here a "Sidmaximumlength" ??
            //
            Status = GetSidFromProcessId(
                            pSrcProcessInfo->UniqueProcessId,
                            pSrcProcessInfo->CreateTime,
                            &pSid,
                            TRUE
                            );

            if (Status == STATUS_CANNOT_IMPERSONATE)
            {
                RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
                MemFree(pSrcProcessBuffer);
                *pResult = STATUS_ACCESS_DENIED;
                return FALSE;
            }

            if (NT_SUCCESS(Status))
            {
                Size += RtlLengthSid(pSid);
            }

            TotalOffset += pSrcProcessInfo->NextEntryOffset;
            pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
        }
        while (pSrcProcessInfo->NextEntryOffset != 0);

        if (ByteCount < Size)
        {
            RevertToSelf();
            RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
            MemFree(pSrcProcessBuffer);
            *pResult = STATUS_INFO_LENGTH_MISMATCH;
            return FALSE;
        }

        /*
         * Walk the returned buffer (it's in new Win2000 SYSTEM_PROCESS_INFORMATION format),
         * copy it to the old TS4 SYSTEM_PROCESS_INFORMATION format, and fixup the addresses
         * (now containing pointers in our address space within pProcessBuffer) to offsets.
         */

        // back to the beginning
        pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pSrcProcessBuffer;
        pDestProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pProcessBuffer;

        // initialize current pointers
        pSrc = pSrcProcessBuffer;
        pDest = pProcessBuffer;
        TotalOffset = 0;
        for(;;) {
            //
            // Check winstation Query access first.
            //
            SessionId = pSrcProcessInfo->SessionId;
            if( SessionId == INVALID_SESSIONID )
            {
                // 
                // Skip the process entry.
                //
                if( pSrcProcessInfo->NextEntryOffset == 0 )
                {
                    pDestProcessInfo->NextEntryOffset = 0;
                    break;
                }

                TotalOffset += pSrcProcessInfo->NextEntryOffset;
                pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
                pSrc = (PBYTE)pSrcProcessInfo;
                continue;
            }

            /*
            * Find and lock client WinStation
            */
            pWinStation = FindWinStationById( SessionId, FALSE );
            if ( pWinStation == NULL ) 
            {
                //
                // The session this process belongs to, might already be gone.
                // Don't fail here, just skip the process entry.
                //
                if( pSrcProcessInfo->NextEntryOffset == 0 )
                {
                    pDestProcessInfo->NextEntryOffset = 0;
                    break;
                }

                TotalOffset += pSrcProcessInfo->NextEntryOffset;
                pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
                pSrc = (PBYTE)pSrcProcessInfo;
                continue;
            }

            Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, TRUE );
            ReleaseWinStation( pWinStation );
            if ( !NT_SUCCESS( Status ) )
            {
                //
                // The client is not authorized to view this process entry. Skip it.
                //
                if( pSrcProcessInfo->NextEntryOffset == 0 )
                {
                    pDestProcessInfo->NextEntryOffset = 0;
                    break;
                }

                TotalOffset += pSrcProcessInfo->NextEntryOffset;
                pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
                pSrc = (PBYTE)pSrcProcessInfo;
                continue;
            }
        
            //
            // Copy process information
            //
            memcpy(pDest,pSrc,SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION);
            pSrc += sizeof(SYSTEM_PROCESS_INFORMATION);
            pDest += SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION;

            //
            // Copy all the threads info
            //
            for (i=0; i < pSrcProcessInfo->NumberOfThreads ; i++)
            {
                memcpy(pDest,pSrc,SIZEOF_TS4_SYSTEM_THREAD_INFORMATION);
                pSrc += sizeof(SYSTEM_THREAD_INFORMATION);
                pDest += SIZEOF_TS4_SYSTEM_THREAD_INFORMATION;
            }

            //
            // Set the old TS4 info
            //
            pDestCitrixInfo = (PCITRIX_PROCESS_INFORMATION) pDest;
            pDest += sizeof(CITRIX_PROCESS_INFORMATION);

            pDestCitrixInfo->MagicNumber = CITRIX_PROCESS_INFO_MAGIC;
            pDestCitrixInfo->LogonId = pSrcProcessInfo->SessionId;
            pDestCitrixInfo->ProcessSid = NULL;

            //
            //  Get the Sid again (from the cache)
            //
            Status = GetSidFromProcessId(
                            pDestProcessInfo->UniqueProcessId,
                            pDestProcessInfo->CreateTime,
                            &pSid,
                            TRUE
                            );

            if (Status == STATUS_CANNOT_IMPERSONATE)
            {
                *pResult = STATUS_ACCESS_DENIED;
                break;
            }

            if (NT_SUCCESS(Status))
            {
                //
                // Copy the Sid
                //
                SizeOfSid = RtlLengthSid(pSid);

                pDestCitrixInfo->ProcessSid = NULL;
                if ( NT_SUCCESS(RtlCopySid(SizeOfSid, pDest, pSid) ) )
                {
                    pDestCitrixInfo->ProcessSid = (PSID)((ULONG_PTR)pDest - (ULONG_PTR)pProcessBuffer);
                    pDest += SizeOfSid;
                }
            }

            pDestCitrixInfo->Pad = 0;

            //
            // Copy the image file name
            //
            if ((pSrcProcessInfo->ImageName.Buffer != NULL) && (pSrcProcessInfo->ImageName.Length != 0) )
            {
                memcpy(pDest, pSrcProcessInfo->ImageName.Buffer, pSrcProcessInfo->ImageName.Length);
                pDestProcessInfo->ImageName.Buffer = (PWSTR) ((ULONG_PTR)pDest - (ULONG_PTR)pProcessBuffer);
                pDestProcessInfo->ImageName.Length = pSrcProcessInfo->ImageName.Length;
                pDest += (pSrcProcessInfo->ImageName.Length);
                memcpy(pDest,L"\0",sizeof(WCHAR));
                pDest += sizeof(WCHAR);
            }
            else
            {
                pDestProcessInfo->ImageName.Buffer = NULL;
                pDestProcessInfo->ImageName.Length = 0;
            }

            //
            // loop...
            //
            if( pSrcProcessInfo->NextEntryOffset == 0 )
            {
                pDestProcessInfo->NextEntryOffset = 0;
                break;
            }

            pDestProcessInfo->NextEntryOffset =
                (ULONG)((ULONG_PTR)pDest - (ULONG_PTR)pDestProcessInfo);

            pDestProcessInfo = (PSYSTEM_PROCESS_INFORMATION)pDest;

            TotalOffset += pSrcProcessInfo->NextEntryOffset;
            pSrcProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&pSrcProcessBuffer[TotalOffset];
            pSrc = (PBYTE)pSrcProcessInfo;
        }
    }

    if (Status != STATUS_CANNOT_IMPERSONATE)
        RevertToSelf();

    RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
    MemFree(pSrcProcessBuffer);
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
#else

    *pResult = STATUS_NOT_SUPPORTED;
    return FALSE;
#endif
}


/*******************************************************************************
 * AllocateGAPPointer
 ******************************************************************************/
void __RPC_FAR * __RPC_USER
AllocateGAPPointer( size_t Size )
{
    void __RPC_FAR * pMyPointer;

    pMyPointer = MIDL_user_allocate(Size);
    if (pMyPointer != NULL)
    {
        if (gbRpcGetAllProcessesOK == TRUE)
        {
            //
            // store the pointer in our database
            // so that the RPC server stub do not try to free them.
            //
            if (!NT_SUCCESS(InsertPointerInGAPDatabase(pMyPointer)))
            {
                MIDL_user_free(pMyPointer);
                pMyPointer = NULL;
            }
        }
        else    // nothing can be done
        {
            MIDL_user_free(pMyPointer);
            pMyPointer = NULL;
        }
    }
    return pMyPointer;
}


//********************************************************************************
//
//      Functions used to handle the memory allocations and de-allocations
//      in RpcWinStationGetAllProcesses (GAP = Get All Processes)
//
//********************************************************************************
NTSTATUS
InitializeGAPPointersDatabase()
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
    {
        gPointersDatabaseSize = MIN_GAP_DATABASE_SIZE;
        gPointersDatabase = MemAlloc(MIN_GAP_DATABASE_SIZE * sizeof(PVOID));

        if (gPointersDatabase == NULL)
        {
            Status = STATUS_NO_MEMORY;
        }
        else
        {
            RtlZeroMemory(gPointersDatabase,MIN_GAP_DATABASE_SIZE * sizeof(PVOID));
        }

        gNbProcesses = 0;
        gbPointersDatabaseIsValid = FALSE;
    }
    RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);

    return Status;
}


NTSTATUS
IncreaseGAPPointersDatabaseSize()
{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID   *NewPointersDatabase;

    NewPointersDatabase = MemAlloc(gPointersDatabaseSize * 2 * sizeof(PVOID));

    if (NewPointersDatabase == NULL)
    {
        Status = STATUS_NO_MEMORY;
    }
    else
    {
        RtlCopyMemory(NewPointersDatabase,
                      gPointersDatabase,
                      gPointersDatabaseSize * sizeof(PVOID));
        RtlZeroMemory(&NewPointersDatabase[gPointersDatabaseSize],
                      gPointersDatabaseSize * sizeof(PVOID));

        MemFree(gPointersDatabase);
        gPointersDatabase = NewPointersDatabase;
        gPointersDatabaseSize = gPointersDatabaseSize * 2;
    }

    return Status;
}


NTSTATUS
InsertPointerInGAPDatabase(PVOID Pointer)
{
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

//    DBGPRINT(("TERMSRV: InsertPointerInGAPDatabase 0x%x\n",Pointer));

    RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
    {
        for (i=0; i < gPointersDatabaseSize; i++)
        {
            if (gPointersDatabase[i] == NULL)
            {
                gPointersDatabase[i] = Pointer;
                break;
            }
        }
        if (i == gPointersDatabaseSize)
        {
            Status = IncreaseGAPPointersDatabaseSize();
            if (NT_SUCCESS(Status))
            {
                gPointersDatabase[i] = Pointer;
            }
        }
    }
    RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);
    return Status;
}


VOID
ReleaseGAPPointersDatabase()
{
    PTS_ALL_PROCESSES_INFO_NT6  pProcessArray;
    ULONG   i;

    if (gPointersDatabase != NULL)
    {
        RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
        {
            //
            // free all the "autonomic" pointers
            //

            // the first one is ProcessArray
            if ((gPointersDatabase[0] != NULL) && (gNbProcesses != 0))
            {
                pProcessArray = (PTS_ALL_PROCESSES_INFO_NT6) gPointersDatabase[0];

                //
                //  free the Process Info buffer
                //
                if (pProcessArray[0].pTsProcessInfo != NULL)
                {
                    LocalFree(pProcessArray[0].pTsProcessInfo);
                }

                //
                //  free all the SIDs
                //
                for (i=0; i < gNbProcesses ; i++)
                {
                    if (pProcessArray[i].pSid != NULL)
                    {
                        LocalFree(pProcessArray[i].pSid);
                    }
                }
                //
                //  free the returned array
                //
                LocalFree(pProcessArray);
            }

            //
            //  free the database
            //
            MemFree(gPointersDatabase);
            gPointersDatabase = NULL;
            gNbProcesses = 0;
            //
            //  disable the checking
            //
            gbPointersDatabaseIsValid = FALSE;
        }
        RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);
    }
}


BOOLEAN
PointerIsInGAPDatabase(PVOID Pointer)
{
    ULONG   i;
    BOOLEAN bRet = FALSE;

    // spend time only if necessary
    if ((Pointer != NULL)
            && (gbRpcGetAllProcessesOK == TRUE)
            && (gbPointersDatabaseIsValid == TRUE)
            )
    {
        RtlEnterCriticalSection(&gRpcPointersDatabaseLock);
        {
            // we need to check because the database may have been released
            // while we were waiting for the lock
            if (gPointersDatabase != NULL)
            {
                for (i=0; i < gPointersDatabaseSize; i++)
                {
                    if (gPointersDatabase[i] == Pointer)
                    {
                        bRet = TRUE;
                        break;
                    }
                }
            }
        }
        RtlLeaveCriticalSection(&gRpcPointersDatabaseLock);
    }

    return bRet;
}


VOID
ValidateGAPPointersDatabase(ULONG n)
{
    gbPointersDatabaseIsValid = TRUE;
    gNbProcesses = n;
}


/*******************************************************************************
 *  SidCacheAdd
 *
 *  NOTE: Do not call with GAP allocated, or otherwise controlled pointers.
 ******************************************************************************/
VOID
SidCacheAdd(
        HANDLE          UniqueProcessId,
        LARGE_INTEGER   CreateTime,
        PSID            pNewSid
        )
{
    DWORD                   SidLength;
    NTSTATUS                Status;
    PLIST_ENTRY             pNewListEntry;
    PSID_CACHE_LIST_ENTRY   pNewCacheRecord;
    PSID                    pSid;

    //
    //  If the lock didn't initialize, bail.
    //
    if (!gbRpcSidCacheOK) {
        return;
    }

    //
    //  Initialize memory for cache record. Failure is not a problem;
    //  the sid just won't be cached.
    //
    pNewCacheRecord = MemAlloc(sizeof(SID_CACHE_LIST_ENTRY));
    if (pNewCacheRecord == NULL) {
        return;
    }

    pNewCacheRecord->pSid = pNewSid;
    pNewCacheRecord->ProcId = UniqueProcessId;
    pNewCacheRecord->CreateTime = CreateTime;
    pNewListEntry = &pNewCacheRecord->ListEntry;

    //
    //  Lock the Sid Cache and add the new member.
    //
    RtlEnterCriticalSection(&gRpcSidCacheLock);
    InsertTailList(&gSidCacheHead, pNewListEntry);

    gMaxSidCacheEntries++;
    RtlLeaveCriticalSection(&gRpcSidCacheLock);
}


/*******************************************************************************
 *
 *  SidCacheFind
 *
 *  NOTE: Use RtlLengthSid, alloc memory, and RtlCopySid for the return value!
 *        Otherwise, you may free memory being used by the Cache!!
 *
 ******************************************************************************/
PSID
SidCacheFind(
    HANDLE          UniqueProcessId,
    LARGE_INTEGER   CreateTime
    )
{
    PLIST_ENTRY             pTempEntry;
    PSID_CACHE_LIST_ENTRY   pSidCacheEntry;
    PSID                    pRetSid = NULL;

    //
    //  If the lock didn't initialize, bail.
    //
    if (!gbRpcSidCacheOK) {
        return(NULL);
    }

    //
    //  Lock the Sid Cache.
    //
    RtlEnterCriticalSection(&gRpcSidCacheLock);

    //
    //  The list head is a place holder, start searching from the head's
    //  Flink. Stop when we reach the list head again.
    //
    pTempEntry = gSidCacheHead.Flink;

    while(pTempEntry != &gSidCacheHead) {
        pSidCacheEntry = CONTAINING_RECORD(
                            pTempEntry,
                            SID_CACHE_LIST_ENTRY,
                            ListEntry
                            );

        if (pSidCacheEntry->ProcId != UniqueProcessId) {
            pTempEntry = pTempEntry->Flink;
        } else {
            if (pSidCacheEntry->CreateTime.QuadPart == CreateTime.QuadPart) {
                pRetSid = pSidCacheEntry->pSid;
            } else {
                //
                //  If the PID matches, but the create time doesn't, this record is
                //  stale. Remove it from the list and free the memory associated with
                //  it. There can only be one entry in the cache per PID, therefore,
                //  stop searching after freeing.
                //
                RemoveEntryList(pTempEntry);
                if (pSidCacheEntry->pSid != NULL) {
                    MemFree(pSidCacheEntry->pSid);
                }
                MemFree(pSidCacheEntry);
            }
            break;
        }
    }

    //
    //  Release the Sid Cache.
    //
    RtlLeaveCriticalSection(&gRpcSidCacheLock);
    return(pRetSid);
}


/*******************************************************************************
 *
 *  SidCacheFree
 *
 *
 ******************************************************************************/
VOID
SidCacheFree(
    PLIST_ENTRY pListHead
    )
{
    PLIST_ENTRY pTempEntry = pListHead->Flink;

    //
    //  Lock the Sid Cache.
    //

    RtlEnterCriticalSection(&gRpcSidCacheLock);


    //
    //  The list head is a place holder, start freeing from the head's
    //  Flink. Stop when we reach the list head again.
    //

    while (pTempEntry != pListHead) {
        PSID_CACHE_LIST_ENTRY pSidCacheEntry;
        pSidCacheEntry = CONTAINING_RECORD(
                            pTempEntry,
                            SID_CACHE_LIST_ENTRY,
                            ListEntry
                            );

        if (pSidCacheEntry->pSid != NULL) {
            MemFree(pSidCacheEntry->pSid);
        }


        RemoveEntryList(pTempEntry);
        pTempEntry = pTempEntry->Flink;
        MemFree(pSidCacheEntry);

    }

    //
    //  Release the Sid Cache.
    //

    RtlLeaveCriticalSection(&gRpcSidCacheLock);
}

/*******************************************************************************
 *
 *  SidCacheUpdate
 *
 *
 ******************************************************************************/
VOID
SidCacheUpdate(
    VOID
    )
{

    //
    //  TODO: Figure out a way to get rid of stale cache entries!
    //

}

/*******************************************************************************
 *
 *    GetSidFromProcessId
 *
 *  NOTE: GetSid returns a normal, local memory pointer. The caller should
 *        copy this sid based on its needs. For example, RpcWinStationGAP
 *        would copy this sid to a GAP pointer. The caller should NOT free
 *        the returned pointer, as it is also being cached!
 *
 ******************************************************************************/
NTSTATUS
GetSidFromProcessId(
    HANDLE          UniqueProcessId,
    LARGE_INTEGER   CreateTime,
    PSID            *ppProcessSid,
    BOOLEAN         ImpersonatingClient
    )
{
    BOOLEAN             bResult = FALSE;
    DWORD               ReturnLength;
    DWORD               BufferLength;
    DWORD               SidLength;
    PSID                pSid;
    NTSTATUS            Status;
    PTOKEN_USER         pTokenUser = NULL;
    HANDLE              hProcess = NULL;
    HANDLE              hToken;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    CLIENT_ID           ClientId;
    KERNEL_USER_TIMES   TimeInfo;
    BOOLEAN             ImpersonateAgain = FALSE;
    RPC_STATUS          RpcStatus;

    //
    //  Look in sid cache first. Do it only for Admins.
    //

    if ( IsCallerAdmin() ) {
        *ppProcessSid = SidCacheFind(UniqueProcessId, CreateTime);
        if (*ppProcessSid != NULL) {
            return(STATUS_SUCCESS);
        }
    }

    //
    //  Take the long road...
    //  Get the Process Handle
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0,
        NULL,
        NULL
        );
    ClientId.UniqueThread = (HANDLE)NULL;
    ClientId.UniqueProcess = (HANDLE)UniqueProcessId;

    // For Admins, we revert to system context before getting the SID.
    // This is a hack. Ideally, process ACLs should have been set appropriately. 
    if ( ImpersonatingClient && IsCallerAdmin() ) {
        RpcStatus = RpcRevertToSelf();

        if (RpcStatus == RPC_S_OK) {
            ImpersonateAgain = TRUE;
        }
    }

    // This should now pass. If not, then this is not a permission issue.
    Status = NtOpenProcess(
                &hProcess,
                PROCESS_QUERY_INFORMATION,
                &ObjectAttributes,
                &ClientId
                );

    if (NT_SUCCESS(Status)) {

        //
        //  Get the Process CreateTime information
        //

        Status = NtQueryInformationProcess(
                    hProcess,
                    ProcessTimes,
                    (PVOID)&TimeInfo,
                    sizeof(TimeInfo),
                    NULL
                    );

        //
        //  Verify that the passed in PID and CreateTime match
        //  the current environment (i.e. don't bother getting
        //  information on a stale PID).
        //

        if (NT_SUCCESS(Status)) {
            if ((TimeInfo.CreateTime.LowPart != CreateTime.LowPart) ||
                (TimeInfo.CreateTime.HighPart != CreateTime.HighPart)) {
                CloseHandle(hProcess);
                Status = STATUS_INVALID_HANDLE;
                goto ReturnStatus;
            }
        } else {
            CloseHandle(hProcess);
            goto ReturnStatus;
        }

        //
        //  Get the Process Token
        //

        Status = NtOpenProcessToken(
                    hProcess,
                    TOKEN_QUERY,
                    &hToken
                    );

        if (NT_SUCCESS(Status)) {

            //
            //  Query the TokenUser size, then allocate space
            //  and re-query.
            //

            Status = NtQueryInformationToken(
                         hToken,
                         TokenUser,
                         NULL,
                         0,
                         &ReturnLength
                         );

            if (ReturnLength == 0) {
                CloseHandle(hProcess);
                CloseHandle(hToken);
                goto ReturnStatus;
            }

            BufferLength = ReturnLength;
            pTokenUser = MemAlloc(BufferLength);
            if( pTokenUser == NULL ) {
                CloseHandle(hProcess);
                CloseHandle(hToken);
                Status = STATUS_NO_MEMORY;
                goto ReturnStatus;
            }

            Status = NtQueryInformationToken(
                         hToken,
                         TokenUser,
                         pTokenUser,
                         BufferLength,
                         &ReturnLength
                         );

            CloseHandle(hToken);

            if (NT_SUCCESS(Status)) {

                //
                //  A valid Sid has been found; copy it and add it to
                //  the cache.
                //

                SidLength = RtlLengthSid(pTokenUser->User.Sid);
                pSid = MemAlloc(SidLength);

                if (pSid != NULL) {
                    Status = RtlCopySid(
                                SidLength,
                                pSid,
                                pTokenUser->User.Sid
                                );

                    if (NT_SUCCESS(Status)) {
                        *ppProcessSid = pSid;
                        bResult = TRUE;
                        SidCacheAdd(UniqueProcessId, CreateTime, pSid);
                    }
                } else {
                    Status = STATUS_NO_MEMORY;
                }
            }
            MemFree(pTokenUser);
        }
        CloseHandle(hProcess);
    }

ReturnStatus:
    if (ImpersonateAgain) {
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK )
            Status = STATUS_CANNOT_IMPERSONATE;
    }

    return(Status);
}


VOID
CheckSidCacheSize()

{

    // if cache has grown over limit, free all the entries
    // and reset the cache entries counter

    if (gMaxSidCacheEntries >= MAX_SID_CACHE_ENTRIES) {
        SidCacheFree(&gSidCacheHead);
        InitializeListHead(&gSidCacheHead);
        gMaxSidCacheEntries = 0;

    }

}

//
// This function converts sys buffer to ts buffer. also counts the processes, and returns array procids.
// CALLER NEED TO LocalFree the *ppProcIds, thats allocaed.
NTSTATUS ConvertSysBufferToTSBuffer(PBYTE *ppSysProcessBuffer, DWORD ByteCount, ULONG *pProcesses, PHANDLE *ppProcIds)
{
    PBYTE                       pTSProcessBuffer = NULL;
    PSYSTEM_PROCESS_INFORMATION pSysProcessInfo  = NULL;
    PTS_SYS_PROCESS_INFORMATION_NT6 pTSProcessInfo   = NULL;
    ULONG                       TotalOffset      = 0;
    ULONG                       TotalTSOffset    = 0;
    ULONG                       TotalTmpOffset   = 0;
    ULONG                       CurrentOffset    = 0;
    ULONG                       CurrentSessionId = INVALID_SESSIONID;
    HANDLE                      *pProcessIds     = NULL;
    UINT                        uiNumProcess     = 0;
    NTSTATUS                    Status;
    PWINSTATION                 pWinStation = NULL;

    ASSERT(ppSysProcessBuffer);
    ASSERT(*ppSysProcessBuffer);
    ASSERT(ByteCount);
    ASSERT(pProcesses);
    ASSERT(ppProcIds);
 
    // allocate target buffer.
    pTSProcessBuffer = MIDL_user_allocate(ByteCount);

    if (pTSProcessBuffer == NULL)
    {
        *ppProcIds = NULL;
        *pProcesses = 0;
        return STATUS_NO_MEMORY;
    }

    
    uiNumProcess = 0;
    TotalOffset = 0;
    
    //count number of processes
    do
    {
        ASSERT(TotalOffset < ByteCount);
        pSysProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &((*ppSysProcessBuffer)[TotalOffset]);
        TotalOffset += pSysProcessInfo->NextEntryOffset;
        uiNumProcess++;
    }
    while (pSysProcessInfo->NextEntryOffset != 0);
    
    // allocate memory for  process ids.
    pProcessIds = LocalAlloc(LMEM_FIXED, sizeof(HANDLE) * uiNumProcess);

    if (!pProcessIds)
    {
        MIDL_user_free(pTSProcessBuffer);
        *ppProcIds = NULL;
        *pProcesses = 0;
        return STATUS_NO_MEMORY;
    }

    uiNumProcess = 0;
    TotalOffset = 0;
    TotalTSOffset = 0;

    do
    {
        ASSERT(TotalOffset < ByteCount);
        pSysProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &((*ppSysProcessBuffer)[TotalOffset]);
        CurrentSessionId = pSysProcessInfo->SessionId;

        if(CurrentSessionId == INVALID_SESSIONID)
        {
            TotalOffset += pSysProcessInfo->NextEntryOffset;
            CurrentOffset = pSysProcessInfo->NextEntryOffset;
            continue;
        }

        /*
         * Find and lock client WinStation
         */
        pWinStation = FindWinStationById( CurrentSessionId, FALSE );
        if ( pWinStation == NULL ) 
        {
            //
            //The session this process belongs to, might already be gone.
            //Don't fail here, just skip the process.
            //
            pSysProcessInfo->SessionId = INVALID_SESSIONID;
            TotalOffset += pSysProcessInfo->NextEntryOffset;
            CurrentOffset = pSysProcessInfo->NextEntryOffset;
            continue;
        }

        Status = RpcCheckClientAccess( pWinStation, WINSTATION_QUERY, TRUE );
        
        ReleaseWinStation( pWinStation );
        
        TotalTmpOffset = TotalOffset;
        TotalOffset += pSysProcessInfo->NextEntryOffset;
        CurrentOffset = pSysProcessInfo->NextEntryOffset;

        do
        {
            pSysProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &((*ppSysProcessBuffer)[TotalTmpOffset]);

            if(pSysProcessInfo->SessionId != CurrentSessionId)
            {
                TotalTmpOffset += pSysProcessInfo->NextEntryOffset;
                continue;
            }

            if ( NT_SUCCESS( Status ) )
            {
                pTSProcessInfo  = (PTS_SYS_PROCESS_INFORMATION_NT6)&(pTSProcessBuffer[TotalTSOffset]);

                // now copy the information over.
                /* ULONG */ pTSProcessInfo->NextEntryOffset = sizeof(TS_SYS_PROCESS_INFORMATION_NT6) + 
                                pSysProcessInfo->ImageName.MaximumLength;//pSysProcessInfo->NextEntryOffset;
                /* ULONG */ pTSProcessInfo->NumberOfThreads = pSysProcessInfo->NumberOfThreads;
                /* LARGE_INTEGER */ pTSProcessInfo->SpareLi1 = pSysProcessInfo->SpareLi1;
                /* LARGE_INTEGER */ pTSProcessInfo->SpareLi2 = pSysProcessInfo->SpareLi2;
                /* LARGE_INTEGER */ pTSProcessInfo->SpareLi3 = pSysProcessInfo->SpareLi3;
                /* LARGE_INTEGER */ pTSProcessInfo->CreateTime = pSysProcessInfo->CreateTime;
                /* LARGE_INTEGER */ pTSProcessInfo->UserTime = pSysProcessInfo->UserTime;
                /* LARGE_INTEGER */ pTSProcessInfo->KernelTime = pSysProcessInfo->KernelTime;

                if (pSysProcessInfo->ImageName.Buffer != NULL && pSysProcessInfo->ImageName.Length != 0)
                {
                    pTSProcessInfo->ImageName.Buffer = (PWSTR)((PBYTE)pTSProcessInfo + sizeof(TS_SYS_PROCESS_INFORMATION_NT6));
                    memcpy(pTSProcessInfo->ImageName.Buffer, pSysProcessInfo->ImageName.Buffer, pSysProcessInfo->ImageName.MaximumLength );            
                    pTSProcessInfo->ImageName.Length = pSysProcessInfo->ImageName.Length;
                    pTSProcessInfo->ImageName.MaximumLength = pSysProcessInfo->ImageName.MaximumLength;
                }
                else
                {
                    pTSProcessInfo->ImageName.Buffer = NULL;
                    pTSProcessInfo->ImageName.Length = 0;
                }

                /* KPRIORITY */ pTSProcessInfo->BasePriority = pSysProcessInfo->BasePriority;
                /* HANDLE */ pTSProcessInfo->UniqueProcessId = HandleToULong(pSysProcessInfo->UniqueProcessId);
                /* HANDLE */ pTSProcessInfo->InheritedFromUniqueProcessId = HandleToULong(pSysProcessInfo->InheritedFromUniqueProcessId);
                /* ULONG */ pTSProcessInfo->HandleCount = pSysProcessInfo->HandleCount;
                /* ULONG */ pTSProcessInfo->SessionId = pSysProcessInfo->SessionId;
                // /* ULONG_PTR */ pTSProcessInfo->PageDirectoryBase = pSysProcessInfo->PageDirectoryBase;
                /* SIZE_T */ pTSProcessInfo->PeakVirtualSize = pSysProcessInfo->PeakVirtualSize;
                /* SIZE_T */ pTSProcessInfo->VirtualSize = pSysProcessInfo->VirtualSize;
                /* ULONG */ pTSProcessInfo->PageFaultCount = pSysProcessInfo->PageFaultCount;
                /* SIZE_T */ pTSProcessInfo->PeakWorkingSetSize =  (ULONG)pSysProcessInfo->PeakWorkingSetSize;
                /* SIZE_T */ pTSProcessInfo->WorkingSetSize = (ULONG)pSysProcessInfo->WorkingSetSize;
                /* SIZE_T */ pTSProcessInfo->QuotaPeakPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaPeakPagedPoolUsage;
                /* SIZE_T */ pTSProcessInfo->QuotaPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaPagedPoolUsage;
                /* SIZE_T */ pTSProcessInfo->QuotaPeakNonPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaPeakNonPagedPoolUsage;
                /* SIZE_T */ pTSProcessInfo->QuotaNonPagedPoolUsage = (ULONG)pSysProcessInfo->QuotaNonPagedPoolUsage;
                /* SIZE_T */ pTSProcessInfo->PagefileUsage = (ULONG)pSysProcessInfo->PagefileUsage;
                /* SIZE_T */ pTSProcessInfo->PeakPagefileUsage = (ULONG)pSysProcessInfo->PeakPagefileUsage;
                /* SIZE_T */ pTSProcessInfo->PrivatePageCount = (ULONG)pSysProcessInfo->PrivatePageCount;
            
                //
                // now keep the original pid form the original buffer, 
                //we have lost some data while converting it to ts format.
                pProcessIds[uiNumProcess] =  pSysProcessInfo->UniqueProcessId;
                TotalTSOffset += pTSProcessInfo->NextEntryOffset;
                uiNumProcess++;
            }
            
            pSysProcessInfo->SessionId = INVALID_SESSIONID;
            TotalTmpOffset += pSysProcessInfo->NextEntryOffset;
        }
        while (pSysProcessInfo->NextEntryOffset != 0);

    }
    while (CurrentOffset != 0);

    if ( !uiNumProcess ) 
    {
        LocalFree(pProcessIds);
        MIDL_user_free(pTSProcessBuffer);
        *ppProcIds = NULL;
        *pProcesses = 0;
        return STATUS_ACCESS_DENIED;
    }

    // now lets get rid of the original buffer, and replace it with our new TS process buffer
    LocalFree(*ppSysProcessBuffer);

    *ppProcIds          = pProcessIds;
    *pProcesses         = uiNumProcess;
    *ppSysProcessBuffer = pTSProcessBuffer;
    
    return STATUS_SUCCESS;
}


/***********************************************************************************************************
 *  WinStationGetAllProcessesWorker
 *
 *    Worker routine for RpcWinStationGetAllProcesses(Win2K) and RpcWinStationGetAllProcesses_NT6(Whistler).
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 ***********************************************************************************************************/
BOOLEAN
WinStationGetAllProcessesWorker(
        HANDLE  hServer,
        DWORD   *pResult,
        ULONG   Level,
        ULONG   *pNumberOfProcesses,
        PBYTE   *ppTsAllProcessesInfo
        )
{
    PTS_SYS_PROCESS_INFORMATION_NT6 pProcessInfo = NULL;
    PTS_ALL_PROCESSES_INFO_NT6 pProcessArray = NULL;

    ULONG   TotalOffset;
    ULONG   NumberOfProcesses = 1;  // at least 1 process
    ULONG i;
    RPC_STATUS RpcStatus;
    NTSTATUS    Status = STATUS_INFO_LENGTH_MISMATCH;       // Assume that this length is wrong. In fact it *is* wrong initially.

    if (gbRpcGetAllProcessesOK == FALSE)
    {
        *pResult = STATUS_NO_MEMORY;
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
        return FALSE;
    }
    
    //
    //  this critical section will be released in
    //  RpcWinStationGetAllProcesses_notify_flag
    //
    RtlEnterCriticalSection(&gRpcGetAllProcessesLock);

    RpcStatus = RpcImpersonateClient( NULL );
    
    if( RpcStatus != RPC_S_OK ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: WinStationGetAllProcessesWorker RpcImpersonateClient failed! %d\n",RpcStatus));
        *pResult = STATUS_ACCESS_DENIED;
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
        return FALSE;
    }

    // Check if SID cache hasn't grown too much

    CheckSidCacheSize();


    if (!NT_SUCCESS(InitializeGAPPointersDatabase()))
    {
        RpcRevertToSelf();
        *pResult = STATUS_NO_MEMORY;
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
        return FALSE;
    }

    //
    //  make sure requested information level is known
    //
    if (Level != GAP_LEVEL_BASIC)     // only info level known on this version
    {
        *pResult = STATUS_NOT_IMPLEMENTED;
    }
    else        // OK
    {
        PBYTE       pProcessBuffer = NULL;
        PSID        pSid;
        DWORD       RequiredByteCount = 0;
        DWORD       ByteCount = (MAX_PATH*sizeof(WCHAR)) + 1;   // Give the minimum length first. We will get the correct on subsequent calls.
        HANDLE      *pProcessids = NULL;

        while ( Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            //  Allocate a buffer
            //
            pProcessBuffer = MIDL_user_allocate(ByteCount);

            if (pProcessBuffer == NULL)
            {
                Status = STATUS_NO_MEMORY;
                *pResult = STATUS_NO_MEMORY;
                *pNumberOfProcesses = 0;
                *ppTsAllProcessesInfo = NULL;
                break;
            }

            //
            //  Perform process enumeration.
            //  NOTE: We had a mismatch in the structure for the process information in Win2K and whistler from RPC point of view.
            //  Win2K RPC interpretes the size of the image name is twice of what whistler does. So, to take care of this problem,
            //  where Win2K client may call Whistler server, we will allocate more bytes than actually required. So, we will pass
            //  less number of bytes to the system call by the same amount.
            //
            Status = NtQuerySystemInformation( SystemProcessInformation,
                                                 (PVOID)pProcessBuffer,
                                                 ByteCount - (MAX_PATH*sizeof(WCHAR)),
                                                 &RequiredByteCount );
            if (Status == STATUS_INFO_LENGTH_MISMATCH)
            {
                // Allocate little more bytes than required.
                ByteCount = RequiredByteCount + (MAX_PATH*sizeof(WCHAR));
                MIDL_user_free(pProcessBuffer);
            }
        }
        
        if ( Status != STATUS_SUCCESS)
        {
            *pResult = STATUS_NO_MEMORY;
            if (pProcessBuffer != NULL)
            {
                MIDL_user_free(pProcessBuffer);
                pProcessBuffer = NULL;
            }
        }
        else
        {
            Status = ConvertSysBufferToTSBuffer(&pProcessBuffer, ByteCount, &NumberOfProcesses, &pProcessids);

            if (Status != STATUS_SUCCESS)
            {
                // failed to convert sysbuffer to ts buffer.
                // lets bail out.
                *pResult = Status;
                if (pProcessBuffer != NULL)
                {
                    MIDL_user_free(pProcessBuffer);
                    pProcessBuffer = NULL;
                }
            }
            else    // everything's fine
            {
                ASSERT(pProcessids);
                ASSERT(pProcessBuffer);
                ASSERT(NumberOfProcesses > 0);


                pProcessArray = AllocateGAPPointer(NumberOfProcesses * sizeof(TS_ALL_PROCESSES_INFO_NT6));

                if (pProcessArray == NULL)
                {
                    *pResult = STATUS_NO_MEMORY;
                    MIDL_user_free(pProcessBuffer);
                    pProcessBuffer = NULL;
                }
                else
                {

                    RtlZeroMemory(pProcessArray,
                                  NumberOfProcesses * sizeof(TS_ALL_PROCESSES_INFO_NT6));
                    *pResult = STATUS_SUCCESS;
                    pProcessInfo = (PTS_SYS_PROCESS_INFORMATION_NT6)pProcessBuffer;
                    TotalOffset = 0;

                    //
                    // Walk the returned buffer again to set the correct pointers in pProcessArray
                    //
                    for (i=0; i < NumberOfProcesses; i++)
                    {
                        pProcessArray[i].pTsProcessInfo = (PTS_SYS_PROCESS_INFORMATION_NT6)pProcessInfo;

                        //
                        // keep some trace of the "internal" pointers
                        // so that the RPC server stub do not try to free them.
                        //

                        if (!NT_SUCCESS(InsertPointerInGAPDatabase(pProcessArray[i].pTsProcessInfo)))
                        {
                            *pResult = STATUS_NO_MEMORY;
                            break;
                        }

                        if ( pProcessInfo->ImageName.Buffer )
                        {
                            if (!NT_SUCCESS(InsertPointerInGAPDatabase(pProcessInfo->ImageName.Buffer)))
                            {
                                *pResult = STATUS_NO_MEMORY;
                                break;
                            }
                        }

                        //
                        //  Get the Sid
                        //
                        Status = GetSidFromProcessId(
                                        pProcessids[i],
                                        pProcessInfo->CreateTime,
                                        &pSid,
                                        TRUE
                                        );

                        if (Status == STATUS_CANNOT_IMPERSONATE)
                        {
                            *pResult = STATUS_ACCESS_DENIED;
                            break;
                        }

                        if (NT_SUCCESS(Status))
                        {
                            //
                            // set the length for the Sid
                            //
                            pProcessArray[i].SizeOfSid = RtlLengthSid(pSid);
                            // GAP allocate a pointer and copy!
                            pProcessArray[i].pSid = AllocateGAPPointer(
                                                        pProcessArray[i].SizeOfSid
                                                        );
                            if (pProcessArray[i].pSid == NULL) {
                                *pResult = STATUS_NO_MEMORY;
                                break;
                            }

                            *pResult = RtlCopySid(
                                        pProcessArray[i].SizeOfSid,
                                        pProcessArray[i].pSid,
                                        pSid
                                        );
                            if (!(NT_SUCCESS(*pResult))) {
                                break;
                            }


                        }
                        else
                        {
                            //
                            // set a NULL Sid
                            //
                            pProcessArray[i].pSid = NULL;
                            pProcessArray[i].SizeOfSid = 0;
                        }
                        //
                        // next entry
                        //

                        TotalOffset += pProcessInfo->NextEntryOffset;

                    
                        pProcessInfo = (PTS_SYS_PROCESS_INFORMATION_NT6)&pProcessBuffer[TotalOffset];

                    
                    }
                
                    if (*pResult != STATUS_SUCCESS) // we finally failed !
                    {
    //                    DBGPRINT(( "TERMSRV: RpcWinStationGAP: ultimate failure\n"));

                        //
                        //  free all SIDs
                        //
                        for (i=0; i < NumberOfProcesses; i++)
                        {
                            if (pProcessArray[i].pSid != NULL)
                            {
                                LocalFree(pProcessArray[i].pSid);
                            }
                        }
                        //
                        //  free the array
                        //
                        LocalFree(pProcessArray);
                        pProcessArray = NULL;
                        //
                        //  free the buffer
                        //
                        MIDL_user_free(pProcessBuffer);
                        pProcessBuffer = NULL;
                    }
                }

                if (pProcessids)
                    LocalFree(pProcessids);

            }
        }
    }

    if (NT_SUCCESS(*pResult))
    {
//        DBGPRINT(( "TERMSRV: RpcWinStationGAP: Everything went fine\n"));

        //
        //  From that moment, we may receive some MIDL_user_free
        //  so enable the database checking
        //
        ValidateGAPPointersDatabase(NumberOfProcesses);

        *pNumberOfProcesses = NumberOfProcesses;
        *ppTsAllProcessesInfo = (PBYTE) pProcessArray;
    
    }
    else    // error case
    {
        *pNumberOfProcesses = 0;
        *ppTsAllProcessesInfo = NULL;
    }

    if (Status != STATUS_CANNOT_IMPERSONATE)
        RpcRevertToSelf();

    return ( (NT_SUCCESS(*pResult))? TRUE : FALSE);
}


/*******************************************************************************
 *  RpcWinStationGetAllProcesses_NT6
 *
 *    Replaces RpcWinStationGetAllProcesses for Win2K servers.
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationGetAllProcesses_NT6(
        HANDLE  hServer,
        DWORD   *pResult,
        ULONG   Level,
        ULONG   *pNumberOfProcesses,
        PTS_ALL_PROCESSES_INFO_NT6  *ppTsAllProcessesInfo
        )
{
    BOOLEAN Result;
    PTS_ALL_PROCESSES_INFO_NT6  pProcessInfo;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    Result = WinStationGetAllProcessesWorker(
        hServer, 
        pResult, 
        Level, 
        pNumberOfProcesses,
        (PBYTE *)&pProcessInfo
        );

    *ppTsAllProcessesInfo = pProcessInfo;

    return Result;
}



/*******************************************************************************
 *
 *  RpcWinStationGetAllProcesses
 *
 *    Replaces RpcWinStationEnumerateProcesses for NT5.0 servers.
 *      (Now used only by winsta client of Win2K)
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationGetAllProcesses(
    HANDLE  hServer,
    DWORD   *pResult,
    ULONG   Level,
    ULONG   *pNumberOfProcesses,
    PTS_ALL_PROCESSES_INFO  *ppTsAllProcessesInfo
    )
{
    BOOLEAN Result;
    PTS_ALL_PROCESSES_INFO  pProcessInfo;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    Result = WinStationGetAllProcessesWorker(
        hServer, 
        pResult, 
        Level, 
        pNumberOfProcesses,
        (PBYTE *)&pProcessInfo
        );

    *ppTsAllProcessesInfo = pProcessInfo;

    return Result;
}


/*******************************************************************************
 *  RpcWinStationGetLanAdapterName
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is returned in pResult.
 ******************************************************************************/

#define RELEASEPTR(iPointer)  \
    if (iPointer) {  \
        iPointer->lpVtbl->Release(iPointer);  \
        iPointer = NULL;  \
    }

BOOLEAN RpcWinStationGetLanAdapterName(
        HANDLE  hServer,
        DWORD   *pResult,
        DWORD PdNameSize,
        PWCHAR  pPdName,
        ULONG   LanAdapter,
        ULONG   *pLength,
        PWCHAR  *ppLanAdapterName)
{
    HRESULT hResult = S_OK;
    HRESULT hr = S_OK;

    //Interface pointer declarations
    WCHAR szProtocol[256];
    INetCfg * pnetCfg = NULL;
    INetCfgClass * pNetCfgClass = NULL;
    INetCfgClass * pNetCfgClassAdapter = NULL;
    INetCfgComponent * pNetCfgComponent = NULL;
    INetCfgComponent * pNetCfgComponentprot = NULL;
    IEnumNetCfgComponent * pEnumComponent = NULL;
    INetCfgComponentBindings * pBinding = NULL;
    LPWSTR pDisplayName = NULL;
    DWORD dwCharacteristics;
    ULONG count = 0;
    RPC_STATUS RpcStatus;
    PWCHAR pLanAdapter = NULL;

    *ppLanAdapterName = NULL;
    *pLength = 0;
    *pResult = STATUS_SUCCESS;    
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    // Impersonate the client so that strings get localized
    RpcStatus = RpcImpersonateClient(NULL);
    if(RpcStatus != RPC_S_OK) 
    {
        *pResult = STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    // 0 corresponds to "All network adapters"

    if (0 == LanAdapter) {
        pLanAdapter = MIDL_user_allocate((DEVICENAME_LENGTH + 1) * sizeof(WCHAR));
        if (pLanAdapter == NULL) {
            *pResult = STATUS_NO_MEMORY;
            RpcRevertToSelf();
            goto done;
        }
        else {
            if (!LoadString(hModuleWin, STR_ALL_LAN_ADAPTERS, pLanAdapter,
                    DEVICENAME_LENGTH + 1)) {
                *pResult = STATUS_UNSUCCESSFUL;
                MIDL_user_free(pLanAdapter);
                RpcRevertToSelf();
                goto done;
            }

            *ppLanAdapterName = pLanAdapter;
            *pLength = (DEVICENAME_LENGTH + 1);
            RpcRevertToSelf();
            goto done;
        }
    }

    RpcRevertToSelf();


    try{

        NTSTATUS StringStatus ; 

        // Do some buffer validation
        // No of bytes (and not no of WCHARS) is sent from the Client, so send half the length got
        StringStatus = IsZeroterminateStringW(pPdName, PdNameSize / sizeof(WCHAR) );
        if (StringStatus != STATUS_SUCCESS) {
            *pResult = STATUS_INVALID_PARAMETER;
             goto done;
        }

        if (0 == _wcsnicmp( pPdName , L"tcp", PdNameSize/sizeof(WCHAR))) {
            lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_TCPIP);
        }
        else if( 0 == _wcsnicmp( pPdName , L"netbios", PdNameSize/sizeof(WCHAR)) ) {
            lstrcpy(szProtocol,NETCFG_SERVICE_CID_MS_NETBIOS);
        }
        else if( 0 == _wcsnicmp( pPdName , L"ipx", PdNameSize/sizeof(WCHAR)) ) {
            lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWIPX);
        }
        else if( 0 == _wcsnicmp( pPdName , L"spx", PdNameSize/sizeof(WCHAR)) ) {
            lstrcpy(szProtocol,NETCFG_TRANS_CID_MS_NWSPX);
        }
        else {
            *pResult = STATUS_INVALID_PARAMETER;
            goto done;
        }
    } except(EXCEPTION_EXECUTE_HANDLER){
       *pResult =  STATUS_INVALID_PARAMETER;
       goto done;
    }


    hResult = CoCreateInstance(&CLSID_CNetCfg, NULL, CLSCTX_SERVER,
            &IID_INetCfg, (LPVOID *)&pnetCfg);
    if (FAILED(hResult)) {
        *pResult = STATUS_UNSUCCESSFUL;
        goto done;
    }

    if (pnetCfg != NULL) {
        hResult = pnetCfg->lpVtbl->Initialize(pnetCfg,NULL );
        if (FAILED(hResult) || pnetCfg == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        if (lstrcmpi(szProtocol, NETCFG_SERVICE_CID_MS_NETBIOS) == 0) {
            hResult = pnetCfg->lpVtbl->QueryNetCfgClass(pnetCfg,
                    &GUID_DEVCLASS_NETSERVICE, &IID_INetCfgClass,
                    (void **)&pNetCfgClass);
            if (FAILED(hResult) || pNetCfgClass == NULL) {
                *pResult = STATUS_UNSUCCESSFUL;
                goto done;
            }
        }
        else {
            hResult = pnetCfg->lpVtbl->QueryNetCfgClass(pnetCfg,
                    &GUID_DEVCLASS_NETTRANS, &IID_INetCfgClass,
                    (void **)&pNetCfgClass);
            if (FAILED( hResult ) || pNetCfgClass == NULL) {
                *pResult = STATUS_UNSUCCESSFUL;
                goto done;
            }
        }

        hResult = pnetCfg->lpVtbl->QueryNetCfgClass(pnetCfg,
                &GUID_DEVCLASS_NET, &IID_INetCfgClass,
                (void **)&pNetCfgClassAdapter);
        if (FAILED( hResult ) || pNetCfgClassAdapter == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        hResult = pNetCfgClass->lpVtbl->FindComponent(pNetCfgClass,
                szProtocol, &pNetCfgComponentprot);
        if (FAILED( hResult ) || pNetCfgComponentprot == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        hResult = pNetCfgComponentprot->lpVtbl->QueryInterface(
                pNetCfgComponentprot, &IID_INetCfgComponentBindings,
                (void **)&pBinding);
        if (FAILED( hResult ) || pBinding == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        hResult = pNetCfgClassAdapter->lpVtbl->EnumComponents(
                pNetCfgClassAdapter, &pEnumComponent);

        RELEASEPTR(pNetCfgClassAdapter);

        if (FAILED( hResult ) || pEnumComponent == NULL) {
            *pResult = STATUS_UNSUCCESSFUL;
            goto done;
        }

        *pResult = STATUS_UNSUCCESSFUL;

        while(TRUE) {
            hr = pEnumComponent->lpVtbl->Next(pEnumComponent, 1,
                    &pNetCfgComponent,&count);
            if (count == 0 || NULL == pNetCfgComponent)
                break;

            hr = pNetCfgComponent->lpVtbl->GetCharacteristics(
                    pNetCfgComponent,&dwCharacteristics);
            if (FAILED(hr)) {
                RELEASEPTR(pNetCfgComponent);
                continue;
            }

            if (dwCharacteristics & NCF_PHYSICAL) {
                if (S_OK == pBinding->lpVtbl->IsBoundTo(pBinding,
                        pNetCfgComponent)) {
                    GUID guidNIC;
                    /*index++;
                    if(index == LanAdapter)
                    {
                        hResult = pNetCfgComponent->lpVtbl->GetDisplayName(pNetCfgComponent,&pLanAdapter);

                         if( FAILED( hResult ) )
                         {
                             *pResult = STATUS_UNSUCCESSFUL;
                         }
                         else
                         {
                             *ppLanAdapterName = MIDL_user_allocate((lstrlen(pLanAdapter) + 1) * sizeof(WCHAR));
                             if (*ppLanAdapterName  == NULL)
                             {
                                 *pResult = STATUS_NO_MEMORY;
                             }
                             else
                             {
                                 lstrcpy(*ppLanAdapterName,pLanAdapter);
                                 *pLength = (lstrlen(pLanAdapter) + 1);
                                 *pResult = STATUS_SUCCESS;
                             }
                             CoTaskMemFree(pLanAdapter);
                             break;
                        }
                    }
                    */

                    hResult = pNetCfgComponent->lpVtbl->GetInstanceGuid(
                            pNetCfgComponent , &guidNIC);
                    if (SUCCEEDED( hResult )) {
                        hResult = pNetCfgComponent->lpVtbl->GetDisplayName(
                                pNetCfgComponent, &pLanAdapter);
                    }
                    if (SUCCEEDED(hResult)) {
                        WCHAR wchRegKey[ MAX_PATH ];
                        WCHAR wchGUID[ 40 ];
                        HKEY hKey;

                        lstrcpy( wchRegKey , REG_GUID_TABLE );

                        // convert the 128bit value into a string
                        StringFromGUID2(&guidNIC, wchGUID,
                                sizeof( wchGUID ) / sizeof( WCHAR ));

                        // create the full regkey
                        lstrcat( wchRegKey , wchGUID );

                        // find guid in guid table
                        hResult = (HRESULT)RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                wchRegKey, 0, KEY_READ, &hKey);

                        if (hResult == ERROR_SUCCESS) {
                            DWORD dwSize = sizeof( DWORD );
                            DWORD dwLana = 0;

                            RegQueryValueEx(hKey, LANA_ID, NULL, NULL,
                                    (LPBYTE)&dwLana, &dwSize);
                            RegCloseKey(hKey);

                            // if we have a match allocate space for the lanadapter name
                            // and then lets split
                            if (LanAdapter == dwLana) {
                                *ppLanAdapterName = MIDL_user_allocate(
                                        (lstrlen(pLanAdapter) + 1) *
                                        sizeof(WCHAR));

                                if ( *ppLanAdapterName == NULL ) {
                                    *pResult = STATUS_NO_MEMORY;
                                }
                                else {
                                    lstrcpy( *ppLanAdapterName , pLanAdapter );
                                    *pLength = ( lstrlen( pLanAdapter ) + 1 );
                                    *pResult = STATUS_SUCCESS;
                                }

                                MIDL_user_free(pLanAdapter);
                                break;
                            }
                        }

                        MIDL_user_free(pLanAdapter);
                    }
                }
            }
        }

        RELEASEPTR(pNetCfgComponent);
    }


done:
    RELEASEPTR(pBinding);
    RELEASEPTR(pEnumComponent);
    RELEASEPTR(pNetCfgComponentprot);
    RELEASEPTR(pNetCfgComponent);
    RELEASEPTR(pNetCfgClass);

    if ( pnetCfg != NULL )
        pnetCfg->lpVtbl->Uninitialize(pnetCfg);

    RELEASEPTR(pnetCfg);

    CoUninitialize();

    return *pResult == STATUS_SUCCESS ? TRUE : FALSE;
}


/*******************************************************************************
 *
 *    RpcWinStationGetAllProcesses_NT6_notify_flag
 *
 *      This callback function is called by the RPC server stub at the very end
 *      (after all the calls to MIDL_user_free).
 *      This allows us to free the remaining pointers.
 *      We also release the lock so that a new RpcWinStationGetAllProcesses
 *      can be processed.
 *
 ******************************************************************************/
void RpcWinStationGetAllProcesses_NT6_notify_flag(boolean fServerCalled)
{
//    DBGPRINT(( "TERMSRV: Entering RpcWinStationGAP_notify\n"));

    if (!fServerCalled)
        return;

    if (gbRpcGetAllProcessesOK == TRUE)
    {
        //
        // free our own pointers, free the database and disable the checking
        //
        ReleaseGAPPointersDatabase();

        //
        // release the lock that has been held since we entered
        // RpcWinStationGetAllProcesses
        //
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
    }
}


/*******************************************************************************
 *
 *    RpcWinStationGetAllProcesses_notify_flag
 *
 *      This callback function is called by the RPC server stub at the very end
 *      (after all the calls to MIDL_user_free).
 *      This allows us to free the remaining pointers.
 *      We also release the lock so that a new RpcWinStationGetAllProcesses
 *      can be processed.
 *
 ******************************************************************************/
void RpcWinStationGetAllProcesses_notify_flag(boolean fServerCalled)
{
//    DBGPRINT(( "TERMSRV: Entering RpcWinStationGAP_notify\n"));

    if (!fServerCalled)
        return;

    if (gbRpcGetAllProcessesOK == TRUE)
    {
        //
        // free our own pointers, free the database and disable the checking
        //
        ReleaseGAPPointersDatabase();

        //
        // release the lock that has been held since we entered
        // RpcWinStationGetAllProcesses
        //
        RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);
    }
}


/*****************************************************************************
 *
 *  RpcWinStationGetProcessSid
 *
 *   RpcWinStationGetProcessSid API
 *
 * ENTRY:
 *   hServer           - input, The serrver handle to work on.
 *   dwUniqueProcessId - input, ProcessID (its not really unique)
 *   ProcessStartTime  - input, ProcessStartTime combined with ProcessID
 *                       identifies a unique process
 *   pResult           - output, error code
 *   pProcessUserSid   - output, process user sid
 *   dwSidSize         - input, sid size allocated.
 *
 * EXIT:
 *   TRUE   -   Requested Sid is in pProcessUserSid.
 *   FALSE  -   The operation failed. Status code is in pResult.
 *
 ****************************************************************************/
BOOLEAN RpcWinStationGetProcessSid(
        HANDLE          hServer,
        DWORD           dwUniqueProcessId,
        LARGE_INTEGER   ProcessStartTime,
        LONG            *pResult,   //  Really an NTSTATUS
        PBYTE           pProcessUserSid,
        DWORD           dwSidSize,
        DWORD           *pdwSizeNeeded)
{
    PSID pSid;
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    RpcStatus = RpcImpersonateClient( NULL );
    
    if( RpcStatus != RPC_S_OK ) {
        *pResult = STATUS_ACCESS_DENIED;
        return FALSE;
    }

    RtlEnterCriticalSection(&gRpcGetAllProcessesLock);

    // Check if SID cache hasn't grown too much
    CheckSidCacheSize();

    *pResult = GetSidFromProcessId(
                (HANDLE)(ULONG_PTR)dwUniqueProcessId,
                ProcessStartTime,
                &pSid,
                TRUE
                );

    if (NT_SUCCESS(*pResult)) {
        *pdwSizeNeeded = RtlLengthSid(pSid);

        if (*pdwSizeNeeded <= dwSidSize) {
            if (pProcessUserSid == NULL) {
                *pResult = STATUS_INVALID_PARAMETER;
            } else {
                *pResult = RtlCopySid(
                            *pdwSizeNeeded,
                            pProcessUserSid,
                            pSid
                            );
            }
        } else {
            *pResult = STATUS_BUFFER_TOO_SMALL;
        }
    } else {
        *pdwSizeNeeded = 0;
    }

    RtlLeaveCriticalSection(&gRpcGetAllProcessesLock);

    RpcRevertToSelf();

    return(*pResult == STATUS_SUCCESS ? TRUE : FALSE);
}


/*******************************************************************************
 *
 *  RpcWinStationRename
 *
 *    Renames a window station object in the session manager.
 *
 * ENTRY:
 *
 *    pWinStationNameOld (input)
 *       Old name of window station.
 *
 *    pWinStationNameNew (input)
 *       New name of window station.
 *
 *
 * EXIT:
 *
 *    TRUE  -- The rename operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationRename(
        HANDLE hServer,
        DWORD   *pResult,
        PWCHAR pWinStationNameOld,
        DWORD  NameOldSize,
        PWCHAR pWinStationNameNew,
        DWORD  NameNewSize
        )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = WinStationRenameWorker(
                   pWinStationNameOld,
                   NameOldSize,
                   pWinStationNameNew,
                   NameNewSize
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationQueryInformation
 *
 *    Queries configuration information about a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_QUERY access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationQueryInformation(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        DWORD  WinStationInformationClass,
        PCHAR  pWinStationInformation,
        DWORD  WinStationInformationLength,
        DWORD  *pReturnLength
        )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    if (!pReturnLength) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }

    // Do minimal buffer validation
    if ((pWinStationInformation == NULL ) && (WinStationInformationLength != 0)) {
       *pResult = STATUS_INVALID_USER_BUFFER;
       return FALSE;
    }


    *pResult = xxxWinStationQueryInformation(
                   LogonId,
                   WinStationInformationClass,
                   pWinStationInformation,
                   WinStationInformationLength,
                   pReturnLength
                   );


    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationSetInformation
 *
 *    Sets configuration information for a window station object.
 *
 * ENTRY:
 *
 *    WinStationHandle (input)
 *       Identifies the window station object. The handle must have
 *       WINSTATION_SET access.
 *
 *    WinStationInformationClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       window station object.
 *
 *    pWinStationInformation (input)
 *       A pointer to a buffer that contains information to set for the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being set.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The set operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationSetInformation(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        DWORD  WinStationInformationClass,
        PCHAR  pWinStationInformation,
        ULONG  WinStationInformationLength
        )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    // Do minimal buffer validation
    if ((pWinStationInformation == NULL ) && (WinStationInformationLength != 0)) {
       *pResult = STATUS_INVALID_USER_BUFFER;
       return FALSE;
    }


    *pResult = xxxWinStationSetInformation(
                   LogonId,
                   WinStationInformationClass,
                   pWinStationInformation,
                   WinStationInformationLength
                   );


    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcLogonIdFromWinStationName
 *
 *    Returns the LogonId for the specified window station name.
 *
 * ENTRY:
 *
 *    pWinStationName (input)
 *       Window station name.
 *
 *    pLogonId (output)
 *       Pointer to where to place the LogonId if found
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/
BOOLEAN
RpcLogonIdFromWinStationName(
        HANDLE hServer,
        DWORD  *pResult,
        PWCHAR pWinStationName,
        DWORD  NameSize,
        PULONG pLogonId
        )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = LogonIdFromWinStationNameWorker(
                   pWinStationName,
                   NameSize,
                   pLogonId
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationNameFromLogonId
 *
 *    Returns the WinStation name for the specified LogonId.
 *
 * ENTRY:
 *
 *    LogonId (output)
 *       LogonId to query
 *
 *    pWinStationName (input)
 *       Location to return WinStation name
 *
 * EXIT:
 *
 *    If the function succeeds, the return value is TRUE, otherwise, it is
 *    FALSE.
 *    To get extended error information, use the GetLastError function.
 *
 ******************************************************************************/
BOOLEAN
RpcWinStationNameFromLogonId(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        PWCHAR pWinStationName,
        DWORD  NameSize
        )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    if((NameSize < ((WINSTATIONNAME_LENGTH + 1) * sizeof(WCHAR))) ||
        (IsBadWritePtr(pWinStationName, NameSize)))
    {
         *pResult = STATUS_INVALID_PARAMETER;
         return FALSE;
    }

    *pResult = IcaWinStationNameFromLogonId(
                   LogonId,
                   pWinStationName
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationDisconnect
 *
 *    Disconects a window station object from the configured terminal and Pd.
 *    While disconnected all window station i/o is bit bucketed.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to disconnect.
 *    bWait (input)
 *       Specifies whether or not to wait for disconnect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The disconnect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/
BOOLEAN
RpcWinStationDisconnect(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = WinStationDisconnectWorker(
                   LogonId,
                   bWait,
                   TRUE
                   );
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *
 *  RpcWinStationConnect
 *
 *    Connects a window station object to the configured terminal and Pd.
 *
 * ENTRY:
 *
 *    LogonId (input)
 *       ID of window station object to connect.
 *
 *    TargetLogonId (input)
 *       ID of target window station.
 *
 *    pPassword (input)
 *       password of LogonId window station (not needed if same domain/username)
 *
 *    bWait (input)
 *       Specifies whether or not to wait for connect to complete
 *
 * EXIT:
 *
 *    TRUE  -- The connect operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/
BOOLEAN
RpcWinStationConnect(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  ClientLogonId,
    ULONG  ConnectLogonId,
    ULONG  TargetLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize,
    BOOLEAN bWait
    )
{
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    // Do some buffer Validation
    *pResult = IsZeroterminateStringW(pPassword, PasswordSize  );

    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = WinStationConnectWorker(
                   ClientLogonId,
                   ConnectLogonId,
                   TargetLogonId,
                   pPassword,
                   PasswordSize,
                   bWait,
                   FALSE
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationVirtualOpen
 *
 *   Open a virtual channel
 ****************************************************************************/
BOOLEAN
RpcWinStationVirtualOpen(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    DWORD Pid,
    PCHAR pVirtualName,   /* ascii name */
    DWORD  NameSize,
    ULONG_PTR *pHandle
    )
{
    RPC_STATUS RpcStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    HANDLE pidhandle = NULL;
    HANDLE handle = NULL;
    UINT LocalFlag = 0;
    ULONG ulChannelNameLength = 0;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // Only allow local access since virtual channels can't be accessed remotely
    //

    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL,
                  "TERMSRV: RpcWinStationVirtualOpen: I_RpcBindingIsClientLocal() failed: 0x%x\n",RpcStatus));
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Check that the call came in locally
    //
    if (!LocalFlag) {
        Status = (DWORD)STATUS_INVALID_PARAMETER;
        goto done;
    }

    //
    // Check channel name length.
    //
    if ( pVirtualName ) {
       // Make sure if the virtual channel name is specified, the namelength if set to non-zero.
       // Some bad client might intentionally have set it to 0, we don't want it to succeed.
       if ( NameSize == 0 ) {
          Status = (DWORD)STATUS_INVALID_PARAMETER;
          goto done;
       }

       pVirtualName[NameSize-1] = '\0';
       ulChannelNameLength =  strlen( pVirtualName );
    }

    if ( !ulChannelNameLength ||
         (ulChannelNameLength > VIRTUALCHANNELNAME_LENGTH) 
        ) {
        Status = (DWORD)STATUS_INVALID_PARAMETER;
        goto done;
    }
    
    /*
     * Impersonate the client so that when the attempt is made to open the
     * process, it will fail if the client does not have dup handle access.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationVirtualOpen: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status = (DWORD)STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    pidhandle = OpenProcess( PROCESS_DUP_HANDLE, FALSE, Pid );

    RpcRevertToSelf();

    if ( !pidhandle ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * If this winstation type does not allow opening virtual channel, then deny access.
     */
    if ( !_tcsicmp(VIRTUAL_THINWIRE, pVirtualName) &&
         ( ( pWinStation->Client.ProtocolType == PROTOCOL_RDP ) ||
         !(pWinStation->Config.Wd.WdFlag & WDF_USER_VCIOCTL) ) )
    {
        Status = STATUS_ACCESS_DENIED;
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Make sure the caller has WINSTATION_VIRTUAL access
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_VIRTUAL, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Don't allow VirtualChannel opens on listner or idle sessions
     */
    if( pWinStation->State == State_Listen ||
        pWinStation->State == State_Idle )
    {
        ReleaseWinStation( pWinStation);
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * we need to impersonate before calling IcaChannelOpen to 
     * make sure the handle gets marked as non system created
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
      	 ReleaseWinStation( pWinStation);
        DbgPrint("\n\n-----752354 - TERMSRV: RpcWinStationVirtualOpen: Not impersonating! RpcStatus 0x%x*----\n\n",RpcStatus);
        Status = (DWORD)STATUS_CANNOT_IMPERSONATE;
        goto done;
    }
    
    /*
     * Duplicate the virtual channel.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Virtual,
                             pVirtualName,
                             &handle );

    RevertToSelf();

    ReleaseWinStation( pWinStation );

    if ( !NT_SUCCESS( Status ) ) {
    	 DbgPrint("**** 752354 - TERMSRV: IcaChannelOpen failed! Status 0x%x\n",Status);
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                handle,
                                pidhandle,
                                (PHANDLE)pHandle,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

done:
    if ( handle )
        IcaChannelClose( handle );
    if ( pidhandle )
        CloseHandle( pidhandle );
    *pResult = Status;

    if ( NT_SUCCESS(Status) )
        return( TRUE );
    else
        return( FALSE );
}


/*****************************************************************************
 *  RpcWinStationBeepOpen
 *
 *   Open a beep channel
 ****************************************************************************/
BOOLEAN
RpcWinStationBeepOpen(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    DWORD Pid,
    ULONG_PTR *pHandle
    )
{
    RPC_STATUS RpcStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    PWINSTATION pWinStation;
    HANDLE pidhandle = NULL;
    HANDLE handle = NULL;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client so that when the attempt is made to open the
     * process, it will fail if the client does not have dup handle access.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationBeepOpen: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status = (DWORD)STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    if ( !IsCallerSystem() ) {
        *pResult = STATUS_ACCESS_DENIED;
         RpcRevertToSelf();
         return FALSE;
     }
    

    pidhandle = OpenProcess( PROCESS_DUP_HANDLE, FALSE, Pid );

    RpcRevertToSelf();

    if ( !pidhandle ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = (DWORD)STATUS_ACCESS_DENIED;
        goto done;
    }

    /*
     * Make sure the caller has WINSTATION_VIRTUAL access
     */
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_VIRTUAL, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Duplicate the beep channel.
     */
    Status = IcaChannelOpen( pWinStation->hIca,
                             Channel_Beep,
                             NULL,
                             &handle );

    ReleaseWinStation( pWinStation );

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    Status = NtDuplicateObject( NtCurrentProcess(),
                                handle,
                                pidhandle,
                                (PHANDLE)pHandle,
                                0,
                                0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

done:
    if ( handle )
        IcaChannelClose( handle );
    if ( pidhandle )
        CloseHandle( pidhandle );
    *pResult = Status;

    if ( NT_SUCCESS(Status) )
        return( TRUE );
    else
        return( FALSE );
}


/*******************************************************************************
 *  RpcWinStationReset
 *
 *    Reset the specified window station.
 *
 * ENTRY:
 *    LogonId (input)
 *       Identifies the window station object to reset.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *    TRUE  -- The reset operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationReset(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    BOOLEAN bWait
    )
{
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = WinStationResetWorker(
                   LogonId,
                   bWait,
                   TRUE,    // Rpc caller, must check access
                   TRUE     // By default, recreate the WinStation
                   );

    //
    // dont return STATUS_TIMEOUT.
    //

    if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationShadowStop
 *
 *    Stop any shadow operation on the specified window station.
 *
 * ENTRY:
 *    LogonId (input)
 *       Identifies the window station object to reset.
 *    bWait (input)
 *       Specifies whether or not to wait for reset to complete
 *
 * EXIT:
 *    TRUE  -- The stop shadow operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationShadowStop(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    BOOLEAN bWait // unused - later?
    )
{
    PWINSTATION pWinStation;
    ULONG       ClientLogonId;
    NTSTATUS    Status;
    RPC_STATUS  RpcStatus;
    UINT        LocalFlag;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: RpcWinStationShadowStop, LogonId=%d\n", LogonId ));


    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto notfound;
    }

    //
    // If the session is NOT being shadowed then bail out
    //
    if ( !( pWinStation->State == State_Active &&
            !IsListEmpty(&pWinStation->ShadowHead) ) ) {
        Status = STATUS_CTX_SHADOW_NOT_RUNNING;
        goto done;
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadowStop: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status =  STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    //
    // If its remote RPC call we should ignore ClientLogonId
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "ERMSRV: RpcWinStationShadowStop: I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // Get the client session id if it's local
    //
    if (LocalFlag) {
        Status = RpcGetClientLogonId( &ClientLogonId );
        if ( !NT_SUCCESS( Status ) ) {
            RpcRevertToSelf();
            goto done;
        }
    }


    //
    // Check for Disconnect or Reset rights since these two operations
    // would anyway terminate the shadow.
    //
    Status = RpcCheckClientAccess( pWinStation, WINSTATION_DISCONNECT | WINSTATION_RESET, TRUE );

    //
    // If the access is denied then see if the client is on the same session
    // and check to see if the user has the veto right to being shadowed.
    //
    if( !NT_SUCCESS(Status) && LocalFlag && (ClientLogonId == LogonId ) ) {

        switch ( pWinStation->Config.Config.User.Shadow ) {

            case Shadow_EnableInputNotify :
            case Shadow_EnableNoInputNotify :

                Status = STATUS_SUCCESS;
                break;

            default :

                // other cases : don't touch the Status
                break;
        }

    } // else : The call comes from a remote machine or a different session.

    RpcRevertToSelf();

    if ( !NT_SUCCESS( Status ) ) {
        goto done;
    }

    Status = WinStationStopAllShadows( pWinStation );

done:

    ReleaseWinStation( pWinStation );

notfound:

    *pResult = Status;

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationShutdownSystem
 *
 *    Shutdown the system and optionally logoff all WinStations
 *    and/or reboot the system.
 *
 * ENTRY:
 *    ShutdownFlags (input)
 *       Flags which specify shutdown options.
 *
 * EXIT:
 *    TRUE  -- The shutdown operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationShutdownSystem(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  ClientLogonId,
    ULONG  ShutdownFlags
    )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = WinStationShutdownSystemWorker( ClientLogonId, ShutdownFlags );
    if (AuditingEnabled() && (ShutdownFlags & WSD_LOGOFF)
            && (*pResult == STATUS_SUCCESS))
        AuditShutdownEvent();

    //
    // dont return STATUS_TIMEOUT.
    //

    if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationTerminateProcess
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *    hServer (input)
 *       handle to winframe server
 *    pResult (output)
 *       address to return error status
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 *
 * EXIT:
 *    TRUE  -- The terminate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationTerminateProcess(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  ProcessId,
    ULONG  ExitCode
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client so that when the attempt is made to terminate
     * the process, it will fail if the account is not admin.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationTerminateProcess: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = WinStationTerminateProcessWorker( ProcessId, ExitCode );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationWaitSystemEvent
 *
 *    Waits for an event (WinStation create, delete, connect, etc) before
 *    returning to the caller.
 *
 * ENTRY:
 *    EventFlags (input)
 *       Bit mask that specifies which event(s) to wait for.
 *    pEventFlags (output)
 *       Bit mask of event(s) that occurred.
 *
 * EXIT:
 *    TRUE  -- The wait event operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationWaitSystemEvent(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG EventMask,
    PULONG pEventFlags
    )
{
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = WinStationWaitSystemEventWorker( hServer, EventMask, pEventFlags );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationShadow
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     shadow client server handle
 *   pResult (output)
 *     address to return status
 *   LogonId (input)
 *     shadow client logon id
 *   pTargetServerName (input)
 *     shadow target server name
 *   NameSize (input)
 *     size of pTargetServerName (input)
 *   TargetLogonId (input)
 *     shadow target login id (where the app is running)
 *   HotkeyVk (input)
 *     virtual key to press to stop shadow
 *   HotkeyModifiers (input)
 *     virtual modifer to press to stop shadow (i.e. shift, control)
 ****************************************************************************/
BOOLEAN
RpcWinStationShadow(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG LogonId,
    PWSTR pTargetServerName,
    ULONG NameSize,
    ULONG TargetLogonId,
    BYTE HotkeyVk,
    USHORT HotkeyModifiers
    )
{
    RPC_STATUS RpcStatus;
    ULONG ulLength = 0;
    WCHAR TargetServerNameW[MAX_COMPUTERNAME_LENGTH+1];
    char* pTargetServerNameA = NULL;
    PWSTR pTargetServerNameW = pTargetServerName;

    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    // Do minimal buffer validation
    if (pTargetServerName != NULL) {
        // No of bytes is sent from the Client, so send half the length got 
        *pResult = (DWORD)IsZeroterminateStringW(pTargetServerName, NameSize / sizeof(WCHAR));

        if (*pResult != STATUS_SUCCESS) {
            return FALSE;
        }

        ulLength = wcslen(pTargetServerName);

        if (ulLength > (MAX_COMPUTERNAME_LENGTH)) {
            struct hostent *hostPtr;
            ULONG ulRequiredLength = 0;
            PUCHAR ipaddr = NULL;
            int ipLength = 0;

            *pResult = STATUS_INVALID_PARAMETER;
            //
            // Limit the target server name to MAX_COMPUTERNAME_LENGTH.
            // We do this by converting the server name to ipaddress.
            // First convert the name to ANSI
            //
            ulRequiredLength = WideCharToMultiByte(CP_ACP, 0, 
                                                   pTargetServerName, -1,
                                                   NULL, 0, NULL, NULL);

            ASSERT(ulRequiredLength > 0);
            pTargetServerNameA = MemAlloc(ulRequiredLength);

            if (pTargetServerNameA == NULL) {
                *pResult = STATUS_NO_MEMORY;
                goto EXIT;
            }
            if (ulRequiredLength == 0 || 
                !WideCharToMultiByte(CP_ACP, 0, 
                                    pTargetServerName, -1,
                                    pTargetServerNameA, ulRequiredLength,
                                    NULL, NULL)) {
                DBGPRINT(("RpcWinStationShadow: WideCharToMultiByte failed %ld\n", 
                           GetLastError()));
                goto EXIT;
            }
            
            //
            // Get the ip address of the target server name
            //
            if ((hostPtr = gethostbyname(pTargetServerNameA)) == NULL) {
                DBGPRINT(("RpcWinStationShadow: gethostbyname failed %ld\n", 
                           WSAGetLastError()));
                goto EXIT;
            }
            
            MemFree(pTargetServerNameA);
            pTargetServerNameA = NULL;
            
            ipaddr = (PUCHAR)*(hostPtr->h_addr_list);
            
            // Sanity checks.
            ASSERT(hostPtr->h_length >= 4);
            ASSERT(ipaddr != NULL);
            if (ipaddr == NULL) {
                goto EXIT;
            }
            //
            // Put the ip address in target server name.
            // Use this for shadowing
            //
            ipLength =_snwprintf(TargetServerNameW, MAX_COMPUTERNAME_LENGTH, 
                     L"%d.%d.%d.%d", 
                     ipaddr[0], ipaddr[1], ipaddr[2], ipaddr[3]);

            if (ipLength < 0) {
                DBGPRINT(("RpcWinStationShadow: _snwprintf failed\n"));
                *pResult = STATUS_BUFFER_OVERFLOW;
                goto EXIT;
            }
            ulLength = ipLength;
            TargetServerNameW[MAX_COMPUTERNAME_LENGTH] = L'\0';
            pTargetServerNameW = TargetServerNameW;
        }
    }

    /*
     * Impersonate the client so that when the shadow connection is
     * created, it will have the correct security.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadow: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = (DWORD)WinStationShadowWorker( LogonId,
                                              pTargetServerNameW,
                                              ulLength,
                                              TargetLogonId,
                                              HotkeyVk,
                                              HotkeyModifiers );

    RpcRevertToSelf();

EXIT:
    if (pTargetServerNameA != NULL) {
        MemFree(pTargetServerNameA);
    }
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationShadowTargetSetup
 *
 *   Setup a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     target server
 *   pResult (output)
 *     address to return status
 *   LogonId (input)
 *      target logon id
 ****************************************************************************/
BOOLEAN
RpcWinStationShadowTargetSetup(
    HANDLE hServer,
    DWORD  *pResult,
    IN ULONG LogonId
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client so that the shadow connect request
     * will be under the correct security context.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadow: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    // remote caller can't RA session.
    *pResult = (DWORD)WinStationShadowTargetSetupWorker( FALSE, LogonId );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationShadowTarget
 *
 *   Start a Winstation shadow operation
 *
 * ENTRY:
 *   hServer (input)
 *     target server
 *   pResult (output)
 *     address to return status
 *   LogonId (input)
 *      target logon id
 *   pConfig (input)
 *      pointer to WinStation config data
 *   NameSize (input)
 *      length of config data
 *   pAddress (input)
 *      address of shadow client
 *   AddressSize (input)
 *      length of address
 *   pModuleData (input)
 *      pointer to client module data
 *   ModuleDataLength (input)
 *      length of client module data
 *   pThinwireData (input)
 *      pointer to thinwire module data
 *   ThinwireDataLength (input)
 *      length of thinwire module data
 *   pClientName (input)
 *      pointer to client name string (domain/username)
 *   ClientNameLength (input)
 *      length of client name string
 ****************************************************************************/
BOOLEAN
RpcWinStationShadowTarget(
    HANDLE hServer,
    DWORD  *pResult,
    IN ULONG LogonId,
    IN PBYTE pConfig,
    IN DWORD NameSize,
    IN PBYTE pAddress,
    IN DWORD AddressSize,
    IN PBYTE pModuleData,
    IN DWORD ModuleDataLength,
    IN PBYTE pThinwireData,
    IN DWORD ThinwireDataLength,
    IN PBYTE pClientName,
    IN DWORD ClientNameLength
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Validate  buffers .
     */
    if (AddressSize  <  sizeof(ICA_STACK_ADDRESS) ||
        pClientName == NULL ||
        NameSize  < sizeof(WINSTATIONCONFIG2)) {
        *pResult = STATUS_INVALID_USER_BUFFER;
        return FALSE;
    }
    // No of bytes is sent from the Client, so send half the length got 
    *pResult = (DWORD)IsZeroterminateStringW((PWCHAR)pClientName,ClientNameLength / sizeof(WCHAR));
    if (*pResult != STATUS_SUCCESS) {
        return FALSE;
    }

    *pResult = IsConfigValid((PWINSTATIONCONFIG2)pConfig);
    if (*pResult != STATUS_SUCCESS) {
        return FALSE;
    }

    /*
     * Impersonate the client so that the shadow connect request
     * will be under the correct security context.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadow: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = (DWORD)STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    *pResult = (DWORD)WinStationShadowTargetWorker(
                                                    FALSE,        // Shadower not a Help Assistant session.
                                                    FALSE,  // protocol shadow, can't be help assistant session
                                                    LogonId,
                                                    (PWINSTATIONCONFIG2) pConfig,
                                                    (PICA_STACK_ADDRESS) pAddress,
                                                    (PVOID) pModuleData,
                                                    ModuleDataLength,
                                                    (PVOID) pThinwireData,
                                                    ThinwireDataLength,
                                                    pClientName );

    RpcRevertToSelf();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationGenerateLicense
 *
 *  Called to generate a license from a given serial number string.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pSerialNumberString (input)
 *       Pointer to a null-terminated, wide-character Serial Number string
 *    pLicense (output)
 *       Pointer to a License structure that will be filled in with
 *       information based on pSerialNumberString
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The generate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationGenerateLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PWCHAR pSerialNumberString,
    DWORD  Length,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // The WinFrame licensing API's load the Ulm DLL in the context
    // of the ICASRV process, and then attempt to access the
    // WinFrame licensing registry keys. By impersonating the caller,
    // we can make sure that the license key operation is done under
    // the callers subject context. This will fail for non-admin callers, as
    // defined by the ACL placed on the licensing keys.
    //

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationGenerateLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationGenerateLicense(
                 pSerialNumberString,
                 Length,
                 pLicense,
                 LicenseSize
                 );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationGenerateLicense ) {
            *pResult = pWsx->pWsxWinStationGenerateLicense(
                         pSerialNumberString,
                         Length,
                         pLicense,
                         LicenseSize
                         );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "WinStationGenerateLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationInstallLicense
 *
 *  Called to install a license.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be installed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The install operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationInstallLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationInstallLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationInstallLicense(
                 pLicense,
                 LicenseSize
                 );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationInstallLicense ) {
            *pResult = pWsx->pWsxWinStationInstallLicense(
                        pLicense,
                        LicenseSize
                        );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationInstallLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationEnumerateLicenses
 *
 *  Called to return the list of valid licenses.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pIndex (input/output)
 *       Specifies the subkey index for the \Citrix\WinStations subkeys in the
 *       registry.  Should be set to 0 for the initial call, and supplied
 *       again (as modified by this function) for multi-call enumeration.
 *    pEntries (input/output)
 *       Points to a variable specifying the number of entries requested.
 *       If the number requested is 0xFFFFFFFF, the function returns as
 *       many entries as possible. When the function finishes successfully,
 *       the variable pointed to by the pEntries parameter contains the
 *       number of entries actually read.
 *    pLicense (input/output)
 *       Points to the buffer to receive the enumeration results, which are
 *       returned as an array of LICENSE structures.  If this parameter
 *       is NULL, then no data will be copied, but just an enumeration count
 *       will be made.
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *    pByteCount (input/output)
 *       Points to a variable that specifies the size, in bytes, of the
 *       pWinStationName parameter. If the buffer is too small to receive even
 *       one entry, the function returns an error code (ERROR_OUTOFMEMORY)
 *       and this variable receives the required size of the buffer for a
 *       single subkey.  When the function finishes sucessfully, the variable
 *       pointed to by the pByteCount parameter contains the number of bytes
 *       actually stored in pLicense.
 *
 * EXIT:
 *    TRUE  -- The enumerate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationEnumerateLicenses(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  *pIndex,
    DWORD  *pEntries,
    PCHAR  pLicense,
    DWORD  LicenseSize,
    DWORD  *pByteCount
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationEnumerateLicenses: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationEnumerateLicenses(
                 pIndex,
                 pEntries,
                 pLicense,
                 pByteCount
                 );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationEnumerateLicenses ) {
            *pResult = pWsx->pWsxWinStationEnumerateLicenses(
                         pIndex,
                         pEntries,
                         pLicense,
                         pByteCount
                         );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationEnumerateLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationActivateLicense
 *
 *  Called to Activate a license for a License
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (output)
 *       Pointer to a License structure that will be filled in with
 *       information based on pSerialNumberString
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *    pActivationCode (input)
 *       Pointer to a null-terminated, wide-character Activation Code string
 *
 * EXIT:
 *    TRUE  -- The activate operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationActivateLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize,
    PWCHAR pActivationCode,
    DWORD StringSize
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationActivateLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationActivateLicense(
                   pLicense,
                   LicenseSize,
                   pActivationCode,
                   StringSize
                   );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationActivateLicense ) {
            *pResult = pWsx->pWsxWinStationActivateLicense(
                           pLicense,
                           LicenseSize,
                           pActivationCode,
                           StringSize
                           );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationActivateLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationQueryLicense
 *
 *   Query the license(s) on the WinFrame server and the network
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicenseCounts (output)
 *       pointer to buffer to return license count structure
 *    ByteCount (input)
 *       length of buffer in bytes
 *
 * EXIT:
 *    TRUE  -- The query operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ****************************************************************************/
BOOLEAN
RpcWinStationQueryLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR pLicenseCounts,
    ULONG ByteCount
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationQueryLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = QueryLicense(
                   (PLICENSE_COUNTS) pLicenseCounts,
                   ByteCount );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxQueryLicense ) {
            *pResult = pWsx->pWsxQueryLicense(
                           pLicenseCounts,
                           ByteCount );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationQueryLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationQueryUpdateRequired
 *
 *   Query the license(s) on the WinFrame server and determine if an
 *   update is required.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pUpdateFlag (output)
 *       Update flag, set if an update is required
 *
 * EXIT:
 *    TRUE  -- The query operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ****************************************************************************/
BOOLEAN
RpcWinStationQueryUpdateRequired(
    HANDLE hServer,
    DWORD  *pResult,
    PULONG pUpdateFlag
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationQueryUpdateRequired: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationQueryUpdateRequired( pUpdateFlag );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationQueryUpdateRequired ) {
            *pResult = pWsx->pWsxWinStationQueryUpdateRequired( pUpdateFlag );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationRemoveLicense
 *
 *  Called to remove a license diskette.
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be removed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The remove operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationRemoveLicense(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationRemoveLicense: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationRemoveLicense(
                   pLicense,
                   LicenseSize
                   );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationRemoveLicense ) {
            *pResult = pWsx->pWsxWinStationRemoveLicense(
                           pLicense,
                           LicenseSize
                           );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationRemoveLicense: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*******************************************************************************
 *  RpcWinStationSetPoolCount
 *
 *  Called to change the PoolCount for the given license
 *
 * ENTRY:
 *    hServer (input)
 *       Server handle
 *    pLicense (input)
 *       Pointer to a License structure containing the license to
 *       be removed
 *    LicenseSize (input)
 *       Size in bytes of the structure pointed to by pLicense
 *
 * EXIT:
 *    TRUE  -- The change operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             in pResult.
 ******************************************************************************/
BOOLEAN
RpcWinStationSetPoolCount(
    HANDLE hServer,
    DWORD  *pResult,
    PCHAR  pLicense,
    DWORD  LicenseSize
    )
{
    RPC_STATUS RpcStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationSetPoolCount: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = xxxWinStationSetPoolCount(
                   pLicense,
                   LicenseSize
                   );
#else
    {
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx;
    ICASRVPROCADDR IcaSrvProcAddr;

    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( pWsx->pWsxWinStationSetPoolCount ) {
            *pResult = pWsx->pWsxWinStationSetPoolCount(
                           pLicense,
                           LicenseSize
                           );
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationSetPoolCount: 0x%x\n", *pResult ));
#endif

    RpcRevertToSelf();

    return( *pResult == ERROR_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationAnnoyancePopup
 ****************************************************************************/
BOOLEAN
RpcWinStationAnnoyancePopup(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( LogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

#ifdef not_hydrix
    *pResult = WinStationLogonAnnoyance( LogonId );
#else
    //  Assume the worst
    *pResult = (DWORD)STATUS_UNSUCCESSFUL;

    //  Check for compatibility
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation != NULL ) {
        if ( pWinStation->pWsx &&
             pWinStation->pWsx->pWsxWinStationLogonAnnoyance ) {
            UnlockWinStation( pWinStation );
            *pResult = pWinStation->pWsx->pWsxWinStationLogonAnnoyance( LogonId );
            RelockWinStation( pWinStation );
        /*
         * If WinStation has no Wsx structure, wen try to annoy it anyway.
         * This will have the effect of sending annoy msgs to the console.
         */
        } else if ( pWinStation->pWsx == NULL ) {
            PLIST_ENTRY Head, Next;
            PWSEXTENSION pWsx;
            ICASRVPROCADDR IcaSrvProcAddr;

            RtlEnterCriticalSection( &WsxListLock );

            Head = &WsxListHead;
            for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
                pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
                if ( pWsx->pWsxWinStationLogonAnnoyance ) {
                    UnlockWinStation( pWinStation );
                    *pResult = pWsx->pWsxWinStationLogonAnnoyance( LogonId );
                    RelockWinStation( pWinStation );
                    break;
               }
            }

            RtlLeaveCriticalSection( &WsxListLock );
        }
        ReleaseWinStation( pWinStation );
    }
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationAnnoyancePopup: 0x%x\n", *pResult ));
#endif

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationCallback
 ****************************************************************************/
BOOLEAN
RpcWinStationCallback(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId,
    PWCHAR pPhoneNumber,
    DWORD  PhoneNumberSize
    )
{
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( LogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationCallbackWorker( LogonId, pPhoneNumber );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationBreakPoint
 ****************************************************************************/
BOOLEAN
RpcWinStationBreakPoint(
    HANDLE  hServer,
    DWORD   *pResult,
    ULONG   LogonId,
    BOOLEAN KernelFlag
    )
{
    /*
     * This is obsolete and should be removed from the RPC code.
     */
    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}


/*****************************************************************************
 *  RpcWinStationReadRegistry
 ****************************************************************************/
BOOLEAN
RpcWinStationReadRegistry(
    HANDLE  hServer,
    DWORD   *pResult
    )
{
    RPC_STATUS RpcStatus;

    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }


    if (!(IsCallerSystem() || IsCallerAdmin() )) {
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return FALSE;
    }
    RpcRevertToSelf();
    return RpcWinStationUpdateSettings(hServer, pResult, WINSTACFG_LEGACY, 0);
}

/*****************************************************************************
 *  RpcWinStationUpdateSettings
 ****************************************************************************/
BOOLEAN
RpcWinStationUpdateSettings(
    HANDLE  hServer,
    DWORD   *pResult,
    DWORD SettingsClass,
    DWORD SettingsParameters
    )
{
    /*
     * This API is not secured, since it is harmless. It tells the system
     * to make sure all winstations are up to date with the registry. You
     * must be system to write the keys, so the info would match for a normal
     * user poking this call.
     */

    switch (SettingsClass) {

        case WINSTACFG_SESSDIR:
        {
            if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
                *pResult = UpdateSessionDirectory(SettingsParameters);
            }
            else {
                // Do nothing in remote admin or on PTS
                *pResult = STATUS_SUCCESS;
            }
        }
        break;

        case WINSTACFG_LEGACY:
        {
            *pResult = WinStationReadRegistryWorker();
        }
        break;

        default:
        {
            *pResult = STATUS_INVALID_PARAMETER;
        }
    }
 
    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}



/*****************************************************************************
 *  RpcReInitializeSecurity
 ****************************************************************************/
BOOLEAN
RpcWinStationReInitializeSecurity(
    HANDLE  hServer,
    DWORD   *pResult
    )
{
    RPC_STATUS RpcStatus;

    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }



    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }


    if (!(IsCallerSystem() || IsCallerAdmin() )) {
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return FALSE;
    }
    RpcRevertToSelf();

    *pResult = ReInitializeSecurityWorker();

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationWaitForConnect
 ****************************************************************************/
BOOLEAN
RpcWinStationWaitForConnect(
    HANDLE  hServer,
    DWORD   *pResult,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE WinlogonStartHandle = NULL;
    WCHAR  szWinlogonStartEvent[MAX_PATH];
    UNICODE_STRING WinlogonEventName;
    OBJECT_ATTRIBUTES ObjA;
    LARGE_INTEGER TimeOut ;
    ULONG SleepDuration = 90 * 1000; // 90 seconds
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // Winlogon can call into Terminal Server, before we store the session id in its internal structure
    // To prevent this, RpcWinStationWaitForConnect (which is called by Winlogon) will wait for a named event
    // This is the same Named event (CsrStartEvent) which the Csr also waits for before calling into TermSrv
    //

    if (ClientLogonId != 0) {

        wsprintf(szWinlogonStartEvent,
            L"\\Sessions\\%d\\BaseNamedObjects\\CsrStartEvent",ClientLogonId);

        RtlInitUnicodeString( &WinlogonEventName, szWinlogonStartEvent );
        InitializeObjectAttributes( &ObjA, &WinlogonEventName, OBJ_OPENIF, NULL, NULL );
    
        Status = NtCreateEvent( &WinlogonStartHandle,
                                EVENT_ALL_ACCESS,
                                &ObjA,
                                NotificationEvent,
                                FALSE );

        if (!WinlogonStartHandle) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto error_exit;
        } else {

            TimeOut = RtlEnlargedIntegerMultiply( SleepDuration, -10000);
            Status = NtWaitForSingleObject(WinlogonStartHandle, FALSE, &TimeOut);

            NtClose(WinlogonStartHandle);
            WinlogonStartHandle = NULL;

            if (!NT_SUCCESS(Status) || (Status == STATUS_TIMEOUT)) {
                // We timed out waiting for Session Creation to get complete - cant connect now, just exit 
                goto error_exit;
            }
        }
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitForConnect, LogonId=%d\n",ClientLogonId ));

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        *pResult = (DWORD)STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    *pResult = (DWORD)WaitForConnectWorker( pWinStation, (HANDLE)(ULONG_PTR)ClientProcessId );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );

error_exit:
    *pResult = Status;

    //
    // dont return STATUS_TIMEOUT.
    //

    if (*pResult == STATUS_TIMEOUT) *pResult = STATUS_UNSUCCESSFUL;

    return FALSE;
}


/*****************************************************************************
 *  RpcWinStationNotifyLogon
 ****************************************************************************/
BOOLEAN
RpcWinStationNotifyLogon(
    HANDLE  hServer,
    DWORD   *pResult,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    BOOLEAN fUserIsAdmin,
    DWORD   UserToken,
    PWCHAR  pDomain,
    DWORD   DomainSize,
    PWCHAR  pUserName,
    DWORD   UserNameSize,
    PWCHAR  pPassword,
    DWORD   PasswordSize,
    UCHAR   Seed,
    PCHAR   pUserConfig,
    DWORD   ConfigSize,
    BOOLEAN *pfIsRedirected
    )
{
    NTSTATUS Status;

    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }
    /*
     * Do some buffer validation
     * No of bytes is sent from the Client, so send half the length got
     */

    *pResult = IsZeroterminateStringW(pPassword, PasswordSize / sizeof(WCHAR) );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pUserName, UserNameSize / sizeof(WCHAR) );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pDomain, DomainSize / sizeof(WCHAR) );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationNotifyLogonWorker(
            ClientLogonId,
            ClientProcessId,
            fUserIsAdmin,
            UserToken,
            pDomain,
            DomainSize,
            pUserName,
            UserNameSize,
            pPassword,
            PasswordSize,
            Seed,
            pUserConfig,
            ConfigSize,
            pfIsRedirected
            );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationNotifyLogoff
 ****************************************************************************/
BOOLEAN
RpcWinStationNotifyLogoff(
    HANDLE  hServer,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    DWORD   *pResult
    )
{
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }
    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationNotifyLogoffWorker(
                   ClientLogonId,
                   ClientProcessId
                   );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  RpcWinStationNotifyNewSession
 *
 *  THIS FUNCTION IS OBSOLETE AND SHOULD BE REMOVED FROM FUTURE VERSIONS OF
 *  INTERFACE.
 ****************************************************************************/
BOOLEAN
RpcWinStationNotifyNewSession(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  ClientLogonId
    )
{
    *pResult = STATUS_SUCCESS;

    return(TRUE);
}


/*******************************************************************************
 *  RpcWinStationSendMessage
 *
 *    Sends a message to the specified window station object and optionally
 *    waits for a reply.  The reply is returned to the caller of
 *    WinStationSendMessage.
 *
 * ENTRY:
 *    WinStationHandle (input)
 *       Specifies the window station object to send a message to.
 *    pTitle (input)
 *       Pointer to title for message box to display.
 *    TitleLength (input)
 *       Length of title to display in bytes.
 *    pMessage (input)
 *       Pointer to message to display.
 *    MessageLength (input)
 *       Length of message in bytes to display at the specified window station.
 *    Style (input)
 *       Standard Windows MessageBox() style parameter.
 *    Timeout (input)
 *       Response timeout in seconds.  If message is not responded to in
 *       Timeout seconds then a response code of IDTIMEOUT (cwin.h) is
 *       returned to signify the message timed out.
 *    pResponse (output)
 *       Address to return selected response.
 *    DoNotWait (input)
 *       Do not wait for the response. Causes pResponse to be set to
 *       IDASYNC (cwin.h) if no errors queueing the message.
 *
 * EXIT:
 *    TRUE  -- The send message operation succeeded.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationSendMessage(
        HANDLE hServer,
        DWORD  *pResult,
        ULONG  LogonId,
        PWCHAR pTitle,
        ULONG  TitleLength,
        PWCHAR pMessage,
        ULONG MessageLength,
        ULONG Style,
        ULONG Timeout,
        PULONG pResponse,
        BOOLEAN DoNotWait
        )
{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG WMsg;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    NTSTATUS MessageDelieveryStatus;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Make sure that the title and the message are NULL terminated.
     */
    pTitle[TitleLength-1] = L'\0';
    pMessage[MessageLength-1] = L'\0';


    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        *pResult = (DWORD)STATUS_CTX_WINSTATION_NOT_FOUND;
        return( FALSE );
    }


    Status = RpcCheckClientAccess( pWinStation, WINSTATION_MSG, FALSE );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        ReleaseWinStation( pWinStation );
        return( FALSE );
    }




    TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: pTitle   %S\n", pTitle ));
    TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: pMessage %S\n", pMessage ));

    /*
     * Marshall in the [in] parameters
     *
     * pTitle and pMessage will be mapped into client
     * view at apropriate time and place
     */

    WMsg.u.SendMessage.pTitle = pTitle;
    WMsg.u.SendMessage.TitleLength = TitleLength;
    WMsg.u.SendMessage.pMessage = pMessage;
    WMsg.u.SendMessage.MessageLength = MessageLength;
    WMsg.u.SendMessage.Style = Style;
    WMsg.u.SendMessage.Timeout = Timeout;
    WMsg.u.SendMessage.DoNotWait = DoNotWait;
    WMsg.u.SendMessage.DoNotWaitForCorrectDesktop = FALSE;
    
    if( !DoNotWait ) {
        WMsg.u.SendMessage.pStatus = &MessageDelieveryStatus;
        WMsg.u.SendMessage.pResponse = pResponse;
    } else {
        WMsg.u.SendMessage.pStatus = NULL;
        WMsg.u.SendMessage.pResponse = NULL;
    }
    

    WMsg.ApiNumber = SMWinStationDoMessage;

    /*
     *  Create wait event
     */
    if( !DoNotWait ) {
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtCreateEvent( &WMsg.u.SendMessage.hEvent, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );
        if ( !NT_SUCCESS(Status) ) {
            *pResult = Status;
            goto done;
        }
    }
    else
    {
        WMsg.u.SendMessage.hEvent = NULL;

    }

    /*
     *  Initialize response to IDTIMEOUT or IDASYNC
     */

    if (DoNotWait) {
        *pResponse = IDASYNC;
    } else {
        *pResponse = IDTIMEOUT;
    }

    /*
     * Tell the WinStation to display the message box
     */
    *pResult = SendWinStationCommand( pWinStation, &WMsg, 0 );

    /*
     *  Wait for response, pResponse & MessageDelieveryStatus are filled in WinStationIcaReplyMessage
     */
    if( !DoNotWait ) {
        if (*pResult == STATUS_SUCCESS) {
            TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: wait for response\n" ));
            UnlockWinStation( pWinStation );
            Status = NtWaitForSingleObject( WMsg.u.SendMessage.hEvent, FALSE, NULL );
            if ( !RelockWinStation( pWinStation ) ) {
                Status = STATUS_CTX_CLOSE_PENDING;
            }
            else {
                Status = MessageDelieveryStatus;
            }

            *pResult = Status;
            
            TRACE((hTrace,TC_ICASRV,TT_API1, "RpcWinStationSendMessage: got response %u\n", *pResponse ));
        }
        NtClose( WMsg.u.SendMessage.hEvent );
    }

done:

    ReleaseWinStation( pWinStation );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}


/*****************************************************************************
 *  SERVER_HANDLE_rundown
 *
 *   Required RPC context run down routine.
 *
 *   This gets called when the RPC client drops or closes
 *   the connection and allows us to cleanup any state
 *   information.
 *
 * ENTRY:
 *   phContext (input)
 *     Context handle being rundown
 ****************************************************************************/
VOID
SERVER_HANDLE_rundown(
    HANDLE hContext
    )
{
    DWORD Result;
    PRPC_CLIENT_CONTEXT pContext = (PRPC_CLIENT_CONTEXT)hContext;
    ULONG EventFlags;
          
    TRACE((hTrace,TC_ICASRV,TT_API1,"TERMSRV: Context rundown, %p\n", hContext));
    
    if(!pContext)
    {
        return;
    }
    //RpcWinStationCloseServerEx( &hContext, &Result );
    //ASSERT(hContext == NULL);
    
    // Free the wait event block if one was allocated
    if ( pContext->pWaitEvent ) {
        WinStationWaitSystemEventWorker( pContext, WEVENT_NONE, &EventFlags );
    }

    midl_user_free(hContext);
    hContext = NULL;

    return;
}


/*
 * The following functions allow us to control the
 * memory allocation and free functions of the RPC.
 */

void __RPC_FAR * __RPC_USER
MIDL_user_allocate( size_t Size )
{
    return( LocalAlloc(LMEM_FIXED,Size) );
}


void __RPC_USER
MIDL_user_free( void __RPC_FAR *p )
{
    if (!PointerIsInGAPDatabase(p))
    {
//        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: MIDL_user_free for 0x%x....FREE it\n",p));
        LocalFree( p );
    }
    else
    {
//        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: MIDL_user_free for 0x%x..................DON'T FREE IT\n",p));
    }
}


/*******************************************************************************
 *  NotifySystemEvent
 *
 *   Notify clients that a system event occured.
 *
 * ENTRY:
 *    EventMask (input)
 *       mask of event(s) that have occured
 ******************************************************************************/
VOID
NotifySystemEvent( ULONG EventMask )
{
    PLIST_ENTRY Head, Next;
    PEVENT pWaitEvent;
    NTSTATUS Status;

    if ( IsListEmpty( &SystemEventHead ) ) {
        return;
    }

    TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: NotifySystemEvent, Event=0x%08x\n", EventMask ));

    RtlEnterCriticalSection( &WinStationListLock );
    Head = &SystemEventHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWaitEvent = CONTAINING_RECORD( Next, EVENT, EventListEntry );
        if ( pWaitEvent->EventMask & EventMask ) {
            pWaitEvent->EventFlags |= EventMask;
            if ( pWaitEvent->fWaiter ) {
                pWaitEvent->WaitResult = STATUS_SUCCESS;
                NtSetEvent( pWaitEvent->Event, NULL );
            }
        }
    }

    RtlLeaveCriticalSection( &WinStationListLock );
}

/*****************************************************************************
 *  WinStationDisconnectWorker
 *
 *   Function to disconnect a Winstation based on an RPC API request.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationDisconnectWorker(
    ULONG LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc
    )
{
    PWINSTATION pWinStation;
    ULONG ClientLogonId;
    ULONG PdFlag;
    WINSTATIONNAME WinStationName;
    WINSTATIONNAME ListenName;
    NTSTATUS Status;
    BOOLEAN bConsoleSession = FALSE;
    UINT        LocalFlag = FALSE;
    BOOLEAN bRelock;
    BOOLEAN bIncrementFlag = FALSE; 

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDisconnect, LogonId=%d\n", LogonId ));

    //
    //There are some bad ginas that break 
    //console disconnection bug 345286
    //
    if(LogonId == 0 && !IsGinaVersionCurrent()) {
        Status = STATUS_CTX_CONSOLE_DISCONNECT;
        goto done;
    }

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    if (LogonId == 0 && !bConsoleConnected){

       Status = WaitForConsoleConnectWorker(  pWinStation );
       if (NT_SUCCESS(Status)) {
           bConsoleConnected=TRUE;
       } else {
           ReleaseWinStation( pWinStation );
           goto done;
       }

    }

    /*
     * Note if we are disconnecting a session that is connected to the console terminal.
     */

    bConsoleSession = pWinStation->fOwnsConsoleTerminal;

    /*
     * Verify that client has DISCONNECT access if its an RPC (external) caller.
     *
     * When ICASRV calls this function internally, it is not impersonating
     * and fails the RpcCheckClientAccess() call. Internal calls are
     * not a security problem since they come in as LPC messages on a secured
     * port.
     */
    if ( CallerIsRpc ) {
        RPC_STATUS RpcStatus;

        /*
         * Impersonate the client
         */
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationDisconnectWorker: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto done;
        }

        Status = RpcCheckClientAccess( pWinStation, WINSTATION_DISCONNECT, TRUE );
        if ( !NT_SUCCESS( Status ) ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            goto done;
        }

        //
        // If its remote RPC call we should ignore ClientLogonId
        //
        RpcStatus = I_RpcBindingIsClientLocal(
                        0,    // Active RPC call we are servicing
                        &LocalFlag
                        );

        if( RpcStatus != RPC_S_OK ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationDisconnectWorker: IsClientLocal failed! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }

        if ( LocalFlag ) {
            Status = RpcGetClientLogonId( &ClientLogonId );
            if ( !NT_SUCCESS( Status ) ) {
                RpcRevertToSelf();
                ReleaseWinStation( pWinStation );
                goto done;
            }
        }

        RpcRevertToSelf();
    }

    /*
     * If WinStation is already disconnected, then we're done
     */
    if ( !pWinStation->WinStationName[0] )  {
        ReleaseWinStation( pWinStation );
        return (STATUS_SUCCESS);
    }

    /*
     * If we are disconnecting the console session, we want to make sure
     * that we can precreate a session that would become the console session.
     */
    if (bConsoleSession && !ShutdownInProgress) {
        UnlockWinStation(pWinStation);
        Status = CheckIdleWinstation();
        bRelock = RelockWinStation(pWinStation);
        if (!NT_SUCCESS(Status) || !bRelock) {
            if (NT_SUCCESS(Status)) {
                Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            }
            ReleaseWinStation( pWinStation );
            goto done;
        }

    }

    /*
     * If busy with something already, don't do this
     */
    if ( pWinStation->NeverConnected || pWinStation->Flags ) {

        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto done;
    }


    if (bConsoleSession) {
        InterlockedIncrement(&gConsoleCreationDisable);
        bIncrementFlag = TRUE; 
    }

    /*
     * If no broken reason/source have been set, then set them here.
     *
     * BrokenReason is Disconnect.  BrokenSource is User if we are
     * called via RPC and caller is disconnecting his own LogonId.
     */
    if ( pWinStation->BrokenReason == 0 ) {
        pWinStation->BrokenReason = Broken_Disconnect;
        if ( CallerIsRpc &&  LocalFlag  && ClientLogonId == pWinStation->LogonId ) {
            pWinStation->BrokenSource = BrokenSource_User;
        } else {
            pWinStation->BrokenSource = BrokenSource_Server;
        }
    }

    /*
     * If it's an external request (RPC) then set the last error
     * state to the client to indicate what the reason for the
     * disconnection was.
     */
    if ( CallerIsRpc && pWinStation)
    {
        if(pWinStation->pWsx &&
           pWinStation->pWsx->pWsxSetErrorInfo &&
           pWinStation->pWsxContext)
        {
            pWinStation->pWsx->pWsxSetErrorInfo(
                               pWinStation->pWsxContext,
                               TS_ERRINFO_RPC_INITIATED_DISCONNECT,
                               FALSE); //stack lock not held
        }
    }

    /*
     * If the RPC caller did not wish to wait for this disconnect,
     * then queue an internal call for this to be done.
     * This is safe now that we have done all of the above checks
     * to determine that the caller has access to perform the
     * disconnect and have set BrokenSource/Reason above.
     */
    if ( CallerIsRpc && !bWait ) {
        ReleaseWinStation( pWinStation );
        QueueWinStationDisconnect( LogonId );
        Status = STATUS_SUCCESS;
        goto done;
    }

    /*
     * Preserve some of this WinStation's state in case it's
     * needed after we disconnect and release it.
     */
    PdFlag = pWinStation->Config.Pd[0].Create.PdFlag;
    wcscpy( WinStationName, pWinStation->WinStationName );
    if ( gbListenerOff ) {
        wcscpy( ListenName, pWinStation->ListenName );
    }

    /*
     *  Notify the licensing core of the disconnect. Failures are ignored.
     */

    (VOID)LCProcessConnectionDisconnect(pWinStation);

    /*
     * Disconnect the WinStation
     */
    pWinStation->Flags |= WSF_DISCONNECT;
    Status = WinStationDoDisconnect( pWinStation, NULL, FALSE );
    pWinStation->Flags &= ~WSF_DISCONNECT;

    /*
     * If there is no user logged on (logon time is 0),
     * then queue a reset for this WinStation.
     *
     * We don't want to do this here directly since the RPC client may
     * NOT have reset access.  However, the behavior we want is that if
     * a WinStation with no user logged on is disconnected, it gets reset.
     * This is consistent with how we handle broken connections
     * (see WinStationBrokenConnection() in wstlpc.c).
     */
    if ( RtlLargeIntegerEqualToZero( pWinStation->LogonTime ) ) {
        QueueWinStationReset( pWinStation->LogonId);
    }

    ReleaseWinStation( pWinStation );

    // Increment the total number of disconnected sessions
    if (Status == STATUS_SUCCESS) {
        InterlockedIncrement(&g_TermSrvDiscSessions);
    }



    /*
     * For single-instance transports a listener must be re-created
     * upon disconnection
     */
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WinStationDisconnect: after disconnecting\n" ));


    if ( PdFlag & PD_SINGLE_INST ) {

        Status = QueueWinStationCreate( WinStationName );
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WinStationDisconnect: QueueWinStationCreate returned 0x%x\n", Status ));
        if ( !NT_SUCCESS( Status ) ) {
            goto done;
        }
    }

     if ( gbListenerOff && ListenName[0]) {

         StartStopListeners( ListenName, FALSE );
     }

    /*
     * Determine return status and cleanup
     */
done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationDisconnect, Status=0x%x\n", Status ));

    if (bIncrementFlag) {
        InterlockedDecrement(&gConsoleCreationDisable);
        bIncrementFlag = FALSE;
    }

    // If we disconnected a Session owning the console terminal, go an create a new one
    // to own it.

    if (bConsoleSession) {
        ENTERCRIT(&ConsoleLock);
        if (!WinStationCheckConsoleSession()) {
            /*
             * Wake up the WinStationIdleControlThread
             */
            NtSetEvent(WinStationIdleControlEvent, NULL);

        }
        LEAVECRIT(&ConsoleLock);
    }
    return( Status );
}



/*****************************************************************************
 *  RpcGetUserSID
 *
 *  Helper function to get the SID of the caller
 *
 * ENTRY:
 * - BOOLEAN AlreadyImpersonating TRUE if the caller is already impersonating
 *      the client
 * - PSID*   ppSid : pointer to receive the SID pointer
 *
 * RETURN:
 *  - nt Status, the pointer to the Sid in ppSid if success, NULL otherwise.
 ****************************************************************************/
NTSTATUS
RpcGetUserSID(
    BOOLEAN AlreadyImpersonating,
    PSID*   ppSid
    )
{
    PSID        pClientSid = NULL;
    PTOKEN_USER TokenInfo = NULL;
    HANDLE      CurrentThreadToken = NULL;
    ULONG       SidLength;
    ULONG       Length;
    RPC_STATUS  RpcStatus;
    NTSTATUS    Status;


    if (ppSid == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    *ppSid = NULL;

    /*
     * Impersonate the client
     */
    if (!AlreadyImpersonating) {
        RpcStatus = RpcImpersonateClient( NULL );
        if (RpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcGetUserSID: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            return STATUS_CANNOT_IMPERSONATE;
        }
    }

    Status = NtOpenThreadToken(
                  NtCurrentThread(),
                  TOKEN_QUERY,
                  TRUE,              // Use service's security context to open thread token
                  &CurrentThreadToken
                  );

    if (!NT_SUCCESS(Status)) {
       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcGetUserSID: Cannot open the current thread token %08lx\n",
                    Status));
       goto done;
   }

    /*
     * Determine size needed for token info buffer and allocate it
     */
    Status = NtQueryInformationToken( CurrentThreadToken, TokenUser,
                                      NULL, 0, &Length );
    if ( Status != STATUS_BUFFER_TOO_SMALL ) {
        goto done;
    }

    TokenInfo = MemAlloc( Length );
    if (TokenInfo == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    /*
     * Query token information to get client user's SID
     */
    Status = NtQueryInformationToken( CurrentThreadToken, TokenUser,
                                      TokenInfo, Length, &Length );
    if (!NT_SUCCESS( Status )) {
        goto done;
    }

    SidLength = RtlLengthSid( TokenInfo->User.Sid );

    pClientSid = (PSID) MemAlloc( SidLength );
    if (pClientSid == NULL) {
        Status = STATUS_NO_MEMORY;
        goto done;
    }

    Status = RtlCopySid(SidLength, pClientSid, TokenInfo->User.Sid);


done:
    if ( !AlreadyImpersonating ) {
        RpcRevertToSelf();
    }

    if (CurrentThreadToken) {
      NtClose( CurrentThreadToken );
    }

    if (TokenInfo) {
        MemFree( TokenInfo );
    }

    if (!NT_SUCCESS(Status)) {
        if (pClientSid) {
            MemFree( pClientSid );
        }
    } else {
        *ppSid = pClientSid;
    }

    return Status;
}


/*****************************************************************************
 *  WinStationConnectWorker
 *
 *   Worker for handling WinStation connection called from RPC server.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    bAutoReconnecting (input)
 *      Boolean set to TRUE to indicate that this is a connection for the
 *      purposes of autoreconnection. This is important to allow an atomic
 *      autoreconnection by properly handling the WSF_AUTORECONNECTING flag
 *      that otherwise guards against race conditions while autoreconnecting.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationConnectWorker(
    ULONG  ClientLogonId,
    ULONG  ConnectLogonId,
    ULONG  TargetLogonId,
    PWCHAR pPassword,
    DWORD  PasswordSize,
    BOOLEAN bWait,
    BOOLEAN bAutoReconnecting
    )
{
    PWINSTATION pClientWinStation;
    PWINSTATION pSourceWinStation;
    PWINSTATION pTargetWinStation;
    PWINSTATION pWinStation;
    PSID pClientSid;
    UNICODE_STRING PasswordString;
    BOOLEAN fWrongPassword;
    PRECONNECT_INFO pTargetReconnectInfo = NULL;
    PRECONNECT_INFO pSourceReconnectInfo = NULL;
    BOOLEAN SourceConnected = FALSE;
    WINSTATIONNAME SourceWinStationName;
    NTSTATUS Status;
    BOOLEAN bConsoleSession = FALSE;
    ULONG ulIndex;
    LONG lActiveCount = 0;
    PLIST_ENTRY Head, Next;
    BOOLEAN fSourceAutoReconnecting = FALSE;
    BOOLEAN fTargetAutoReconnecting = FALSE;
    
    //------------------------------------------------------------
    /*
     * Target winstation might still have user password
     * used for auto-logon. Let's clear it here.
     */
    pTargetWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        return Status;
    }
    
    //Since we don't need the password anymore, clean it up
    if (pTargetWinStation->pNewClientCredentials != NULL) {
        RtlSecureZeroMemory(pTargetWinStation->pNewClientCredentials->Password,
            sizeof(pTargetWinStation->pNewClientCredentials->Password));
    }
    
    RtlSecureZeroMemory(pTargetWinStation->Config.Config.User.Password,
        sizeof(pTargetWinStation->Config.Config.User.Password));
    
    ReleaseWinStation( pTargetWinStation );
    //------------------------------------------------------------

    // Do not allow reconnection to the same session, for any session.
    // BUG 506808
    // This problem was only happening on a non-logged in console (bConsoleConnected=FALSE),  when from 
    // some other session, TsCon was used to connection session0 to console session:
    //      tscon 0 /dest:console
    // 

    if (TargetLogonId == ConnectLogonId)
    {
        Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
        return Status;
    }

    //
    //On session 0 it might happen that user already logged on,
    //but termsrv is not notified yet.
    //in this case "Local\\WinlogonTSSynchronizeEvent" event will be in
    //nonsignaled state. We need to refuse all attempts to connect to
    //session 0 untill this event is signaled.
    //
    if (ConnectLogonId == 0) {
        

        HANDLE hSyncEvent;
        DWORD dwWaitResult;

        hSyncEvent = OpenEventW(SYNCHRONIZE, FALSE, L"Local\\WinlogonTSSynchronizeEvent");
        if ( !hSyncEvent){
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL,
                "TERMSRV: Cannot open WinlogonTSSynchronizeEvent event. ERROR: %d\n",GetLastError()));
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }
        
        dwWaitResult = WaitForSingleObject(hSyncEvent,0);

        CloseHandle(hSyncEvent);

        if(dwWaitResult != WAIT_OBJECT_0) {
            TRACE((hTrace,TC_ICASRV,TT_API1,
                "TERMSRV: WinStationConnectWorker. WinlogonTSSynchronizeEvent is not signaled.\n"));
            return STATUS_CTX_WINSTATION_BUSY;
        }

    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationConnect, LogonId=%u, Target LogonId=%u, (%S)\n",
              ConnectLogonId, TargetLogonId, pPassword ));

    /*
     * Allocate RECONNECT_INFO structures
     */

    if ((pTargetReconnectInfo = MemAlloc(sizeof(*pTargetReconnectInfo))) == NULL) {
        return STATUS_NO_MEMORY;
    }

    if ((pSourceReconnectInfo = MemAlloc(sizeof(*pSourceReconnectInfo))) == NULL) {
        MemFree(pTargetReconnectInfo);
        return STATUS_NO_MEMORY;
    }


    Status = RpcGetUserSID( FALSE, &pClientSid);
    if(!NT_SUCCESS(Status)) {
        goto done;
    }

    /*
     * on non server make sure to fail reconnect if it is going to endup in more than one active session.
     */

    if (!gbServer) {
       Head = &WinStationListHead;
       ENTERCRIT( &WinStationListLock );
       for ( Next = Head->Flink; Next != Head; Next = Next->Flink) {
           pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
           if ( (pWinStation->State == State_Active) || (pWinStation->State == State_Shadow) ){
               if (pWinStation->LogonId != ConnectLogonId && pWinStation->LogonId != TargetLogonId  ) {
                   if (!TSIsSessionHelpSession(pWinStation, NULL)) {
                      lActiveCount ++;
                   }
               }
           }
       }
       LEAVECRIT( &WinStationListLock );
       if (lActiveCount != 0) {
           Status = STATUS_CTX_WINSTATION_NOT_FOUND;
           MemFree( pClientSid );
           goto done;
       }
    }


    /*
     * Find and lock the WinStation (source) for the specified LogonId
     */

    pSourceWinStation = FindWinStationById( ConnectLogonId, FALSE );
    if ( pSourceWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        MemFree( pClientSid );
        goto done;
    }
    if (ConnectLogonId == 0 && !bConsoleConnected ){

       Status = WaitForConsoleConnectWorker(  pSourceWinStation );
       if (NT_SUCCESS(Status)) {
           bConsoleConnected=TRUE;
       } else{
           ReleaseWinStation( pSourceWinStation );
           MemFree( pClientSid );
           goto done;
       }

    }

    /*
     * Verify that there is someone logged on (SALIMC)
     */
    if ( (ConnectLogonId != 0) && !pSourceWinStation->pUserSid ) {
        Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
        ReleaseWinStation( pSourceWinStation );
        MemFree( pClientSid );
        goto done;
    }

    /*
     * Verify that client has CONNECT access
     *
     * NOTE: This function clears pPassword whether successful or not
     *       to prevent its being paged out as clear text.
     */
    Status = _CheckConnectAccess(
                 pSourceWinStation,
                 pClientSid,
                 ClientLogonId,
                 pPassword,
                 PasswordSize
                 );
    MemFree( pClientSid );
    if ( !NT_SUCCESS( Status ) ) {
        ReleaseWinStation( pSourceWinStation );
        goto done;
    }

    //
    // Deterime if source is part of an autoreconnection
    //
    fSourceAutoReconnecting = bAutoReconnecting &&                            
                             (pSourceWinStation->Flags & WSF_AUTORECONNECTING);

    /*
     * Mark the winstation as being connected. (SALIMC)
     * If any operation (create/delete/reset/...) is already in progress
     * on this winstation, then don't proceed with the connect.
     * unless that operation is an autoreconnect and we are autoreconnecting
     */
    if (pSourceWinStation->LogonId == 0) {

        if (pSourceWinStation->Flags && !fSourceAutoReconnecting) {
          if ((pSourceWinStation->Flags & WSF_DISCONNECT) && (pSourceWinStation->UserName[0] == L'\0')) { 
             /* Let us wait for sometime here before setting Busy flag and exiting */
              for (ulIndex=0; ulIndex < WINSTATION_WAIT_RETRIES; ulIndex++) {
                  if ( pSourceWinStation->Flags ) {
                      LARGE_INTEGER Timeout;
                      Timeout = RtlEnlargedIntegerMultiply( WINSTATION_WAIT_DURATION, -10000 );
                      UnlockWinStation( pSourceWinStation );
                      NtDelayExecution( FALSE, &Timeout );
                      if ( !RelockWinStation( pSourceWinStation ) ) {
                          ReleaseWinStation( pSourceWinStation );
                          Status = STATUS_CTX_WINSTATION_BUSY;
                          goto done;
                      }
                  } else {
                      break;
                  }
              }
          }
          if (pSourceWinStation->Flags && !fSourceAutoReconnecting) {
              #if DBG
                DbgPrint("WinstationConnectWorker : Even after waiting for 2 mins,Winstation flag is not clear. Sending STATUS_CTX_WINSTATION_BUSY.\n");
              #endif
              Status = STATUS_CTX_WINSTATION_BUSY;
              ReleaseWinStation( pSourceWinStation );
              goto done;
          }
       }

    } else if ( pSourceWinStation->NeverConnected ||
         (pSourceWinStation->Flags && !fSourceAutoReconnecting) ||
         (pSourceWinStation->State != State_Active &&
          pSourceWinStation->State != State_Disconnected) ) {
        Status = STATUS_CTX_WINSTATION_BUSY;
        ReleaseWinStation( pSourceWinStation );
        goto done;
    }

    pSourceWinStation->Flags |= WSF_CONNECT;

    /*
     * Unlock the source WinStation but keep a reference to it.
     */
    UnlockWinStation( pSourceWinStation );

    /*
     * Now find and lock the target WinStation
     */
    pTargetWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto badname;
    }

    /*
     * If this is a re-connection to Session 0 where no one is logged on, then it must be a request from the Client or should be a from a temp session attached to console
     */

    if ( (gbServer) && (ConnectLogonId == 0) && (!pSourceWinStation->pUserSid) ) {
        BOOLEAN Check1 = FALSE, Check2 = FALSE ;

        Check1 = pTargetWinStation->bRequestedSessionIDFieldValid && (pTargetWinStation->RequestedSessionID == 0);
        Check2 = pTargetWinStation->fOwnsConsoleTerminal;

        if ( !(Check1 || Check2) ) {
            Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
            ReleaseWinStation( pTargetWinStation );
            goto badname;
        }
    }


    if (TargetLogonId == 0 && !bConsoleConnected){

        Status = WaitForConsoleConnectWorker(  pTargetWinStation );
        if (NT_SUCCESS(Status)) {
            bConsoleConnected=TRUE;
        }  else {
            ReleaseWinStation( pTargetWinStation );
            goto badname;
        }
    }

    /*
     * Verify that client has DISCONNECT access
     */
    Status = RpcCheckClientAccess( pTargetWinStation, WINSTATION_DISCONNECT, FALSE );
    if ( !NT_SUCCESS( Status ) )
        goto targetnoaccess;

#if 0 
    BUG 495195
    http://liveraid/?id=495195

    /*
     * Do not allow a client running on the same machine to reconnect a the console session to its own session.
     */
    if (IsValidLoopBack(pTargetWinStation, ConnectLogonId, ClientLogonId)) {
        Status = STATUS_CTX_CONSOLE_CONNECT;
        goto targetnoconsole;
    }
#endif

    /*
     *  On server do not allow reconnecting a non zero session to the iconsole.
     */

    if (pTargetWinStation->fOwnsConsoleTerminal && gbServer && (ConnectLogonId != 0)) {
        Status = STATUS_CTX_CONSOLE_DISCONNECT;
        goto targetnoconsole;
    }

    // Whistler supports reconnecting a session from Console to a given Remote Protocol
    // But Whistler does not support direct reconnect from one remote protocol to a different remote protocol 
    // Check for the above condition and block this scenario

    if ( (pSourceWinStation->Client.ProtocolType != PROTOCOL_CONSOLE) && (pTargetWinStation->Client.ProtocolType != PROTOCOL_CONSOLE) ) {
        // This is not a Direct Console Disconnect/Reconnect Scenario
        if (pSourceWinStation->Client.ProtocolType != pTargetWinStation->Client.ProtocolType) {
            Status = STATUS_CTX_BAD_VIDEO_MODE ;
            goto targetnoaccess;

        }
    }

    /*
     *  Make sure the reconnected session is licensed.
     */

    Status = LCProcessConnectionReconnect(pSourceWinStation, pTargetWinStation);

    if (!NT_SUCCESS(Status))
    {
        goto badlicense;
    }

    fTargetAutoReconnecting = bAutoReconnecting &&                            
                             (pTargetWinStation->Flags & WSF_AUTORECONNECTING);

    /*
     * Mark the winstation as being disconnected.
     * If any operation (create/delete/reset/...) is already in progress
     * on this winstation, then don't proceed with the connect.
     */
    if ( pTargetWinStation->NeverConnected ||
         (pTargetWinStation->Flags && !fTargetAutoReconnecting)) {
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto targetbusy;
    }


    pTargetWinStation->Flags |= WSF_DISCONNECT;


    /*
     * Disconnect the target WinStation
     */
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationConnectWorker Disconnecting target!\n"));

    /*
     * Note if we are disconnecting the session that owns the console
     */
    if (pTargetWinStation->fOwnsConsoleTerminal) {

        bConsoleSession = TRUE;
        UnlockWinStation( pTargetWinStation );
        ENTERCRIT(&ConsoleLock);
        InterlockedIncrement(&gConsoleCreationDisable);
        LEAVECRIT(&ConsoleLock);
        if (!RelockWinStation( pTargetWinStation )) {
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            goto baddisconnecttarget;
        }

    }

    Status = WinStationDoDisconnect( pTargetWinStation, pTargetReconnectInfo, FALSE );

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "WinStationConnectWorker Disconnecting target failed Status = %x!\n", Status));
        goto baddisconnecttarget;
    }

    /*
     * Unlock target WinStation but leave it referenced
     */
    UnlockWinStation( pTargetWinStation );


    /*
     * Relock the source WinStation
     */
    if ( !RelockWinStation( pSourceWinStation ) )
        goto sourcedeleted;

    /*
     * The source Winstation might have been deleted while it was unlocked.
     * Let's check this didn't happen because we don't want to reconnect to a
     * going away session (Bug#206614).
     */
    if (pSourceWinStation->Terminating || pSourceWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE)
        goto sourcedeleted;

    /*
     * If the source WinStation is currently connected, then disconnect it.
     */
    if ( pSourceWinStation->WinStationName[0] ) {
        SourceConnected = TRUE;

        /*
         * For single-instance transports a listener must be re-created upon disconnection
         * so we remember the source WinStation name.
         */
        if ( pSourceWinStation->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
            wcscpy( SourceWinStationName, pSourceWinStation->WinStationName );
        }

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "WinStationConnectWorker Disconnecting Source!\n"));


        /*
         * Note if we are disconnecting the session that owns the console
         */
        if (pSourceWinStation->fOwnsConsoleTerminal) {
            /*
             * If we are disconnecting the console session, we want to make sure
             * that we can precreate a session that would become the console session.
             */

            UnlockWinStation( pSourceWinStation );
            if ( !ShutdownInProgress) {
                Status = CheckIdleWinstation();
                if (!NT_SUCCESS(Status)) {
                    RelockWinStation(pSourceWinStation);
                    goto baddisconnectsource;
                }

            }

            bConsoleSession = TRUE;
            ENTERCRIT(&ConsoleLock);
            InterlockedIncrement(&gConsoleCreationDisable);
            LEAVECRIT(&ConsoleLock);
            if (!RelockWinStation( pSourceWinStation )) {
                Status = STATUS_CTX_WINSTATION_NOT_FOUND;
                goto baddisconnectsource;
            }

        }


        if(pSourceWinStation->pWsx &&
           pSourceWinStation->pWsx->pWsxSetErrorInfo &&
           pSourceWinStation->pWsxContext)
        {
            //
            // Extended error reporting, set status to client.
            //
            pSourceWinStation->pWsx->pWsxSetErrorInfo(
                               pSourceWinStation->pWsxContext,
                               TS_ERRINFO_DISCONNECTED_BY_OTHERCONNECTION,
                               FALSE); //stack lock not held
        }


        Status = WinStationDoDisconnect( pSourceWinStation, pSourceReconnectInfo, TRUE );
        if ( !NT_SUCCESS( Status ) )  {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "WinStationConnectWorker Disconnecting source failed Status = %x!\n", Status));
            goto baddisconnectsource;
        }

                                
    }

    /*
     * Cause the source WinStation to connect using the stack state
     * obtained from the target WinStation.
     */


    Status = WinStationDoReconnect( pSourceWinStation, pTargetReconnectInfo );



    if ( !NT_SUCCESS( Status ) )
        goto badconnectsource;

    /*
     * Indicate source WinStation connect is complete and unlock it.
     */
    pSourceWinStation->Flags &= ~WSF_CONNECT;

    /*
     * Set Last Reconnect Type for the Source WinStation
     */

    if (bAutoReconnecting) {
        pSourceWinStation->LastReconnectType = AutoReconnect;
    } else {
        pSourceWinStation->LastReconnectType = ManualReconnect;
    }

    ReleaseWinStation( pSourceWinStation );


    /*
     * Indicate target WinStation disconnect is complete and unlock it.
     */
    if ( RelockWinStation( pTargetWinStation ) ) {
        pTargetWinStation->Flags &= ~WSF_DISCONNECT;

        /*
         * Clear all client license data and indicate
         * this WinStaion no longer holds a license.
         */
        if ( pTargetWinStation->pWsx &&
             pTargetWinStation->pWsx->pWsxClearContext ) {
            pTargetWinStation->pWsx->pWsxClearContext( pTargetWinStation->pWsxContext );
        }
    }

    ReleaseWinStation( pTargetWinStation );

    /*
     * If the source WinStation was connected and we disconnected it above,
     * then make sure we cleanup the reconnect structure.
     * (This will also complete the disconnect by closing the endpoint
     * that was connected to the source WinStation).
     * Also, if the source WinStation was a single-instance transport,
     * then we must re-create the listener.
     */
    if ( SourceConnected ) {
        CleanupReconnect( pSourceReconnectInfo );
        if ( (pSourceReconnectInfo->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST) ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinstationConnectWorker create new winstation: %S \n ", SourceWinStationName));
            QueueWinStationCreate( SourceWinStationName );
        }
    }

    // Stop the listener if the target was the last WinStation.
     if ( gbListenerOff ) {

         StartStopListeners( NULL, FALSE );
     }

    goto done;

/*=============================================================================
==   Error returns
=============================================================================*/

    /*
     * Could not connect source WinStation
     */
badconnectsource:
    /*
     * If source WinStation was connected, try to reconnect if it is
     * NOT currently terminating.  If the reconnect does not succeed,
     * there's nothing else we can do.
     */
    if ( SourceConnected ) {
        CleanupReconnect( pSourceReconnectInfo );
        if ( !pSourceWinStation->Terminating &&
             !pSourceWinStation->WinStationName[0] ) {
            if ( pSourceReconnectInfo->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
                QueueWinStationCreate( pSourceReconnectInfo->WinStationName );
            }
        } 
    }

    /*
     * Could not disconnect source WinStation
     */
baddisconnectsource:

    /*
     * Source WinStation was deleted
     */
sourcedeleted:
    pSourceWinStation->Flags &= ~WSF_CONNECT;
    ReleaseWinStation( pSourceWinStation );
    pSourceWinStation = NULL;   // indicate source WinStation is released

    /*
     * Try to relock and reconnect the target WinStation.
     */
    if ( RelockWinStation( pTargetWinStation ) &&
         !pTargetWinStation->Terminating &&
         !pTargetWinStation->WinStationName[0] ) {
        NTSTATUS st;

        st = WinStationDoReconnect( pTargetWinStation, pTargetReconnectInfo );
        if ( !NT_SUCCESS( st ) ) {
            CleanupReconnect( pTargetReconnectInfo );
            if ( pTargetReconnectInfo->Config.Pd[0].Create.PdFlag & PD_SINGLE_INST ) {
                QueueWinStationCreate( pTargetReconnectInfo->WinStationName );
            }
        }
    } else {
        CleanupReconnect( pTargetReconnectInfo );
    }

    /*
     * Could not disconnect target WinStation
     * Could not query target WinStation stack state
     */
baddisconnecttarget:
    /* clear disconnect flag, unlock/derererence target WinStation */
    pTargetWinStation->Flags &= ~WSF_DISCONNECT;

    /*
     * Target WinStation is busy or is the console
     */
targetbusy:
badlicense:
targetnoconsole:
targetnoaccess:
    ReleaseWinStation( pTargetWinStation );

badname:
    /* clear connect flag, unlock/derererence source WinStation */
    if ( pSourceWinStation ) {
        if ( RelockWinStation( pSourceWinStation ) )
            pSourceWinStation->Flags &= ~WSF_CONNECT;
        ReleaseWinStation( pSourceWinStation );
    }

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationConnect, Status=0x%x\n", Status ));

    // If we disconnected a Session owning the console terminal, go an create a new one
    // to own it.

    if (bConsoleSession) {
        ENTERCRIT(&ConsoleLock);

        InterlockedDecrement(&gConsoleCreationDisable);





        if (!WinStationCheckConsoleSession()) {
            /*
             * Wake up the WinStationIdleControlThread
             */
            NtSetEvent(WinStationIdleControlEvent, NULL);

        }
        LEAVECRIT(&ConsoleLock);
    }

    // Increment total number of reconnected sessions
    if (Status == STATUS_SUCCESS) {
        InterlockedIncrement(&g_TermSrvReconSessions);
    }

    // free RECONNECT_INFO structures

    MemFree(pTargetReconnectInfo);
    MemFree(pSourceReconnectInfo);

    return( Status );
}


/*****************************************************************************
 *  WinStationResetWorker
 *
 *   Function to reset a Winstation based on an RPC API request.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationResetWorker(
    ULONG   LogonId,
    BOOLEAN bWait,
    BOOLEAN CallerIsRpc,
    BOOLEAN bRecreate
    )
{
    PWINSTATION pWinStation;
    ULONG ClientLogonId;
    WINSTATIONNAME ListenName;
    NTSTATUS Status;
    ULONG ulIndex;
    BOOL bConnectDisconnectPending = TRUE;
    BOOL bConsoleSession = FALSE;
    BOOL bListener = FALSE;
    UINT LocalFlag = 0;
    BOOLEAN bRelock;
    DWORD dwWaitStatus ; 
    DWORD dwTimeOut ; 

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationReset, LogonId=%d\n", LogonId ));

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * For non zero sessions which are connected and has not yet been initialized, wait for it to be initialized (for max 10 mins) 
     */

    if ((pWinStation->LogonId != 0) && (pWinStation->State == State_Connected)) {
        dwTimeOut = 10 * 60 * 1000 ; // 10 mins
        UnlockWinStation( pWinStation );
        dwWaitStatus = WaitForSingleObject(pWinStation->SessionInitializedEvent, dwTimeOut);  
        RelockWinStation( pWinStation );
        if (dwWaitStatus != WAIT_OBJECT_0) {
                KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationResetWorker: Timed out waiting for the Session to be initialized before Resetting. \n"));
                Status = STATUS_TIMEOUT;
                ReleaseWinStation( pWinStation );
                goto done ;
        }
    }

    /*
     * Note if we are disconnecting a session that is connected to the console terminal.
     */
    bConsoleSession = pWinStation->fOwnsConsoleTerminal;


    /*
     * If we are Resetting a non-zero console session, we want to make sure
     * that we can precreate a session that would become the console session.
     */
    if (bConsoleSession && !ShutdownInProgress && (pWinStation->LogonId != 0)) {
        UnlockWinStation(pWinStation);
        Status = CheckIdleWinstation();
        bRelock = RelockWinStation(pWinStation);
        if (!NT_SUCCESS(Status) || !bRelock) {
            if (NT_SUCCESS(Status)) {
                Status = STATUS_CTX_WINSTATION_NOT_FOUND;
            }
            ReleaseWinStation( pWinStation );
            goto done;
        }

    }


    /*
     * Save off the listen name if needed later.
     */
    if ( pWinStation->Flags & WSF_LISTEN ) {
        wcscpy(ListenName, pWinStation->WinStationName);
        bListener = TRUE;
    } else if (gbListenerOff) {
        wcscpy(ListenName, pWinStation->ListenName);
    }

    /*
     * Verify that client has RESET access if its an RPC (external) caller.
     *
     * When ICASRV calls this function internally, it is not impersonating
     * and fails the RpcCheckClientAccess() call. Internal calls are
     * not a security problem since they come in as LPC messages on a secured
     * port.
     */
    if ( CallerIsRpc ) {
        RPC_STATUS RpcStatus;

        /*
         * Impersonate the client
         */
        RpcStatus = RpcImpersonateClient( NULL );
        if ( RpcStatus != RPC_S_OK ) {
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationResetWorker: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_CANNOT_IMPERSONATE;
            goto done;
        }

        Status = RpcCheckClientAccess( pWinStation, WINSTATION_RESET, TRUE );
        if ( !NT_SUCCESS( Status ) ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            goto done;
        }

        //
        // If its remote RPC call we should ignore ClientLogonId
        //
        RpcStatus = I_RpcBindingIsClientLocal(
                        0,    // Active RPC call we are servicing
                        &LocalFlag
                        );

        if( RpcStatus != RPC_S_OK ) {
            RpcRevertToSelf();
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationResetWorker: IsClientLocal failed! RpcStatus 0x%x\n",RpcStatus));
            Status = STATUS_UNSUCCESSFUL;
            goto done;
        }

        if ( LocalFlag ) {
            Status = RpcGetClientLogonId( &ClientLogonId );
            if ( !NT_SUCCESS( Status ) ) {
                RpcRevertToSelf();
                ReleaseWinStation( pWinStation );
                goto done;
            }
        }

        RpcRevertToSelf();

        if(pWinStation->WinStationName[0] &&
           pWinStation->pWsx &&
           pWinStation->pWsx->pWsxSetErrorInfo &&
           pWinStation->pWsxContext)
        {
            pWinStation->pWsx->pWsxSetErrorInfo(
                               pWinStation->pWsxContext,
                               TS_ERRINFO_RPC_INITIATED_LOGOFF,
                               FALSE); //stack lock not held
        }
    }

    /*
     * For console reset, logoff (SALIMC)
     */
    if ( LogonId == 0 ) {

        Status = LogoffWinStation( pWinStation,EWX_FORCE | EWX_LOGOFF);
        ReleaseWinStation( pWinStation );
        if (NT_SUCCESS(Status) && bWait) {
           DWORD dwRet;
           dwRet = WaitForSingleObject(ConsoleLogoffEvent,120*1000);
           if (dwRet == WAIT_TIMEOUT)
           {
              KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: TimedOut wait for ConsoleLogoffEvent\n"));
              Status = STATUS_TIMEOUT;
           }
        }
        goto done;
    }

    /*
     * Mark the winstation as being reset.
     * If a reset/delete operation is already in progress
     * on this winstation, then don't proceed with the delete.
     * If the WinStation is currently in the process of connecting or
     * disconnecting, then give it some time to complete before we continue.
     * If connect/disconnect doesn't complete whithin timeout duration
     * do not proceed with termination (bug#204614).
     */
    for (ulIndex=0; ulIndex < WINSTATION_WAIT_COMPLETE_RETRIES; ulIndex++) {
        if ( pWinStation->Flags & (WSF_RESET | WSF_DELETE) ) {
            ReleaseWinStation( pWinStation );
            Status = STATUS_CTX_WINSTATION_BUSY;
            goto done;
        }

        if ( pWinStation->Flags & (WSF_CONNECT | WSF_DISCONNECT |
                                   WSF_AUTORECONNECTING) ) {
            LARGE_INTEGER Timeout;
            Timeout = RtlEnlargedIntegerMultiply( WINSTATION_WAIT_COMPLETE_DURATION, -10000 );
            UnlockWinStation( pWinStation );
            NtDelayExecution( FALSE, &Timeout );
            if ( !RelockWinStation( pWinStation ) ) {
                ReleaseWinStation( pWinStation );
                Status = STATUS_SUCCESS;
                goto done;
            }
        } else {
            bConnectDisconnectPending = FALSE;
            break;
        }
    }

    if ( bConnectDisconnectPending ) {
        ReleaseWinStation( pWinStation );
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto done;
    }

    pWinStation->Flags |= WSF_RESET;

    /*
     * If no broken reason/source have been set, then set them here.
     *
     * BrokenReason is Terminate.  BrokenSource is User if we are
     * called via RPC and caller is resetting his own LogonId, or if
     * the "Terminating" field is already set, then this is a reset
     * from the WinStationTerminateThread after seeing WinLogon/CSR exit.
     * Otherwise, this reset is the result of a call from another
     * WinStation or a QueueWinStationReset call from within ICASRV.
     */
    if ( pWinStation->BrokenReason == 0 ) {
        pWinStation->BrokenReason = Broken_Terminate;
        if ( CallerIsRpc && LocalFlag  && ClientLogonId == pWinStation->LogonId
             || pWinStation->Terminating ) {
            pWinStation->BrokenSource = BrokenSource_User;
        } else {
            pWinStation->BrokenSource = BrokenSource_Server;
        }
    }

    /*
     * If the RPC caller did not wish to wait for this reset,
     * then queue an internal call for this to be done.
     * This is safe now that we have done all of the above checks
     * to determine that the caller has access to perform the
     * reset and have set BrokenSource/Reason above.
     */
    if ( CallerIsRpc && !bWait ) {
        // clear reset flag so the internal reset will proceed
        pWinStation->Flags &= ~WSF_RESET;
        ReleaseWinStation( pWinStation );
        QueueWinStationReset( LogonId);
        Status = STATUS_SUCCESS;
        goto done;
    }

    /*
     * Make sure this WinStation is ready to reset
     */
    WinStationTerminate( pWinStation );

    /*
     * If it's a listener, reset all active winstations of the same type
     */
    if ((pWinStation->Flags & WSF_LISTEN) && ListenName[0] && bRecreate) {
        ResetGroupByListener(ListenName);
    }

    /*
     * If WinStation is marked DownPending (and is not disconnected),
     * then set it to the Down state, clear the DownPending and Reset flags,
     * and release the WinStation.
     */
    if ( (pWinStation->Flags & WSF_DOWNPENDING) && pWinStation->WinStationName[0] ) {
        pWinStation->State = State_Down;
        pWinStation->Flags &= ~(WSF_DOWNPENDING | WSF_RESET);
        ReleaseWinStation( pWinStation );
        Status = STATUS_SUCCESS;

    /*
     * The WinStation is not DownPending so complete deleting it
     * and then recreate it.
     */
    } else {
        ULONG PdFlag;
        ULONG WinStationFlags;
        WINSTATIONNAME WinStationName;

        /*
         * Save WinStation name for later create call
         */
        WinStationFlags = pWinStation->Flags;
        PdFlag = pWinStation->Config.Pd[0].Create.PdFlag;
        wcscpy( WinStationName, pWinStation->WinStationName );

        /*
         * Call the WinStationDelete worker
         */
        WinStationDeleteWorker( pWinStation );

        /*
         * Now recreate the WinStation
         */
        if ( WinStationName[0] &&
             bRecreate &&
             ((WinStationFlags & WSF_LISTEN) || (PdFlag & PD_SINGLE_INST)) ) {
            Status = WinStationCreateWorker( WinStationName, NULL, TRUE );
        } else if ( WinStationFlags & WSF_IDLE ) {
            // wake up WinStationIdleControlThread so that it recreates an idle session
            NtSetEvent(WinStationIdleControlEvent, NULL);
        } else {
            Status = STATUS_SUCCESS;
        }
    }

    // If we disconnected a Session owning the console terminal, go an create a new one
    // to own it.
    if (bConsoleSession) {
        ENTERCRIT(&ConsoleLock);
        if (!WinStationCheckConsoleSession()) {
            /*
             * Wake up the WinStationIdleControlThread
             */
            NtSetEvent(WinStationIdleControlEvent, NULL);

        }
        LEAVECRIT(&ConsoleLock);
    }

     if ( gbListenerOff && !bListener && ListenName[0] ) {

         StartStopListeners( ListenName, FALSE );
     }
    /*
     * Save return status
     */
done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationReset, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationShutdownSystemWorker
 *
 *   Function to shutdown the system from an RPC API request
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationShutdownSystemWorker(
    ULONG ClientLogonId,
    ULONG ShutdownFlags
    )
{
    BOOL     rc;
    BOOLEAN WasEnabled;
    NTSTATUS Status = 0;
    NTSTATUS Status2;
    PWINSTATION pWinStation;
    UINT ExitWindowsFlags;
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;


    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShutdownSystem, Flags=%d\n", ShutdownFlags ));

    /*
     * Impersonate the client so that when the attempt is made to enable
     * the SE_SHUTDOWN_PRIVILEGE, it will fail if the account is not admin.
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status =  STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    //
    // If its remote RPC call we should ignore ClientLogonId
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        Status = STATUS_UNSUCCESSFUL;
        goto done;
    }

    //
    // we dont care about client logon id if this is called from remote machine.
    // so lets set it zero. So its treated as shutdown from session 0.
    //
    if (!LocalFlag) {
        ClientLogonId = 0;
    }


    /*
     * We are called under RPC impersonation so that the current
     * thread token represents the RPC client. If the RPC client
     * does not have SE_SHUTDOWN_PRIVILEGE, the RtlAdjustPrivilege()
     * will fail.
     */
    Status = RtlAdjustPrivilege(
                 SE_SHUTDOWN_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 TRUE,    // Use Thread token (under impersonation)
                 &WasEnabled
                 );
    if( NT_SUCCESS( Status ) && !WasEnabled ) {
        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the shutdown privilege
         * if it was just a logoff force.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SHUTDOWN_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      TRUE,     // Use Thread token (under impersonation)
                      &WasEnabled
                      );

        ASSERT( NT_SUCCESS(Status2) );
    }

    RpcRevertToSelf();

    if ( Status == STATUS_NO_TOKEN ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: No Thread token!\n"));
        goto done;
    }

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: RtlAdjustPrivilege failure 0x%x\n",Status));
        goto done;
    }

    if ( ShutdownFlags == 0 )
        goto done;

    //
    // At this point we know that the client has access to shutdown the machine.
    // Now enable Shutdown privilege for the termsrv.exe process. This is done
    // because winlogon only allow system processes to shutdown the machine if
    // if no one is logged on the console session. If we just enable privilige
    // for the impersonating thread winlogon will not consider it as a system
    // process
    //
    Status = RtlAdjustPrivilege(
                 SE_SHUTDOWN_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 FALSE,   // Use Process Token
                 &WasEnabled
                 );
    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: RtlAdjustPrivilege failure 0x%x\n",Status));
        goto done;
    }

    /*
     * Set global shutdown flag
     */
    ShutdownInProgress = TRUE;

    // Let TS leave SD in case of shutdown
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
        DestroySessionDirectory();
    }

    /*
     * If logoff option is specified, then cause all WinStations
     * to logoff now and don't restart them.
     */
    if ( ShutdownFlags & (WSD_SHUTDOWN | WSD_LOGOFF) ) {
        Status = ShutdownLogoff( ClientLogonId, ShutdownFlags );
    }

    if ( ShutdownFlags & (WSD_SHUTDOWN | WSD_REBOOT | WSD_POWEROFF) ) {
        /*
         * If system will be rebooted or powered off, then cause
         * the client WinStation that called us to logoff now.
         * If shutdown from non-console, close the connection (self) here.
         */
        if ( (ShutdownFlags & (WSD_REBOOT | WSD_POWEROFF)) || ClientLogonId != 0) {
            
            if (!ShutDownFromSessionID)
                ShutDownFromSessionID = ClientLogonId;

            // ShutdownTerminateNoWait = TRUE;
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: Start reset of last WinStation\n" ));
            (VOID) DoForWinStationGroup( &ClientLogonId, 1,
                                         (LPTHREAD_START_ROUTINE) WinStationShutdownReset );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: Last WinStation reset\n" ));
            
            
            if ( ClientLogonId == 0 ) {

                DWORD dwRet;
                dwRet = WaitForSingleObject(ConsoleLogoffEvent,120*1000);
                if (dwRet == WAIT_TIMEOUT)
                {
                   KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationShutdownSystemWorker: Timedout waiting for ConsoleLogoffEvent\n"));
                   Status = STATUS_TIMEOUT;
                }
            }
        }

        /*
         * Now complete system shutdown.
         *
         * Use ExitWindowsEx() so that console winlogon completes
         * our shutdown. This is so that services get shutdown
         * properly.
         */
        if (ClientLogonId == (USER_SHARED_DATA->ActiveConsoleId) ) {
            ExitWindowsFlags = 0;
        } else {
            ExitWindowsFlags = EWX_FORCE;
        }
        if ( ShutdownFlags & WSD_REBOOT )
            ExitWindowsFlags |= EWX_REBOOT;
        else if ( ShutdownFlags & WSD_POWEROFF )
            ExitWindowsFlags |= EWX_POWEROFF;
        else
            ExitWindowsFlags |= EWX_SHUTDOWN;

        /*
         * Need to pass the EWX_TERMSRV_INITIATED to let winlogon know 
         * that the shutdown was initiated by termsrv.
         */
        rc = ExitWindowsEx( ExitWindowsFlags | EWX_TERMSRV_INITIATED,SHTDN_REASON_LEGACY_API|SHTDN_REASON_MINOR_TERMSRV );
        if( !rc ) {
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: ExitWindowsEx failed %d\n",GetLastError() ));
        }
    }

    if( !WasEnabled ) {

        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the shutdown privilege
         * if it was just a logoff force.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SHUTDOWN_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      FALSE,    // Use Process Token
                      &WasEnabled
                      );
        ASSERT( NT_SUCCESS(Status2) );
    }

    /*
     * Save return status in API message
     */
done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationShutdownSystem, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationTerminateProcessWorker
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 ****************************************************************************/
NTSTATUS
WinStationTerminateProcessWorker(
    ULONG  ProcessId,
    ULONG  ExitCode
    )
{
    OBJECT_ATTRIBUTES Obja;
    CLIENT_ID ClientId;
    BOOLEAN fWasEnabled = FALSE;
    NTSTATUS Status;
    NTSTATUS Status2;
    SID_IDENTIFIER_AUTHORITY NtSidAuthority = SECURITY_NT_AUTHORITY;
    HANDLE ProcHandle = NULL;
    HANDLE TokenHandle = NULL;
    PTOKEN_USER pTokenInfo = NULL;
    ULONG TokenInfoLength;
    ULONG ReturnLength;
    int rc;

    TRACE(( hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationTerminateProcess, PID=%d, ExitCode %u\n",
            ProcessId, ExitCode ));

    /*
     *  If possible, enable the debug privilege
     */
    (void) RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE,
                               TRUE,    // Enable the PRIVILEGE
                               TRUE,    // Use Thread token (under impersonation)
                               &fWasEnabled );

    /*
     * Attempt to open the process for query and terminate access.
     */
    ClientId.UniqueThread  = (HANDLE) NULL;
    ClientId.UniqueProcess = (HANDLE) LongToHandle( ProcessId );
    InitializeObjectAttributes( &Obja, NULL, 0, NULL, NULL );
    Status = NtOpenProcess( &ProcHandle,
                            PROCESS_QUERY_INFORMATION | PROCESS_TERMINATE,
                            &Obja,
                            &ClientId );
    if ( !NT_SUCCESS(Status) )
        goto restore;

    /*
     * Open the process token so we can query the user SID.  If the user
     * SID for this process is the SYSTEM SID, we will deny access to it.
     * This is to prevent ADMINs from killing system processes.
     */
    Status = NtOpenProcessToken( ProcHandle, TOKEN_QUERY, &TokenHandle );

    /*
     * Its possible for OpenProcess above to succeed and NtOpenProcessToken
     * to fail.  One scenario is an ADMIN user trying to kill a USER process.
     * Standard security allows ADMIN terminate access to the process but
     * does not allow any access to the process token.  In this case we
     * will just skip the SID check and do the terminate below.
     */
    if ( NT_SUCCESS( Status ) ) {
        /*
         * Allocate buffer for reading user SID
         */
        TokenInfoLength = sizeof(TOKEN_USER) +
                          RtlLengthRequiredSid( SID_MAX_SUB_AUTHORITIES );
        pTokenInfo = MemAlloc( TokenInfoLength );
        if ( pTokenInfo == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto freeit;
        }

        /*
         * Query the user SID in the token
         */
        Status = NtQueryInformationToken( TokenHandle, TokenUser, pTokenInfo,
                                          TokenInfoLength, &ReturnLength );
        if ( !NT_SUCCESS( Status ) )
            goto freeit;

        /*
         * If user SID for this process is the SYSTEM SID,
         * then we don't allow it to be terminated.
         */
        if ( RtlEqualSid( gSystemSid, pTokenInfo->User.Sid ) ) {
            Status = STATUS_ACCESS_DENIED;
            goto freeit;
        }
    }

    /*
     * Now try to terminate the process
     */
    Status = NtTerminateProcess( ProcHandle, (NTSTATUS)ExitCode );

freeit:
    if ( pTokenInfo )
        MemFree( pTokenInfo );

    if ( TokenHandle )
        CloseHandle( TokenHandle );

    if ( ProcHandle )
        CloseHandle( ProcHandle );

restore:
    if( !fWasEnabled ) {

        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need. So we must disable the debug privilege
         * if it was not enabled on entry to this routine.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_DEBUG_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      TRUE,     // Use Thread token (under impersonation)
                      &fWasEnabled
                      );

        ASSERT( NT_SUCCESS(Status2) );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationTerminateProcess, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationWaitSystemEventWorker
 *
 *   Function to wait for a system event from an RPC API request.
 *
 *   Only one event wait may be posted per server handle at a time. The
 *   code protects itself from misuse by returning STATUS_PIPE_BUSY if
 *   an eventwait is already outstanding, and the request is not a cancel.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationWaitSystemEventWorker(
    HANDLE hServer,
    ULONG EventMask,
    PULONG pEventFlags
    )
{
    NTSTATUS Status;
    PEVENT pWaitEvent;
    OBJECT_ATTRIBUTES ObjA;
    PRPC_CLIENT_CONTEXT pContext = (PRPC_CLIENT_CONTEXT)hServer;
    static long s_cEvents = 0; //Used to count events in SystemEvent list.
                             //Protected by "WinStationListLock" Critical Section.
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEventWorker, Mask=0x%08x\n", EventMask ));
    ASSERT( MAX_WINSTATION_RPC_THREADS > MAX_SYSTEM_EVENTS);   
    /*
     * Protect ourselves from multiple threads calling in at once
     */
    RtlEnterCriticalSection( &WinStationListLock );
        
    /*
     * If client doesn't already have an event block,
     * then allocate and initialize one now.
     */
    if ( pContext->pWaitEvent == NULL ) {

        // If event mask is null or flush specified, then nothing to do
        if ( EventMask == WEVENT_NONE || (EventMask & WEVENT_FLUSH) ) {
            Status = STATUS_SUCCESS;
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }
        
        if(s_cEvents == MAX_SYSTEM_EVENTS)
        {
            Status = STATUS_PIPE_BUSY;
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }

        /*
         * Allocate event block and initialize it
         */
        if ( (pWaitEvent = MemAlloc( sizeof(EVENT) )) == NULL ) {
            Status = STATUS_NO_MEMORY;
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }
        RtlZeroMemory( pWaitEvent, sizeof(EVENT) );

        pWaitEvent->fWaiter = FALSE;
        pWaitEvent->EventMask = EventMask;
        pWaitEvent->EventFlags = 0;

        /*
         * Create an event to wait on
         */
        InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
        Status = NtCreateEvent( &pWaitEvent->Event, EVENT_ALL_ACCESS, &ObjA,
                                NotificationEvent, FALSE );

        if( !NT_SUCCESS(Status) ) {
            MemFree( pWaitEvent );
            RtlLeaveCriticalSection( &WinStationListLock );
            goto done;
        }
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Event=%p\n", pWaitEvent->Event ));

        TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: WinStationWaitSystemEvent, Event block=%p\n", pWaitEvent ));

        /*
         * Save event block pointer in RPC client context structure
         * and insert in system event list.
         */
        pContext->pWaitEvent = pWaitEvent;
        InsertTailList( &SystemEventHead, &pWaitEvent->EventListEntry );
        
        s_cEvents++;
        ASSERT(s_cEvents <= MAX_SYSTEM_EVENTS);
        /*
         * Wait for the event to be signaled
         */
        pWaitEvent->fWaiter = TRUE;
        RtlLeaveCriticalSection( &WinStationListLock );
        Status = WaitForSingleObject( pWaitEvent->Event, (DWORD)-1 );
        RtlEnterCriticalSection( &WinStationListLock );
        pWaitEvent->fWaiter = FALSE;

        if ( NT_SUCCESS(Status) ) {
            Status = pWaitEvent->WaitResult;
            if( NT_SUCCESS(Status) ) {
                *pEventFlags = pWaitEvent->EventFlags;
                /*
                * makarp - Fix For . (#21929)
                */
                pWaitEvent->EventFlags = 0;
            }
        }

        /*
         * If fClosing is set, then cleanup the eventwait entry and free it.
         */
        if ( pWaitEvent->fClosing ) {
            pContext->pWaitEvent = NULL;
            RemoveEntryList( &pWaitEvent->EventListEntry );
            s_cEvents--;
            ASSERT(s_cEvents >= 0);
            RtlLeaveCriticalSection( &WinStationListLock );
            NtClose( pWaitEvent->Event );
            pWaitEvent->Event = NULL;
            MemFree( pWaitEvent );
        } else {
            RtlLeaveCriticalSection( &WinStationListLock );
        }
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
        return( Status );

    /*
     * Client has an event block but wants to remove it
     */
    } else if ( EventMask == WEVENT_NONE ) {

        pWaitEvent = pContext->pWaitEvent;

        // If we have a waiter, mark the eventwait struct as closing
        // and let the waiter clean up.
        if ( pWaitEvent->fWaiter ) {
            pWaitEvent->fClosing = TRUE;
            pWaitEvent->WaitResult = STATUS_CANCELLED;
            NtSetEvent( pWaitEvent->Event, NULL );
            RtlLeaveCriticalSection( &WinStationListLock );
            Status = STATUS_SUCCESS;
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
            return( Status );
        }
        pContext->pWaitEvent = NULL;
        RemoveEntryList( &pWaitEvent->EventListEntry );
        s_cEvents--;
        ASSERT(s_cEvents >= 0);
        RtlLeaveCriticalSection( &WinStationListLock );
        NtClose( pWaitEvent->Event );
        pWaitEvent->Event = NULL;
        MemFree( pWaitEvent );
        Status = STATUS_SUCCESS;
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
        return( Status );

    /*
     * Flush specified so we must release waiting client
     */
    } else if ( EventMask & WEVENT_FLUSH ) {
        pWaitEvent = pContext->pWaitEvent;
        if ( pWaitEvent->fWaiter ) {
            pWaitEvent->WaitResult = STATUS_CANCELLED;
            NtSetEvent( pWaitEvent->Event, NULL );
            TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: WinStationWaitSystemEvent, event wait cancelled\n" ));
        }
        RtlLeaveCriticalSection( &WinStationListLock );
        Status = STATUS_SUCCESS;
        TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
        return( Status );

    /*
     * Client already has an event block and is calling again
     * to wait for another event.  Update the EventMask in case it
     * changed from the original call.
     */
    } else {

        pWaitEvent = pContext->pWaitEvent;

        // Only allow one waiter
        if ( pWaitEvent->fWaiter ) {
            RtlLeaveCriticalSection( &WinStationListLock );
            Status = STATUS_PIPE_BUSY;
            TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
            return( Status );
        }

        pWaitEvent->EventMask = EventMask;

        /*
         * If additional events occured while client was processing
         * previous events, then just return to the client now.
         */
        if ( pWaitEvent->EventFlags &= EventMask ) {
            *pEventFlags = pWaitEvent->EventFlags;
            pWaitEvent->EventFlags = 0;
            Status = STATUS_SUCCESS;
            RtlLeaveCriticalSection( &WinStationListLock );
            TRACE((hTrace,TC_ICAAPI,TT_API3, "TERMSRV: WinStationWaitSystemEvent, returning immediately\n" ));
               return( Status );
        } else {

            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, waiting for event\n" ));

            // Reset the event
            NtResetEvent( pWaitEvent->Event, NULL );

            /*
             * Wait for the event to be signaled
             */
            pWaitEvent->fWaiter = TRUE;
            RtlLeaveCriticalSection( &WinStationListLock );
            Status = WaitForSingleObject( pWaitEvent->Event, (DWORD)-1 );
            RtlEnterCriticalSection( &WinStationListLock );
            pWaitEvent->fWaiter = FALSE;

            if( NT_SUCCESS(Status) ) {
                Status = pWaitEvent->WaitResult;
                if( NT_SUCCESS(Status) ) {
                    *pEventFlags = pWaitEvent->EventFlags;
                    /*
                     * makarp - Fix For . (#21929)
                     */
                    pWaitEvent->EventFlags = 0;
                }
            }

            /*
             * If fClosing is set, then cleanup the eventwait entry and free it.
             */
            if ( pWaitEvent->fClosing ) {
                pContext->pWaitEvent = NULL;
                RemoveEntryList( &pWaitEvent->EventListEntry );
                s_cEvents--;
                ASSERT(s_cEvents >= 0);
                RtlLeaveCriticalSection( &WinStationListLock );
                NtClose( pWaitEvent->Event );
                pWaitEvent->Event = NULL;
                MemFree( pWaitEvent );
            } else {
                RtlLeaveCriticalSection( &WinStationListLock );
            }
            TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
               return( Status );
        }
    }

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationWaitSystemEvent, Status=0x%x\n", Status ));
    return( Status );
}


/*****************************************************************************
 *  WinStationCallbackWorker
 *
 *   Perform callback processing for the specified WinStation.
 *
 * ENTRY:
 *    LogonId (input)
 *      Logon Id of WinStation
 *    pPhoneNumber (input)
 *      Phone number string suitable for processing by TAPI
 ****************************************************************************/
NTSTATUS
WinStationCallbackWorker(
    ULONG  LogonId,
    PWCHAR pPhoneNumber
    )
{
    PWINSTATION pWinStation;
    NTSTATUS Status;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        return( Status );
    }

    /*
     * Unlock WinStation while Callback is in progress
     */
    UnlockWinStation( pWinStation );

    if (pWinStation->hStack != NULL) {
        Status = IcaStackCallback( pWinStation->hStack,
                                   &pWinStation->Config,
                                   pPhoneNumber,
                                   pWinStation->pEndpoint,
                                   pWinStation->EndpointLength,
                                   &pWinStation->EndpointLength );
    } else {
        Status = STATUS_INVALID_PARAMETER;

    }

    return( Status );
}


/*****************************************************************************
 *  WinStationBreakPointWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 *
 * ENTRY:
 *    pContext (input)
 *      Pointer to our context structure describing the connection.
 *
 *    pMsg (input/output)
 *      Pointer to the API message, a superset of NT LPC PORT_MESSAGE.
 ****************************************************************************/
NTSTATUS
WinStationBreakPointWorker(
    ULONG   LogonId,
    BOOLEAN KernelFlag
    )
{
    NTSTATUS Status;
    NTSTATUS Status2;
    BOOLEAN WasEnabled;
    WINSTATION_APIMSG WMsg;
    PWINSTATION pWinStation;

    /*
     * We are called under RPC impersonation so that the current
     * thread token represents the RPC client. If the RPC client
     * does not have SE_SHUTDOWN_PRIVILEGE, the RtlAdjustPrivilege()
     * will fail.
     *
     * SE_SHUTDOWN_PRIVILEGE is used for breakpoints because that is
     * effectively what a break point does to the system.
     */
    Status = RtlAdjustPrivilege(
                 SE_SHUTDOWN_PRIVILEGE,
                 TRUE,    // Enable the PRIVILEGE
                 TRUE,    // Use Thread token (under impersonation)
                 &WasEnabled
                 );

    if ( Status == STATUS_NO_TOKEN ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationBreakPointWorker: No Thread token!\n"));
        return( Status );
    }

    if ( !NT_SUCCESS( Status ) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationBreakPointWorker: RtlAdjustPrivilege failure 0x%x\n",Status));
        return( Status );
    }

    /*
     * Stop here if that's what was requested
     */
    if ( LogonId == (ULONG)-2 ) {
        DbgBreakPoint();
        Status = STATUS_SUCCESS;
        goto Done;
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto Done;
    }

    /*
     * Tell the WinStation to breakpoint
     */

    WMsg.ApiNumber = SMWinStationDoBreakPoint;
    WMsg.u.BreakPoint.KernelFlag = KernelFlag;
    Status = SendWinStationCommand( pWinStation, &WMsg, 0 );

    ReleaseWinStation( pWinStation );

Done:

    if( !WasEnabled ) {
        /*
         * Principle of least rights says to not go around with privileges
         * held you do not need.
         */
        Status2 = RtlAdjustPrivilege(
                      SE_SHUTDOWN_PRIVILEGE,
                      FALSE,    // Disable the PRIVILEGE
                      TRUE,     // Use Thread token (under impersonation)
                      &WasEnabled
                      );

        ASSERT( NT_SUCCESS(Status2) );
    }

    return( Status );
}


NTSTATUS
WinStationEnableSessionIo( 
    PWINSTATION pWinStation, 
    BOOL bEnable
    )
/*++

Description:

    Funtion to disable keyboard and mouse input from session, this is to prevent
    security hole that a hacker can send keystrock to bring up utility manager 
    before shadowing.

Parameters:

    pWinStation (INPUT) : Pointer to winstation, function will ignore if session is 
                          not a help session.
    bEnable (INPUT) : TRUE to enable keyboard/mouse, FALSE otherwise.

Returns:

    ...

Note:

WINSTATION structure must be locked. Two new IOCTL code so we don't introduce any regression.
    

--*/
{
    HANDLE ChannelHandle;
    NTSTATUS Status;

    if( pWinStation->fOwnsConsoleTerminal )
    {
        //
        // Don't want to disable mouse/keyboard input on active console session,
        //
        Status = STATUS_SUCCESS;
    }
    else
    {
        Status = IcaChannelOpen( 
                            pWinStation->hIca,
                            Channel_Keyboard,
                            NULL,
                            &ChannelHandle 
                        );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaChannelIoControl( 
                                    ChannelHandle,
                                    (bEnable) ? IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO : IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO,
                                    NULL, 0, NULL, 0, NULL 
                                );
            IcaChannelClose( ChannelHandle );
        }

        Status = IcaChannelOpen( 
                            pWinStation->hIca,
                            Channel_Mouse,
                            NULL,
                            &ChannelHandle 
                        );
        if ( NT_SUCCESS( Status ) ) {
            Status = IcaChannelIoControl( ChannelHandle,
                                          (bEnable) ? IOCTL_ICA_CHANNEL_ENABLE_SESSION_IO : IOCTL_ICA_CHANNEL_DISABLE_SESSION_IO,
                                          NULL, 0, NULL, 0, NULL );
            IcaChannelClose( ChannelHandle );    
        }
    }

    return Status;
}

/*****************************************************************************
 *  WinStationNotifyLogonWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 ****************************************************************************/
NTSTATUS WinStationNotifyLogonWorker(
        DWORD   ClientLogonId,
        DWORD   ClientProcessId,
        BOOLEAN fUserIsAdmin,
        DWORD   UserToken,
        PWCHAR  pDomain,
        DWORD   DomainSize,
        PWCHAR  pUserName,
        DWORD   UserNameSize,
        PWCHAR  pPassword,
        DWORD   PasswordSize,
        UCHAR   Seed,
        PCHAR   pUserConfig,
        DWORD   ConfigSize,
        BOOLEAN *pfIsRedirected
        )
{
    extern GENERIC_MAPPING WinStaMapping;
    extern LPCWSTR szTermsrv;
    extern LPCWSTR szTermsrvSession;

    PWINSTATION pWinStation;
    HANDLE ClientToken, NewToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    HANDLE ImpersonationToken;
    PTOKEN_USER TokenInfo;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG UserNameLength = USERNAME_LENGTH;
    ULONG DomainLength = DOMAIN_LENGTH;
    BOOL bAccessCheckOk = FALSE;
    DWORD GrantedAccess;
    BOOL AccessStatus;
    BOOL fGenerateOnClose;
    PTSSD_CreateSessionInfo pCreateInfo = NULL;
    BOOL bHaveCreateInfo = FALSE;
    BOOL bQueueReset = FALSE;
    BOOL bRedirect = FALSE;     // TRUE: redirect this connection
    BOOL bValidHelpSession;
    BOOL bNoAccessCheck = FALSE;
    BOOL fReconnectingToConsole = FALSE;
    BOOL RetValue = FALSE;


    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogon, LogonId=%d\n", ClientLogonId ));

    *pfIsRedirected = FALSE;
    
    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        return Status;
    }
    
    //Since we don't need the password anymore, clean it up
    if (pWinStation->pNewClientCredentials != NULL) {
        RtlSecureZeroMemory(pWinStation->pNewClientCredentials->Password,
            sizeof(pWinStation->pNewClientCredentials->Password));
    }
    
    RtlSecureZeroMemory(pWinStation->Config.Config.User.Password,
        sizeof(pWinStation->Config.Config.User.Password));

    if( sizeof( USERCONFIGW ) > ConfigSize ) {
        ReleaseWinStation( pWinStation );
        return( STATUS_ACCESS_VIOLATION );
    }

    //
    // If this is a notification from Session 0, then clear the Mpr notification information
    // Termsrv already erases this after query, but since this is critical information, lets Erase everything again
    // This is to take care of the case where reconnect to Session 0 failed for some reason and we do not Erase these after Query
    //

    if (ClientLogonId == 0) {
        RtlSecureZeroMemory( g_MprNotifyInfo.Domain, wcslen(g_MprNotifyInfo.Domain) * sizeof(WCHAR) );
        RtlSecureZeroMemory( g_MprNotifyInfo.UserName, wcslen(g_MprNotifyInfo.UserName) * sizeof(WCHAR) );
        RtlSecureZeroMemory( g_MprNotifyInfo.Password, wcslen(g_MprNotifyInfo.Password) * sizeof(WCHAR) );
    }

    if ( ShutdownInProgress ) {
        ReleaseWinStation( pWinStation );
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    pCreateInfo = MemAlloc(sizeof(TSSD_CreateSessionInfo));
    if (NULL == pCreateInfo) {
        ReleaseWinStation( pWinStation );
        return ( STATUS_NO_MEMORY ); 
    }
    
    //
    // Release filtered address
    //
    if (pWinStation->pRememberedAddress != NULL) {
        Filter_RemoveOutstandingConnection( &pWinStation->pRememberedAddress->addr[0], pWinStation->pRememberedAddress->length );
        MemFree(pWinStation->pRememberedAddress);
        pWinStation->pRememberedAddress = NULL;
        if( (ULONG)InterlockedDecrement( &NumOutStandingConnect ) == MaxOutStandingConnect )
        {
           if (hConnectEvent != NULL)
           {
               SetEvent(hConnectEvent);
           }
        }


    }

    // The client has communicated its initial configuration
    // information. Check if we need to redirect the client for
    // load balancing. Ignore the console!
    // Note: Only go through this if SD is enabled, i.e. GetTSSD() returns valid value
    if (ClientLogonId != 0 && !g_bPersonalTS && g_fAppCompat && g_bAdvancedServer && GetTSSD()) {
        PTS_LOAD_BALANCE_INFO pLBInfo = NULL;
        PWINSTATION pTargetWinStation = pWinStation;
        ULONG ReturnLength;
        BOOL bSuccess = FALSE;

        pLBInfo = MemAlloc(sizeof(TS_LOAD_BALANCE_INFO));
        if (NULL == pLBInfo) {
            Status = STATUS_NO_MEMORY;
            if (pWinStation->pNewNotificationCredentials != NULL) {
                MemFree(pWinStation->pNewNotificationCredentials);
                pWinStation->pNewNotificationCredentials = NULL;
            }
            ReleaseWinStation( pWinStation );
            goto done;
        }

        // need to release it
        ReleaseTSSD();
    
        // Get the client load balance capability info. We continue onward
        // to do a session directory query only when the client supports
        // redirection and has not already been redirected to this server.
        memset(pLBInfo, 0, sizeof(TS_LOAD_BALANCE_INFO));
        Status = IcaStackIoControl(pTargetWinStation->hStack,
                IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                NULL, 0,
                pLBInfo, sizeof(TS_LOAD_BALANCE_INFO),
                &ReturnLength);
               
        // Only check for possible redirection if this is the initial request
        if (NT_SUCCESS(Status) && !pLBInfo->bRequestedSessionIDFieldValid) {
            // On non-success, we'll have FALSE for all of our entries, on
            // success valid values. So, save off the cluster info into the
            // WinStation struct now.
            pTargetWinStation->bClientSupportsRedirection =
                    pLBInfo->bClientSupportsRedirection;
            pTargetWinStation->bRequestedSessionIDFieldValid =
                    pLBInfo->bRequestedSessionIDFieldValid;
            pTargetWinStation->bClientRequireServerAddr =
                    pLBInfo->bClientRequireServerAddr;
            pTargetWinStation->RequestedSessionID = pLBInfo->RequestedSessionID;
        
            // Use the name & domain they used to actually log on
            memset(pLBInfo->Domain, 0, sizeof(pLBInfo->Domain));
            memset(pLBInfo->UserName, 0, sizeof(pLBInfo->UserName));        
            wcsncpy(pLBInfo->Domain, pDomain, DomainLength);
            wcsncpy(pLBInfo->UserName, pUserName, UserNameLength);

            TRACE((hTrace,TC_LOAD,TT_API1, 
                    "Client LBInfo: Supports Redirect [%lx], "
                    "Session Id valid [%lx]:%lx, "
                    "Creds [%S\\%S]\n",
                    pLBInfo->bClientSupportsRedirection,
                    pLBInfo->bRequestedSessionIDFieldValid,
                    pLBInfo->RequestedSessionID,
                    pLBInfo->UserName, pLBInfo->Domain));

            wcsncpy(pLBInfo->Password, pPassword, PasswordSize);

            bSuccess = SessDirCheckRedirectClient(pTargetWinStation, pLBInfo);

            // Clear password
            if (0 != PasswordSize)
                SecureZeroMemory(pLBInfo->Password, PasswordSize);

            if (bSuccess) {
                // The client should drop the socket, and we'll
                // go ahead and drop this ongoing connection.
                // Set an error status.
                Status = STATUS_UNSUCCESSFUL;
                *pfIsRedirected = TRUE;
                bRedirect = TRUE;

                TRACE((hTrace,TC_LOAD,TT_API1, 
                       "Disconnected session found: redirecting client!\n"));

                if (pLBInfo != NULL) {
                    MemFree(pLBInfo);
                    pLBInfo = NULL;
                }

                goto release;
            }
            else {              
                TRACE((hTrace,TC_LOAD,TT_API1, 
                       "Disconnected session not found: status [%lx], pers [%ld], appcompat [%ld]\n",
                       Status, g_bPersonalTS, g_fAppCompat));
            }
        }

        if (pLBInfo != NULL) {
            MemFree(pLBInfo);
            pLBInfo = NULL;
        }
    }
    

    if (ClientLogonId == 0) {
       //
       //ReSet the Console Logon Event
       //
       KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_INFO_LEVEL, "TERMSRV: WinStationNotifyLogon, ReSetting ConsoleLogoffEvent\n"));
       NtResetEvent(ConsoleLogoffEvent, NULL);
    }
    /*
     * Do not do anything if the session is not connected. The processing in this API assumes we are connected and have a
     * valid stack.
     */
    
    if ((ClientLogonId != 0) && ((pWinStation->State != State_Connected) ||  pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
        Status = STATUS_CTX_CLOSE_PENDING;
        if (pWinStation->pNewNotificationCredentials != NULL) {
            MemFree(pWinStation->pNewNotificationCredentials);
            pWinStation->pNewNotificationCredentials = NULL;
        }
        ReleaseWinStation( pWinStation );
        goto done;
    }
    

    if (ClientLogonId == 0 && !bConsoleConnected ){

       Status = WaitForConsoleConnectWorker(  pWinStation );
       if (NT_SUCCESS(Status)) {
           bConsoleConnected=TRUE;
       } else {
           if (pWinStation->pNewNotificationCredentials != NULL) {
               MemFree(pWinStation->pNewNotificationCredentials);
               pWinStation->pNewNotificationCredentials = NULL;
           }
           ReleaseWinStation( pWinStation );
           goto done;
       }
    }

    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        /*
         * The console has a special problem with NTSD starting winlogon.
         * It doesn't get notified until now what the PID if winlogon.exe
         * instead of ntsd.exe is.
         */
        if ( !pWinStation->LogonId && !pWinStation->InitialProcessSet ) {
            pWinStation->InitialCommandProcess = OpenProcess(
                PROCESS_ALL_ACCESS,
                FALSE,
                (DWORD) ClientProcessId );

            if ( pWinStation->InitialCommandProcess == NULL ) {
                Status = STATUS_ACCESS_DENIED;
                if (pWinStation->pNewNotificationCredentials != NULL) {
                    MemFree(pWinStation->pNewNotificationCredentials);
                    pWinStation->pNewNotificationCredentials = NULL;
                }
                ReleaseWinStation( pWinStation );
                goto done;
            }
            pWinStation->InitialCommandProcessId = (HANDLE)(ULONG_PTR)ClientProcessId;
            pWinStation->InitialProcessSet = TRUE;

        }
        else {
            //Set flag saying that WinStationNotifyLogonWorker 
            //was successfully completed
            pWinStation->StateFlags |= WSF_ST_LOGON_NOTIFIED;
            if (pWinStation->pNewNotificationCredentials != NULL) {
                MemFree(pWinStation->pNewNotificationCredentials);
                pWinStation->pNewNotificationCredentials = NULL;
            }
            ReleaseWinStation( pWinStation );
            Status = STATUS_SUCCESS;
            goto done;
        }
    }

    /*
     * Verify the client license if appropriate
     */
    if ( pWinStation->pWsx && pWinStation->pWsx->pWsxVerifyClientLicense ) {
        Status = pWinStation->pWsx->pWsxVerifyClientLicense(
                pWinStation->pWsxContext,
                pWinStation->Config.Pd[0].Create.SdClass);
    }

    if ( Status != STATUS_SUCCESS) {
        if (pWinStation->pNewNotificationCredentials != NULL) {
            MemFree(pWinStation->pNewNotificationCredentials);
            pWinStation->pNewNotificationCredentials = NULL;
        }
        ReleaseWinStation( pWinStation );
        goto done;
    }

    //
    //  DON'T CHECK RpcClientAccess. The client is always winlogon (verified
    //  before the call to this function) so this call does not check against
    //  the actual user logging in. This is done further down from here.
    //
#if 0
    if (ClientLogonId != 0)
    {
        Status = RpcCheckClientAccess( pWinStation, WINSTATION_LOGON, FALSE );
        if ( !NT_SUCCESS( Status ) ) {
            if (pWinStation->pNewNotificationCredentials != NULL) {
                MemFree(pWinStation->pNewNotificationCredentials);
                pWinStation->pNewNotificationCredentials = NULL;
            }
            ReleaseWinStation( pWinStation );
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogon, RpcCheckClientAccess failed=%x\n", Status ));
            goto done;
        }
    }
#endif

    /*
     * Save user status
     *
     * NOTE: This flag should only be used by the annoyance thread,
     *       and not for any security sensitive operations. All
     *       security sensitive operations need to go through the
     *       NT SeAccessCheck so that auditing is done properly.
     */

    pWinStation->fUserIsAdmin = fUserIsAdmin;

    if (!ClientLogonId && !pWinStation->pWsx) {
        PLIST_ENTRY Head, Next;
        PWSEXTENSION pWsx;
        ICASRVPROCADDR IcaSrvProcAddr;

        RtlEnterCriticalSection( &WsxListLock );

        Head = &WsxListHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
            if ( pWsx->pWsxGetLicense ) {
                if (!pWinStation->pWsxContext && pWsx->pWsxWinStationInitialize) {
                    Status = pWsx->pWsxWinStationInitialize(&pWinStation->pWsxContext);
                }
                Status = pWsx->pWsxGetLicense(pWinStation->pWsxContext,
                                              pWinStation->hStack,
                                              pWinStation->LogonId,
                                              fUserIsAdmin);
                break;
           }
        }

        RtlLeaveCriticalSection( &WsxListLock );
    } else {
        if ( pWinStation->pWsx && pWinStation->pWsx->pWsxGetLicense ) {
            Status = pWinStation->pWsx->pWsxGetLicense( pWinStation->pWsxContext,
                                                        pWinStation->hStack,
                                                        pWinStation->LogonId,
                                                        fUserIsAdmin );
        }
    }

    if ( Status != STATUS_SUCCESS) {
        HANDLE h;
        PWSTR Strings[2];

        /*
         * Send event to event log
         */
        h = RegisterEventSource(NULL, gpszServiceName);
        if (h) {
           //
           //  Would have used UserName and Domain in this error message,
           //  but they aren't set yet.
           //
           Strings[0] = pUserName;
           Strings[1] = pDomain;
           ReportEvent(h, EVENTLOG_WARNING_TYPE, 0, EVENT_NO_LICENSES, NULL, 2, 0, Strings, NULL);
           DeregisterEventSource(h);
        }
        if (pWinStation->pNewNotificationCredentials != NULL) {
            MemFree(pWinStation->pNewNotificationCredentials);
            pWinStation->pNewNotificationCredentials = NULL;
        }
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Get a valid copy of the clients token handle
     */
    Status = NtDuplicateObject( pWinStation->InitialCommandProcess,
                                (HANDLE)LongToHandle( UserToken ),
                                NtCurrentProcess(),
                                &ClientToken,
                                0, 0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );
    if ( !NT_SUCCESS( Status ) )
        goto baddupobject;

    /*
     * ClientToken is a primary token - create an impersonation token
     * version of it so we can set it on our thread
     */
    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;


    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );
    if ( !NT_SUCCESS( Status ) )
        goto badduptoken;

    /*
     * Impersonate the client
     */
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     (ULONG)sizeof(HANDLE) );
    if ( !NT_SUCCESS( Status ) )
        goto badimpersonate;

    //
    //  security check
    //
    Status = ApplyWinStaMapping( pWinStation );
    if( !NT_SUCCESS( Status ) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogon, ApplyWinStaMapping failed=%x\n", Status ));
        goto noaccess;
    }

    // There is a race condition between this function and Reconnect - we may reach here when Reconnect is still pending 
    // In that case the ActiveConsoleId is -1 and we do access check for a non-admin user - this leads to access check failure
    // Check for this special case and dont call AccessCheck for this Special case

    fReconnectingToConsole = pWinStation->fReconnectingToConsole;

    if ( (ClientLogonId == 0) && (USER_SHARED_DATA->ActiveConsoleId == -1) && (pWinStation->fReconnectPending) && (pWinStation->fReconnectingToConsole) ) {
        bNoAccessCheck = TRUE ; 
    }

    if (bNoAccessCheck == FALSE) {

        if (ClientLogonId != (USER_SHARED_DATA->ActiveConsoleId))
        //
        // Since for PTS the remote session could have an ID of 0 or (1),
        // we check for access only if session is not on console.
        //
        {
    
            bAccessCheckOk = AccessCheckAndAuditAlarm(szTermsrv,
                                 NULL,
                                 (LPWSTR)szTermsrvSession,
                                 (LPWSTR)szTermsrvSession,
                                 WinStationGetSecurityDescriptor(pWinStation),
                                 WINSTATION_LOGON,
                                 &WinStaMapping,
                                 FALSE,
                                 &GrantedAccess,
                                 &AccessStatus,
                                 &fGenerateOnClose);
    
            if (bAccessCheckOk)
            {
                if (AccessStatus == FALSE)
                {
                    TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, AccessCheckAndAuditAlarm(%u) returned error 0x%x\n",
                              pWinStation->LogonId, GetLastError() ));
                    Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
                    goto noaccess;
                }
                else
                {
                    TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, AccessCheckAndAuditAlarm(%u) returned no error \n",
                              pWinStation->LogonId));
                }
            }
            else
            {
                TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, AccessCheckAndAuditAlarm(%u) failed 0x%x\n",
                          pWinStation->LogonId, GetLastError() ));
                goto noaccess;
            }
        }
    } // if ( !bNoAccessCheck)

    /*
     * Revert back to our threads default token.
     */
    NewToken = NULL;
    NtSetInformationThread( NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID)&NewToken,
                            (ULONG)sizeof(HANDLE) );

    /*
     * See if OpenWinStation was successful
     */
    if ( !NT_SUCCESS( Status ) ) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR, "TERMSRV: WinStationNotifyLogon, OpenWinStation(%u) failed 0x%x\n",
                  pWinStation->LogonId, Status ));
        goto noaccess;
    }

    /*
     * Save User Name and Domain Name. Do this before the call into the
     * license core so that the core knows who is calling.
     */

    wcsncpy( pWinStation->Domain, pDomain, DomainLength );
    wcsncpy( pWinStation->UserName, pUserName, UserNameLength );

    /*
     *  Call into the licensing core.
     */

    Status = LCProcessConnectionPostLogon(pWinStation);

    if (Status != STATUS_SUCCESS)
    {
        goto nolicense;
    }

    /*
     * note that post logon licensing happened
     */

    pWinStation->StateFlags |= WSF_ST_LICENSING;



    if (pWinStation->pWsx &&
        pWinStation->pWsx->pWsxLogonNotify) {
        if ((ClientLogonId != 0) && (pWinStation->State != State_Connected || pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
            Status = STATUS_CTX_CLOSE_PENDING;
        } else {

            PWCHAR pDomainToSend, pUserNameToSend ;
            
            // Use the Notification given by GINA (WinStationUpdateClientCachedCredentials) if they are available 
            // This is because the credentials got in this call are not UPN names
            if (pWinStation->pNewNotificationCredentials) {
                pDomainToSend = pWinStation->pNewNotificationCredentials->Domain;
                pUserNameToSend = pWinStation->pNewNotificationCredentials->UserName;
            } else {
                pDomainToSend = pDomain;
                pUserNameToSend = pUserName;
            }

            /*
             * Reset any autoreconnect information prior to reconnection
             * as it is stale. New information will be generated by the stack
             * when login completes.
             */
            ResetAutoReconnectInfo(pWinStation);

            Status = pWinStation->pWsx->pWsxLogonNotify(pWinStation->pWsxContext,
                                                  pWinStation->LogonId,
                                                  ClientToken,
                                                  pDomainToSend,
                                                  pUserNameToSend);

            if (pWinStation->pNewNotificationCredentials != NULL) {
                MemFree(pWinStation->pNewNotificationCredentials);
                pWinStation->pNewNotificationCredentials = NULL;
            }


        }

    }

    if( !NT_SUCCESS(Status) ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: pWsxLogonNotify rejected logon status 0x%x\n",Status));
        goto badwsxnotify;
    }

    /*
     * Determine size needed for token info buffer and allocate it
     */
    Status = NtQueryInformationToken( ClientToken, TokenUser,
                                      NULL, 0, &Length );
    if ( Status != STATUS_BUFFER_TOO_SMALL )
        goto badquerytoken;
    TokenInfo = MemAlloc( Length );
    if ( TokenInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto badquerytoken;
    }

    /*
     * Query token information to get user's SID
     */
    Status = NtQueryInformationToken( ClientToken, TokenUser,
                                      TokenInfo, Length, &Length );
    if ( !NT_SUCCESS( Status ) ) {
        MemFree( TokenInfo );
        goto badquerytoken;
    }

    /*
     * Save copy of user's SID and password in WinStation
     */
    Length = RtlLengthSid( TokenInfo->User.Sid );

    if (pWinStation->pUserSid) {
       MemFree(pWinStation->pUserSid);
    }
    // clean up usertoken
    if ( pWinStation->UserToken ) {
        NtClose( pWinStation->UserToken );
        pWinStation->UserToken = NULL;
    }

    pWinStation->pUserSid = MemAlloc( Length );

    /* makarp; check for allocation failure. #182624 */
    if (!pWinStation->pUserSid) {
        Status = STATUS_NO_MEMORY;
        goto badusersid;
    }

    RtlCopySid( Length, pWinStation->pUserSid, TokenInfo->User.Sid );
    MemFree( TokenInfo );
    NtClose( ImpersonationToken );

    //For console session profile cleanup is done at next
    //logon because the session is never unloaded.
    if (pWinStation->pProfileSid != NULL) {
       ASSERT(pWinStation->LogonId == 0);
       if (pWinStation->LogonId == 0) {
          if (!RtlEqualSid(pWinStation->pProfileSid, pWinStation->pUserSid  )) {
             WinstationUnloadProfile(pWinStation);
          }
       }
       MemFree(pWinStation->pProfileSid);
       pWinStation->pProfileSid = NULL;
    }


    /*
     * Save copy of Client token in WinStation
     */
    pWinStation->UserToken = ClientToken;

#if 0
    //
    // C2 WARNING - WARNING - WARNING
    //
    // This is no longer done, or needed. See comments in acl.c
    //
    // C2 WARNING - WARNING - WARNING
    //
    RtlCopyMemory( pWinStation->Password, pPassword,
                   sizeof(pWinStation->Password) );

    pWinStation->Seed = Seed;
#endif

    /*
     * Fixup the security descriptors for the session
     * so this user has access to their named WIN32
     * object directory's.
     */
    RetValue = ConfigurePerSessionSecurity( pWinStation );
    if (RetValue != TRUE) {
        // Set WinStation's UserToken to NULL here as the error path closes the ClientToken
        pWinStation->UserToken = NULL;
        goto badduptoken;
    }


    /*
     * Add ACE for logged on user to the WinStation object SD
     */
    Status = AddUserAce( pWinStation );
    if (Status != STATUS_SUCCESS) {
        // Set WinStation's UserToken to NULL here as the error path closes the ClientToken
        pWinStation->UserToken = NULL;
        goto badduptoken;
    }       

    /*
     * Notify clients of WinStation logon
     */
    NotifySystemEvent( WEVENT_LOGON );
    NotifyLogon(pWinStation);

    /*
     * State is now active
     */
    if ( pWinStation->State != (ULONG) State_Active ) {

        // make sure repopulating thread don't include this winstation
        // in the list reporting to SD and let this thread do its
        // own reporting.
        if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
            SessDirWaitForRepopulate();
        }

        pWinStation->State = State_Active;
        NotifySystemEvent( WEVENT_STATECHANGE );
    }

    (VOID) NtQuerySystemTime( &(pWinStation->LogonTime) );

    // 2nd and 3rd parama are NULL, since we don't yet have policy data. 
    // policy data will be aquired when user hive is loaded and winlogin fires
    // a shell-startup notify.
    MergeUserConfigData(pWinStation, NULL, NULL, (PUSERCONFIGW)pUserConfig ) ;

    /*
     * Save User Name and Domain Name into the USERCONFIG of the WINSTATION
     */
    wcsncpy( pWinStation->Config.Config.User.UserName, pUserName, UserNameLength );
    wcsncpy( pWinStation->Config.Config.User.Domain, pDomain, DomainLength );

    /*
     * Convert any "published app" to absolute path.  This will also return
     * failure if a non-published app is trying to run on a WinStation that
     * is configured to only run published apps.
     */
    if ( pWinStation->pWsx &&
            pWinStation->pWsx->pWsxConvertPublishedApp ) {
        if ((Status = pWinStation->pWsx->pWsxConvertPublishedApp(
                pWinStation->pWsxContext, &pWinStation->Config.Config.User)) !=
                STATUS_SUCCESS)
            goto release;
    }

    // Now that we have all the WinStation data, notify the session directory.
    // Copy off the pertinent info, which we will send to the directory after
    // we release the WinStation lock.
    wcsncpy(pCreateInfo->UserName, pWinStation->UserName,
            sizeof(pCreateInfo->UserName) / sizeof(WCHAR) - 1);
    wcsncpy(pCreateInfo->Domain, pWinStation->Domain,
            sizeof(pCreateInfo->Domain) / sizeof(WCHAR) - 1);
    pCreateInfo->SessionID = pWinStation->LogonId;
    pCreateInfo->TSProtocol = pWinStation->Client.ProtocolType;
    // If InitialProgram is set on the server side, use it for the Applicationtype
    if (!pWinStation->Config.Config.User.fInheritInitialProgram) {
        wcsncpy(pCreateInfo->ApplicationType, pWinStation->Config.Config.User.InitialProgram,
                sizeof(pCreateInfo->ApplicationType) / sizeof(WCHAR) - 1);
    }
    else {
        wcsncpy(pCreateInfo->ApplicationType, pWinStation->Client.InitialProgram,
                sizeof(pCreateInfo->ApplicationType) / sizeof(WCHAR) - 1);
    }
    pCreateInfo->ResolutionWidth = pWinStation->Client.HRes;
    pCreateInfo->ResolutionHeight = pWinStation->Client.VRes;
    pCreateInfo->ColorDepth = pWinStation->Client.ColorDepth;
    memcpy(&(pCreateInfo->CreateTime), &pWinStation->LogonTime,
            sizeof(pCreateInfo->CreateTime));
    bHaveCreateInfo = TRUE;

    
    if(Status == STATUS_SUCCESS)
    {
        //Set flag saying that WinStationNotifyLogonWorker 
        //was successfully completed
        pWinStation->StateFlags |= WSF_ST_LOGON_NOTIFIED;
    }

    if( TSIsSessionHelpSession(pWinStation, &bValidHelpSession) )
    {
        WINSTATION_APIMSG msg;

        // we disconnect RA if ticket is invalid at conntion time so assert
        // if we ever come to this.
        ASSERT( TRUE == bValidHelpSession );

        //
        // Disable IO from Help Session
        //
        WinStationEnableSessionIo( pWinStation, FALSE );

        msg.ApiNumber = SMWinStationNotify;
        msg.WaitForReply = FALSE;
        msg.u.DoNotify.NotifyEvent = WinStation_Notify_DisableScrnSaver;
        Status = SendWinStationCommand( pWinStation, &msg, 0 );

        ASSERT( NT_SUCCESS(Status) );

        // ignore this error, help can still proceed.
        Status = STATUS_SUCCESS;
    }

    /*
     * Release the winstation lock
     */
release:

    if (pWinStation != NULL) {
        if (pWinStation->pNewNotificationCredentials != NULL) {
            MemFree(pWinStation->pNewNotificationCredentials);
            pWinStation->pNewNotificationCredentials = NULL;
        }
    }

    ReleaseWinStation( pWinStation );

    // Now inform the session directory while we're not holding the lock.
    if (!bQueueReset && bHaveCreateInfo && !g_bPersonalTS && g_fAppCompat && g_bAdvancedServer && !bRedirect)
        SessDirNotifyLogon(pCreateInfo);

    /*
     * Save return status in API message
     */
done:
    // Clear password
    if (0 != PasswordSize)
        SecureZeroMemory(pPassword, PasswordSize);
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogon, Status=0x%x\n", Status ));

    if (pCreateInfo != NULL) {
        MemFree(pCreateInfo);
        pCreateInfo = NULL;
    }

    // Update the counters for successful logons.
    if (Status == STATUS_SUCCESS) {

        InterlockedIncrement(&g_TermSrvSuccTotalLogons);

        if (ClientLogonId == 0) {
            // Connecting to console.
            InterlockedIncrement(&g_TermSrvSuccSession0Logons);
        }

        if (fReconnectingToConsole) {
            // Reconnecting locally to console.
            InterlockedIncrement(&g_TermSrvSuccLocalLogons);
        }
        else {
            if ( (ClientLogonId == 0) && (USER_SHARED_DATA->ActiveConsoleId == 0) ) {
                // Logging on to console locally (When no one is connected to console).
                InterlockedIncrement(&g_TermSrvSuccLocalLogons);
            }
            else {
                // Connecting remotely. (if ClientLogonId is 0, then connecting remotely to console, else connecting to non-console).
                InterlockedIncrement(&g_TermSrvSuccRemoteLogons);
            }
        }
    }

    return Status;

/*=============================================================================
==   Error returns
=============================================================================*/

    /* Could not allocate for pWinStation->pUserSid,  makarp #182624 */
badusersid:
    MemFree( TokenInfo );

    /*
     * Could not query token info
     * WinStation Open failed (no access)
     * Could not impersonate client token
     * Could not duplicate client token
     */
badquerytoken:
badwsxnotify:
nolicense:
noaccess:
badimpersonate:
    NtClose( ImpersonationToken );
badduptoken:
    NtClose( ClientToken );

    /*
     * Could not duplicate client token handle
     */
baddupobject:
#ifdef not_hydrix
    pWinStation->HasLicense = FALSE;
    RtlZeroMemory( pWinStation->ClientLicense,
                   sizeof(pWinStation->ClientLicense) );
#else
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxClearContext ) {
        pWinStation->pWsx->pWsxClearContext( pWinStation->pWsxContext );
    }
#endif

    if (pWinStation->pNewNotificationCredentials != NULL) {
        MemFree(pWinStation->pNewNotificationCredentials);
        pWinStation->pNewNotificationCredentials = NULL;
    }

    ReleaseWinStation( pWinStation );
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogon, Status=0x%x\n", Status ));

    // Clear password
    if (0 != PasswordSize)
        memset(pPassword, 0, PasswordSize);

    if (pCreateInfo != NULL) {
        MemFree(pCreateInfo);
        pCreateInfo = NULL;
    }

    return Status;
}


/*****************************************************************************
 *  WinStationNotifyLogoffWorker
 *
 *   Message parameter unmarshalling function for WinStation API.
 ****************************************************************************/
NTSTATUS WinStationNotifyLogoffWorker(
        DWORD ClientLogonId,
        DWORD ClientProcessId)
{

    NTSTATUS Status;
    PWINSTATION pWinStation;
    DWORD SessionID = 0;


    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogoff, LogonId=%d\n", ClientLogonId ));
    KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogoff, LogonId=%d\n", ClientLogonId ));

    Status = STATUS_SUCCESS;

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }
    
    //See if WinStation was notified of logon
    if(pWinStation->StateFlags & WSF_ST_LOGON_NOTIFIED)
    {
        //Clear the flag
        pWinStation->StateFlags &= ~WSF_ST_LOGON_NOTIFIED;
    }
    else
    {
        //WinStation was not notified of logon.
        //do nothing; return error. However if postlogon licensing happened, do post logoff licensing.

        if (pWinStation->StateFlags & WSF_ST_LICENSING) {
            (VOID)LCProcessConnectionLogoff(pWinStation);
            pWinStation->StateFlags &= ~WSF_ST_LICENSING;
        }

        KdPrint(("TERMSRV: WinStationNotifyLogoff FAILED, WinStation was not notified of logon!\n"));
        ReleaseWinStation( pWinStation );
        Status = STATUS_INVALID_PARAMETER; //probably need some special error code
        goto done;
    }


    /*
     * The upper level has verified the client caller
     * is local and has SYSTEM access. So we can trust
     * the parameters passed.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Stop the shadow on console if needed.
     */
    if ( pWinStation->fOwnsConsoleTerminal ) {
        WinStationStopAllShadows( pWinStation );
    }
    
    /*
     * Remove ACE for logged on user to the WinStation object SD
     */
    if (pWinStation->pSecurityDescriptor != NULL) { 
        RemoveUserAce( pWinStation );
    }

    if ( pWinStation->pUserSid ) {
        ASSERT(pWinStation->pProfileSid == NULL);
        pWinStation->pProfileSid = pWinStation->pUserSid;
        pWinStation->pUserSid = NULL;
    }

    /*
     * Cleanup UserToken
     */
    if ( pWinStation->UserToken ) {
        NtClose( pWinStation->UserToken );
        pWinStation->UserToken = NULL;
    }

    /*
     * Indicate this WinStation no longer has a license
     */
#ifdef not_hydrix
    pWinStation->HasLicense = FALSE;
    RtlZeroMemory( pWinStation->ClientLicense,
                   sizeof(pWinStation->ClientLicense) );
#else
    if ( pWinStation->pWsx &&
         pWinStation->pWsx->pWsxClearContext ) {
        pWinStation->pWsx->pWsxClearContext( pWinStation->pWsxContext );
    }
#endif

    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
        // TS only reset the Flag not the the winstation state for logoff session
        // so we wait and let repopulating thread has enough time to pick up this
        // winstation/report to SD then this thread can continue to notify SD 
        // about logoff        
        SessDirWaitForRepopulate();
    }
 
    /*
     * do needed data cleanup.
     */

    RtlZeroMemory( pWinStation->Domain,
                   sizeof( pWinStation->Domain ) );
    RtlZeroMemory( pWinStation->UserName,
                   sizeof( pWinStation->UserName ) );
    RtlZeroMemory( &pWinStation->LogonTime,
                   sizeof( pWinStation->LogonTime ) );

    ResetUserConfigData( pWinStation );

    pWinStation->Config.Config.User.UserName[0] = L'\0';
    pWinStation->Config.Config.User.Domain[0] = L'\0';
    pWinStation->Config.Config.User.Password[0] = L'\0';

    if ( pWinStation->LogonId == 0 ) {


        /*
         * No need to do anything else for console state change.
         */
        
        if ( pWinStation->State != (ULONG) State_Connected &&
            pWinStation->State != (ULONG) State_Disconnected) {

            pWinStation->State = State_Connected;
            NotifySystemEvent( WEVENT_STATECHANGE );
        }
        
        //
        //Set the Console Logon Event
        //

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: WinStationNotifyLogoff, Setting ConsoleLogoffEvent\n"));
        NtSetEvent(ConsoleLogoffEvent, NULL);

    /*
     * For non-Console WinStations, mark this WinStation as terminating
     * and set the broken reason and source for later use.
     */
    } else {
        //pWinStation->Terminating = TRUE;
        pWinStation->BrokenReason = Broken_Terminate;
        pWinStation->BrokenSource = BrokenSource_User;

        // Save off the session dir for sending to the session directory
        // below.
        SessionID = pWinStation->LogonId;
    }

    // Clean up the New Client Credentials struct for Long UserName

    if (pWinStation->pNewClientCredentials != NULL) {

        MemFree(pWinStation->pNewClientCredentials);
        pWinStation->pNewClientCredentials = NULL;
    }

    /*
     * Call into licensing core for logoff. Ignore errors.
     */
    if (pWinStation->StateFlags & WSF_ST_LICENSING) {
        (VOID)LCProcessConnectionLogoff(pWinStation);
        pWinStation->StateFlags &= ~WSF_ST_LICENSING;
    }

    NotifyLogoff(pWinStation);
    ReleaseWinStation( pWinStation );

    // Notify the session directory.
    if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer) {
        SessDirNotifyLogoff(SessionID);
    }

    /*
     * Notify clients of WinStation logoff
     */
    NotifySystemEvent(WEVENT_LOGOFF);

done:
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyLogoff, Status=0x%x\n", Status ));
    return Status;
}


/*****************************************************************************
 *  OldRpcWinStationEnumerateProcesses
 *
 *   WinStationEnumerateProcesses API for Beta servers
 *
 *   The format changed after Beta.  New winsta.dll's were trapping when talking
 *   to old hosts.
 ****************************************************************************/
BOOLEAN
OldRpcWinStationEnumerateProcesses(
    HANDLE  hServer,
    DWORD   *pResult,
    PBYTE   pProcessBuffer,
    DWORD   ByteCount
    )
{
    return ( RpcWinStationEnumerateProcesses( hServer, pResult, pProcessBuffer, ByteCount ) );
}


/*******************************************************************************
 *  RpcWinStationCheckForApplicationName
 *
 *    Handles published applications.
 *
 * EXIT:
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcWinStationCheckForApplicationName(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId,
    PWCHAR pUserName,
    DWORD  UserNameSize,
    PWCHAR pDomain,
    DWORD  DomainSize,
    PWCHAR pPassword,
    DWORD  *pPasswordSize,
    DWORD  MaxPasswordSize,
    PCHAR  pSeed,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    /*
     * This is obsolete and should be removed from the RPC
     */
    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}


/*******************************************************************************
 *
 *  RpcWinStationGetApplicationInfo
 *
 *    Gets info about published applications.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationGetApplicationInfo(
    HANDLE hServer,
    DWORD  *pResult,
    ULONG  LogonId,
    PBOOLEAN pfPublished,
    PBOOLEAN pfAnonymous
    )
{
    /*
     * This is obsolete and should be removed from the RPC code.
     */
    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}


/*******************************************************************************
 *
 *  RpcWinStationNtsdDebug
 *
 *    Sets up connection for Ntsd to debug processes belonging to another
 *    CSR.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationNtsdDebug(
    HANDLE     hServer,
    DWORD     *pResult,
    ULONG      LogonId,
    LONG       ProcessId,
    ULONG      DbgProcessId,
    ULONG      DbgThreadId,
    DWORD_PTR  AttachCompletionRoutine
    )
{

    *pResult = STATUS_NOT_IMPLEMENTED;
    RpcRaiseException(ERROR_INVALID_FUNCTION);
    return FALSE;
}

/*******************************************************************************
 *
 *  RpcWinStationGetTermSrvCountersValue
 *
 *    Gets TermSrv Counters value
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOLEAN
RpcWinStationGetTermSrvCountersValue(
    HANDLE hServer,
    DWORD  *pResult,
    DWORD  dwEntries,
    PTS_COUNTER pCounter
    )
{
    UINT i;
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;
    BOOLEAN     bWalkedList = FALSE;
    ULONG       cActive, cDisconnected;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult = STATUS_UNSUCCESSFUL;

    if (pCounter != NULL) {
        for (i = 0; i < dwEntries; i++) {
            // set the TermSrv counter value.  Currently, startTime is always
            // set to 0 because we don't support time stamp.
            pCounter[i].startTime.QuadPart = 0;

            switch (pCounter[i].counterHead.dwCounterID) {

                case TERMSRV_TOTAL_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvTotalSessions;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_DISC_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvDiscSessions;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_RECON_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvReconSessions;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_CURRENT_ACTIVE_SESSIONS:
                case TERMSRV_CURRENT_DISC_SESSIONS:
                {
                    if ( !bWalkedList ) {

                        cActive = cDisconnected = 0;

                        Head = &WinStationListHead;
                        ENTERCRIT( &WinStationListLock );
                        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {

                            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );

                            if ( (pWinStation->State == State_Active) ||
                                 (pWinStation->State == State_Shadow) ) 
                                cActive ++;

                            if ( pWinStation->State == State_Disconnected ) 
                                if ( pWinStation->LogonId != 0 )
                                    cDisconnected ++;
                                else if ( pWinStation->UserName[0] )
                                    // For session 0, test if a user is logged on.
                                    cDisconnected ++;
                        }
                        LEAVECRIT( &WinStationListLock );

                        bWalkedList = TRUE;
                    }

                    pCounter[i].counterHead.bResult = TRUE;

                    if ( pCounter[i].counterHead.dwCounterID == TERMSRV_CURRENT_ACTIVE_SESSIONS ) 
                        pCounter[i].dwValue = cActive;
                    else
                        pCounter[i].dwValue = cDisconnected;

                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_PENDING_SESSIONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = NumOutStandingConnect;
    
                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_SUCC_TOTAL_LOGONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvSuccTotalLogons;
    
                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_SUCC_LOCAL_LOGONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvSuccLocalLogons;
    
                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_SUCC_REMOTE_LOGONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvSuccRemoteLogons;
    
                    *pResult = STATUS_SUCCESS;
                }
                break;

                case TERMSRV_SUCC_SESSION0_LOGONS:
                {
                    pCounter[i].counterHead.bResult = TRUE;
                    pCounter[i].dwValue = g_TermSrvSuccSession0Logons;
    
                    *pResult = STATUS_SUCCESS;
                }
                break;

                default:
                {
                    pCounter[i].counterHead.bResult = FALSE;
                    pCounter[i].dwValue = 0;
                }
            }
        }
    }

    return ( *pResult == STATUS_SUCCESS );
}

/******************************************************************************
 *
 *  RpcServerGetInternetConnectorStatus
 *
 *    Returns whether Internet Connector licensing is being used
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and pfEnabled contains the requested data.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 *****************************************************************************/

BOOLEAN
RpcServerGetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    PBOOLEAN pfEnabled
    )
{

#if 0
    if (pResult != NULL)
    {
        *pResult = STATUS_NOT_IMPLEMENTED;
    }

    if (pfEnabled != NULL)
    {
        *pfEnabled = FALSE;
    }

    return(FALSE);
#else
    //
    //  TEMPORARY FUNCTION! THIS WILL GET NUKED ONCE THE LCRPC
    //  INTERFACE IS UP AND RUNNING AND TSCC CHANGES HAVE BEEN
    //  MADE!
    //

    if (pResult == NULL)
    {
        return(FALSE);
    }
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    if (pfEnabled == NULL)
    {
        *pResult = STATUS_INVALID_PARAMETER;
        return(FALSE);
    }

    *pfEnabled = (LCGetPolicy() == (ULONG)3);

    *pResult = STATUS_SUCCESS;
    return(TRUE);
#endif
}

/******************************************************************************
 *
 *  RpcServerSetInternetConnectorStatus
 *
 *    This function will (if fEnabled has changed from its previous setting):
 *       Check that the caller has administrative privileges,
 *       Modify the corresponding value in the registry,
 *       Change licensing mode (between normal per-seat and Internet Connector.
 *       Enable/Disable the TsInternetUser account appropriately
 *
 * ENTRY:
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is in pResult
 *
 ******************************************************************************/

BOOLEAN
RpcServerSetInternetConnectorStatus(
    HANDLE   hServer,
    DWORD    *pResult,
    BOOLEAN  fEnabled
    )
{
    

#if 0
    if (pResult != NULL)
    {
        *pResult = STATUS_NOT_IMPLEMENTED;
    }

    return(FALSE);
#else
    //
    //  TEMPORARY FUNCTION! THIS WILL GET NUKED ONCE THE LCRPC
    //  INTERFACE IS UP AND RUNNING AND TSCC CHANGES HAVE BEEN
    //  MADE!
    //

    NTSTATUS NewStatus;
    RPC_STATUS RpcStatus;
    
    if (pResult == NULL)
    {
        return FALSE;
    }
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    if (!IsCallerAdmin())
    {
        RpcRevertToSelf();
        *pResult = STATUS_PRIVILEGE_NOT_HELD;
        return FALSE;
    }

    RpcRevertToSelf();

    *pResult = LCSetPolicy(fEnabled ? 3 : 2, &NewStatus);

    if ((*pResult == STATUS_SUCCESS) && (NewStatus == STATUS_SUCCESS))
    {
        return(TRUE);
    }

    //
    //  If there was an error, it was either in the core or the new policy.
    //  If its in the core, NewStatus will be success. If its in the new
    //  policy, *pResult will be unsuccessful, and the real error will be in
    //  NewStatus. Return the real error.
    //  

    if (NewStatus != STATUS_SUCCESS)
    {
        *pResult = NewStatus;
    }

    return(FALSE);
#endif
}

/******************************************************************************
 *
 *  RpcServerQueryInetConnectorInformation
 *
 *    Queries configuration information about a Internet Connector licensing.
 *
 * ENTRY:
 *
 *    pWinStationInformation (output)
 *       A pointer to a buffer that will receive information about the
 *       specified window station.  The format and contents of the buffer
 *       depend on the specified information class being queried.
 *
 *    WinStationInformationLength (input)
 *       Specifies the length in bytes of the window station information
 *       buffer.
 *
 *    pReturnLength (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes placed in the window station information buffer.
 *
 * EXIT:
 *
 *    TRUE  -- The query succeeded, and the buffer contains the requested data.
 *
 *    False -- The operation failed or Internet Connector licensing isn't
 *             turned on.  Extended error status is in pResult
 *
 *****************************************************************************/

BOOLEAN
RpcServerQueryInetConnectorInformation(
        HANDLE hServer,
        DWORD  *pResult,
        PCHAR  pWinStationInformation,
        DWORD  WinStationInformationLength,
        DWORD  *pReturnLength
        )
{
    // doesn't return
    RpcRaiseException(RPC_S_CANNOT_SUPPORT);

    return FALSE;
}

/******************************************************************************
 *
 *  RpcWinStationQueryLogonCredentials
 *
 *    Queries autologon credentials for use in Winlogon/GINA.
 *
 *****************************************************************************/

BOOLEAN
RpcWinStationQueryLogonCredentials(
    HANDLE hServer,
    ULONG LogonId,
    PCHAR *ppWire,
    PULONG pcbWire
    )
{
    BOOL fRet;
    BOOL fUseLcCredentials;
    LCCREDENTIALS LcCredentials;
    NTSTATUS Status;
    PWINSTATION pWinStation;
    RPC_STATUS RpcStatus;
    WLX_CLIENT_CREDENTIALS_INFO_V2_0 WlxCredentials;
    BOOL fHelpAssistant = FALSE;
    BOOL bValidHelpSession;
    
    pExtendedClientCredentials pHelpAssistantCredential = NULL;

    if(!hServer)
    {
        return( FALSE );
    }

    //
    //  Impersonate client.
    //
    
    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        return(FALSE);
    }

    //
    //  Check for administration privileges.
    //

    if (!IsCallerSystem())
    {
        RpcRevertToSelf();
        return(FALSE);
    }

    RpcRevertToSelf();

    pWinStation = FindWinStationById(LogonId, FALSE);

    if (pWinStation == NULL)
    {
        return(FALSE);
    }

    pHelpAssistantCredential = MemAlloc(sizeof(ExtendedClientCredentials));
    if (pHelpAssistantCredential == NULL) {
        ReleaseWinStation(pWinStation);
        return FALSE;
    }

    ZeroMemory(&WlxCredentials, sizeof(WLX_CLIENT_CREDENTIALS_INFO_V2_0));
    WlxCredentials.dwType = WLX_CREDENTIAL_TYPE_V2_0;

    if( TSIsSessionHelpSession( pWinStation, &bValidHelpSession ) )
    {
        //
        // We should not hit this since we will disconnect at winstation transfer time
        //
        ASSERT( TRUE == bValidHelpSession );

        Status = TSHelpAssistantQueryLogonCredentials(pHelpAssistantCredential);
        if( STATUS_SUCCESS == Status )
        {
            WlxCredentials.fDisconnectOnLogonFailure = TRUE;
            WlxCredentials.fPromptForPassword = FALSE;
            WlxCredentials.pszUserName = pHelpAssistantCredential->UserName;
            WlxCredentials.pszDomain = pHelpAssistantCredential->Domain;
            WlxCredentials.pszPassword = pHelpAssistantCredential->Password;

            fUseLcCredentials = FALSE;

            fHelpAssistant = TRUE;
        }
    }

    if( FALSE == fHelpAssistant )
    {
        //
        // Not Help Assistant, use whatever send in from client.
        //
        ZeroMemory(&LcCredentials, sizeof(LCCREDENTIALS));

        Status = LCProvideAutoLogonCredentials(
            pWinStation,
            &fUseLcCredentials,
            &LcCredentials
            );

   
        if (Status == STATUS_SUCCESS)
        {
            if (fUseLcCredentials)
            {
                WlxCredentials.fDisconnectOnLogonFailure = TRUE;
                WlxCredentials.fPromptForPassword = FALSE;
                WlxCredentials.pszUserName = LcCredentials.pUserName;
                WlxCredentials.pszDomain = LcCredentials.pDomain;
                WlxCredentials.pszPassword = LcCredentials.pPassword;
            }
            else
            {    
                WlxCredentials.fDisconnectOnLogonFailure = FALSE;
                WlxCredentials.fPromptForPassword = pWinStation->Config.Config.User.fPromptForPassword;
                
                // If it's an app server, check if it's a SD redirected connection
                // If yes, ignore fPromptForPassword setting and allow auto-logon
                // Note: Only do it if SD is enabled, i.e. GetTSSD() returns a valide value
                if (!g_bPersonalTS && g_fAppCompat && g_bAdvancedServer && GetTSSD()) {
                    TS_LOAD_BALANCE_INFO LBInfo;
                    ULONG ReturnLength;

                    // need to release it
                    ReleaseTSSD();

                    memset(&LBInfo, 0, sizeof(LBInfo));
                    Status = IcaStackIoControl(pWinStation->hStack,
                                               IOCTL_TS_STACK_QUERY_LOAD_BALANCE_INFO,
                                               NULL, 0,
                                               &LBInfo, sizeof(LBInfo),
                                               &ReturnLength); 
                
                    if (NT_SUCCESS(Status)) {
                        if (LBInfo.RequestedSessionID &&
                            (LBInfo.ClientRedirectionVersion >= TS_CLUSTER_REDIRECTION_VERSION3)) {
                            WlxCredentials.fPromptForPassword = FALSE;

                            if (LBInfo.bUseSmartcardLogon) {
                                pWinStation->fSDRedirectedSmartCardLogon = TRUE;
                            }
                        }
                    }   
                }

                // Check if we have to use New Credentials for long UserName and copy accordingly
                if (pWinStation->pNewClientCredentials != NULL) {
                    WlxCredentials.pszUserName = pWinStation->pNewClientCredentials->UserName;
                    WlxCredentials.pszDomain = pWinStation->pNewClientCredentials->Domain;
                    WlxCredentials.pszPassword = pWinStation->pNewClientCredentials->Password;
                } else { 
                    WlxCredentials.pszUserName = pWinStation->Config.Config.User.UserName ;
                    WlxCredentials.pszDomain = pWinStation->Config.Config.User.Domain ;
                    WlxCredentials.pszPassword = pWinStation->Config.Config.User.Password ;
                }
            }   

        }
        else
        {
            fRet = FALSE;
            goto exit;
        }
    }

    ASSERT(WlxCredentials.pszUserName != NULL);
    ASSERT(WlxCredentials.pszDomain != NULL);
    ASSERT(WlxCredentials.pszPassword != NULL);

    *pcbWire = AllocateAndCopyCredToWire((PWLXCLIENTCREDWIREW*)ppWire, &WlxCredentials);
        
    fRet = *pcbWire > 0;

    //
    //  The values in LcCredentials are LocalAlloc-ed by the core.
    //

    if (fUseLcCredentials)
    {
        if (LcCredentials.pUserName != NULL)
        {
            LocalFree(LcCredentials.pUserName);
        }

        if (LcCredentials.pDomain != NULL)
        {
            LocalFree(LcCredentials.pDomain);
        }

        if (LcCredentials.pPassword != NULL)
        {
            //This code is never executed, but once it does we should call the below function.
            //RtlSecureZeroMemory(LcCredentials.pPassword,
                //lstrlenW(LcCredentials.pPassword)*sizeof(WCHAR));
            LocalFree(LcCredentials.pPassword);
        }
    }

    if( TRUE == fHelpAssistant )
    {
        // Zero out memory that contains password
        RtlSecureZeroMemory( pHelpAssistantCredential, sizeof(ExtendedClientCredentials));
    }

exit:
    ReleaseWinStation(pWinStation);

    if (pHelpAssistantCredential != NULL) {
        MemFree(pHelpAssistantCredential);
        pHelpAssistantCredential = NULL;
    }


    return((BOOLEAN)fRet);
}

/*****************************************************************************
 *  RPcWinStationBroadcastSystemMessage
 *      This is the server side for cleint's WinStationBroadcastSystemMessage
 *
 *   Perform the the equivalent to BroadcastSystemMessage to each specified sessions
 *
 * Limittations:
 *   Caller must be system or Admin, and lparam can not be zero unless
 *      msg is WM_DEVICECHANGE
 *      Error checking is done on the clinet side (winsta\client\winsta.c)
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *        sessionID
 *            this idefntifies the hydra session to which message is being sent
 *        timeOut
 *            set this to the amount of time you are willing to wait to get a response
 *            from the specified winstation. Even though Window's SendMessage API
 *            is blocking, the call from this side MUST choose how long it is willing to
 *            wait for a response.
 *        dwFlags
 *                 Option flags. Can be a combination of the following values: Value Meaning
 *                 BSF_ALLOWSFW Windows NT 5.0 and later: Enables the recipient to set the foreground window while
 *                     processing the message.
 *                 BSF_FLUSHDISK Flush the disk after each recipient processes the message.
 *                 BSF_FORCEIFHUNG Continue to broadcast the message, even if the time-out period elapses or one of
 *                     the recipients is hung..
 *                 BSF_IGNORECURRENTTASK Do not send the message to windows that belong to the current task.
 *                     This prevents an application from receiving its own message.
 *                 BSF_NOHANG Force a hung application to time out. If one of the recipients times out, do not continue
 *                     broadcasting the message.
 *                 BSF_NOTIMEOUTIFNOTHUNG Wait for a response to the message, as long as the recipient is not hung.
 *                     Do not time out.
 *                   ***
 *                 *** DO NOT USE *** BSF_POSTMESSAGE Post the message. Do not use in combination with BSF_QUERY.
 *                   ***
 *                 BSF_QUERY Send the message to one recipient at a time, sending to a subsequent recipient only if the
 *                     current recipient returns TRUE.
 *        lpdwRecipients
 *                         Pointer to a variable that contains and receives information about the recipients of the message. The variable can be a combination of the following values: Value Meaning
 *                         BSM_ALLCOMPONENTS Broadcast to all system components.
 *                         BSM_ALLDESKTOPS Windows NT: Broadcast to all desktops. Requires the SE_TCB_NAME privilege.
 *                         BSM_APPLICATIONS Broadcast to applications.
 *                         BSM_INSTALLABLEDRIVERS Windows 95 and Windows 98: Broadcast to installable drivers.
 *                         BSM_NETDRIVER Windows 95 and Windows 98: Broadcast to network drivers.
 *                         BSM_VXDS Windows 95 and Windows 98: Broadcast to all system-level device drivers.
 *                         When the function returns, this variable receives a combination of these values identifying which recipients actually received the message.
 *                         If this parameter is NULL, the function broadcasts to all components.
 *        uiMessage
 *            the window's message to send
 *        wParam
 *            first message param
 *        lParam
 *            second message parameter
 *
 *         pResponse
 *            This is the response to the broadcasted message
 *                  If the function succeeds, the value is a positive value.
 *                  If the function is unable to broadcast the message, the value is ?1.
 *                  If the dwFlags parameter is BSF_QUERY and at least one recipient returned
 *                     BROADCAST_QUERY_DENY to the corresponding message, the return value is zero
 *
 * EXIT:
 *        TRUE    if all went well or
 *        FALSE if something went wrong.
 *
 * WARNING:
 *            Do not use flag  BSF_POSTMESSAGE, since an app/window on a winstation is not setup to send back
 *            a response to the query in an asynchronous fashion. You must wait for the response (until the time out period).
 *
 * Comments:
 *      For more info, please see MSDN for BroadcastSystemMessage()
 *
 ****************************************************************************/
LONG RpcWinStationBroadcastSystemMessage(
    HANDLE      hServer,
    ULONG       sessionID,
    ULONG       waitTime,
    DWORD       dwFlags,
    DWORD       *lpdwRecipients,
    ULONG       uiMessage,
    WPARAM      wParam,
    LPARAM      lParam,
    PBYTE       rpcBuffer,
    ULONG       bufferSize,
    BOOLEAN     fBufferHasValidData,
    LONG        *pResponse
    )
{
    // Broadcast system message to all winstations.

    PWINSTATION pWinStation=NULL;
    WINSTATION_APIMSG WMsg;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    LONG    rc;
    int i;
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    
    if(!hServer)
    {
        return( FALSE );
    }

    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationBroadcastSystemMessage()\n"));

    //
    //
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        SetLastError(ERROR_CANNOT_IMPERSONATE );
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        SetLastError(ERROR_ACCESS_DENIED);
        return( FALSE );
    }

    if( !LocalFlag ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " Not a local client call\n"));
        RpcRevertToSelf();
        return( FALSE );
    }

    // if the caller is system or admin, then let it thru, else, return
    if( !(IsCallerSystem() | IsCallerAdmin() ) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, " Caller must be system or admin \n"));
        SetLastError(ERROR_ACCESS_DENIED);
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // if we got this far, then client is admin or system
    //

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    /*
     * Marshall in the [in] parameters
     *
     */

    WMsg.WaitForReply=TRUE;
    WMsg.u.bMsg.dwFlags = dwFlags;
    WMsg.u.bMsg.dwRecipients= *lpdwRecipients;  //note that we are passing the value, and we will get a new value back
    WMsg.u.bMsg.uiMessage = uiMessage;
    WMsg.u.bMsg.wParam = wParam;
    WMsg.u.bMsg.lParam = lParam;
    WMsg.u.bMsg.dataBuffer = NULL;
    WMsg.u.bMsg.bufferSize = 0;
    WMsg.u.bMsg.Response = *pResponse;

    WMsg.ApiNumber = SMWinStationBroadcastSystemMessage ;

    /*
     * Find and lock client WinStation
     */
    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationBroadcastSystemMessage() for sessionID = %d \n", sessionID ));
    pWinStation = FindWinStationById( sessionID, FALSE );

    if ( pWinStation == NULL )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "Winstation not found \n"));
        return( FALSE );
    }

    if ( pWinStation->Flags & WSF_LISTEN )
    {
        // this is a "listen" winstation, not an interactive one, so return an empty response.
        *pResponse = 0;
        ReleaseWinStation( pWinStation );
        return( TRUE );
    }

    if ( !((pWinStation->State == State_Active) ||
            (pWinStation->State == State_Disconnected) ) )
    {
        // This is something that winsta.C checks for, but it's possibele that from the time it
        // took to get here, a winstation was logged out from.
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\t request aborted, winstation State should be Active or Disconnected, neither in this case. \n"));
        *pResponse = 0;
        ReleaseWinStation( pWinStation );
        return( TRUE );
    }

    // if we have valid data, then set the msg dataBuffer to point to it
    if ( fBufferHasValidData )
    {
       WMsg.u.bMsg.dataBuffer = rpcBuffer;
       WMsg.u.bMsg.bufferSize = bufferSize;
    }

    /*
     * send message to winstation
     */
    rc = SendWinStationCommand( pWinStation, &WMsg, waitTime );

    ReleaseWinStation( pWinStation );

    if ( NT_SUCCESS( rc ) )
    {
        *pResponse = WMsg.u.bMsg.Response;
        *lpdwRecipients = WMsg.u.bMsg.dwRecipients;
        return (TRUE);
    }
    else
        return ( FALSE );

}


/*****************************************************************************
 *
 *  RpcWinStationSendWindowMessage
 *
 *   Perform the the equivalent to SendMessage to a specific winstation as
 *        identified by the session ID.  This is an exported function, at least used
 *        by the PNP manager to send a device change message (or any other window's message)
 *
 * Limitations:
 *   Caller must be system or Admin, and lparam can not be zero unless
 *      msg is WM_DEVICECHANGE
 *      Error checking is done on the clinet side (winsta\client\winsta.c)
 *
 * ENTRY:
 *        hServer
 *            this is a handle which identifies a Hydra server. For the local server, hServer
 *            should be set to SERVERNAME_CURRENT
 *        sessionID
 *            this idefntifies the hydra session to which message is being sent
 *        timeOut
 *            set this to the amount of time you are willing to wait to get a response
 *            from the specified winstation. Even though Window's SendMessage API
 *            is blocking, the call from this side MUST choose how long it is willing to
 *            wait for a response.
 *        hWnd
 *            This is the HWND of the target window in the specified session that
 *            a message will be sent to.
 *        Msg
 *            the window's message to send
 *        wParam
 *            first message param
 *        lParam
 *            second message parameter
 *        pResponse
 *          this is the response to the message sent, it depends on the type of message sent, see MSDN
 *
 *
 * EXIT:
 *        TRUE if all went well , check presponse for the actual response to the send message
 *        FALSE if something went wrong, the value of pResponse is not altered.
 *
 * WARNINGs:
 *        since the RPC call never blocks, you need to specify a reasonable timeOut if you want to wait for
 *         a response. Please remember that since this message is being sent to all winstations, the timeOut value
 *        will be on per-winstation.
 *
 *
 * Comments:
 *      For more info, please see MSDN for SendMessage()
 *
 ****************************************************************************/
LONG
   RpcWinStationSendWindowMessage(
    HANDLE      hServer,
    ULONG       sessionID,
    ULONG       waitTime,
    ULONG       hWnd,      // handle of destination window
    ULONG       Msg,       // message to send
    WPARAM      wParam,  // first message parameter
    LPARAM      lParam,   // second message parameter
    PBYTE       rpcBuffer,
    ULONG       bufferSize,
    BOOLEAN     fBufferHasValidData,
    LONG        *pResponse    // reply to the message sent
  )
{
    PWINSTATION pWinStation=NULL;
    WINSTATION_APIMSG WMsg;
    OBJECT_ATTRIBUTES ObjA;
    NTSTATUS Status;
    LONG    rc;
    int i;
    PVOID pData;
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;

    if(!hServer)
    {
        return( FALSE );
    }

    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationSendWindowMessage()\n"));

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tNot impersonating! RpcStatus 0x%x\n",RpcStatus));
        SetLastError(ERROR_CANNOT_IMPERSONATE );
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tI_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        SetLastError(ERROR_ACCESS_DENIED);
        return( FALSE );
    }

    if( !LocalFlag ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tNot a local client call\n"));
        RpcRevertToSelf();
        return( FALSE );
    }

    // if the caller is system or admin, then let it thru, else, return
    if( !(IsCallerSystem() | IsCallerAdmin() ) )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\tCaller must be system or admin \n"));
        SetLastError(ERROR_ACCESS_DENIED);
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // if we got this far, then client is admin or system
    //

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    /*
     * Marshall in the [in] parameters
     *
     */

    WMsg.WaitForReply=TRUE;
    WMsg.u.sMsg.hWnd = (HWND)LongToHandle( hWnd );
    WMsg.u.sMsg.Msg = Msg;
    WMsg.u.sMsg.wParam = wParam;
    WMsg.u.sMsg.lParam = lParam;
    WMsg.u.sMsg.dataBuffer = NULL;
    WMsg.u.sMsg.bufferSize = 0;
    WMsg.u.sMsg.Response = *pResponse;

    WMsg.ApiNumber = SMWinStationSendWindowMessage ;


    /*
     * Find and lock client WinStation
     */
    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "in RpcWinStationSendWindowMessage() for essionID = %d \n", sessionID ));
    pWinStation = FindWinStationById( sessionID, FALSE );

    if ( pWinStation == NULL )
    {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "Winstation not found \n"));
        return( FALSE );
    }

    if ( pWinStation->Flags & WSF_LISTEN )
    {
        // this is a "listen" winstation, not an interactive one
        ReleaseWinStation( pWinStation );
        return( FALSE );        // this is normal situation, not an error, but no caller of this func should send a message to this w/s
    }

    if ( !((pWinStation->State == State_Active) ||
            (pWinStation->State == State_Disconnected) ) )
    {
        // This is something that winsta.C checks for, but it's possibele that from the time it
        // took to get here, a winstation was logged out from.
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "\t request aborted, winstation State should be Active or Disconnected, neither in this case. \n"));
        *pResponse = 0;
        ReleaseWinStation( pWinStation );
        return( TRUE );
    }

    // if we have valid data, then set the msg dataBuffer to point to it
    if ( fBufferHasValidData )
    {
        WMsg.u.sMsg.dataBuffer = rpcBuffer;
        WMsg.u.sMsg.bufferSize = bufferSize;

    }

    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "  dataBuffer = 0x%lx \n", WMsg.u.sMsg.dataBuffer ));
    // KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "  bufferSize = %d \n", WMsg.u.sMsg.bufferSize ));

    /*
     * send message to winstation
     */
    rc = SendWinStationCommand( pWinStation, &WMsg, waitTime );

    ReleaseWinStation( pWinStation );

    if ( NT_SUCCESS( rc ) )
    {
        *pResponse = WMsg.u.sMsg.Response;
        return (TRUE);
    }
    else
        return ( FALSE );
}

NTSTATUS
IsZeroterminateStringA(
    PBYTE pString,
    DWORD  dwLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;



    if ( (pString == NULL) || (memchr(pString, '\0', dwLength) == NULL)) {
       Status = STATUS_INVALID_PARAMETER;
    }
    return Status;

}

NTSTATUS
IsZeroterminateStringW(
    PWCHAR pwString,
    DWORD  dwLength
    )
{


    if (pwString == NULL) {
        return STATUS_INVALID_PARAMETER;
    }
    for (; 0 < dwLength; ++pwString, --dwLength ) {
        if (*pwString == (WCHAR)0) {
        return STATUS_SUCCESS;
        }
    }
    return STATUS_INVALID_PARAMETER;


}


/*****************************************************************************
*  GetTextualSid()
*     given a sid, return the text of that sid
*
*  Params:
*     [in]    user sid binary
*     [out]   text of user sid stuffed in the buffer which was passed in by the caller
*     [in]    the size of buffer passed in.
*
*  Return:
*     TRUE if no errors.
*
******************************************************************************/
BOOL
GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy) {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, TEXT("S-%lu-"), SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}

/*****************************************************************************
*  RpcWinStationUpdateUserConfig()
*     Called by notify when winlogon tells notify that shell startup is about to happen
*     We open the user profile and get the policy data, and then override any data found
*     in user's sessions's USERCONFIGW
*
*  Params:
*     [in]    hServer,
*     [in]    ClientLogonId,
*     [in]    ClientProcessId,
*     [in]    UserToken,
*     [in]    pDomain,
*     [in]    DomainSize,
*     [in]    pUserName,
*     [in]    UserNameSize,
*     [out]  *pResult
*
*  Return:
*     TRUE if no errors, FALSE otherwise, see pResult for the NTSTATUS of the error
*
*
*
* *****************************************************************************/
BOOLEAN
RpcWinStationUpdateUserConfig(
    HANDLE  hServer,
    DWORD   ClientLogonId,
    DWORD   ClientProcessId,
    DWORD   UserToken,
    DWORD   *pResult
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               Length;
    DWORD               rc = ERROR_SUCCESS;
    ULONG               Error;
    USERCONFIGW         *pTmpUserConfig;
    POLICY_TS_USER      userPolicy;
    USERCONFIGW         userPolicyData;
    HANDLE              NewToken;

    PWINSTATION         pWinStation;
    OBJECT_ATTRIBUTES   ObjA;

    PTOKEN_USER         pTokenInfo = NULL;
    HANDLE              hClientToken=NULL;

    // @@@ make these dynamic later
    TCHAR               szSidText [MAX_PATH ];
    DWORD               sidTextSize = MAX_PATH;

    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult=0;

    /*
     * Make sure the caller is SYSTEM (WinLogon)
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationUpdateUserConfig, LogonId=%d\n", ClientLogonId ));
    
    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL )
    {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        *pResult = Status;
        return( FALSE );
    }
    
    /*
     * Get a valid copy of the clients token handle
     */
    Status = NtDuplicateObject( pWinStation->InitialCommandProcess,
                                (HANDLE)LongToHandle( UserToken ),
                                NtCurrentProcess(),
                                &hClientToken,
                                0, 0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

    if ( !NT_SUCCESS( Status ) )
        goto done;

     /*
     * Determine size needed for token info buffer and allocate it
     */
     Status = NtQueryInformationToken ( hClientToken, TokenUser,
                                       NULL, 0, &Length );

     if ( Status != STATUS_BUFFER_TOO_SMALL ) 
     {
         goto done;
     }

     pTokenInfo = MemAlloc( Length );
     if ( pTokenInfo == NULL ) 
     {
         Status = STATUS_NO_MEMORY;
         goto done;
     }

     /*
      * Query token information to get client user's SID
      */
     Status = NtQueryInformationToken ( hClientToken, TokenUser,
                                       pTokenInfo, Length, &Length );
     if ( NT_SUCCESS( Status ) ) 
     {

        if ( GetTextualSid( pTokenInfo->User.Sid , szSidText, &sidTextSize ) )
        {
        
            // We now have the user SID
            
            /*
            * Get User policy from HKCU
            */
            if ( RegGetUserPolicy( szSidText, &userPolicy, & userPolicyData ) )
            {
                // 4th param is NULL, since config data is already part of pWinstation 
                // due to the call into NotifyLogonWorker from Winlogon. We are now
                // going to override data by any/all user group policy data.
                MergeUserConfigData( pWinStation, &userPolicy, &userPolicyData, NULL );
            }
            // else we were not able to get user policy, so no merge was done.
            
        }
    }

 done:

    if (pTokenInfo )
    {
        MemFree( pTokenInfo );
    }

    if (hClientToken)
    {
        NtClose( hClientToken );
    }

    /*
     * Start logon timers anyway, in case of any errors, we should still start the timers since
     * some machine policy might have set them up. 
     */
    StartLogonTimers( pWinStation );

    ReleaseWinStation( pWinStation );

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: RpcWinStationUpdateUserConfig, Status=0x%x\n", Status ));

    *pResult = Status ;

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

BOOLEAN RpcWinStationUnRegisterNotificationEvent (
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG_PTR   NotificationId,
    ULONG       SessionId
)
{
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    
    if (pResult == NULL) {
        return FALSE;
    }
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {

        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }
    else
    {
        ULONG ClientLogonId;
        *pResult = RpcGetClientLogonId( &ClientLogonId );
        if ( !NT_SUCCESS( *pResult ) ) {
            RpcRevertToSelf();
            return( FALSE );
        }

        if (ClientLogonId != SessionId)
        {
            RpcRevertToSelf();
            *pResult = STATUS_INVALID_PARAMETER;
            return FALSE;
        }
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();

    *pResult = UnRegisterConsoleNotification ( NotificationId, SessionId, WTS_EVENT_NOTIFICATION);
    
    return (*pResult == STATUS_SUCCESS);

}

BOOLEAN RpcWinStationRegisterNotificationEvent (
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG_PTR   *pNotificationId,
    ULONG_PTR   EventHandle,      // handle of destination window
    DWORD       dwFlags,
    DWORD       dwMask,
    ULONG       SessionId,
    ULONG       ProcessId

)
{
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    ULONG_PTR dupHandle;
    HANDLE ClientProcessHandle = NULL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    CLIENT_ID           ClientId;

    if (pResult == NULL) {
        return FALSE;
    }

    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    if (pNotificationId == NULL) {
        *pResult = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    if (!dwMask) {
        *pResult = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {

        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }
    else
    {
        ULONG ClientLogonId;
        *pResult = RpcGetClientLogonId( &ClientLogonId );
        if ( !NT_SUCCESS( *pResult ) ) {
            RpcRevertToSelf();
            return( FALSE );
        }

        if (ClientLogonId != SessionId)
        {
            RpcRevertToSelf();
            *pResult = STATUS_INVALID_PARAMETER;
            return( FALSE );
        }
    }

    //
    // get the client process handle.
    // do this while client is impersonated, so that if client doesnt have access to the
    // said process, we will fail the call.
    //
    ClientProcessHandle = OpenProcess( PROCESS_DUP_HANDLE, FALSE, ProcessId );

    if (!ClientProcessHandle) {

        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return (FALSE);

    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();



    if (DuplicateHandle(
            ClientProcessHandle,
            (HANDLE)EventHandle,
            GetCurrentProcess(),
            (PHANDLE)&dupHandle,
            0,
            0,
            DUPLICATE_SAME_ACCESS
            )) {

        *pResult = STATUS_SUCCESS;

    } else {

        *pResult = STATUS_INVALID_PARAMETER;

    }

    CloseHandle(ClientProcessHandle);

    if ( NT_SUCCESS( *pResult ) ) {

        dwFlags |= WTS_EVENT_NOTIFICATION;
        dwFlags &= ~WTS_WINDOW_NOTIFICATION;
        *pResult = RegisterConsoleNotification ( dupHandle, SessionId, dwFlags, dwMask );


        if ( NT_SUCCESS( *pResult ) ) {

            *pNotificationId = dupHandle;

        } else {

            CloseHandle((HANDLE)dupHandle);
        }
    }

    return (*pResult == STATUS_SUCCESS);

}

BOOLEAN RpcWinStationRegisterConsoleNotification (
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG       SessionId,
    ULONG_PTR   handle,      // handle of destination window
    DWORD       dwFlags,
    DWORD       dwMask
)
{

    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    

    if (pResult == NULL) {
        return FALSE;
    }
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }
    
    {
        ULONG ClientLogonId;
        *pResult = RpcGetClientLogonId( &ClientLogonId );
        if ( !NT_SUCCESS( *pResult ) ) {
            RpcRevertToSelf();
            return( FALSE );
        }

        if (ClientLogonId != SessionId)
        {
            RpcRevertToSelf();
            *pResult = STATUS_INVALID_PARAMETER;
            return( FALSE );
        }
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    // BUGBUG : MakarP, can we check if the calling process owns this hWnd ?
    // using GetWindowThreadProcessId ? Does it work across the sessions ?

    dwFlags &= ~WTS_EVENT_NOTIFICATION;
    dwFlags |= WTS_WINDOW_NOTIFICATION;
    *pResult = RegisterConsoleNotification ( handle, SessionId, dwFlags, dwMask );
    return (*pResult == STATUS_SUCCESS);
}

BOOLEAN RpcWinStationUnRegisterConsoleNotification (
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG       SessionId,
    ULONG       hWnd      // handle of destination window
)
{
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    
    if (pResult == NULL) {
        return FALSE;
    }
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = STATUS_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = STATUS_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }
    
    {
        ULONG ClientLogonId;
        *pResult = RpcGetClientLogonId( &ClientLogonId );
        if ( !NT_SUCCESS( *pResult ) ) {
            RpcRevertToSelf();
            return( FALSE );
        }

        if (ClientLogonId != SessionId)
        {
            RpcRevertToSelf();
            *pResult = STATUS_INVALID_PARAMETER;
            return( FALSE );
        }
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();


    // BUGBUG : MakarP, can we check if the calling process owns this hWnd ?
    // using GetWindowThreadProcessId ? Does it work across the sessions ?

    *pResult = UnRegisterConsoleNotification ( hWnd, SessionId, WTS_WINDOW_NOTIFICATION);

    return (*pResult == STATUS_SUCCESS);
}



BOOLEAN RpcWinStationIsHelpAssistantSession (
    HANDLE      hServer,
    DWORD       *pResult,           // function status
    ULONG       SessionId           // user logon id
    )
/*++

    RpcWinStationIsSessionHelpAssistantSession returns if a
    given session is created by Salem HelpAssistant account.

Parameters:

    hServer : Handle to server, unused, just to match all
              other RPC function.
    SessionId : User session ID.

Returns:

    TRUE/FALSE

--*/
{
    RPC_STATUS RpcStatus;
    UINT  LocalFlag;
    PWINSTATION pWinStation=NULL;
    BOOLEAN bReturn;
    BOOL bValidHelpSession;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    *pResult=0;

    //
    // Do we need to check system or only LPC call?
    //

    //
    // Find and lock client WinStation
    //
    pWinStation = FindWinStationById( SessionId, FALSE );
    if ( pWinStation == NULL )
    {
        *pResult = STATUS_CTX_WINSTATION_NOT_FOUND;
        return( FALSE );
    }

    bReturn = (BOOLEAN)TSIsSessionHelpSession( pWinStation, &bValidHelpSession );

    if( TRUE == bReturn )
    {
        if( FALSE == bValidHelpSession )
        {
            *pResult = STATUS_WRONG_PASSWORD;
        }
    }
    
    ReleaseWinStation( pWinStation );
    return bReturn;
}

BOOLEAN RpcRemoteAssistancePrepareSystemRestore (
    HANDLE      hServer,     
    DWORD       *pResult           // function status
    )
/*++ 

    Prepare TermSrv/Salem for system restore.

Parameters:

    hServer : Handle to server, unused, just to match all
              other RPC function.
    pResult : Pointer to DWORD to receive status of function.

Returns:

    TRUE/FALSE

--*/
{
    BOOLEAN bReturn = TRUE;
    RPC_STATUS RpcStatus;   
    BOOL LocalFlag;
    HRESULT hRes;
    
    if (pResult == NULL) {
        return FALSE;
    }
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    //
    // Calling this function from the remote machine, does not make sense, and
    // we should not allow it.
    //
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" RpcImpersonateClient() failed : 0x%x\n",RpcStatus));
        *pResult = ERROR_CANNOT_IMPERSONATE;
        return( FALSE );
    }

    //
    // Allow ony local admin to invoke this call.
    //
    if( !IsCallerAdmin() ) {
        RpcRevertToSelf();    
        *pResult = ERROR_ACCESS_DENIED;
        return (FALSE);
    }

    //
    // Inquire if local RPC call
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        DBGPRINT((" I_RpcBindingIsClientLocal() failed : 0x%x\n",RpcStatus));
        RpcRevertToSelf();
        *pResult = ERROR_ACCESS_DENIED;
        return( FALSE );
    }

    if( !LocalFlag ) {
        DBGPRINT((" Not a local client call\n"));
        *pResult = ERROR_ACCESS_DENIED;
        RpcRevertToSelf();
        return( FALSE );
    }

    //
    // done with the impersonation, we must have succeeded, otherwise, we would have exited above
    //
    RpcRevertToSelf();

    *pResult=0;

    hRes = TSRemoteAssistancePrepareSystemRestore();
    if( S_OK != hRes ) {
       bReturn = FALSE;
       *pResult = hRes;
    }

    return bReturn;
}


/*
* RpcWinStationGetMachinePolicy
*
*   Return (a copye of ) the machine policy to the caller 
*
*   Parameters:
*
*    hServer : Handle to server, unused, just to match all
*              other RPC function.
*
*    pointer to the policy struct
*   
*    size of the policy struct.
*
*/
BOOLEAN 
RpcWinStationGetMachinePolicy(
       SERVER_HANDLE                hServer,
       PBYTE                        pPolicy,
       ULONG                        bufferSize )
{
    if(!hServer)
    {
        return( FALSE );
    }

    if (pPolicy == NULL) {
        return FALSE;
    }
    // Check if BufferSize if big enough
    if (bufferSize < sizeof(POLICY_TS_MACHINE)) {
        return FALSE;
    }
    RtlCopyMemory( pPolicy , & g_MachinePolicy, sizeof( POLICY_TS_MACHINE ) );
    return TRUE;
}

/*++ 

    RpcWinStationUpdateClientCachedCredentials is used to store the ACTUAL credentials
    used to log on by a client. This is stored in WINSTATION struct which is later
    on used to notify the client about the logon credentials. This API is called
    from MSGINA.

Parameters:

    ClientLogonId : Logon Id of the new session opened by the client
    
    pDomian, pUserName : Credentials used by the client to log on

Returns:

    TRUE if the call succeeded in updating the credentials.

--*/

BOOLEAN
RpcWinStationUpdateClientCachedCredentials(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize,
    BOOLEAN     fSmartCard
    )
{
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Do some buffer validation
     */
    *pResult = IsZeroterminateStringW(pUserName, UserNameSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pDomain, DomainSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationUpdateClientCachedCredentialsWorker(
                    ClientLogonId,
                    ClientProcessId,
                    pDomain,
                    DomainSize,
                    pUserName,
                    UserNameSize,
                    fSmartCard
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationUpdateClientCachedCredentialsWorker
 *
 *   Worker function for RPCWinStationUpdateClientCachedCredentials
 ****************************************************************************/
NTSTATUS WinStationUpdateClientCachedCredentialsWorker(
        DWORD       ClientLogonId,
        ULONG_PTR   ClientProcessId,
        PWCHAR      pDomain,
        DWORD       DomainSize,
        PWCHAR      pUserName,
        DWORD       UserNameSize,
        BOOLEAN        fSmartCard)
{

    PWINSTATION pWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationUpdateClientCachedCredentialsWorker, LogonId=%d\n", ClientLogonId ));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Do not do anything if the session is not connected. The processing in this API assumes we are connected and have a
     * valid stack.
     */
    if ((ClientLogonId != 0) && ((pWinStation->State != State_Connected) ||  pWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation( pWinStation );
        goto done;
    }
    
    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        ReleaseWinStation( pWinStation );
        goto done;
    }

    /*
     * Save User Name and Domain Name which we will later use to send Notification to the Client 
     */
    pWinStation->pNewNotificationCredentials = MemAlloc(sizeof(CLIENTNOTIFICATIONCREDENTIALS)); 
    if (pWinStation->pNewNotificationCredentials == NULL) {
        Status = STATUS_NO_MEMORY ; 
        ReleaseWinStation( pWinStation );
        goto done ; 
    }

    // pDomain and pUserName are sent from Winlogon - these cannot exceed the size of the pWinstation buffers
    // because of the restrictions in the credentials lengths imposed by winlogon
    // But anyway check for their length and truncate them if they are more than the length of pWinstation buffers

    if ( wcslen(pDomain) > EXTENDED_DOMAIN_LEN ) {
        pDomain[EXTENDED_DOMAIN_LEN] = L'\0';
    }

    if ( wcslen(pUserName) > EXTENDED_USERNAME_LEN ) {
        pUserName[EXTENDED_USERNAME_LEN] = L'\0';
    }

    wcscpy( pWinStation->pNewNotificationCredentials->Domain, pDomain);
    wcscpy( pWinStation->pNewNotificationCredentials->UserName, pUserName);
    pWinStation->fSmartCardLogon = fSmartCard;

    /*
     * Release the winstation lock
     */
    ReleaseWinStation( pWinStation );

done:
    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationUpdateClientCachedCredentialsWorker, Status=0x%x\n", Status ));
    return Status;

}

/*++ 

    RpcWinStationFUSCanRemoteUserDisconnect - this API is used in a FUS Scenario 
    when there is someone at the console and another user tries to open a remote 
    session. This API askes the local user if it is ok to disconnect his/her session
    and allow the remote user to connect.

Parameters:

    TargetLogonId : Session ID which is being requested for connection
    
    ClientLogonId : Session ID of the temperory new session
  
    pDomain : Domain Name of the user who is trying to connect from remote
    
    pUserName : UserName of the user who is trying to connect from remote
   

Returns:

    TRUE - The local user has agreed to connect the remote user - so this user's session
           will be disconnected
           
    FALSE - Local user does not allow the remote user to connect           

--*/

BOOLEAN
RpcWinStationFUSCanRemoteUserDisconnect(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       TargetLogonId,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId,
    PWCHAR      pDomain,
    DWORD       DomainSize,
    PWCHAR      pUserName,
    DWORD       UserNameSize
    )
{
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Do some buffer validation
     */
    *pResult = IsZeroterminateStringW(pUserName, UserNameSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }
    *pResult = IsZeroterminateStringW(pDomain, DomainSize  );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }

    *pResult = WinStationFUSCanRemoteUserDisconnectWorker(
                    TargetLogonId,
                    ClientLogonId,
                    ClientProcessId,
                    pDomain,
                    DomainSize,
                    pUserName,
                    UserNameSize
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationFUSCanRemoteUserDisconnectWorker
 *
 *   Worker function for WinStationFUSCanRemoteUserDisconnect
 ****************************************************************************/
NTSTATUS WinStationFUSCanRemoteUserDisconnectWorker(
        DWORD       TargetLogonId,
        DWORD       ClientLogonId,
        ULONG_PTR   ClientProcessId,
        PWCHAR      pDomain,
        DWORD       DomainSize,
        PWCHAR      pUserName,
        DWORD       UserNameSize)
{

    PWINSTATION pTargetWinStation, pClientWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS MessageDelieveryStatus;

    WINSTATION_APIMSG msg;
    ULONG DisconnectResponse;
    OBJECT_ATTRIBUTES ObjA;

    WCHAR *szDomain = NULL;
    WCHAR *szUserName = NULL;
    
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationFUSCanRemoteUserDisconnect, LogonId=%d\n", ClientLogonId ));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    /*
     * Find and lock client WinStation
     */
    pClientWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pClientWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Do not do anything if the session is not connected. The processing in this API assumes we are connected and have a
     * valid stack.
     */
    if ((ClientLogonId != 0) && ((pClientWinStation->State != State_Connected) ||  pClientWinStation->StateFlags & WSF_ST_IN_DISCONNECT)) {
        Status = STATUS_CTX_CLOSE_PENDING;
        ReleaseWinStation(pClientWinStation);
        goto done;
    } 
    
    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pClientWinStation->InitialCommandProcessId ) {
        ReleaseWinStation(pClientWinStation);
        goto done;
    } 

    /*
     * Client WinStation is not needed anymore, so release that lock
     */
    ReleaseWinStation(pClientWinStation);

    /*
     * Find and lock target WinStation
     */
    pTargetWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    // Allocate the strings needed to display the Popup MessageBox
    if ((szDomain = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES * sizeof(WCHAR))) == NULL) {
        Status = STATUS_NO_MEMORY ;
        goto done;
    }

    if ((szUserName = LocalAlloc(LMEM_FIXED, MAX_STRING_BYTES * sizeof(WCHAR))) == NULL) {
        Status = STATUS_NO_MEMORY ;
        goto done;
    }

    memcpy(szDomain, pDomain, (DomainSize) * sizeof(WCHAR));
    szDomain[DomainSize] = L'\0';

    memcpy(szUserName, pUserName, (UserNameSize) * sizeof(WCHAR));
    szUserName[UserNameSize] = L'\0';

    /*
     *  Create wait event
     */
    InitializeObjectAttributes( &ObjA, NULL, 0, NULL, NULL );
    Status = NtCreateEvent( &msg.u.LoadStringMessage.hEvent, EVENT_ALL_ACCESS, &ObjA,
                            NotificationEvent, FALSE );
    if ( !NT_SUCCESS(Status) ) {
        ReleaseWinStation(pTargetWinStation);
        goto done;
    }

    /*
     * Send message and wait for reply
     */
    msg.u.LoadStringMessage.TitleId = REMOTE_DISCONNECT_TITLE_ID;
    msg.u.LoadStringMessage.MessageId = REMOTE_DISCONNECT_MESSAGE_ID;
    msg.u.LoadStringMessage.Style = MB_YESNO | MB_DEFBUTTON1 | MB_ICONQUESTION;
    msg.u.LoadStringMessage.Timeout = 20;
    msg.u.LoadStringMessage.DoNotWait = FALSE;
    msg.u.LoadStringMessage.pResponse = &DisconnectResponse;
    msg.u.LoadStringMessage.pDomain = szDomain;
    msg.u.LoadStringMessage.DomainSize = (ULONG) (DomainSize * sizeof(WCHAR));
    msg.u.LoadStringMessage.pUserName = szUserName;
    msg.u.LoadStringMessage.UserNameSize = (ULONG)(UserNameSize * sizeof(WCHAR));
    msg.u.LoadStringMessage.pStatus = &MessageDelieveryStatus;


    msg.ApiNumber = SMWinStationDoLoadStringNMessage;

    /*
     *  Initialize response to IDTIMEOUT
     */
    DisconnectResponse = IDTIMEOUT;

    /*
     * Tell the WinStation to display the message box
     */
    Status = SendWinStationCommand( pTargetWinStation, &msg, 0 );

    /*
     *  Wait for response
     */
    if ( Status == STATUS_SUCCESS ) {
        TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: wait for response\n" ));
        UnlockWinStation( pTargetWinStation );
        Status = NtWaitForSingleObject( msg.u.LoadStringMessage.hEvent, FALSE, NULL );
        if ( !RelockWinStation( pTargetWinStation ) ) {
            Status = STATUS_CTX_CLOSE_PENDING;
        }
        else {
            Status = MessageDelieveryStatus;
        }

        TRACE((hTrace,TC_ICASRV,TT_API1, "WinStationSendMessage: got response %u\n", DisconnectResponse ));
        NtClose( msg.u.LoadStringMessage.hEvent );
    } else {
        /* close the event in case of SendWinStationCommand failure */
        NtClose( msg.u.LoadStringMessage.hEvent );
    }

    if (Status == STATUS_SUCCESS && DisconnectResponse == IDNO) {
        Status = STATUS_CTX_WINSTATION_ACCESS_DENIED;
    }

    /*
     * Release the target winstation lock
     */
    ReleaseWinStation( pTargetWinStation );

done:
    /*
     * Do some memory cleanup
     */
    if (szDomain != NULL) {
        LocalFree(szDomain);
        szDomain = NULL;
    }

    if (szUserName != NULL) {
        LocalFree(szUserName);
        szUserName = NULL;
    }

    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationFUSCanRemoteUserDisconnectWorker, Status=0x%x\n", Status ));
    return Status;

}

/*++ 

    RPCWinStationCheckLoopBack checks for loopback during connections. This API
    is called from Winlogon. 

Parameters:

    ClientSessionId : Session ID from where the TS Client was started
            
    TargetLogonId : Session ID to which we are trying to connect
    
    pTargetServerName : Name of the Server we are trying to connect to
    
Returns:

    TRUE if there is a loopBack, FALSE otherwise 

--*/

BOOLEAN
RpcWinStationCheckLoopBack(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientSessionId,
    DWORD       TargetLogonId,
    PWCHAR      pTargetServerName,
    DWORD       NameSize
    )
{
    
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Do some buffer validation
     */
    *pResult = IsZeroterminateStringW(pTargetServerName, NameSize );
    if (*pResult != STATUS_SUCCESS) {
       return FALSE;
    }

    *pResult = WinStationCheckLoopBackWorker(
                    TargetLogonId,
                    ClientSessionId,
                    pTargetServerName,
                    NameSize
                    );

    // NOTE - If Worker function returns STATUS_SUCCESS that means there is no loopback, so return FALSE
    return( *pResult == STATUS_SUCCESS ? FALSE : TRUE );
}

/*****************************************************************************
 *  WinStationCheckLoopBackWorker
 *
 *   Worker function for RPCWinStationCheckLoopBack
 ****************************************************************************/
NTSTATUS WinStationCheckLoopBackWorker(
        DWORD       TargetLogonId,
        DWORD       ClientSessionId,
        PWCHAR      pTargetServerName,
        DWORD       NameSize)
{
    PWINSTATION pWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCheckLoopBackWorker, ClientSessionId=%d, TargetLogonId = %d\n", ClientSessionId, TargetLogonId ));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    // Do the actual processing to call the CheckLoopBack routine here
    // Use the _CheckShadowLoop function which already detects for a loop during Shadowing

    Status = _CheckShadowLoop(ClientSessionId, pTargetServerName, TargetLogonId);

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCheckLoopBackWorker, Status=0x%x\n", Status ));
    return Status;

}

/*******************************************************************************
 * RpcConnectCallBack
 *
 * Initiate connect back to TS client.  For Whistler, this is Salem only call.
 *
 *
 * Returns :
 *    TRUE  -- 
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 ******************************************************************************/
BOOLEAN
RpcConnectCallback(
    HANDLE hServer,     // needed?
    DWORD  *pResult,
    DWORD  Timeout,
    ULONG  AddressType,     // should be one of the TDI_ADDRESS_TYPE_XXX
    PBYTE  pAddress,        // should be one of the TDI_ADDRESS_XXX
    ULONG  AddressLength
    )
{
    NTSTATUS    Status;
    RPC_STATUS  RpcStatus;
    ICA_STACK_ADDRESS StackAddress;
    PICA_STACK_ADDRESS pStackAddress = &StackAddress;
    PTDI_ADDRESS_IP pTargetIpAddress;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: RpcConnectCallBack" ));

    if( ShutdownInProgress )
    {
        *pResult = STATUS_SYSTEM_SHUTDOWN;
        return FALSE;
    }

    //
    // We only support IPV4 address, Need to modify tdtcp.sys to support IPv6
    //
    if( AddressType != TDI_ADDRESS_TYPE_IP )
    {
        *pResult = STATUS_NOT_SUPPORTED;
        return FALSE;
    }

    //
    // Extra checking, making sure we gets everything.
    //
    if( AddressLength != TDI_ADDRESS_LENGTH_IP )
    {
        *pResult = STATUS_INVALID_PARAMETER;
        return FALSE;
    }

    ZeroMemory( &StackAddress , sizeof( ICA_STACK_ADDRESS ) );    

    // 
    // ??? What other security we want to apply here
    //

    /*
     * Impersonate the client
     */
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: RpcWinStationShadowStop: Not impersonating! RpcStatus 0x%x\n",RpcStatus));
        Status =  STATUS_CANNOT_IMPERSONATE;
        goto done;
    }

    //
    // For Whistler, this call is Salem rdshost.exe only, rdshost.exe is kick off by helpctr
    // running under system context.
    //
    if( !IsCallerSystem() ) {

#if DISABLESECURITYCHECKS

        //
        // Private testing only, allowing administrator to make this call.
        //
        if( !IsCallerAdmin() ) {
            RpcRevertToSelf();    
            Status = STATUS_ACCESS_DENIED;
            goto done;
        }
#else

        RpcRevertToSelf();    
        Status = STATUS_ACCESS_DENIED;
        goto done;

#endif

    }

    RpcRevertToSelf();


    //
    // winsta.h, byte 0, 1, family, 2-n address.
    //
    *(PUSHORT)pStackAddress = (USHORT)AddressType;
    if ( AddressLength <= (sizeof(ICA_STACK_ADDRESS) - 2) ) {
        //
        // Refer to TDI_ADDRESS_IP, last 8 char is not use.
        // Adding a timeout to pass into TD will require changes to ICA_STACK_ADDRESS
        // too risky for Whister but needed on next.
        //
        pTargetIpAddress = (PTDI_ADDRESS_IP)pAddress;
        RtlCopyMemory( &(pTargetIpAddress->sin_zero[0]), &Timeout, sizeof(Timeout) );

        RtlCopyMemory( &((PCHAR)pStackAddress)[2], pAddress, AddressLength );
    } else {
        Status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    #if DBG
    {
        PULONG pData = (PULONG)pStackAddress;
        PTDI_ADDRESS_IP pIpAddress = (PTDI_ADDRESS_IP)&((PCHAR)pStackAddress)[2];

        DbgPrint(
                "TERMSRV: Connect API: address port %u  address 0x%x (%u.%u.%u.%u)\n",
                ntohs(pIpAddress->sin_port),
                pIpAddress->in_addr,
                (pIpAddress->in_addr & 0xff000000) >> 24,
                (pIpAddress->in_addr & 0x00ff0000) >> 16,
                (pIpAddress->in_addr & 0x0000ff00) >> 8,
                (pIpAddress->in_addr & 0x000000ff)
            );
    }
    #endif

    Status = TransferConnectionToIdleWinStation( NULL, // no listen winstation
                                                 NULL, // no Endpoint,
                                                 0, //  EndpointLength,
                                                 &StackAddress );

done:

    *pResult = Status;

    return( NT_SUCCESS(*pResult) ? TRUE : FALSE );
}

//*************************************************************
//
//  IsGinaVersionCurrent()
//
//  Purpose:    Loads the gina DLL and negotiates the version number
//
//  Parameters: NONE
//
//  Return:     TRUE  if gina is of current version
//              FALSE if version of gina is not current
//                    or in case of any error
//
//*************************************************************

BOOL 
IsGinaVersionCurrent()
{
    HMODULE hGina = NULL;
    LPWSTR wszGinaName = NULL;
    PWLX_NEGOTIATE pWlxNegotiate = NULL;
    DWORD dwGinaLevel = 0;
    BOOL bResult = FALSE;
    
    wszGinaName = (LPWSTR) LocalAlloc(LPTR,(MAX_PATH+1)*sizeof(WCHAR));

    if(!wszGinaName)
    {
        //
        //Not enough memory
        //
        return FALSE;
    }

    GetProfileStringW(
                L"WINLOGON",
                L"GinaDll",
                L"msgina.dll",
                wszGinaName,
                MAX_PATH);
    
    
    if(!_wcsicmp(L"msgina.dll",wszGinaName))
    {
        //
        //If it is "msgina.dll", 
        //assume that it is a Windows native gina.
        //
        LocalFree(wszGinaName);
        return TRUE;
    }

    //
    //Load gina
    //if we cannot load gina, assume that it is incompatible
    //with TS
    //
    hGina = LoadLibraryW(wszGinaName);

    if (hGina)
    {
        //
        // Get the "WlxNegotiate" function pointer
        //
        pWlxNegotiate = (PWLX_NEGOTIATE) GetProcAddress(hGina, WLX_NEGOTIATE_NAME);

        if (pWlxNegotiate)
        {
            //
            // Negotiate a version number with the gina
            //
            
            if ( pWlxNegotiate(WLX_CURRENT_VERSION, &dwGinaLevel) && 
                (dwGinaLevel == WLX_CURRENT_VERSION) )
            {
                bResult = TRUE;
            }

        }

        FreeLibrary(hGina);
    }
    
    LocalFree(wszGinaName);
    return bResult;
}

/*++ 

    RPCWinStationNotifyDisconnectPipe notifies session 0 Winlogon to disconnect from the autologon named pipe
    
Parameters:

    ClientSessionId : Session ID of the calling process

    ClientProcessId : Process ID of the calling process
    
    
Returns:

    TRUE if notification is successful, FALSE otherwise

--*/

BOOLEAN
RpcWinStationNotifyDisconnectPipe(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )
{
    
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }


    *pResult = WinStationNotifyDisconnectPipeWorker(
                    ClientLogonId,
                    ClientProcessId
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationNotifyDisconnectPipeWorker
 *
 *   Worker function for RpcWinstationNotifyDisconnectPipe
 ****************************************************************************/
NTSTATUS WinStationNotifyDisconnectPipeWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )

{
    PWINSTATION pWinStation, pTargetWinStation;
    ULONG Length;
    NTSTATUS Status = STATUS_SUCCESS;
    WINSTATION_APIMSG DisconnectPipeMsg;
    DWORD SessionZeroLogonId = 0; 

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationNotifyDisconnectPipeWorker, ClientLogonId=%d \n", ClientLogonId));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Upper level code has verified that this RPC
     * is coming from a local client with SYSTEM access.
     *
     * We should be able to trust the ClientProcessId from
     * SYSTEM code.
     */

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        Status = STATUS_ACCESS_DENIED; 
        ReleaseWinStation( pWinStation );
        goto done;
    }

    ReleaseWinStation(pWinStation); 

    /*
     * Send the Notification to disconnect the autologon Pipe to Winlogon in session 0
     */
    pTargetWinStation = FindWinStationById( SessionZeroLogonId, FALSE );
    if ( pTargetWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    DisconnectPipeMsg.ApiNumber = SMWinStationNotify;
    DisconnectPipeMsg.WaitForReply = FALSE;
    DisconnectPipeMsg.u.DoNotify.NotifyEvent = WinStation_Notify_DisconnectPipe;
    Status = SendWinStationCommand( pTargetWinStation, &DisconnectPipeMsg, 0 );

    /*
     * Release the winstation lock
     */
    ReleaseWinStation( pTargetWinStation );

done:
    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinstationNotifyDisconnectPipeWorker, Status=0x%x\n", Status ));
    return Status;

}


/*++ 

    RpcWinstationSessionInitialized informs termsrv that winlogon has created the window station and desktop for this session
    
Parameters:

    ClientSessionId : Session ID of the calling process

    ClientProcessId : Process ID of the calling process
    
    
Returns:

    TRUE if everything went well. FALSE otherwise

--*/

BOOLEAN
RpcWinStationSessionInitialized(
    HANDLE      hServer,
    DWORD       *pResult,
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )
{
    
    NTSTATUS Status;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Make sure the caller is SYSTEM (WinLogon) 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }


    *pResult = WinStationSessionInitializedWorker(
                    ClientLogonId,
                    ClientProcessId
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationSessionInitializedWorker
 *
 *   Worker function for RpcWinstationSessionInitialized
 ****************************************************************************/
NTSTATUS WinStationSessionInitializedWorker(
    DWORD       ClientLogonId,
    ULONG_PTR   ClientProcessId
    )

{
    PWINSTATION pWinStation;
    NTSTATUS Status = STATUS_SUCCESS;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationSessionInitializedWorker, ClientLogonId=%d \n", ClientLogonId));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    /*
     * Find and lock client WinStation
     */
    pWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Ensure this is WinLogon calling
     */
    if ( (HANDLE)(ULONG_PTR)ClientProcessId != pWinStation->InitialCommandProcessId ) {
        Status = STATUS_ACCESS_DENIED; 
        ReleaseWinStation( pWinStation );
        goto done;
    }

    // Set the Event to indicate Session is initialized
    if (pWinStation->SessionInitializedEvent) {
        SetEvent(pWinStation->SessionInitializedEvent);
    }

    ReleaseWinStation(pWinStation); 

done:
    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinstationSessionInitializedWorker, Status=0x%x\n", Status ));
    return Status;

}

/*******************************************************************************
 *  RpcWinStationAutoReconnect
 *
 *   Does atomic autoreconnection policy work
 *
 * ENTRY:
 *    IN  hServer - RPC caller handle - API restricted to local use
 *    OUT pResult - Result code in NTSTATUS format with information class set
 *    IN  LogonId - Session to autoreconnect
 *    IN  flags   - extra options (currently unused)
 *
 * EXIT:
 *    STATUS_SUCCESS             - if we successfully autoreconnected
 *    STATUS_CTX_WINSTATION_BUSY - if session is already disconnected, or busy
 *    STATUS_ACCESS_DENIED       - if the target winstation was not found
 *                                 or if the autoreconnection check failed
 *    STATUS_NOT_FOUND           - autoreconnect info was not specified
 ******************************************************************************/
BOOLEAN
RpcWinStationAutoReconnect(
   SERVER_HANDLE hServer,
   DWORD         *pResult,
   DWORD         LogonId,
   DWORD         flags
   )
{
    RPC_STATUS RpcStatus;
    UINT LocalFlag = 0;
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PWINSTATION pSourceWinStation = NULL;
    PWINSTATION pTargetWinStation = NULL;
    TS_AUTORECONNECTINFO autoReconnectInfo;
    BYTE abClientRandom[512];
    LONG cbClientRandomLen = 0;
    ULONG BytesGot = 0;
    DWORD SourceID;
    DWORD TargetID;
    
    if(!hServer)
    {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    TRACE((hTrace,TC_ICASRV,TT_API2,"RPC RpcWinStationAutoReconnect for %d\n",
           LogonId));

    //
    // Only allow system caller for security reasons
    //

    RpcStatus = RpcImpersonateClient(NULL);
    if (RpcStatus != RPC_S_OK) {
        Status = STATUS_UNSUCCESSFUL;
        goto rpcaccessdenied;
    }

    //
    //  Check for System caller
    //
    if (!IsCallerSystem()) {
        RpcRevertToSelf();
        Status = STATUS_ACCESS_DENIED;
        goto rpcaccessdenied;
    }
    RpcRevertToSelf();


    //
    // Only allow local access for security reasons
    //
    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) {
        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL,
                   "TERMSRV: RpcWinStationAutoReconnect:" \
                   "I_RpcBindingIsClientLocal() failed: 0x%x\n", RpcStatus));
        Status = STATUS_UNSUCCESSFUL;
        goto rpcaccessdenied;
    }

    //
    // Do the check for local access
    //
    if (!LocalFlag) {
        Status = (DWORD)STATUS_INVALID_PARAMETER;
        goto rpcaccessdenied;
    }

    pSourceWinStation = FindWinStationById( LogonId, FALSE);
    if (pSourceWinStation == NULL) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR,
               "RpcWinStationAutoReconnect source session not found: %d\n",
               LogonId));

        Status = STATUS_ACCESS_DENIED;
        goto badconnectsource;
    }

    if (pSourceWinStation->Terminating ||
        pSourceWinStation->StateFlags & WSF_ST_WINSTATIONTERMINATE ||
        !pSourceWinStation->WinStationName[0]) {

        TRACE((hTrace,TC_ICASRV,TT_ERROR,
               "RpcWinStationAutoReconnect source session disconnected %d\n",
               LogonId));

        Status = STATUS_ACCESS_DENIED;
        goto badconnectsource;
    }

    if (pSourceWinStation->Flags) {
        Status = STATUS_CTX_WINSTATION_BUSY;
        goto badconnectsource;
    }

    //
    // Check if Winstation logons are disabled and prevent ARC from
    // happening in this case. Bug#532238
    //
    if (GetProfileInt(APPLICATION_NAME, WINSTATIONS_DISABLED, 0) == 1) {
        
        //
        // Fail the ARC and tell the client
        //
        Status = STATUS_ACCESS_DENIED;
        pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus(
                    pSourceWinStation->pWsxContext,
                    0,
                    FALSE); //stack lock held

        ReleaseWinStation(pSourceWinStation);
        pSourceWinStation = NULL;
        goto done;
    }


    //
    // Get the client autoreconnect info
    //
    if (pSourceWinStation->pWsx &&
        pSourceWinStation->pWsx->pWsxEscape) {
        Status = pSourceWinStation->pWsx->pWsxEscape(
                                              pSourceWinStation->pWsxContext,
                                              GET_CS_AUTORECONNECT_INFO,
                                              NULL,
                                              0,
                                              &autoReconnectInfo,
                                              sizeof(autoReconnectInfo),
                                              &BytesGot);
    }
    TRACE((hTrace,TC_ICASRV,TT_API3,
           "RpcWinStationAutoReconnect get GET_CS_AUTORECONNECT_INFO: 0x%x\n",
           Status));

    if (0 == BytesGot ) {

        //
        // Skip the rest of the processing if we didn't get any arc info
        //

        //
        // This is not strictly an error condition, the client could have
        // just not sent up any autoreconnect info
        //

        Status = STATUS_NOT_FOUND;
        goto badconnectsource;
    }

    //
    // Get the client random
    //
    if (NT_SUCCESS(Status)) {
        if (pSourceWinStation->pWsx &&
            pSourceWinStation->pWsx->pWsxEscape) {
            Status = pSourceWinStation->pWsx->pWsxEscape(
                                              pSourceWinStation->pWsxContext,
                                              GET_CLIENT_RANDOM,
                                              NULL,
                                              0,
                                              &abClientRandom,
                                              sizeof(abClientRandom),
                                              &BytesGot);

            TRACE((hTrace,TC_ICASRV,TT_API3,
                   "RpcWinStationAutoReconnect get GET_CLIENT_RANDOM: 0x%x\n",
                   Status));

        }
    }

    //
    // Source winstation locked here
    // Target not set yet
    //

    if (NT_SUCCESS(Status)) {

        cbClientRandomLen = BytesGot;

        //
        // Flag the winstation as part of the autoreconnection
        // to prevent a race where it might be reconnected somewhere
        // else while we unlock it
        //
        pSourceWinStation->Flags |= WSF_AUTORECONNECTING;
        SourceID = pSourceWinStation->LogonId;

        //
        // Unlock the winstation because we are about to try to
        // lock the target winstation
        //
        UnlockWinStation(pSourceWinStation);

        //
        // Use the autoreconnect info to find the target winstation
        // Returns a LOCKED winstation on success
        //
        pTargetWinStation = GetWinStationFromArcInfo(
            (PBYTE)abClientRandom,
            cbClientRandomLen,
            (PTS_AUTORECONNECTINFO)&autoReconnectInfo
            );

        if (pTargetWinStation) {

            //
            // Check if the target is busy or if AutoReconnect is disallowed
            //
            if (pTargetWinStation->Flags || pTargetWinStation->fDisallowAutoReconnect) {

                if (pTargetWinStation->fDisallowAutoReconnect) {
                    Status = STATUS_ACCESS_DENIED;
                } else {
                    Status = STATUS_CTX_WINSTATION_BUSY;
                }

                ReleaseWinStation(pTargetWinStation);
                pTargetWinStation = NULL;

                RelockWinStation(pSourceWinStation);

                //
                // Tell the client that ARC failed
                //
                if (pSourceWinStation->pWsx &&
                    pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus) {

                            pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus(
                                    pSourceWinStation->pWsxContext,
                                    0,
                                    FALSE); //stack lock held
                }

                pSourceWinStation->Flags &= ~WSF_AUTORECONNECTING;
                ReleaseWinStation(pSourceWinStation);

                goto done;
            }

            //
            // Success! We found a winstation to autoreconnect to
            // flag it and unlock it so we can make the connect call
            //
            TargetID = pTargetWinStation->LogonId;
            pTargetWinStation->Flags |= WSF_AUTORECONNECTING;
            UnlockWinStation(pTargetWinStation);

        }
        else {

            TRACE((hTrace,TC_ICASRV,TT_ERROR,
                   "TERMSRV: GetWinStationFromArcInfo failed\n"));

            //
            // Relock the source and cancel the autoreconnect flag
            //
            if (RelockWinStation(pSourceWinStation)) {

                //
                // Tell the client that ARC failed
                //
                if (pSourceWinStation->pWsx &&
                    pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus) {
    
                        Status = pSourceWinStation->pWsx->pWsxSendAutoReconnectStatus(
                                    pSourceWinStation->pWsxContext,
                                    0,
                                    FALSE); //stack lock held
                }
            }
            else {
                //
                // This is a failure path anyway so it doesn't
                // matter if the winstation was deleted. It just means
                // we can't send status to the client
                //
            }

            pSourceWinStation->Flags &= ~WSF_AUTORECONNECTING;
            ReleaseWinStation(pSourceWinStation);
            pSourceWinStation = NULL;

            Status = STATUS_ACCESS_DENIED;
            
            goto done;
        }
    }
    else {
        goto badconnectsource;
    }

    //
    // At this point neither winstation is locked
    //

    if (NT_SUCCESS(Status)) {

        ASSERT(pTargetWinStation);

        //
        // Trigger an autoreconnection from Source->Target
        //
        TRACE((hTrace,TC_ICASRV,TT_API1,
               "RpcWinStationAutoReconnect doing ARC from %d to %d\n",
               SourceID, TargetID));

        //
        // Do the reconnection
        //
        // The autoreconnect flag allows the connect worker to properly
        // handle the WSF_AUTORECONNECTING flag whose purpose is to
        // prevent a race where the sessions could be reconnected while
        // the winstations are unlocked
        //
        Status = WinStationConnectWorker(
                    LOGONID_CURRENT,
                    TargetID,
                    SourceID,
                    NULL,
                    0,
                    TRUE,
                    TRUE //flag that this is an autoreconnection
                    );

        //
        // Relock and then release the source
        //
        if (!RelockWinStation(pSourceWinStation)) {
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        }
        pSourceWinStation->Flags &= ~WSF_AUTORECONNECTING;
        ReleaseWinStation(pSourceWinStation);
        pSourceWinStation = NULL;

        //
        // Relock and then release the target
        //
        if (!RelockWinStation(pTargetWinStation)) {
            Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        }
        pTargetWinStation->Flags &= ~WSF_AUTORECONNECTING;
        ReleaseWinStation(pTargetWinStation);
        pTargetWinStation = NULL;


        TRACE((hTrace,TC_ICASRV,TT_API1,
               "RpcWinStationAutoReconnect ARC ConnectWorker result: 0x%x\n",
               Status));

        if (NT_SUCCESS(Status)) {

            //
            // Call succeeded AND we autoreconnected
            //
            TRACE((hTrace,TC_ICASRV,TT_API1,
                   "RpcWinStationAutoReconnect ARC Succeeded\n"));
        }

    }
    goto done;

badconnectsource:
    if (pSourceWinStation) {
        ReleaseWinStation(pSourceWinStation);
    }
rpcaccessdenied:
done:
    *pResult = Status;

    return NT_SUCCESS(Status);
}

#ifdef DBG
void PrintClientInfo()
{
    RPC_STATUS status;
    RPC_CALL_ATTRIBUTES CallAttributes;

    TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: -|--------------------------------------------|-\n"));
    
    memset(&CallAttributes, 0, sizeof(CallAttributes));
    CallAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;
    CallAttributes.Flags = RPC_QUERY_SERVER_PRINCIPAL_NAME | RPC_QUERY_CLIENT_PRINCIPAL_NAME;

    RpcServerInqCallAttributes(NULL, &CallAttributes);

    if(CallAttributes.ServerPrincipalNameBufferLength)
    {
        CallAttributes.ServerPrincipalName = (WCHAR*)LocalAlloc(LPTR,
            CallAttributes.ServerPrincipalNameBufferLength);
        if(!CallAttributes.ServerPrincipalName)
        {
            TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: PrintClientInfo failed - no memory\n"));
            goto done;
        }
    }
    
    if(CallAttributes.ClientPrincipalNameBufferLength)
    {
        CallAttributes.ClientPrincipalName = (WCHAR*)LocalAlloc(LPTR,
            CallAttributes.ClientPrincipalNameBufferLength);
        if(!CallAttributes.ClientPrincipalName)
        {
            TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: PrintClientInfo failed - no memory\n"));
            goto done;
        }
    }
    
    status = RpcServerInqCallAttributes(NULL, &CallAttributes);

    if(status != RPC_S_OK)
    {
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: RpcServerInqCallAttributes failed - %d\n", status));
        return ;
    }

    if(CallAttributes.ServerPrincipalName)
    {
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Server SPN: %ws\n", CallAttributes.ServerPrincipalName));
    }

    if(CallAttributes.ClientPrincipalName)
    {
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Client SPN: %ws\n", CallAttributes.ClientPrincipalName));
    }

    switch(CallAttributes.AuthenticationLevel)
    {
    case RPC_C_AUTHN_LEVEL_DEFAULT:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_DEFAULT\n"));
        break;
    case RPC_C_AUTHN_LEVEL_NONE:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_NONE\n"));
        break;
    case RPC_C_AUTHN_LEVEL_CONNECT:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_CONNECT\n"));
        break;
    case RPC_C_AUTHN_LEVEL_CALL:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_CALL\n"));
        break;
    case RPC_C_AUTHN_LEVEL_PKT:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_PKT\n"));
        break;
    case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_PKT_INTEGRITY\n"));
        break;
    case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n"));
        break;
    default:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication level: UNKNOWN!!!\n"));
        break;
    }
    
    switch(CallAttributes.AuthenticationService)
    {
    case RPC_C_AUTHN_NONE:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_NONE\n"));
        break;
    case RPC_C_AUTHN_DCE_PRIVATE:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_DCE_PRIVATE\n"));
        break;
    case RPC_C_AUTHN_DCE_PUBLIC:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_DCE_PUBLIC\n"));
        break;
    case RPC_C_AUTHN_DEC_PUBLIC:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_DEC_PUBLIC\n"));
        break;
    case RPC_C_AUTHN_GSS_NEGOTIATE:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_GSS_NEGOTIATE\n"));
        break;
    case RPC_C_AUTHN_WINNT:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_WINNT\n"));
        break;
    case RPC_C_AUTHN_GSS_SCHANNEL:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_GSS_SCHANNEL\n"));
        break;
    case RPC_C_AUTHN_GSS_KERBEROS:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_GSS_KERBEROS\n"));
        break;
    case RPC_C_AUTHN_DPA:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_DPA\n"));
        break;
    case RPC_C_AUTHN_MSN:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_MSN\n"));
        break;
    case RPC_C_AUTHN_DIGEST:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_DIGEST\n"));
        break;
    case RPC_C_AUTHN_MQ:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_MQ\n"));
        break;
    case RPC_C_AUTHN_DEFAULT:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: RPC_C_AUTHN_DEFAULT\n"));
        break;
    default:
        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: Authentication service: UNKNOWN!!!\n"));
        break;
    }

done:
    if(CallAttributes.ServerPrincipalName)
    {
        LocalFree(CallAttributes.ServerPrincipalName);
    }
    if(CallAttributes.ClientPrincipalName)
    {
        LocalFree(CallAttributes.ClientPrincipalName);
    }

    TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: -|--------------------------------------------|-\n"));
}
#endif //DBG

RPC_STATUS __stdcall
RpcSecurityCallback(
        IN RPC_IF_HANDLE Interface,
        IN void *Context)
{
    RPC_STATUS status;
    WCHAR *szStringBinding = NULL;
    WCHAR *szProtSeq = NULL;
    RPC_CALL_ATTRIBUTES CallAttributes;  // this maps to RPC_CALL_ATTRIBUTES_V1
    BOOL bUsingLPC;
    BOOL bUsingNP;

#ifdef DBG
    //To enable tracing, set these registry values:
    //HKLM\System\CurrentControlSet\Control\TerminalServer:
    //TraceEnable=(dword)0x8
    //TraceClass=(dword)0x1
    //TraceDebugger=(dword)0x1
    PrintClientInfo();
#endif //DBG

    status = RpcBindingToStringBinding(Context, &szStringBinding);
    if(status != RPC_S_OK)
    {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: RpcBindingToStringBinding failed - %d\n", status));
        return ERROR_ACCESS_DENIED;
    }
    
    

    status = RpcStringBindingParse(szStringBinding,
                NULL, &szProtSeq, NULL, NULL, NULL);
    if(status != RPC_S_OK)
    {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: RpcStringBindingParse failed - %d\n", status));
        RpcStringFree(&szStringBinding);
        return ERROR_ACCESS_DENIED;
    }
    
    RpcStringFree(&szStringBinding);
    
    bUsingLPC = (!_wcsicmp(szProtSeq, L"ncalrpc"));
    bUsingNP  = (!_wcsicmp(szProtSeq, L"ncacn_np"));

    if(!bUsingLPC && !bUsingNP)
    {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Client is neither using named pipe nor LPC!\n"));
        RpcStringFree(&szProtSeq);
        return ERROR_ACCESS_DENIED;
    }
    
    RpcStringFree(&szProtSeq);

    memset(&CallAttributes, 0, sizeof(CallAttributes));
    CallAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;
    CallAttributes.Flags = 0;

    status = RpcServerInqCallAttributes(Context, &CallAttributes);
    
    if(status == RPC_S_BINDING_HAS_NO_AUTH && !g_MachinePolicy.fEncryptRPCTraffic)
    {
        //User must be authenticated at least on a transport level,
        //even when we are not in "Secure" mode.
        status = RpcImpersonateClient(NULL);
        if(status != RPC_S_OK)
        {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Cannot impersonate client: %d\n",status));
            return ERROR_ACCESS_DENIED;
        }
        
        //No anonymous calls are allowed.
        if(IsCallerAnonymous())
        {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Caller is ANONYMOUS!\n"));
            RpcRevertToSelf();
            return ERROR_ACCESS_DENIED;
        }
        
        RpcRevertToSelf();
        
        //We are not in "Secure" mode. Nothing more to check out.
        return RPC_S_OK;
    }

    if(status != RPC_S_OK)
    {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: RpcServerInqCallAttributes failed - %d\n", status));
        return ERROR_ACCESS_DENIED;
    }
    
    if(g_MachinePolicy.fEncryptRPCTraffic)
    {
        //Check authentication level only when we in "Secure" mode.
        if(CallAttributes.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: AuthLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY\n"));
            return ERROR_ACCESS_DENIED;
        }
    }
            
    if(CallAttributes.NullSession != 0)
    {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: NULL SESSION!\n"));
        return ERROR_ACCESS_DENIED;
    }

    return RPC_S_OK;
}

RPC_STATUS
RegisterRPCInterface( 
        BOOL bReregister)
{
    RPC_STATUS Status;
    static BOOL bRunSecure = FALSE;
    WCHAR *szDefaultSPN = NULL;

    TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: IN RegisterRPCInterface Reregister=%d OldSecure= %d Secure=%d\n",bReregister, bRunSecure, g_MachinePolicy.fEncryptRPCTraffic));

    if(bReregister)
    {
        if( bRunSecure == g_MachinePolicy.fEncryptRPCTraffic )
        {
            return RPC_S_OK;
        }

    }
    else
    {
        Status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &szDefaultSPN);
        if( Status != RPC_S_OK ) 
        {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcServerInqDefaultPrincName\n",Status));
            return( Status );
        }

        Status = RpcServerRegisterAuthInfo(
                szDefaultSPN,        // service SPN,
                RPC_C_AUTHN_GSS_NEGOTIATE,
                NULL,
                NULL );
        if (szDefaultSPN) {
            RpcStringFree(&szDefaultSPN);
        }

        if( Status != RPC_S_OK ) 
        {
            TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcServerRegisterAuthInfo\n",Status));
            return( Status );
        }

        TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: RpcServerRegisterAuthInfo OK!\n"));
    }

    bRunSecure = g_MachinePolicy.fEncryptRPCTraffic;
    
    
    // Register our interface handle
    Status = RpcServerRegisterIfEx(
                     IcaApi_ServerIfHandle,  
                     NULL,   
                     NULL,
                     bRunSecure ? RPC_IF_ALLOW_SECURE_ONLY : RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,
                     RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                     &RpcSecurityCallback);

    if( Status != RPC_S_OK ) 
    {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d RpcServerRegisterIf\n",Status));
        return( Status );
    }

    TRACE((hTrace,TC_ICASRV,TT_API4,"TERMSRV: RpcServerRegisterIfEx OK!\n"));
    return( Status );
}

/*++ 

RpcWinStationCheckAccess - find out if a User has a specific access to a WinStation
    
Parameters:

    ClientLogonId : Session ID of the calling process
    UserToken : Token of the User whose access needs to be determined
    TargetLogonId : Target Session Id against whom we should verify Access
    AccessMask : Desired Access - eg. WINSTATION_LOGON
    
Returns:

    TRUE if User has required Access. FALSE otherwise

--*/

BOOLEAN
RpcWinStationCheckAccess(
    HANDLE      hServer,
    DWORD       *pResult,
    ULONG       ClientLogonId,
    DWORD       UserToken,
    ULONG       TargetLogonId,
    ULONG       AccessMask
    )
{
    
    NTSTATUS Status;
    
    if(!hServer) {
        *pResult = STATUS_UNSUCCESSFUL;
        return( FALSE );
    }

    /*
     * Make sure the caller is SYSTEM 
     */
    Status = RpcCheckSystemClient( ClientLogonId );
    if ( !NT_SUCCESS( Status ) ) {
        *pResult = Status;
        return( FALSE );
    }


    *pResult = WinStationCheckAccessWorker(
                    ClientLogonId,
                    UserToken,
                    TargetLogonId,
                    AccessMask
                    );

    return( *pResult == STATUS_SUCCESS ? TRUE : FALSE );
}

/*****************************************************************************
 *  WinStationCheckAccessWorker
 *
 *   Worker function for RpcWinStationCheckAccess
 ****************************************************************************/
NTSTATUS WinStationCheckAccessWorker(
    ULONG       ClientLogonId,
    DWORD       UserToken,
    ULONG       TargetLogonId,
    ULONG       AccessMask
    )

{
    PWINSTATION pWinStation, pClientWinStation;
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE ClientToken, NewToken, ImpersonationToken;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    OBJECT_ATTRIBUTES ObjA;
    BOOL bAccessCheckOk = FALSE;

    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCheckAccessWorker, ClientLogonId=%d \n", ClientLogonId));

    if ( ShutdownInProgress ) {
        return ( STATUS_CTX_WINSTATION_ACCESS_DENIED );
    }

    pClientWinStation = FindWinStationById( ClientLogonId, FALSE );
    if ( pClientWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto done;
    }

    /*
     * Get a valid copy of the clients token handle
     */
    Status = NtDuplicateObject( pClientWinStation->InitialCommandProcess,
                                (HANDLE)LongToHandle( UserToken ),
                                NtCurrentProcess(),
                                &ClientToken,
                                0, 0,
                                DUPLICATE_SAME_ACCESS |
                                DUPLICATE_SAME_ATTRIBUTES );

    if (Status != STATUS_SUCCESS) {
        ReleaseWinStation(pClientWinStation);
        goto done;
    }

    ReleaseWinStation(pClientWinStation);

    /*
     * ClientToken is a primary token - create an impersonation token
     * version of it so we can set it on our thread
     */
    InitializeObjectAttributes( &ObjA, NULL, 0L, NULL, NULL );

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    ObjA.SecurityQualityOfService = &SecurityQualityOfService;

    Status = NtDuplicateToken( ClientToken,
                               TOKEN_IMPERSONATE,
                               &ObjA,
                               FALSE,
                               TokenImpersonation,
                               &ImpersonationToken );
    if (Status != STATUS_SUCCESS) {
        NtClose(ClientToken);
        goto done;
    }

    /*
     * Impersonate the client
     */
    Status = NtSetInformationThread( NtCurrentThread(),
                                     ThreadImpersonationToken,
                                     (PVOID)&ImpersonationToken,
                                     (ULONG)sizeof(HANDLE) );
    if ( Status != STATUS_SUCCESS ) {
        goto CloseTokens;
    }

    /*
     * Find and lock Target WinStation
     */
    pWinStation = FindWinStationById( TargetLogonId, FALSE );
    if ( pWinStation == NULL ) {
        Status = STATUS_CTX_WINSTATION_NOT_FOUND;
        goto CloseTokens;
    }

    Status = RpcCheckClientAccess(pWinStation, AccessMask, TRUE);

    /*
     * Revert back to our threads default token.
     */
    NewToken = NULL;
    NtSetInformationThread( NtCurrentThread(),
                            ThreadImpersonationToken,
                            (PVOID)&NewToken,
                            (ULONG)sizeof(HANDLE) );

    ReleaseWinStation(pWinStation); 

CloseTokens:
    NtClose(ImpersonationToken);
    NtClose(ClientToken);

done:
    /*
     * Save return status in API message
     */
    TRACE((hTrace,TC_ICASRV,TT_API1, "TERMSRV: WinStationCheckAccess, Status=0x%x\n", Status ));
    return Status;

}

/*****************************************************************************
 *  RpcWinStationOpenSessionDirectory
        Ping SD to see if it can accept RPC call
        
        Params: 
            hServer: not used
            pszServerName: SD server name
        Return:
            ERROR_SUCCESS if SD can accept RPC call
            otherwise NT error code is returned
 ****************************************************************************/
BOOLEAN RpcWinStationOpenSessionDirectory(
           HANDLE hServer,
           DWORD *pResult,
           PWCHAR pszServerName)
{
    RPC_STATUS RpcStatus;
    DWORD SessDirError;

    if(!hServer || !pszServerName || !*pszServerName)
    {
        *pResult = STATUS_INVALID_PARAMETER;
        goto Exit;
    }

    if ( ShutdownInProgress ) 
    {
        *pResult = STATUS_CTX_WINSTATION_ACCESS_DENIED;
        goto Exit;
    }

    // TS can only participate in session directory if it is in
    // app. server mode and is ADS SKU
    if( g_bPersonalTS || !g_fAppCompat || !g_bAdvancedServer ) 
    {
        *pResult = STATUS_UNSUCCESSFUL;
        goto Exit;
    }

    // Impersonate client and only allow service and admin to call
    RpcStatus = RpcImpersonateClient( NULL );
    if( RpcStatus != RPC_S_OK ) 
    {
        *pResult =  STATUS_CANNOT_IMPERSONATE;
        goto Exit;
    }

    if ( !(IsCallerSystem() || IsCallerAdmin()) ) 
    {
        *pResult = STATUS_ACCESS_DENIED;
        RpcRevertToSelf();
        goto Exit;
    }
    RpcRevertToSelf();

    SessDirError = SessDirOpenSessionDirectory( pszServerName );
    *pResult = WinStationWinerrorToNtStatus( SessDirError );
Exit:

    return(*pResult == STATUS_SUCCESS ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\server\wsxmgr.c ===
/*************************************************************************
*
* wsxmgr.c
*
* Routines to manage Window Station extensions.
*
* Copyright Microsoft Corporation, 1998
*
*
*************************************************************************/


#include "precomp.h"
#pragma hdrstop


/*=============================================================================
==   Macros
=============================================================================*/


/*=============================================================================
==   External procedures defined
=============================================================================*/

PWSEXTENSION FindWinStationExtensionDll( PWSTR pszWsxDll, ULONG WdFlag );


/*=============================================================================
==   Local Data
=============================================================================*/

RTL_CRITICAL_SECTION WsxListLock;
RTL_CRITICAL_SECTION WsxLoadLock;
LIST_ENTRY WsxListHead;


/*=============================================================================
==   External Data
=============================================================================*/

extern LIST_ENTRY WinStationListHead;    // protected by WinStationListLock


/*******************************************************************************
 *
 *  WsxInit
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    STATUS_SUCCESS on success, the return value of InitCritSec on failure.
 *
 ******************************************************************************/

NTSTATUS
WsxInit( VOID )
{
    NTSTATUS Status;
    InitializeListHead( &WsxListHead );
    Status = RtlInitializeCriticalSection( &WsxLoadLock );
    if (Status == STATUS_SUCCESS) {
        Status = RtlInitializeCriticalSection( &WsxListLock );
        if (Status != STATUS_SUCCESS) {
            RtlDeleteCriticalSection(&WsxLoadLock);
        }
    }
    return(Status);
}


/*******************************************************************************
 *
 *  _WinStationEnumCallback
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

VOID
_WinStationEnumCallback(PCALLBACK_PRIMARY pPrimaryCallback,
                        PCALLBACK_COMPLETION pCompletionCallback,
                        PVOID pWsxEnum
)
{
    PLIST_ENTRY Head, Next;
    PWINSTATION pWinStation;

    RtlEnterCriticalSection( &WinStationListLock );

    //  call primary if valid
    if ( pPrimaryCallback ) {

        Head = &WinStationListHead;
        for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
            pWinStation = CONTAINING_RECORD( Next, WINSTATION, Links );
            if ( pWinStation->pWsx ) {
                pPrimaryCallback( pWinStation->pWsx->hInstance, pWinStation->pWsxContext, pWsxEnum );
            } else {
                pPrimaryCallback( NULL, pWinStation->pWsxContext, pWsxEnum );
            }
        }
    }

    //  call completion if valid
    if ( pCompletionCallback ) {
        pCompletionCallback( pWsxEnum );
    }

    RtlLeaveCriticalSection( &WinStationListLock );
}


/*******************************************************************************
 *
 *  _SendWinStationMessage
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
_SendWinStationMessage(
    ULONG LogonId,
    PWCHAR pTitle,
    PWCHAR pMessage,
    ULONG MessageTimeout )
{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;
    NTSTATUS Status;

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    /*
     *  Build message
     */
    msg.u.SendMessage.pTitle = pTitle;
    msg.u.SendMessage.TitleLength = wcslen( pTitle ) * sizeof(WCHAR);
    msg.u.SendMessage.pMessage = pMessage;
    msg.u.SendMessage.MessageLength = wcslen( pMessage ) * sizeof(WCHAR);
    msg.u.SendMessage.Style = MB_OK | MB_ICONSTOP;
    msg.u.SendMessage.Timeout = MessageTimeout;
    msg.u.SendMessage.Response = 0;
    msg.u.SendMessage.DoNotWait = TRUE;
    msg.u.SendMessage.DoNotWaitForCorrectDesktop = FALSE;
    msg.ApiNumber = SMWinStationDoMessage;
    
    // since we not going to wait for the message delievary, we dont care for status.
    msg.u.SendMessage.pStatus = NULL;  
    msg.u.SendMessage.pResponse = NULL;  
    msg.u.SendMessage.hEvent = NULL;

    /*
     *  Send message
     */
    Status = SendWinStationCommand( pWinStation, &msg, 0 );

    /*
     *  Done with winstation
     */
    ReleaseWinStation( pWinStation );

    return( Status );
}


/*******************************************************************************
 *
 *  _GetContextForLogonId
 *
 *
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
_GetContextForLogonId(
    ULONG LogonId,
    PVOID * ppWsxContext
    )
{
    PWINSTATION pWinStation;
    WINSTATION_APIMSG msg;

    /*
     * Find and lock the WinStation struct for the specified LogonId
     */
    pWinStation = FindWinStationById( LogonId, FALSE );
    if ( pWinStation == NULL ) {
        *ppWsxContext = NULL;
        return( STATUS_CTX_WINSTATION_NOT_FOUND );
    }

    /*
     *  Return context
     */
    *ppWsxContext = pWinStation->pWsxContext;

    /*
     *  Done with winstation
     */
    ReleaseWinStation( pWinStation );

    return( STATUS_SUCCESS );
}


/*******************************************************************************
 *
 *  _LoadWsxDll
 *
 *   Load and Initialize Window Station Extension DLL.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

PWSEXTENSION
_LoadWsxDll( PWSTR pszWsxDll )
{
    PWSEXTENSION    pWsx;
    HINSTANCE       hDllInstance;

    if ( pszWsxDll == NULL || *pszWsxDll == UNICODE_NULL )  
        return( NULL );

    hDllInstance = LoadLibrary(pszWsxDll);

    if (!hDllInstance) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Error %d, _LoadWsxDll(%s) failed\n",
                GetLastError(), pszWsxDll));
        return(NULL);
    }

    pWsx = MemAlloc( sizeof(WSEXTENSION) );
    if ( !pWsx ) {
        return(NULL);
    }
    RtlZeroMemory( pWsx, sizeof(WSEXTENSION) );

    RtlCopyMemory( pWsx->WsxDLL, pszWsxDll, sizeof(pWsx->WsxDLL) );
    pWsx->hInstance = hDllInstance;

    /*
     *  Initialize Dll support functions
     */
    pWsx->pWsxInitialize = (PWSX_INITIALIZE) GetProcAddress(hDllInstance, WSX_INITIALIZE);
    if (!pWsx->pWsxInitialize) {
        TRACE((hTrace,TC_ICASRV,TT_ERROR,"TERMSRV: Could not find pWsxInitialize entry point\n"));
        goto LoadWsx_ErrorReturn;
    }

    /*
     *  Client Drive Mapping Extensions
     */
    pWsx->pWsxCdmConnect = (PWSX_CDMCONNECT)
        GetProcAddress(hDllInstance,  WSX_CDMCONNECT);

    pWsx->pWsxCdmDisconnect = (PWSX_CDMDISCONNECT)
        GetProcAddress(hDllInstance,  WSX_CDMDISCONNECT);

    pWsx->pWsxVerifyClientLicense = (PWSX_VERIFYCLIENTLICENSE)
        GetProcAddress(hDllInstance, WSX_VERIFYCLIENTLICENSE);

    pWsx->pWsxQueryLicense = (PWSX_QUERYLICENSE)
        GetProcAddress(hDllInstance,  WSX_QUERYLICENSE);

    pWsx->pWsxGetLicense = (PWSX_GETLICENSE)
        GetProcAddress(hDllInstance,  WSX_GETLICENSE);

    pWsx->pWsxWinStationLogonAnnoyance = (PWSX_WINSTATIONLOGONANNOYANCE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONLOGONANNOYANCE);

    pWsx->pWsxWinStationGenerateLicense = (PWSX_WINSTATIONGENERATELICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONGENERATELICENSE);

    pWsx->pWsxWinStationInstallLicense = (PWSX_WINSTATIONINSTALLLICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONINSTALLLICENSE);

    pWsx->pWsxWinStationEnumerateLicenses = (PWSX_WINSTATIONENUMERATELICENSES)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONENUMERATELICENSES);

    pWsx->pWsxWinStationActivateLicense = (PWSX_WINSTATIONACTIVATELICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONACTIVATELICENSE);

    pWsx->pWsxWinStationRemoveLicense = (PWSX_WINSTATIONREMOVELICENSE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONREMOVELICENSE);

    pWsx->pWsxWinStationSetPoolCount = (PWSX_WINSTATIONSETPOOLCOUNT)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONSETPOOLCOUNT);

    pWsx->pWsxWinStationQueryUpdateRequired = (PWSX_WINSTATIONQUERYUPDATEREQUIRED)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONQUERYUPDATEREQUIRED);

    pWsx->pWsxWinStationAnnoyanceThread = (PWSX_WINSTATIONANNOYANCETHREAD)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONANNOYANCETHREAD);

    pWsx->pWsxInitializeClientData = (PWSX_INITIALIZECLIENTDATA)
        GetProcAddress(hDllInstance,  WSX_INITIALIZECLIENTDATA);

    pWsx->pWsxInitializeUserConfig = (PWSX_INITIALIZEUSERCONFIG)
        GetProcAddress(hDllInstance,  WSX_INITIALIZEUSERCONFIG);

    pWsx->pWsxConvertPublishedApp = (PWSX_CONVERTPUBLISHEDAPP)
        GetProcAddress(hDllInstance,  WSX_CONVERTPUBLISHEDAPP);

    pWsx->pWsxWinStationInitialize = (PWSX_WINSTATIONINITIALIZE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONINITIALIZE);

    pWsx->pWsxWinStationReInitialize = (PWSX_WINSTATIONREINITIALIZE)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONREINITIALIZE);

    pWsx->pWsxWinStationRundown = (PWSX_WINSTATIONRUNDOWN)
        GetProcAddress(hDllInstance,  WSX_WINSTATIONRUNDOWN);

    pWsx->pWsxDuplicateContext = (PWSX_DUPLICATECONTEXT)
        GetProcAddress(hDllInstance,  WSX_DUPLICATECONTEXT);

    pWsx->pWsxCopyContext = (PWSX_COPYCONTEXT)
        GetProcAddress(hDllInstance,  WSX_COPYCONTEXT);

    pWsx->pWsxClearContext = (PWSX_CLEARCONTEXT)
        GetProcAddress(hDllInstance,  WSX_CLEARCONTEXT);

    pWsx->pWsxVirtualChannelSecurity = (PWSX_VIRTUALCHANNELSECURITY)
        GetProcAddress(hDllInstance,  WSX_VIRTUALCHANNELSECURITY);

    pWsx->pWsxIcaStackIoControl = (PWSX_ICASTACKIOCONTROL)
        GetProcAddress(hDllInstance,  WSX_ICASTACKIOCONTROL);

    pWsx->pWsxBrokenConnection = (PWSX_BROKENCONNECTION)
        GetProcAddress(hDllInstance,  WSX_BROKENCONNECTION);

    pWsx->pWsxLogonNotify = (PWSX_LOGONNOTIFY)
        GetProcAddress(hDllInstance,  WSX_LOGONNOTIFY);

    pWsx->pWsxSetErrorInfo = (PWSX_SETERRORINFO)
        GetProcAddress(hDllInstance,  WSX_SETERRORINFO);

    pWsx->pWsxSendAutoReconnectStatus = (PWSX_SENDAUTORECONNECTSTATUS)
        GetProcAddress(hDllInstance, WSX_SENDAUTORECONNECTSTATUS);

    pWsx->pWsxEscape = (PWSX_ESCAPE)
        GetProcAddress(hDllInstance,  WSX_ESCAPE);

    return(pWsx);

LoadWsx_ErrorReturn:

    LocalFree(pWsx);
    return(NULL);
}


/*******************************************************************************
 *
 *  FindWinStationExtensionDll
 *
 *   Perform initialization of Window Station Extensions
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

PWSEXTENSION
FindWinStationExtensionDll( PWSTR pszWsxDll, ULONG WdFlag )
{
    PLIST_ENTRY Head, Next;
    PWSEXTENSION pWsx = NULL;
    ICASRVPROCADDR IcaSrvProcAddr;

    RtlEnterCriticalSection( &WsxLoadLock );
    RtlEnterCriticalSection( &WsxListLock );

    Head = &WsxListHead;
    for ( Next = Head->Flink; Next != Head; Next = Next->Flink ) {
        pWsx = CONTAINING_RECORD( Next, WSEXTENSION, Links );
        if ( !_wcsicmp( pszWsxDll, pWsx->WsxDLL ) ){
            break;
        }
    }

    RtlLeaveCriticalSection( &WsxListLock );
    if ( Next != Head ) {
        RtlLeaveCriticalSection( &WsxLoadLock );
        return( pWsx );
    }

    /*
     *  Load winstation extensions dll
     */
    if ( (pWsx = _LoadWsxDll( pszWsxDll )) != NULL ) {

        KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_TRACE_LEVEL, "TERMSRV: FindWinStationExtensionDll(%S) succeeded\n", pszWsxDll ));

        IcaSrvProcAddr.cbProcAddr               =
            (ULONG) sizeof(ICASRVPROCADDR);

        IcaSrvProcAddr.pNotifySystemEvent       =
            (PICASRV_NOTIFYSYSTEMEVENT) NotifySystemEvent;

        IcaSrvProcAddr.pSendWinStationMessage =
            (PICASRV_SENDWINSTATIONMESSAGE) _SendWinStationMessage;

        IcaSrvProcAddr.pGetContextForLogonId =
            (PICASRV_GETCONTEXTFORLOGONID) _GetContextForLogonId;

        IcaSrvProcAddr.pWinStationEnumCallBack  =
            (PICASRV_WINSTATIONENUMCALLBACK) _WinStationEnumCallback;

        //  initialize dll support procs
        if ( pWsx->pWsxInitialize( &IcaSrvProcAddr ) ) {
            RtlEnterCriticalSection( &WsxListLock );
            InsertHeadList( &WsxListHead, &pWsx->Links );
            RtlLeaveCriticalSection( &WsxListLock );
        } else {
            LocalFree( pWsx );
            pWsx = NULL;
            KdPrintEx((DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: FindWinStationExtensionDll(%S) failed\n", pszWsxDll ));
        }
    }
    else {
        KdPrintEx(( DPFLTR_TERMSRV_ID, DPFLTR_ERROR_LEVEL, "TERMSRV: FindWinStationExtensionDll(%S) failed\n", pszWsxDll ));
    }

    RtlLeaveCriticalSection( &WsxLoadLock );


    /*
     *  Create the thread which will monitor the condition of the
     *  WinFrame Licenses and if necessary send Annoyance Messages.
     */
    if ( pWsx && pWsx->pWsxWinStationAnnoyanceThread ) {
        DWORD ThreadId;
        HANDLE ThreadHandle;

        ThreadHandle = CreateThread( NULL,
                      0,
                      (LPTHREAD_START_ROUTINE)pWsx->pWsxWinStationAnnoyanceThread,
                      NULL,
                      THREAD_SET_INFORMATION,
                      &ThreadId );

        if(ThreadHandle )
            NtClose( ThreadHandle );
    }


    return( pWsx );
}


/*******************************************************************************
 *
 *  WsxStackIoControl
 *
 *   Callback routine called from ICAAPI.DLL to issue StackIoControl calls.
 *
 * ENTRY:
 *    nothing
 *
 * EXIT:
 *    nothing
 *
 ******************************************************************************/

NTSTATUS
WsxStackIoControl(
    IN PVOID pContext,
    IN HANDLE pStack,
    IN ULONG IoControlCode,
    IN PVOID pInBuffer,
    IN ULONG InBufferSize,
    OUT PVOID pOutBuffer,
    IN ULONG OutBufferSize,
    OUT PULONG pBytesReturned )
{
    PWINSTATION pWinStation = (PWINSTATION)pContext;
    NTSTATUS Status;

    TRACE((hTrace, TC_ICASRV, TT_API1,
           "TERMSRV: Enter WsxIcaIoControl, IoControlCode=%d\n",
           (IoControlCode >> 2) & 0xfff));

    if ( pWinStation &&
         pWinStation->pWsx &&
         pWinStation->pWsx->pWsxIcaStackIoControl ) {

        Status = pWinStation->pWsx->pWsxIcaStackIoControl(
                                pWinStation->pWsxContext,
                                pWinStation->hIca,
                                pStack,
                                IoControlCode,
                                pInBuffer,
                                InBufferSize,
                                pOutBuffer,
                                OutBufferSize,
                                pBytesReturned );
    } else {
        Status = IcaStackIoControl(
                                pStack,
                                IoControlCode,
                                pInBuffer,
                                InBufferSize,
                                pOutBuffer,
                                OutBufferSize,
                                pBytesReturned );
    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\assertbreak.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  AssertBreak.h
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ASSERT_BREAK_HMH_
#define _ASSERT_BREAK_HMH_

// Needed to add L to the __FILE__
#define __FRT2(x)      L ## x
#define _FRT2(x)       __FRT2(x)

// We'll need both of these values in case we're running in NT.
// Since our project is not an NT-only project, these are #ifdefd
// out of windows.h

#ifndef _WIN32_WINNT
#define MB_SERVICE_NOTIFICATION          0x00200000L
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

void WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFilename, int nLine );

#if (defined DEBUG || defined _DEBUG)
#define ASSERT_BREAK(exp)    \
    if (!(exp)) { \
        assert_break( _FRT2(#exp), _FRT2(__FILE__), __LINE__ ); \
    }
#else
#define ASSERT_BREAK(exp)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\makefile.inc ===
$(O)\tscfgwmi.mof $(O)\tscfgwmi.mfl: tscfgwmi.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\tscfgwmi.mof -MFL:$(O)\tscfgwmi.mfl tscfgwmi.mof
    copy $(O)\tscfgwmi.mof+$(O)\tscfgwmi.mfl $(O)\tscfgwmi.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\maksassert.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  Module Name:
*
*      maksassert.cpp
*
*  Abstract:
*
*      Implementas the assert functions.
*      maks_todo : use common assert macros instead.
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Comments
*   This file is here only because I could not find the right friendly assert includes.
*    maks_todo : should be removed later.
*/

#include "stdafx.h"
#include "maksassert.h"
#include <TCHAR.h>
//#define _UNICODE

void MaksAssert(LPCTSTR exp, LPCTSTR file, int line)
{
    TCHAR szMsg[1024];
    _stprintf(szMsg, _T("assertion [%s] failed at [%s,%d]. Want to Debug?\n"), exp, file, line);

#if defined(_LOGMESSAGE_INCLUDED_)
    LOGMESSAGE0(szMsg);
#endif

    OutputDebugString(szMsg);

    if (MessageBox(0, szMsg, _T("TsOc.dll"), MB_YESNO  ) == IDYES )
    {
        DebugBreak();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (C) 2000 Microsoft Corp.
//
//***************************************************************************
#include "stdafx.h"
#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>
#include <regapi.h>
#include <tchar.h>
#include "trace.h"
#include "terminal.h"
#include "winstation.h"

HINSTANCE g_hInstance = NULL;

#ifdef UNICODE
#pragma message("Its unicode")
#else
#pragma message("Its ansi")
#endif 

//============

// {39524FB7-028F-4035-8C2B-8E65D2B17E67}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORY, 
0x39524fb7, 0x28f, 0x4035, 0x8c, 0x2b, 0x8e, 0x65, 0xd2, 0xb1, 0x7e, 0x67);

// {7970614A-BD82-439e-A828-CC96F8E91428}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALSERVICE, 
0x7970614a, 0xbd82, 0x439e, 0xa8, 0x28, 0xcc, 0x96, 0xf8, 0xe9, 0x14, 0x28);

// {6BD6AECA-AFB0-45b7-BAC4-F292EC0F3F41}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALSERVICESETTING, 
0x6bd6aeca, 0xafb0, 0x45b7, 0xba, 0xc4, 0xf2, 0x92, 0xec, 0xf, 0x3f, 0x41);

// {74628299-57EC-4f12-BA1C-08B477BF447A}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINAL,
0x74628299, 0x57ec, 0x4f12, 0xba, 0x1c, 0x8, 0xb4, 0x77, 0xbf, 0x44, 0x7a);

// {4C8A0917-F587-4ecf-9C89-48147528F4E1}
DEFINE_GUID(CLSID_CIM_WIN32_TSGENERALSETTING, 
0x4c8a0917, 0xf587, 0x4ecf, 0x9c, 0x89, 0x48, 0x14, 0x75, 0x28, 0xf4, 0xe1);

// {C41FF872-07B1-4926-819B-8C94E6B1FBB9}
DEFINE_GUID(CLSID_CIM_WIN32_TSLOGONSETTING, 
0xc41ff872, 0x7b1, 0x4926, 0x81, 0x9b, 0x8c, 0x94, 0xe6, 0xb1, 0xfb, 0xb9);

// {BE9B3133-250B-44a5-A278-C532B7B7FF76}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONSETTING, 
0xbe9b3133, 0x250b, 0x44a5, 0xa2, 0x78, 0xc5, 0x32, 0xb7, 0xb7, 0xff, 0x76);


// {9A17DFD1-34FA-4d61-B9BB-3A1097E7FADF}
DEFINE_GUID(CLSID_CIM_WIN32_TSENVIRONMENTSETTING, 
0x9a17dfd1, 0x34fa, 0x4d61, 0xb9, 0xbb, 0x3a, 0x10, 0x97, 0xe7, 0xfa, 0xdf);


// {DBD71B6B-F717-4a61-A914-2337BC50B0D6}
DEFINE_GUID(CLSID_CIM_WIN32_TSREMOTECONTROLSETTING, 
0xdbd71b6b, 0xf717, 0x4a61, 0xa9, 0x14, 0x23, 0x37, 0xbc, 0x50, 0xb0, 0xd6);


// {647BD8C2-658B-4eca-ABC7-FC5C0BF1704D}
DEFINE_GUID(CLSID_CIM_WIN32_TSCLIENTSETTING,
0x647bd8c2, 0x658b, 0x4eca, 0xab, 0xc7, 0xfc, 0x5c, 0xb, 0xf1, 0x70, 0x4d);


// {D25E0260-AAB7-48cb-A192-4D73D2FD375F}
DEFINE_GUID(CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING,
0xd25e0260, 0xaab7, 0x48cb, 0xa1, 0x92, 0x4d, 0x73, 0xd2, 0xfd, 0x37, 0x5f);


// {FA06375D-F0A4-4a47-AD8D-148595F1E0B8}
DEFINE_GUID(CLSID_CIM_WIN32_TSPERMISSIONSSETTING, 
0xfa06375d, 0xf0a4, 0x4a47, 0xad, 0x8d, 0x14, 0x85, 0x95, 0xf1, 0xe0, 0xb8);


// {7757BA9B-7986-4866-B53F-A31E89FCBA15}
DEFINE_GUID(CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING, 
0x7757ba9b, 0x7986, 0x4866, 0xb5, 0x3f, 0xa3, 0x1e, 0x89, 0xfc, 0xba, 0x15);


// {BDF9E8B8-6C66-4e45-BA15-E050393DD079}
DEFINE_GUID(CLSID_CIM_WIN32_TSACCOUNT, 
0xbdf9e8b8, 0x6c66, 0x4e45, 0xba, 0x15, 0xe0, 0x50, 0x39, 0x3d, 0xd0, 0x79);


// {B490264C-8D8F-40fd-B1BE-CD69AD779EC1}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALSERVICETOSETTING,
0xb490264c, 0x8d8f, 0x40fd, 0xb1, 0xbe, 0xcd, 0x69, 0xad, 0x77, 0x9e, 0xc1);

// {BA4EAC04-AFCE-441a-A4F0-C4A97545425A}
DEFINE_GUID(CLSID_CIM_WIN32_TERMINALTERMINALSETTING, 
0xba4eac04, 0xafce, 0x441a, 0xa4, 0xf0, 0xc4, 0xa9, 0x75, 0x45, 0x42, 0x5a);

// {CCBA37FC-982B-433b-8AC2-455E616A8559}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING, 
0xccba37fc, 0x982b, 0x433b, 0x8a, 0xc2, 0x45, 0x5e, 0x61, 0x6a, 0x85, 0x59);

CRITICAL_SECTION g_critsect;

CWin32_TerminalServiceSetting* g_pobj = NULL;

CWin32_TerminalService* g_pTerminalServiceObj = NULL;

CWin32_TSSessionDirectory* g_pTSSessionDirectoryObj = NULL;

CWin32_Terminal* g_pTerminalObj = NULL;

CWin32_TSGeneralSetting* g_pTSGeneralSettingObj = NULL;

CWin32_TSLogonSetting* g_pTSLogonSettingObj = NULL;

CWin32_TSSessionSetting* g_pTSSessionSettingObj = NULL;

CWin32_TSEnvironmentSetting* g_pTSEnvironmentSettingObj = NULL;

CWin32_TSRemoteControlSetting* g_pTSRemoteControlSettingObj = NULL;

CWin32_TSClientSetting* g_pTSClientSettingObj = NULL;

CWin32_TSNetworkAdapterSetting* g_pTSNetworkAdapterSettingObj = NULL;

CWin32_TSPermissionsSetting* g_pTSPermissionsSettingObj = NULL;

CWin32_TSNetworkAdapterListSetting* g_pTSNetworkAdapterListSettingObj = NULL;

CWin32_TSAccount* g_pTSAccountObj = NULL;

DEFINE_GUID(CLSID__CfgComp,0xBB0D7187,0x3C44,0x11D2,0xBB,0x98,0x30,0x78,0x30,0x2C,0x20,0x30);

DEFINE_GUID(IID__ICfgComp,0xBB0D7186,0x3C44,0x11D2,0xBB,0x98,0x30,0x78,0x30,0x2C,0x20,0x30);

//Count number of objects and number of locks.
long g_cLock=0;



/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue (

    wchar_t *pszKey, 
    wchar_t *pszSubkey, 
    wchar_t *pszValueName, 
    wchar_t *pszValue
)
{
    HKEY        hKey;
    TCHAR       szKey[MAX_PATH+1];

    if(lstrlen(pszKey) > MAX_PATH)
    {
        return FALSE;
    }
    
    lstrcpy(szKey, pszKey);    

    if (NULL!=pszSubkey && (lstrlen(pszKey)+lstrlen(pszSubkey)+1) <= MAX_PATH )
    {
        lstrcat(szKey, TEXT("\\"));
        lstrcat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, (LPCTSTR)pszValueName, 0, REG_SZ, (BYTE *)(LPCTSTR)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
            return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}


HRESULT RegisterServer (

    TCHAR *a_pName, 
    REFGUID a_rguid
)
{   
    WCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH];
    TCHAR * pName = TEXT("WBEM Framework Instance Provider");
    TCHAR * pModel;
    HKEY hKey1;

    GetModuleFileName(g_hInstance, szModule,  MAX_PATH);
    szModule[(sizeof(szModule)/sizeof(szModule[0]))-1] = L'\0';

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = TEXT("Apartment") ;
    else
        pModel = TEXT("Apartment") ;

    // Create the path.

    StringFromGUID2(a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    lstrcat(szCLSID, wcID);

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));

    lstrcat(szProviderCLSIDAppID, wcID);

    if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_pName ))
        return SELFREG_E_CLASS;
#endif

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)a_pName, (lstrlen(a_pName)+1) * 
        sizeof(TCHAR));


#ifdef LOCALSERVER

    if (FALSE ==SetKeyAndValue(szCLSID, TEXT("LocalServer32"), NULL,szModule))
        return SELFREG_E_CLASS;

    if (FALSE ==SetKeyAndValue(szCLSID, TEXT("LocalServer32"),TEXT("ThreadingModel"), pModel))
        return SELFREG_E_CLASS;
#else

    HKEY hKey2 ;
    RegCreateKey(hKey1, TEXT("InprocServer32"), &hKey2);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, TEXT("ThreadingModel"), 0, REG_SZ, 
        (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    CloseHandle(hKey2);

#endif

    CloseHandle(hKey1);

    return S_OK;
}

HRESULT UnregisterServer (

    REFGUID a_rguid
)
{
    TCHAR    szID[128];
    WCHAR    wcID[128];
    TCHAR    szCLSID[128];
    HKEY    hKey;

    // Create the path using the CLSID

    StringFromGUID2( a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    lstrcat(szCLSID, wcID);

    DWORD dwRet ;

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID,szCLSID);

    //Delete entries under APPID

    DWORD hrStatus = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

    TCHAR szTemp[128];
    _stprintf(szTemp, TEXT("%s\\%s"),szCLSID, TEXT("LocalServer32"));
    hrStatus = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

    // First delete the InProcServer subkey.

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, TEXT("InProcServer32") );
        CloseHandle(hKey);
    }

#endif

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }
    else
    {
        ERR((TB,"UnregisterServer ret 0x%x\n", dwRet));
    }

    return HRESULT_FROM_WIN32( dwRet );
    
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if     it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    CWbemGlueFactory *pObj;

    if ( ( CLSID_CIM_WIN32_TERMINALSERVICESETTING == rclsid ) || 
        ( CLSID_CIM_WIN32_TERMINAL == rclsid ) || ( CLSID_CIM_WIN32_TSGENERALSETTING == rclsid ) ||
        ( CLSID_CIM_WIN32_TSLOGONSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSSESSIONSETTING == rclsid ) ||
        ( CLSID_CIM_WIN32_TSENVIRONMENTSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSCLIENTSETTING == rclsid ) ||
        ( CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSPERMISSIONSSETTING == rclsid) ||
        ( CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING == rclsid ) || (CLSID_CIM_WIN32_TSACCOUNT == rclsid) ||
        ( CLSID_CIM_WIN32_TSREMOTECONTROLSETTING == rclsid ) || ( CLSID_CIM_WIN32_TERMINALSERVICE == rclsid ) || 
        ( CLSID_CIM_WIN32_TERMINALSERVICETOSETTING == rclsid ) || ( CLSID_CIM_WIN32_TERMINALTERMINALSETTING == rclsid) ||
        ( CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING == rclsid ) || ( CLSID_CIM_WIN32_TSSESSIONDIRECTORY == rclsid ))

    {
        EnterCriticalSection(&g_critsect);

        try{
            pObj =new CWbemGlueFactory () ;

            if (NULL==pObj)
            {                
                hr =  E_OUTOFMEMORY;
            }
            else
            {            
                hr=pObj->QueryInterface(riid, ppv);

                if (FAILED(hr))
                    delete pObj;
            }

            if( SUCCEEDED(hr) )
            {
                // EnterCriticalSection prevents more than one threads from instantiating the global pointers to the objects.

                if( g_pobj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TerminalServiceSetting object created"));

                    g_pobj = new CWin32_TerminalServiceSetting( PROVIDER_NAME_Win32_WIN32_TERMINALSERVICESETTING_Prov, L"root\\cimv2"); 
                }

                if( g_pTerminalServiceObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TerminalService object created"));

                    g_pTerminalServiceObj = new CWin32_TerminalService( PROVIDER_NAME_Win32_WIN32_TERMINALSERVICE_Prov, L"root\\cimv2");
                }
    
                if( g_pTSSessionDirectoryObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSSessionDirectory object created"));

                    g_pTSSessionDirectoryObj = new CWin32_TSSessionDirectory( PROVIDER_NAME_Win32_WIN32_TSSESSIONDIRECTORY_Prov, L"root\\cimv2");

                }

                if( g_pTerminalObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_Terminal object created"));

                    g_pTerminalObj = new CWin32_Terminal( PROVIDER_NAME_Win32_WIN32_TERMINAL_Prov, L"root\\cimv2");
                }

                if( g_pTSGeneralSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSGeneralSetting object created"));

                    g_pTSGeneralSettingObj = new CWin32_TSGeneralSetting( PROVIDER_NAME_Win32_WIN32_TSGENERALSETTING_Prov, L"root\\cimv2");
                }

                if( g_pTSLogonSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSLogonSetting object created"));

                    g_pTSLogonSettingObj = new CWin32_TSLogonSetting( PROVIDER_NAME_Win32_WIN32_TSLOGONSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSSessionSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSSessionSetting object created"));

                    g_pTSSessionSettingObj = new CWin32_TSSessionSetting( PROVIDER_NAME_Win32_WIN32_TSSESSIONSETTING_Prov, L"root\\cimv2");
                }

                if( g_pTSEnvironmentSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSEnvironmentSetting object created"));

                    g_pTSEnvironmentSettingObj = new CWin32_TSEnvironmentSetting( PROVIDER_NAME_Win32_WIN32_TSENVIRONMENTSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSRemoteControlSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TRemoteControlSetting object created"));

                    g_pTSRemoteControlSettingObj = new CWin32_TSRemoteControlSetting( PROVIDER_NAME_Win32_WIN32_TSREMOTECONTROLSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSClientSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSClientSetting object created"));

                    g_pTSClientSettingObj = new CWin32_TSClientSetting( PROVIDER_NAME_Win32_WIN32_TSCLIENTSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSNetworkAdapterSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSNetworkAdapterSetting object created"));

                    g_pTSNetworkAdapterSettingObj = new CWin32_TSNetworkAdapterSetting( PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSPermissionsSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSPermissionsSetting object created"));

                    g_pTSPermissionsSettingObj = new CWin32_TSPermissionsSetting( PROVIDER_NAME_Win32_WIN32_TSPERMISSIONSSETTING_Prov, L"root\\cimv2");                     

                }

                if( g_pTSNetworkAdapterListSettingObj == NULL )
                {
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSNetworkAdapterListSetting object created"));

                    g_pTSNetworkAdapterListSettingObj = new CWin32_TSNetworkAdapterListSetting( PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERLISTSETTING_Prov, L"root\\cimv2");

                }

                if( g_pTSAccountObj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_TSAccount object created"));

                    g_pTSAccountObj = new CWin32_TSAccount( PROVIDER_NAME_Win32_WIN32_TSACCOUNT_Prov, L"root\\cimv2");
                }
            }       
        }
        catch (...)
        {
            hr = E_OUTOFMEMORY;
        }

        LeaveCriticalSection(&g_critsect);

    }
    else
    {
        hr=E_FAIL;
        ERR((TB, "DllGetClassObject ret 0x%x\n" , hr));
    }

    return hr;
}



//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"TSCFGWMI"))
    {
        // EnterCriticalSection prevents multiple threads from accessing the global pointers concurrently and
        // allows only one thread access to free the objects based on the condition that g_cLock count is zero
        // and FrameworkLogoffDLL is TRUE.

		EnterCriticalSection(&g_critsect);

        if( g_pobj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TerminalServiceSetting object deleted"));

                delete g_pobj;

                g_pobj = NULL;
            }

            if( g_pTerminalServiceObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TerminalService object deleted"));

                delete g_pTerminalServiceObj;

                g_pTerminalServiceObj = NULL;
            }

            if( g_pTSSessionDirectoryObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSSessionDirectory object deleted"));

                delete g_pTSSessionDirectoryObj;

                g_pTSSessionDirectoryObj = NULL;
            }

            if( g_pTerminalObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_Terminal object deleted"));

                delete g_pTerminalObj;

                g_pTerminalObj = NULL;
            }

            if( g_pTSGeneralSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSGeneralSetting object deleted"));

                delete g_pTSGeneralSettingObj;

                g_pTSGeneralSettingObj = NULL;
            }

            if( g_pTSLogonSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSLogonSetting object deleted"));

                delete g_pTSLogonSettingObj;

                g_pTSLogonSettingObj = NULL;
            }

            if( g_pTSSessionSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSSessionSetting object deleted"));

                delete g_pTSSessionSettingObj;

                g_pTSSessionSettingObj = NULL;
            }

            if( g_pTSEnvironmentSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSEnvironmentSetting object deleted"));

                delete g_pTSEnvironmentSettingObj;

                g_pTSEnvironmentSettingObj = NULL;
            }

            if( g_pTSRemoteControlSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSRemoteControlSetting object deleted"));

                delete g_pTSRemoteControlSettingObj;

                g_pTSRemoteControlSettingObj = NULL;
            }

            if( g_pTSClientSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSClientSetting object deleted"));

                delete g_pTSClientSettingObj;

                g_pTSClientSettingObj = NULL;
            }

            if( g_pTSNetworkAdapterSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSNetworkAdapterSetting object deleted"));

                delete g_pTSNetworkAdapterSettingObj;

                g_pTSNetworkAdapterSettingObj = NULL;
            }

            if( g_pTSPermissionsSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSPermissionsSetting object deleted"));

                delete g_pTSPermissionsSettingObj;

                g_pTSPermissionsSettingObj = NULL;
            }

            if( g_pTSNetworkAdapterListSettingObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSNetworkAdapterListSetting object deleted"));

                delete g_pTSNetworkAdapterListSettingObj;

                g_pTSNetworkAdapterListSettingObj = NULL;
            }

            if( g_pTSAccountObj != NULL )
            {
                TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_TSAccount object deleted"));

                delete g_pTSAccountObj;

                g_pTSAccountObj = NULL;
            }

            // LeaveCriticalSection releases the critical section once the thread has freed all objects.

		    LeaveCriticalSection(&g_critsect);

        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
     //   ERR((TB, "DllCanUnloadNow ret 0x%x\n" , sc));
    }

    return sc;
}







//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    HRESULT hrStatus;


    hrStatus = RegisterServer( TEXT("WBEM Win32_TERMINALSERVICESETTING Provider"), CLSID_CIM_WIN32_TERMINALSERVICESETTING ) ;
    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TERMINALSERVICESETTING: succeeded"));      

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINAL Provider"), CLSID_CIM_WIN32_TERMINAL ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TERMINAL: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINALSERVICE Provider"), CLSID_CIM_WIN32_TERMINALSERVICE ) ;

    }


    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TERMINALSERVICE: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORY Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORY ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSSESSIONDIRECTORY: succeeded"));        
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSGENERALSETTING Provider"), CLSID_CIM_WIN32_TSGENERALSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSGENERALSETTING: succeeded")); 

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSLOGONSETTING Provider"), CLSID_CIM_WIN32_TSLOGONSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSLOGONSETTING: succeeded")); 
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONSETTING Provider"), CLSID_CIM_WIN32_TSSESSIONSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSSESSIONSETTING: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSENVIRONMENTSETTING Provider"), CLSID_CIM_WIN32_TSENVIRONMENTSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSENVIRONMENTSETTING: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSREMOTECONTROLSETTING Provider"), CLSID_CIM_WIN32_TSREMOTECONTROLSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSREMOTECONTROLSETTING: succeeded"));  

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSCLIENTSETTING Provider"), CLSID_CIM_WIN32_TSCLIENTSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSCLIENTSETTING: succeeded")); 
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSNETWORKADAPTERSETTING Provider"), CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSNETWORKADAPTERSETTING: succeeded"));
    
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSPERMISSIONSSETTING Provider"), CLSID_CIM_WIN32_TSPERMISSIONSSETTING ) ;

    }

    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSPERMISSIONSSETTING: succeeded"));
        
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSNETWORKADAPTERLISTSETTING Provider"), CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING ) ;

    }

    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSNETWORKADAPTERLISTSETTINGS: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSACCOUNT Provider"), CLSID_CIM_WIN32_TSACCOUNT ) ;
    }


    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_TSACCOUNT: succeeded"));  
        
        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINALSERVICETOSETTING Provider"), CLSID_CIM_WIN32_TERMINALSERVICETOSETTING ) ;
    }

    if (SUCCEEDED( hrStatus ) )
    {
        TRC2((TB, "RegisterServer Win32_TERMINALSERVICETOSETTING: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TERMINALTERMINALSETTING Provider"), CLSID_CIM_WIN32_TERMINALTERMINALSETTING ) ;
    }

    if (SUCCEEDED( hrStatus ) )
    {
        TRC2((TB, "RegisterServer Win32_TERMINALTERMINALSETTING: succeeded"));

        hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORYSETTING Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING ) ;
    }
    

    if (SUCCEEDED( hrStatus ) )
    {
        TRC2((TB, "RegisterServer Win32_TSSESSIONDIRECTORYSETTING: succeeded"));
    
    }

    return hrStatus;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    
    UnregisterServer( CLSID_CIM_WIN32_TERMINALSERVICE );

    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORY ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINALSERVICESETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINAL ) ;
    
    UnregisterServer( CLSID_CIM_WIN32_TSGENERALSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSLOGONSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSENVIRONMENTSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSREMOTECONTROLSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSCLIENTSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSNETWORKADAPTERSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSPERMISSIONSSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSNETWORKADAPTERLISTSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TSACCOUNT ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINALSERVICETOSETTING ) ;

    UnregisterServer( CLSID_CIM_WIN32_TERMINALTERMINALSETTING ) ;
    
    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORYSETTING ) ;

    return S_OK;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************


BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD  fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;

    // Perform actions based on the reason for calling.
    if( DLL_PROCESS_ATTACH == fdwReason )
    {

        DisableThreadLibraryCalls(hInstDLL);
        // CriticalSection object is initialized on Thread attach.

        __try
        {
		    InitializeCriticalSection(&g_critsect);                
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
         {
	        return E_FAIL;
         }    
            
        g_hInstance = hInstDLL ;
      
        bRet = CWbemProviderGlue :: FrameworkLoginDLL ( L"TSCFGWMI" ) ;
        
    }

    else if( DLL_PROCESS_DETACH == fdwReason )
    {
        // CriticalSection object is deleted

		DeleteCriticalSection(&g_critsect);

    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\smartptr.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  SmartPtr.h
//
//  Purpose: Declare smartpointer typedefs
//
//***************************************************************************

#pragma once
#include <io.h>

#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment, __uuidof(IUnsecuredApartment));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));
_COM_SMARTPTR_TYPEDEF(IWbemRefresher, __uuidof(IWbemRefresher));
_COM_SMARTPTR_TYPEDEF(IWbemHiPerfEnum, __uuidof(IWbemHiPerfEnum));
_COM_SMARTPTR_TYPEDEF(IWbemConfigureRefresher, __uuidof(IWbemConfigureRefresher));
_COM_SMARTPTR_TYPEDEF(IMofCompiler, __uuidof(IMofCompiler));
_COM_SMARTPTR_TYPEDEF(ExternalMethodContext, __uuidof(ExternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContext, __uuidof(InternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContextAsynch, __uuidof(InternalMethodContextAsynch));

class SmartCloseHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHandle(HANDLE h):m_h(h){}
   ~SmartCloseHandle(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class Smart_findclose
{

private:
	long m_h;

public:
	Smart_findclose():m_h(0){}
	Smart_findclose(long h):m_h(h){}
   ~Smart_findclose(){if (m_h!=0) _findclose(m_h);}
	long operator =(long h) {if (m_h) _findclose(m_h); m_h=h; return h;}
	operator long() const {return m_h;}
	long* operator &() {if (m_h) _findclose(m_h); m_h = 0; return &m_h;}
};

class SmartFindClose
{

private:
	HANDLE m_h;

public:
	SmartFindClose():m_h(INVALID_HANDLE_VALUE){}
	SmartFindClose(HANDLE h):m_h(h){}
   ~SmartFindClose(){if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class SmartCloseServiceHandle
{

private:
	SC_HANDLE m_h;

public:
	SmartCloseServiceHandle():m_h(NULL){}
	SmartCloseServiceHandle(SC_HANDLE h):m_h(h){}
   ~SmartCloseServiceHandle(){if (m_h!=NULL) CloseServiceHandle(m_h);}
	SC_HANDLE operator =(SC_HANDLE h) {if (m_h!=NULL) CloseServiceHandle(m_h); m_h=h; return h;}
	operator SC_HANDLE() const {return m_h;}
	SC_HANDLE* operator &() {if (m_h!=NULL) CloseServiceHandle(m_h); m_h = NULL; return &m_h;}
};

class CSmartCreatedDC
{
public:
    CSmartCreatedDC(HDC hdc) { m_hdc = hdc;}
	operator HDC() const {return m_hdc;}
    ~CSmartCreatedDC() 
    { 
        if (m_hdc)
            DeleteDC(m_hdc); 
    }

protected:
    HDC m_hdc;
};

class CSmartBuffer
{
private:
	LPBYTE m_pBuffer;

public:
	CSmartBuffer() : m_pBuffer(NULL) {}
	CSmartBuffer(LPBYTE pBuffer) : m_pBuffer(pBuffer) {}
    CSmartBuffer(DWORD dwSize)
    {
        m_pBuffer = new BYTE[dwSize];
        if (m_pBuffer == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    ~CSmartBuffer()
    {
        Free();
    }

	LPBYTE operator =(LPBYTE pBuffer) 
    {
        Free();
            
        m_pBuffer = pBuffer; 
        
        return m_pBuffer;
    }
	
    operator LPBYTE() const { return m_pBuffer; }
	
    LPBYTE* operator &()
    {
        Free();

        m_pBuffer = NULL;
        
        return &m_pBuffer;
    }

protected:
    void Free()
    {
        if (m_pBuffer != NULL) 
        {
            delete [] m_pBuffer;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\assoc.cpp ===
//=================================================================
//
// assoc.cpp -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================
#include <stdafx.h>
#include "precomp.h"
#include <assertbreak.h>

#include "Assoc.h"

CAssociation::CAssociation(
    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
    ) : Provider(pwszClassName, pwszNamespaceName)
{
    ASSERT_BREAK( ( pwszClassName != NULL ) &&
                  ( pwszLeftClassName != NULL ) &&
                  ( pwszRightClassName != NULL) &&
                  ( pwszLeftPropertyName != NULL ) &&
                  ( pwszRightPropertyName != NULL) );

    m_pwszLeftClassName = pwszLeftClassName;
    m_pwszRightClassName = pwszRightClassName;

    m_pwszLeftPropertyName = pwszLeftPropertyName;
    m_pwszRightPropertyName = pwszRightPropertyName;

}

CAssociation::~CAssociation()
{
}

HRESULT CAssociation::ExecQuery(

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> lefts;

    CHStringArray sLeftPaths, sRightPaths;
    pQuery.GetValuesForProp ( m_pwszLeftPropertyName, sLeftPaths ) ;
    pQuery.GetValuesForProp ( m_pwszRightPropertyName, sRightPaths ) ;

    if (sLeftPaths.GetSize() == 0)
    {
        // GetLeftInstances populates lefts
        hr = GetLeftInstances(pMethodContext, lefts);
    }
    else
    {
        // For each sLeftPaths that is valid, create an entry in lefts
        hr = ValidateLeftObjectPaths(pMethodContext, sLeftPaths, lefts);
    }

    if (SUCCEEDED(hr) && lefts.GetSize() > 0)
    {
        if (sRightPaths.GetSize() == 0)
        {
            // GetRightInstances takes the 'lefts' and rubs all the
            // rights against them creating instances where appropriate
            hr = GetRightInstances(pMethodContext, &lefts);
        }
        else
        {
            TRefPointerCollection<CInstance> rights;

            // For each sRightPaths that is valid, create an instance
            hr = ValidateRightObjectPaths(pMethodContext, sRightPaths, lefts);
        }
    }

    return hr;
}

HRESULT CAssociation::GetObject(

    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString sLeftPath, sRightPath;

    // Get the two endpoints
    if (pInstance->GetCHString(m_pwszLeftPropertyName, sLeftPath ) &&
        pInstance->GetCHString(m_pwszRightPropertyName, sRightPath ) )
    {
        CInstancePtr pLeft, pRight;

        // Try to get the objects
        if (SUCCEEDED(hr = RetrieveLeftInstance(sLeftPath, &pLeft, pInstance->GetMethodContext())) &&
            SUCCEEDED(hr = RetrieveRightInstance(sRightPath, &pRight, pInstance->GetMethodContext())) )
        {

            hr = WBEM_E_NOT_FOUND;

            // So, the end points exist.  Are they derived from or equal to the classes we are working with?
            CHString sLeftClass, sRightClass;

            pLeft->GetCHString(L"__CLASS", sLeftClass);
            pRight->GetCHString(L"__CLASS", sRightClass);

            BOOL bDerived = _wcsicmp(m_pwszLeftClassName, sLeftClass) == 0;
            if (!bDerived)
            {
                bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszLeftClassName, sLeftClass, pInstance->GetMethodContext());
            }

            if (bDerived)
            {
                // Left side was correct, now let's check the right
                bDerived = _wcsicmp(m_pwszRightClassName, sRightClass) == 0;

                if (!bDerived)
                {
                    bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszRightClassName, sRightClass, pInstance->GetMethodContext());
                }
            }

            if (bDerived)
            {
                // Just because two instances are valid and derive from the right class, doesn't mean they are related.  Do
                // any other checks.
                if (AreRelated(pLeft, pRight))
                {
                    hr = LoadPropertyValues(pInstance, pLeft, pRight);
                }
            }
        }
    }

    return hr;
}

HRESULT CAssociation::EnumerateInstances(

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> lefts;

    // GetLeftInstances populates lefts
    if (SUCCEEDED(hr = GetLeftInstances(pMethodContext, lefts)))
    {
        // GetRightInstances takes the 'lefts' and rubs all the
        // rights against them
        hr = GetRightInstances(pMethodContext, &lefts);
    }

    return hr;
}

HRESULT CAssociation::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_pwszRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        NULL,
        pMethodContext,
        lefts);

    return hr;
}

HRESULT WINAPI CAssociation::StaticEnumerationCallback(

    Provider* pThat,
    CInstance* pInstance,
    MethodContext* pContext,
    void* pUserData
)
{
    HRESULT hr;

    CAssociation *pThis = (CAssociation *) pThat;
    ASSERT_BREAK(pThis != NULL);

    if (pThis)
    {
        hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

HRESULT CAssociation::EnumerationCallback(

    CInstance *pRight,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    HRESULT hr = WBEM_E_FAILED;

    CInstancePtr pLeft;
    REFPTRCOLLECTION_POSITION posLeft;
    CHString sLeftPath, sRightPath;

    // Cast for userdata back to what it is
    TRefPointerCollection<CInstance> *pLefts = (TRefPointerCollection<CInstance> *)pUserData;

    if (pLefts->BeginEnum(posLeft))
    {
        hr = WBEM_S_NO_ERROR;

        // Walk all the pLefts
        for (pLeft.Attach(pLefts->GetNext(posLeft)) ;
            (SUCCEEDED(hr)) && (pLeft != NULL) ;
            pLeft.Attach(pLefts->GetNext(posLeft)) )
        {
            // Compare it to the current pRight
            if(AreRelated(pLeft, pRight))
            {
                // We have a winner.  Populate the properties and send it in.
                if (GetLocalInstancePath(pLeft,  sLeftPath) &&
                    GetLocalInstancePath(pRight, sRightPath))
                {
                    CInstancePtr pNewAssoc(CreateNewInstance(pMethodContext), false);

                    if (pNewAssoc->SetCHString(m_pwszLeftPropertyName, sLeftPath) &&
                        pNewAssoc->SetCHString(m_pwszRightPropertyName, sRightPath) )
                    {
                        if (SUCCEEDED(hr = LoadPropertyValues(pNewAssoc, pLeft, pRight)))
                        {
                            hr = pNewAssoc->Commit();
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);
                    }
                }
            }
        }

        pLefts->EndEnum();
    }

    return hr;
}

HRESULT CAssociation::ValidateLeftObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0; x < sPaths.GetSize(); x++)
    {

        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( sPaths[x],  &pParsedPath );

        if ( 0 == nStatus )
        {
            BOOL bDerived;

            try
            {
                 bDerived = _wcsicmp(m_pwszLeftClassName, pParsedPath->m_pClass) == 0;
                 if (!bDerived)
                 {
                    bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszLeftClassName, pParsedPath->m_pClass, pMethodContext);
                 }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid
                if (SUCCEEDED(RetrieveLeftInstance(sPaths[x], &pInstance, pMethodContext)))
                {
                    // Yup, add it to the list
                    lefts.Add(pInstance);
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CAssociation::ValidateRightObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    HRESULT hr = WBEM_S_NO_ERROR;;
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0;
         (x < sPaths.GetSize()) && SUCCEEDED(hr);
         x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( sPaths[x],  &pParsedPath );

        if ( 0 == nStatus )
        {
            BOOL bDerived;
            try
            {
                 bDerived = _wcsicmp(m_pwszRightClassName, pParsedPath->m_pClass) == 0;
                 if (!bDerived)
                 {
                     bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszRightClassName, pParsedPath->m_pClass, pMethodContext);
                 }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid
                if (SUCCEEDED(RetrieveRightInstance(sPaths[x], &pInstance, pMethodContext)))
                {
                    hr = EnumerationCallback(pInstance, pMethodContext, &lefts);
                }
            }
        }
    }

    return hr;
}

HRESULT CAssociation::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_pwszLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext);
}

HRESULT CAssociation::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

HRESULT CAssociation::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}


/*
//========================
CAssocSystemToOS::CAssocSystemToOS(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
) : CAssociation (

    pwszClassName,
    pwszNamespaceName,

    pwszLeftClassName,
    pwszRightClassName,

    pwszLeftPropertyName,
    pwszRightPropertyName
    )
{
}

CAssocSystemToOS::~CAssocSystemToOS()
{
}

HRESULT CAssocSystemToOS::LoadPropertyValues(

    CInstance *pInstance,
    const CInstance *pLeft,
    const CInstance *pRight
)
{
    CAssociation::LoadPropertyValues(pInstance, pLeft, pRight);

    // This will work... until win32_os returns more than one instance.
    pInstance->Setbool(L"PrimaryOS", true);

    return WBEM_S_NO_ERROR;
}


CAssocSystemToOS MySystemToOperatingSystem(
    L"Win32_SystemOperatingSystem",
    L"root\\cimv2",
    L"Win32_ComputerSystem",
    L"Win32_OperatingSystem",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

  */
bool CAssociation::IsInstance(const CInstance *pInstance)
{
    DWORD dwGenus = 0;

    pInstance->GetDWORD(L"__Genus", dwGenus);

    return dwGenus == WBEM_GENUS_INSTANCE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\winsta\tsremdsk\tsremdsk.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    salemlib.cpp

Abstract:

    All Salem related function, this library is shared by termsrv.dll
    and salem sessmgr.exe

Author:

    HueiWang    4/26/2000

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#include <ntlsapi.h>
#include <stdio.h>
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>
#include <regapi.h>
#include "winsta.h"
#include "tsremdsk.h"
#include "base64.h"

#ifdef AllocMemory

#undef AllocMemory
#undef FreeMemory

#endif

#define AllocMemory(size) LocalAlloc(LPTR, size)
#define FreeMemory(ptr) LocalFree(ptr)

//
// Global Crypto provider
//
HCRYPTPROV gm_hCryptProv = NULL;    // Crypto provider

// 
// CryptEncrypt()/CryptDecrypt() not thread safe
//
HANDLE gm_hMutex = NULL;


extern DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
);

extern DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
);

void
EncryptUnlock();

DWORD
EncryptLock();


void
InitLsaString(
    IN OUT PLSA_UNICODE_STRING LsaString,
    IN LPWSTR String 
    )
/*++

Routine Description:

    Initialize LSA unicode string.

Parameters:

    LsaString : Pointer to LSA_UNICODE_STRING to be initialized.
    String : String to initialize LsaString.

Returns:

    None.

Note:

    Refer to LSA_UNICODE_STRING

--*/
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}


DWORD
OpenPolicy(
    IN LPWSTR ServerName,
    IN DWORD  DesiredAccess,
    OUT PLSA_HANDLE PolicyHandle 
    )
/*++

Routine Description:

    Create/return a LSA policy handle.

Parameters:
    
    ServerName : Name of server, refer to LsaOpenPolicy().
    DesiredAccess : Desired access level, refer to LsaOpenPolicy().
    PolicyHandle : Return PLSA_HANDLE.

Returns:

    ERROR_SUCCESS or  LSA error code

--*/
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaOpenPolicy(
                    Server,
                    &ObjectAttributes,
                    DesiredAccess,
                    PolicyHandle ) );
}

DWORD
StoreKeyWithLSA(
    IN PWCHAR  pwszKeyName,
    IN BYTE *  pbKey,
    IN DWORD   cbKey 
    )
/*++

Routine Description:

    Save private data to LSA.

Parameters:

    pwszKeyName : Name of the key this data going to be stored under.
    pbKey : Binary data to be saved.
    cbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;
    
    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_CREATE_SECRET, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}


DWORD
RetrieveKeyFromLSA(
    IN PWCHAR pwszKeyName,
    OUT PBYTE * ppbKey,
    OUT DWORD * pcbKey 
    )
/*++

Routine Description:

    Retrieve private data previously stored with StoreKeyWithLSA().

Parameters:

    pwszKeyName : Name of the key.
    ppbKey : Pointer to PBYTE to receive binary data.
    pcbKey : Size of binary data.

Returns:

    ERROR_SUCCESS
    ERROR_INVALID_PARAMETER.
    ERROR_FILE_NOT_FOUND
    LSA return code

--*/
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING *pSecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) || ( NULL == ppbKey ) || ( NULL == pcbKey ) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    InitLsaString( 
            &SecretKeyName, 
            pwszKeyName 
        );

    Status = OpenPolicy( 
                    NULL, 
                    POLICY_GET_PRIVATE_INFORMATION, 
                    &PolicyHandle 
                );

    if( Status != ERROR_SUCCESS )
    {
        SetLastError( LsaNtStatusToWinError(Status) );
        return GetLastError();
    }

    Status = LsaRetrievePrivateData(
                            PolicyHandle,
                            &SecretKeyName,
                            &pSecretData
                        );

    LsaClose( PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        SetLastError( LsaNtStatusToWinError(Status) );
        return GetLastError();
    }

    if(pSecretData != NULL && pSecretData->Length)
    {
        *ppbKey = (LPBYTE)AllocMemory( pSecretData->Length );

        if( *ppbKey )
        {
            *pcbKey = pSecretData->Length;
            CopyMemory( *ppbKey, pSecretData->Buffer, pSecretData->Length );
            Status = ERROR_SUCCESS;
        } 
        else 
        {
            Status = GetLastError();
        }
    }
    else
    {
        Status = ERROR_FILE_NOT_FOUND;
        SetLastError( Status );
        *pcbKey = 0;
        *ppbKey = NULL;
    }

    if (pSecretData != NULL) {
        SecureZeroMemory( pSecretData->Buffer, pSecretData->Length );
        LsaFreeMemory( pSecretData );
    }

    return Status;
}

DWORD
TSSetEncryptionKey(
    IN PBYTE pbData,
    IN DWORD  cbData
    )
/*++

Routine Description:

    Cache random password that use to deriving encryption cycle key.

Parameters:

    pbData :
    cbData :

Returns:

    ERROR_SUCCESS or error code

--*/
{
    DWORD status;

    if( !pbData || cbData == 0 )
    {
        status = ERROR_INVALID_PARAMETER;
        goto CLEANUPANDEXIT;
    }

    status = EncryptLock();
    if( ERROR_SUCCESS == status )
    {
        //
        // Load password to derive session encryption key from LSA   
        //
        status = StoreKeyWithLSA(
                            SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                            pbData,
                            cbData
                        );

        EncryptUnlock();
    }

CLEANUPANDEXIT:

    return status;
}

DWORD
TSGetEncryptionKey(
    OUT PBYTE* ppbData,
    OUT DWORD* pcbData
    )
/*++

Routine Description:

    Cache random password that use to deriving encryption cycle key.

Parameters:

    pbData :
    cbData :

Returns:

    ERROR_SUCCESS or error code

--*/
{
    DWORD status;

    if( !ppbData || !pcbData )
    {
        status = ERROR_INVALID_PARAMETER;
        goto CLEANUPANDEXIT;
    }

    status = EncryptLock();
    if( ERROR_SUCCESS == status )
    {
        //
        // Load password to derive session encryption key from LSA   
        //
        status = RetrieveKeyFromLSA(
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    ppbData,
                                    pcbData
                                );

        EncryptUnlock();
    }

CLEANUPANDEXIT:

    return status;
}

DWORD
TSGetHelpAssistantAccountPassword(
    OUT LPWSTR* ppszAccPwd
    )
/*++

--*/
{
    DWORD cbHelpAccPwd = 0;
    DWORD Status;

    Status = RetrieveKeyFromLSA(
                            SALEMHELPASSISTANTACCOUNT_PASSWORDKEY,
                            (PBYTE *)ppszAccPwd,
                            &cbHelpAccPwd
                        );

    if( ERROR_SUCCESS != Status )
    {
        // password is not set, assuming no help
        Status = ERROR_INVALID_ACCESS;
    }

    return Status;
}

	
DWORD
TSGetHelpAssistantAccountName(
    OUT LPWSTR* ppszAccDomain,
    OUT LPWSTR* ppszAcctName
    )
/*++

Routine Description:

    Get HelpAssistant account name.

Parameters:

    ppszAcctName : Pointer to LPWSTR to receive account name, use LocalFree()
                   to free the buffer.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    LPWSTR pszHelpAcctName = NULL;
    LPWSTR pszHelpAcctDomain = NULL;
    DWORD cbHelpAcctName = 0;
    DWORD cbHelpAcctDomain = 0;
    SID_NAME_USE sidUse;

    DWORD Status;
    BOOL bSuccess;
    PSID pLsaHelpAccSid = NULL;
    DWORD cbLsaHelpAccSid = 0;

    //
    // Retrieve HelpAccount SID we cached in LSA
    Status = RetrieveKeyFromLSA(
                            SALEMHELPASSISTANTACCOUNT_SIDKEY,
                            (PBYTE *)&pLsaHelpAccSid,
                            &cbLsaHelpAccSid
                        );

    if( ERROR_SUCCESS != Status )
    {
        // Salem is not installed or not active on this machine
        goto CLEANUPANDEXIT;
    }

    //
    // Lookup account name from SID
    //
    bSuccess = LookupAccountSid(
                            NULL,
                            pLsaHelpAccSid,
                            NULL,
                            &cbHelpAcctName,
                            NULL,
                            &cbHelpAcctDomain,
                            &sidUse
                        );

    if( bSuccess == FALSE && ERROR_NONE_MAPPED == GetLastError() )
    {
        // Can't retrieve either because network error or account
        // does not exist, error out.
        Status = ERROR_FILE_NOT_FOUND;
        goto CLEANUPANDEXIT;
    }

    pszHelpAcctName = (LPTSTR)AllocMemory( (cbHelpAcctName+1)*sizeof(WCHAR) );
    pszHelpAcctDomain = (LPTSTR)AllocMemory( (cbHelpAcctDomain+1)*sizeof(WCHAR) );

    if( NULL == pszHelpAcctName || NULL == pszHelpAcctDomain )
    {
        Status = ERROR_OUTOFMEMORY;
        goto CLEANUPANDEXIT;
    }

    bSuccess = LookupAccountSid(
                            NULL,
                            pLsaHelpAccSid,
                            pszHelpAcctName,
                            &cbHelpAcctName,
                            pszHelpAcctDomain,
                            &cbHelpAcctDomain,
                            &sidUse
                        );

    if( FALSE == bSuccess )
    {
        Status = GetLastError();
        goto CLEANUPANDEXIT;
    }

    *ppszAcctName = pszHelpAcctName;
    *ppszAccDomain = pszHelpAcctDomain;

    // don't free account name.
    pszHelpAcctName = NULL;
    pszHelpAcctDomain = NULL;

CLEANUPANDEXIT:

    if( NULL != pLsaHelpAccSid )
    {
        SecureZeroMemory( pLsaHelpAccSid, cbLsaHelpAccSid );
        FreeMemory( pLsaHelpAccSid );
    }

    if( NULL != pszHelpAcctDomain )
    {
        FreeMemory( pszHelpAcctDomain );
    }

    if( NULL != pszHelpAcctName )
    {
        FreeMemory(pszHelpAcctName);
    }

    return Status;
}

BOOL
TSIsMachineInHelpMode()
/*++

Routine Description:

    Return if machine is in GetHelp mode
    
Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    //
    // machine can only be in help mode if we have some
    // password to derive session encryption key, if
    // no pending help session exist, sessmgr will end
    // encryption cycle.
    return TSHelpAssistantInEncryptionCycle();
}

////////////////////////////////////////////////////////////////////////////

DWORD
EncryptLock()
/*++

Routine Description:

    Acquire encryption/decryption routine lock.

Parameters:

    None.

Returns:

    None.

--*/
{
    DWORD dwStatus;

    ASSERT( NULL != gm_hMutex );

    if( gm_hMutex )
    {
        dwStatus = WaitForSingleObject( gm_hMutex, INFINITE );

        ASSERT( WAIT_FAILED != dwStatus );
    }
    else
    {
        dwStatus = ERROR_INTERNAL_ERROR;
    }

    return dwStatus;
}

void
EncryptUnlock()
/*++

Routine Description:

    Release encryption/decryption routine lock.

Parameters:

    None.

Returns:

    None.

--*/
{
    BOOL bSuccess;

    bSuccess = ReleaseMutex( gm_hMutex );
    ASSERT( TRUE == bSuccess );
}


LPTSTR 
GenerateEncryptionPassword()
/*++

Routine Description:

    Generate a random password to derive encryption key.

Parameters:

    N/A

Returns:

    NULL or random password, GetLastError() to 
    retrieve detail error.

Note:

    Use UUID as password to derive encryption key.

--*/
{
    RPC_STATUS rpcStatus;
    UUID uuid;
    LPTSTR pszUuidString = NULL;

    rpcStatus = UuidCreate( &uuid );

    if( rpcStatus == RPC_S_OK || rpcStatus == RPC_S_UUID_LOCAL_ONLY ||
        rpcStatus == RPC_S_UUID_NO_ADDRESS )
    {
        rpcStatus = UuidToString( &uuid, &pszUuidString );
    }

    return pszUuidString;
}

BOOL
TSHelpAssistantInEncryptionCycle()
{
    LPTSTR pszEncryptKey = NULL;
    DWORD cbEncryptKey = 0;
    DWORD dwStatus;

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Sessmgr will reset encryption password to NULL 
        // if there is no help pending
        //
        dwStatus = RetrieveKeyFromLSA(
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    (PBYTE *)&pszEncryptKey,
                                    &cbEncryptKey
                                );

        if( NULL != pszEncryptKey )
        {
            SecureZeroMemory( pszEncryptKey , cbEncryptKey );

            FreeMemory( pszEncryptKey );
        }

        EncryptUnlock();
    }

    return ERROR_SUCCESS == dwStatus;
}


DWORD
TSHelpAssistantBeginEncryptionCycle()
{
    DWORD dwStatus;
    LPTSTR pszKey = NULL;
    DWORD cbKey;

    ASSERT( NULL != gm_hMutex );

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Generate a random password for deriving encryption key
        //
        pszKey = GenerateEncryptionPassword();
        if( NULL != pszKey )
        {
            //
            // Store key deriving password into LSA
            //
            dwStatus = StoreKeyWithLSA( 
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    (PBYTE)pszKey,
                                    (lstrlenW(pszKey)+1) * sizeof(WCHAR) 
                                );
        }
        else
        {
            dwStatus = GetLastError();
        }

        EncryptUnlock();
    }

    if( ERROR_SUCCESS == dwStatus )
    {
        HKEY Handle = NULL;
        DWORD dwInHelpMode = 1;

        dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                           KEY_READ | KEY_SET_VALUE, &Handle );
        if ( dwStatus == ERROR_SUCCESS )
        {
            dwStatus = RegSetValueEx(Handle,REG_MACHINE_IN_HELP_MODE,
                                  0,REG_DWORD,(const BYTE *)&dwInHelpMode,
                                  sizeof(dwInHelpMode));

         }
         if(Handle)
         {
             RegCloseKey(Handle);
         }

         ASSERT( ERROR_SUCCESS == dwStatus );

    }

    if( NULL != pszKey )
    {
        // string is generated by UuidToString()
        SecureZeroMemory( pszKey , lstrlenW( pszKey ) * sizeof(WCHAR) );
        RpcStringFree( &pszKey );
    }

    return dwStatus;
}


DWORD
TSHelpAssisantEndEncryptionCycle()
/*++

Routine Description:

    End an encryption cycle, a cycle is defined between first help
    created in help session manager to last pending help been resolved.

Parameters:

    N/A

Returns:

    ERROR_SUCCESS or LSA error code

--*/
{
    DWORD dwStatus;

    ASSERT( NULL != gm_hMutex );

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        dwStatus = StoreKeyWithLSA(
                                    SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                    (PBYTE)NULL,
                                    0
                                );

        EncryptUnlock();
    }

    if( ERROR_SUCCESS == dwStatus ) // should we not always do it?
    {
        HKEY Handle = NULL;
        DWORD dwInHelpMode = 0;

        dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REG_CONTROL_TSERVER, 0,
                           KEY_READ | KEY_SET_VALUE, &Handle );
        if ( dwStatus == ERROR_SUCCESS )
        {
            dwStatus = RegSetValueEx(Handle,REG_MACHINE_IN_HELP_MODE,
                                  0,REG_DWORD,(const BYTE *)&dwInHelpMode,
                                  sizeof(dwInHelpMode));

         }
         if(Handle)
         {
             RegCloseKey(Handle);
         }

         ASSERT( ERROR_SUCCESS == dwStatus );

    }

    return dwStatus;
}    


HCRYPTKEY
CreateEncryptDecryptKey(
    IN LPCTSTR pszEncryptPrefix,
    IN LPCTSTR pszPassword
    )
/*++

Routine Description:

    CreateEncryptDecryptKey() derive a session encryption/decryption
    key from password string.

Parameters:

    pszEncryptPrefix : Optional string to be concatenated with password string to derives
                an encryption key.
    pszPassword : Pointer to password string to derives a session encryption
                  decryption key.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Caller must invoke EncryptLock();

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    HCRYPTHASH hCryptHash = NULL;
    HCRYPTKEY hCryptKey = NULL;
    BOOL bStatus;
    LPTSTR pszEncryptKey = NULL;


    ASSERT( NULL != pszPassword );
    ASSERT( NULL != gm_hCryptProv );

    if( NULL != pszPassword && NULL != gm_hCryptProv )
    {
        if( pszEncryptPrefix )
        {
            pszEncryptKey = (LPTSTR)AllocMemory( (lstrlen(pszEncryptPrefix) + lstrlen(pszPassword) + 1) * sizeof(TCHAR) );
            if( NULL == pszEncryptKey )
            {
                // Out of memory, can't continue.
                goto CLEANUPANDEXIT;
            }

            lstrcpy( pszEncryptKey, pszEncryptPrefix );
            lstrcat( pszEncryptKey, pszPassword );
        }
                

        //
        // Derives a session key for encryption/decryption.
        //
        bStatus = CryptCreateHash(
                                gm_hCryptProv,
                                CALG_MD5,
                                0,
                                0,
                                &hCryptHash
                            );

        if( FALSE == bStatus )
        {
            dwStatus = GetLastError();
            ASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        if( pszEncryptKey )
        { 
            bStatus = CryptHashData(
                                hCryptHash,
                                (BYTE *)pszEncryptKey,
                                lstrlen(pszEncryptKey) * sizeof(TCHAR),
                                0
                            );
        }
        else
        {
            bStatus = CryptHashData(
                                hCryptHash,
                                (BYTE *)pszPassword,
                                lstrlen(pszPassword) * sizeof(TCHAR),
                                0
                            );
        }

        if( FALSE == bStatus )
        {
            dwStatus = GetLastError();
            ASSERT(FALSE);
            goto CLEANUPANDEXIT;
        }

        //
        // derive a session key for encrypt/decrypt
        //
        bStatus = CryptDeriveKey(
                                gm_hCryptProv,
                                ENCRYPT_ALGORITHM,  
                                hCryptHash,
                                0,
                                &hCryptKey
                            );

        if( FALSE == bStatus )
        {
            dwStatus = GetLastError();
            ASSERT(FALSE);
        }
    }
    else
    {
        SetLastError( dwStatus = ERROR_INVALID_PARAMETER );
    }

       
CLEANUPANDEXIT:

    if( NULL != hCryptHash )
    {
        (void)CryptDestroyHash( hCryptHash );
    }

    if( NULL != pszEncryptKey )
    {
        SecureZeroMemory( pszEncryptKey , lstrlen( pszEncryptKey ) * sizeof( TCHAR ) );
        FreeMemory( pszEncryptKey );
    }
                
    return hCryptKey;
}


DWORD 
EnsureCryptoProviderCreated()
{
    BOOL bStatus;
    DWORD dwStatus = ERROR_SUCCESS;

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Acquire a global Crypto provider 
        //
        if( NULL == gm_hCryptProv )
        {
            bStatus = CryptAcquireContext(
                                &gm_hCryptProv,
                                HELPASSISTANT_CRYPT_CONTAINER,
                                MS_DEF_PROV,                
                                PROV_RSA_FULL,
                                0
                            );

            if( FALSE == bStatus )
            {
                // Create a container if not exists.
                bStatus = CryptAcquireContext(
                                    &gm_hCryptProv,
                                    HELPASSISTANT_CRYPT_CONTAINER,
                                    MS_DEF_PROV,                
                                    PROV_RSA_FULL,
                                    CRYPT_NEWKEYSET
                                );

                if( FALSE == bStatus )
                {
                    dwStatus = GetLastError();
                    ASSERT(FALSE);
                }
            }
        }

        EncryptUnlock();
    }

    return dwStatus;
}

HCRYPTKEY
GetEncryptionCycleKey(
    IN LPCTSTR pszEncryptPrefix
    )
/*++

Routine Description:

    Create a encryption/decryption key for current encryption 
    cycle, function first load password to derive session encryption 
    key from LSA and invoke CryptAPI to create the session encryption 
    key.  If password is not in LSA, function return error.

Parameters:

    None.

Returns:

    Handle to session encryption key, NULL if error, use GetLastError to
    to retrieve detail error code.

Note:

    Caller must invoke EncryptLock();


--*/
{
    LPTSTR pszEncryptKey;
    DWORD cbEncryptKey;
    DWORD dwStatus;
    HCRYPTKEY hCryptKey = NULL;

    //
    // Load password to derive session encryption key from LSA   
    //
    dwStatus = RetrieveKeyFromLSA(
                                SALEMHELPASSISTANTACCOUNT_ENCRYPTIONKEY,
                                (PBYTE *)&pszEncryptKey,
                                &cbEncryptKey
                            );

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Make sure global crypto provider exists.
        //
        dwStatus = EnsureCryptoProviderCreated();

        if( ERROR_SUCCESS == dwStatus )
        {
            //
            // Create the session encryption key.
            //
            hCryptKey = CreateEncryptDecryptKey( pszEncryptPrefix, pszEncryptKey );
        }

        SecureZeroMemory( pszEncryptKey , lstrlen( pszEncryptKey ) * sizeof( TCHAR ) );

        FreeMemory( pszEncryptKey ); 
    }

    return hCryptKey;
}


VOID
TSHelpAssistantEndEncryptionLib()
{
    //
    // ignore error code, this is only for shutdown
    //
    if( NULL != gm_hCryptProv )
    {
        CryptReleaseContext( gm_hCryptProv, 0 );
        gm_hCryptProv = NULL;    
    }

    if( NULL != gm_hMutex )
    {
        ReleaseMutex( gm_hMutex );
    }
    return;
}


DWORD
TSHelpAssistantInitializeEncryptionLib()
/*++

Routine Description:

    Initialize encryption/decryption library

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bStatus;
    LPTSTR pszEncryptKey;
    DWORD cbEncryptKey;


    ASSERT( NULL == gm_hCryptProv );
    ASSERT( NULL == gm_hMutex );

    //
    // Create a global mutex
    //
    gm_hMutex = CreateMutex(
                        NULL,
                        FALSE,
                        SALEMHELPASSISTANTACCOUNT_ENCRYPTMUTEX
                    );

    
    if( NULL == gm_hMutex )
    {
        dwStatus = GetLastError();
        ASSERT( NULL != gm_hMutex );
    }

    return dwStatus;
}


DWORD
TSHelpAssistantEncryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
    )
/*++

Routine Description:

    Encrypt binary data, called must have invoked
    TSHelpAssistantInitializeEncryptionLib() and 
    TSHelpAssistantBeginEncryptionCycle().

Parameters:

    pbData : Pointer to binary data to be encrypted.
    pcbData : Size of binary data to be encrypted.

Returns:

    ERROR_SUCCESS or error code.

Note:

    Caller need to free ppbEncryptedData via LocalFree().

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bStatus;
    HCRYPTKEY hCryptKey = NULL;
    EXCEPTION_RECORD ExceptionCode;
    DWORD cbBufSize = *pcbData;


    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Retrieve current cycle encryption key
        //
        hCryptKey = GetEncryptionCycleKey(pszEncryptPrefixKey);

        if( NULL == hCryptKey )
        {
            dwStatus = GetLastError();

            EncryptUnlock();
            goto CLEANUPANDEXIT;
        }

        //
        // Encrypt the data, not thread safe.
        //
        __try{

            // Stream cipher - same buffer size
            bStatus = CryptEncrypt(
                                hCryptKey,
                                NULL,
                                TRUE,
                                0,
                                pbData,      // buffer to be encrypted
                                pcbData,     // buffer size
                                cbBufSize    // number of byte to be encrypt
                            );

            if( FALSE == bStatus )
            {
                dwStatus = GetLastError();
            }
        }
        __except(
            ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
            EXCEPTION_EXECUTE_HANDLER )
        {
            bStatus = FALSE;
            dwStatus = ExceptionCode.ExceptionCode;
        }

        EncryptUnlock();

        //
        // Using stream cipher, has to be same size.
        //
        ASSERT( cbBufSize == *pcbData );
    }

CLEANUPANDEXIT:

    if( NULL != hCryptKey )
    {
        CryptDestroyKey( hCryptKey );
    }

    return dwStatus;
}


DWORD
TSHelpAssistantDecryptData(
    IN LPCWSTR pszEncryptPrefixKey,
    IN OUT PBYTE pbData,
    IN OUT DWORD* pcbData
    )
/*++

Routine Description:

    Decrypt data previously encrypted using TSHelpAssistantEncryptBase64EncodeData().

Parameters:

    pbData : Stream of binary data to be decoded/decrypted.
    pcbData : Size of data in bytes to be decrypted/decoded.

Returns:

    ERROR_SUCCESS or error code

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    BOOL bStatus;
    HCRYPTKEY hCryptKey = NULL;
    EXCEPTION_RECORD ExceptionCode;
    DWORD dwBufSize = *pcbData;

    dwStatus = EncryptLock();

    if( ERROR_SUCCESS == dwStatus )
    {
        //
        // Retrieve session encryption key for this encryption cycle.
        //
        hCryptKey = GetEncryptionCycleKey(pszEncryptPrefixKey);

        if( NULL == hCryptKey )
        {
            dwStatus = GetLastError();
            EncryptUnlock();
            goto CLEANUPANDEXIT;
        }


        __try {
            // Stream cipher - same buffer size
            bStatus = CryptDecrypt(
                                hCryptKey,
                                NULL,
                                TRUE,
                                0,
                                pbData,
                                pcbData
                            );

            if( FALSE == bStatus )
            {
                dwStatus = GetLastError();
            }
        }
        __except(
            ExceptionCode = *(GetExceptionInformation())->ExceptionRecord,
            EXCEPTION_EXECUTE_HANDLER )
        {
            bStatus = FALSE;
            dwStatus = ExceptionCode.ExceptionCode;
        }

        EncryptUnlock();

        //
        // Stream cipher, same buffer size
        ASSERT( dwBufSize == *pcbData );
    }

CLEANUPANDEXIT:

    if( NULL != hCryptKey )
    {
        CryptDestroyKey( hCryptKey );
    }
        
    return dwStatus;
}

BOOL
TSIsMachinePolicyAllowHelp()
/*++

Routine Description:

    Check if 'GetHelp' is enabled on local machine, routine first query 
    system policy registry key, if policy is not set, then read salem
    specific registry.  Default to 'enable' is registry value does not
    exist.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    return RegIsMachinePolicyAllowHelp();
}

BOOL
TSIsMachineInSystemRestore()
/*+=

Routine Description:

    Check if our special reg. value exist that indicate system restore 
    has rebooted machine.

Parameters:

    None.

Returns:

    TRUE/FALSE

--*/
{
    DWORD dwStatus;
    HKEY hKey = NULL;
    DWORD cbData;
    DWORD value;
    DWORD type;
    BOOL bInSystemRestore = FALSE;

    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_REMDSK L"\\" REG_CONTROL_HELPSESSIONENTRY,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                    );

    if( ERROR_SUCCESS != dwStatus ) 
    {
        goto CLEANUPANDEXIT;
    }

    cbData = sizeof(value);
    value = 0;
    dwStatus = RegQueryValueEx( 
                        hKey,
                        REG_VALUE_SYSTEMRESTORE,
                        0,
                        &type,
                        (LPBYTE)&value,
                        &cbData
                    );

    if( ERROR_SUCCESS == dwStatus && type == REG_DWORD && value == 1 )
    {
        bInSystemRestore = TRUE;
    }

CLEANUPANDEXIT:

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    return bInSystemRestore;
}

DWORD
TSSystemRestoreCacheValues()
/*++

Routine Description:

    Cache necessary LSA data that we use in Salem for system restore.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

Note:

    We can't cache HelpAssistant account SID as 
    1) System restore will restore all user account.
    2) System restore also restore our LSA SID key.

    since our account is created at setup time, account has to 
    match SID we cached.
--*/
{
    DWORD dwStatus;
    DWORD dwSize;
    DWORD dwValue;
    PBYTE pbData = NULL;
    HKEY hCacheKey = NULL;
    HKEY hRegControlKey = NULL;
    DWORD dwType;
    DWORD dwEncryptionDataSize = 0;


    //
    // Check if we just start up after rebooted from system restore.
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_REMDSK L"\\" REG_CONTROL_HELPSESSIONENTRY,
                        0,
                        KEY_ALL_ACCESS,
                        &hCacheKey
                    );

    if( ERROR_SUCCESS != dwStatus ) 
    {
        // This registry key is created at setup time so must exist.
        ASSERT(FALSE);
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Mark that we are in system restore.
    //
    dwSize = sizeof(dwValue);
    dwValue = 1;
    dwStatus = RegSetValueEx( 
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        dwSize
                    );

    //
    // Cache encryption cycle key.
    //    
    dwStatus = TSGetEncryptionKey( &pbData, &dwEncryptionDataSize );
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = RegSetValueEx(
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY,
                        0,
                        REG_BINARY,
                        pbData,
                        dwEncryptionDataSize
                    );

    //
    // Cache fAllowToGetHelp
    //
    dwStatus = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_TSERVER,
                        0,
                        KEY_READ,
                        &hRegControlKey
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hRegControlKey,
                            POLICY_TS_REMDSK_ALLOWTOGETHELP,
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume no help is allow.
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );
                

    //
    // Cache fInHelpMode
    //   
    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hRegControlKey,
                            REG_MACHINE_IN_HELP_MODE,
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume No help
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hCacheKey,
                        REG_VALUE_SYSTEMRESTORE_INHELPMODE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );

CLEANUPANDEXIT:

    if( NULL != hCacheKey )
    {
        RegCloseKey( hCacheKey );
    }

    if( NULL != hRegControlKey )
    {
        RegCloseKey( hRegControlKey );
    }

    if( NULL != pbData )
    {
        SecureZeroMemory( pbData , dwEncryptionDataSize );
        LocalFree( pbData );
    }

    return dwStatus;
}
    

DWORD
TSSystemRestoreResetValues()
/*++

Routine Description:

    Reset necessary LSA data that we use in Salem for system restore.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    PBYTE pbData = NULL;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwValue;
    HKEY hRegControlKey = NULL;
    HKEY hCacheKey = NULL;
    DWORD dwEncryptionDataSize = 0;

    //
    // Check if we just start up after rebooted from system restore.
    //
    dwStatus = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_REMDSK L"\\" REG_CONTROL_HELPSESSIONENTRY,
                        0,
                        KEY_ALL_ACCESS,
                        &hCacheKey
                    );

    if( ERROR_SUCCESS != dwStatus ) 
    {
        // This registry key is created at setup time so must exist.
        ASSERT(FALSE);
        dwStatus = ERROR_INTERNAL_ERROR;
        goto CLEANUPANDEXIT;
    }

    //
    // Restore necessary LSA values.
    //
    
    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY,
                            0,
                            &dwType,
                            NULL,
                            &dwEncryptionDataSize
                        );

    if( ERROR_SUCCESS != dwStatus || dwType != REG_BINARY )
    {
        goto CLEANUPANDEXIT;
    }

    pbData = (PBYTE) LocalAlloc( LPTR, dwEncryptionDataSize );
    if( NULL == pbData )
    {
        dwStatus = GetLastError();
        goto CLEANUPANDEXIT;
    }

    // Restore encryption key
    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY,
                            0,
                            &dwType,
                            pbData,
                            &dwEncryptionDataSize
                        );
    
    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwStatus = TSSetEncryptionKey(pbData, dwEncryptionDataSize );

    //
    // Reset fAllowToGetHelp
    //
    dwStatus = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_TSERVER,
                        0,
                        KEY_READ | KEY_SET_VALUE,
                        &hRegControlKey
                    );

    if( ERROR_SUCCESS != dwStatus )
    {
        goto CLEANUPANDEXIT;
    }

    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP,
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume no help is allow.
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hRegControlKey,
                        POLICY_TS_REMDSK_ALLOWTOGETHELP,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );
                

    //
    // Reset fInHelpMode
    //   
    dwSize = sizeof(dwValue);
    dwValue = 0;
    dwType = 0;

    dwStatus = RegQueryValueEx(
                            hCacheKey,
                            REG_VALUE_SYSTEMRESTORE_INHELPMODE, 
                            0,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwSize
                        );
    
    // Key does not exist, assume not in help
    if( ERROR_SUCCESS != dwStatus || dwType != REG_DWORD )
    {
        dwValue = 0;
    }

    dwStatus = RegSetValueEx(
                        hRegControlKey,
                        REG_MACHINE_IN_HELP_MODE,
                        0,
                        REG_DWORD,
                        (PBYTE)&dwValue,
                        dwSize
                    );

CLEANUPANDEXIT:

    if( NULL != pbData )
    {
        SecureZeroMemory( pbData , dwEncryptionDataSize );
        LocalFree(pbData);
    }

    if( NULL != hCacheKey )
    {
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE_ENCRYPTIONKEY );
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE );
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE_ALLOWTOGETHELP );
        RegDeleteValue( hCacheKey, REG_VALUE_SYSTEMRESTORE_INHELPMODE );
        RegCloseKey( hCacheKey );
    }

    if( NULL != hRegControlKey )
    {
        RegCloseKey( hRegControlKey );
    }

    return dwStatus;
}
    

BOOL
TSIsFireWallPortsOpen()
/*++

Routine Description:

    Checks DirectPlayNatHelp regkeys to see any entries exist. This could
    mean that entries are active or stale. The caller must update the
    DPHUPNP server status to remove stale entries.

Parameters:

    None.

Returns:

    ERROR_SUCCESS or error code.

--*/
{
    DWORD dwStatus;
    BOOL fPortEntryFound = FALSE;
    TCHAR szValueNameBuffer[ MAX_PATH ];
    DWORD cbValueNameCharCount = MAX_PATH;
    HKEY hKey = NULL;

    // check to see if values exist under regkey ActiveFirewallMappings

    dwStatus = RegOpenKeyEx( 
        HKEY_LOCAL_MACHINE ,
        L"Software\\Microsoft\\DirectPlayNATHelp\\DPNHUPnP\\ActiveFirewallMappings",
        0,
        KEY_READ,
        &hKey );

    if( dwStatus == ERROR_SUCCESS )
    {
        // see if there is at least one entry under this key
        dwStatus = RegEnumValue( 
            hKey , 
            0 ,                     // first item
            &szValueNameBuffer[0] ,
            &cbValueNameCharCount ,
            NULL ,                  // reserved
            NULL ,                  // type is not required
            NULL ,                  // data is not required - pass in NULL
            NULL                    // size of data not required
            );
        
        // an error such as ERROR_NO_MORE_ITEMS would mean that there are no 
        // items under this key and fPortEntryFound should be set to FALSE

        if( dwStatus == ERROR_SUCCESS )
        {
            fPortEntryFound = TRUE;
        }

        RegCloseKey( hKey );
    }

    // no need to check secondary registry key if we have entries in the 
    // first key

    if( !fPortEntryFound )
    {
        // check to see if values exist under this key ActiveNATMappings
        dwStatus = RegOpenKeyEx( 
            HKEY_LOCAL_MACHINE ,
            L"Software\\Microsoft\\DirectPlayNATHelp\\DPNHUPnP\\ActiveNATMappings",
            0,
            KEY_READ,
            &hKey );

        if( dwStatus == ERROR_SUCCESS )
        {
            // see if there is at least one entry under this key
            dwStatus = RegEnumValue( 
                hKey , 
                0 ,                     // first item
                &szValueNameBuffer[0] ,
                &cbValueNameCharCount ,
                NULL ,                  // reserved
                NULL ,                  // type is not required
                NULL ,                  // data is not required - pass in NULL
                NULL                    // size of data not required
                );
        
            if( dwStatus == ERROR_SUCCESS )
            {
                fPortEntryFound = TRUE;
            }

            RegCloseKey( hKey );
        }

    }

    return fPortEntryFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\precomp.h ===
#pragma message("Precompiling header...")
//#include <nt.h>
//#include <ntrtl.h>
//#include <nturtl.h>

#include <fwcommon.h>
//#include "brodcast.h"
//#include "dllutils.h"
#include "smartptr.h"
//#include <strings.h>
//#include "ConfgMgr.h"
//#define MAXDWORD MAXULONG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\resource.h ===
/****************************************************************************/
// Resource.h
//
// Resource file for TsCfgComp.dll
//
// Copyright (C) 2000 Microsoft Corp.
/****************************************************************************/

#define IDS_ERR_ENUMTSSETTINGS 40000
#define IDS_ERR_ENUMTERMINAL 40001
#define IDS_ERR_ENUMTSGCONFIG 40002
#define IDS_ERR_ENUMTSLCONFIG 40003
#define IDS_ERR_ENUMTSSCONFIG 40004
#define IDS_ERR_ENUMTSECONFIG 40005
#define IDS_ERR_ENUMTSRCONFIG 40006
#define IDS_ERR_ENUMTSCCONFIG 40007
#define IDS_ERR_ENUMTSNCONFIG 40008
#define IDS_ERR_ENUMTSPCONFIG 40009
#define IDS_ERR_PUTTERMINAL 40010
#define IDS_ERR_PUTTSGCONFIG 40011
#define IDS_ERR_PUTTSLCONFIG 40012
#define IDS_ERR_PUTTSSCONFIG 40013
#define IDS_ERR_PUTTSECONFIG 40014
#define IDS_ERR_PUTTSRCONFIG 40015
#define IDS_ERR_PUTTSCCONFIG 40016
#define IDS_ERR_PUTTSNCONFIG 40017
#define IDS_ERR_PUTTSPCONFIG 40018
#define IDS_ERR_PUTINSTANCE 40019
#define IDS_ERR_ENUMINSTANCE 40020
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\registry.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.h
*
*  Abstract:
*
*      declaration of a simple registry class CRegistry.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#if !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)
#define AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000




#include <winreg.h>



#define ASSERT(x) NULL
#define VERIFY(x) NULL

class CRegistry
{
private:

    LPBYTE      m_pMemBlock;
    HKEY        m_hKey;
    int         m_iEnumIndex;
    int         m_iEnumValueIndex;

    DWORD       ReadReg             (LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype);
    void *      Allocate            (DWORD dwSize);



    //
    // This class is not designed to allow copy constructors, = assignments,
    // therefore we should ensure that copy ctor, assignment operator are not
    // generated by compiler. we do that by declaring these functions private
    // and not implementing them. This will ensure that these functions are
    // not generated by compilers, and caller will get error if he tries to
    // use them.
    //

                CRegistry           (const CRegistry &reg);     // copy ctor
  CRegistry &   operator=           (const CRegistry &reg);     // = oprerator



#ifdef DBG
    DWORD       m_dwSizeDebugOnly;
#endif

public:
                CRegistry           ();
    virtual     ~CRegistry          ();
    void        Release             ();

    operator    HKEY                ()    {return m_hKey;}


    DWORD       OpenKey             (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS);
    DWORD       CreateKey           (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL, LPSECURITY_ATTRIBUTES lpSecAttr  = NULL );

    DWORD       DeleteValue         (LPCTSTR lpValue);
    DWORD       RecurseDeleteKey    (LPCTSTR lpSubKey);

    DWORD       ReadRegString       (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegDWord        (LPCTSTR lpValue, DWORD *pdw);
    DWORD       ReadRegMultiString  (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegBinary       (LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw);

    DWORD       WriteRegString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegDWord       (LPCTSTR lpValueName, DWORD dwValue);
    DWORD       WriteRegMultiString (LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize);


    DWORD       GetFirstSubKey      (LPTSTR *lppStr, DWORD *pdw);
    DWORD       GetNextSubKey       (LPTSTR *lppStr, DWORD *pdw);
/*
    DWORD       GetFirstValue       (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
    DWORD       GetNextValue        (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
*/
    DWORD       GetSecurity         (PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize);
    DWORD       SetSecurity         (PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation);

};

#endif // !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\stdafx.h ===
/****************************************************************************/
// stdafx.h
//
// Copyright (C) 2000 Microsoft Corp.
/****************************************************************************/

#ifndef _STDAFX_H_
#define _STDAFX_H_

#include "cfgbkend.h"

extern HINSTANCE g_hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\registry.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.cpp
*
*  Abstract:
*
*      Registry.cpp: implementation of the CRegistry class.
*      This class helps with registry by allocating memory by itself
*      As a result caller must copy the pointer returned by Get functions
*      immediately.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/
#include "stdafx.h"
#include <fwcommon.h>  // This must be the first include.

#include "Registry.h"


/*--------------------------------------------------------------------------------------------------------
* Constructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::CRegistry()
{
    m_pMemBlock = NULL;
    m_hKey = NULL;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;

#ifdef DBG
    m_dwSizeDebugOnly = 0;
#endif
}

/*--------------------------------------------------------------------------------------------------------
* Destructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::~CRegistry()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    Release();
}

/*--------------------------------------------------------------------------------------------------------
* void Allocate (DWORD dwSize)
* This private function is used for allocating the memory for
* reading registry
* returns the pointer to memory allocated.
* -------------------------------------------------------------------------------------------------------*/
void *CRegistry::Allocate (DWORD dwSize)
{
    ASSERT(dwSize != 0);
    if (m_pMemBlock)
        Release();
    
    m_pMemBlock = new BYTE[dwSize];

#ifdef DBG
    // remember the size of the block to be allocated.
    m_dwSizeDebugOnly = dwSize;
#endif

    return m_pMemBlock;
}

/*--------------------------------------------------------------------------------------------------------
* void Release ()
* This private function is used for releasing internal memory block
* -------------------------------------------------------------------------------------------------------*/
void CRegistry::Release ()
{
    if (m_pMemBlock)
    {

#ifdef DBG
        // fistly fill up the block we allocated previously with garbage.
        // so that if anybody is using this block, it is more lilely to 
        // catch the bug.
        ASSERT(m_dwSizeDebugOnly != 0);
        FillMemory(m_pMemBlock, m_dwSizeDebugOnly, 'c');
        m_dwSizeDebugOnly = 0;

#endif

        delete [] m_pMemBlock;
    }
    
    m_pMemBlock = 0;
}


///*--------------------------------------------------------------------------------------------------------
//* DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
//* opens/creates the key specified. before attempting any operation on any key/value. this function
//* must be called.
//* hKey - hive
//* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
//* access - access desired. like REG_READ, REG_WRITE..
//* RETURNS error code.
//* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    // security descriptor should be null or it should be a valid one.
    ASSERT(!lpSecAttr || IsValidSecurityDescriptor(lpSecAttr->lpSecurityDescriptor));

    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
                    hKey,               // handle of an open key
                    lpSubKey,           // address of subkey name
                    0,                  // reserved
                    NULL,               // address of class string
                    REG_OPTION_NON_VOLATILE ,  // special options flag
                    access,             // desired security access
                    lpSecAttr,          // address of key security structure
                    &m_hKey,            // address of buffer for opened handle
                    &dwDisposition      // address of disposition value buffer
                    );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    if (pDisposition)
        *pDisposition = dwDisposition;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access) ()
* opens the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/ )
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    LONG lResult = RegOpenKeyEx(
        hKey,                       // handle of open key
        lpSubKey,                   // address of name of subkey to open
        0 ,                         // reserved
        access,                     // security access mask
        &m_hKey                     // address of handle of open key
        );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    return lResult;
}

DWORD CRegistry::DeleteValue (LPCTSTR lpValue)
{
    ASSERT(lpValue);
    ASSERT(m_hKey);
    return RegDeleteValue(m_hKey, lpValue);

}
DWORD CRegistry::RecurseDeleteKey (LPCTSTR lpSubKey)
{
    ASSERT(lpSubKey);
    ASSERT(m_hKey);

    CRegistry reg;
    DWORD dwError = reg.OpenKey(m_hKey, lpSubKey);
    if (dwError != ERROR_SUCCESS)
        return dwError;


    LPTSTR lpChildKey;
    DWORD  dwSize;

    // we needn't/shouldn't use GetNextSubKey in this here
    // as we are deleting the key during the loop.
    while (ERROR_SUCCESS == reg.GetFirstSubKey(&lpChildKey, &dwSize))
    {
        VERIFY(reg.RecurseDeleteKey(lpChildKey) == ERROR_SUCCESS);
    }

    return RegDeleteKey(m_hKey, lpSubKey);

}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
* Reads the registry used internally.
* LPCTSTR lpValue - value to be read.
* LPBYTE *lppbyte - address of the lpbyte at which to place the output buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* dword datatype - datatype you are expecting.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
{
    ASSERT(lpValue);
    ASSERT(lppbyte);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    *pdw = 0;

    DWORD dwType;
    DWORD lResult = RegQueryValueEx(
        m_hKey,             // handle of key to query
        lpValue,            // address of name of value to query
        0,                  // reserved
        &dwType,            // address of buffer for value type 
        0,                  // address of data buffer 
        pdw                 // address of data buffer size 
        ); 
    
    if (lResult == ERROR_SUCCESS)
    {
        ASSERT(dwType == dwDatatype || dwType == REG_EXPAND_SZ);
    
        if (0 == Allocate(*pdw))
            return ERROR_OUTOFMEMORY;

        lResult = RegQueryValueEx( 
            m_hKey,                 // handle of key to query 
            lpValue,                // address of name of value to query
            0,                      // reserved 
            &dwType,                // address of buffer for value type 
            m_pMemBlock,            // address of data buffer 
            pdw                     // address of data buffer size 
            ); 
    
        ASSERT (ERROR_MORE_DATA != lResult);
    
        if (lResult == ERROR_SUCCESS)
            *lppbyte = m_pMemBlock;
    }
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* DWORD  *pdw  - address of dword in which the read dword returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
{
    ASSERT(pdw);

    DWORD dwSize;
    LPBYTE pByte;
    DWORD dwReturn = ReadReg(lpValue, &pByte, &dwSize, REG_DWORD);
    //ASSERT(dwReturn != ERROR_SUCCESS || dwSize == sizeof(DWORD));

    if (dwReturn == ERROR_SUCCESS)
        *pdw = * LPDWORD(pByte);

    return dwReturn;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_MULTI_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPBYTE *lppByte - address of LPBYTE in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
{
    return ReadReg(lpValue, lppByte, pdw, REG_BINARY);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
* Reads a first subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    m_iEnumIndex = 0;
    
    return GetNextSubKey(lppStr, pdw);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextSubKey(LPTSTR *lppStr, DWORD *pdw
* Reads the next subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumIndex >= 0); // must call GetFirstSubKey first.
    
    //FILETIME unused;
    
    *pdw = (sizeof(m_pMemBlock)/sizeof(m_pMemBlock[0]))+1;
    if (0 == Allocate(*pdw))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumKeyEx( 
        m_hKey,                     // handle of key to enumerate 
        m_iEnumIndex,               // index of subkey to enumerate 
        (LPTSTR)m_pMemBlock,        // address of buffer for subkey name 
        pdw,                        // address for size of subkey buffer 
        0,                          // reserved 
        NULL,                       // address of buffer for class string 
        NULL,                       // address for size of class buffer 
        NULL                        // address for time key last written to 
        ); 
    
    (*pdw)++;    // since null is not included in the size.
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;
    
    m_iEnumIndex++;
    
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a first value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
/*DWORD CRegistry::GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);

    m_iEnumValueIndex = 0;
    return GetNextValue(lppStr, pdw, pDataType);
}*/

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a next value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
/*DWORD CRegistry::GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumValueIndex >= 0); // must call GetFirstSubKey first.
    
    *pdw = (sizeof(m_pMemBlock)/sizeof(m_pMemBlock[0]))+1;
    if (0 == Allocate(*pdw))
        return ERROR_NOT_ENOUGH_MEMORY;
    
    LONG lResult = RegEnumValue( 
        m_hKey,                     // handle of key to query 
        m_iEnumValueIndex,          // index of value to query 
        (LPTSTR)m_pMemBlock,        // address of buffer for value string 
        pdw,                        // address for size of value buffer 
        0,                          // reserved 
        pDataType,                  // address of buffer for type code 
        NULL,                       // address of buffer for value data    maks_todo : use this
        NULL                        // address for size of data buffer 
        ); 
    
    (*pdw)++;    // since null is not included in the size.
    
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;
    
    
    m_iEnumValueIndex++;
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}
*/
/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = ( lstrlen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx( 
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_SZ,                 // flag for value type 
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
* writes REG_MULTI_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

#ifdef DBG
    
    // lets make sure that the given size is right.
    LPCTSTR lpTemp = lpStr;
    DWORD rightsize = 0;
    while (lstrlen(lpTemp) > 0)
    {
        rightsize  += lstrlen(lpTemp) + 1;
        lpTemp += lstrlen(lpTemp) + 1;
    }

    ASSERT(*lpTemp == 0);           // final NULL.
    rightsize++;                    // account for final terminating null

    rightsize *= sizeof(TCHAR) / sizeof(BYTE); // size must be in bytes.

    ASSERT(dwSize == rightsize);
    
#endif

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_MULTI_SZ,           // flag for value type
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
* writes REG_DWORD value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR dwValue - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);

    return RegSetValueEx( 
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_DWORD,              // flag for value type
        (LPBYTE)&dwValue,       // address of value data 
        sizeof(dwValue)         // size of value data 
        ); 
}

// copy the buffer immediately
DWORD CRegistry::GetSecurity(PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(ppSec);
    ASSERT(pdwSize);
    DWORD dwError;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    *pdwSize = 0;   // we just want to get the right size during the first call.
    
    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        &pSecurityDescriptor,    // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    // this call can not succeed. as we have set the size = 0
    ASSERT(dwError != ERROR_SUCCESS);

    if (dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        // something else has went wronng.
        // return the error code
        return dwError;
    }

    ASSERT(*pdwSize != 0);

    // now we have got the right size, allocate it.
    if (0 == Allocate(*pdwSize))
        return ERROR_OUTOFMEMORY;

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        m_pMemBlock,             // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);
    
    if (dwError == ERROR_SUCCESS)
        *ppSec = m_pMemBlock;

    return dwError;
           
}

DWORD CRegistry::SetSecurity(PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    return RegSetKeySecurity(
        m_hKey,                 // open handle of key to set
        SecurityInformation,    // descriptor contents
        pSec                    // address of descriptor for key
        );
}


#ifdef _Maks_AutoTest_

//
// make sure that CRegistry does not support
// Copy constructor & assignment operator
//
void TestRegistry (CRegistry reg)
{
    CRegistry reg2 = reg;   // should get error for copy constructor
    CRegistry reg3(reg);     // should get error for copy constructor
    CRegistry reg4;
    reg4 = reg;             // should get error for = operator.
    TestRegistry(reg);       // should get error for copy construtor
}

#endif // _Maks_AutoTest_

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\trace.cpp ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/
#include "stdafx.h"
#include <windows.h>
#include "trace.h"

#if DBG || defined(_DEBUG)



struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSRT,  "TERMSRV@TSCFGWMI: !!! ASSERT: " },
    { Z_ERR,    "TERMSRV@TSCFGWMI: *** ERROR: " },
    { Z_WRN,    "TERMSRV@TSCFGWMI: Warning: " },
    { Z_TRC1,   "TERMSRV@TSCFGWMI: " },
    { Z_TRC2,   "TERMSRV@TSCFGWMI: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
//UINT32 g_TraceMask = 0xFFFFFFFF;
UINT32 g_TraceMask = 0x0000000F;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

        if(sizeof(TB2) < (2 + strlen(OutString) + strlen(Prefix)) * sizeof(TCHAR))
            return;
            // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\terminal.cpp ===
/******************************************************************
   Copyright (C) 2000 Microsoft Corp.

   Terminal.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/
#include "stdafx.h"
#include <fwcommon.h>
#include "Terminal.h"
#include "registry.h"
#include "smartptr.h"
#include <windows.h>
#include <Iphlpapi.h>
#include "cfgbkend_i.c"


#define TS_PATH TEXT("SYSTEM\\ControlSet\\Control\\Terminal Server")
#define TS_LOGON_PATH TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define TS_ACTIVEDESKTOP TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies")
#define TERMINAL_SERVICE_PARAM_DISCOVERY  TEXT("SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters")
#define TERMINAL_SERVICE_PARAM_DISCOVERY_SERVERS  TEXT("SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\LicenseServers")


#define GUID_LENGTH 40
extern TCHAR tchErrorMessage[ 80 ];

#define ARRAYSIZE( rg ) sizeof( rg ) / sizeof( rg[0] )

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================


// Property names
//===============


// Property names
//===============

const static WCHAR* pErrorClass = L"\\\\.\\root\\cimv2:TerminalServiceSettingError";


CStackClass::CStackClass ( )
{
    HRESULT hr;

    m_pCfg = NULL;
    m_pCfgComp = NULL;

    hr = CoGetClassObject(CLSID_CfgComp, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void **)&m_pCfg); 
    
    TRC2((TB, "StackClass@Constructor: CoGetClassObject of IClassFactory ret 0x%x", hr));

    if( SUCCEEDED ( hr ) && m_pCfg != NULL )
    {           
        hr = m_pCfg->CreateInstance(NULL, IID_ICfgComp, (void **)&m_pCfgComp); 
        
        TRC2((TB, "StackClass@Constructor: CoCreateInstance of ICfgComp ret 0x%x", hr));
        
        if( SUCCEEDED ( hr ) && m_pCfgComp != NULL )
        {            
            hr = m_pCfgComp->Initialize( );
        }
        else
        {
            m_pCfgComp = NULL;
        }        
    }   
    else
    {
        m_pCfgComp = NULL;
        m_pCfg = NULL;
    }
}


//=--------------------
/******************************************************************************************************
*
*DESCRIPTION :     CWin32_TSProvider class is a base class from which all other classes are derived.
*                  The destructor releases the CfgBkEnd interface pointer.
*                  
********************************************************************************************************/

CStackClass::~CStackClass ()
{
    if ( NULL != m_pCfgComp )
    {
        m_pCfgComp->Release();
       
        TRC2((TB, "StackClass@Destructor for ICfgComp: succeeded"));        
    }    
    if ( NULL != m_pCfg )
    {
        m_pCfg->Release();
       
        TRC2((TB, "StackClass@Destructor for IClassFactory: succeeded"));       
    }
}



//------------------------




/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_TerminalServiceSetting::CWin32_TerminalServiceSetting
 *                  This class reads and sets the Server Settings such as Terminal
 *                  server mode, license type, active desktop state, temp folders,
 *                  logon and Help.
 *
 *****************************************************************************/
CWin32_TerminalServiceSetting::CWin32_TerminalServiceSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
   
    if ( g_hInstance != NULL)
    {

        TRC2((TB, "CWin32_TerminalServiceSetting_ctor"));       

        _tcscpy(m_szServerName, _T("ServerName"));

        _tcscpy(m_szMode, _T("TerminalServerMode"));

        _tcscpy(m_szLicensingName, _T("LicensingName"));

        _tcscpy(m_szLicensingDescription, _T("LicensingDescription"));

        _tcscpy(m_szActiveDesktop, _T("ActiveDesktop"));

        _tcscpy(m_szUserPerm, _T("UserPermission"));

        _tcscpy(m_szDeleteTempFolders, _T("DeleteTempFolders"));

        _tcscpy(m_szUseTempFolders, _T("UseTempFolders"));

        _tcscpy(m_szLogons, _T("Logons"));

        _tcscpy(m_szHelp, _T("Help"));

        _tcscpy(m_szValue, _T("Value"));

        _tcscpy(m_szPropertyName, _T("PropertyName"));
        
        _tcscpy(m_szChangeMode, _T("ChangeMode"));

        _tcscpy(m_szLicensingType, _T("LicensingType"));

        _tcscpy(m_szSetPolicyPropertyName, _T("SetPolicyPropertyName"));

        _tcscpy(m_szAllowTSConnections, _T("AllowTSConnections"));

        _tcscpy(m_szSetAllowTSConnections, _T("SetAllowTSConnections"));

        _tcscpy(m_szSingleSession, _T("SingleSession"));

        _tcscpy(m_szSetSingleSession, _T("SetSingleSession"));

        _tcscpy(m_szProfilePath, _T("ProfilePath"));

        _tcscpy(m_szHomeDirectory, _T("HomeDirectory"));

        _tcscpy(m_szSetProfilePath, _T("SetProfilePath"));

        _tcscpy(m_szSetHomeDirectory, _T("SetHomeDirectory"));

        _tcscpy(m_szDirectConnectLicenseServers, _T("DirectConnectLicenseServers"));

        _tcscpy(m_szAddDirectConnectLicenseServer, _T("AddDirectConnectLicenseServer"));

        _tcscpy(m_szDeleteDirectConnectLicenseServer, _T("DeleteDirectConnectLicenseServer"));

        _tcscpy(m_szLicenseServerName, _T("LicenseServerName"));

        _tcscpy(m_szTimeZoneRedirection, _T("TimeZoneRedirection"));

        _tcscpy(m_szSetTimeZoneRedirection, _T("SetTimeZoneRedirection"));

        _tcscpy(m_szDisableForcibleLogoff, _T("DisableForcibleLogoff"));

        _tcscpy(m_szSetDisableForcibleLogoff, _T("SetDisableForcibleLogoff"));

    }        
    RegGetMachinePolicy(&m_gpPolicy);
                                                                                                                       
}

//=-------------
/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_TerminalServiceSetting::~CWin32_TerminalServiceSetting
 *****************************************************************************/
CWin32_TerminalServiceSetting::~CWin32_TerminalServiceSetting ()
{
}
//=-------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TerminalServiceSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_E_INVALID_PARAMETER;        
    
    CInstance* pInstance = CreateNewInstance(pMethodContext);

    if( pInstance != NULL )
    {        

        TRC2((TB, "TerminalServiceSetting@EnumerateInstances: CreateNewInstance succeeded"));  
        
        hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES);

        if( SUCCEEDED( hr ))
        {
            hr = pInstance->Commit();            
            
        } 
        pInstance->Release( );
    }

    return hr ;
}
//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, the TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_TerminalServiceSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    

    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwMode = 0;                  // Mode
    BOOL bActivate ;
    DWORD dwStatus = 0;
    CRegistry oRegObject;
    DWORD dwData = 0;
    DWORD dwRequiredProperties = 0;


    if( Query.IsPropertyRequired(m_szServerName))
       dwRequiredProperties |= BIT_SERVERNAME;
 
    if (Query.IsPropertyRequired(m_szMode))
       dwRequiredProperties |= BIT_MODE;

    if (Query.IsPropertyRequired(m_szActiveDesktop))
       dwRequiredProperties |= BIT_ACTIVEDESKTOP;

    if (Query.IsPropertyRequired(m_szDeleteTempFolders))
       dwRequiredProperties |= BIT_DELETETEMPDIRS;

    if (Query.IsPropertyRequired(m_szLicensingType))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLicensingName))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLicensingDescription))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLogons))
       dwRequiredProperties |= BIT_LOGONS;

    if (Query.IsPropertyRequired(m_szUserPerm))
       dwRequiredProperties |= BIT_USERPERM;

    if (Query.IsPropertyRequired(m_szUseTempFolders))
       dwRequiredProperties |= BIT_PERSESSIONTEMPDIR;

    if (Query.IsPropertyRequired(m_szHelp))
       dwRequiredProperties |= BIT_HELP;

    if (Query.IsPropertyRequired(m_szAllowTSConnections))
       dwRequiredProperties |= BIT_ALLOWTSCONNECTIONS;

    if (Query.IsPropertyRequired(m_szSingleSession))
        dwRequiredProperties |= BIT_SINGLESESSION;

    if (Query.IsPropertyRequired(m_szProfilePath))
        dwRequiredProperties |= BIT_PROFILEPATH;

    if (Query.IsPropertyRequired(m_szHomeDirectory))
        dwRequiredProperties |= BIT_HOMEDIRECTORY;

    if (Query.IsPropertyRequired(m_szDirectConnectLicenseServers))
        dwRequiredProperties |= BIT_DIRECTCONNECTLICENSESERVERS;

    if (Query.IsPropertyRequired(m_szTimeZoneRedirection))
       dwRequiredProperties |= BIT_TIMEZONEREDIRECTION;

    if (Query.IsPropertyRequired(m_szDisableForcibleLogoff))
       dwRequiredProperties |= BIT_DISABLEFORCIBLELOGOFF;

    hr = LoadPropertyValues(pInstance, dwRequiredProperties);


    return S_OK ;
}
//=---------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::ExecQuery
*
*  DESCRIPTION :    The method context is passed for use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CWin32_TerminalServiceSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwRequiredProperties = 0;
    CHStringArray asNames;
    DWORD dwMode = 0;
    DWORD dwStatus = 0;
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}  	

    // Method 2
    Query.GetValuesForProp(m_szServerName, asNames);

    BOOL bGetAllInstances = asNames.GetSize() == 0;

    // Method 1
    if (Query.IsPropertyRequired(m_szServerName))
        dwRequiredProperties |= BIT_SERVERNAME;

    if (Query.IsPropertyRequired(m_szMode))
       dwRequiredProperties |= BIT_MODE;

    if (Query.IsPropertyRequired(m_szActiveDesktop))
       dwRequiredProperties |= BIT_ACTIVEDESKTOP;

    if (Query.IsPropertyRequired(m_szDeleteTempFolders))
       dwRequiredProperties |= BIT_DELETETEMPDIRS;

    if (Query.IsPropertyRequired(m_szLicensingType))
       dwRequiredProperties |= BIT_LICENSING;

    if (Query.IsPropertyRequired(m_szLogons))
       dwRequiredProperties |= BIT_LOGONS;

    if (Query.IsPropertyRequired(m_szUserPerm))
       dwRequiredProperties |= BIT_USERPERM;

    if (Query.IsPropertyRequired(m_szUseTempFolders))
       dwRequiredProperties |= BIT_PERSESSIONTEMPDIR;

    if (Query.IsPropertyRequired(m_szHelp))
        dwRequiredProperties |= BIT_HELP;

    if (Query.IsPropertyRequired(m_szAllowTSConnections))
       dwRequiredProperties |= BIT_ALLOWTSCONNECTIONS;

    if (Query.IsPropertyRequired(m_szSingleSession))
        dwRequiredProperties |= BIT_SINGLESESSION;

    if (Query.IsPropertyRequired(m_szProfilePath))
        dwRequiredProperties |= BIT_PROFILEPATH;

    if (Query.IsPropertyRequired(m_szHomeDirectory))
        dwRequiredProperties |= BIT_HOMEDIRECTORY;

    if (Query.IsPropertyRequired(m_szDirectConnectLicenseServers))
        dwRequiredProperties |= BIT_DIRECTCONNECTLICENSESERVERS;

    if (Query.IsPropertyRequired(m_szTimeZoneRedirection))
       dwRequiredProperties |= BIT_TIMEZONEREDIRECTION;

    if (Query.IsPropertyRequired(m_szDisableForcibleLogoff))
       dwRequiredProperties |= BIT_DISABLEFORCIBLELOGOFF;


    ISettingsComp *pSettings = NULL;
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    do
    {
        if( SUCCEEDED( hr ) && pSettings != NULL )
        {

           // Method 2

            CInstance* pInstance = CreateNewInstance(pMethodContext);

            if( pInstance == NULL)
            {

               ERR((TB, "TerminalServiceSetting@ExecQuery: CreateNewInstance failed"));

               hr = WBEM_E_OUT_OF_MEMORY;

               break;            
            }            
      
            hr = LoadPropertyValues(pInstance, dwRequiredProperties);

            if( SUCCEEDED( hr ) )
            {
               hr = pInstance->Commit();
            }

            pInstance->Release();
        }
    
    }while (0);

    if ( pSettings != NULL )
    {
        pSettings->Release();
    }

    return hr;

}


//=--------------

BOOL CWin32_TerminalServiceSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


//=---------
/*************************************************************************************
*
*  FUNCTION    : CWin32_TerminalServiceSetting::PutInstance
*
*  DESCRIPTION :    PutInstance is in provider classes that can 
*                   write instance information back to the registry.
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   property - TerminalServerMode.
* 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    :    ActiveDesktop state, UserPerm and Logon are configurable through 
*                   this method as they are not Group Policy based nor server-overridable. 
*
***************************************************************************************/

HRESULT CWin32_TerminalServiceSetting::PutInstance ( const CInstance &Instance, long lFlags)
{   
    HRESULT hr = 0;               
    DWORD dwMode = 0;
    DWORD dwlicensing = 0;         // Licensing mode
    DWORD dwActiveDesktop = 0;     // Active Desktop Enabled or Disabled
    DWORD dwUserPerm = 0;          // Application Compatibility
    DWORD dwDeleteTempFolders = 0; // Delete Temporary Directories on Exit
    DWORD dwUseTempFolders = 0;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    CHString chData;
    CRegistry oRegObject;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
    TCHAR tch[MAX_PATH] = {0};
    ICfgComp *pCfgComp = NULL;
    HKEY hKey = NULL;
    HKEY hOutKey = NULL;
        

        
    hr = WBEM_S_NO_ERROR;
    
	CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    ISettingsComp *pSettings = NULL;

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;
    
    do
    {
        if( SUCCEEDED (hr) && pSettings != NULL )
        {                   
            if( Instance.GetDWORD(m_szActiveDesktop, dwActiveDesktop ) )
            {
                hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            TS_ACTIVEDESKTOP ,
                            0,
                            KEY_READ ,
                            &hKey );

                if( ERROR_SUCCESS == hr )
                { 


                    hr = RegCreateKeyEx( hKey ,
                                            L"Explorer",
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hOutKey ,
                                            &dwData ); 
                    
                }                                                                          

                if( dwActiveDesktop != 0 && dwActiveDesktop != 1 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }

                pSettings->SetActiveDesktopState( dwActiveDesktop, &dwStatus );

                TRC2((TB, "TerminalServiceSetting@PutInstance: SetActiveDesktopState returned 0x%x\n" , dwStatus));
            }
                            
            
            if( Instance.GetDWORD( m_szUserPerm, dwUserPerm ) )
            {
                if( dwUserPerm != 0 && dwUserPerm != 1 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }

                pSettings->SetUserPerm(dwUserPerm, &dwStatus );

                TRC2((TB, "TerminalServiceSetting@PutInstance: SetUserPerm returned 0x%x\n" , dwStatus));               
            }            
            
          

            hr = oRegObject.OpenKey(HKEY_LOCAL_MACHINE, TS_LOGON_PATH);

            chData.Empty();

            if( SUCCEEDED( hr ) )
            {
                if( GetVersionEx( &OsVersionInfo) )
                {
                    if( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion == 0 )
                    {
                        TRC2((TB, "TerminalServiceSetting@GetObject GetVersionInfo is Win2000"));

                        if( Instance.GetCHString(m_szLogons, chData ) )
                        {
                            if( chData.IsEmpty() || ((lstrcmp ((LPCTSTR)chData, L"0") != 0 ) && (lstrcmp ((LPCTSTR) chData, L"1") != 0)) )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                
                                break;
                            }

                            // Todo: Add this for Beta2 to reverse logic

                            /*

                            if( lstrcmp ((LPCTSTR)chData, L"0") == 0 )
                            {
                                chData.Empty();
                                chData = L"1";
                            }
                            else
                            {
                                chData.Empty();
                                chData = L"0";
                            }
                            */
                                              
                            hr = oRegObject.WriteRegString(L"WinStationsDisabled", (LPTSTR) (LPCTSTR) chData);
                        
                            TRC2((TB, "TerminalServiceSetting@PutInstance WinStationsDisabled returned 0x%x\n" , hr));                                                   
                        }
                    }     
    
                    else
                    {
                        TRC2((TB, "TermServiceSetting@PutInstance GetVersionInfo is Whistler"));

                        if( Instance.GetCHString(m_szLogons, chData ) )
                        {
                            if( chData.IsEmpty() || ((lstrcmp ((LPCTSTR)chData, L"0") != 0 ) && (lstrcmp ((LPCTSTR) chData, L"1") != 0)) )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                
                                break;
                            } 
                            
                            /*

                            if( lstrcmp ((LPCTSTR)chData, L"0") == 0 )
                            {
                                chData.Empty();
                                chData = L"1";
                            }
                            else
                            {
                                chData.Empty();
                                chData = L"0";
                            }
                            */
                            
                            hr = oRegObject.WriteRegString(L"WinStationsDisabled", (LPTSTR) (LPCTSTR) chData);
                        
                            TRC2((TB, "TermServiceSetting@PutInstance WinStationDisabled returned 0x%x\n" , hr));
                        }
                    }                                        
                }                                    
            }

            // ForceUpdate() is called explicitly to update WinstationsDisabled in the registry.

            if( SUCCEEDED( hr ) )
            {
                StackObj.m_pCfgComp->ForceUpdate();
            }
        }

    }while(0);

    if( NULL != hKey)
    {
        RegCloseKey(hKey);
    }
        
    if( NULL != hOutKey)
    {
        RegCloseKey(hOutKey);
    }
	
    if( pSettings != NULL )
    {
        pSettings->Release();
    }
    
    return hr;
    
}


//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_TerminalServiceSetting::DeleteInstance ( const CInstance &Instance,  long lFlags )
{
    

    return (WBEM_E_PROVIDER_NOT_CAPABLE);

}


//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalServiceSetting::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    :    Provides method to configure the License type base on
*                   the Terminal server mode, UseTempFolders, DeleteTempFolders
*                   and Help that are group policy based.
*
*****************************************************************************/
HRESULT CWin32_TerminalServiceSetting::ExecMethod ( const CInstance& Inst,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags)

{
    
    
    DWORD dwMode = 0;
    DWORD dwLicensing = 0;
    DWORD dwStatus = 0;
    DWORD dwNewStatus = 0;
    DWORD dwData = 0;
    HANDLE hServer = NULL;
    BOOL fRet = FALSE;
    CHString chData;
    bool fData;
    bool bRet;
    CRegistry oRegObject;	
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CStackClass StackObj;
    HKEY hKey = NULL;
    HKEY hOutKey = NULL;
    

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    ISettingsComp *pSettings = NULL;

    if(pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;
        
    do
    {        
        if( SUCCEEDED (hr) && pSettings != NULL )
        {            
            if( _wcsicmp(bstrMethodName, m_szChangeMode) == 0 )
            {
                // Configures License type based on the Terminal Server Mode. {None, Remote Administration} for "Remote Admin", 
                // {Per Seat, Per CPU, ICL} for "Application Server" and {Personal Terminal Server} for "Personal Terminal Server".
                // uint32 ChangeMode([In] uint32 LicensingType);
                            
                hr = WBEM_S_NO_ERROR ;
                
                
                bRet = pInParams->GetDWORD(m_szLicensingType, dwLicensing);
                
                if ( !bRet )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }                    
                                
                
                hServer = ServerLicensingOpen(NULL);

                if (NULL != hServer)
                {                
                    dwStatus = ServerLicensingSetPolicy(hServer, dwLicensing, &dwNewStatus);                               
                
                    TRC2( (TB, "TermServiceSetting@ExecMethod:ChangeMode ServerLicensingSetPolicy ret old: 0x%x new: 0x%x\n" , dwStatus, dwNewStatus) );  
                
                    if( ERROR_SUCCESS == dwStatus && ERROR_SUCCESS == dwNewStatus && pOutParams != NULL )
                    {
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }
                    else if( ERROR_SUCCESS != dwStatus || ERROR_SUCCESS != dwNewStatus )
                    {                        
                        hr = WBEM_E_INVALID_OPERATION;                        

                        break;
                    }                    
                }
                
            }

            else if( _wcsicmp( bstrMethodName, m_szSetAllowTSConnections ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDenyTSConnections == 0 )
                {  
                    TRC2((TB, "Condition to update fPolicyDenyTSConnections satisfied"));                        
                      
                    bRet = pInParams->GetDWORD(m_szAllowTSConnections, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    } 

                    // The bit is negated because it calls the function SetDenyTSConnections which is negative logic.
                    
                    if( dwData == 0 )
                    {
                        dwData = 1;                                            
                    }
                    else if( dwData == 1 )
                    {
                        dwData = 0;
                    }
                                        
                    hr = pSettings->SetDenyTSConnections( dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetAllowTSConnections ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }

            else if( _wcsicmp( bstrMethodName, m_szSetTimeZoneRedirection ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);
                //todo: change the policy name

                if( m_gpPolicy.fPolicyEnableTimeZoneRedirection == 0 )
                {  
                    TRC2((TB, "Condition to update fPolicyEnableTimeZoneRedirection satisfied"));                        
                      
                    bRet = pInParams->GetDWORD(m_szTimeZoneRedirection, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                   
                                        
                    hr = pSettings->SetTimeZoneRedirection( dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetTimeZoneRedirection ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            
            else if( _wcsicmp( bstrMethodName, m_szSetSingleSession ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicySingleSessionPerUser == 0 )
                {  
                    TRC2((TB, "Condition to update fSingleSessionPerUser satisfied"));                        
                      
                    bRet = pInParams->GetDWORD(m_szSingleSession, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        
                    
                    hr = pSettings->SetSingleSessionState( dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetSingleSession ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            else if( _wcsicmp( bstrMethodName, m_szSetProfilePath ) == 0 )
            {
                
                BSTR bstrVal = NULL;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyWFProfilePath == 0 )
                {  
                    TRC2((TB, "Condition to update WFProfilePath satisfied"));                        
                      
                    bRet = pInParams->GetCHString(m_szProfilePath, chData);                    

                    if ( !bRet )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        

                    bstrVal = SysAllocString((LPTSTR) (LPCTSTR) (chData));

                    if(bstrVal != NULL)
                    {                                         
                        hr = pSettings->SetProfilePath( bstrVal , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                            TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetProfilePath ret 0x%x\n" , hr  ));
                        }
                    }
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            else if( _wcsicmp( bstrMethodName, m_szSetHomeDirectory ) == 0 )
            {
                
                BSTR bstrVal = NULL;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyWFHomeDir == 0 )
                {  
                    TRC2((TB, "Condition to update WFProfilePath satisfied"));                        
                      
                    bRet = pInParams->GetCHString(m_szHomeDirectory, chData);
                    

                    if ( !bRet )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                          

                    bstrVal = SysAllocString((LPTSTR) (LPCTSTR) (chData));

                    if(bstrVal != NULL)
                    {                   
                        hr = pSettings->SetHomeDir( bstrVal , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                            TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetHomeDirectory ret 0x%x\n" , hr  ));
                        }
                    }
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            else if( _wcsicmp( bstrMethodName, m_szSetDisableForcibleLogoff ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableForcibleLogoff == 0 )
                {  
                    TRC2((TB, "Condition to update fDisableForcibleLogoff satisfied"));                        
                      
                    bRet = pInParams->GetDWORD(m_szDisableForcibleLogoff, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        
                    
                    hr = pSettings->SetDisableForcibleLogoff( dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TerminalServiceSetting@ExecMethod:  SetDisableForcibleLogoff ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            }
            else if( _wcsicmp(bstrMethodName, m_szSetPolicyPropertyName) == 0 )
            {
                //  PropertyName is an enumeration of the properties: 
                //  DeleteTempFolders, UseTempFolders and Help which are flags that are either set
                //  to False or True according as whether Value is set to 0 or 1 respectively.
                //                                  
                //  uint32 SetPolicyPropertyName([In] string PropertyName, [In] boolean Value) ;
                
                bRet = 0;

                RegGetMachinePolicy(&m_gpPolicy);
    
                pInParams->GetCHString(m_szPropertyName, chData);                
                
                if( chData.CompareNoCase(m_szDeleteTempFolders) == 0 )
                {
                    bRet = pInParams->Getbool(m_szValue, fData);
                    
                    TRC2((TB, "m_gpPolicy.fPolicyDeleteTempFoldersOnExit ret 0x%x\n", m_gpPolicy.fPolicyDeleteTempFoldersOnExit));                          
                    
                    if( m_gpPolicy.fPolicyDeleteTempFoldersOnExit == 0 )
                    {  
                        TRC2((TB, "Condition to update fPolicyDeleteTempFoldersOnExit satisfied"));
                        
                        if( !bRet || (fData != 0 && fData != 1 ))
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        hr = pSettings->SetDelDirsOnExit(fData);
                        
                        TRC2((TB, "TerminalServiceSetting@PutInstance: SetDelDirsOnExit"));
                        
                        if( pOutParams != NULL )
                        {
                            pOutParams->SetDWORD(L"ReturnValue", hr);
                        }
                        
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }
                }
                else if( chData.CompareNoCase(m_szUseTempFolders) == 0 )
                {
                    bRet = 0;

                    bRet = pInParams->Getbool(L"Value", fData);
                    
                    TRC2((TB, "m_gpPolicy.fPolicyTempFoldersPerSession ret 0x%x\n", m_gpPolicy.fPolicyTempFoldersPerSession));

                    
                    if( m_gpPolicy.fPolicyTempFoldersPerSession == 0 )
                    {
                        TRC2((TB, "Condition to update fPolicyTempFoldersPerSession satisfied"));
                        
                        if( !bRet || ( fData != 0 && fData != 1 ))
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                            
                            break;
                        }
                        
                        hr = pSettings->SetUseTempDirPerSession(fData );
                        
                        TRC2((TB, "TerminalServiceSetting@ExecMethod: SetUseTempDirPerSession"));
                        
                        if( pOutParams != NULL )
                        {
                            pOutParams->SetDWORD(L"ReturnValue", hr);
                        }
                        
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }
                }
                else if( chData.CompareNoCase(m_szHelp) == 0 )
                {   
                    bRet = 0;

                    hr = oRegObject.OpenKey(HKEY_LOCAL_MACHINE, TS_POLICY_SUB_TREE);

                    if( SUCCEEDED (hr) )
                    {
                        if( ERROR_SUCCESS != oRegObject.ReadRegDWord(POLICY_TS_REMDSK_ALLOWTOGETHELP, &dwData) )
                        {
                            bRet = pInParams->Getbool(m_szValue, fData);                        
        
                            TRC2((TB, "Condition to update fAllowToGetHelp satisfied"));
            
                            if( !bRet || (fData != 0 && fData != 1 ))
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                
                                break;
                            }
            
                            hr = pSettings->SetSalemHelpMode(fData, &dwStatus );
            
                            TRC2((TB, "TerminalServiceSetting@ExecMethod: Help"));
            
                            if( pOutParams != NULL && dwStatus == ERROR_SUCCESS )
                            {                               
                                pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                            }                                                
                            else
                            {
                                hr = WBEM_E_INVALID_OPERATION;
                
                                break;
                            }
                        }
                    }                            
                }
                else
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                
                    break;
                }  
            }

                                
            else if(  _wcsicmp( bstrMethodName, m_szAddDirectConnectLicenseServer ) == 0 )
            {                      
                DWORD dwReturn = 0;
                 
                bRet = pInParams->GetCHString(m_szLicenseServerName, chData);

                if( chData.IsEmpty() || (chData.GetLength() >= OPAQUESETTINGS_LENGTH) )
                {
                    hr = WBEM_E_INVALID_PARAMETER;

                    break;
                }

              
                
                hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TERMINAL_SERVICE_PARAM_DISCOVERY ,
                                    0,
                                    KEY_READ ,
                                    &hKey );

                if( ERROR_SUCCESS == hr )
                { 


                    hr = RegCreateKeyEx( hKey ,
                                            L"LicenseServers",
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_ALL_ACCESS,
                                            NULL,
                                            &hOutKey ,
                                            &dwReturn ); 
                    if( ERROR_SUCCESS == hr )
                    {                                    
                        hr = RegCreateKeyEx( hOutKey ,
                                                chData.LockBuffer(),
                                                0,
                                                NULL,
                                                REG_OPTION_NON_VOLATILE,
                                                KEY_ALL_ACCESS,
                                                NULL,
                                                &hOutKey ,
                                                &dwReturn );   
                        chData.UnlockBuffer();

                        TRC2((TB, "Win32_TerminalServiceSetting@ExecMethod: AddLicenseServer ret 0x%x" , hr));                 
                    }

                    if( hr == ERROR_SUCCESS )
                    {

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }  
                                        
                    chData.Empty();
                }
            }

            else if(  _wcsicmp( bstrMethodName, m_szDeleteDirectConnectLicenseServer ) == 0 )
            {                      
                DWORD dwReturn = 0;
                 
                bRet = pInParams->GetCHString(m_szLicenseServerName, chData );

                
                if( chData.IsEmpty() || (chData.GetLength() >= OPAQUESETTINGS_LENGTH) )
                {
                    hr = WBEM_E_INVALID_PARAMETER;

                    break;
                }

                hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    TERMINAL_SERVICE_PARAM_DISCOVERY_SERVERS,                                        
                                    0,
                                    KEY_ALL_ACCESS ,
                                    &hKey );

                if( ERROR_SUCCESS == hr )
                { 
            
                    hr = RegDeleteKey( hKey ,
                                         chData.LockBuffer() );      

                    TRC2((TB, "Win32_TerminalServiceSetting@ExecMethod: DeleteLicenseServer ret 0x%x" , hr));                       

                    if( hr == ERROR_SUCCESS )
                    {

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.UnlockBuffer();

                    chData.Empty();                        
                
                }
                else
                {
                    hr = S_OK;
                }
            }                                                                                                            
        }

    }while (0);

    if( NULL != hKey )
    {
        RegCloseKey(hKey);
    }

    if(NULL != hOutKey)
    {
        RegCloseKey(hOutKey);
    }

    if( NULL != hServer )
    {
        ServerLicensingClose(hServer);
    }
    
    if( pSettings != NULL )
    {
        pSettings->Release();       
    }
    
    return hr;
}

//=---------

HRESULT CWin32_TerminalServiceSetting::LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties)
{         
    int Licensing;
    DWORD dwMode = 0;
    DWORD dwData = 0;
    ULONG ulMode = 0;
    CRegistry oRegObject;
    DWORD dwSize = 0;
    BOOL bData = 0;
    BOOL bActivate = 0;
    DWORD dwStatus = 0;
    DWORD dwType = 0;
    HANDLE      hServer = NULL;
    BYTE bbyte;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
    LPTSTR lpLogon; 
    int iData;
    LPLCPOLICYINFO_V1W pPolicyInfo = NULL;
    ULONG  ulInfoStructVersion = LCPOLICYINFOTYPE_CURRENT;	
    CHString chLogon;
    CHString chData;
    HKEY hParamKey = NULL;
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    CHString chServerName;
    
    chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());

    CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInstance == NULL )
    {
        ERR((TB, "TermServiceSetting@LoadPropertyValues: invalid interface"));

        return E_FAIL;
    }
    ISettingsComp *pSettings = NULL;

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;    

    if( SUCCEEDED (hr) && pSettings != NULL )
    {

        if( dwRequiredProperties & BIT_SERVERNAME )
        {
            pInstance->SetCHString(m_szServerName, chServerName);            
        }

        if( dwRequiredProperties & BIT_MODE )
        {
            pSettings->GetTermSrvMode(&dwMode , &dwStatus );
        
            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetTermSrvMode returned 0x%x\n" , dwStatus));

            if( ERROR_SUCCESS == dwStatus )
            {            
                pInstance->SetDWORD(m_szMode, dwMode);
            }            
        }

        if( dwRequiredProperties & BIT_LICENSING )
        {            
            hServer = ServerLicensingOpen(NULL);

            if (NULL != hServer)
            {
                if( ServerLicensingGetPolicy( hServer, &ulMode ) )
                {            
                    TRC2((TB, "TermServiceSetting@LoadPropertyValues: ServerLicensingGetPolicy ret 0x%x\n" , dwStatus));
                 
                    pInstance->SetDWORD(m_szLicensingType, (DWORD &)ulMode);   
                    
                    if( ServerLicensingGetPolicyInformation( hServer, ulMode, &ulInfoStructVersion, 
                        (LPLCPOLICYINFOGENERIC *) &pPolicyInfo ))
                    {
                        pInstance->SetCHString(m_szLicensingName, pPolicyInfo->lpPolicyName );
                        pInstance->SetCHString(m_szLicensingDescription, pPolicyInfo->lpPolicyDescription );

                        ServerLicensingFreePolicyInformation((LPLCPOLICYINFOGENERIC *)&pPolicyInfo);
                    }
                }      

                ServerLicensingClose(hServer);
            }
            
        }

        if( dwRequiredProperties & BIT_ACTIVEDESKTOP )
        {            
            pSettings->GetActiveDesktopState(&bActivate , &dwStatus );

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetActiveDesktopState returned 0x%x\n" , dwStatus));
    
            if( ERROR_SUCCESS == dwStatus )
            {
                pInstance->SetDWORD(m_szActiveDesktop, (DWORD &)bActivate);
            }

            if( ERROR_FILE_NOT_FOUND == dwStatus )
            {
                pInstance->SetDWORD(m_szActiveDesktop, 1);
            }
            
        }

        if( dwRequiredProperties & BIT_USERPERM )
        {
            pSettings->GetUserPerm(&bActivate , &dwStatus );

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetUserPerm returned 0x%x\n" , dwStatus));

            if( ERROR_SUCCESS == dwStatus )
            {
                pInstance->SetDWORD(m_szUserPerm, bActivate);        
            }            
        }        
            

        if( dwRequiredProperties & BIT_DELETETEMPDIRS )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyDeleteTempFoldersOnExit != 0 )
            {
                bActivate = m_gpPolicy.fDeleteTempFoldersOnExit;
            }
            else
            {
                pSettings->GetDelDirsOnExit( &bActivate );
            }

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetDelDirsOnExit returned 0x%x\n" , hr));
            
            pInstance->SetDWORD(m_szDeleteTempFolders, bActivate);                        
        }

        if( dwRequiredProperties & BIT_PERSESSIONTEMPDIR )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyTempFoldersPerSession != 0 )
            {
                bActivate = m_gpPolicy.fTempFoldersPerSession;
            }
            else
            {
                pSettings->GetUseTempDirPerSession(&bActivate );
            }

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetUseTempDirsPerSession returned 0x%x\n" , hr));
              
            pInstance->SetDWORD(m_szUseTempFolders, bActivate);                        
        }
        

        if( dwRequiredProperties & BIT_LOGONS )
        {
            hr = oRegObject.OpenKey(HKEY_LOCAL_MACHINE, TS_LOGON_PATH);

            if( SUCCEEDED( hr ) )
            {   
                if( GetVersionEx( &OsVersionInfo) )
                {

                    if( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion == 0 )
                    {
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetVersionInfo is Win2000"));

                        dwData = 0;
                                      
                        hr = oRegObject.ReadRegDWord(L"WinStationsDisabled", &dwData);
                        
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetWinStationsDisabled returned 0x%x\n" , hr));

                        if( SUCCEEDED (hr) )
                        {
                            if( dwData == 0 )
                            {
                                pInstance->SetCharSplat(m_szLogons, L"0");
                            }

                            else
                            {
                                pInstance->SetCharSplat(m_szLogons, L"1");
                            }
                        }                        
                    }     
    
                    else
                    {
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetVersionInfo is Whistler"));                    
          
                        hr = oRegObject.ReadRegString(L"WinStationsDisabled", &lpLogon, &dwData);
                        
                        TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetWinStationsDisabled returned 0x%x\n" , hr));

                        if( SUCCEEDED( hr ) )
                        {        
                            pInstance->SetCharSplat(m_szLogons, lpLogon);
                        }                        
                    }
                }                                                      
            }
        }

        if( dwRequiredProperties & BIT_HELP )
        {
           
            hr = pSettings->GetSalemHelpMode(&iData, &dwStatus );            

            TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetHelp returned 0x%x" , dwStatus));

            if( S_OK == dwStatus )
            {              
                pInstance->SetDWORD(m_szHelp, iData);            
            }
            else
            {
                pInstance->SetDWORD(m_szHelp, 0);
            }
        }

        if( dwRequiredProperties & BIT_ALLOWTSCONNECTIONS )
        {
           
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyDenyTSConnections != 0 )
            {
                iData = m_gpPolicy.fDenyTSConnections;
            }
            else
            {                
                hr = pSettings->GetDenyTSConnections(&iData, &dwStatus );            

                TRC2((TB, "TermServiceSetting@LoadPropertyValues: GetAllowTSConnections returned 0x%x" , dwStatus));
            }

            // The bit is negated because it calls the function GetDenyTSConnections which is negative logic.

            if( iData == 0)
            {
                iData = 1;
            }
            else if( iData == 1)
            {
                iData = 0;
            }
             
            pInstance->SetDWORD(m_szAllowTSConnections, iData);                                                 
        
            TRC2((TB,"TerminalServiceSetting@LoadPropertyValues: AllowTSConnections" ));
        }

        if( dwRequiredProperties & BIT_TIMEZONEREDIRECTION )
        {
           
            RegGetMachinePolicy(&m_gpPolicy);

            //todo: change policy name

            if( m_gpPolicy.fPolicyEnableTimeZoneRedirection  != 0 )
            {
                iData = m_gpPolicy.fEnableTimeZoneRedirection;
            }
            else
            {                
                hr = pSettings->GetTimeZoneRedirection(&iData, &dwStatus ); 
                
                if(dwStatus != ERROR_SUCCESS)
                {
                    iData = 0;
                }

                TRC2((TB, "TerminalServiceSetting@LoadPropertyValues: GetTimeZoneRedirection returned 0x%x" , dwStatus));
            }
             
            pInstance->SetDWORD(m_szTimeZoneRedirection, iData);                                                 
        
            TRC2((TB,"TerminalServiceSetting@LoadPropertyValues: TimeZoneRedirection" ));
        }

        if( dwRequiredProperties & BIT_SINGLESESSION)
        {  
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySingleSessionPerUser != 0 )
            {
                bData = m_gpPolicy.fSingleSessionPerUser;
            }
            else
            {  
                hr = pSettings->GetSingleSessionState( &bData, &dwStatus);
            }
            dwData = bData;

            pInstance->SetDWORD(m_szSingleSession, dwData);                                               
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: SingleSession" ));
        }

        if( dwRequiredProperties & BIT_DISABLEFORCIBLELOGOFF)
        {  
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyDisableForcibleLogoff != 0 )
            {
                bData = m_gpPolicy.fDisableForcibleLogoff;
            }
            else
            {  
                hr = pSettings->GetDisableForcibleLogoff( &bData, &dwStatus);
            }
            dwData = bData;

            pInstance->SetDWORD(m_szDisableForcibleLogoff, dwData);                                               
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: DisableForcibleLogoff" ));
        }
       
        if( dwRequiredProperties & BIT_PROFILEPATH)
        { 
            BSTR bstrData = NULL;

            chData.Empty();

            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyWFProfilePath != 0 )
            {               
                chData.Format(L"%s", m_gpPolicy.WFProfilePath);
            }
            else
            {                  
                hr = pSettings->GetProfilePath( &bstrData, &dwStatus);

                if( bstrData != NULL)
                {
                    chData.Format(L"%s", (LPCWSTR)(bstrData));

                    SysFreeString(bstrData);
                }
            }            

            pInstance->SetCHString(m_szProfilePath, chData);                          
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: ProfilePath" ));
        }

        if( dwRequiredProperties & BIT_HOMEDIRECTORY)
        {  
            BSTR bstrData = NULL;

            chData.Empty();

            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyWFHomeDir != 0 )
            {                
                chData.Format(L"%s", m_gpPolicy.WFHomeDir);               
            }
            else
            {  
                hr = pSettings->GetHomeDir( &bstrData, &dwStatus);

                if(bstrData != NULL)
                {
                    chData.Format(L"%s", (LPCWSTR)(bstrData));

                    SysFreeString(bstrData);
                }
            }           

            pInstance->SetCHString(m_szHomeDirectory, chData);                                                         
        
            TRC2((TB,"TermServiceSetting@LoadPropertyValues: HomeDirectory" ));
        }

        if( dwRequiredProperties & BIT_DIRECTCONNECTLICENSESERVERS)
        {  
            
            DWORD dwValueType;
            DWORD cbValue = 0, dwDisp;
            LONG lReturn;
            DWORD cbServer;
            DWORD cServers;
            DWORD cchServerMax;
            LPWSTR szServer;
            DWORD i, j;
            CHString chServers;
            chServers.Empty();
            
            do
            {            

                lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               TERMINAL_SERVICE_PARAM_DISCOVERY_SERVERS,
                               0,
                               KEY_READ,
                               &hParamKey );

                if (ERROR_SUCCESS != lReturn)
                {
                    break;
                }

                lReturn = RegQueryInfoKey(hParamKey,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &cServers,
                                          &cchServerMax,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL);

                if (ERROR_SUCCESS != lReturn)
                {
                    RegCloseKey( hParamKey );

                    break;
                }

                if (0 == cServers)
                {
                    RegCloseKey( hParamKey );

                    hParamKey = NULL;

                    break;
                }
                

                // Add one for null terminator
                cchServerMax++;

                szServer = (LPWSTR) LocalAlloc(LPTR,cchServerMax * sizeof(WCHAR));

                if(NULL == szServer)
                {
                    LocalFree(szServer);

                    RegCloseKey( hParamKey );

                    hParamKey = NULL;

                    break;
                } 
    
                for (i = 0; i < cServers; i++)
                {
                    if(!chServers.IsEmpty())
                    {
                        chServers+=L"; ";
                    }                                                       

                    cbServer = cchServerMax * sizeof(WCHAR);

                    lReturn = RegEnumKeyEx(hParamKey,
                                           i,
                                           szServer,
                                           &cbServer,
                                           NULL,
                                           NULL,
                                           NULL,
                                           NULL);

                    if (ERROR_SUCCESS != lReturn)
                    {
                        LocalFree(szServer);

                        RegCloseKey( hParamKey );

                        hParamKey = NULL;

                        break;
                    }

                    chServers+= szServer;                

                    
                }

                if(szServer)
                {
                    LocalFree(szServer);                      
                }

                pInstance->SetCHString(m_szDirectConnectLicenseServers, chServers);

            }while(0);
        }
    }
   

    if(hParamKey)
    {
        RegCloseKey(hParamKey);
    }

    if( pSettings != NULL )
    {
        pSettings->Release();
    }
    
    return S_OK;
}

//=---------
/*************************************************************************************
*
*  DESCRIPTION :    CWin32_TerminalService class is subclassed from the Win32_Service
*                   class in CIM schema. It provides live information such as Total
*                   sessions, Disconnected sessions, Resource constraint and 
*                   Raw session capacity.
*
***************************************************************************************/

CWin32_TerminalService::CWin32_TerminalService (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
    if (g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TerminalService_ctor"));

        _tcscpy(m_szName, _T("Name"));

        _tcscpy(m_szCaption, _T("Caption"));

        _tcscpy(m_szTotalSessions, _T("TotalSessions"));

        _tcscpy(m_szDisconnectedSessions, _T("DisconnectedSessions"));
/*
        _tcscpy(m_szEstimatedSessionCapacity, _T("EstimatedSessionCapacity"));

        _tcscpy(m_szResourceConstraint, _T("ResourceConstraint"));

        _tcscpy(m_szRawSessionCapacity, _T("RawSessionCapacity"));
*/
        
    }    
}

//=-----------------

CWin32_TerminalService::~CWin32_TerminalService ()
{
}

//=--------------------
/************************************************************************************
*
*  DESCRIPTION :    Find a single instance based on the key property, "Name". 
*
*  INPUTS      :    A pointer to a CInstance object containing the key property, "Name". 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
**************************************************************************************/

HRESULT CWin32_TerminalService::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chServerName;
    TCHAR tchServer[MAX_PATH] = {0};
    HANDLE hServerName = SERVERNAME_CURRENT;
    ULONG CurrentLogonId = (ULONG) -1;
    WINSTATIONLOADINDICATORDATA LIData;
    ULONG Length = 0;
    DWORD dwRequiredProperties = 0;
    CHString chName;

    pInstance->GetCHString(m_szName, chName);

    pInstance->SetCHString(m_szCaption, chName);

    if( chName.CompareNoCase(L"TermService") == 0 )
    {    
        chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());
        wcscpy (tchServer, chServerName);
        bool bRet = 0;

        if (Query.IsPropertyRequired(m_szTotalSessions))
           dwRequiredProperties |= BIT_TOTALSESSIONS;

        if (Query.IsPropertyRequired(m_szDisconnectedSessions))
           dwRequiredProperties |= BIT_DISCONNECTEDSESSIONS;
/*
        if (Query.IsPropertyRequired(m_szEstimatedSessionCapacity))
           dwRequiredProperties |= BIT_ESTIMATEDSESSIONCAPACITY;

        if (Query.IsPropertyRequired(m_szResourceConstraint))
           dwRequiredProperties |= BIT_RESOURCECONSTRAINT;

        if (Query.IsPropertyRequired(m_szRawSessionCapacity))
           dwRequiredProperties |= BIT_RAWSESSIONCAPACITY;
*/
        hServerName = WinStationOpenServer (tchServer);

        CurrentLogonId = GetCurrentLogonId();

        if( hServerName != NULL )
        {
            bRet  = WinStationQueryInformation(hServerName, CurrentLogonId,
                                       WinStationLoadIndicator,
                                       &LIData,
                                       sizeof(LIData), &Length)  ;
            if( bRet )
            {
                hr = LoadPropertyValues(pInstance, dwRequiredProperties, LIData);
            }
        }
        else
        {        
            ERR((TB, "Win32_TerminalService@GetObject: WinStationQueryInformation GetLastError returned: 0x%x\n" ,GetLastError()));
        }
    }
          
    return hr;        
}

//=------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TerminalService::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*
*****************************************************************************/

HRESULT CWin32_TerminalService::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{

    return WBEM_S_NO_ERROR;

    // Commented as implementation is protocol dependent
/*
    CHString chServerName;
    TCHAR tchServer[MAX_PATH] = {0};
    HANDLE hServer = SERVERNAME_CURRENT;
    WINSTATIONLOADINDICATORDATA LIData;
    ULONG CurrentLogonId = (ULONG) -1;
    ULONG Length;
    chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());
    wcscpy (tchServer, chServerName);
    hServer = WinStationOpenServer (tchServer);
    bool bRet = 0;

    CurrentLogonId = GetCurrentLogonId();

    if (hServer != NULL)
    {        

        bRet  = WinStationQueryInformation(hServer, CurrentLogonId,
                                   WinStationLoadIndicator,
                                   &LIData,
                                   sizeof(LIData), &Length);

        TRC2((TB, "Win32_TerminalService@EnumerateInstances: WinStationQueryInformation bRet: 0x%x\n" , bRet));

        if (bRet)
        {
            CInstance* pInstance = CreateNewInstance(pMethodContext);        
    
            if( pInstance != NULL )
            {
               
                pInstance->SetCHString(m_szServerName, chServerName);                              

                hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, LIData);

                if ( SUCCEEDED( hr ))
                {            
                    hr = pInstance->Commit();
                }        
                            
                pInstance->Release();             
            }
        }
    }
    else
    {
       
        TRC2((TB, "Win32_TerminalService@EnumerateInstances: WinStationQueryInformation GetLastError returned: 0x%x\n" , hr));
    }
           
    return hr; 
    */
    
}

//=-------------

HRESULT CWin32_TerminalService::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwRequiredProperties = 0;
    CHStringArray asNames;
    DWORD dwMode;
    DWORD dwStatus;
    CHString chServerName;
    TCHAR tchServer[MAX_PATH] = {0};
    bool bRet = 0;

    HANDLE hServerName = SERVERNAME_CURRENT;
    WINSTATIONLOADINDICATORDATA LIData;
    ULONG CurrentLogonId = (ULONG) -1;
    ULONG Length = 0;
    
    chServerName.Format(L"%s", (LPCTSTR)GetLocalComputerName());

    wcscpy (tchServer, chServerName);

    hServerName = WinStationOpenServer (tchServer);    

    CurrentLogonId = GetCurrentLogonId();

    if( hServerName != NULL )
    {
        bRet  = WinStationQueryInformation(hServerName, CurrentLogonId,
                                   WinStationLoadIndicator,
                                   &LIData,
                                  sizeof(LIData), &Length);       
        if( bRet )
        {
        
           // Method 2
           Query.GetValuesForProp(m_szName, asNames);

           BOOL bGetAllInstances = asNames.GetSize() == 0;

           // Method 1
           if (Query.IsPropertyRequired(m_szTotalSessions))
               dwRequiredProperties |= BIT_TOTALSESSIONS;

           if (Query.IsPropertyRequired(m_szDisconnectedSessions))
               dwRequiredProperties |= BIT_DISCONNECTEDSESSIONS;
/*    
           if (Query.IsPropertyRequired(m_szEstimatedSessionCapacity))
               dwRequiredProperties |= BIT_ESTIMATEDSESSIONCAPACITY;

           if (Query.IsPropertyRequired(m_szResourceConstraint))
               dwRequiredProperties |= BIT_RESOURCECONSTRAINT;

           if (Query.IsPropertyRequired(m_szRawSessionCapacity))
               dwRequiredProperties |= BIT_RAWSESSIONCAPACITY;
*/

           CInstance* pInstance = CreateNewInstance(pMethodContext);

           if( pInstance != NULL)
           {                                                       
               
               pInstance->SetCHString(m_szName, chServerName);

               pInstance->SetCHString(m_szCaption, chServerName);

               hr = LoadPropertyValues( pInstance, dwRequiredProperties, LIData );

               if( SUCCEEDED( hr ) )
               {
                   hr = pInstance->Commit();
               }

               pInstance->Release();
           }
           else
           {
               ERR((TB, "Win32_TerminalService@GetObject@ExecQuery: CreateNewInstance failed"));
               hr = WBEM_E_OUT_OF_MEMORY;
           }
        }
    }
    else
    {
        
        TRC2((TB, "Win32_TerminalService@ExecQuery: WinStationQueryInformation GetLastError returned: 0x%x\n" , GetLastError()));
    }

   return hr;
   
}

//=---------------------


HRESULT CWin32_TerminalService::LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties, WINSTATIONLOADINDICATORDATA LIData)
{

    if( pInstance != NULL )
    {        
        
        if( dwRequiredProperties & BIT_TOTALSESSIONS )
        {
            pInstance->SetDWORD(m_szTotalSessions, LIData.TotalSessions);           
        }

        if( dwRequiredProperties & BIT_DISCONNECTEDSESSIONS )
        {
            pInstance->SetDWORD(m_szDisconnectedSessions, LIData.DisconnectedSessions);
        }
/*
        if( dwRequiredProperties & BIT_ESTIMATEDSESSIONCAPACITY )
        {
            pInstance->SetDWORD(m_szEstimatedSessionCapacity, LIData.RemainingSessionCapacity);
        }
        
        if( dwRequiredProperties & BIT_RESOURCECONSTRAINT )
        { 
            switch( LIData.LoadFactor )
            {
            case 0:                
                pInstance->SetCharSplat(m_szResourceConstraint, L"Error");
                break;
            case 1:
                pInstance->SetCharSplat(m_szResourceConstraint, L"PagedPool");
                break;
            case 2:
                pInstance->SetCharSplat(m_szResourceConstraint, L"NonPagedPool");
                break;
            case 3:
                pInstance->SetCharSplat(m_szResourceConstraint, L"Available Memory");
                break;
            case 4:
                pInstance->SetCharSplat(m_szResourceConstraint, L"System PTEs");
                break;           
            case 5:
                pInstance->SetCharSplat(m_szResourceConstraint, L"CPU");
                break;        
   
            default:
                pInstance->SetCharSplat(m_szResourceConstraint, L"Error");
                break;
            }
        }
        if( dwRequiredProperties & BIT_RAWSESSIONCAPACITY )
        {
            pInstance->SetDWORD(m_szRawSessionCapacity, LIData.RawSessionCapacity); 
        }
*/
    }

    return S_OK;
}


//=--------------

CWin32_TSSessionDirectory::CWin32_TSSessionDirectory (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{    
    if ( g_hInstance != NULL)
    {
        
        TRC2((TB, "CWin32_TSSessionDirectory_ctor"));

        _tcscpy(m_szMode, _T("TerminalServerMode"));

        _tcscpy(m_szSessionDirectoryActive, _T("SessionDirectoryActive"));

        _tcscpy(m_szSessionDirectoryLocation, _T("SessionDirectoryLocation"));

        _tcscpy(m_szSessionDirectoryClusterName, _T("SessionDirectoryClusterName"));

 //       _tcscpy(m_szSessionDirectoryAdditionalParams, _T("SessionDirectoryAdditionalParams"));

        _tcscpy(m_szSetSessionDirectoryProperty, _T("SetSessionDirectoryProperty"));

        _tcscpy(m_szSetSessionDirectoryActive, _T("SetSessionDirectoryActive"));

        _tcscpy(m_szPropertyName, _T("PropertyName"));

        _tcscpy(m_szValue, _T("Value"));

        _tcscpy(m_szSessionDirectoryExposeServerIP, _T("SessionDirectoryExposeServerIP"));

        _tcscpy(m_szSetSessionDirectoryExposeServerIP, _T("SetSessionDirectoryExposeServerIP"));

        _tcscpy(m_szSessionDirectoryIPAddress, _T("SessionDirectoryIPAddress"));

               
    }   
}

//=-------------

CWin32_TSSessionDirectory::~CWin32_TSSessionDirectory ()
{
 
}

HRESULT
GetNLBIP(LPWSTR * ppwszRetIP)
{
    HRESULT                hr               = S_OK;        
    IWbemLocator         * pWbemLocator     = NULL;
    IWbemServices        * pWbemServices    = NULL;
    IWbemClassObject     * pWbemObj         = NULL;
    IEnumWbemClassObject * pWbemEnum        = NULL;
    BSTR                   bstrServer       = NULL;
    BSTR                   bstrNode         = NULL;
    BSTR                   bstrNameProperty = NULL;
    ULONG                  uReturned;
    VARIANT                vtNLBNodeName; 
    size_t                 dwIPLength;


    // make sure an empty buffer is passed in
    if (*ppwszRetIP != NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
       
    // create an instance of the WMI Locator, need this to query WMI
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          reinterpret_cast<void**>(&pWbemLocator));
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // create a connection to WMI Namespace "root\\MicrosoftNLB";
    bstrServer = SysAllocString(L"root\\MicrosoftNLB");
    if (bstrServer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pWbemLocator->ConnectServer(bstrServer,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     &pWbemServices);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    hr = CoImpersonateClient();
    
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Set the proxy so that impersonation of the client occurs.
    hr = CoSetProxyBlanket(pWbemServices,
                           RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE,
                           NULL,
                           RPC_C_AUTHN_LEVEL_CALL,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           EOAC_DYNAMIC_CLOAKING);
    if (FAILED(hr))
    {
        goto Cleanup;
    }


    // get instance of MicrosoftNLB_NodeSetting, this is where we can get the 
    // IP Address for the Cluster IP through the "Name" property
    bstrNode = SysAllocString(L"MicrosoftNLB_NodeSetting");
    if (bstrNode == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pWbemServices->CreateInstanceEnum(bstrNode,
                                           WBEM_FLAG_RETURN_IMMEDIATELY,
                                           NULL,
                                           &pWbemEnum);
    if (FAILED(hr))
    {
        goto Cleanup;
    }


    // we only need to look at one instance to get the NLB IP Address
    hr = pWbemEnum->Next(WBEM_INFINITE, 
                         1,
                         &pWbemObj,
                         &uReturned);
    if (FAILED(hr))
    {
        // if NLB provider doesn't exist provider will fail to load
        // this is ok so we'll return S_OK in this case
        if (hr == WBEM_E_PROVIDER_LOAD_FAILURE || hr == WBEM_E_ACCESS_DENIED)
        {
            hr = S_OK;
            *ppwszRetIP = NULL;
        }

        goto Cleanup;
    }    

    // query the "Name" property which holds the IP address we want
    bstrNameProperty = SysAllocString(L"Name");
    if (bstrNameProperty == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pWbemObj->Get(bstrNameProperty,
                       0,
                       &vtNLBNodeName,
                       NULL,
                       NULL);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    
    // We should get a string back
    if (vtNLBNodeName.vt != VT_BSTR)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // allocate memory for the return string, *** CALLER MUST FREE THIS ***
    dwIPLength = wcslen(vtNLBNodeName.bstrVal) + 1;
    *ppwszRetIP = (LPWSTR)GlobalAlloc(GPTR, dwIPLength * sizeof(WCHAR));
    if (*ppwszRetIP == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Copy the string into our return buffer
    wcscpy(*ppwszRetIP, vtNLBNodeName.bstrVal);
    (*ppwszRetIP)[dwIPLength - 1] = L'\0';

Cleanup:

    if (pWbemLocator)
        pWbemLocator->Release();

    if (pWbemServices)
        pWbemServices->Release();

    if (pWbemEnum)
        pWbemEnum->Release();

    if (pWbemObj)
        pWbemObj->Release();
    
    if (bstrServer)
        SysFreeString(bstrServer);

    if (bstrNode)
        SysFreeString(bstrNode);

    if (bstrNameProperty)
        SysFreeString(bstrNameProperty);

    VariantClear(&vtNLBNodeName);

    return hr;
}

//=------------

HRESULT CWin32_TSSessionDirectory::DeleteInstance ( const CInstance &Instance,  long lFlags )
{    
    return WBEM_E_PROVIDER_NOT_CAPABLE;
}

//=-------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSSessionDirectory::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSSessionDirectory::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{    

    HRESULT hr = WBEM_E_INVALID_CLASS;
    OSVERSIONINFOEX OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;

	CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( GetVersionEx((OSVERSIONINFO*)&OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ))
        {
            return WBEM_E_INVALID_CLASS;
            
        }
        if(!(OsVersionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) && !( OsVersionInfo.wSuiteMask & VER_SUITE_DATACENTER))
        {
            return WBEM_E_INVALID_CLASS;
        }
    }

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );
        
        TRC2((TB, "Win32_TSSessionDirectory@EnumInst: GetTermSrvMode: dwMode ret 0x%x\n" , dwMode));

        if( ERROR_SUCCESS == dwStatus && dwMode == 1)
        {             
            CInstance* pInstance = CreateNewInstance(pMethodContext);

            if( pInstance != NULL )
            {
                TRC2((TB, "Win32_TSSessionDirectory@EnumerateInstances: CreateNewInstance succeeded"));         

                hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES);

                if( SUCCEEDED( hr ))
                {
                    hr = pInstance->Commit();
                }

                pInstance->Release( );
            }
        }
    }

	
    if( pSettings != NULL)
    {
        pSettings->Release();
    }
    
    return hr ;
}

//=-------------


HRESULT CWin32_TSSessionDirectory::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{    
    
    OSVERSIONINFOEX OsVersionInfo ;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    HRESULT hr = WBEM_E_INVALID_CLASS;

    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;
	ICfgComp *pCfgComp = NULL;

    if( GetVersionEx((OSVERSIONINFO*)&OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ) )
        {
            return WBEM_E_INVALID_CLASS;
            
        }
        if(!(OsVersionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) && !( OsVersionInfo.wSuiteMask & VER_SUITE_DATACENTER))
        {
            return WBEM_E_INVALID_CLASS;
        }
    } 

	CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );   

        if( ERROR_SUCCESS == dwStatus && dwMode == 1)
        {

            ULONGLONG dwRequiredProperties = 0;

            if (Query.IsPropertyRequired(m_szMode))
               dwRequiredProperties |= BIT_MODE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryActive))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYACTIVE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryLocation))
                dwRequiredProperties |= BIT_SESSIONDIRECTORY;

            if (Query.IsPropertyRequired(m_szSessionDirectoryClusterName))
                dwRequiredProperties |= BIT_CLUSTERNAME;

            if (Query.IsPropertyRequired(m_szSessionDirectoryExposeServerIP))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYEXPOSESERVERIP;

            if (Query.IsPropertyRequired(m_szSessionDirectoryIPAddress))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYIPADDRESS;
           /* 
            if (Query.IsPropertyRequired(m_szSessionDirectoryAdditionalParams))
                dwRequiredProperties |= BIT_ADDITIONALPARAMS;    
        */
            if( pInstance != NULL )
            {        
                hr  = LoadPropertyValues(pInstance, dwRequiredProperties);

                TRC2((TB, "Win32_TSSessionDirectory@GetObject: LoadPropertyValues ret 0x%x\n" , hr));   
            }
        }
    }

    if( pSettings != NULL)
    {
        pSettings->Release();
    }
        
    return hr;
}

//=-----------------

HRESULT CWin32_TSSessionDirectory::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    DWORD dwRequiredProperties = 0;
    CHStringArray asNames;
    CHString chSessionDirectory;
    HRESULT hr = WBEM_E_INVALID_CLASS;
    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;
	ICfgComp *pCfgComp = NULL;

    OSVERSIONINFOEX OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if( GetVersionEx((OSVERSIONINFO*)&OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ))
        {
            return WBEM_E_INVALID_CLASS;
            
        }
        if(!(OsVersionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) && !( OsVersionInfo.wSuiteMask & VER_SUITE_DATACENTER))
        {
            return WBEM_E_INVALID_CLASS;
        }
    }    

    CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );   

        if( ERROR_SUCCESS == dwStatus && dwMode == 1)
        {

           // Method 2
          //  Query.GetValuesForProp(m_szSessionDirectoryLocation, asNames);
            Query.GetValuesForProp(m_szMode, asNames);

            BOOL bGetAllInstances = asNames.GetSize() == 0;

           // Method 1

            if (Query.IsPropertyRequired(m_szMode))
               dwRequiredProperties |= BIT_MODE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryActive))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYACTIVE;

            if (Query.IsPropertyRequired(m_szSessionDirectoryLocation))
                dwRequiredProperties |= BIT_SESSIONDIRECTORY;

            if (Query.IsPropertyRequired(m_szSessionDirectoryClusterName))
                dwRequiredProperties |= BIT_CLUSTERNAME;

            if (Query.IsPropertyRequired(m_szSessionDirectoryExposeServerIP))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYEXPOSESERVERIP;

            if (Query.IsPropertyRequired(m_szSessionDirectoryIPAddress))
                dwRequiredProperties |= BIT_SESSIONDIRECTORYIPADDRESS;
           /* 
            if (Query.IsPropertyRequired(m_szSessionDirectoryAdditionalParams))
                dwRequiredProperties |= BIT_ADDITIONALPARAMS;                  
                  
        */
               // Method 2

            CInstance* pInstance = CreateNewInstance(pMethodContext);       

            if( pInstance != NULL)
            {
               
               pInstance->SetCHString(m_szSessionDirectoryLocation, chSessionDirectory );

               hr = LoadPropertyValues(pInstance, dwRequiredProperties);

               if( SUCCEEDED( hr ) )
               {
                   hr = pInstance->Commit();
               }

               pInstance->Release();
            }
            else
            {
                ERR((TB, "Win32_TSSessionDirectory@ExecQuery: CreateNewInstance failed"));                   

                hr = WBEM_E_OUT_OF_MEMORY;
            }
        }
    }

    if( pSettings != NULL )
    {
        pSettings->Release();
    }

    return hr;

}


//=--------------

BOOL CWin32_TSSessionDirectory::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for( DWORD x=0; x < dwSize; x++ )
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}

//=-------------

HRESULT CWin32_TSSessionDirectory::ExecMethod ( const CInstance& Inst,
                                                          const BSTR bstrMethodName,
                                                          CInstance *pInParams,
                                                          CInstance *pOutParams,
                                                          long lFlags)
                                                          
{
                 
    DWORD dwData = 0;
    CHString chData;
    HKEY hKey = NULL;
    LONG lRet = 0;
    bool bRet;
    bool bUpdate = FALSE;
    DWORD dwSize = sizeof (DWORD);
    TCHAR szName[ SESSDIR_LENGTH ];
    ISettingsComp* pSettings = NULL;
    DWORD dwStatus = 0;
    DWORD dwMode = 0;
    HRESULT hr = WBEM_E_INVALID_CLASS;
    ICfgComp *pCfgComp = NULL;
    CHString chSessDirName;
    DWORD cbName;
    
    OSVERSIONINFOEX OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

      

    CStackClass StackObj;

	if(StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInParams == NULL )
    {
        ERR((TB, "TSSessionDirectory@ExecQuery: invalid interface"));

        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }

    hr = StackObj.m_pCfgComp->QueryInterface( IID_ISettingsComp , ( PVOID * )&pSettings ) ;

    if( SUCCEEDED( hr ) && pSettings != NULL )
    {
        pSettings->GetTermSrvMode(&dwMode , &dwStatus );   

        if( ERROR_SUCCESS == dwStatus && dwMode == 0)
        {
            return WBEM_E_INVALID_CLASS;
        }
    }

    if( GetVersionEx((OSVERSIONINFO*) &OsVersionInfo) )
    {
        if( ( OsVersionInfo.dwMajorVersion < 5 ) || ( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion < 1 ))
        {
            return WBEM_E_INVALID_CLASS;
            
        }
        if(!(OsVersionInfo.wSuiteMask & VER_SUITE_ENTERPRISE) && !( OsVersionInfo.wSuiteMask & VER_SUITE_DATACENTER))
        {
            return WBEM_E_INVALID_CLASS;
        }
    }  
   
    /*
    
    Inst.GetCHString(m_szSessionDirectoryLocation, chSessDirName);
    
    if( chSessDirName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chSessDirName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    */    
    
    do
    {
    
        // Sets one of the properties: SessionDirectoryLocation or SessionDirectoryClusterName 

        // uint32 SetSessionDirectoryProperty([In] string PropertyName, string Value);
    
        if( _wcsicmp(bstrMethodName, m_szSetSessionDirectoryProperty) == 0 )
        {
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 REG_TS_CLUSTERSETTINGS ,
                                 0,
                                 KEY_READ | KEY_WRITE,
                                 &hKey );

            if( ERROR_SUCCESS != lRet )
            { 
                ERR((TB, "TSSessionDirectory@ExecQuery: RegOpenKeyEx failed"));

                hr = WBEM_E_INITIALIZATION_FAILURE;

                break;
            }
            
            pInParams->GetCHString (m_szPropertyName, chData);

            if( chData.CompareNoCase (m_szSessionDirectoryLocation) == 0 )
            {        
                RegGetMachinePolicy(&m_gpPolicy);

                chData.Empty();
                         
                bRet = pInParams->GetCHString(m_szValue, chData );

                if( ( m_gpPolicy.fPolicySessionDirectoryLocation == 0) && bRet )
                {     

                    if( chData.IsEmpty() )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
            
                        break;
                    }

                    if( chData.GetLength() > SESSDIR_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                        break;
                    }

                    lstrcpy(szName, chData);
                    cbName = (lstrlen(szName)+ 1) * sizeof(TCHAR);
                        
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_CLUSTER_STORESERVERNAME,
                                            NULL ,
                                            REG_SZ,
                                            ( CONST LPBYTE )szName ,
                                            cbName );      

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectory returned 0x%x" , lRet));   

                    
                    if( lRet == ERROR_SUCCESS )
                    {
                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.Empty();
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
                
            }
            else if( chData.CompareNoCase(m_szSessionDirectoryClusterName) == 0 )
            {
                       
                RegGetMachinePolicy(&m_gpPolicy);

                chData.Empty();
                     
                bRet = pInParams->GetCHString(m_szValue, chData );

                if( ( m_gpPolicy.fPolicySessionDirectoryClusterName == 0) && bRet )
                {                         
                    if( chData.GetLength() > SESSDIR_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
        
                        break;
                    }

                    lstrcpy(szName, chData);
                    cbName = (lstrlen(szName)+ 1) * sizeof(TCHAR);
                    
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_CLUSTER_CLUSTERNAME,
                                            NULL ,
                                            REG_SZ,
                                            ( CONST LPBYTE )szName ,
                                            cbName );      

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectory returned 0x%x" , lRet));                       

                    if( lRet == ERROR_SUCCESS )
                    {
                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }

                    chData.Empty();                        
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
            } 
            else
            {
                hr = WBEM_E_INVALID_METHOD;

                break;
            } 

        }

        // Enables / Disables participation of a server in Session Directory

        // uint32 SetSessionDirectoryActive([In] uint32 Value);

        else if( _wcsicmp(bstrMethodName, m_szSetSessionDirectoryActive) == 0 )
        {
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

            if( ERROR_SUCCESS == lRet )
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                bRet = pInParams->GetDWORD( m_szSessionDirectoryActive, dwData );
                
                if( (m_gpPolicy.fPolicySessionDirectoryActive == 0) && bRet )
                {

                    if( dwData != 0 && dwData != 1 )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                
                        break;
                    }
                     
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_SESSDIRACTIVE,
                                            0 ,
                                            REG_DWORD,
                                            ( LPBYTE )&dwData ,
                                            dwSize );                   

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectoryActive returned 0x%x" , lRet)); 
                
                    if( ERROR_SUCCESS == lRet )
                    {                      

                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                        
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_METHOD;
                }
            }
        }

        // Enables / Disables exposing the IP Address of Session Directory Server

        // uint32 SetSessionDirectoryExposeServerIP([In] uint32 Value);

        else if( _wcsicmp(bstrMethodName, m_szSetSessionDirectoryExposeServerIP) == 0 )
        {
            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

            if( ERROR_SUCCESS == lRet )
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                bRet = pInParams->GetDWORD( m_szSessionDirectoryExposeServerIP, dwData );
                
                //todo: change the policy to IP
                if( (m_gpPolicy.fPolicySessionDirectoryExposeServerIP == 0) && bRet )
                {

                    if( dwData != 0 && dwData != 1 )
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                
                        break;
                    }
                     
                    lRet = RegSetValueEx( hKey ,
                                            REG_TS_SESSDIR_EXPOSE_SERVER_ADDR,
                                            0 ,
                                            REG_DWORD,
                                            ( LPBYTE )&dwData ,
                                            dwSize );                   

                    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectoryExposeServerIP returned 0x%x" , lRet)); 
                
                    if( ERROR_SUCCESS == lRet )
                    {                      

                        bUpdate = TRUE;

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                        
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_METHOD;
                }
            }
        }               

    }while(0);

    if( bUpdate )
    {
        StackObj.m_pCfgComp->UpdateSessionDirectory(&dwStatus);
    }

    if( hKey != NULL )
    {
        RegCloseKey( hKey );
    }

        
    if( pSettings != NULL )
    {
        pSettings->Release();
    }

    return hr;
}


//=-------------

HRESULT CWin32_TSSessionDirectory::LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties)
{         
    LONG lRet = 0;    
    DWORD dwData = 0;
    DWORD dwSize = 0;
    HKEY hKey = NULL;
    WCHAR tchData[ OPAQUESETTINGS_LENGTH +1] ={0};
    TCHAR tchData1[ OPAQUESETTINGS_LENGTH +1] = {0} ;
    dwSize = sizeof( DWORD );
    
    
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ,
                         &hKey );

    if( ERROR_SUCCESS == lRet && hKey != NULL)
    {
        if( dwRequiredProperties & BIT_SESSIONDIRECTORYACTIVE )
        {  
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySessionDirectoryActive != 0 )
            {
                dwData = m_gpPolicy.SessionDirectoryActive;
            }
            else
            {
                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_SESSDIRACTIVE,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)&dwData ,
                                        &dwSize );
            }
   
            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: SessionDirectoryActive returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetDWORD(m_szSessionDirectoryActive, dwData);
            }
        }

        if( dwRequiredProperties & BIT_SESSIONDIRECTORYEXPOSESERVERIP )
        {  
            RegGetMachinePolicy(&m_gpPolicy);
            
            if( m_gpPolicy.fPolicySessionDirectoryExposeServerIP != 0 )
            {
                dwData = m_gpPolicy.SessionDirectoryExposeServerIP;
            }
            else
            {
                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_SESSDIR_EXPOSE_SERVER_ADDR,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)&dwData ,
                                        &dwSize );
            }
   
            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: SessionDirectoryExposeServerIP returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetDWORD(m_szSessionDirectoryExposeServerIP, dwData);
            }
        }               

        RegCloseKey (hKey);
    }

    
    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                 REG_TS_CLUSTERSETTINGS ,
                                 0,
                                 KEY_READ,
                                 &hKey );
    

    if( ERROR_SUCCESS == lRet  && hKey != NULL)
    {

        if( dwRequiredProperties & BIT_SESSIONDIRECTORY )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySessionDirectoryLocation != 0 )
            {
                lstrcpy(tchData, m_gpPolicy.SessionDirectoryLocation);
            }
            else
            {
         
                dwSize = sizeof( tchData );
            
                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_CLUSTER_STORESERVERNAME,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)tchData ,
                                        &dwSize );
            }
    
            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: SessionDirectoryLocation returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetCHString(m_szSessionDirectoryLocation, tchData);
            }
        }

        if( dwRequiredProperties & BIT_CLUSTERNAME )
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicySessionDirectoryClusterName != 0 )
            {
                lstrcpy( tchData, m_gpPolicy.SessionDirectoryClusterName );
            }
            else
            {
                dwSize = sizeof( tchData );

                lRet = RegQueryValueEx( hKey ,
                                        REG_TS_CLUSTER_CLUSTERNAME,
                                        NULL ,
                                        NULL ,
                                        (LPBYTE)tchData ,
                                        &dwSize );
            }

            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: ClusterName returned 0x%x" , lRet));   

            if( ERROR_SUCCESS == lRet )
            {
                pInstance->SetCHString(m_szSessionDirectoryClusterName, tchData);            
            }
        }

        if( dwRequiredProperties & BIT_SESSIONDIRECTORYIPADDRESS )
        {              
            dwSize = sizeof( tchData1 );

            lRet = RegQueryValueEx( hKey ,
                                    REG_TS_CLUSTER_REDIRECTIONIP,
                                    NULL ,
                                    NULL ,
                                    (LPBYTE)tchData1 ,
                                    &dwSize );
        

            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues:Session Directory IP Address returned 0x%x" , lRet));   

            if( ERROR_SUCCESS == lRet )
            {
                pInstance->SetCHString(m_szSessionDirectoryIPAddress, tchData1);            
            }
        }

/*
        if( dwRequiredProperties & BIT_ADDITIONALPARAMS )
        {

            dwSize = sizeof( tchData );
            
            lRet = RegQueryValueEx( hKey ,
                                    REG_TS_CLUSTER_OPAQUESETTINGS,
                                    NULL ,
                                    NULL ,
                                    (LPBYTE)&tchData ,
                                    &dwSize );
            

            TRC2((TB, "Win32_TSSessionDirectory@LoadPropertyValues: AdditionalParams returned 0x%x" , lRet));

            if( ERROR_SUCCESS == lRet )
            {            
                pInstance->SetCHString(m_szSessionDirectoryAdditionalParams, (LPTSTR)(LPCTSTR)&tchData);
            }            
        }
        */

        RegCloseKey( hKey );        
    }    
    
    return S_OK;
}

//=-------------------


HRESULT CWin32_TSSessionDirectory::PutInstance ( const CInstance &Instance, long lFlags)
{   
    LONG hr = 0;               
    DWORD dwData;
    CHString chData;
    HKEY hKey = NULL;
    LONG lRet;
    DWORD dwSize = sizeof (DWORD);
    TCHAR szName[ SESSDIR_LENGTH ];
    DWORD cbName;
    DWORD dwStatus;
    ULONG ulTerminals = 0, ulAdapters = 0;
    ULONG ulSize = 0, ulNum =0;
    PWS pWS= NULL;
    PWS pWSList= NULL;
    PGUIDTBL pGuidtbl = NULL;
    TCHAR tchGuid[ GUID_LENGTH ];
        
    hr = WBEM_S_NO_ERROR;

    CHString chAddress;
    DWORD Err = 0;
    TCHAR tchAdd[MAX_PATH]=L"";                     
    TCHAR tchAdapterName[MAX_PATH]=L"";
    DWORD AdapterInfoSize;
    PIP_ADDR_STRING pAddrStr;
    PIP_ADAPTER_INFO pAdapterInfo = NULL, pAdapt = NULL;
    LPWSTR           pwszNLBipAddress         = NULL;

    ICfgComp *pCfgComp = NULL;
    
    CStackClass StackObj;

    if(StackObj.m_pCfgComp == NULL)
    {
        return WBEM_E_ILLEGAL_NULL;
    }          

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_CONTROL_TSERVER ,
                         0,
                         KEY_READ,
                         &hKey );

    if( ERROR_SUCCESS != lRet || hKey == NULL)
    {
        return WBEM_E_INVALID_OPERATION;
    }

    RegGetMachinePolicy(&m_gpPolicy);

    if( m_gpPolicy.fPolicySessionDirectoryActive != 0 )
    {
        dwData = m_gpPolicy.SessionDirectoryActive;
    }
    else
    {
        lRet = RegQueryValueEx( hKey ,
                                REG_TS_SESSDIRACTIVE,
                                NULL ,
                                NULL ,
                                (LPBYTE)&dwData ,
                                &dwSize );
    }

    TRC2((TB, "Win32_TSSessionDirectory@PutInstance: RegQuery for SessionDirectoryActive returned 0x%x" , lRet));

    if(hKey)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    if( dwData == 0 )
    {                 
        return WBEM_E_INVALID_OPERATION;    
    }    
    
    Instance.GetCHString(m_szSessionDirectoryIPAddress, chAddress);
        

    lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                         REG_TS_CLUSTERSETTINGS ,
                         0,
                         KEY_READ | KEY_WRITE,
                         &hKey );

    if( ERROR_SUCCESS != lRet )
    { 
        ERR((TB, "TSSessionDirectory@PutInstance: RegOpenKeyEx failed"));

        return WBEM_E_INVALID_OPERATION;
    }

    hr = GetNLBIP(&pwszNLBipAddress);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if( !_tcsicmp(chAddress, _TEXT("0.0.0.0")))
    {
        hr = WBEM_E_INVALID_PARAMETER;
        goto Cleanup;
    } 

    //
    // Enumerate all of the adapter specific information using the IP_ADAPTER_INFO structure.
    // Note:  IP_ADAPTER_INFO contains a linked list of adapter entries.
    //
    AdapterInfoSize = 0;
    GetAdaptersInfo(NULL, &AdapterInfoSize);

    if(AdapterInfoSize == 0)
    {               
        return WBEM_E_OUT_OF_MEMORY;                
    }


    if( chAddress.GetLength() > GUID_LENGTH )
    {
        hr = WBEM_E_INVALID_PARAMETER;
    
        goto Cleanup;
    }

    // Allocate memory from sizing information
    if ((pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, AdapterInfoSize)) == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;   
    }
    // Get actual adapter information
    if ((Err = GetAdaptersInfo(pAdapterInfo, &AdapterInfoSize)) != 0)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    
        goto Cleanup;
    }    

    BOOL bAllAdapters = FALSE;

    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWSList);
                
    if( SUCCEEDED( hr ) && pWSList != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals ; ulNum++ )
        {  
            if( pWSList[ulNum].LanAdapter == 0 )
            {
                bAllAdapters = TRUE;
                
            }
        }
    }     

    pAdapt = pAdapterInfo;


    for (; pAdapt ; pAdapt = pAdapt->Next)
    {
        pAddrStr = &(pAdapt->IpAddressList);
        while(pAddrStr)
        {                    
            MultiByteToWideChar(GetACP(), 0, pAddrStr->IpAddress.String, -1, tchAdd, MAX_PATH);

            MultiByteToWideChar(GetACP(), 0, pAdapt->AdapterName, -1, tchAdapterName, MAX_PATH);             
     
            if( !_tcsicmp(chAddress, tchAdd))
            {   
                if(pwszNLBipAddress && (_tcsstr(pwszNLBipAddress, tchAdd)!= NULL))
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    goto Cleanup;
                }
                goto Label;                
            }

            pAddrStr = pAddrStr->Next;
        }

    }

    hr = WBEM_E_INVALID_PARAMETER;
    goto Cleanup;

Label:

    if(bAllAdapters == TRUE)
    {
        goto Found;
    }     
            
    if( SUCCEEDED( hr ) && pWSList != NULL)
    {
        for( ulNum = 0; ulNum < ulTerminals ; ulNum++ )
        {  
            if(_tcsicmp(pWSList[ulNum].pdName, L"Console"))
                break;
        }

        hr = StackObj.m_pCfgComp->GetLanAdapterList2(pWSList[ulNum].pdName, &ulAdapters , &pGuidtbl );
        
        if( SUCCEEDED( hr ) && pGuidtbl != NULL)
        {                     
            StringFromGUID2( ( pGuidtbl )[ pWSList[ulNum].LanAdapter ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );                                            
            
            if( _tcsicmp( tchGuid, tchAdapterName ) == 0 )
            {
                goto Found;  
            }
        }
    }

    hr = WBEM_E_INVALID_PARAMETER;
    goto Cleanup;

Found:

    lstrcpy(szName, chAddress);
    cbName = (lstrlen(szName)+ 1) * sizeof(TCHAR);
    
    lRet = RegSetValueEx( hKey ,
                            REG_TS_CLUSTER_REDIRECTIONIP,
                            NULL ,
                            REG_SZ,
                            ( CONST LPBYTE )szName ,
                            cbName );      

    TRC2((TB, "Win32_TSSessionDirectory@ExecMethod: SessionDirectory returned 0x%x" , lRet));    

    if(lRet == ERROR_SUCCESS)
    {
        StackObj.m_pCfgComp->UpdateSessionDirectory(&dwStatus);
    }

Cleanup:

    if (pwszNLBipAddress)
        GlobalFree(pwszNLBipAddress);

    if(pAdapterInfo)
    {
        GlobalFree(pAdapterInfo);
    }

    return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSRT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSRT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSRT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSRT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\terminal.h ===
/******************************************************************
   Copyright (C) 2000 Microsoft Corp.

   Terminal.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _TerminalWinstation_H_
#define _TerminalWinstation_H_
#include "resource.h"
#include <winsta.h>
#include <regapi.h>
#include <utilsub.h>
#include <allproc.h>
#include "trace.h"


#define PROVIDER_NAME_Win32_WIN32_TERMINALSERVICESETTING_Prov L"Win32_TerminalServiceSetting"
#define PROVIDER_NAME_Win32_WIN32_TSPROVIDER_Prov L"Win32_TSProvider"
#define PROVIDER_NAME_Win32_WIN32_TERMINALSERVICE_Prov L"Win32_TerminalService"
#define PROVIDER_NAME_Win32_WIN32_TSSESSIONDIRECTORY_Prov L"Win32_TSSessionDirectory"



#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

extern BOOL g_bInitialized;

// See ExecQuery for details of the usage of these #defines
#define BIT_MODE                            0x00000001
#define BIT_LICENSING                       0x00000002
#define BIT_ACTIVEDESKTOP                   0x00000004
#define BIT_USERPERM                        0x00000008
#define BIT_DELETETEMPDIRS                  0x00000010
#define BIT_PERSESSIONTEMPDIR               0x00000020
#define BIT_LOGONS                          0x00000040
#define BIT_TOTALSESSIONS                   0x00000080
#define BIT_DISCONNECTEDSESSIONS            0x00000100
#define BIT_ESTIMATEDSESSIONCAPACITY        0x00000200
#define BIT_RESOURCECONSTRAINT              0x00000400
#define BIT_RAWSESSIONCAPACITY              0x00000800
#define BIT_SESSIONDIRECTORY                0x00001000
#define BIT_CLUSTERNAME                     0x00002000
#define BIT_HELP                            0x00004000
#define BIT_ADDITIONALPARAMS                0x00008000
#define BIT_SESSIONDIRECTORYACTIVE          0x00010000
#define BIT_ALLOWTSCONNECTIONS              0x00020000
#define BIT_SINGLESESSION                   0x00040000
#define BIT_PROFILEPATH                     0x00080000
#define BIT_HOMEDIRECTORY                   0x00100000
#define BIT_SESSIONDIRECTORYEXPOSESERVERIP  0x00200000
#define BIT_DIRECTCONNECTLICENSESERVERS     0x00400000
#define BIT_SERVERNAME                      0x00800000
#define BIT_TIMEZONEREDIRECTION             0x01000000
#define BIT_SESSIONDIRECTORYIPADDRESS       0x02000000
#define BIT_DISABLEFORCIBLELOGOFF           0x04000000

#define BIT_ALL_PROPERTIES 0xffffffff

#define SESSDIR_LENGTH 64
#define OPAQUESETTINGS_LENGTH 256 

// Property name externs -- defined in Terminal.cpp
//=================================================

//=--------------------------


class CStackClass
{
    public:
        // Constructor/destructor
        //=======================

        CStackClass();
        virtual ~CStackClass();
        IClassFactory *m_pCfg;
        ICfgComp *m_pCfgComp;
		

    protected:
        // Reading Functions
        //============================
        

        // Writing Functions    
        //============================
       

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.  
		
   
        
} ;

//=----------



class CWin32_TerminalService : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_TerminalService( LPCWSTR lpwszName, LPCWSTR lpwszNameSpace );
        virtual ~CWin32_TerminalService();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance *pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
       

        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties, WINSTATIONLOADINDICATORDATA LIData);
    

    private:
        // All data members for CTerminalWinstation should be included here.  
        
      
        TCHAR m_szTotalSessions[ 64 ];
        TCHAR m_szDisconnectedSessions[ 64 ];
        TCHAR m_szEstimatedSessionCapacity[ 64 ];
        TCHAR m_szResourceConstraint[ 64 ];
        TCHAR m_szRawSessionCapacity[ 64 ];
        TCHAR m_szName[ 64 ];
        TCHAR m_szCaption[ 64 ];
       
        
} ;



//=---------


class CWin32_TerminalServiceSetting : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_TerminalServiceSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_TerminalServiceSetting();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod(const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.  
    //    BOOL m_bInitialized;

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

        ISettingsComp *m_pSettings;
        POLICY_TS_MACHINE m_gpPolicy;
        TCHAR m_szServerName[ 64 ];
        TCHAR m_szMode[ 64 ];
        TCHAR m_szLicensingName[ 64 ];
        TCHAR m_szLicensingDescription[ 512 ];
        TCHAR m_szActiveDesktop[ 64 ];
        TCHAR m_szUserPerm[ 64 ];
        TCHAR m_szDeleteTempFolders[ 64 ];
        TCHAR m_szUseTempFolders[ 64 ];
        TCHAR m_szLogons[ 64 ];
        TCHAR m_szHelp[ 64 ];
        TCHAR m_szPropertyName[ 64 ];
        TCHAR m_szValue[ 64 ];
        TCHAR m_szChangeMode[ 64 ];
        TCHAR m_szSetPolicyPropertyName[ 64 ];
        TCHAR m_szLicensingType[ 64 ];
        TCHAR m_szAllowTSConnections[ 64 ];
        TCHAR m_szSetAllowTSConnections[ 64 ];
        TCHAR m_szSingleSession[ 64 ];
        TCHAR m_szSetSingleSession[ 64 ];
        TCHAR m_szProfilePath[ 64 ];
        TCHAR m_szHomeDirectory[ 64 ];
        TCHAR m_szDisableForcibleLogoff[ 64 ];
        TCHAR m_szSetProfilePath[ 64 ];
        TCHAR m_szSetHomeDirectory[ 64 ];
        TCHAR m_szAddDirectConnectLicenseServer[ 64 ];
        TCHAR m_szDeleteDirectConnectLicenseServer[ 64 ];
        TCHAR m_szLicenseServerName[ 64 ];
        TCHAR m_szDirectConnectLicenseServers[ 64 ];
        TCHAR m_szTimeZoneRedirection[ 64 ];
        TCHAR m_szSetTimeZoneRedirection[ 64 ]; 
        TCHAR m_szSetDisableForcibleLogoff[ 64 ];
} ;


//=---------


class CWin32_TSSessionDirectory : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_TSSessionDirectory(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_TSSessionDirectory();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        virtual HRESULT ExecMethod(const CInstance& Instance,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags = 0L );

        HRESULT LoadPropertyValues( CInstance *pInstance, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.  
    //    BOOL m_bInitialized;

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

   //     ADOConnection *m_pConnection;
        POLICY_TS_MACHINE m_gpPolicy;
        TCHAR m_szMode[ 64 ];
        TCHAR m_szSessionDirectoryActive[ 64 ];
        TCHAR m_szSessionDirectoryLocation[ 64 ];
        TCHAR m_szSessionDirectoryClusterName[ 64 ];
        TCHAR m_szSessionDirectoryExposeServerIP[ 64 ];
        TCHAR m_szSessionDirectoryIPAddress[ 64 ];
//        TCHAR m_szSessionDirectoryAdditionalParams[ 64 ];
        TCHAR m_szSetSessionDirectoryProperty[ 64 ];
        TCHAR m_szSetSessionDirectoryActive[ 64 ];
        TCHAR m_szSetSessionDirectoryExposeServerIP[ 64 ];
        TCHAR m_szPropertyName[ 64 ];
        TCHAR m_szValue[ 64 ];
        
} ;




//-----------------------Changed--------------------------

// struct to hold instance information


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\winstation.cpp ===
/******************************************************************
Copyright (C) 2000 Microsoft Corp.

  Terms.CPP -- WMI provider class implementation
  
    Generated by Microsoft WMI Code Generation Engine
    
      TO DO: - See individual function headers
      - When linking, make sure you link to framedyd.lib & 
      msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).
      
        Description: 
        
          
            
******************************************************************/
#include "stdafx.h"
#include <fwcommon.h>  // This must be the first include.
#include "Winstation.h"
#include "registry.h"
#include "winsta.h"
#include "resource.h"
#include <regapi.h>
#include <sddl.h>
#include <provider.h>
#include <Iphlpapi.h>

#define ARRAYSIZE( rg ) sizeof( rg ) / sizeof( rg[0] )
#define GUID_LENGTH 40
TCHAR tchErrorMessage[ 80 ] = {0};

const static WCHAR* pErrorClass = L"\\\\.\\root\\cimv2:TerminalError";

#define TS_PATH_WINSTATION TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Winstations\\")

//=--------------------

DWORD
GetUserSid(LPCTSTR pwszAccountName, 
           LPCTSTR pwszServerName, 
           PSID* ppUserSid)
{
    DWORD        cbSid     = 0;
    DWORD        cbDomain  = 0;
    PSID         pSID      = NULL;
    LPTSTR       pszDomain = NULL;
    BOOL         bStatus;
    DWORD        dwStatus  = ERROR_SUCCESS;    
    SID_NAME_USE seUse;   

    bStatus = LookupAccountName(pwszServerName,
                                pwszAccountName,
                                NULL,
                                &cbSid,
                                NULL,
                                &cbDomain,
                                &seUse);
    if(!bStatus)
    {
        dwStatus = GetLastError();
        if(dwStatus != ERROR_INSUFFICIENT_BUFFER)
        {
            goto Cleanup;
        }
    }

    dwStatus = ERROR_SUCCESS;

    pSID = (PSID)LocalAlloc(LMEM_FIXED, cbSid );
    pszDomain = (LPTSTR)LocalAlloc(LMEM_FIXED, sizeof(TCHAR) * (cbDomain + 1));

    if(pSID == NULL || pszDomain == NULL)
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    bStatus = LookupAccountName(pwszServerName,
                                pwszAccountName,
                                pSID,
                                &cbSid,
                                pszDomain,
                                &cbDomain,
                                &seUse);

    if(!bStatus)
    {
        dwStatus = GetLastError();
        goto Cleanup;
    }

    *ppUserSid = pSID;
    pSID = NULL;


Cleanup:
    if(pszDomain != NULL)
    {
        LocalFree(pszDomain);
    }

    if(pSID != NULL)
    {
        LocalFree(pSID);
    }

    return dwStatus;
} 


/*****************************************************************************
*
*  FUNCTION    :   CWin32_Terminal::CWin32_Terminal
*
*  DESCRIPTION :   Constructor
*
*  INPUTS      :   none
*
*  RETURNS     :   nothing
*
*  COMMENTS    :   Calls the Provider constructor.
*
*****************************************************************************/
CWin32_Terminal::CWin32_Terminal (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
    int retval = 1;

    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_Terminal_ctor"));

        _tcscpy(m_szEnableTerminal, _T("fEnableTerminal"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szNewTerminalName, _T("NewTerminalName"));

        _tcscpy(m_szEnable, _T("Enable"));

        _tcscpy(m_szRename, _T("Rename"));

        _tcscpy(m_szDelete, _T("Delete"));
        
    }
}


//==================
/*****************************************************************************
*
*  FUNCTION    :   CWin32_Terminal::~CWin32_Terminal
*  DESCRIPTION :   Destructor
*  INPUTS      :   none
*  RETURNS     :   nothing
*****************************************************************************/

CWin32_Terminal::~CWin32_Terminal ()
{
    
}


//==================
/*****************************************************************************
*
*  FUNCTION    :    CWin32_Terminal::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/



HRESULT CWin32_Terminal::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;    	
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

	hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        

	TRC2((TB,"Terminal@EnumerateInstances: GetWinstationList ret 0x%x" , hr )); 	
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;

            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"Terminal@EnumerateInstances: CreateNewInstance failed"));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }              
            
            hr = LoadPropertyValues( pInstance, BIT_ALL_PROPERTIES, &pWS[ ulNum ] );
            
            if (SUCCEEDED( hr ) ) 
            {
                hr = pInstance->Commit();       
            }            
            pInstance->Release( );
        }
    }

    if( pWS != NULL)
    {
        CoTaskMemFree(pWS);
    }
    
    return hr;
}


//=--------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_Terminal::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_Terminal::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;   
    LONG lSize;
    ULONGLONG ulRequiredProperties = 0;
    PWS  pWS = NULL;
    CHString chTermName;

    TRC2((TB,"TSCFGWMI!CWin32_Terminal_GetObject"));
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"Terminal@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szEnableTerminal))
        ulRequiredProperties |= BIT_FENABLETERMINAL;

    hr = StackObj.m_pCfgComp->GetWSInfo( ( LPTSTR )( LPCTSTR )chTermName, &lSize, &pWS);
    
    if( SUCCEEDED (hr) && pWS != NULL )        
    {
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS);        
    }
    else
    {
        hr = WBEM_E_INVALID_OBJECT;
    }
    

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }    

    return hr ;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_Terminal::ExecQuery
*
*  DESCRIPTION :    You are passed a method context to use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*                  There are two different ways query processing
*                  can be used to improve performance.  
* 
* Method 1 - Returns data for only those fields that were requested.  This can  
*            optimize performance if some properties are very expensive to retrieve.  
*
* Method 2 - Returns only the requested records in the "Where" clause. There is a method
*            that can be run against the CFrameworkQuery object where you pass it the name
*            of a property, and it will tell you all the values they requested.  For example,  
*            if the query is of the form 
*            'Select * from Win32_Terminal where TerminalName = "RDP-Tcp" or TerminalName = "ICA-Tcp"',
*            GetValuesForProp(L"TerminalName") sends back an array that contains {"RDP-Tcp", "ICA-Tcp"}.  
*            Or if the query was of the form 
*            'Select * from Win32_Terminal where TerminalName = "RDP-Tcp" AND fEnableTerminal = TRUE' 
*            (note that this query, unlike the one in the paragraph above, uses AND), then 
*            GetValuesForProp(L"TerminalName") will return {"RDP-Tcp"}.
*
*****************************************************************************/
HRESULT CWin32_Terminal::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{    
   
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szEnableTerminal))
        ulRequiredProperties |= BIT_FENABLETERMINAL;
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
	
    
	hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        { 
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
            {				
                continue;
            }
            
            // Method 2 - Check if the query CAN be processed by 'name'. If yes, return only those names.
            
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {                
                CInstance* pInstance = CreateNewInstance(pMethodContext); 
                
                if( pInstance != NULL)
                {            
                    pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                    hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
            
                    if( SUCCEEDED( hr ) )
                    {
                        hr = pInstance->Commit();
                    }                
                    pInstance->Release();
                }
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    
    return hr;
    
}


//=-----------

BOOL CWin32_Terminal::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    : CWin32_Terminal::PutInstance
*
*  DESCRIPTION :   
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    : TO DO: If you don't intend to support writing to your provider, 
*                       or are creating a 'method only' provider, remove this 
*                       method.
*
*****************************************************************************/
HRESULT CWin32_Terminal::PutInstance ( const CInstance &Instance, long lFlags)
{

    /*
    HRESULT hr = WBEM_S_NO_ERROR; 
    DWORD dwfEnable = 0;
    CHString chTermName; 
    ULONG ulTerminals = 0;
    ULONG ulSize = 0;
    ULONG ulNum = 0;
    PWS pWS = NULL;

    static USERCONFIG g_uc;

    static ASYNCCONFIG g_ac;
    
    if( g_pCfgComp == NULL ) 
    {
        ERR((TB,"Terminal@PutInstance: invalid interface" ));
        
        return WBEM_E_INITIALIZATION_FAILURE;
    }
    
    Instance.GetDWORD(m_szEnableTerminal, dwfEnable);
    
    if ( dwfEnable != 0 && dwfEnable !=1 )
    {
        return WBEM_E_INVALID_PARAMETER;
    }
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    hr = g_pCfgComp->ForceUpdate();
    

    if( SUCCEEDED( hr ))
    {        
        hr = g_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    }  
    
    do
    {        
        if( SUCCEEDED( hr ) && pWS != NULL )
        {           
            for ( ulNum = 0; ulNum < ulTerminals ; ulNum++)
            {               
                if( _tcsicmp( (LPCTSTR) &pWS[ulNum].Name, (LPTSTR)(LPCTSTR) chTermName) == 0)
                {
                    hr = g_pCfgComp->EnableWinstation( (LPTSTR) (LPCTSTR) chTermName,  dwfEnable);
                    break;
                }
            }

            if( ulNum >= ulTerminals )
            {
                ULONG ulSize = 0;

                lstrcpy( pWS->Name, (LPTSTR)(LPCTSTR)chTermName);
                pWS->fEnableWinstation = 1;
                pWS->uMaxInstanceCount = 0xffffffff;
                lstrcpy( pWS->Comment, L"");
                lstrcpy( pWS->pdName, L"tcp");
                lstrcpy( pWS->wdName, L"Microsoft RDP 5.1");
                pWS->PdClass = 2;
                pWS->LanAdapter = 0;
        
    
                RegDefaultUserConfigQuery( NULL ,
                    &g_uc,
                    sizeof( USERCONFIG ) ,
                    &ulSize );

                hr = g_pCfgComp->CreateNewWS( *pWS, sizeof( USERCONFIG ) , &g_uc, NULL);            
                TRC2((TB,"Terminal@PutInstance: CreateNewWS returned 0x%x\n", hr));
            }
        }       
        if( FAILED( hr ) )
        {
            CHString sRelPath;
        
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
        
            CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance);
        
            if( pErrorInstance != NULL )
            {
                LoadString( g_hInstance , IDS_ERR_PUTTERMINAL, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
            
                LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
            
                pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TERMINAL_Prov);
                pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
            
                pErrorInstance->SetCHString(L"TerminalName", chTermName );
            
                IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
            
                MethodContext *pMethodContext = Instance.GetMethodContext(); 
            
                if( pObj != NULL )
                {
                    if (pMethodContext != NULL)
                    {
                        pMethodContext->SetStatusObject(pObj);
                    }
                
                
                    pObj->Release();
                }
                pErrorInstance->Release();
            }
        }
    }while (0);

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }
   
    return hr;
    */
    return WBEM_E_PROVIDER_NOT_CAPABLE;

    
}

//=----------------------------------------------------------------------------------------------------------

HRESULT CWin32_Terminal::DeleteInstance ( const CInstance &Instance,  long lFlags )
{
    
    return WBEM_E_PROVIDER_NOT_CAPABLE;
/*
    HRESULT hr = WBEM_E_NOT_FOUND;
    
    CHString chTermName;
    
    if( g_pCfgComp == NULL )
    {
        return WBEM_E_INITIALIZATION_FAILURE;
    }
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }    

    hr = g_pCfgComp->DeleteWS((LPTSTR)(LPCTSTR) chTermName);

    TRC2((TB,"Terminal@ExecMethod: Delete returned 0x%x\n" , hr ));
    
    return hr;
  */     
    
}

//=----------------------------------------------------------------------------------------------------------
HRESULT CWin32_Terminal::ExecMethod ( const CInstance& Inst,
                                     const BSTR bstrMethodName,
                                     CInstance *pInParams,
                                     CInstance *pOutParams,
                                     long lFlags)
                                     
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
	ICfgComp *pCfgComp = NULL;

    if( pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }

    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if(_tcsicmp(chTermName, L"Console")== 0 )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    if( _wcsicmp(bstrMethodName, m_szEnable ) == 0 )
    {
        // Enables or Disables the Terminal.
        // Return Value: 0 if Success or an error.
        // uint32 Enable ([In] Boolean fEnable)
        
        DWORD dwfEnable = 0;
        ULONG  Size = 0;
        bool bRet;
        
        bRet = pInParams->GetDWORD(m_szEnableTerminal, dwfEnable);
        
        if ( !bRet || ( dwfEnable != 0 && dwfEnable != 1 ) )
        {
            return WBEM_E_INVALID_METHOD_PARAMETERS;
        }
        
        hr = StackObj.m_pCfgComp->EnableWinstation( (LPTSTR)(LPCTSTR) chTermName, dwfEnable);            
        
        TRC2((TB,"Terminal@ExecMethod: Enable returned 0x%x\n" , hr ));

        if( SUCCEEDED( hr ) )
        {
            hr = StackObj.m_pCfgComp->ForceUpdate();
        }
        
        if( SUCCEEDED( hr ) && pOutParams != NULL )
        {
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
        }                 
    }
    else if( _wcsicmp( bstrMethodName , m_szRename ) == 0 )
    {
        //  Renames the Terminal.
        //  uint32 Rename([In] string NewTerminalName) 
        
        CHString chNewTermName;

        pInParams->GetCHString(m_szNewTerminalName, chNewTermName);
        
        if ( chNewTermName.GetLength() > WINSTATIONNAME_LENGTH)
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        if ( chNewTermName.IsEmpty() != 0)
        {
            return WBEM_E_ILLEGAL_NULL;
        }
        
        hr = StackObj.m_pCfgComp->RenameWinstation((LPTSTR)(LPCTSTR) chTermName, (LPTSTR)(LPCTSTR) chNewTermName);
        
        TRC2((TB,"Terminal@ExecMethod: Rename returned 0x%x\n" , hr ));

        if( SUCCEEDED( hr ) )
        {
            hr = StackObj.m_pCfgComp->ForceUpdate();
        }
        
        if (SUCCEEDED (hr) && pOutParams != NULL )
        {
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
            
        }       
    }
    
    else if (_wcsicmp(bstrMethodName, m_szDelete) == 0)
    {
        //  Delete the Terminal.  
        //  uint32 Delete() ;
        
        hr = StackObj.m_pCfgComp->DeleteWS((LPTSTR)(LPCTSTR) chTermName);

        TRC2((TB,"Terminal@ExecMethod: Delete returned 0x%x\n" , hr ));
        
        if ( SUCCEEDED (hr) && pOutParams != NULL )
        {                
            
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
        }
        else
        {
            return WBEM_E_INVALID_METHOD_PARAMETERS;
        }                       
    }
    
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }  
    TRC2((TB,"Terminal@ExecMethod: Delete returned 0x%x\n" , hr ));  
	
    return hr;
}
//=--------------------


HRESULT CWin32_Terminal::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	    
    
    if( pInstance == NULL )
    { 
        TRC2((TB,"Terminal@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME)
    {                
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        
    } 
    
    if( ulRequiredProperties & BIT_FENABLETERMINAL)
    {                
        pInstance->SetDWORD(m_szEnableTerminal, pWS->fEnableWinstation);
        
    }  	
    
    return S_OK;
}


//------------------------------

CWin32_TSGeneralSetting::CWin32_TSGeneralSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSGeneralSetting_ctor"));
        
        _tcscpy(m_szTerminalProtocol, _T("TerminalProtocol"));

        _tcscpy(m_szTransport, _T("Transport"));

        _tcscpy(m_szComment, _T("Comment"));

        _tcscpy(m_szWindowsAuthentication, _T("WindowsAuthentication"));

        _tcscpy(m_szEncryptionLevel, _T("MinEncryptionLevel"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szSetEncryptionLevel, _T("SetEncryptionLevel"));
               
    }

    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------

CWin32_TSGeneralSetting::~CWin32_TSGeneralSetting ()
{
    
}



//=---------------------

BOOL CWin32_TSGeneralSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------

HRESULT CWin32_TSGeneralSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    LONG lSize;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
    CHString chTermName;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSGeneralSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szComment))
        ulRequiredProperties |= BIT_COMMENT;
    
    if (Query.IsPropertyRequired(m_szEncryptionLevel))
        ulRequiredProperties |= BIT_ENCRYPTIONLEVEL;
    
    if (Query.IsPropertyRequired(m_szTerminalProtocol))
        ulRequiredProperties |= BIT_TERMINALPROTOCOL;
    
    if (Query.IsPropertyRequired(m_szTransport))
        ulRequiredProperties |= BIT_TRANSPORT;
    
    if (Query.IsPropertyRequired(m_szWindowsAuthentication))
        ulRequiredProperties |= BIT_WINDOWSAUTHENTICATION;
    
    hr = StackObj.m_pCfgComp->GetWSInfo( (LPTSTR) (LPCTSTR) chTermName, &lSize, &pWS);
    
    TRC2((TB,"TSGeneralSetting@GetObject: returned 0x%x\n" , hr ));   
    
    
    if( SUCCEEDED( hr ) && (pWS != NULL) )
    {           
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );

        if( !(SUCCEEDED( hr )) )
        {        
            hr = WBEM_E_INVALID_OBJECT;
        }
        
    }
    else
    {
        hr = WBEM_E_INVALID_OBJECT;
    }


    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    
    return hr ;
}

//=--------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSGeneralSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/


HRESULT CWin32_TSGeneralSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
            {
                continue;
            }
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSGeneralSetting@EnumerateInstances: CreateNewInstance failed" ));
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSGeneralSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr )); 
            
            hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, &pWS[ ulNum ] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();                               
            }
            
            pInstance->Release( );
        }        
    }
    

    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}


//=----------------------------------------------------------------------------------------------------------
HRESULT CWin32_TSGeneralSetting::ExecMethod ( const CInstance& Inst,
                                                    const BSTR bstrMethodName,
                                                    CInstance *pInParams,
                                                    CInstance *pOutParams,
                                                    long lFlags)
                                                    
{
    
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;
    LONG lSize;
    OSVERSIONINFOW OsVersionInfo;
    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
        
    if( _wcsicmp(bstrMethodName, m_szSetEncryptionLevel ) == 0 )
    {
        // Sets the EncryptionLevel to one of Low, Medium or High. 
        // uint32 SetEncryptionLevel ([In] uint32 EncryptionLevel)
        
        DWORD dwData = 0 ;
        DWORD dwStatus = 0;
        ULONG  Size = 0;
        bool bRet;
        
        RegGetMachinePolicy(&m_gpPolicy);
        
        do
        {
            if( pInParams != NULL )
            {  
                
                bRet = pInParams->GetDWORD(m_szEncryptionLevel, dwData);
                
                TRC2((TB,"m_gpPolicy.fPolicyMinEncryptionLevel ret 0x%x\n", m_gpPolicy.fPolicyMinEncryptionLevel));                 
                
                if( m_gpPolicy.fPolicyMinEncryptionLevel == 0 )
                {
                    TRC2((TB,"Condition to update fPolicyMinEncryptionLevel satisfied"));     
                    
                    hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);

                    if( SUCCEEDED( hr ) && pUser != NULL )
                    {                    
                        if( GetVersionEx( &OsVersionInfo))
                        {
                            if( OsVersionInfo.dwMajorVersion == 5 && OsVersionInfo.dwMinorVersion == 0)
                            {

                                if( dwData < 1 || dwData > 3)
                                {
                                    hr = WBEM_E_INVALID_PARAMETER;

                                    break;
                                }
                    
                                pUser->MinEncryptionLevel = dwData;
                    
                                hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );

                                if( SUCCEEDED( hr ))
                                {
                                    hr = StackObj.m_pCfgComp->ForceUpdate();
                                }
                                
                            }
                            else
                            {                               
                                if( dwData < 1 || dwData > 4)
                                {
                                    hr = WBEM_E_INVALID_PARAMETER;

                                    break;
                                }
                    
                                pUser->MinEncryptionLevel = dwData;
                    
                                hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );  
                                
                                if( SUCCEEDED( hr ))
                                {
                                    hr = StackObj.m_pCfgComp->ForceUpdate();
                                }
                            }
                        }
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
                TRC2((TB,"TSGeneralSetting@ExecMethod: SetEncryptionLevel returned 0x%x\n" , hr));                     
                
            }            
            else
            {
                hr = WBEM_E_INVALID_METHOD_PARAMETERS;
            }  
            
        }while (0);

        if (pUser != NULL)
        {
            CoTaskMemFree (pUser);
        }        
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }
	
    return hr;
}


//=--------------------


HRESULT CWin32_TSGeneralSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szComment))
        ulRequiredProperties |= BIT_COMMENT;
    
    if (Query.IsPropertyRequired(m_szEncryptionLevel))
        ulRequiredProperties |= BIT_ENCRYPTIONLEVEL;
    
    if (Query.IsPropertyRequired(m_szTerminalProtocol))
        ulRequiredProperties |= BIT_TERMINALPROTOCOL;
    
    if (Query.IsPropertyRequired(m_szTransport))
        ulRequiredProperties |= BIT_TRANSPORT;
    
    if (Query.IsPropertyRequired(m_szWindowsAuthentication))
        ulRequiredProperties |= BIT_WINDOWSAUTHENTICATION;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
            {
                continue;
            }
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    ERR((TB,"TSGeneralSetting@ExecQuery: CreateNewInstance failed"));                    
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }
    
    return hr;
}




//=----------

HRESULT CWin32_TSGeneralSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    ULONG  ulNumPd = 0; 
    ULONG ulSize = 0;
    LONG lSize = 0;
    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSGeneralSetting@LoadPropertyValues: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME)
    {
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);    
    }
    
    TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetTerminalName"));

    if( pWS != NULL )
    {
    
        if( ulRequiredProperties & BIT_TERMINALPROTOCOL )
        {      
            pInstance->SetWCHARSplat(m_szTerminalProtocol, pWS->wdName);
        
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetTerminalProtocol"));              
        }
    
        if( ulRequiredProperties & BIT_TRANSPORT)
        {
        
            pInstance->SetWCHARSplat(m_szTransport, pWS->pdName);
        
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetTransportTypes"));
        
        }
    
        if( ulRequiredProperties & BIT_COMMENT )
        {
        
            pInstance->SetWCHARSplat(m_szComment, pWS->Comment);
        
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetComment"));
        }
    
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        
        if(( ulRequiredProperties & BIT_WINDOWSAUTHENTICATION) && ( SUCCEEDED(hr) ) && pUser != NULL) 
        {      
            pInstance->SetDWORD(m_szWindowsAuthentication, pUser->fUseDefaultGina);
            
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetComment ret 0x%x\n" , hr));
        }
        
        
        if(( ulRequiredProperties & BIT_ENCRYPTIONLEVEL) && ( SUCCEEDED (hr) ) && pUser != NULL)
        {            
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyMinEncryptionLevel != 0 )
            {
                pInstance->SetDWORD(m_szEncryptionLevel, m_gpPolicy.MinEncryptionLevel );
            }
            else
            {
                pInstance->SetDWORD(m_szEncryptionLevel, pUser->MinEncryptionLevel);
            }
            
            TRC2((TB,"TSGeneralSetting@LoadPropertyValues: GetEncryptionLevel ret 0x%x\n" , hr));        
        }
    }
    
	
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
    
    return hr;
}
//=--------------------

HRESULT CWin32_TSGeneralSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    CHString chTermName;
    CHString chData;
    PUSERCONFIG pUser = NULL;   
    PWS  pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
    
    do
    {        
        if (SUCCEEDED ( hr ) && pWS != NULL)
        {
            hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
            if(SUCCEEDED (hr)  && pUser != NULL )
            {
                
                Instance.GetCHString(m_szTerminalProtocol, chData);
                
                if (chData.GetLength() > WINSTATIONNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                wcscpy(pWS->wdName, (LPTSTR) (LPCTSTR) chData);
                
                Instance.GetCHString(m_szTransport, chData);
                
                if (chData.GetLength() > WINSTATIONNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                wcscpy(pWS->pdName, (LPTSTR)(LPCTSTR) chData);
                
                Instance.GetCHString(m_szComment, chData);
                
                if ( chData.GetLength() > WINSTATIONCOMMENT_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                wcscpy(pWS->Comment, (LPTSTR) (LPCTSTR) chData);
                
                
                Instance.GetDWORD(m_szWindowsAuthentication, dwData);
                
                if (dwData != 0 && dwData != 1)
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }
                
                pUser->fUseDefaultGina = dwData;
                
                hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                
                TRC2((TB,"TSGeneralSetting@PutInstance: SetUserConfig ret 0x%x\n" , dwStatus));
                
                hr = StackObj.m_pCfgComp->UpDateWS( pWS, (DWORD)BIT_ALL_PROPERTIES , &dwStatus, TRUE );
                
                TRC2((TB,"TSGeneralSetting@PutInstance: UpdateWS ret 0x%x\n" , dwStatus));                                                

                if( SUCCEEDED( hr ))
                {
                    hr = StackObj.m_pCfgComp->ForceUpdate();
                }
            }
            else
            {                
                CHString sRelPath;
                
                Instance.GetCHString(L"__RelPath", sRelPath);
                CInstance *pErrorInstance = NULL;
                
             
                TRC2((TB,"TSGeneralSetting@PutInstance: ret 0x%x\n" , hr));
                
                if( SUCCEEDED( hr ) )
                {
                    if (pErrorInstance != NULL)
                    {
                        LoadString( g_hInstance , IDS_ERR_PUTTSGCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                        pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                        
                        LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                        pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                        
                        pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                        pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSGENERALSETTING_Prov);
                        pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                        
                        IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                        
                        if (pObj != NULL)
                        {                        
                            MethodContext *pMethodContext = Instance.GetMethodContext();  
                            
                            if (pMethodContext != NULL)
                                pMethodContext->SetStatusObject(pObj);
                            
                            pObj->Release();
                        }
                        pErrorInstance->Release();
                    }
                    
                }
                TRC2((TB,"TSGeneralSetting@PutInstance: ret 0x%x\n" , hr));
            }
            
        } 
    }while (0);

    
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }    

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;
}


//=-------------------------------------------------------
CWin32_TSLogonSetting::CWin32_TSLogonSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{	

    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSLogonSetting_ctor"));

        _tcscpy(m_szClientLogonInfoPolicy, _T("ClientLogonInfoPolicy"));

        _tcscpy(m_szPromptForPassword, _T("PromptForPassword"));

        _tcscpy(m_szUserName, _T("UserName"));

        _tcscpy(m_szDomain, _T("Domain"));

        _tcscpy(m_szPassword, _T("Password"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szExplicitLogon, _T("ExplicitLogon"));

        _tcscpy(m_szSetPromptForPassword, _T("SetPromptForPassword"));
    }
    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------

CWin32_TSLogonSetting::~CWin32_TSLogonSetting ()
{
    
}

//=------------

BOOL CWin32_TSLogonSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------

HRESULT CWin32_TSLogonSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{	
    HRESULT     hr  = WBEM_E_NOT_FOUND;
    PWS         pWS = NULL;
    LONG        lSize;
    ULONGLONG   ulRequiredProperties = 0;
    CHString    chTermName;    
    CStackClass StackObj;

    if( StackObj.m_pCfgComp == NULL)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( pInstance == NULL  )
    {
        TRC2((TB,"TSLogonSetting@GetObject: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientLogonInfoPolicy))
        ulRequiredProperties |= BIT_CLIENTLOGONINFOPOLICY;
    
    if (Query.IsPropertyRequired(m_szDomain))
        ulRequiredProperties |= BIT_DOMAIN;
        
    if (Query.IsPropertyRequired(m_szPromptForPassword))
        ulRequiredProperties |= BIT_PROMPTFORPASSWORD;
    
    if (Query.IsPropertyRequired(m_szUserName))
        ulRequiredProperties |= BIT_USERNAME;
    
    if ( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
        }                
    }
    	
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}
//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSLogonSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSLogonSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    LONG ulNum = 0;
    ULONG  ulSize = 0; 
    PWS pWS = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;

            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR ((TB,"TSLogonSetting@EnumerateInstances: CreateNewInstance failed"));
                                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSLogonSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr));

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, &pWS[ulNum] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();
            }
            pInstance->Release();
        }        
    } 
    

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    
    return hr;
}
//=--------------------
//=------@resume here 
HRESULT CWin32_TSLogonSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG lSize = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSLogonSetting@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME)
    {
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);    
    }
    
    TRC2((TB,"TSLogonSetting@LoadPropertyValues: GetTerminalName" ));
    
    hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
    
    TRC2((TB,"TSLogonSetting@LoadPropertyValues ret 0x%x\n" , hr ));
    
    if ( SUCCEEDED (hr) && pUser != NULL )
    {        
        if( ulRequiredProperties & BIT_CLIENTLOGONINFOPOLICY)
        {         
            pInstance->SetDWORD(m_szClientLogonInfoPolicy, pUser->fInheritAutoLogon);
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: ClientLogonInfoPolicy" ));                  
        
        if( ulRequiredProperties & BIT_PROMPTFORPASSWORD)
        {
            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyPromptForPassword != 0 )
            {
                pInstance->SetDWORD(m_szPromptForPassword, m_gpPolicy.fPromptForPassword);
            }
            else
            {
                pInstance->SetDWORD(m_szPromptForPassword, pUser->fPromptForPassword);
            }
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: PromptForPassword" ));         
        
        if( ulRequiredProperties & BIT_USERNAME)
        {                          
            pInstance->SetWCHARSplat(m_szUserName, pUser->UserName);
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: UserName" ));                
        
        if( ulRequiredProperties & BIT_DOMAIN)
        {                          
            pInstance->SetWCHARSplat(m_szDomain, pUser->Domain);
        }
        TRC2((TB,"TSLogonSetting@LoadPropertyValues: Domain" ));                
    } 

	
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSLogonSetting::PutInstance ( const CInstance &Instance, long lFlags)
{

    HRESULT hr= WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    CHString chTermName;
    DWORD dwStatus = 0;
    LONG lSize;
    PUSERCONFIG pUser = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        
        if( SUCCEEDED( hr ) && pUser != NULL )
        {
            Instance.GetDWORD(m_szClientLogonInfoPolicy, dwData);
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritAutoLogon = dwData;
            
            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus ); 
            
            if( SUCCEEDED( hr ) )
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
        }        
        else
        {
            TRC2((TB,"TSLogonSetting@PutInstance ret 0x%x\n" , hr ));             
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ))
            {
                TRC2((TB,"TSLogonSetting@PutInstance: GetInstanceByPath ret 0x%x\n" , hr ));

                if( pErrorInstance != NULL )
                {
                    
                    LoadString( g_hInstance , IDS_ERR_PUTTSLCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSLOGONSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if( pObj != NULL )
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        
                        if( pMethodContext != NULL )
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }            
        }
    }while (0);

	
    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }
    
    return hr;
}
//=--------------------

HRESULT CWin32_TSLogonSetting::ExecMethod ( const CInstance& Inst,
                                                  const BSTR bstrMethodName,
                                                  CInstance *pInParams,
                                                  CInstance *pOutParams,
                                                  long lFlags)
                                                  
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    PUSERCONFIG pUser = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
	
    if( pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }
            
    
    // Sets the properties UserName, Password and Domain which specify 
    // the credentials explicitly to be used for authentication.
                              
    //  uint32 ExplicitLogon([In] string UserName, [In] string Domain, [In] string Password)
    
    if (_wcsicmp(bstrMethodName, m_szExplicitLogon) == 0)
    {
        
        DWORD dwData = 0;
        DWORD dwStatus = 0;
        CHString chData;
        CHString chTermName;
        LONG lSize;
        
        
        Inst.GetCHString(m_szTerminalName, chTermName);
        
        if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        if( chTermName.IsEmpty() != 0)
        {
            return WBEM_E_ILLEGAL_NULL;
        }
        
        if(_tcsicmp(chTermName, L"Console") == 0)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
    
        hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR) (LPCTSTR) chTermName , &lSize, &pUser, TRUE);
        
        do
        {
            if( SUCCEEDED( hr ) && pUser != NULL )
            {
                dwData = pUser->fInheritAutoLogon;
                
                if( dwData == 0 )
                {   
                    chData.Empty();

                    pInParams->GetCHString( m_szUserName, chData );
                    
                    if( chData.GetLength() > USERNAME_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }

                    wcscpy(pUser->UserName, (LPTSTR) (LPCTSTR) chData);                        

                    chData.Empty();
                    
                    pInParams->GetCHString( m_szDomain, chData );
                    
                    if( chData.GetLength() > APPSERVERNAME_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }

                    wcscpy(pUser->Domain, (LPTSTR) (LPCTSTR) chData);     

                    chData.Empty();
                    
                    pInParams->GetCHString( m_szPassword, chData );
                    
                    if( chData.GetLength() > PASSWORD_LENGTH )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                        
                        break;
                    }
                    
                    wcscpy( pUser->Password, (LPTSTR) (LPCTSTR) chData );                                            
                    
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                    if( SUCCEEDED (hr) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSLogonSetting@ExecMethod: ExplicitLogon ret 0x%x\n" , hr ));
                    } 
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;                        
                }
                
            }
        }while(0);
        
    }
    
    else if( _wcsicmp( bstrMethodName, m_szSetPromptForPassword ) == 0 )
    {
        
        DWORD dwData = 0;
        DWORD dwStatus = 0;
        CHString chTermName;
        LONG lSize;
        bool bRet;
        
        
        Inst.GetCHString(m_szTerminalName, chTermName);
        
        if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
        {
            return WBEM_E_VALUE_OUT_OF_RANGE;
        }
        
        if( chTermName.IsEmpty() != 0)
        {
            return WBEM_E_ILLEGAL_NULL;
        }

        if(_tcsicmp(chTermName, L"Console") == 0)
        {
            return WBEM_E_NOT_SUPPORTED;
        }
        
        hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
        
        RegGetMachinePolicy(&m_gpPolicy);
        
        do
        {
            if( SUCCEEDED (hr) && pInParams != NULL && pUser != NULL )
            {      
                bRet = pInParams->GetDWORD( m_szPromptForPassword, dwData );
                
                if( ( m_gpPolicy.fPolicyPromptForPassword == 0) && bRet != 0 )
                {                    
                    if( dwData != 0 && dwData != 1 )
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                        
                        break;
                    }
                    
                    pUser->fPromptForPassword = dwData;
                    
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                    if ( SUCCEEDED (hr) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSLogonSetting@ExecMethod: PromptForPassword ret 0x%x\n" , hr ));
                    } 
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
                
            }
        } while (0);
        
    }
    
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }
    
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }

    return hr;
}

//=----------------------------


HRESULT CWin32_TSLogonSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
	
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientLogonInfoPolicy))
        ulRequiredProperties |= BIT_CLIENTLOGONINFOPOLICY;
    
    if (Query.IsPropertyRequired(m_szDomain))
        ulRequiredProperties |= BIT_DOMAIN;
        
    if (Query.IsPropertyRequired(m_szPromptForPassword))
        ulRequiredProperties |= BIT_PROMPTFORPASSWORD;
    
    if (Query.IsPropertyRequired(m_szUserName))
        ulRequiredProperties |= BIT_USERNAME;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++ )
        {  
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue; 
            
            // Method 2 - Check to see if the query CAN be processed by 'name', if so,
            // only return those names.
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name) )
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL )
                {
                    ERR( (TB,"TSLogonSetting@ExecQuery: CreateNewInstance failed" ) );
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString( m_szTerminalName, CHString(pWS[ulNum].Name) );

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }  	
    
    return hr;
    
}




//=--------------------Win32_TSSessionSettingsConfig------------------------



CWin32_TSSessionSetting::CWin32_TSSessionSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSSessionSetting_ctor"));

        _tcscpy(m_szTimeLimitPolicy, _T("TimeLimitPolicy"));

        _tcscpy(m_szActiveSessionLimit, _T("ActiveSessionLimit"));

        _tcscpy(m_szDisconnectedSessionLimit, _T("DisconnectedSessionLimit"));

        _tcscpy(m_szIdleSessionLimit, _T("IdleSessionLimit"));

        _tcscpy(m_szBrokenConnectionPolicy, _T("BrokenConnectionPolicy"));

        _tcscpy(m_szReconnectionPolicy, _T("ReconnectionPolicy"));

        _tcscpy(m_szBrokenConnectionAction, _T("BrokenConnectionAction"));

        _tcscpy(m_szSessionLimitType, _T("SessionLimitType"));

        _tcscpy(m_szValueLimit, _T("ValueLimit"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szTimeLimit, _T("TimeLimit"));

        _tcscpy(m_szBrokenConnection, _T("BrokenConnection"));

               
    }
}
//=--------------------
CWin32_TSSessionSetting::~CWin32_TSSessionSetting ()
{
    
}

//=-----------------

BOOL CWin32_TSSessionSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------

HRESULT CWin32_TSSessionSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    DWORD dwData = 0;
    CHString chTermName; 
    LONG  lSize ;
 //   PUSERCONFIG pUser = NULL;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSSessionSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;

    if (Query.IsPropertyRequired(m_szTimeLimitPolicy))
        ulRequiredProperties |= BIT_ACTIVESESSIONPOLICY;

    if (Query.IsPropertyRequired(m_szBrokenConnectionPolicy))
        ulRequiredProperties |= BIT_BROKENCONNECTIONPOLICY;

    if (Query.IsPropertyRequired(m_szActiveSessionLimit))
        ulRequiredProperties |= BIT_ACTIVESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szBrokenConnectionAction))
        ulRequiredProperties |= BIT_BROKENCONNECTIONACTION;
    
    if (Query.IsPropertyRequired(m_szDisconnectedSessionLimit))
        ulRequiredProperties |= BIT_DISCONNECTEDSESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szIdleSessionLimit))
        ulRequiredProperties |= BIT_IDLESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szReconnectionPolicy))
        ulRequiredProperties |= BIT_RECONNECTIONPOLICY;

    hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
    
    if ( pInstance != NULL && SUCCEEDED( hr ) && pWS != NULL )
    {
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
    }
    
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    	
    return hr;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSSessionSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSSessionSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{	
    HRESULT hr = WBEM_S_NO_ERROR;
    ULONG  ulTerminals = 0;
    ULONG ulNum = 0;
    ULONG  ulSize = 0; 
    LONG lSize = 0;
    PWS  pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;

            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSSessionSetting@EnumerateInstances: CreateNewInstance failed" ));
                                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSSessionSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr  ));

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum] );

            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();
                                
            }
            
            pInstance->Release( );            
        }
        
    }  
    

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSSessionSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL ) 
    {
        ERR((TB,"TSSessionSetting@LoadPropertyValues: invalid pointer"  ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    
    if ( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);        
        }

        RegGetMachinePolicy(&m_gpPolicy);
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSSessionSetting@LoadPropertyValues: GetUserConfig ret 0x%x\n" , hr   ));
        
        if ( SUCCEEDED (hr) && pUser != NULL )
        {
            
            if( ulRequiredProperties & BIT_ACTIVESESSIONPOLICY)
            {                
                pInstance->SetDWORD(m_szTimeLimitPolicy, pUser->fInheritMaxSessionTime);                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: TimeLimitPolicy"   ));
            
            
            if( ulRequiredProperties & BIT_ACTIVESESSIONLIMIT)
            {    
                if( m_gpPolicy.fPolicyMaxSessionTime != 0 )
                {
                    pInstance->SetDWORD(m_szActiveSessionLimit, m_gpPolicy.MaxConnectionTime);
                }
                else
                {
                    pInstance->SetDWORD(m_szActiveSessionLimit, pUser->MaxConnectionTime);
                }                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: MaxConnectionTime"   ));          
            
            if( ulRequiredProperties & BIT_DISCONNECTEDSESSIONLIMIT)
            {   
                if( m_gpPolicy.fPolicyMaxDisconnectionTime != 0 )
                {
                    pInstance->SetDWORD(m_szDisconnectedSessionLimit, m_gpPolicy.MaxDisconnectionTime);
                }
                else
                {                
                    pInstance->SetDWORD(m_szDisconnectedSessionLimit, pUser->MaxDisconnectionTime);
                }                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: MaxDisconnectionTime" ));      
            
            if( ulRequiredProperties & BIT_IDLESESSIONLIMIT)
            {     
                if( m_gpPolicy.fPolicyMaxIdleTime != 0 )
                {
                    pInstance->SetDWORD(m_szIdleSessionLimit, m_gpPolicy.MaxIdleTime);
                }
                else
                {
                    pInstance->SetDWORD(m_szIdleSessionLimit, pUser->MaxIdleTime);
                }
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: MaxIdleTime" ));        
            
            if( ulRequiredProperties &  BIT_BROKENCONNECTIONPOLICY)
            {                   
                pInstance->SetDWORD(m_szBrokenConnectionPolicy, pUser->fInheritResetBroken);                
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: BrokenConnectionPolicy" ));         
            
            if( ulRequiredProperties & BIT_BROKENCONNECTIONACTION)
            {   
                if( m_gpPolicy.fPolicyResetBroken != 0 )
                {
                    pInstance->SetDWORD(m_szBrokenConnectionAction, m_gpPolicy.fResetBroken);
                }
                else
                {
                    pInstance->SetDWORD(m_szBrokenConnectionAction, pUser->fResetBroken);
                }                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: BrokenConnectionAction" ));         
            
            if( ulRequiredProperties & BIT_RECONNECTIONPOLICY)
            {                          
                pInstance->SetDWORD(m_szReconnectionPolicy, pUser->fInheritReconnectSame);
                
            }
            TRC2((TB,"TSSessionSetting@LoadPropertyValues: ReconnectionPolicy" )); 
                       
        }
        
    }

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }

    return hr;
    
}

//=--------------------

HRESULT CWin32_TSSessionSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    LONG lSize;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR) (LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED( hr ) && pUser != NULL )
        {
            Instance.GetDWORD(m_szTimeLimitPolicy, dwData);
            
            if (dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritMaxSessionTime = dwData;
            pUser->fInheritMaxDisconnectionTime = dwData;
            pUser->fInheritMaxIdleTime = dwData;
            
            Instance.GetDWORD( m_szBrokenConnectionPolicy, dwData );
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritResetBroken = dwData;
            
            Instance.GetDWORD( m_szReconnectionPolicy, dwData );
            
            if (dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritReconnectSame = dwData;
            
            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
            
            TRC2((TB,"TSSessionSetting@PutInstance: SetUserConfig ret 0x%x\n" , dwStatus ));  
            
            if( SUCCEEDED( hr ))
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
        }
        
        else
        {
            ERR((TB,"TSSessionSetting@PutInstance: Failed" ));
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSSessionSetting@PutInstance: GetInstanceByPath succeeded" ));

                if (pErrorInstance != NULL)
                {
                    
                    LoadString( g_hInstance , IDS_ERR_PUTTSSCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSSESSIONSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if (pObj != NULL)
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        if (pMethodContext != NULL)
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }
            TRC2((TB,"TSSessionSetting@PutInstance: GetInstanceByPath ret 0x%x\n" , hr ));     
        }
    }while (0);

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }
    	
    return hr;
}

//=--------------------

HRESULT CWin32_TSSessionSetting::ExecMethod ( const CInstance& Inst,
                                                    const BSTR bstrMethodName,
                                                    CInstance *pInParams,
                                                    CInstance *pOutParams,
                                                    long lFlags)
                                                    
{
	
    HRESULT hr= WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;
    LONG lSize;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}    
    
    Inst.GetCHString( m_szTerminalName, chTermName );
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty( ) != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0 )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    RegGetMachinePolicy(&m_gpPolicy);
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR) (LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED (hr) && pUser != NULL && pInParams != NULL )
        {
            
            // SessionLimitType is an enumeration of the properties:
            // ActiveSessionLimit, DisconnectedSessionLimit and IdleSessionLimit
            // which specify the Maximum allowed time for Active, Disconnected Session 
            // Idle session limits. Value specifies the time in minutes.
                              
            // uint32 TimeLimit([In] uint32 SessionLimitType, [In] uint32 ValueLimit)
            
            if( _wcsicmp( bstrMethodName, m_szTimeLimit ) == 0 )
            {
                
                CHString chData;
                DWORD dwData = 0;
                DWORD dwStatus = 0;
                DWORD dwSessionType; 
                bool bRet;
                
                chData.Empty();
                
                pInParams->GetCHString( m_szSessionLimitType, chData );
                
                if( chData.IsEmpty() != 0 )
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }
                
                if( chData.CompareNoCase( m_szActiveSessionLimit ) == 0 )
                {
                   dwData = pUser->fInheritMaxSessionTime;

                    if( dwData == 0 && m_gpPolicy.fPolicyMaxSessionTime == 0)
                    {
                        bRet = pInParams->GetDWORD(m_szValueLimit, dwData);
                    
                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                        
                            break;
                        }
                    
                        pUser->MaxConnectionTime = dwData;
                    
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            hr = StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD( L"ReturnValue", WBEM_S_NO_ERROR );
                        
                            TRC2((TB,"TSSessionSetting@ExecMethod:  TimeLimit - ActiveSessionLimit ret 0x%x\n" , hr  ));         
                        } 
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    
                        break;                        
                    }                
                }
                else if( chData.CompareNoCase( m_szDisconnectedSessionLimit ) == 0 )
                {
                    dwData = pUser->fInheritMaxSessionTime;
                
                    if( dwData == 0 && m_gpPolicy.fPolicyMaxDisconnectionTime == 0)
                    {
                        bRet = pInParams->GetDWORD(m_szValueLimit, dwData);
                    
                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                        
                            break;
                        }
                    
                        pUser->MaxDisconnectionTime = dwData;
                    
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                            TRC2((TB,"TSSessionSetting@ExecMethod:  TimeLimit - DisconnectedSessionLimit ret 0x%x\n" , hr  ));      
                        } 
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    
                        break;                        
                    }               
                }
                else if( chData.CompareNoCase(m_szIdleSessionLimit) == 0)
                {
                    dwData = pUser->fInheritMaxSessionTime;

                    if( dwData == 0 && m_gpPolicy.fPolicyMaxIdleTime == 0)
                    {
                        bRet = pInParams->GetDWORD(m_szValueLimit, dwData);
                    

                        if ( !bRet )
                        {
                            hr = WBEM_E_INVALID_PARAMETER;
                        
                            break;
                        }
                    
                        pUser->MaxIdleTime = dwData;
                    
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                    
                        if( SUCCEEDED( hr ) && pOutParams != NULL )
                        {
                            StackObj.m_pCfgComp->ForceUpdate();

                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                            TRC2((TB,"TSSessionSetting@ExecMethod:  TimeLimit - IdleSessionLimit ret 0x%x\n" , hr  ));    
                        } 
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    
                        break;                        
                    }                
                }
                else 
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                    
                    break;
                }                     
            }
            
            else if( _wcsicmp( bstrMethodName, m_szBrokenConnection ) == 0 )
            {
                
                DWORD dwData = 0;
                DWORD dwStatus = 0; 
                bool bRet;
             
                dwData = pUser->fInheritResetBroken;

                if( dwData == 0 && m_gpPolicy.fPolicyResetBroken == 0  )
                {
                    bRet = pInParams->GetDWORD(m_szBrokenConnectionAction, dwData);
                

                    if ( !bRet || (dwData !=0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                    
                        break;
                    }
                
                    pUser->fResetBroken = dwData;
                
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    
                        TRC2((TB,"TSSessionSetting@ExecMethod:  BrokenConnection ret 0x%x\n" , hr  ));
                    } 
                
                }
                else
                {
                
                    hr = WBEM_E_INVALID_OPERATION;
                
                    break;
                
                }              
            }                         
        }
        
    } while( 0 );


    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
}


//=--------------------------

HRESULT CWin32_TSSessionSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;	

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;

	if (Query.IsPropertyRequired(m_szTimeLimitPolicy))
        ulRequiredProperties |= BIT_ACTIVESESSIONPOLICY;

    if (Query.IsPropertyRequired(m_szBrokenConnectionPolicy))
        ulRequiredProperties |= BIT_BROKENCONNECTIONPOLICY;
    
    if (Query.IsPropertyRequired(m_szActiveSessionLimit))
        ulRequiredProperties |= BIT_ACTIVESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szBrokenConnectionAction))
        ulRequiredProperties |= BIT_BROKENCONNECTIONACTION;
    
    if (Query.IsPropertyRequired(m_szDisconnectedSessionLimit))
        ulRequiredProperties |= BIT_DISCONNECTEDSESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szIdleSessionLimit))
        ulRequiredProperties |= BIT_IDLESESSIONLIMIT;
    
    if (Query.IsPropertyRequired(m_szReconnectionPolicy))
        ulRequiredProperties |= BIT_RECONNECTIONPOLICY;
   
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue; 

            // Method 2
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSSessionSetting@ExecQuery: CreateNewInstance failed" ));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }
    	
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    	
    return hr;
    
}

//=----------------------Win32_TSEnvironmentSetting---------------------


CWin32_TSEnvironmentSetting::CWin32_TSEnvironmentSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSEnvironmentSetting_ctor"));

        _tcscpy(m_szInitialProgramPolicy, _T("InitialProgramPolicy"));

        _tcscpy(m_szInitialProgramPath, _T("InitialProgramPath"));

        _tcscpy(m_szStartIn, _T("StartIn"));

        _tcscpy(m_szClientWallPaper, _T("ClientWallPaper"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szInitialProgram, _T("InitialProgram"));

        _tcscpy(m_szSetClientWallPaper, _T("SetClientWallPaper"));
               
    }
}
//=--------------------

CWin32_TSEnvironmentSetting::~CWin32_TSEnvironmentSetting ()
{
}

//=---------------


BOOL CWin32_TSEnvironmentSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------

HRESULT CWin32_TSEnvironmentSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName;
    LONG  lSize ;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
  //  PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if(  pInstance == NULL )
    {
        ERR((TB,"TSEnvironmentSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientWallPaper))
        ulRequiredProperties |= BIT_CLIENTWALLPAPER;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPath))
        ulRequiredProperties |= BIT_INITIALPROGRAMPATH;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPolicy))
        ulRequiredProperties |= BIT_INITIALPROGRAMPOLICY;
    
    if (Query.IsPropertyRequired(m_szStartIn))
        ulRequiredProperties |= BIT_STARTIN;
    
    if ( pInstance != NULL )
    {
        
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
        }                        
    }    	

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
	
    return hr;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSEnvironmentSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSEnvironmentSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG ulNum = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ); ulNum++)
        {   
			if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
				continue;

            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSEnvironmentSetting@EnumerateInstances: CreateNewInstance Failed" ));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }            

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROPERTIES, &pWS[ulNum] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();                                
            }
            
            pInstance->Release( );
        }
    }   
    
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
    
    return hr;
}

//=--------------------

HRESULT CWin32_TSEnvironmentSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
 	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSEnvironmentSetting@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if ( pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: GetTerminalName ret 0x%x\n" , hr  ));
        
        if ( SUCCEEDED (hr) && pUser != NULL )
        {
            
            if( ulRequiredProperties & BIT_INITIALPROGRAMPOLICY)
            {
                
                pInstance->SetDWORD(m_szInitialProgramPolicy, pUser->fInheritInitialProgram);
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: InitialProgramPolicy"  ));
            
            if( ulRequiredProperties & BIT_INITIALPROGRAMPATH)
            {   
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyInitialProgram != 0 )
                {
                    pInstance->SetWCHARSplat(m_szInitialProgramPath, m_gpPolicy.InitialProgram);
                }
                else
                {
                    pInstance->SetWCHARSplat(m_szInitialProgramPath, pUser->InitialProgram);
                }
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: InitialProgramPath"  ));
            
            if( ulRequiredProperties & BIT_STARTIN)
            {                          
                pInstance->SetWCHARSplat(m_szStartIn, pUser->WorkDirectory);
                
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: StartIn"  ));
            
            
            if( ulRequiredProperties & BIT_CLIENTWALLPAPER)
            {   
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableWallpaper != 0 )
                {
                    pInstance->SetDWORD(m_szClientWallPaper, m_gpPolicy.fDisableWallpaper);
                }
                else
                {
                    pInstance->SetDWORD(m_szClientWallPaper, pUser->fWallPaperDisabled);
                }                                 
            }
            TRC2((TB,"TSEnvironmentSetting@LoadPropertyValues: ClientWallPaper"  ));            
        }                  
    }
        
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
    
}

//=--------------------

HRESULT CWin32_TSEnvironmentSetting::PutInstance ( const CInstance &Instance, long lFlags)
{	
    HRESULT hr= WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    CHString chTermName;
    LONG lSize;
    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if (chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        
        if( SUCCEEDED (hr) && pUser != NULL )
        {
            Instance.GetDWORD(m_szInitialProgramPolicy, dwData);
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritInitialProgram = dwData;                        
            
            hr = StackObj.m_pCfgComp->SetUserConfig((LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
            
            if( SUCCEEDED( hr ))
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }

        }
        else
        {
            TRC2((TB,"TSEnvironmentSetting@PutInstance: ret 0x%x\n" , hr  ));  
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSEnvironmentSetting@PutInstance: ret 0x%x\n" , hr  ));  
                
                if (pErrorInstance != NULL)
                {
                    LoadString( g_hInstance , IDS_ERR_PUTTSECONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSENVIRONMENTSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if (pObj != NULL)
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        
                        if (pMethodContext != NULL)
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }
        }
    }while (0);

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
}


//=--------------------


HRESULT CWin32_TSEnvironmentSetting::ExecMethod ( const CInstance& Inst,
                                                        const BSTR bstrMethodName,
                                                        CInstance *pInParams,
                                                        CInstance *pOutParams,
                                                        long lFlags)
                                                        
{	   
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    Inst.GetCHString( m_szTerminalName, chTermName );
    
    if( chTermName.GetLength( ) > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
       
    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    // Sets the properties InitialProgramPath and StartIn which 
    // specify the name and path of the program and the working 
    // directory path for the program the user wants to start on 
    // logon to the Terminal Server.              
    
    // uint32 InitialProgram([In] string InitialProgramPath, [In] string Startin)
    
    do
    {
        if (_wcsicmp(bstrMethodName, m_szInitialProgram) == 0)
        {
            
            DWORD dwData = 0;
            DWORD dwStatus = 0;
            CHString chData;
            LONG lSize;


            
            hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);

            RegGetMachinePolicy(&m_gpPolicy);

            if( SUCCEEDED (hr) && pUser != NULL )
            {
            
                dwData = pUser->fInheritInitialProgram;
            
                if( (dwData == 0) && pInParams != NULL  )
                {   
                    if(m_gpPolicy.fPolicyInitialProgram != 0)
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                    
                        break;
                    }
                    chData.Empty();                       
                
                    pInParams->GetCHString(m_szInitialProgramPath, chData);
                
                    if( chData.GetLength() > 256 )
                    {                        
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                        break;
                    }
                                  
                    wcscpy( pUser->InitialProgram, (LPTSTR)(LPCTSTR) chData );                    
                                   
                    chData.Empty();
                            
                    pInParams->GetCHString( m_szStartIn, chData );
        
                    if( chData.GetLength() > 256 )
                    {
                        hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                        break;
                    }
        
                    wcscpy( pUser->WorkDirectory, (LPTSTR) (LPCTSTR) chData );
        
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR) (LPCTSTR) chTermName, lSize, pUser , &dwStatus );
        
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD( L"ReturnValue", WBEM_S_NO_ERROR );
                    }
                }   
            
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;
        
                    break;
                }
            }
        }

        if (_wcsicmp(bstrMethodName, m_szSetClientWallPaper) == 0)
        {
            BOOL   bRet  = 0;
            DWORD dwData = 0;
            DWORD dwStatus = 0;
            LONG lSize;

            RegGetMachinePolicy(&m_gpPolicy);

            if( m_gpPolicy.fPolicyDisableWallpaper == 0 )
            { 
            
                hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
                if( SUCCEEDED (hr) && pUser != NULL && pInParams != NULL)
                {
                    bRet = pInParams->GetDWORD(m_szClientWallPaper, dwData);

                    if(!bRet || (dwData != 0 && dwData != 1))
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                        break;
                    }

                    pUser->fWallPaperDisabled = dwData;
            
                    hr = StackObj.m_pCfgComp->SetUserConfig((LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
            
                    if( SUCCEEDED( hr ))
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD( L"ReturnValue", WBEM_S_NO_ERROR );
                    }
                }
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;

                break;
            }
        }
        
    }while (0);

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }    

    return hr;
}


//=-----------------------

HRESULT CWin32_TSEnvironmentSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
    // return (WBEM_E_PROVIDER_NOT_CAPABLE);
    
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
   
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szClientWallPaper))
        ulRequiredProperties |= BIT_CLIENTWALLPAPER;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPath))
        ulRequiredProperties |= BIT_INITIALPROGRAMPATH;
    
    if (Query.IsPropertyRequired(m_szInitialProgramPolicy))
        ulRequiredProperties |= BIT_INITIALPROGRAMPOLICY;
    
    if (Query.IsPropertyRequired(m_szStartIn))
        ulRequiredProperties |= BIT_STARTIN;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList( &ulTerminals, &ulSize, &pWS );
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals ; ulNum++)
        { 
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;
            // Method 2
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSEnvironmentSetting@ExecQuery CreateNewInstance failed"  ));  
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString( m_szTerminalName, CHString( pWS[ulNum].Name ) );

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if (SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;
    
}



//=----------------------Win32_TSRemoteControlSettingsConfig---------------------


CWin32_TSRemoteControlSetting::CWin32_TSRemoteControlSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{

    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSRemoteControlSetting_ctor"));

        _tcscpy(m_szRemoteControlPolicy, _T("RemoteControlPolicy"));

        _tcscpy(m_szLevelOfControl, _T("LevelOfControl"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szRemoteControl, _T("RemoteControl"));        
    }

}

//=--------------------

CWin32_TSRemoteControlSetting::~CWin32_TSRemoteControlSetting ()
{
}



//=------------

BOOL CWin32_TSRemoteControlSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName;
    LONG  lSize ;
    PWS pWS = NULL;
    ULONGLONG ulRequiredProperties = 0;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSRemoteControlSetting@Getobject invalid pointer"  ));  
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szRemoteControlPolicy))
        ulRequiredProperties |= BIT_REMOTECONTROLPOLICY;
    
    if (Query.IsPropertyRequired(m_szLevelOfControl))
        ulRequiredProperties |= BIT_LEVELOFCONTROL;
    
    if( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );
        }               
    }

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;    
}

//=--------------------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSRemoteControlSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSRemoteControlSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    { 

		
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
			
            CInstance* pInstance = CreateNewInstance(pMethodContext);            

            if( pInstance == NULL)
            {
                ERR((TB,"TSRemoteControlSetting@EnumerateInstances CreateNewInstance failed"  ));               
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSRemoteControlSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr  ));    
            
            hr = LoadPropertyValues( pInstance, BIT_ALL_PROPERTIES, &pWS[ulNum] );
            
            if ( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();
            }
			
            pInstance->Release( );

        } 
        
    }  

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    
    if ( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }
        
        TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: GetTerminalName"  ));
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: GetUserConfig ret 0x%x\n" , hr  ));
        
        if ( SUCCEEDED (hr) && pUser != NULL )
        {
            
            if( ulRequiredProperties & BIT_REMOTECONTROLPOLICY)
            {
                
                pInstance->SetDWORD(m_szRemoteControlPolicy, pUser->fInheritShadow);
				
            }
            TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: RemoteControlPolicy"  ));
            
            if( ulRequiredProperties & BIT_LEVELOFCONTROL)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyShadow != 0 )
                {
                    pInstance->SetDWORD(m_szLevelOfControl, m_gpPolicy.Shadow);
                }
                else
                {                
                    pInstance->SetDWORD(m_szLevelOfControl, pUser->Shadow);
                }
            }
            TRC2((TB,"TSRemoteControlSetting@LoadPropertyValues: LevelOfControl"));            
        }                  

    }   

    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);
        
    }
	
    return hr;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    LONG  lSize;
    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED( hr ) && pUser != NULL )
        {
            if( Instance.GetDWORD( m_szRemoteControlPolicy, dwData ) )
            {
                pUser->fInheritShadow = dwData;
                
                if ( dwData != 0 && dwData != 1 )
                {
                    hr = WBEM_E_INVALID_PARAMETER;
                    
                    break;
                }
                
                hr = StackObj.m_pCfgComp->SetUserConfig((LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                
                if( SUCCEEDED( hr ))
                {
                    hr = StackObj.m_pCfgComp->ForceUpdate();
                }
            }
            
        }
        
        else
        {
            TRC2((TB,"TSRemoteControlSetting@PutInstance: ret 0x%x\n" , hr ));
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if(( SUCCEEDED( hr ) ) && (pErrorInstance != NULL))
            {
                
                LoadString( g_hInstance , IDS_ERR_PUTTSRCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                
                LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                
                pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSREMOTECONTROLSETTING_Prov);
                pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                
                IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                if (pObj != NULL)
                {
                    
                    MethodContext *pMethodContext = Instance.GetMethodContext();  
                    
                    if (pMethodContext != NULL)
                    {
                        pMethodContext->SetStatusObject(pObj);
                    }
                    
                    pObj->Release();
                }
                pErrorInstance->Release();
                
            }
            TRC2((TB,"TSRemoteControlSetting@PutInstance: GetInstanceByPath ret 0x%x\n" , hr ));           
        }
    }while (0);

    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSRemoteControlSetting::ExecMethod ( const CInstance& Inst,
                                                          const BSTR bstrMethodName,
                                                          CInstance *pInParams,
                                                          CInstance *pOutParams,
                                                          long lFlags)
                                                          
{
	
    HRESULT hr= WBEM_E_NOT_FOUND;
    CHString chTermName;    

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
        
    
    // Sets the property LevelOfControl which specifies the level of control
    // which is one of Disable, EnableInputNotify, EnableInputNoNotify, 
    // EnableNoInputNotify, EnableNoInputNoNotify. 

    // uint32 RemoteControl([In] uint32 LevelOfControl);
    
    if( _wcsicmp( bstrMethodName, m_szRemoteControl ) == 0 )
    {
        
        DWORD dwRemoteData = 0;
        DWORD dwData = 0;
        DWORD dwStatus = 0;
        bool bRet;
        LONG lSize;
        PUSERCONFIG pUser = NULL;
        
        if ( pInParams != NULL )
        {
            do
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyShadow == 0 )
                { 
            
                    hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE );
            
                    if ( SUCCEEDED( hr ) && pUser != NULL )
                    {
                        dwRemoteData = pUser->fInheritShadow;
                    
                        if ( SUCCEEDED( hr ) && ( dwRemoteData == 0 ))
                        {  
                            bRet = pInParams->GetDWORD(m_szLevelOfControl, dwData);
                        
                            if ( !bRet || ( dwData > 4 ) )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->Shadow = ( SHADOWCLASS )dwData;
                        
                            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                        
                            if( SUCCEEDED( hr ) && pOutParams )
                            {
                                hr = StackObj.m_pCfgComp->ForceUpdate();

                                pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                            
                            }
                            TRC2((TB,"TSRemoteControlSetting@ExecMethod: LevelOfControl ret 0x%x\n" , hr ));
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;
                        }
                    
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }

            }while (0);
            
            if ( pUser != NULL )
            {
                CoTaskMemFree(pUser);
            }
        }      
    }

    return hr;
}

//=-------------------------------

HRESULT CWin32_TSRemoteControlSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szRemoteControlPolicy))
        ulRequiredProperties |= BIT_REMOTECONTROLPOLICY;
    
    if (Query.IsPropertyRequired(m_szLevelOfControl))
        ulRequiredProperties |= BIT_LEVELOFCONTROL;
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals ; ulNum++)
        {
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSRemoteControlSetting@ExecQuery: CreateNewInstance failed" ));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }

    return hr;
    
}




//=----------------------Win32_TSClientSetting---------------------


CWin32_TSClientSetting::CWin32_TSClientSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{  
    if ( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSClientSetting_ctor"));

        _tcscpy(m_szConnectionPolicy, _T("ConnectionPolicy"));

        _tcscpy(m_szConnectClientDrivesAtLogon, _T("ConnectClientDrivesAtLogon"));

        _tcscpy(m_szConnectPrinterAtLogon, _T("ConnectPrinterAtLogon"));

        _tcscpy(m_szDefaultToClientPrinter, _T("DefaultToClientPrinter"));

        _tcscpy(m_szWindowsPrinterMapping, _T("WindowsPrinterMapping"));

        _tcscpy(m_szLPTPortMapping, _T("LPTPortMapping"));

        _tcscpy(m_szCOMPortMapping, _T("COMPortMapping"));

        _tcscpy(m_szDriveMapping, _T("DriveMapping"));

        _tcscpy(m_szAudioMapping, _T("AudioMapping"));

        _tcscpy(m_szClipboardMapping, _T("ClipboardMapping"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szPropertyName, _T("PropertyName"));

        _tcscpy(m_szValue, _T("Value"));

        _tcscpy(m_szConnectionSettings, _T("ConnectionSettings"));

        _tcscpy(m_szSetClientProperty, _T("SetClientProperty"));

        _tcscpy(m_szColorDepth, _T("ColorDepth"));

        _tcscpy(m_szSetColorDepth, _T("SetColorDepth"));

        _tcscpy(m_szColorDepthPolicy, _T("ColorDepthPolicy"));

        _tcscpy(m_szSetColorDepthPolicy, _T("SetColorDepthPolicy"));
        
               
    }
    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------

CWin32_TSClientSetting::~CWin32_TSClientSetting ()
{
    
}


//=-----------------

BOOL CWin32_TSClientSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------

HRESULT CWin32_TSClientSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName; 
    LONG  lSize ;
    ULONGLONG ulRequiredProperties = 0;
    PWS pWS = NULL;
//    PUSERCONFIG pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSClientSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szAudioMapping))
        ulRequiredProperties |= BIT_AUDIOMAPPING;
    
    if (Query.IsPropertyRequired(m_szClipboardMapping))
        ulRequiredProperties |= BIT_CLIPBOARDMAPPING;
    
    if (Query.IsPropertyRequired(m_szCOMPortMapping))
        ulRequiredProperties |= BIT_COMPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szConnectClientDrivesAtLogon))
        ulRequiredProperties |= BIT_CONNECTCLIENTDRIVESATLOGON;
    
    if (Query.IsPropertyRequired(m_szConnectionPolicy))
        ulRequiredProperties |= BIT_CONNECTIONPOLICY;
    
    if (Query.IsPropertyRequired(m_szConnectPrinterAtLogon))
        ulRequiredProperties |= BIT_CONNECTPRINTERATLOGON;
    
    if (Query.IsPropertyRequired(m_szDefaultToClientPrinter))
        ulRequiredProperties |= BIT_DEFAULTTOCLIENTPRINTER;
    
    if (Query.IsPropertyRequired(m_szDriveMapping))
        ulRequiredProperties |= BIT_DRIVEMAPPING;
    
    if (Query.IsPropertyRequired(m_szLPTPortMapping))
        ulRequiredProperties |= BIT_LPTPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szWindowsPrinterMapping))
        ulRequiredProperties |= BIT_WINDOWSPRINTERMAPPING;

    if (Query.IsPropertyRequired(m_szColorDepth))
        ulRequiredProperties |= BIT_COLORDEPTH;

    if (Query.IsPropertyRequired(m_szColorDepthPolicy))
        ulRequiredProperties |= BIT_COLORDEPTHPOLICY;


    if ( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS );

        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues( pInstance, ulRequiredProperties, pWS );
        }                
    }

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }	
    return hr;
    
}
//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSClientSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSClientSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    PWS  pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
        
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   		
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;

            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSClientSetting@EnumerateInstances: CreateNewInstance failed" ));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSClientSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr ));

            hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ ulNum ] );
            
            if( SUCCEEDED( hr ) )
            {
                hr = pInstance->Commit();

            }
            pInstance->Release( );
        }
        
    }  

    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }
  
    return hr;
}
//=--------------------

HRESULT CWin32_TSClientSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lSize ;
    DWORD dwData = 0;
    BOOL bData = 0;
    DWORD dwStatus = 0;
    USERCONFIGW* pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL  )
    {
        ERR((TB,"TSClientSetting@LoadPropertyValues: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    
    if( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
	        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }

        TRC2((TB,"TSClientSetting@LoadPropertyValues: GetTerminalName"));
        
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
        
        TRC2((TB,"TSClientSetting@LoadPropertyValues ret 0x%x\n" , hr));
        
        if( SUCCEEDED (hr) && pUser != NULL )
        {            
            if( ulRequiredProperties & BIT_CONNECTIONPOLICY)
            {                
                pInstance->SetDWORD(m_szConnectionPolicy, pUser->fInheritAutoClient);     
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ConnectionPolicy" ));
            }
                     
            
            if( ulRequiredProperties & BIT_CONNECTCLIENTDRIVESATLOGON)
            {  
                
                pInstance->SetDWORD(m_szConnectClientDrivesAtLogon, pUser->fAutoClientDrives);      
                
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues ConnectClientDrives"));
            }            
                           
            
            if( ulRequiredProperties & BIT_CONNECTPRINTERATLOGON)
            {                  
                pInstance->SetDWORD(m_szConnectPrinterAtLogon, pUser->fAutoClientLpts);                
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ConnectPrinter"));
            }
            
            
            if( ulRequiredProperties & BIT_DEFAULTTOCLIENTPRINTER)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyForceClientLptDef != 0 )
                {
                    pInstance->SetDWORD(m_szDefaultToClientPrinter, m_gpPolicy.fForceClientLptDef);
                }
                else
                {
                    pInstance->SetDWORD(m_szDefaultToClientPrinter, pUser->fForceClientLptDef); 
                }
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: DefaultToClientPrinter"));
            }
                        
            
            if( ulRequiredProperties & BIT_LPTPORTMAPPING)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableLPT != 0 )
                {
                    pInstance->SetDWORD(m_szLPTPortMapping, m_gpPolicy.fDisableLPT);
                }
                else
                {
                    pInstance->SetDWORD(m_szLPTPortMapping, pUser->fDisableLPT);
                }                
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: WindowsPrinterMapping"));
            }
                        
            
            if( ulRequiredProperties & BIT_WINDOWSPRINTERMAPPING)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCpm != 0 )
                {
                    pInstance->SetDWORD(m_szWindowsPrinterMapping, m_gpPolicy.fDisableCpm);
                }
                else
                {
                    pInstance->SetDWORD(m_szWindowsPrinterMapping, pUser->fDisableCpm);
                }    
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: LPTPortMapping"));            
            }
            
            
            if( ulRequiredProperties & BIT_COMPORTMAPPING)
            {  
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCcm != 0 )
                {
                    pInstance->SetDWORD(m_szCOMPortMapping, m_gpPolicy.fDisableCcm);
                }
                else
                {
                    pInstance->SetDWORD(m_szCOMPortMapping, pUser->fDisableCcm);
                }
                 
                TRC2((TB,"TSClientSetting@LoadPropertyValues: COMPortMapping"));
            }
            
            
            if( ulRequiredProperties & BIT_DRIVEMAPPING)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCdm != 0 )
                {
                    pInstance->SetDWORD(m_szDriveMapping, m_gpPolicy.fDisableCdm);                                                   
                }
                else
                {
                    pInstance->SetDWORD(m_szDriveMapping, pUser->fDisableCdm);
                } 

                TRC2((TB,"TSClientSetting@LoadPropertyValues: DriveMapping"));
            }
            
            
            if( ulRequiredProperties & BIT_AUDIOMAPPING)
            { 
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableCam != 0 )
                {
                    pInstance->SetDWORD(m_szAudioMapping, m_gpPolicy.fDisableCam);
                }
                else
                {
                    pInstance->SetDWORD(m_szAudioMapping, pUser->fDisableCam);
                }
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: AudioMapping"));
            }
            
            
            if( ulRequiredProperties & BIT_CLIPBOARDMAPPING)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyDisableClip != 0 )
                {
                    pInstance->SetDWORD(m_szClipboardMapping, m_gpPolicy.fDisableClip);
                }
                else
                {
                    pInstance->SetDWORD(m_szClipboardMapping, pUser->fDisableClip);
                }
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues ClipboardMapping"));
            }
            
            if( ulRequiredProperties & BIT_COLORDEPTHPOLICY)
            {  
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth != 0 )
                {
                    dwData = 0;
                }
                else
                {  
                    hr = StackObj.m_pCfgComp->GetColorDepth( pWS->Name, &bData, &dwStatus);
                   
                    dwData = bData;
                }   
                pInstance->SetDWORD(m_szColorDepthPolicy, dwData);    
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ColorDepthPolicy" ));
            }

            if( ulRequiredProperties & BIT_COLORDEPTH)
            {  
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth != 0 )
                {
                    pInstance->SetDWORD(m_szColorDepth, m_gpPolicy.ColorDepth);
                }
                else
                { 
                    pInstance->SetDWORD(m_szColorDepth, pUser->ColorDepth);
                   
                }       
                
                TRC2((TB,"TSClientSetting@LoadPropertyValues: ColorDepth" ));
            }
            
        }        
    }
    
    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }
	
    return hr;
    
}

//=--------------------
HRESULT CWin32_TSClientSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    DWORD dwStatus = 0;
    LONG lSize;
    PUSERCONFIGW pUser = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0 )
    {
        return WBEM_E_NOT_SUPPORTED;
    }
    
    hr = StackObj.m_pCfgComp->GetUserConfig( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
    
    do
    {
        if( SUCCEEDED (hr) && pUser != NULL )
        {
            Instance.GetDWORD(m_szConnectionPolicy, dwData);
            
            if( dwData != 0 && dwData != 1 )
            {
                hr = WBEM_E_INVALID_PARAMETER;
                
                break;
            }
            
            pUser->fInheritAutoClient = dwData;                        
            
            hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );    
            
            if( SUCCEEDED( hr ) )
            {
                hr = StackObj.m_pCfgComp->ForceUpdate();
            }
        }
        
        else
        {
            TRC2((TB,"TSClientSetting@PutInstance: ret 0x%x\n" , hr));           
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);

            CInstance *pErrorInstance = NULL;            
            
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSClientSetting@PutInstance: ret 0x%x\n" , hr));

                if (pErrorInstance != NULL)
                {                    
                    LoadString( g_hInstance , IDS_ERR_PUTTSCCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );

                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );

                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);

                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSCLIENTSETTING_Prov);

                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();

                    if (pObj != NULL)
                    {                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        if (pMethodContext != NULL)
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    
                    pErrorInstance->Release();
                }
                
            }           
        }

    }while (0);
    
    if ( pUser != NULL )
    {
        CoTaskMemFree(pUser);        
    }
    
    return hr;
}

//=--------------------
HRESULT CWin32_TSClientSetting::ExecMethod ( const CInstance& Inst,
                                                   const BSTR bstrMethodName,
                                                   CInstance *pInParams,
                                                   CInstance *pOutParams,
                                                   long lFlags)
                                                   
{   
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PUSERCONFIG pUser = NULL;
    DWORD dwAutoData = 0;
    DWORD dwData = 0;
    DWORD dwStatus = 0;    
    LONG lSize;
    bool fValue;
    CHString chData;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    do
    {        
        
        if( pInParams != NULL )
        {
            // Sets the properties ClientConnectDrivesAtLogon, ConnectPrinterAtLogon 
            // and DefaultPrinterToClient. 
                      
            // uint32 ConnectSettings([In] uint32 ConnectClientDrivesAtLogon, [In] uint32 ConnectPrinterAtLogon, [In] uint32 DefaultToClientPrinter)
        
            if( _wcsicmp( bstrMethodName, m_szConnectionSettings ) == 0 )
            { 
                bool bRet;

                RegGetMachinePolicy(&m_gpPolicy);
                             
                hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
                if( SUCCEEDED (hr) && pUser != NULL )
                {
                    dwAutoData = pUser->fInheritAutoClient;
                
                    if( dwAutoData == 0 )
                    {                           
                        bRet = pInParams->GetDWORD(m_szConnectClientDrivesAtLogon, dwData);
                    
                        if ( !bRet || ( dwData != 0 && dwData != 1 ) )
                        {                            
                            hr = WBEM_E_INVALID_PARAMETER;
                        
                            break;
                        }
                    
                        
                        pUser->fAutoClientDrives = dwData;
                        
                    
                        bRet = pInParams->GetDWORD(m_szConnectPrinterAtLogon, dwData);
                    
                        if( !bRet || ( dwData != 0 && dwData != 1 ) )
                        {                            
                            hr = WBEM_E_INVALID_PARAMETER;
                        
                            break;
                        }
                        
                        pUser->fAutoClientLpts = dwData;                        
                    
                        bRet = pInParams->GetDWORD(m_szDefaultToClientPrinter, dwData);
                    
                        if( !bRet || ( dwData != 0 && dwData != 1 ) )
                        {                            
                            hr = WBEM_E_INVALID_PARAMETER;
                        
                            break;
                        }
                        

                        if( m_gpPolicy.fPolicyForceClientLptDef == 0 )
                        {                    
                            pUser->fForceClientLptDef = dwData;
                        }
                
                        hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );
                
                        TRC2((TB,"TSClientSetting@ExecMethod: ConnectSettings: ret 0x%x\n" , hr ));
                
                        if( pOutParams != NULL )
                        {
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                            
                        } 
                    }
                                 
                    else
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }
                }
            }

            else if( _wcsicmp( bstrMethodName, m_szSetColorDepthPolicy ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0; 
                bool bRet;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth == 0 )
                {  
                    TRC2((TB, "ColorDepth is not enabled by Group Policy."));                        
                      
                    bRet = pInParams->GetDWORD(m_szColorDepthPolicy, dwData);
                    

                    if ( !bRet || (dwData != 0 && dwData != 1 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    }                                        
                    
                    hr = StackObj.m_pCfgComp->SetColorDepth( (LPTSTR)(LPCTSTR) chTermName, dwData , &dwStatus );
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSClientSetting@ExecMethod:  ColorDepthPolicy ret 0x%x\n" , hr  ));
                    } 
                    
                }
                else
                {
                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                    
                }
                
            } 
            
            else if( _wcsicmp( bstrMethodName, m_szSetColorDepth ) == 0 )
            {
                
                dwData = 0;
                dwStatus = 0;
                bool bRet;
                BOOL bData = 0;
                
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyColorDepth == 0 )
                {  
                    TRC2((TB, "Condition to update fInheritColorDepth satisfied"));                        
                      
                    hr = StackObj.m_pCfgComp->GetColorDepth( (LPTSTR)(LPCTSTR) chTermName, &bData, &dwStatus);                  
                    

                    if( FAILED( hr ) || bData == 1)
                    {
                        hr = WBEM_E_INVALID_OPERATION;
                        
                        break;
                    }                                        

                    bRet = pInParams->GetDWORD(m_szColorDepth, dwData);
                    
                    if ( !bRet || (dwData < 1 || dwData > 4 ))
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                        
                        break;
                    } 

                    TCHAR tchRegPath[ MAX_PATH ] = WINSTATION_REG_NAME;

                    HKEY hKey = NULL;

                    if (MAX_PATH < _tcslen(WINSTATION_REG_NAME)+ 2+ chTermName.GetLength())
                    {
                        hr = WBEM_E_INVALID_PARAMETER;
                    }

                    lstrcat( tchRegPath, L"\\");

                    lstrcat( tchRegPath , chTermName );                
                    
                    hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                             tchRegPath ,
                             0,
                             KEY_READ | KEY_WRITE,
                             &hKey );

                    if( SUCCEEDED( hr)  && hKey != NULL)
                    {

                        hr = RegSetValueEx( hKey ,
                                        TEXT("ColorDepth"),
                                        0 ,
                                        REG_DWORD,
                                        ( LPBYTE )&dwData ,
                                        sizeof(DWORD) );   
                        
                        RegCloseKey( hKey );
                    }
                    
                    if( SUCCEEDED( hr ) && pOutParams != NULL )
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        TRC2((TB,"TSClientSetting@ExecMethod:  ColorDepth ret 0x%x\n" , hr  ));
                    } 
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                    }
                    
                }
                else
                {                    
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;                    
                }
                
            }
        
            //  PropertyName is a string enumeration of the properties: 
            //  LPTPortMapping, COMPortMapping, AudioMapping ClipboardMapping and WindowsPrinterMapping.
            //  They are False or True according as if the Value is set to 0 or 1 respectively.
                

            //  uint32 SetClientProperty([In] string PropertyName, [In] boolean Value)
        
            else if( _wcsicmp( bstrMethodName, m_szSetClientProperty) == 0 )
            {
                BOOL bRet = 0;
                fValue = 0;

                hr = StackObj.m_pCfgComp->GetUserConfig((LPTSTR)(LPCTSTR) chTermName, &lSize, &pUser, TRUE);
            
                RegGetMachinePolicy(&m_gpPolicy);
            
                if( SUCCEEDED( hr ) && pUser != NULL && pOutParams != NULL)
                {
                    pInParams->GetCHString(m_szPropertyName, chData);                
                
                    if( chData.CompareNoCase(m_szLPTPortMapping) == 0 )
                    {
                        bRet = pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableLPT ret 0x%x\n", m_gpPolicy.fPolicyDisableLPT ));
                    
                        if( m_gpPolicy.fPolicyDisableLPT == 0 )
                        {   
                            TRC2((TB,"Condition to update fPolicyDisableLPT satisfied" ));
                        
                            if( !bRet || (fValue != 0 && fValue != 1 ))
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableLPT = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    
                    }
                    else if( chData.CompareNoCase(m_szCOMPortMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableCcm ret 0x%x\n", m_gpPolicy.fPolicyDisableCcm ));
                    
                        if( (m_gpPolicy.fPolicyDisableCcm) == 0)
                        {
                            TRC2((TB,"Condition to update fPolicyDisableCcm satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCcm = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    
                    }
                
                    else if( chData.CompareNoCase(m_szAudioMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);

                        TRC2((TB,"m_gpPolicy.fPolicyDisableCam ret 0x%x\n", m_gpPolicy.fPolicyDisableCam ));                    
                    
                        if( (m_gpPolicy.fPolicyDisableCam) == 0)
                        {                        
                            if(fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCam = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    }
                
                    else if( chData.CompareNoCase(m_szClipboardMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableClip ret 0x%x\n", m_gpPolicy.fPolicyDisableClip ));                    
                    
                        if( (m_gpPolicy.fPolicyDisableClip) == 0 )
                        {
                            TRC2((TB,"Condition to update fPolicyDisableClip satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableClip = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    }
                    else if( chData.CompareNoCase(m_szWindowsPrinterMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableCpm ret 0x%x\n", m_gpPolicy.fPolicyDisableCpm ));
                    
                        if( (m_gpPolicy.fPolicyDisableCpm) == 0)
                        {
                            TRC2((TB,"Condition to update fPolicyDisableCpm satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCpm = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    }
                    else if( chData.CompareNoCase(m_szDriveMapping) == 0 )
                    {
                        pInParams->Getbool(m_szValue, fValue);
                    
                        TRC2((TB,"m_gpPolicy.fPolicyDisableCdm ret 0x%x\n", m_gpPolicy.fPolicyDisableCdm ));
                    
                        if( (m_gpPolicy.fPolicyDisableCdm) == 0)
                        {
                            TRC2((TB,"Condition to update fPolicyDisableCdm satisfied" ));
                        
                            if( fValue != 0 && fValue != 1 )
                            {
                                hr = WBEM_E_INVALID_PARAMETER;
                            
                                break;
                            }
                        
                            pUser->fDisableCdm = fValue;
                        
                            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                        
                        }
                        else
                        {
                            hr = WBEM_E_INVALID_OPERATION;

                            break;
                        }
                    
                    }
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD;
                        break;
                    }
                
                    hr = StackObj.m_pCfgComp->SetUserConfig( (LPTSTR)(LPCTSTR) chTermName, lSize, pUser , &dwStatus );

                    if( SUCCEEDED( hr ))
                    {
                        hr = StackObj.m_pCfgComp->ForceUpdate();
                    }                
                }
            }
        }
        
    }while (0);
    
    if( pUser != NULL )
    {
        CoTaskMemFree( pUser );        
    }

    return hr;   
}

//=-----------------
HRESULT CWin32_TSClientSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szAudioMapping))
        ulRequiredProperties |= BIT_AUDIOMAPPING;
    
    if (Query.IsPropertyRequired(m_szClipboardMapping))
        ulRequiredProperties |= BIT_CLIPBOARDMAPPING;
    
    if (Query.IsPropertyRequired(m_szCOMPortMapping))
        ulRequiredProperties |= BIT_COMPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szConnectClientDrivesAtLogon))
        ulRequiredProperties |= BIT_CONNECTCLIENTDRIVESATLOGON;
    
    if (Query.IsPropertyRequired(m_szConnectionPolicy))
        ulRequiredProperties |= BIT_CONNECTIONPOLICY;
    
    if (Query.IsPropertyRequired(m_szConnectPrinterAtLogon))
        ulRequiredProperties |= BIT_CONNECTPRINTERATLOGON;
    
    if (Query.IsPropertyRequired(m_szDefaultToClientPrinter))
        ulRequiredProperties |= BIT_DEFAULTTOCLIENTPRINTER;
    
    if (Query.IsPropertyRequired(m_szDriveMapping))
        ulRequiredProperties |= BIT_DRIVEMAPPING;
    
    if (Query.IsPropertyRequired(m_szLPTPortMapping))
        ulRequiredProperties |= BIT_LPTPORTMAPPING;
    
    if (Query.IsPropertyRequired(m_szWindowsPrinterMapping))
        ulRequiredProperties |= BIT_WINDOWSPRINTERMAPPING;

    if (Query.IsPropertyRequired(m_szColorDepth))
        ulRequiredProperties |= BIT_COLORDEPTH;

    if (Query.IsPropertyRequired(m_szColorDepthPolicy))
        ulRequiredProperties |= BIT_COLORDEPTHPOLICY;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals ; ulNum++)
        {   
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;
            // Method 2 
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                CInstance* pInstance = CreateNewInstance(pMethodContext);
                
                if( pInstance == NULL)
                {
                    ERR((TB,"TSClientSetting@ExecQuery: CreateNewInstance failed" ));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;

                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }    
    	
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }

    return hr;    
}



//=----------------------Win32_TSNetworkAdapterSetting---------------------


CWin32_TSNetworkAdapterSetting::CWin32_TSNetworkAdapterSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{    
    if( g_hInstance != NULL)
    {
        TRC2((TB, "CWin32_TSNetworkAdapterSetting_ctor"));
        
        _tcscpy(m_szNetworkAdapterID, _T("NetworkAdapterID"));

        _tcscpy(m_szNetworkAdapterIP, _T("NetworkAdapterIP"));

        _tcscpy(m_szNetworkAdapterName, _T("NetworkAdapterName"));

        _tcscpy(m_szMaximumConnections, _T("MaximumConnections"));

        _tcscpy(m_szSelectNetworkAdapterIP, _T("SelectNetworkAdapterIP"));

        _tcscpy(m_szSelectAllNetworkAdapters, _T("SelectAllNetworkAdapters"));
       
        _tcscpy(m_szTerminalName, _T("TerminalName"));


    }
    
    RegGetMachinePolicy(&m_gpPolicy);
}
//=--------------------
CWin32_TSNetworkAdapterSetting::~CWin32_TSNetworkAdapterSetting ()
{
    
}

//=---------------
BOOL CWin32_TSNetworkAdapterSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for (DWORD x=0; x < dwSize; x++)
    {
        if (asArray[x].CompareNoCase(pszString) == 0)
        {
            return TRUE;
        }
    }
    
    return FALSE;
}


//=--------------------
HRESULT CWin32_TSNetworkAdapterSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{ 	
    HRESULT     hr  = WBEM_E_NOT_FOUND;
    PWS         pWS = NULL;  
    LONG        lSize;
    ULONGLONG   ulRequiredProperties = 0;
    CHString    chTermName;
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    if( pInstance == NULL )
    {
        ERR((TB,"TSNetworkAdapterSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if(chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if(chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szNetworkAdapterID))
        ulRequiredProperties |= BIT_NETWORKADAPTERID;
    
    if (Query.IsPropertyRequired(m_szMaximumConnections))
        ulRequiredProperties |= BIT_MAXIMUMCONNECTIONS;
    
    if ( pInstance != NULL )
    {
        hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
        
        if( SUCCEEDED( hr ) && pWS != NULL )
        {
            hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS );            
        }               
    }
    
    if ( pWS != NULL )
    {
        CoTaskMemFree(pWS);        
    }

    return hr;
}

//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSNetworkAdapterSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSNetworkAdapterSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    
    HRESULT hr = WBEM_S_NO_ERROR;    
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    PWS  pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
        
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSNetworkAdapterSetting@EnumerateInstances: CreateNewInstance failed" ));               
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            TRC2((TB,"TSNetworkAdapterSetting@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr ));

            if( _tcsicmp( pWS[ulNum].pdName, L"Console") != 0 )
            {

                hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum] );
            
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                pInstance->Release( );
            }
        }
        
    }

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }
    
    return hr;
}
//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{    
    HRESULT hr = WBEM_S_NO_ERROR; 
    PUSERCONFIGW pUser = NULL;
    LONG lSize ;
    ULONG ulNAdapters =0;
    DWORD dwData = 0;    
    DWORD dwStatus = 0;
    int i = 0;
    TCHAR tch = ';';		    
    TCHAR tchGuid[ GUID_LENGTH ];
    PGUIDTBL pGuidtbl = NULL;
    CHString chGuid;
    CHString chAllGuids;
    CHString chName;    
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSNetworkAdapterSetting@LoadPropertyValues: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;       
    }
    

    if( pInstance != NULL && pWS != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME)
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);        
        }
    
        hr = StackObj.m_pCfgComp->GetUserConfig(pWS->Name, &lSize, &pUser, TRUE);
    
        TRC2((TB,"TSNetworkAdapterSetting@LoadPropertyValues: GetUserConfig ret 0x%x\n" , hr));
    
        if( SUCCEEDED( hr ) && pUser != NULL )
        {            
            if( ulRequiredProperties & BIT_NETWORKADAPTERID)
            {                
                pInstance->SetDWORD(m_szNetworkAdapterID, pWS->LanAdapter);               
            }
            TRC2((TB,"TSNetworkAdapterSetting@LoadPropertyValues: NetworkAdapterID"));      
            
            if( ulRequiredProperties & BIT_MAXIMUMCONNECTIONS)
            {
                RegGetMachinePolicy(&m_gpPolicy);

                if( m_gpPolicy.fPolicyMaxInstanceCount != 0 )
                {
                    pInstance->SetDWORD(m_szMaximumConnections, m_gpPolicy.MaxInstanceCount);                   
                }
                else
                {                
                    pInstance->SetDWORD(m_szMaximumConnections, pWS->uMaxInstanceCount);
                    
                }
            }
            TRC2((TB,"TSNetworkAdapterSetting@LoadPropertyValues: MaxConnections")); 
                        
            
            hr = StackObj.m_pCfgComp->GetLanAdapterList2(pWS->pdName, &ulNAdapters , &pGuidtbl ); 

            chAllGuids.Empty();
            chGuid.Empty();
            
            if( pWS->LanAdapter != ((ULONG)-1))
            {
                StringFromGUID2 (( pGuidtbl )[ pWS->LanAdapter ].guidNIC, tchGuid, ARRAYSIZE(tchGuid));            

                chGuid.Format (L"%s", tchGuid);
            
                pInstance->SetCharSplat(m_szNetworkAdapterID, tchGuid);     
            
                chName = ( pGuidtbl )[ pWS->LanAdapter ].DispName;                  
            
                pInstance->SetCHString(m_szNetworkAdapterName, chName);
            }            
            else
            {
                pInstance->SetCHString(m_szNetworkAdapterName, L"");
            }                        
        }          
    }

    if( pUser != NULL )
    {
        CoTaskMemFree(pUser);
    }

    if( pGuidtbl != NULL )
    {
        CoTaskMemFree(pGuidtbl);
    }
    
    return S_OK;
    
}
//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::PutInstance ( const CInstance &Instance, long lFlags)
{	
    HRESULT hr= WBEM_S_NO_ERROR;
    CHString chTermName ;
    DWORD dwData = 0;
    LONG lSize;
    DWORD dwStatus = 0;
    PWS  pWS = NULL;
    BOOL bRet = 0;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}    
    
    Instance.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
    
    RegGetMachinePolicy( &m_gpPolicy );
    
    do
    {
        if( SUCCEEDED (hr) && pWS != NULL )
        {
            bRet = Instance.GetDWORD(m_szMaximumConnections, dwData);

            TRC2((TB,"m_gpPolicy.fPolicyMaxInstanceCount ret 0x%x\n", m_gpPolicy.fPolicyMaxInstanceCount));
            
            if( m_gpPolicy.fPolicyMaxInstanceCount == 0  && bRet )
            { 
                TRC2((TB,"m_gpPolicy.fPolicyMaxInstanceCount satisfied"));
                

                pWS->uMaxInstanceCount = dwData;
                
                hr = StackObj.m_pCfgComp->UpDateWS( pWS, BIT_ALL_PROPS , &dwStatus, TRUE ); 
            }
            else
            {
                hr = WBEM_E_INVALID_OPERATION;

                break;
            }          
        }
        
        else
        {
            TRC2((TB,"TSNetworkAdapterSetting@PutInstance ret 0x%x\n" , hr));  
            
            CHString sRelPath;
            
            Instance.GetCHString(L"__RelPath", sRelPath);
            CInstance *pErrorInstance = NULL;
                        
            hr = CWbemProviderGlue::GetInstanceByPath(pErrorClass, &pErrorInstance );
            
            if( SUCCEEDED( hr ) )
            {
                TRC2((TB,"TSNetworkAdapterSetting@PutInstance ret 0x%x\n" , hr));

                if( pErrorInstance != NULL )
                {
                    LoadString( g_hInstance , IDS_ERR_PUTTSNCONFIG, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Description", tchErrorMessage);
                    
                    LoadString( g_hInstance , IDS_ERR_PUTINSTANCE, tchErrorMessage, SIZE_OF_BUFFER(tchErrorMessage) );
                    pErrorInstance->SetWCHARSplat(L"Operation", tchErrorMessage);
                    
                    pErrorInstance->SetCHString(L"ParameterInfo", sRelPath);
                    pErrorInstance->SetWCHARSplat(L"ProviderName", PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERSETTING_Prov);
                    pErrorInstance->SetDWORD(L"StatusCode", WBEM_E_INVALID_PARAMETER);
                    
                    
                    IWbemClassObject *pObj = pErrorInstance->GetClassObjectInterface();
                    if( pObj != NULL )
                    {
                        
                        MethodContext *pMethodContext = Instance.GetMethodContext();  
                        
                        
                        if( pMethodContext != NULL )
                        {
                            pMethodContext->SetStatusObject(pObj);
                        }
                        
                        pObj->Release();
                    }
                    pErrorInstance->Release();
                }
                
            }
        }
    }while (0);

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }

    return hr;
} 

//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::ExecMethod ( const CInstance& Inst,
                                                           const BSTR bstrMethodName,
                                                           CInstance *pInParams,
                                                           CInstance *pOutParams,
                                                           long lFlags)
                                                           
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    PWS pWS= NULL;
    PWS pWSList= NULL;
    CRegistry oRegObject;
    PIP_ADAPTER_INFO pAdapterInfo = NULL, pAdapt = NULL;
    PGUIDTBL pGuidtbl = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    if(_tcsicmp(chTermName, L"Console") == 0)
    {
        return WBEM_E_NOT_SUPPORTED;
    }
       
    // Selects all the LanAdapters on the machine.
                              
    // uint32 SelectAllNetworkAdapters();
    
    do
    {
        if( _wcsicmp(bstrMethodName, m_szSelectAllNetworkAdapters) == 0 )
        {
            
            ULONG ulTerminals = 0;
            ULONG ulNum = 0;
            LONG lNum = 0;
            ULONG ulSize = 0;
            DWORD dwStatus = 0;
            DWORD dwData = 0;
            LONG lSize;
            ULONG ulNumAdapters;
            CHStringArray a_chNetworkAdapterIDs;
            TCHAR tchGuid[ GUID_LENGTH ];
            
            hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
            
            if( SUCCEEDED (hr) )
            {
                
                hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWSList);
                
                if( SUCCEEDED( hr ) && pWSList != NULL )
                {   
                    for( ulNum = 0; ulNum < ulTerminals ; ulNum++ )
                    {  
                        if( pWSList[ulNum].LanAdapter == 0 )
                        {
                            hr = WBEM_E_ALREADY_EXISTS;
                            
                            goto Cleanup;
                        }
                    }  
                    
                    hr = StackObj.m_pCfgComp->GetWSInfo( (LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS );
                    
                    pWS->LanAdapter = 0;
                    
                    hr = StackObj.m_pCfgComp->UpDateWS( pWS, BIT_ALL_PROPS , &dwStatus, TRUE );
                }
                if( pOutParams != NULL && SUCCEEDED( hr ))
                {
                    TRC2((TB,"TSNetworkAdapterSetting@ExecMethod: GetNetworkAdapterIDs ret 0x%x\n" , hr));                    
                    
                    pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                }
            }                
            
            else
            {
                hr = WBEM_E_INVALID_OPERATION;
            }
        }
                
        
        else if( _wcsicmp(bstrMethodName, m_szSelectNetworkAdapterIP) == 0 )
        {
            ULONG ulTerminals = 0;
            ULONG ulSize = 0;
            DWORD dwStatus = 0;
            DWORD dwData = 0;
            LONG lSize = 0;            
            BOOL bUniq = FALSE;
            ULONG ulAdapters = 0;
            TCHAR tchRootKey[ MAX_PATH ] = L"";
            TCHAR tchGuid[ GUID_LENGTH ];
            TCHAR tchSearchGuid[GUID_LENGTH] = L"";
            TCHAR tchSelectGuid[ GUID_LENGTH ] = L"";
            HKEY hKey;    
            CHString chGuid;                       
            DWORD AdapterInfoSize;
            PIP_ADDR_STRING pAddrStr;
            DWORD Err = 0;
            CHString chAddress;
            chAddress.Empty();
            TCHAR tchAdd[MAX_PATH]=L"";
            TCHAR tchAdapterName[MAX_PATH] = L"";

            if(pInParams == NULL)
            {
                hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                break;
            }
            
            pInParams->GetCHString(m_szNetworkAdapterIP, chAddress);
            
            if( chAddress.IsEmpty() != 0 )
            {
                hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                
                break;
            }
           
              
            //
            // Enumerate all of the adapter specific information using the IP_ADAPTER_INFO structure.
            // Note:  IP_ADAPTER_INFO contains a linked list of adapter entries.
            //
            AdapterInfoSize = 0;
            GetAdaptersInfo(NULL, &AdapterInfoSize);

            if(AdapterInfoSize == 0)
            {               
                hr = WBEM_E_OUT_OF_MEMORY;
                    
                break;                
            }


            if( chAddress.GetLength() > GUID_LENGTH )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
                          

            // Allocate memory from sizing information
            if ((pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, AdapterInfoSize)) == NULL)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }
            // Get actual adapter information
            if ((Err = GetAdaptersInfo(pAdapterInfo, &AdapterInfoSize)) != 0)
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }

            pAdapt = pAdapterInfo;

            for (; pAdapt ; pAdapt = pAdapt->Next)
            {
                pAddrStr = &(pAdapt->IpAddressList);
                while(pAddrStr)
                {                    
                    MultiByteToWideChar(GetACP(), 0, pAddrStr->IpAddress.String, -1, tchAdd, MAX_PATH);
                 
                    MultiByteToWideChar(GetACP(), 0, pAdapt->AdapterName, -1, tchAdapterName, MAX_PATH);                    

                    if( !_tcsicmp(chAddress, tchAdd))
                        goto Label;

                    pAddrStr = pAddrStr->Next;
                }

            }

            hr = WBEM_E_INVALID_PARAMETER;
            goto Cleanup;
Label:           
            hr = StackObj.m_pCfgComp->GetWSInfo((LPTSTR)(LPCTSTR) chTermName, &lSize, &pWS);
            
            if( SUCCEEDED( hr ) && pWS != NULL)
            {
                hr = StackObj.m_pCfgComp->GetLanAdapterList2(pWS->pdName, &ulAdapters , &pGuidtbl );

                hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWSList);
                
                if( SUCCEEDED( hr ) && pGuidtbl != NULL)
                {
                    
                    for( int i = 0 ; i < ulAdapters ; i++)
                    {
                        StringFromGUID2( ( pGuidtbl )[ i ].guidNIC , tchGuid , ARRAYSIZE( tchGuid ) );                                            
                        
                        if( _tcsicmp( tchGuid, tchAdapterName ) != 0 )
                        {
                            continue;  
                        }

                        StringFromGUID2( ( pGuidtbl )[ pWS->LanAdapter ].guidNIC , tchSearchGuid , ARRAYSIZE( tchSearchGuid ) );

                        if( _tcsicmp( tchSearchGuid, tchAdapterName ) == 0 )
                        {
                            hr = WBEM_E_ALREADY_EXISTS;
                            goto Cleanup;
                        }                        

                        if( SUCCEEDED(hr) && ulTerminals == 2)
                        {               
                            bUniq = TRUE;
                        }
                        else
                        {
                            hr = StackObj.m_pCfgComp->IsNetWorkConnectionUnique(pWS->wdName, pWS->pdName, i, &bUniq);
                        }
                        
                        if( SUCCEEDED( hr ) && bUniq == TRUE )
                        {
                            pWS->LanAdapter = i;
                            
                            hr = StackObj.m_pCfgComp->UpDateWS( pWS, BIT_ALL_PROPS , &dwStatus, TRUE );
                            
                            if( SUCCEEDED( hr ))
                            {                                
                                if( SUCCEEDED( hr ) && pOutParams != NULL)
                                {
                                    pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);

                                    TRC2((TB,"TSNetworkAdapterSetting@ExecMethod: SelectNetworkAdapterIP ret 0x%x\n" , hr));
                                } 
                                
                            }
                        }
                        else
                        {                           
                            hr = WBEM_E_ALREADY_EXISTS;                                                       
                        }                        
                    }                    
                }
            }                       

            TRC2((TB,"TSNetworkAdapterSetting@ExecMethod: SelectNetworkAdapterIP ret 0x%x\n" , hr));
        }
        
        
        else
        {
            hr = WBEM_E_INVALID_METHOD;

            break;
        }
        
    }while (0);
    
Cleanup:

    if ( pGuidtbl != NULL )
    {
        CoTaskMemFree(pGuidtbl);
        pGuidtbl = NULL;                
    }

    if(pAdapterInfo)
    {
        GlobalFree(pAdapterInfo);
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree( pWS );        
    }

    if( pWSList != NULL )
    {
        CoTaskMemFree( pWSList );
    }

    return hr;
}

//=--------------------

HRESULT CWin32_TSNetworkAdapterSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szNetworkAdapterID))
        ulRequiredProperties |= BIT_NETWORKADAPTERID;
    
    if (Query.IsPropertyRequired(m_szMaximumConnections))
        ulRequiredProperties |= BIT_MAXIMUMCONNECTIONS;
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++ )
        {    
            if(_tcsicmp(pWS[ulNum].Name, L"Console") == 0)
                continue;

            // Method 2
            if( bGetAllInstances || IsInList(asNames, pWS[ulNum].Name) )
            {
                CInstancePtr pInstance (NULL);

                pInstance.Attach( CreateNewInstance( pMethodContext ) );
                
                if( pInstance == NULL)
                {
                    ERR((TB,"TSNetworkAdapterSetting@ExecQuery: CreateNewInstance failed"));                    
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }                
            }
        }
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    return hr;
    
}



//=----------------------Win32_TSPermissionsSettingsConfig---------------------


CWin32_TSPermissionsSetting::CWin32_TSPermissionsSetting (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{  
    if( g_hInstance != NULL )
    {

        TRC2((TB, "CWin32_TSPermissionsSetting_ctor"));

        _tcscpy(m_szPermissionPreSet, _T("PermissionPreSet"));

        _tcscpy(m_szPermissionMask, _T("PermissionMask"));

        _tcscpy(m_szAccountName, _T("AccountName"));

        _tcscpy(m_szAddAccount, _T("AddAccount"));

        _tcscpy(m_szRestoreDefaults, _T("RestoreDefaults"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

    }
}
//=--------------------
CWin32_TSPermissionsSetting::~CWin32_TSPermissionsSetting ()
{
    
}


//=---------------

BOOL CWin32_TSPermissionsSetting::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for( DWORD x=0; x < dwSize; x++ )
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}
//=---------------------

HRESULT CWin32_TSPermissionsSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;   
    LONG lSize;
    ULONGLONG ulRequiredProperties = 0;
    PWS  pWS = NULL;
    CHString chTermName;
	
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    TRC2((TB,"TSCFGWMI!CWin32_TSPermissionsSetting_GetObject"));
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSPermissionsSetting@GetObject: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH)
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;

    hr = StackObj.m_pCfgComp->GetWSInfo( ( LPTSTR )( LPCTSTR )chTermName, &lSize, &pWS);
    
    if( SUCCEEDED (hr) && pWS != NULL )        
    {
        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS);        
    }
    else
    {
        hr = WBEM_E_INVALID_OBJECT;
    }
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }	

    return hr ;


	/*

    HRESULT hr = WBEM_E_NOT_FOUND;
    
    // get the object for the Win32_Terminal
    CHString chsTerminal;
    CInstancePtr pTerminal(NULL);
    
    if( pInstance != NULL )
    {
        pInstance->GetCHString(L"Element", chsTerminal);

        MethodContext* pMethodContext = pInstance->GetMethodContext();    
        
        hr = CWbemProviderGlue::GetInstanceByPath(chsTerminal, &pTerminal, pMethodContext);
        TRC2((TB,"TSPermissionsSetting@GetObject: GetInstanceByPath ret 0x%x\n" , hr ));       
        
        do
        {
            if( SUCCEEDED( hr ) && pTerminal != NULL)
            {
                // Got the account.  Now, match it to the GUID.
                // first, generate a relpath with which to compare.
                CHString chTSAccountSettingInstance;
                CHString chTermName;
                DWORD dwIndex = 0;
                pTerminal->GetCHString(m_szTerminalName, chTermName); 
               
                // create a relpath for the sid
                CHString chsTSAccountSettingPath;
                chsTSAccountSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSAccount", m_szTerminalName, (LPCTSTR)chTermName);
        
                // get the SID path from the instance
              //  pInstance->SetCHString(L"Setting", chsTSAccountSettingPath);
                pInstance->SetCHString(L"Setting", chTSAccountSettingInstance);

                pInstance->SetCHString(m_szTerminalName, chTermName);         
            }
        }while (0);
    }
    return(hr);
	*/
       
}
//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSPermissionsSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSPermissionsSetting::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
	HRESULT hr = WBEM_S_NO_ERROR;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
   
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    TRC2((TB,"TSPermissionsSetting@EnumerateInstances: GetWinstationList ret 0x%x" , hr )); 
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {   
            CInstance* pInstance = CreateNewInstance(pMethodContext);
            
            if( pInstance == NULL)
            {
                ERR((TB,"TSPermissionsSetting@EnumerateInstances: CreateNewInstance failed"));                
                
                hr = WBEM_E_OUT_OF_MEMORY;
                
                break;
            }              
            
            hr = LoadPropertyValues( pInstance, BIT_ALL_PROPERTIES, &pWS[ ulNum ] );
            
            if (SUCCEEDED( hr ) ) 
            {
                hr = pInstance->Commit();       
            }            
            pInstance->Release( );
        }
    }

    if( pWS != NULL)
    {
        CoTaskMemFree(pWS);
    }

    return hr;
/*
    HRESULT hr = WBEM_E_FAILED;
    
    CInstancePtr pInstance;
    
    // Collections
    TRefPointerCollection<CInstance>	TerminalList;
    
    // Perform queries
    //================
    
    if( SUCCEEDED( hr = CWbemProviderGlue::GetInstancesByQuery(L"select TerminalName from Win32_Terminal",
        &TerminalList, pMethodContext) ) )
    {
        TRC2((TB,"TSPermissionsSetting@GetObject: EnumerateInstances: GetInstancesByQuery ret 0x%x\n" , hr ));
        
        REFPTRCOLLECTION_POSITION	pos;
        
        CInstancePtr pTerminal(NULL);
        
        if( TerminalList.BeginEnum( pos ) )
        {
            
            for( pTerminal.Attach(TerminalList.GetNext( pos ) ) ;
            SUCCEEDED( hr ) && ( pTerminal != NULL ) ;
            pTerminal.Attach(TerminalList.GetNext( pos ) ) )
            {
                
                CHString chTermName;
                pTerminal->GetCHString(m_szTerminalName, chTermName);
                
                // No maximum limit check
                
                if( chTermName.IsEmpty() != 0)
                {
                    return WBEM_E_ILLEGAL_NULL;
                }        
                
                pInstance.Attach( CreateNewInstance(pMethodContext) );
                
                if( NULL != pInstance )
                {
                    // set relpath to Terminal
                    CHString chsTerminalPath;
                    CHString chsFullTerminalPath;
                    pTerminal->GetCHString(L"__RELPATH", chsTerminalPath);
                    chsFullTerminalPath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", (LPCTSTR)chsTerminalPath);
                    pInstance->SetCHString(L"Element", chsFullTerminalPath);
                    pInstance->SetCHString(m_szTerminalName, chTermName);
                    
                    // create a relpath for the TSPermissionsSetting
                    CHString chsTSAccountSettingPath;
                    chsTSAccountSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSAccount", m_szTerminalName, (LPCTSTR)chTermName);
                    
                    // and set the reference in the association
                    pInstance->SetCHString(L"Setting", chsTSAccountSettingPath);
                    // to that relpath.                                       
                    
                    hr = pInstance->Commit();
                }	// end if
                
            } // pTerminal not null        
            TerminalList.EndEnum();        
        }	// IF BeginEnum        
    }
    return( hr );
    */
}
//=--------------------



HRESULT CWin32_TSPermissionsSetting::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS)
{	
    
    if( pInstance == NULL )
    {   
        ERR((TB,"TSPermissionsSetting@LoadPropertyValues: invalid pointer" ));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( ulRequiredProperties & BIT_TERMINALNAME )
    {                
        pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        
    } 
	
    return S_OK;
}

//=--------------------

HRESULT CWin32_TSPermissionsSetting::PutInstance ( const CInstance &Instance, long lFlags)
{
    return WBEM_E_PROVIDER_NOT_CAPABLE;
    
} 

//=--------------------


HRESULT CWin32_TSPermissionsSetting::ExecMethod ( const CInstance& Inst,
                                                        const BSTR bstrMethodName,
                                                        CInstance *pInParams,
                                                        CInstance *pOutParams,
                                                        long lFlags)
                                                        
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    CHString chAccountName;
    DWORD dwPermissionPreSet = 0;
    DWORD dwMask = 0;
    DWORD dwPermissionDenyMask = 0;
    BOOL fAudit = FALSE;
    DWORD dwStatus = 0;	
    IUserSecurity *pUserSecurity = NULL;
    PSID pSystemAcctSid = NULL;
    PSID pSid = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}        
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
    
    if( SUCCEEDED( hr ) && pUserSecurity != NULL )
    {       
        // Adds a new user or group to the existing set with 
        // the set of permissions defined.
        // uint32 Add([In] string AccountName, [In] uint32 PermissionPreSet)
        
        do
        {            
            if( _wcsicmp( bstrMethodName, m_szAddAccount ) == 0 )
            {
                if(pInParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }

                bool bRet;

                chAccountName.Empty();
                
                pInParams->GetCHString(m_szAccountName, chAccountName);
                                
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( chAccountName.IsEmpty() != 0)
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                    
                    break;
                }
                
                bRet = pInParams->GetDWORD(m_szPermissionPreSet, dwPermissionPreSet);
                
                
                if( !bRet || dwPermissionPreSet > 3 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( dwPermissionPreSet == 0 )
                {
                    dwMask = WINSTATION_GUEST_ACCESS;
                }
                
                else if( dwPermissionPreSet == 1 )
                {
                    dwMask = WINSTATION_USER_ACCESS;
                }
                
                else if( dwPermissionPreSet == 2 )
                {
                    dwMask = WINSTATION_ALL_ACCESS;
                }

                DWORD SidSize = 0;
                DWORD index = 0;
                
                dwStatus = GetUserSid(chAccountName, NULL, &pSid);
                if(dwStatus != ERROR_SUCCESS)
                {
                    hr = WBEM_E_FAILED;
                    break;
                }

                //
                // System account SID that we don't allow removing from our
                // winstation security descriptor.
                //
                // Local System            S-1-5-18
                // Local Service           S-1-5-19
                // Network Service         S-1-5-20
                //
                WELL_KNOWN_SID_TYPE RestrictedSid[] = {
                                        WinLocalSystemSid,
                                        WinLocalServiceSid,
                                        WinNetworkServiceSid                
                                    };
                DWORD numRestrictedSid = sizeof(RestrictedSid)/sizeof(RestrictedSid[0]);

                // Check if SID is one of system account, if so, reject removing it from
                // our winstation security.
                pSystemAcctSid = LocalAlloc( LPTR, SECURITY_MAX_SID_SIZE );
                if( NULL == pSystemAcctSid ) 
                {
                    dwStatus = GetLastError();
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }

                for( index = 0; index < numRestrictedSid; index++ )
                {
                    SidSize = SECURITY_MAX_SID_SIZE;
                    if( !CreateWellKnownSid(RestrictedSid[index], NULL, pSystemAcctSid, &SidSize) )
                    {
                        dwStatus = GetLastError();
                        hr = WBEM_E_FAILED;
                        break;
                    }

                    if( EqualSid(pSystemAcctSid, pSid) )
                    {
                        dwStatus = ERROR_NOT_SUPPORTED;
                        hr = WBEM_E_NOT_SUPPORTED;
                        break;
                    }
                }

                if(index < numRestrictedSid )
                {
                    break;
                }
                
                hr  = pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                    (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                    dwMask,         // winsta permission
                    FALSE ,
                    TRUE  ,              // t - allow permission f - deny perm 
                    FALSE ,              // t - new object f - donot change previous permission                                
                    FALSE ,           // t - enable auditing f - no auditing
                    &dwStatus ); 
                
                TRC2((TB,"TSPermissionsSetting@ExecMethod: Add ret 0x%x\n" , dwStatus ));                
                
                if( SUCCEEDED (dwStatus) && pOutParams != NULL )
                {
                    hr = StackObj.m_pCfgComp->ForceUpdate();

                    pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    
                } 
                
                else
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                    
                    TRC2((TB,"TSPermissionsSetting@ExecMethod: Modify ret 0x%x\n" , hr));
                    
                    break;
                }
                
            }

            
            
            // Deletes the permission from the specified user or group.
            // uint32 RestoreDefaults();
            
                
            else if( _wcsicmp(bstrMethodName, m_szRestoreDefaults) == 0 )
            {
    
                dwStatus = 0;
                DWORD dwLen = chTermName.GetLength();
                HKEY hKey = NULL;
                TCHAR* pBuffer = NULL;

                if(pOutParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }

                dwLen += (_tcslen(TS_PATH_WINSTATION) + 1);

                pBuffer = (PTCHAR)LocalAlloc(LMEM_ZEROINIT, (dwLen * sizeof(TCHAR)));                

                if( pBuffer == NULL)
                {
                    hr = WBEM_E_OUT_OF_MEMORY;

                    pOutParams->SetDWORD(L"ReturnValue", WBEM_E_OUT_OF_MEMORY);                                       

                    break;
                }

                _tcscpy(pBuffer, TS_PATH_WINSTATION);
                _tcscat(pBuffer, (LPTSTR)(LPCTSTR)chTermName);

                dwStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                                        pBuffer,
                                        0,
                                        KEY_WRITE ,
                                        &hKey );

                if( dwStatus != ERROR_SUCCESS )
                {
                    hr = WBEM_E_FAILED;   
                    
                    pOutParams->SetDWORD(L"ReturnValue", WBEM_E_FAILED);
                   
                    LocalFree(pBuffer);

                    pBuffer = NULL;

                    break;
                }

                dwStatus = RegDeleteValue(hKey, L"Security");

                hr = WBEM_S_NO_ERROR;

                hr = StackObj.m_pCfgComp->ForceUpdate();  
            
                pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);

                TRC2((TB,"TSPermissionsSetting@ExecMethod: RestoreDefaults ret 0x%x\n" , hr));  
                

                if(hKey)
                {
                    RegCloseKey(hKey);
                }  

                if(pBuffer)
                {
                    LocalFree(pBuffer);
                }
            }                        
            
            else
            {
                hr = WBEM_E_INVALID_METHOD;

                break;
            }
            
            
        }while(0);
    }

    if( pSystemAcctSid != NULL )
    {
        LocalFree( pSystemAcctSid );
    }
    if(pSid != NULL)
    {
        LocalFree(pSid);
    }

    if( pUserSecurity != NULL)
    {
        pUserSecurity->Release();
    }

    return hr;
    
}

//=-----------------

HRESULT CWin32_TSPermissionsSetting::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    PWS pWS = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}

    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for ( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            
            // Method 2 - Check if the query CAN be processed by 'name'. If yes, return only those names.
            
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                CInstance* pInstance = CreateNewInstance( pMethodContext );
                
                if( pInstance == NULL)
                {
                    TRC2((TB,"TSPermissionsSetting@ExecQuery: CreateNewInstance failed"));
                    
                    hr = WBEM_E_OUT_OF_MEMORY;
                    
                    break;
                }
                
                pInstance->SetCHString(m_szTerminalName, CHString(pWS[ulNum].Name));

                hr = LoadPropertyValues( pInstance, ulRequiredProperties, &pWS[ ulNum ] );
                
                if( SUCCEEDED( hr ) )
                {
                    hr = pInstance->Commit();
                }
                
                pInstance->Release();
            }
        }
    }

    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
    }

    return hr;
    
}

//=------------------------------

/*
CWin32_TSNetworkAdapterListSetting::CWin32_TSNetworkAdapterListSetting ( const CHString& setName, LPCTSTR pszNameSpace  )
: Provider (setName,pszNameSpace)
{
    

    if ( g_hInstance != NULL)
    {

        TRC2((TB, "CWin32_TSNetworkAdapterListSetting_ctor"));

        LoadString( g_hInstance , IDS_DEVICEID, m_szDeviceID, SIZE_OF_BUFFER(m_szDeviceID)-1 );   

        LoadString( g_hInstance , IDS_INDEX, m_szIndex, SIZE_OF_BUFFER(m_szIndex)-1 );

        LoadString( g_hInstance , IDS_DESCRIPTION, m_szDescription, SIZE_OF_BUFFER(m_szDescription)-1 );
        
        LoadString( g_hInstance , IDS_NETWORKADAPTERID, m_szNetworkAdapterID, SIZE_OF_BUFFER(m_szNetworkAdapterID)-1 );
        
        LoadString( g_hInstance , IDS_TERMINALNAME, m_szTerminalName, SIZE_OF_BUFFER(m_szTerminalName)-1 );

    }
}

CWin32_TSNetworkAdapterListSetting::~CWin32_TSNetworkAdapterListSetting ()
{
}



HRESULT CWin32_TSNetworkAdapterListSetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
    
    HRESULT hr = WBEM_E_FAILED;
    
    CInstancePtr pInstance;
    
    // Collections
    TRefPointerCollection<CInstance>	AdapterList;
    
    // Perform queries
    //================
    
    if (SUCCEEDED(hr = CWbemProviderGlue::GetInstancesByQuery(L"select DeviceID, Description, Index from Win32_NetworkAdapter",
        &AdapterList, pMethodContext)))
    {
        TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetInstancesByQuery ret 0x%x\n" , hr));
        
        REFPTRCOLLECTION_POSITION	pos;
        
        CInstancePtr	pAdapter(NULL);
        
        if( AdapterList.BeginEnum( pos ) )
        {
            
            for (pAdapter.Attach(AdapterList.GetNext( pos ) ) ;
            SUCCEEDED(hr) && ( pAdapter != NULL ) ;
            pAdapter.Attach(AdapterList.GetNext( pos ) ) )
            {
                
                CHString chTermName;
                CHString chDeviceID;
                CHString chDescription;
                DWORD dwIndex = 0;
                pAdapter->GetCHString(m_szDeviceID, chDeviceID);
                pAdapter->GetCHString(m_szDescription, chDescription);
                pAdapter->GetDWORD(m_szIndex, dwIndex);
                
                // No maximum limit check
                
                if( chDeviceID.IsEmpty() != 0)
                {
                    return WBEM_E_ILLEGAL_NULL;
                }        
                
                pInstance.Attach(CreateNewInstance(pMethodContext));
                
                if( NULL != pInstance )
                {
                    // set relpath to Adapter
                    CHString chsAdapterPath;
                    CHString chsFullAdapterPath;
                    pAdapter->GetCHString(L"__RELPATH", chsAdapterPath);
                    chsFullAdapterPath.Format(L"\\\\%s\\%s:%s", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", (LPCTSTR)chsAdapterPath);
                    pInstance->SetCHString(L"Element", chsFullAdapterPath);
                    pInstance->SetCHString(m_szDescription, chDescription);
                    pInstance->SetCHString(m_szDeviceID, chDeviceID);
                    pInstance->SetCHString(m_szNetworkAdapterID, chDeviceID);
                    pInstance->SetDWORD(m_szIndex, dwIndex);
                    
                    // create a relpath for the NetworkAdapterSettingsConfig
                    CHString chsNetworkAdapterSettingPath;
                    chsNetworkAdapterSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSNetworkAdapterSetting", m_szNetworkAdapterID, (LPCTSTR)chDeviceID);
                    
                    // and set the reference in the association
                    pInstance->SetCHString(L"Setting", chsNetworkAdapterSettingPath);
                    // to that relpath.
                    
                    CInstancePtr pNewInstance(NULL);
                    
                    if( SUCCEEDED(hr = CWbemProviderGlue::GetInstanceKeysByPath(chsNetworkAdapterSettingPath, &pNewInstance, pMethodContext)) )
                    {
                        pNewInstance->GetCHString(m_szTerminalName, chTermName);
                        pInstance->SetCHString(m_szTerminalName, chTermName);
                    }
                    TRC2((TB,"TSNetworkAdapterListSetting@EnumerateInstances: GetInstanceKeysByPath ret 0x%x\n" , hr));                    
                    
                    hr = pInstance->Commit();
                }	// end if
                
            } // pAdapter not null        
            AdapterList.EndEnum();        
        }	// IF BeginEnum        
    }
    return(hr);
    
}




HRESULT CWin32_TSNetworkAdapterListSetting::GetObject ( CInstance* pInstance, long lFlags)
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    
    // get the object for the Win32_Terminal
    CHString chsAdapter;
    CInstancePtr pAdapter(NULL);
    
    if( pInstance != NULL )
    {
        pInstance->GetCHString(L"Element", chsAdapter);
        MethodContext* pMethodContext = pInstance->GetMethodContext();    
        
        hr = CWbemProviderGlue::GetInstanceByPath(chsAdapter, &pAdapter, pMethodContext);
        TRC2((TB,"TSNetworkAdapterListSetting@GetObject: GetInstanceByPath ret 0x%x\n" , hr));
        
        do
        {
            if( SUCCEEDED( hr ) && pAdapter != NULL )
            {
                // Got the account.  Now, match it to the GUID.
                // first, generate a relpath with which to compare.
                CHString chDeviceID;
                CHString chNetworkAdapterSettingInstance;
                CHString chDescription;
                DWORD dwIndex = 0;
                pAdapter->GetCHString(m_szDeviceID, chDeviceID); 
                pAdapter->GetCHString(m_szDescription, chDescription);
                pAdapter->GetDWORD(m_szIndex, dwIndex);
                
                // create a relpath for the sid
                CHString chsNetworkAdapterSettingPath;
                chsNetworkAdapterSettingPath.Format(L"\\\\%s\\%s:%s.%s=\"%s\"", (LPCTSTR)GetLocalComputerName(), L"root\\cimv2", L"Win32_TSNetworkAdapterSetting", m_szNetworkAdapterID, (LPCTSTR)chDeviceID);
                
                // get the SID path from the instance
                pInstance->GetCHString(L"Setting", chNetworkAdapterSettingInstance);
                
                // compare it to our generated relpath
                if( 0 != chNetworkAdapterSettingInstance.CompareNoCase(chsNetworkAdapterSettingPath) )
                {
                    hr = WBEM_E_NOT_FOUND;

                    TRC2((TB,"TSNetworkAdapterListSetting@GetObject: CompareNoCase for relpath ret 0x%x\n" , hr));
                    
                    break;
                }
                pInstance->SetCHString(m_szDescription, chDescription);
                pInstance->SetCHString(m_szDeviceID, chDeviceID);
                pInstance->SetCHString(m_szNetworkAdapterID, chDeviceID);
                pInstance->SetDWORD(m_szIndex, dwIndex);
                
            }
        }while (0);
    }
    return(hr);
}
*/



CWin32_TSNetworkAdapterListSetting::CWin32_TSNetworkAdapterListSetting ( const CHString& setName, LPCTSTR pszNameSpace  )
: Provider (setName,pszNameSpace)
{
    

    if ( g_hInstance != NULL)
    {        

        TRC2((TB, "CWin32_TSNetworkAdapterListSetting_ctor"));
       
        _tcscpy(m_szNetworkAdapterID, _T("NetworkAdapterID"));

        _tcscpy(m_szDescription, _T("Description"));

        _tcscpy(m_szNetworkAdapterIP, _T("NetworkAdapterIP"));
                
    }
}

CWin32_TSNetworkAdapterListSetting::~CWin32_TSNetworkAdapterListSetting ()
{
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSNetworkAdapterListSetting::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_TSNetworkAdapterListSetting::EnumerateInstances (MethodContext*  pMethodContext, long lFlags)
{
	
    HRESULT hr = WBEM_S_NO_ERROR;    
    DWORD dwData = 0;
    PIP_ADAPTER_INFO pAdapterInfo = NULL, pAdapt = NULL;
    DWORD AdapterInfoSize = 0;
    PIP_ADDR_STRING pAddrStr;
    DWORD Err;
    ULONGLONG ulRequiredProperties = BIT_ALL_PROP;

    //
    // Enumerate all of the adapter specific information using the IP_ADAPTER_INFO structure.
    // Note:  IP_ADAPTER_INFO contains a linked list of adapter entries.
  
    GetAdaptersInfo(NULL, &AdapterInfoSize);

    if(AdapterInfoSize == 0)
    {
        return WBEM_E_FAILED;
    }
   
    // Allocate memory from sizing information
    if ((pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, AdapterInfoSize)) == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        return hr;
    }
    // Get actual adapter information
    if ((Err = GetAdaptersInfo(pAdapterInfo, &AdapterInfoSize)) != 0)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }

    pAdapt = pAdapterInfo;

    while (pAdapt)
    {
        pAddrStr = &(pAdapt->IpAddressList);

        while(pAddrStr)
        {
            CInstance* pInstance = CreateNewInstance(pMethodContext);

            if( pInstance != NULL )
            {
                TRC2((TB, "Win32_TSNetworkAdapterListSetting@EnumerateInstances: CreateNewInstance succeeded"));         
               
                pInstance->SetCharSplat(m_szDescription, pAdapt->Description );
           
                pInstance->SetCHString(m_szNetworkAdapterID, pAdapt->AdapterName);
            
                pInstance->SetCHString(m_szNetworkAdapterIP, pAddrStr->IpAddress.String);                

                if( SUCCEEDED( hr ))
                {
                    hr = pInstance->Commit();
                }

                pInstance->Release( );
            }

            
            pAddrStr = pAddrStr->Next;
        }
        pAdapt = pAdapt->Next;
    }


cleanup:
    if(pAdapterInfo)
        GlobalFree(pAdapterInfo);

    return hr;

}



HRESULT CWin32_TSNetworkAdapterListSetting::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query)
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTerminalProtocol;
    CHString chTransport;
    CHString chGuid;
    ULONG ulNAdapters = 0;
    ULONG ulNumAdapters = 0;
    DWORD dwSdclass = 0;
    ULONGLONG ulRequiredProperties = 0;

    PIP_ADAPTER_INFO pAdapterInfo = NULL, pAdapt = NULL;
    DWORD AdapterInfoSize = 0;
    PIP_ADDR_STRING pAddrStr;
    DWORD Err;
    CHString chAddress;
    chAddress.Empty();
    CHString chIPAddress;

    if (Query.IsPropertyRequired(m_szDescription))
        ulRequiredProperties |= BIT_DESCRIPTION;
    
    if (Query.IsPropertyRequired(m_szNetworkAdapterID))
        ulRequiredProperties |= BIT_NETWORKADAPTERID;

    if(NULL == pInstance)
    {
        return hr;
    }

    pInstance->GetCHString(m_szNetworkAdapterIP, chIPAddress);
    //
    // Enumerate all of the adapter specific information using the IP_ADAPTER_INFO structure.
    // Note:  IP_ADAPTER_INFO contains a linked list of adapter entries.
    //
    GetAdaptersInfo(NULL, &AdapterInfoSize);
    if (AdapterInfoSize == 0)
    {        
        return WBEM_E_FAILED;
    }

    // Allocate memory from sizing information
    if ((pAdapterInfo = (PIP_ADAPTER_INFO) GlobalAlloc(GPTR, AdapterInfoSize)) == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        return hr;
    }
    // Get actual adapter information
    if ((Err = GetAdaptersInfo(pAdapterInfo, &AdapterInfoSize)) != 0)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }

    pAdapt = pAdapterInfo;

    for (; pAdapt ; pAdapt = pAdapt->Next)
    {
        pAddrStr = &(pAdapt->IpAddressList);
        while(pAddrStr)
        {
            if( !_tcsicmp((LPWSTR)(pAddrStr->IpAddress.String), chIPAddress))
                goto found;

            pAddrStr = pAddrStr->Next;
        }
    }

found:
    if(pAdapt)
    {    
        pAddrStr = &(pAdapt->IpAddressList);
        while(pAddrStr)
        {
            if(!chAddress.IsEmpty())
            {
                chAddress+=L"; ";
            }
            chAddress += pAddrStr->IpAddress.String;
            pAddrStr = pAddrStr->Next;
        }

        if( ulRequiredProperties & BIT_DESCRIPTION)
        {
            pInstance->SetCharSplat(m_szDescription, pAdapt->Description );
        }
        if( ulRequiredProperties & BIT_NETWORKADAPTERID)
        {
            pInstance->SetCHString(m_szNetworkAdapterID, pAdapt->AdapterName);
        }
        pInstance->SetCHString(m_szNetworkAdapterIP, chAddress);

    }


cleanup:
    if(pAdapterInfo)
        GlobalFree(pAdapterInfo);
    return hr;
}



//=-------------------------------


CWin32_TSAccount::CWin32_TSAccount (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) :
Provider( lpwszName, lpwszNameSpace )
{
    
    if ( g_hInstance != NULL)
    {

        TRC2((TB, "CWin32_TSAccount_ctor"));

        _tcscpy(m_szPermissionPreSet, _T("PermissionPreSet"));

        _tcscpy(m_szPermissionMask, _T("PermissionMask"));

        _tcscpy(m_szPermissionsAllowed, _T("PermissionsAllowed"));

        _tcscpy(m_szPermissionsDenied, _T("PermissionsDenied"));

        _tcscpy(m_szAuditSuccess, _T("AuditSuccess"));

        _tcscpy(m_szAuditFail, _T("AuditFail"));

        _tcscpy(m_szAllow, _T("Allow"));

        _tcscpy(m_szSuccess, _T("Success"));

        _tcscpy(m_szSID, _T("SID"));

        _tcscpy(m_szDelete, _T("Delete"));

        _tcscpy(m_szModifyPermissions, _T("ModifyPermissions"));

        _tcscpy(m_szModifyAuditPermissions, _T("ModifyAuditPermissions"));

        _tcscpy(m_szTerminalName, _T("TerminalName"));

        _tcscpy(m_szAccountName, _T("AccountName"));        

    }

}
//=--------------------
CWin32_TSAccount::~CWin32_TSAccount ()
{    
}


//=--------------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_TSAccount::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/


HRESULT CWin32_TSAccount::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
	
    HRESULT hr = WBEM_S_NO_ERROR;
    DWORD dwData = 0;
    ULONG  ulTerminals = 0;
    ULONG  ulSize = 0; 
    LONG  lSize = 0;
    ULONG ulNum = 0;
    ULONG ulAuditNum = 0;
    bool bFound = 0;
    DWORD cbItems = 0;
    DWORD cbAuditItems = 0;
    PWS  pWS = NULL;
    PUSERPERMLIST pUserList = NULL;
    PUSERPERMLIST pUserAuditList = NULL;
    IUserSecurity *pUserSecurity = NULL;
    
	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}    
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++ )
        {   
            hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
            
            if( SUCCEEDED (hr) && pUserSecurity != NULL )
            {                
                
                hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbItems , &pUserList, 0  );

                hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbAuditItems , &pUserAuditList, 1  );                
                
                for( DWORD i = 0; i < cbItems && SUCCEEDED( hr ) ; ++i )
                {

                    for( DWORD j = 0;j < cbAuditItems ; j ++ )
                    {
                        bFound = 0;

                        if( lstrcmpi (pUserAuditList[j].Name, pUserList[i].Name) == 0 )
                        {
                            bFound = 1;

                            ulAuditNum = j;

                            break;
                        }
                    }

                    
                    CInstance* pInstance = CreateNewInstance(pMethodContext);
                    
                    if( pInstance == NULL)
                    {
                        ERR((TB,"TSAccount@EnumerateInstances: CreateNewInstance failed"));
                        
                        hr = WBEM_E_OUT_OF_MEMORY;

                        break;                                               
                    }
                    TRC2((TB,"TSAccount@EnumerateInstances: GetWinstationList ret 0x%x\n" , hr));

                    if( bFound == 1 )
                    {
                        hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum], &pUserList[i], &pUserAuditList[ulAuditNum]);
                    }
                    else
                    {
                        hr = LoadPropertyValues(pInstance, BIT_ALL_PROP, &pWS[ulNum], &pUserList[i], NULL);
                    }
                    
                    if( SUCCEEDED( hr ) )
                    {                        
                        hr = pInstance->Commit();                                                                                                
                    }

                    pInstance->Release( );
                }

                if( pUserList != NULL )
                {
                    CoTaskMemFree( pUserList );
                    pUserList = NULL;
                }

                if( pUserAuditList != NULL )
                {
                    CoTaskMemFree( pUserAuditList );
                    pUserAuditList = NULL;
                }    
            }

            if(pUserSecurity)
            {
                pUserSecurity->Release( );
                pUserSecurity = NULL;
            }
        }
        
    }

    if( pUserList != NULL )
    {
        CoTaskMemFree( pUserList );
        pUserList = NULL;
    }

    if( pUserAuditList != NULL )
    {
        CoTaskMemFree( pUserAuditList );
        pUserAuditList = NULL;
    }    
    
    if( pWS != NULL )
    {
        CoTaskMemFree( pWS );
    }

    if (pUserSecurity != NULL)
    {
        pUserSecurity->Release();
        pUserSecurity = NULL;
    }

    return hr;
    
}


HRESULT CWin32_TSAccount::ExecMethod ( const CInstance& Inst,
                                                        const BSTR bstrMethodName,
                                                        CInstance *pInParams,
                                                        CInstance *pOutParams,
                                                        long lFlags)
                                                        
{
	
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString chTermName;
    CHString chAccountName;
    DWORD dwPermissionPreSet = 0;
    DWORD dwMask = 0;
    DWORD dwPermissionDenyMask = 0;
    BOOL fAudit = FALSE;
    DWORD dwStatus = 0;
    IUserSecurity *pUserSecurity = NULL;
    PSID pSystemAcctSid = NULL;
    PSID pSid = NULL;
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    Inst.GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0)
    {
        return WBEM_E_ILLEGAL_NULL;
    }
            
    hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
    
    if( SUCCEEDED( hr ) && pUserSecurity != NULL  )
    {        
        do
        {
            
            // Deletes the permission from the specified user or group.
            // uint32 Delete();

            if( _wcsicmp(bstrMethodName, m_szDelete) == 0 )
            {
                
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                
                RegGetMachinePolicy( &m_gpPolicy );                    
                  
                Inst.GetCHString(m_szAccountName, chAccountName);
                
                
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( chAccountName.IsEmpty() != 0)
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                    
                    break;
                }
                
                if ( m_gpPolicy.fPolicyWritableTSCCPermissionsTAB == 0)
                {                    
                    hr = pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        0,         // winsta permission
                        TRUE ,
                        FALSE  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        FALSE ,           // t - enable auditing f - no auditing
                        &dwStatus );
                
                    TRC2((TB,"TSAccount@ExecMethod: Delete with Deny=True and Audit=False ret 0x%x\n", dwStatus));
                    if(dwStatus == ERROR_NOT_SUPPORTED)
                    {
                        hr = WBEM_E_NOT_SUPPORTED;
                        break;
                    }
                    else if(dwStatus != ERROR_SUCCESS)
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;
                        break;
                    }
                
                    hr = pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        0,         // winsta permission
                        TRUE ,
                        FALSE  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        TRUE ,           // t - enable auditing f - no auditing
                        &dwStatus );
                
                    TRC2((TB,"TSAccount@ExecMethod: Delete with Deny=True and Audit=True ret 0x%x\n", dwStatus));
                                    
                    if (pOutParams != NULL && SUCCEEDED( hr ) && SUCCEEDED( dwStatus ))
                    {
                        StackObj.m_pCfgComp->ForceUpdate();

                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                    }                      
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;  
                        
                        break;
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;
                    
                    break;
                }                                                   
                
            }
            
            // Restores the default permissions to default set of users and groups.
            // uint32 ModifyPermissions([In] uint32 PermissionMask, [In] boolean Allow)

            else if( _wcsicmp(bstrMethodName, m_szModifyPermissions) == 0 )
            {                                
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                ULONG ulOffset = 0;
                DWORD cbItems = 0;
                ULONG ulPermissionMask = 0;
                bool fAllow;
                bool bRet;
                DWORD index = 0;

                RegGetMachinePolicy(&m_gpPolicy);
                                           
                Inst.GetCHString(m_szAccountName, chAccountName);
            
            
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                }
            
                if( chAccountName.IsEmpty() != 0 )
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                
                    break;
                }

                if(pInParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }

                DWORD SidSize = 0;
                
                dwStatus = GetUserSid(chAccountName, NULL, &pSid);
                if(dwStatus != ERROR_SUCCESS)
                {
                    hr = WBEM_E_FAILED;
                    break;
                }

                //
                // System account SID that we don't allow removing from our
                // winstation security descriptor.
                //
                // Local System            S-1-5-18
                // Local Service           S-1-5-19
                // Network Service         S-1-5-20
                //
                WELL_KNOWN_SID_TYPE RestrictedSid[] = {
                                        WinLocalSystemSid,
                                        WinLocalServiceSid,
                                        WinNetworkServiceSid                
                                    };
                DWORD numRestrictedSid = sizeof(RestrictedSid)/sizeof(RestrictedSid[0]);

                // Check if SID is one of system account, if so, reject removing it from
                // our winstation security.
                pSystemAcctSid = LocalAlloc( LPTR, SECURITY_MAX_SID_SIZE );
                if( NULL == pSystemAcctSid ) 
                {
                    dwStatus = GetLastError();
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }

                for( index = 0; index < numRestrictedSid; index++ )
                {
                    SidSize = SECURITY_MAX_SID_SIZE;
                    if( !CreateWellKnownSid(RestrictedSid[index], NULL, pSystemAcctSid, &SidSize) )
                    {
                        dwStatus = GetLastError();
                        hr = WBEM_E_FAILED;
                        break;
                    }

                    if( EqualSid(pSystemAcctSid, pSid) )
                    {
                        dwStatus = ERROR_NOT_SUPPORTED;
                        hr = WBEM_E_NOT_SUPPORTED;
                        break;
                    }
                }

                if(index < numRestrictedSid )
                {
                    break;
                }
                               

                bRet = pInParams->GetDWORD(m_szPermissionMask, ulPermissionMask);
        
        
                if( !bRet || ulPermissionMask > 9 || (ulPermissionMask == 6) )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }               
                
                if(ulPermissionMask == 3)      // WINSTATION_VIRTUAL | STANDARD_RIGHTS_REQUIRED                                          
                {
                    dwMask = 0xF0008;
                }				
                else
                {        
                   
                    ULONG ulBase = 1;

                    for (ULONG ulIndex = 1; ulIndex <= ulPermissionMask; ulIndex++)
                    {
                        ulBase *= 2;
        
                    }

                    dwMask = ulBase;   
                }
                
                
                RegGetMachinePolicy(&m_gpPolicy);
        
                pInParams->Getbool(m_szAllow, fAllow);
        
                if( fAllow != 0 && fAllow != 1 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }
        
        /*
        
                if( fAudit != 0 && fAudit != 1 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
            
                    break;
                }
        */

                if( m_gpPolicy.fPolicyWritableTSCCPermissionsTAB == 0 )
                {

                    pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        dwMask,         // winsta permission
                        FALSE ,
                        fAllow  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        FALSE ,           // t - enable auditing f - no auditing
                        &dwStatus ); 
                
                    TRC2((TB,"TSAccount@ExecMethod: Modify with Audit=0 ret 0x%x\n", dwStatus));
        
                    if( SUCCEEDED (dwStatus) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
            
                    } 
        
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                        ERR((TB,"TSAccount@ExecMethod: Modify ret 0x%x\n", hr));
            
                        break;
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }
            
                           
            }
            
            // Modifies Audit permissions of users and groups.
            // uint32 ModifyAuditPermissions([In] uint32 PermissionMask, [In] boolean Allow)

            else if( _wcsicmp(bstrMethodName, m_szModifyAuditPermissions) == 0 )
            {
                
                dwStatus = 0;
                DWORD dwData = 0;
                LONG lSize;
                ULONG ulOffset = 0;
                DWORD cbItems = 0;
                ULONG ulPermissionMask = 0;
                bool fSuccess;
                bool bRet;
                
                RegGetMachinePolicy( &m_gpPolicy );
                
                Inst.GetCHString(m_szAccountName, chAccountName);
                
                
                if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                    
                    break;
                }
                
                if( chAccountName.IsEmpty() != 0)
                {
                    hr = WBEM_E_ILLEGAL_NULL;
                    
                    break;
                }

                if(pInParams == NULL)
                {
                    hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                    break;
                }

                DWORD SidSize = 0;
                DWORD index = 0;
                
                dwStatus = GetUserSid( chAccountName, NULL, &pSid);
                if(dwStatus != ERROR_SUCCESS)
                {
                    hr = WBEM_E_FAILED;
                    break;
                }

                //
                // System account SID that we don't allow removing from our
                // winstation security descriptor.
                //
                // Local System            S-1-5-18
                // Local Service           S-1-5-19
                // Network Service         S-1-5-20
                //
                WELL_KNOWN_SID_TYPE RestrictedSid[] = {
                                        WinLocalSystemSid,
                                        WinLocalServiceSid,
                                        WinNetworkServiceSid                
                                    };
                DWORD numRestrictedSid = sizeof(RestrictedSid)/sizeof(RestrictedSid[0]);

                // Check if SID is one of system account, if so, reject removing it from
                // our winstation security.
                pSystemAcctSid = LocalAlloc( LPTR, SECURITY_MAX_SID_SIZE );
                if( NULL == pSystemAcctSid ) 
                {
                    dwStatus = GetLastError();
                    hr = WBEM_E_OUT_OF_MEMORY;
                    break;
                }

                for( index = 0; index < numRestrictedSid; index++ )
                {
                    SidSize = SECURITY_MAX_SID_SIZE;
                    if( !CreateWellKnownSid(RestrictedSid[index], NULL, pSystemAcctSid, &SidSize) )
                    {
                        dwStatus = GetLastError();
                        hr = WBEM_E_FAILED;
                        break;
                    }

                    if( EqualSid(pSystemAcctSid, pSid) )
                    {
                        dwStatus = ERROR_NOT_SUPPORTED;
                        hr = WBEM_E_NOT_SUPPORTED;
                        break;
                    }
                }
                      
                if( index < numRestrictedSid)
                {
                    break;
                }

               
                bRet = pInParams->GetDWORD(m_szPermissionMask, ulPermissionMask);
                        
                if( !bRet || ulPermissionMask > 9 || (ulPermissionMask == 6) )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                } 

                if(ulPermissionMask == 3) // WINSTATION_VIRTUAL is defined as 0x00000008 but                                          
                {                         // GetExplicitEntriesFromAcl is returning 983048
                    dwMask = 0xF0008;
                }
                else
                {                                
                    ULONG ulBase = 1;

                    for( ULONG ulIndex = 1; ulIndex <= ulPermissionMask; ulIndex++ )
                    {
                        ulBase *= 2;
            
                    }

                    dwMask = ulBase;
                }            
            
                pInParams->Getbool(m_szSuccess, fSuccess);
            
            
                if( fSuccess != 0 && fSuccess != 1 )
                {
                    hr = WBEM_E_VALUE_OUT_OF_RANGE;
                
                    break;
                }
            
                if( m_gpPolicy.fPolicyWritableTSCCPermissionsTAB == 0 )
                {
            
                    pUserSecurity->ModifyUserAccess( (LPTSTR) (LPCTSTR)chTermName,  // winsta to modify security
                        (LPTSTR) (LPCTSTR) chAccountName,         // group or user
                        dwMask,         // winsta permission
                        FALSE ,
                        fSuccess  ,              // t - allow permission f - deny perm 
                        FALSE ,              // t - new object f - donot change previous permission                                
                        TRUE ,           // t - enable auditing f - no auditing
                        &dwStatus ); 

                    TRC2((TB,"TSAccount@ExecMethod: ModifyAuditPermissions ret 0x%x\n", dwStatus));                                               
            
                    if( SUCCEEDED (dwStatus) && pOutParams != NULL )
                    {
                        StackObj.m_pCfgComp->ForceUpdate();
                        pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
                
                    } 
                    else
                    {
                        hr = WBEM_E_INVALID_METHOD_PARAMETERS;

                        TRC2((TB,"TSAccount@ExecMethod: Modify ret 0x%x\n", hr));
                
                        break;
                    }
                }
                else
                {
                    hr = WBEM_E_INVALID_OPERATION;

                    break;
                }            
            }
            
            else
            {
                hr = WBEM_E_INVALID_METHOD;

                break;
            }
            
        }while(0);
    } 

    if( pSystemAcctSid != NULL )
    {
        LocalFree( pSystemAcctSid );
    }
    if(pSid != NULL)
    {
        LocalFree(pSid);
    }


    if( pUserSecurity != NULL)
    {
        pUserSecurity->Release();
    }

    return hr;
    
}

//=--------------------

HRESULT CWin32_TSAccount::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{	
    HRESULT hr = WBEM_E_NOT_FOUND;
    ULONGLONG ulRequiredProperties = 0;
    CHStringArray asNames;
    ULONG ulNum = 0;
    ULONG ulSize = 0;
    ULONG ulTerminals = 0;
    ULONG ulAuditNum = 0;
    PWS pWS = NULL;
    PUSERPERMLIST pUserList = NULL;
    PUSERPERMLIST pUserAuditList = NULL;
    DWORD cbItems = 0;
    DWORD cbAuditItems = 0;
    bool bFound = 0;
    IUserSecurity *pUserSecurity = NULL;

	CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    // Method 2
    Query.GetValuesForProp(m_szTerminalName, asNames);
    
    BOOL bGetAllInstances = asNames.GetSize() == 0;
    
    // Method 1
    if (Query.IsPropertyRequired(m_szTerminalName))
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if (Query.IsPropertyRequired(m_szSID))
        ulRequiredProperties |= BIT_SID;
    
    if (Query.IsPropertyRequired(m_szAccountName))
        ulRequiredProperties |= BIT_ACCOUNTNAME;

    if (Query.IsPropertyRequired(m_szAuditSuccess))
        ulRequiredProperties |= BIT_AUDITSUCCESS;

    if (Query.IsPropertyRequired(m_szAuditFail))
        ulRequiredProperties |= BIT_AUDITFAIL;
    
    if (Query.IsPropertyRequired(m_szPermissionsAllowed))
        ulRequiredProperties |= BIT_PERMISSIONSALLOWED;
    
    if (Query.IsPropertyRequired(m_szPermissionsDenied))
        ulRequiredProperties |= BIT_PERMISSIONSDENIED;
   
    
    hr = StackObj.m_pCfgComp->GetWinstationList(&ulTerminals, &ulSize, &pWS);        
    
    if( SUCCEEDED( hr ) && pWS != NULL )
    {   
        for( ulNum = 0; ulNum < ulTerminals && SUCCEEDED( hr ) ; ulNum++)
        {  
            
            // Method 2 
            if (bGetAllInstances || IsInList(asNames, pWS[ulNum].Name))
            {
                
                hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );
                
                if (SUCCEEDED ( hr ) && pUserSecurity != NULL)
                {                   
                    
                    hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbItems , &pUserList, 0  );

                    hr = pUserSecurity->GetUserPermList( pWS[ulNum].Name , &cbAuditItems , &pUserAuditList, 1  );
                    
                    for( DWORD i = 0; i < cbItems && SUCCEEDED( hr ) ; ++i )
                    {
                        for( DWORD j = 0;j < cbAuditItems ; j ++ )
                        {
                            bFound = 0;

                            if( lstrcmpi (pUserAuditList[j].Name, pUserList[i].Name) == 0 )
                            {
                                bFound = 1;

                                ulAuditNum = j;

                                break;
                            }
                        }
                        
                        CInstance* pInstance = CreateNewInstance(pMethodContext);
                        
                        if( pInstance == NULL )
                        {
                            ERR((TB,"TSAccount@ExecQuery: CreateNewInstance failed"));
                                                        
                            hr = WBEM_E_OUT_OF_MEMORY;

                            break;                                                       
                        }                        
                        
                        if( bFound == 1 )
                        {
                            hr = LoadPropertyValues(pInstance, ulRequiredProperties, &pWS[ulNum], &pUserList[i], &pUserAuditList[ulAuditNum]);
                        }
                        else
                        {
                            hr = LoadPropertyValues(pInstance, ulRequiredProperties, &pWS[ulNum], &pUserList[i], NULL);
                        }


                        if( SUCCEEDED( hr ) )
                        {
                            hr = pInstance->Commit();
                        }
                        
                        pInstance->Release();
                    }

                    if( pUserList != NULL )
                    {
                        CoTaskMemFree( pUserList );
                        pUserList = NULL;
                    }

                    if( pUserAuditList != NULL )
                    {
                        CoTaskMemFree( pUserAuditList );
                        pUserAuditList = NULL;
                    }    

                }

                if( pUserSecurity != NULL )
                {
                    pUserSecurity->Release();
                    pUserSecurity = NULL;
                }
            }
        }
    }

    if( pUserList != NULL )
    {
        CoTaskMemFree( pUserList );
        pUserList = NULL;
    }

    if( pUserAuditList != NULL )
    {
        CoTaskMemFree( pUserAuditList );
        pUserAuditList = NULL;
    }    
    
    if( pWS != NULL )
    {
        CoTaskMemFree(pWS);
        
    }

    if( pUserSecurity != NULL )
    {
        pUserSecurity->Release();
        pUserSecurity = NULL;
    }

    return hr;
}

//=------------------------------

HRESULT CWin32_TSAccount::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{	
    HRESULT hr = WBEM_E_NOT_FOUND;
    DWORD dwData = 0;
    CHString chTermName;
    CHString chAccountName;
    DWORD cbItems = 0;
    DWORD cbAuditItems = 0;
    ULONG ulSize = 0;
    ULONGLONG ulRequiredProperties = 0;
    LONG  lSize = 0;
    bool bFound = 0;
    PWS pWS = NULL;
    PUSERPERMLIST pUserList = NULL;
    PUSERPERMLIST pUserAuditList = NULL;
    ULONG ulNum = 0;
    ULONG ulAuditNum = 0;
    IUserSecurity *pUserSecurity = NULL;
    
    CStackClass StackObj;

	if( StackObj.m_pCfgComp == NULL)
	{
		return WBEM_E_ILLEGAL_NULL;
	}
    
    if( pInstance == NULL )
    {
        ERR((TB,"TSAccount@GetObject: invalid pointer"));
        
        return WBEM_E_ILLEGAL_NULL;
    }
    
    pInstance->GetCHString(m_szTerminalName, chTermName);
    
    if( chTermName.GetLength() > WINSTATIONNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chTermName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }

    pInstance->GetCHString(m_szAccountName, chAccountName);
    
    if( chAccountName.GetLength() > NASIUSERNAME_LENGTH )
    {
        return WBEM_E_VALUE_OUT_OF_RANGE;
    }
    
    if( chAccountName.IsEmpty() != 0 )
    {
        return WBEM_E_ILLEGAL_NULL;
    }
    
    if( Query.IsPropertyRequired(m_szTerminalName) )
        ulRequiredProperties |= BIT_TERMINALNAME;
    
    if( Query.IsPropertyRequired(m_szSID) )
        ulRequiredProperties |= BIT_SID;
    
    if( Query.IsPropertyRequired(m_szAccountName) )
        ulRequiredProperties |= BIT_ACCOUNTNAME;

    if( Query.IsPropertyRequired(m_szAuditSuccess) )
        ulRequiredProperties |= BIT_AUDITSUCCESS;

    if( Query.IsPropertyRequired(m_szAuditFail) )
        ulRequiredProperties |= BIT_AUDITFAIL;
    
    if( Query.IsPropertyRequired(m_szPermissionsAllowed) )
        ulRequiredProperties |= BIT_PERMISSIONSALLOWED;
    
    if( Query.IsPropertyRequired(m_szPermissionsDenied) )
        ulRequiredProperties |= BIT_PERMISSIONSDENIED;
    
    hr = StackObj.m_pCfgComp->GetWSInfo( ( LPTSTR )( LPCTSTR )chTermName, &lSize, &pWS);
    
    hr = StackObj.m_pCfgComp->QueryInterface( IID_IUserSecurity , ( LPVOID * )&pUserSecurity );

    if( pUserSecurity != NULL && pWS != NULL && SUCCEEDED( hr ))
    {    
        do
        {                    

            hr = pUserSecurity->GetUserPermList( ( LPTSTR )( LPCTSTR ) chTermName , &cbAuditItems , &pUserAuditList, 1 );

            if( SUCCEEDED( hr ) && pUserAuditList != NULL)
            {

                for( ulAuditNum = 0; ulAuditNum < cbAuditItems ; ulAuditNum ++ )
                {
                    bFound = 0;

                    if( lstrcmpi (pUserAuditList[ulAuditNum].Name, (LPCTSTR) chAccountName) == 0 )
                    {
                        bFound = 1;

                        break;
                    }
                }
            }
            
            hr = pUserSecurity->GetUserPermList( ( LPTSTR )( LPCTSTR ) chTermName , &cbItems , &pUserList, 0 );

            if( SUCCEEDED (hr) && pUserList != NULL )
            {                                                    
                for( ulNum = 0; ulNum < cbItems ; ulNum ++  )
                {
                    if( lstrcmpi (pUserList[ulNum].Name, (LPCTSTR) chAccountName) != 0 )
                
                        continue;

                
                    if( bFound == 1 )
                    {
                        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS, &pUserList[ulNum], &pUserAuditList[ulAuditNum]);
                    }
                    else
                    {
                        hr = LoadPropertyValues(pInstance, ulRequiredProperties, pWS, &pUserList[ulNum], NULL);
                    }
            
                    if( !(SUCCEEDED ( hr ) ))
                    {                                         
                        hr = WBEM_E_INVALID_OBJECT;

                        break;
                    }                                           
                }
            }
        
        }while(0);
    }

    if( pUserList != NULL )
    {
        CoTaskMemFree( pUserList );
    }

    if( pUserAuditList != NULL )
    {
        CoTaskMemFree( pUserAuditList );
    }
       
    if( pWS != NULL )
    {
        CoTaskMemFree (pWS);
    }

    if( pUserSecurity != NULL )
    {
        pUserSecurity->Release();
    }
    
    return hr;
    
}
//=--------------------

BOOL CWin32_TSAccount::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();
    
    for( DWORD x=0; x < dwSize; x++ )
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }
    
    return FALSE;
}

//=-----------------

HRESULT CWin32_TSAccount::LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS, PUSERPERMLIST pUserList, PUSERPERMLIST pUserAuditList)
{	
    HRESULT hr = S_OK;
    LONG lSize ;
    DWORD dwData = 0 ;
    DWORD cbItems = 0;
   
    if( pInstance == NULL )
    {
        return WBEM_E_INVALID_PARAMETER;       
    }   
    
    if( pWS != NULL && pUserList != NULL )
    {
        if( ulRequiredProperties & BIT_TERMINALNAME )
        {
            pInstance->SetCharSplat(m_szTerminalName, pWS->Name);
        }
       
        if( ulRequiredProperties & BIT_SID )
        {      
            pInstance->SetWCHARSplat(m_szSID, pUserList->Sid);
        }
        
        if( ulRequiredProperties & BIT_ACCOUNTNAME )
        {   
            pInstance->SetCharSplat(m_szAccountName, pUserList->Name);
        }
        
        if( ulRequiredProperties & BIT_PERMISSIONSALLOWED )
        {   
            if( pUserList->Type == 1 )
            {                  
                pInstance->SetDWORD(m_szPermissionsAllowed, pUserList->Mask);                
            }
            else
            {
                pInstance->SetDWORD(m_szPermissionsAllowed, 0);
            }
        }
        if( ulRequiredProperties & BIT_PERMISSIONSDENIED )
        {
            if( pUserList->Type == 3 )
            {              
                pInstance->SetDWORD(m_szPermissionsDenied, pUserList->Mask);                
            }
            else
            {
                pInstance->SetDWORD(m_szPermissionsDenied, 0);
            }
        }
        
        if( ulRequiredProperties & BIT_AUDITSUCCESS )
        { 
            if( pUserAuditList != NULL && pUserAuditList->Type == 5 )
            {                
                pInstance->SetDWORD(m_szAuditSuccess, pUserAuditList->Mask); 
            }
                
            else
            {
                pInstance->SetDWORD(m_szAuditSuccess, 0);
            }
        }
        if( ulRequiredProperties & BIT_AUDITFAIL )
        {
            if( pUserAuditList != NULL && pUserAuditList->Type == 6 )
            {
                pInstance->SetDWORD(m_szAuditFail, pUserAuditList->Mask);                        
            }
            else
            {
                pInstance->SetDWORD(m_szAuditFail, 0);
            }
        }                   
    } 


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wtsapi\config.c ===
/*******************************************************************************
* config.c
*
* Published Terminal Server APIs
*
* - user configuration routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <ntsecapi.h>
#include <lm.h>
#include <winbase.h>
#include <winerror.h>
#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif

#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>

#include <lmaccess.h> // for NetGet[Any]DCName                     KLB 10-07-97
#include <lmerr.h>    // for NERR_Success                          KLB 10-07-97
#include <lmapibuf.h> // for NetApiBufferFree                      KLB 10-07-97

#include <wtsapi32.h>


/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSQueryUserConfigW( LPWSTR, LPWSTR, WTS_CONFIG_CLASS, LPWSTR *, DWORD *);
BOOL WINAPI WTSQueryUserConfigA( LPSTR, LPSTR,  WTS_CONFIG_CLASS, LPSTR *,  DWORD *);
BOOL WINAPI WTSSetUserConfigW( LPWSTR, LPWSTR, WTS_CONFIG_CLASS, LPWSTR, DWORD);
BOOL WINAPI WTSSetUserConfigA( LPSTR, LPSTR,  WTS_CONFIG_CLASS, LPSTR,  DWORD);


/*=============================================================================
==   Internal procedures defined
=============================================================================*/
#ifdef NETWARE

//This should be defined in the wtsapi32.h

typedef struct _WTS_USER_CONFIG_SET_NWSERVERW {
    LPWSTR pNWServerName; 
    LPWSTR pNWDomainAdminName;
    LPWSTR pNWDomainAdminPassword;  
} WTS_USER_CONFIG_SET_NWSERVERW, * PWTS_USER_CONFIG_SET_NWSERVERW;

BOOL
SetNWAuthenticationServer(PWTS_USER_CONFIG_SET_NWSERVERW pInput,
                          LPWSTR pServerNameW,
                          LPWSTR pUserNameW,
                          PUSERCONFIGW pUserConfigW
                         );


#endif
/*=============================================================================
==   Procedures used
=============================================================================*/

BOOL _CopyData( PVOID, ULONG, LPWSTR *, DWORD * );
BOOL _CopyStringW( LPWSTR, LPWSTR *, DWORD * );
BOOL _CopyStringA( LPSTR, LPWSTR *, DWORD * );
BOOL _CopyStringWtoA( LPWSTR, LPSTR *, DWORD * );
BOOL ValidateCopyAnsiToUnicode(LPSTR, DWORD, LPWSTR);
BOOL ValidateCopyUnicodeToUnicode(LPWSTR, DWORD, LPWSTR);
VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );


/*=============================================================================
==   Local Data
=============================================================================*/

/****************************************************************************
 *
 *  WTSQueryUserConfigW (UNICODE)
 *
 *    Query information from the SAM for the specified user
 *
 * ENTRY:
 *    pServerName (input)
 *       Name of server to access (NULL for current machine).
 *    pUserName (input)
 *       User name to query
 *    WTSConfigClass (input)
 *       Specifies the type of information to retrieve about the specified user
 *    ppBuffer (output)
 *       Points to the address of a variable to receive information about
 *       the specified session.  The format and contents of the data
 *       depend on the specified information class being queried.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQueryUserConfigW(
                   IN LPWSTR pServerName,
                   IN LPWSTR pUserName,
                   IN WTS_CONFIG_CLASS WTSConfigClass,
                   OUT LPWSTR * ppBuffer,
                   OUT DWORD * pBytesReturned
                   )
{
    USERCONFIGW       UserConfigW;
    ULONG             ulReturnLength;
    LONG              rc;
    BOOL              fSuccess  = FALSE;
    DWORD             dwfInheritInitialProgram;
    DWORD             dwReturnValue;
    PUSER_INFO_0      pUserInfo = NULL;
    WCHAR             netServerName[DOMAIN_LENGTH + 3];

    /*
     * Check the null buffer
     */

    if (!ppBuffer || !pBytesReturned) {
        SetLastError (ERROR_INVALID_PARAMETER);
        fSuccess = FALSE;
        goto done;
    }

    // Verify the length of the incoming parameter pServerName
    // we do lstrcpy operations below with this parameter and do not want to overflow the buffer
    if ( (pServerName != NULL) && (wcslen(pServerName) > DOMAIN_LENGTH) ) {
        SetLastError (ERROR_INVALID_PARAMETER);
        fSuccess = FALSE;
        goto done;
    }

    /*
     *  First, we want to make sure the user actually exists on the specified
     *  machine.
     */

    rc = NetUserGetInfo( pServerName,     // server name (can be NULL)
                         pUserName,       // user name
                         0,               // level to query (0 = just name)
                         (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)

    /*
     * append the "\\" in front of server name to check the user name existence again
     */

    if ( rc != NERR_Success && pServerName) {

        lstrcpyW(netServerName, L"\\\\");
        lstrcatW(netServerName, pServerName);

        rc = NetUserGetInfo( netServerName,     // server name (can be NULL)
                             pUserName,       // user name
                             0,               // level to query (0 = user name)
                             (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)

        if ( rc != NERR_Success ) {
            SetLastError( ERROR_NO_SUCH_USER );
            goto done; // exit with fSuccess = FALSE
        }
    }

    /*
     *  Query the user.  If the user config doesn't exist for the user, then 
     *  we query the default values.
     */
    rc = RegUserConfigQuery( pServerName,               // server name
                              pUserName,                 // user name
                              &UserConfigW,              // returned user config
                              (ULONG)sizeof(UserConfigW),// user config length
                              &ulReturnLength );         // #bytes returned
    if ( rc != ERROR_SUCCESS ) {
        rc = RegDefaultUserConfigQuery( pServerName,               // server name
                                         &UserConfigW,              // returned user config
                                         (ULONG)sizeof(UserConfigW),// user config length
                                         &ulReturnLength );         // #bytes returned
    }

    /*
     *  Now, process the results.  Note that in each case, we're allocating a
     *  new buffer which the caller must free
     *  (WTSUserConfigfInheritInitialProgram is just a boolean, but we allocate
     *  a DWORD to send it back).
     */
    if ( rc == ERROR_SUCCESS ) {
        switch ( WTSConfigClass ) {
        case WTSUserConfigInitialProgram:
            fSuccess = _CopyStringW( UserConfigW.InitialProgram, 
                                     ppBuffer,
                                     pBytesReturned );
            break;

        case WTSUserConfigWorkingDirectory:
            fSuccess = _CopyStringW( UserConfigW.WorkDirectory, 
                                     ppBuffer,
                                     pBytesReturned );
            break;

        case WTSUserConfigfInheritInitialProgram:
            dwReturnValue = UserConfigW.fInheritInitialProgram; 
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigfAllowLogonTerminalServer:    //DWORD returned/expected

            dwReturnValue = !(UserConfigW.fLogonDisabled);
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );


            break;
            //Timeout settings
        case WTSUserConfigTimeoutSettingsConnections:
            dwReturnValue = UserConfigW.MaxConnectionTime;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigTimeoutSettingsDisconnections: //DWORD 
            dwReturnValue = UserConfigW.MaxDisconnectionTime;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigTimeoutSettingsIdle:          //DWORD 
            dwReturnValue = UserConfigW.MaxIdleTime;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
        case WTSUserConfigfDeviceClientDrives:                  //DWORD 
            dwReturnValue = UserConfigW.fAutoClientDrives;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigfDeviceClientPrinters:   //DWORD 
            dwReturnValue = UserConfigW.fAutoClientLpts;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

        case WTSUserConfigfDeviceClientDefaultPrinter:   //DWORD 
            dwReturnValue = UserConfigW.fForceClientLptDef;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;


            //Connection settings
        case WTSUserConfigBrokenTimeoutSettings:         //DWORD 
            dwReturnValue = UserConfigW.fResetBroken;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
        case WTSUserConfigReconnectSettings:
            dwReturnValue = UserConfigW.fReconnectSame;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;

            //Modem settings
        case WTSUserConfigModemCallbackSettings:         //DWORD 
            dwReturnValue = UserConfigW.Callback;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
        case WTSUserConfigModemCallbackPhoneNumber:
            fSuccess = _CopyStringW(UserConfigW.CallbackNumber,
                                    ppBuffer,
                                    pBytesReturned );
            break;

        case WTSUserConfigShadowingSettings:             //DWORD 
            dwReturnValue = UserConfigW.Shadow;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
#ifdef NETWARE
        case WTSUserConfigNWServerName:             // string 
            fSuccess = _CopyStringW(UserConfigW.NWLogonServer,
                                    ppBuffer,
                                    pBytesReturned );

            break;
#endif
        case WTSUserConfigTerminalServerProfilePath:     // string 
            fSuccess = _CopyStringW(UserConfigW.WFProfilePath,
                                    ppBuffer,
                                    pBytesReturned );
            break;

        case WTSUserConfigTerminalServerHomeDir:       // string 
            fSuccess = _CopyStringW(UserConfigW.WFHomeDir,
                                    ppBuffer,
                                    pBytesReturned );
            break;
        case WTSUserConfigTerminalServerHomeDirDrive:    // string 
            fSuccess = _CopyStringW(UserConfigW.WFHomeDirDrive,
                                    ppBuffer,
                                    pBytesReturned );
            break;

        case WTSUserConfigfTerminalServerRemoteHomeDir:                  // DWORD 0:LOCAL 1:REMOTE
            if (wcslen(UserConfigW.WFHomeDirDrive) > 0 ) {
                dwReturnValue = 1;

            } else {
                dwReturnValue = 0;
            }

            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );


            break;
#ifdef NETWARE
        case WTSUserConfigfNWMapRoot:
            dwReturnValue = UserConfigW.fHomeDirectoryMapRoot;
            fSuccess = _CopyData( &dwReturnValue,
                                  sizeof(DWORD),
                                  ppBuffer,
                                  pBytesReturned );
            break;
#endif
        } // switch()
    } //if (rc == ERROR_SUCCESS)

    done:

    if ( pUserInfo ) {
        NetApiBufferFree( pUserInfo );
    }
    
    return( fSuccess );
}



/****************************************************************************
 *
 *  WTSQueryUserConfigA (ANSI)
 *
 *    Query information from the SAM for the specified user
 *
 * ENTRY:
 *
 *    see WTSQueryUserConfigW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQueryUserConfigA(
                   IN LPSTR pServerName,
                   IN LPSTR pUserName,
                   IN WTS_CONFIG_CLASS WTSConfigClass,
                   OUT LPSTR * ppBuffer,
                   OUT DWORD * pBytesReturned
                   )
{
    LPWSTR lpBufferW    = NULL;
    BOOL   fSuccess;
    LONG   rc;
    LPWSTR pUserNameW   = NULL;
    LPWSTR pServerNameW = NULL;

    if (!ppBuffer || !pBytesReturned) {
        SetLastError (ERROR_INVALID_PARAMETER);
        fSuccess = FALSE;
        goto done;
    }

    fSuccess = _CopyStringA( pUserName, &pUserNameW, NULL );
    if ( fSuccess ) {
        fSuccess = _CopyStringA( pServerName, &pServerNameW, NULL );
    }
    if ( fSuccess ) {
        fSuccess = WTSQueryUserConfigW( pServerNameW,
                                        pUserNameW,
                                        WTSConfigClass,
                                        &lpBufferW,
                                        pBytesReturned );
        LocalFree( pUserNameW );
    }
    // Now, process the results.
    if ( fSuccess ) switch ( WTSConfigClass ) {
        case WTSUserConfigInitialProgram:
        case WTSUserConfigWorkingDirectory:
        case WTSUserConfigModemCallbackPhoneNumber:
#ifdef NETWARE
        case WTSUserConfigNWServerName:             // string returned/expected
#endif
        case WTSUserConfigTerminalServerProfilePath:     // string returned/expected
        case WTSUserConfigTerminalServerHomeDir:       // string returned/expected
        case WTSUserConfigTerminalServerHomeDirDrive:    // string returned/expected
            /*
             *  String Data - Convert to ANSI
             */
            
            {
                /* 
                 * allocate return buffer for max possible MultiByte string
                 */
                DWORD DataLength = (wcslen( lpBufferW ) + 1) * sizeof(WCHAR);
                *ppBuffer = LocalAlloc( LPTR, DataLength );
                if ( *ppBuffer != NULL ) {

                    RtlUnicodeToMultiByteN( *ppBuffer, DataLength, pBytesReturned, lpBufferW, DataLength);
                    fSuccess = TRUE;

                } else {

                    fSuccess = FALSE;
                }
            
                LocalFree( lpBufferW );

                break;
            }

        default:
            /*
             *  Just a DWORD, point buffer at the one returned (caller is
             *  responsible for freeing, so this is cool).
             */
            *ppBuffer = (LPSTR)lpBufferW;
            break;
        } // switch()
    done:
    return( fSuccess );
}


/****************************************************************************
 *
 *  WTSSetUserConfigW (UNICODE)
 *
 *    Set information in the SAM for the specified user
 *
 * ENTRY:
 *    pServerName (input)
 *       Name of server to access (NULL for current machine).
 *    pUserName (input)
 *       User name to query
 *    WTSConfigClass (input)
 *       Specifies the type of information to change for the specified user
 *    pBuffer (input)
 *       Pointer to the data used to modify the specified user's information.
 *    DataLength (input)
 *       The length of the data provided.
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetUserConfigW(
                 IN LPWSTR pServerName,
                 IN LPWSTR pUserName,
                 IN WTS_CONFIG_CLASS WTSConfigClass,
                 IN LPWSTR pBuffer,
                 IN DWORD DataLength
                 )
{
    USERCONFIGW       UserConfigW;
    ULONG             ulReturnLength;
    LONG              rc;
    BOOL              fSuccess = FALSE;
    BOOL              fUserConfig = TRUE;          //TRUE - We use RegUserConfigSet
    //FALSE - Use NetUserSetInfo
    DWORD             dwfInheritInitialProgram;
    PDWORD            pdwValue = (DWORD *) pBuffer;
    PUSER_INFO_0      pUserInfo = NULL;
    DWORD             dwParam = 0;
    WCHAR             netServerName[DOMAIN_LENGTH + 3];


    if (!pBuffer || DataLength == 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done; // exit with fSuccess = FALSE
    }

    // Verify the length of the incoming parameter pServerName
    // we do lstrcpy operations below with this parameter and do not want to overflow the buffer
    if ( (pServerName != NULL) && (wcslen(pServerName) > DOMAIN_LENGTH) ) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done;
    }

    /*
     *  First, we want to make sure the user actually exists on the specified
     *  machine.
     */


    rc = NetUserGetInfo( pServerName,     // server name (can be NULL)
                         pUserName,       // user name
                         0,               // level to query (0 = just name)
                         (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)

    if ( rc != NERR_Success ) {

        if (pServerName != NULL) {
            lstrcpyW(netServerName, L"\\\\");
            lstrcatW(netServerName, pServerName);
        
             rc = NetUserGetInfo( netServerName,     // server name (can be NULL)
                             pUserName,       // user name
                             3,               // level to query (3 = ust name)
                             (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)
        }
        else {
             rc = NetUserGetInfo( NULL,       // server name is NULL
                             pUserName,       // user name
                             3,               // level to query (3 = ust name)
                             (LPBYTE *)&pUserInfo );// buffer to return data to (they alloc, we free)
        }

        if ( rc != NERR_Success ) {
            SetLastError( ERROR_NO_SUCH_USER );
            goto done; // exit with fSuccess = FALSE
        }
    }

    /*
     *  Query the user.  If the user config doesn't exist for the user, then
     *  we query the default values.
     */
    rc = RegUserConfigQuery( pServerName,               // server name
                              pUserName,                 // user name
                              &UserConfigW,              // returned user config
                              (ULONG)sizeof(UserConfigW),// user config length
                              &ulReturnLength );         // #bytes returned
    if ( rc != ERROR_SUCCESS ) {
        rc = RegDefaultUserConfigQuery( pServerName,               // server name
                                         &UserConfigW,              // returned user config
                                         (ULONG)sizeof(UserConfigW),// user config length
                                         &ulReturnLength );         // #bytes returned
    }
    if ( rc != ERROR_SUCCESS ) {
        goto done;
    }

    /*
     *  Now, we plug in the part we want to change.
     */
    switch ( WTSConfigClass ) {
    case WTSUserConfigInitialProgram:
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      INITIALPROGRAM_LENGTH,
                                                      UserConfigW.InitialProgram)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;

    case WTSUserConfigWorkingDirectory:
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      DIRECTORY_LENGTH,
                                                      UserConfigW.WorkDirectory)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;

    case WTSUserConfigfInheritInitialProgram:
        /*
         *  We have to point a DWORD pointer at the data, then assign it
         *  from the DWORD, as that's how it's defined (and this will
         *  ensure that it works okay on non-Intel architectures).
         */
        UserConfigW.fInheritInitialProgram = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigfAllowLogonTerminalServer:
        if (*pdwValue) {
            UserConfigW.fLogonDisabled = FALSE;
        } else {
          UserConfigW.fLogonDisabled = TRUE;
        }

        fSuccess = TRUE;

        break;

    case WTSUserConfigTimeoutSettingsConnections:
        UserConfigW.MaxConnectionTime = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigTimeoutSettingsDisconnections: //DWORD 
        UserConfigW.MaxDisconnectionTime = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigTimeoutSettingsIdle:          //DWORD 
        UserConfigW.MaxIdleTime = *pdwValue;
        fSuccess = TRUE;
        break;
    case WTSUserConfigfDeviceClientDrives:                  //DWORD 
        UserConfigW.fAutoClientDrives = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigfDeviceClientPrinters:   //DWORD 
        UserConfigW.fAutoClientLpts = *pdwValue;
        fSuccess = TRUE;
        break;

    case WTSUserConfigfDeviceClientDefaultPrinter:   //DWORD 
        UserConfigW.fForceClientLptDef = *pdwValue;
        fSuccess = TRUE;
        break;


    case WTSUserConfigBrokenTimeoutSettings:         //DWORD 
        UserConfigW.fResetBroken= *pdwValue;
        fSuccess = TRUE;
        break;
    case WTSUserConfigReconnectSettings:
        UserConfigW.fReconnectSame = *pdwValue;
        fSuccess = TRUE;
        break;

        //Modem settings
    case WTSUserConfigModemCallbackSettings:         //DWORD 
        UserConfigW.Callback = *pdwValue;
        fSuccess = TRUE;
        break;
    case WTSUserConfigModemCallbackPhoneNumber:
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.CallbackNumber) - 1,
                                                      UserConfigW.CallbackNumber)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;


    case WTSUserConfigShadowingSettings:             //DWORD 
        UserConfigW.Shadow = *pdwValue;
        fSuccess = TRUE;
        break;
#ifdef NETWARE
    case WTSUserConfigNWServerName:             // WTS_USER_CONFIG_SET_NWSERVERW

        // Make sure the data structure is correct
        //

        if (DataLength < sizeof (WTS_USER_CONFIG_SET_NWSERVERW)) {
            fSuccess = FALSE;
            SetLastError(ERROR_INVALID_PARAMETER);
            goto done;
        }
        fSuccess = SetNWAuthenticationServer((PWTS_USER_CONFIG_SET_NWSERVERW)pBuffer,
                                             pServerName,
                                             pUserName,
                                             pBuffer,
                                             &UserConfigW);


        goto done;


        break;
#endif

    case WTSUserConfigTerminalServerProfilePath:     // string 
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.WFProfilePath) - 1,
                                                      UserConfigW.WFProfilePath)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;


    case WTSUserConfigTerminalServerHomeDir:       // string 
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.WFHomeDir) - 1,
                                                      UserConfigW.WFHomeDir)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;
    case WTSUserConfigTerminalServerHomeDirDrive:    // string 
        if (!(fSuccess = ValidateCopyUnicodeToUnicode((LPWSTR)pBuffer,
                                                      sizeof(UserConfigW.WFHomeDirDrive) - 1,
                                                      UserConfigW.WFHomeDirDrive)) ) {
            SetLastError(ERROR_INVALID_DATA);
            goto done;
        }
        break;

    case WTSUserConfigfTerminalServerRemoteHomeDir:                  // DWORD 0:LOCAL 1:REMOTE
        fSuccess = FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);    // We don't set this parameter
        goto done;
        break;
#ifdef NETWARE
    case WTSUserConfigfNWMapRoot:
        UserConfigW.fHomeDirectoryMapRoot = *pdwValue;
        fSuccess = TRUE;
        break;
#endif
    
    default:
        fSuccess = FALSE;
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done;

    } 

    if ( fSuccess ) {
        if (fUserConfig) {
            /*
             *  Only in here if we successfully changed the data in UserConfigW.
             *  So, we can now write it out to the SAM.
             */

            rc = RegUserConfigSet( pServerName,                // server name
                                    pUserName,                  // user name
                                    &UserConfigW,               // returned user config
                                    (ULONG)sizeof(UserConfigW));// user config length
        }
        fSuccess = (ERROR_SUCCESS == rc);
        if ( !fSuccess ) {
            SetLastError( rc );
        }
    }

    done:
    if ( pUserInfo ) {
        NetApiBufferFree( pUserInfo );
    }

    return(fSuccess);
}


/****************************************************************************
 *
 *  WTSSetUserConfigA (ANSI)
 *
 *    Set information in the SAM for the specified user
 *
 * ENTRY:
 *
 *    see WTSSetUserConfigW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 * HISTORY:
 *    Created KLB 10-06-97
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetUserConfigA(
                 IN LPSTR pServerName,
                 IN LPSTR pUserName,
                 IN WTS_CONFIG_CLASS WTSConfigClass,
                 IN LPSTR pBuffer,
                 IN DWORD DataLength
                 )
{
    BOOL   fSuccess = FALSE;
    BOOL   fFreepBufferW = TRUE;
    LPWSTR pUserNameW    = NULL;
    LPWSTR pServerNameW  = NULL;
    LPWSTR pBufferW      = NULL;
    DWORD  dwDataLength;


    if (!pBuffer || DataLength == 0) {
        SetLastError (ERROR_INVALID_PARAMETER);
        goto done; // exit with fSuccess = FALSE
    }

    /*
     *  We're going to call WTSSetUserConfigW() to do the actual work.  We need
     *  to convert all ANSI strings to Unicode before calling.  These are the
     *  user name, and the pBuffer data if it's the initial program or the
     *  working directory; if it's the flag for inherit initial program, it'll
     *  be a DWORD in either case, so no conversion is necessary.
     */
    fSuccess = _CopyStringA( pUserName, &pUserNameW, NULL );
    if ( fSuccess ) {
        fSuccess = _CopyStringA( pServerName, &pServerNameW, NULL );
    }
    if ( fSuccess ) switch ( WTSConfigClass ) {
        case WTSUserConfigInitialProgram:
        case WTSUserConfigWorkingDirectory:
        case WTSUserConfigModemCallbackPhoneNumber:

        case WTSUserConfigTerminalServerProfilePath:     // string returned/expected
        case WTSUserConfigTerminalServerHomeDir:       // string returned/expected
        case WTSUserConfigTerminalServerHomeDirDrive:    // string returned/expected
            /*
             *  String Data - Convert to Unicode (_CopyStringA() allocates
             *  pBufferW for us)
             */
            fSuccess = _CopyStringA( pBuffer, &pBufferW, &dwDataLength );
            break;
#ifdef NETWARE
        case WTSUserConfigNWServerName:             // string returned/expected
            {
                //Need to convert the data structure from ASCII to UNICODE
                PWTS_USER_CONFIG_SET_NWSERVERW pSetNWServerParamW = LocalAlloc(LPTR, sizeof(WTS_USER_CONFIG_SET_NWSERVERW));
                PWTS_USER_CONFIG_SET_NWSERVERA pSetNWServerParamA = (PWTS_USER_CONFIG_SET_NWSERVERA)pBuffer;
                DWORD                          dwLen = 0;
                if (pSetNWServerParamW == NULL) {
                    fSuccess = FALSE;
                    break;
                }
                pBufferW = pSetNWServerParamW;

                //----------------------------------------//
                // Allocate the buffer to hold the        //
                // required unicode string                //
                //----------------------------------------//
                dwLen = strlen(pSetNWServerParamA -> pNWServerName);
                if (fSuccess = _CopyStringA(pSetNWServerParamA -> pNWServerName, 
                                            &pSetNWServerParamW -> pNWServerName, 
                                            &dwLen)) {
                    dwLen = strlen(pSetNWServerParamA -> pNWDomainAdminName);
                    if (fSuccess = _CopyStringA(pSetNWServerParamA -> pNWDomainAdminName,
                                                &pSetNWServerParamW -> pNWDomainAdminName, 
                                                &dwLen)) {
                        dwLen = strlen(pSetNWServerParamA -> pNWDomainAdminPassword);
                        fSuccess = _CopyStringA(pSetNWServerParamA -> pNWDomainAdminPassword,
                                                &pSetNWServerParamW -> pNWDomainAdminPassword, 
                                                &dwLen);

                    }

                }

                //-----------------------------------------//
                // Call the UNICODE function               //
                //-----------------------------------------//

                if (fSuccess) {

                    fSuccess = WTSSetUserConfigW( pServerNameW,
                                                  pUserNameW,
                                                  WTSConfigClass,
                                                  pBufferW,
                                                  dwDataLength );
                }


                //----------------------------------------------//
                // Free the storage for the specific function   //
                //----------------------------------------------//

                if (pSetNWServerParamW -> pNWServerName) {
                    LocalFree( pSetNWServerParamW -> pNWServerName );
                }
                if (pSetNWServerParamW -> pNWDomainAdminName) {
                    LocalFree( pSetNWServerParamW -> pNWDomainAdminName );
                }

                if (pSetNWServerParamW -> pNWDomainAdminPassword) {
                    LocalFree( pSetNWServerParamW -> pNWDomainAdminPassword );
                }
                goto done;
                break;
            }
#endif

        default:
            /*
             *  Just a DWORD, point our wide buffer at the narrow buffer passed
             *  in to us and set the data length variable we'll pass down.
             *  NOTE: WE DON'T WANT TO FREE THE BUFFER, since we're re-using
             *  the buffer sent in and the caller expects to free it.  We'll
             *  use a BOOL to decide, rather than allocating an extra buffer
             *  here (performance, memory fragmentation, etc.).    KLB 10-08-97
             */
            pBufferW = (LPWSTR) pBuffer;
            dwDataLength = sizeof(DWORD);
            fFreepBufferW = FALSE;
            break;
        } // switch()

    /*
     *  Now, if fSuccess is TRUE, we've copied all the strings we need.  So, we
     *  can now call WTSSetUserConfigW().
     */
    if ( fSuccess ) {
        fSuccess = WTSSetUserConfigW( pServerNameW,
                                      pUserNameW,
                                      WTSConfigClass,
                                      pBufferW,
                                      dwDataLength );
    }
    done:
    if ( pUserNameW ) {
        LocalFree( pUserNameW );
    }
    if ( fFreepBufferW && pBufferW ) {
        LocalFree( pBufferW );
    }
    return(fSuccess);
}


#ifdef NETWARE
BOOL
SetNWAuthenticationServer(PWTS_USER_CONFIG_SET_NWSERVERW pInput,
                          LPWSTR pServerNameW,
                          LPWSTR pUserNameW,
                          PUSERCONFIGW pUserConfigW
                         )

{
    BOOL             bStatus = TRUE;
    PWKSTA_INFO_100  pWkstaInfo = NULL;
    NWLOGONADMIN     nwLogonAdmin;
    HANDLE           hServer;
    DWORD            dwStatus;
    //----------------------------------//
    // Get a Server handle
    //----------------------------------//
    hServer = RegOpenServer(pServerNameW);
    if (!hServer) {
        SetLastError(GetLastError());
        bStatus = FALSE;
        goto done;
    }

    //----------------------------------
    //find the domain name
    //------------------------------------
    dwStatus = NetWkstaGetInfo(
                              pServerNameW,  
                              100,
                              &pWkstaInfo
                              );
    if (dwStatus != ERROR_SUCCESS) {
        SetLastError(dwStatus);
        goto done;
    }
    //-----------------------------------------------------
    //Copy the parameter to the NWLOGONADMIN structure
    //-----------------------------------------------------
    bStatus = ValidateCopyUnicodeToUnicode(pInput -> pNWDomainAdminName,
                                           sizeof(nwLogonAdmin.Username)-1,
                                           nwLogonAdmin.Username);
    if (!bStatus) {
        goto done;
    }

    bStatus = ValidateCopyUnicodeToUnicode(pInput -> pNWDomainAdminPassword,
                                           sizeof(nwLogonAdmin.Password)-1,
                                           nwLogonAdmin.Password);
    if (!bStatus) {
        goto done;
    }

    bStatus = ValidateCopyUnicodeToUnicode(pWkstaInfo -> wki100_langroup,
                                           sizeof(nwLogonAdmin.Domain)-1,
                                           nwLogonAdmin.Domain);
    if (!bStatus) {
        goto done;
    }


    //------------------------------------------//
    // Set the admin                           //
    //-----------------------------------------//

    bStatus = _NWLogonSetAdmin(hServer,
                               &nwLogonAdmin,
                               sizeof(nwLogonAdmin));

    if (!bStatus) {
        SetLastError(GetLastError());
        goto done;
    }

    done:
    if (pWkstaInfo) {
        NetApiBufferFree(pWkstaInfo);
    }

    return bStatus;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wmi\tscfgwmi\winstation.h ===
/******************************************************************
   Copyright (C) 2000 Microsoft Corp.

   Winstation.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _Winstation_H_
#define _Winstation_H_
#include "resource.h"
#include "Terminal.h"
#include <winsta.h>
#include <regapi.h>
#include "smartptr.h"


#define BIT_FENABLETERMINAL                 0x0000000000000001
#define BIT_TERMINALNAME                    0x0000000000000002
#define BIT_TERMINALPROTOCOL                0x0000000000000004
#define BIT_TRANSPORT                       0x0000000000000008
#define BIT_COMMENT                         0x0000000000000010
#define BIT_WINDOWSAUTHENTICATION           0x0000000000000020
#define BIT_ENCRYPTIONLEVEL                 0x0000000000000040
#define BIT_CLIENTLOGONINFOPOLICY           0x0000000000000080
#define BIT_PROMPTFORPASSWORD               0x0000000000000100
#define BIT_USERNAME                        0x0000000000000200
#define BIT_DOMAIN                          0x0000000000000400
#define BIT_ACTIVESESSIONPOLICY             0x0000000000001000
#define BIT_DISCONNECTEDSESSIONPOLICY       0x0000000000002000
#define BIT_IDLESESSIONPOLICY               0x0000000000004000
#define BIT_ACTIVESESSIONLIMIT              0x0000000000008000
#define BIT_DISCONNECTEDSESSIONLIMIT        0x0000000000010000
#define BIT_IDLESESSIONLIMIT                0x0000000000020000
#define BIT_BROKENCONNECTIONPOLICY          0x0000000000040000
#define BIT_BROKENCONNECTIONACTION          0x0000000000080000
#define BIT_RECONNECTIONPOLICY              0x0000000000100000
#define BIT_INITIALPROGRAMPOLICY            0x0000000000200000
#define BIT_INITIALPROGRAMPATH              0x0000000000400000
#define BIT_STARTIN                         0x0000000000800000
#define BIT_CLIENTWALLPAPER                 0x0000000001000000
#define BIT_REMOTECONTROLPOLICY             0x0000000002000000
#define BIT_LEVELOFCONTROL                  0x0000000004000000
#define BIT_CONNECTIONPOLICY                0x0000000008000000
#define BIT_CONNECTCLIENTDRIVESATLOGON      0x0000000010000000
#define BIT_CONNECTPRINTERATLOGON           0x0000000020000000
#define BIT_DEFAULTTOCLIENTPRINTER          0x0000000040000000
#define BIT_WINDOWSPRINTERMAPPING           0x0000000080000000
#define BIT_LPTPORTMAPPING                  0x0000000100000000
#define BIT_COMPORTMAPPING                  0x0000000200000000
#define BIT_DRIVEMAPPING                    0x0000000400000000
#define BIT_AUDIOMAPPING                    0x0000000800000000
#define BIT_CLIPBOARDMAPPING                0x0000001000000000
#define BIT_NETWORKADAPTERID                0x0000002000000000
#define BIT_MAXIMUMCONNECTIONS              0x0000004000000000
#define BIT_ACCOUNTNAME                     0x0000008000000000
#define BIT_SID                             0x0000010000000000
#define BIT_PERMISSIONSALLOWED              0x0000020000000000
#define BIT_PERMISSIONSDENIED               0x0000040000000000
#define BIT_AUDITSUCCESS                    0x0000080000000000
#define BIT_AUDITFAIL                       0x0000100000000000
#define BIT_COLORDEPTHPOLICY                0x0000200000000000
#define BIT_COLORDEPTH                      0x0000400000000000
#define BIT_DESCRIPTION                     0x0000800000000000
#define BIT_ALL_PROP                        0xffffffffffffffff

#define BIT_ALL_PROPS                       0xffffffff


#define TS_PATH TEXT("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations")


#define PROVIDER_NAME_Win32_WIN32_TERMINAL_Prov                         L"Win32_Terminal"
#define PROVIDER_NAME_Win32_WIN32_TSGENERALSETTING_Prov                 L"Win32_TSGeneralSetting"
#define PROVIDER_NAME_Win32_WIN32_TSLOGONSETTING_Prov                   L"Win32_TSLogonSetting"
#define PROVIDER_NAME_Win32_WIN32_TSSESSIONSETTING_Prov                 L"Win32_TSSessionSetting"
#define PROVIDER_NAME_Win32_WIN32_TSENVIRONMENTSETTING_Prov             L"Win32_TSEnvironmentSetting"
#define PROVIDER_NAME_Win32_WIN32_TSREMOTECONTROLSETTING_Prov           L"Win32_TSRemoteControlSetting"
#define PROVIDER_NAME_Win32_WIN32_TSCLIENTSETTING_Prov                  L"Win32_TSClientSetting"
#define PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERSETTING_Prov          L"Win32_TSNetworkAdapterSetting"
#define PROVIDER_NAME_Win32_WIN32_TSPERMISSIONSSETTING_Prov             L"Win32_TSPermissionsSetting"
#define PROVIDER_NAME_Win32_WIN32_TSNETWORKADAPTERLISTSETTING_Prov      L"Win32_TSNetworkAdapterListSetting"
#define PROVIDER_NAME_Win32_WIN32_TSACCOUNT_Prov                        L"Win32_TSAccount"
#define PROVIDER_NAME_Win32_WIN32_TERMINALSERVICETOSETTING_Prov         L"Win32_TerminalServiceToSetting"
#define PROVIDER_NAME_Win32_WIN32_TERMINALTERMINALSETTING_Prov          L"Win32_TerminalTerminalSetting"
#define PROVIDER_NAME_Win32_WIN32_TSSESSIONDIRECTORYSETTING_Prov        L"Win32_TSSessionDirectorySetting"


#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

#define WINSTATIONNAME_LENGTH 32 
#define WINSTATIONCOMMENT_LENGTH 60
#define APPSERVERNAME_LENGTH 17
#define USERNAME_LENGTH 20
#define PASSWORD_LENTH 14


class CWin32_Terminal : public Provider
{
public:
    // Constructor/destructor
    //=======================

    CWin32_Terminal(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_Terminal();
    

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================

    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
    virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );

    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);


private:  

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szEnableTerminal[ 64 ] ;
    TCHAR m_szNewTerminalName[ 64 ] ;
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szEnable[ 64 ];
    TCHAR m_szRename[ 64 ];
    TCHAR m_szDelete[ 64 ];

} ;


class CWin32_TSGeneralSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSGeneralSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSGeneralSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );
    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);


private:

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szTerminalProtocol[ 64 ];
    TCHAR m_szTransport[ 64 ];
    TCHAR m_szComment[ 64 ];
    TCHAR m_szWindowsAuthentication[ 64 ];
    TCHAR m_szEncryptionLevel[ 64 ];
    TCHAR m_szTerminalName[ 64 ];  
    TCHAR m_szSetEncryptionLevel[ 64 ];

} ;


class CWin32_TSLogonSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSLogonSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSLogonSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    
    
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);


private:

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szClientLogonInfoPolicy[ 64 ];
    TCHAR m_szPromptForPassword[ 64 ];
    TCHAR m_szUserName[ 64 ];
    TCHAR m_szDomain[ 64 ];
    TCHAR m_szPassword[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szExplicitLogon[ 64 ];
    TCHAR m_szSetPromptForPassword[ 64 ];

} ;




//-------------------------------------------

class CWin32_TSSessionSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSSessionSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSSessionSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );

    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);

private: 

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szTimeLimitPolicy[ 64 ];
    TCHAR m_szActiveSessionLimit[ 64 ];
    TCHAR m_szDisconnectedSessionLimit[ 64 ];
    TCHAR m_szIdleSessionLimit[ 64 ];
    TCHAR m_szBrokenConnectionPolicy[ 64 ];
    TCHAR m_szBrokenConnectionAction[ 64 ];
    TCHAR m_szReconnectionPolicy[ 64 ];
    TCHAR m_szSessionLimitType[ 64 ];
    TCHAR m_szValueLimit[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szTimeLimit[ 64 ];
    TCHAR m_szBrokenConnection[ 64 ];

} ;



//----------------------------------------------
class CWin32_TSEnvironmentSetting : public Provider
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSEnvironmentSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSEnvironmentSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );

    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);

private:  

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szInitialProgramPolicy[ 64 ];
    TCHAR m_szInitialProgramPath[ 64 ];
    TCHAR m_szStartIn[ 64 ];
    TCHAR m_szClientWallPaper[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szInitialProgram[ 64 ];
    TCHAR m_szSetClientWallPaper[ 64 ];

} ;


//-----------------------------------------------------

class CWin32_TSRemoteControlSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSRemoteControlSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSRemoteControlSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
   
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);

private: 

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);

    TCHAR m_szRemoteControlPolicy[ 64 ];
    TCHAR m_szLevelOfControl[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szRemoteControl[ 64 ];

} ;




//-----------------------------------------------------

class CWin32_TSClientSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSClientSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSClientSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query); 
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
 
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
   
    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS );

private: 

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szConnectionPolicy [ 64 ];
    TCHAR m_szConnectClientDrivesAtLogon[ 64 ];
    TCHAR m_szConnectPrinterAtLogon[ 64 ];
    TCHAR m_szDefaultToClientPrinter[ 64 ];
    TCHAR m_szWindowsPrinterMapping[ 64 ];
    TCHAR m_szLPTPortMapping[ 64 ];
    TCHAR m_szCOMPortMapping[ 64 ];
    TCHAR m_szDriveMapping[ 64 ];
    TCHAR m_szAudioMapping[ 64 ];
    TCHAR m_szClipboardMapping[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szPropertyName[ 64 ];
    TCHAR m_szValue[ 64 ];
    TCHAR m_szConnectionSettings[ 64 ];
    TCHAR m_szSetClientProperty[ 64 ];
    TCHAR m_szColorDepth[ 64 ];
    TCHAR m_szColorDepthPolicy[ 64 ];
    TCHAR m_szSetColorDepth[ 64 ];    
    TCHAR m_szSetColorDepthPolicy[ 64 ];

} ;



//-----------------------------------------------------

class CWin32_TSNetworkAdapterSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSNetworkAdapterSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSNetworkAdapterSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
   
    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);
 
private:  

    POLICY_TS_MACHINE m_gpPolicy;
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    TCHAR m_szNetworkAdapterName[ 64 ];
    TCHAR m_szNetworkAdapterID[ 64 ];
    TCHAR m_szNetworkAdapterIP[ 64 ];
    TCHAR m_szMaximumConnections[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szSelectAllNetworkAdapters[ 64 ];  
    TCHAR m_szSelectNetworkAdapterIP[ 64 ];

} ;

//-------------------------------

class CWin32_TSPermissionsSetting : public Provider 
{
public:
    // Constructor/destructor
    //=======================

    CWin32_TSPermissionsSetting(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
    virtual ~CWin32_TSPermissionsSetting();

protected:
    // Reading Functions
    //============================
    virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);
    
    // Writing Functions
    //============================
    virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );



    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PWS pWS);
   

private:  

    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    const WCHAR* m_pszPermissionPreSet;
  
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szAccountName[ 64 ];
    TCHAR m_szPermissionPreSet[ 64 ];
    TCHAR m_szPermissionMask[ 64 ];
    TCHAR m_szSID[ 64 ];  
    TCHAR m_szAddAccount[ 64 ];
    TCHAR m_szRestoreDefaults[ 64 ];
} ;

//=-------------------

class CWin32_TSNetworkAdapterListSetting : public Provider
{
private:    
    
    TCHAR m_szNetworkAdapterID[ 64 ];
    TCHAR m_szNetworkAdapterIP[ 64 ];
    TCHAR m_szDescription[ 64 ];    

protected:

    

public:
    CWin32_TSNetworkAdapterListSetting (const CHString& setName, LPCTSTR pszNameSpace =NULL);
	~CWin32_TSNetworkAdapterListSetting ();

	virtual HRESULT EnumerateInstances (MethodContext*  pMethodContext, long lFlags = 0L);

	virtual HRESULT GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query );

 //   HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, PTCHAR pdName, PTCHAR wdName, PTCHAR pGuid, PTCHAR DisplayName);

 //   virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

};	


//=---------------------

class CWin32_TSAccount : public Provider
{

protected:

    

public:
    CWin32_TSAccount (LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
	~CWin32_TSAccount ();

	virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
    virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query );
    virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

// Writing Functions
    //============================

    // Other Functions
    virtual HRESULT ExecMethod(const CInstance& Instance,
                    const BSTR bstrMethodName,
                    CInstance *pInParams,
                    CInstance *pOutParams,
                    long lFlags = 0L );
    HRESULT LoadPropertyValues( CInstance *pInstance, ULONGLONG ulRequiredProperties, 
                                PWS pWS, PUSERPERMLIST pUserList, PUSERPERMLIST pUserAuditList);

private:
    BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
    POLICY_TS_MACHINE m_gpPolicy;
    TCHAR m_szPermissionPreSet[ 64 ];
    TCHAR m_szTerminalName[ 64 ];
    TCHAR m_szAccountName[ 64 ];
    TCHAR m_szPermissionMask[ 64 ];
    TCHAR m_szPermissionsAllowed[ 64 ];
    TCHAR m_szPermissionsDenied[ 64 ];
    TCHAR m_szAuditSuccess[ 64 ];
    TCHAR m_szAuditFail[ 64 ]; 
    TCHAR m_szAllow[ 64 ];
    TCHAR m_szSuccess[ 64 ];
    TCHAR m_szSID[ 64 ];  
    TCHAR m_szDelete[ 64 ];
    TCHAR m_szModifyPermissions[ 64 ];
    TCHAR m_szModifyAuditPermissions[ 64 ];    

};	


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wtsapi\process.c ===
/*******************************************************************************
* process.c
*
* Published Terminal Server APIs
*
* - process routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#include <allproc.h>

#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif

#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>


/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSEnumerateProcessesW( HANDLE, DWORD, DWORD, PWTS_PROCESS_INFOW *, DWORD * );
BOOL WINAPI WTSEnumerateProcessesA( HANDLE, DWORD, DWORD, PWTS_PROCESS_INFOA *, DWORD * );
BOOL WINAPI WTSTerminateProcess( HANDLE, DWORD, DWORD );


/*=============================================================================
==   Procedures used
=============================================================================*/

VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );

/*=============================================================================
 * Internal function
 =============================================================================*/

BOOL
GetProcessSid(HANDLE          Server,
              HANDLE          hUniqueProcessId,
              LARGE_INTEGER   ProcessStartTime,
              PBYTE      *     pProcessUserSid     //Return the SID (allocated here..)
             );

/*=======================================================================
 * Private structure definitions
 *=========================================================================*/
typedef struct _SID_INFO {
    struct _SID_INFO * pNext;
    PBYTE pSid;
} SID_INFO;

/****************************************************************************
 *
 *  WTSEnumerateProcessesW (UNICODE)
 *
 *    Returns a list of Terminal Server Processes on the specified server
 *
 * ENTRY:
 *    hServer (input)
 *       Handle to a Terminal server (or WTS_CURRENT_SERVER)
 *    Reserved (input)
 *       Must be zero
 *    Version (input)
 *       Version of the enumeration request (must be 1)
 *    ppProcessInfo (output)
 *       Points to the address of a variable to receive the enumeration results,
 *       which are returned as an array of WTS_PROCESS_INFO structures.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pCount (output)
 *       Points to the address of a variable to receive the number of
 *       WTS_PROCESS_INFO structures returned
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

#if(WINVER >= 0x0500)
BOOL
WINAPI
WTSEnumerateProcessesW(
                      IN HANDLE hServer,
                      IN DWORD Reserved,
                      IN DWORD Version,
                      OUT PWTS_PROCESS_INFOW * ppProcessInfo,
                      OUT DWORD * pCount
                      )
{
    PBYTE pProcessBuffer = NULL;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    PCITRIX_PROCESS_INFORMATION pCitrixInfo;
    ULONG ProcessCount;
    ULONG Offset;
    ULONG DataLength;
    PWTS_PROCESS_INFOW pProcessW;
    PBYTE pProcessData;
    ULONG i;
    ULONG Length;
    PTS_ALL_PROCESSES_INFO  ProcessArray = NULL;
    DWORD dwError;


    SID_INFO   sidInfoHead;                  //The head of the Sid temp storage
    SID_INFO * pSidInfo;                     //Point to a list of temp storage for the
                                             //variable length SID
    sidInfoHead.pNext = NULL;
    sidInfoHead.pSid = NULL;
    pSidInfo = &sidInfoHead;


    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    if (!ppProcessInfo || !pCount) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    //
    // Try the new interface first (Windows 2000 server)
    //
    if (WinStationGetAllProcesses( hServer,
                                   GAP_LEVEL_BASIC,
                                   &ProcessCount,
                                   &ProcessArray) )
    {
        DataLength = 0;

        for (i=0; i<ProcessCount; i++)
        {
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[i].pTsProcessInfo);
            DataLength += (pProcessInfo->ImageName.Length + sizeof(WCHAR));
            if (ProcessArray[i].pSid)
            {
                DataLength += GetLengthSid( ProcessArray[i].pSid );
            }
        }

        /*
         *  Allocate user buffer
         */
        pProcessW = LocalAlloc( LPTR, (ProcessCount * sizeof(WTS_PROCESS_INFOW)) + DataLength );
        if ( pProcessW == NULL ) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto GAPErrorReturn;
        }

        /*
         *  Update user parameters
         */
        *ppProcessInfo = pProcessW;
        *pCount = ProcessCount;

        /*
         *  Copy data to new buffer
         */
        pProcessData = (PBYTE)pProcessW + (ProcessCount * sizeof(WTS_PROCESS_INFOW));
        for ( i=0; i < ProcessCount; i++ ) {

            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION)(ProcessArray[i].pTsProcessInfo);

            Length = pProcessInfo->ImageName.Length; // number of bytes

            pProcessW->pProcessName = (LPWSTR) pProcessData;
            memcpy( pProcessData, pProcessInfo->ImageName.Buffer, Length );
            *(pProcessData += Length) = (WCHAR)0;
            pProcessData += sizeof(WCHAR);

            pProcessW->ProcessId = (ULONG)(ULONG_PTR)pProcessInfo->UniqueProcessId;
            pProcessW->SessionId = pProcessInfo->SessionId;
            if (ProcessArray[i].pSid)
            {
                Length = GetLengthSid( ProcessArray[i].pSid );
                pProcessW->pUserSid = (LPWSTR) pProcessData;
                memcpy( pProcessData, ProcessArray[i].pSid, Length );
                pProcessData += Length;
            }

            pProcessW++;
        }
        //
        // Free ppProcessArray and all child pointers allocated by the client stub.
        //
        WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, ProcessCount);

    }
    else    // Maybe a TS 4.0 server ?
    {
        //
        //   Check the return code indicating that the interface is not available.
        //
        dwError = GetLastError();
        if (dwError != RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            goto badenum;
        }
        else
        {
            // It might be a TS4.0 server
            // Try the old interface
            //
            //
            //  Enumerate Processes and check for an error
            //
            if ( !WinStationEnumerateProcesses( hServer, &pProcessBuffer ) ) {
                goto badenum;
            }

            //
            //  Count the number of processes and total up the size of the data
            //
            ProcessCount = 0;
            DataLength = 0;
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
            Offset = 0;
            do {

                pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

                ProcessCount++;

                DataLength += (pProcessInfo->ImageName.Length + sizeof(WCHAR));

                pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)pProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)pProcessInfo->NumberOfThreads));

                if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
                    if ( pCitrixInfo->ProcessSid )
                        DataLength += GetLengthSid( pCitrixInfo->ProcessSid );
                }

                Offset = pProcessInfo->NextEntryOffset;

            } while ( Offset != 0 );

            /*
             *  Allocate user buffer
             */
            pProcessW = LocalAlloc( LPTR, (ProcessCount * sizeof(WTS_PROCESS_INFOW)) + DataLength );
            if ( pProcessW == NULL ) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto badalloc;
            }

            /*
             *  Update user parameters
             */
            *ppProcessInfo = pProcessW;
            *pCount = ProcessCount;

            /*
             *  Copy data to new buffer
             */
            pProcessData = (PBYTE)pProcessW + (ProcessCount * sizeof(WTS_PROCESS_INFOW));
            pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
            Offset = 0;
            for ( i=0; i < ProcessCount; i++ ) {

                pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

                Length = pProcessInfo->ImageName.Length; // number of bytes

                pProcessW->pProcessName = (LPWSTR) pProcessData;
                memcpy( pProcessData, pProcessInfo->ImageName.Buffer, Length );
                *(pProcessData += Length) = (WCHAR)0;
                pProcessData += sizeof(WCHAR);

                pProcessW->ProcessId = pProcessInfo->UniqueProcessId;

                /*
                 * Point to the CITRIX_INFORMATION which follows the Threads
                 */
                pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                             (((PUCHAR)pProcessInfo) +
                              SIZEOF_TS4_SYSTEM_PROCESS_INFORMATION +
                              (SIZEOF_TS4_SYSTEM_THREAD_INFORMATION * (int)pProcessInfo->NumberOfThreads));

                if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
                    pProcessW->SessionId = pCitrixInfo->LogonId;
                    if ( pCitrixInfo->ProcessSid ) {
                        Length = GetLengthSid( pCitrixInfo->ProcessSid );
                        pProcessW->pUserSid = (LPWSTR) pProcessData;
                        memcpy( pProcessData, pCitrixInfo->ProcessSid, Length );
                        pProcessData += Length;
                    }
                } else {
                    pProcessW->SessionId = (ULONG) -1;
                }

                pProcessW++;
                Offset = pProcessInfo->NextEntryOffset;
            }

            /*
             *  Free original Process list buffer
             */
            WinStationFreeMemory( pProcessBuffer );

        }
    }
    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

GAPErrorReturn:
    //
    // Free ppProcessArray and all child pointers allocated by the client stub.
    //
    WinStationFreeGAPMemory(GAP_LEVEL_BASIC, ProcessArray, ProcessCount);
    goto enderror;

badalloc:
    WinStationFreeMemory( pProcessBuffer );

badenum:
badparam:
enderror:
    if (ppProcessInfo) *ppProcessInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}

#else //#if(WINVER>=0x0500)

BOOL
WINAPI
WTSEnumerateProcessesW(
                      IN HANDLE hServer,
                      IN DWORD Reserved,
                      IN DWORD Version,
                      OUT PWTS_PROCESS_INFOW * ppProcessInfo,
                      OUT DWORD * pCount
                      )
{
    PBYTE pProcessBuffer;
    PTS_SYS_PROCESS_INFORMATION pProcessInfo;
    PCITRIX_PROCESS_INFORMATION pCitrixInfo;
    ULONG ProcessCount;
    ULONG Offset;
    ULONG DataLength;
    PWTS_PROCESS_INFOW pProcessW;
    PBYTE pProcessData;
    ULONG i;
    ULONG Length;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }


    if (!ppProcessInfo || !pCount) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    /*
     *  Enumerate Processes and check for an error
     */
    if ( !WinStationEnumerateProcesses( hServer, &pProcessBuffer ) ) {
        goto badenum;
    }

    /*
     *  Count the number of processes and total up the size of the data
     */
    ProcessCount = 0;
    DataLength = 0;
    pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
    Offset = 0;
    do {

        pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

        ProcessCount++;

        DataLength += (pProcessInfo->ImageName.Length + sizeof(WCHAR));

        pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                      ((PBYTE)pProcessInfo +
                       sizeof(SYSTEM_PROCESS_INFORMATION) +
                       (sizeof(SYSTEM_THREAD_INFORMATION) *
                        pProcessInfo->NumberOfThreads));

        if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
            if ( pCitrixInfo->ProcessSid )
                DataLength += GetLengthSid( pCitrixInfo->ProcessSid );
        }

        Offset = pProcessInfo->NextEntryOffset;

    } while ( Offset != 0 );

    /*
     *  Allocate user buffer
     */
    pProcessW = LocalAlloc( LPTR, (ProcessCount * sizeof(WTS_PROCESS_INFOW)) + DataLength );
    if ( pProcessW == NULL ) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto badalloc;
    }

    /*
     *  Update user parameters
     */
    *ppProcessInfo = pProcessW;
    *pCount = ProcessCount;

    /*
     *  Copy data to new buffer
     */
    pProcessData = (PBYTE)pProcessW + (ProcessCount * sizeof(WTS_PROCESS_INFOW));
    pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) pProcessBuffer;
    Offset = 0;
    for ( i=0; i < ProcessCount; i++ ) {

        pProcessInfo = (PTS_SYS_PROCESS_INFORMATION) ((PBYTE)pProcessInfo + Offset);

        Length = pProcessInfo->ImageName.Length; // number of bytes

        pProcessW->pProcessName = (LPWSTR) pProcessData;
        memcpy( pProcessData, pProcessInfo->ImageName.Buffer, Length );
        *(pProcessData += Length) = (WCHAR)0;
        pProcessData += sizeof(WCHAR);

        pProcessW->ProcessId = (ULONG) pProcessInfo->UniqueProcessId;

        /*
         * Point to the CITRIX_INFORMATION which follows the Threads
         */
        pCitrixInfo = (PCITRIX_PROCESS_INFORMATION)
                      ((PBYTE)pProcessInfo +
                       sizeof(SYSTEM_PROCESS_INFORMATION) +
                       (sizeof(SYSTEM_THREAD_INFORMATION) *
                        pProcessInfo->NumberOfThreads));

        if ( pCitrixInfo->MagicNumber == CITRIX_PROCESS_INFO_MAGIC ) {
            pProcessW->SessionId = pCitrixInfo->LogonId;
            if ( pCitrixInfo->ProcessSid ) {
                Length = GetLengthSid( pCitrixInfo->ProcessSid );
                pProcessW->pUserSid = (LPWSTR) pProcessData;
                memcpy( pProcessData, pCitrixInfo->ProcessSid, Length );
                pProcessData += Length;
            }
        } else {
            pProcessW->SessionId = (ULONG) -1;
        }

        pProcessW++;
        Offset = pProcessInfo->NextEntryOffset;
    }

    /*
     *  Free original Process list buffer
     */
    WinStationFreeMemory( pProcessBuffer );

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:
    WinStationFreeMemory( pProcessBuffer );

    badenum:
    badparam:
    if (ppProcessInfo) *ppProcessInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}
#endif //#if(WINVER>=0x0500)

/****************************************************************************
 *
 *  WTSEnumerateProcessesA (ANSI stub)
 *
 *    Returns a list of Terminal Server Processes on the specified server
 *
 * ENTRY:
 *
 *    see WTSEnumerateProcessesW
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateProcessesA(
                      IN HANDLE hServer,
                      IN DWORD Reserved,
                      IN DWORD Version,
                      OUT PWTS_PROCESS_INFOA * ppProcessInfo,
                      OUT DWORD * pCount
                      )
{
    PWTS_PROCESS_INFOW pProcessW;
    PWTS_PROCESS_INFOA pProcessA;
    PBYTE pProcessData;
    ULONG Length;
    ULONG DataLength;           // number of bytes of name data
    ULONG NameCount;
    ULONG i;

    /*
     *  Enumerate processes (UNICODE)
     */
    if ( !WTSEnumerateProcessesW( hServer,
                                  Reserved,
                                  Version,
                                  &pProcessW,
                                  &NameCount ) ) {
        goto badenum;
    }

    /*
     *  Calculate the length of the name data
     */
    for ( i=0, DataLength=0; i < NameCount; i++ ) {
        DataLength += (wcslen(pProcessW[i].pProcessName) + 1);
        if ( pProcessW[i].pUserSid )
            DataLength += GetLengthSid( pProcessW[i].pUserSid );
    }

    /*
     *  Allocate user buffer
     */
    pProcessA = LocalAlloc( LPTR, (NameCount * sizeof(WTS_PROCESS_INFOA)) + DataLength );
    if ( pProcessA == NULL )
        goto badalloc2;

    /*
     *  Convert unicode process list to ansi
     */
    pProcessData = (PBYTE)pProcessA + (NameCount * sizeof(WTS_PROCESS_INFOA));
    for ( i=0; i < NameCount; i++ ) {

        pProcessA[i].SessionId = pProcessW[i].SessionId;
        pProcessA[i].ProcessId = pProcessW[i].ProcessId;

        Length = wcslen(pProcessW[i].pProcessName) + 1;
        pProcessA[i].pProcessName = pProcessData;
        UnicodeToAnsi( pProcessData, DataLength, pProcessW[i].pProcessName );
        DataLength -= Length;
        pProcessData += Length;

        if ( pProcessW[i].pUserSid ) {
            Length = GetLengthSid( pProcessW[i].pUserSid );
            pProcessA[i].pUserSid = pProcessData;
            memcpy( pProcessData, pProcessW[i].pUserSid, Length );
            DataLength -= Length;
            pProcessData += Length;
        }
    }

    /*
     *  Free unicode process list buffer
     */
    LocalFree( pProcessW );

    /*
     *  Update user parameters
     */
    if (ppProcessInfo) {
        *ppProcessInfo = pProcessA;
    } else {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return(FALSE);
    }
    if (pCount) {
        *pCount = NameCount;
    } else {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return(FALSE);
    }


    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/


    badalloc2:
    LocalFree( pProcessW );

    badenum:
    // make sure the passed parameter buffer pointer is not NULL
    if (ppProcessInfo) *ppProcessInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}


/*******************************************************************************
 *
 *  WTSTerminateProcess
 *
 *    Terminate the specified process
 *
 * ENTRY:
 *
 *    hServer (input)
 *       handle to Terminal server
 *    ProcessId (input)
 *       process id of the process to terminate
 *    ExitCode (input)
 *       Termination status for each thread in the process
 *
 *
 * EXIT:
 *
 *    TRUE  -- The terminate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ******************************************************************************/

BOOL WINAPI
WTSTerminateProcess(
                   HANDLE hServer,
                   DWORD ProcessId,
                   DWORD ExitCode
                   )
{
    return( WinStationTerminateProcess( hServer, ProcessId, ExitCode ) );
}
#if(WINVER >= 0x0500)
//======================================================================//
// Private functions                                                    //
//======================================================================//
BOOL
GetProcessSid(HANDLE          hServer,
              HANDLE          hUniqueProcessId,
              LARGE_INTEGER    ProcessStartTime,
              PBYTE *          ppSid                     //Return the SID (allocated here..)
             )
{
    DWORD dwSidSize;
    BYTE  tmpSid[128];      //temp storage
    FILETIME  startTime;

    dwSidSize = sizeof(tmpSid);
    *ppSid =  NULL;

    //Convert the time format
    startTime.dwLowDateTime = ProcessStartTime.LowPart;
    startTime.dwHighDateTime = ProcessStartTime.HighPart;

    //-------------------------------------------//
    // Get the SID with the temp Sid storage     //
    //-------------------------------------------//
    if (!WinStationGetProcessSid(hServer,
                                 (DWORD)(ULONG_PTR)hUniqueProcessId,
                                 startTime,
                                 (PBYTE)&tmpSid,
                                 &dwSidSize
                                )) {
        //-------------------------------------------//
        // Sid is too big for the temp storage       //
        //Get the size of the sid and do it again    //
        //-------------------------------------------//
        NTSTATUS status;
        if ((status = GetLastError()) == STATUS_BUFFER_TOO_SMALL) {
            *ppSid = LocalAlloc(LPTR, dwSidSize);
            if (!*ppSid) {
                SetLastError(ERROR_OUTOFMEMORY);
                goto ErrorReturn;
            }
        } else if (dwSidSize == 0) {
            *ppSid = NULL;
            return TRUE;
        } else {
            SetLastError(status);
            goto ErrorReturn;
        }
        //-------------------------------------------//
        // Call the server again to get the SID
        //-------------------------------------------//
        if (!WinStationGetProcessSid(hServer,
                                     (DWORD)(ULONG_PTR)hUniqueProcessId,
                                     startTime,
                                     (PBYTE)ppSid,
                                     &dwSidSize
                                    )) {
            goto ErrorReturn;
        }

    } else {

        //-------------------------------------------//
        // Temp Sid is large enough                  //
        // Allocate the correct size and copy the    //
        // Sid                                       //
        //-------------------------------------------//
        *ppSid = LocalAlloc(LPTR, dwSidSize);
        if (*ppSid) {
            memcpy(*ppSid, tmpSid, dwSidSize);
        } else {
            SetLastError(ERROR_OUTOFMEMORY);
            goto ErrorReturn;
        }
    }

    return TRUE;
ErrorReturn:
    if (*ppSid) {
        LocalFree(*ppSid);
        *ppSid = NULL;
    }
    return FALSE;
}
#endif //#if(WINVER >= 0x0500)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wtsapi\server.c ===
/*******************************************************************************
* server.c
*
* Published Terminal Server APIs
*
* - server routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif
#include <utildll.h>
#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>

/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSEnumerateServersW( LPWSTR, DWORD, DWORD, PWTS_SERVER_INFOW *, DWORD * );
BOOL WINAPI WTSEnumerateServersA( LPSTR, DWORD, DWORD, PWTS_SERVER_INFOA *, DWORD * );
HANDLE WINAPI WTSOpenServerW( LPWSTR );
HANDLE WINAPI WTSOpenServerA( LPSTR );
VOID   WINAPI WTSCloseServer( HANDLE );


/*=============================================================================
==   Procedures used
=============================================================================*/

VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );


/****************************************************************************
 *
 *  WTSEnumerateServersW (UNICODE)
 *
 *    Returns a list of Terminal servers within the specified NT domain
 *
 * ENTRY:
 *    pDomainName (input)
 *       Pointer to NT domain name (or NULL for current domain)
 *    Reserved (input)
 *       Must be zero
 *    Version (input)
 *       Version of the enumeration request (must be 1)
 *    ppServerInfo (output)
 *       Points to the address of a variable to receive the enumeration results,
 *       which are returned as an array of WTS_SERVER_INFO structures.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pCount (output)
 *       Points to the address of a variable to receive the number of
 *       WTS_SERVER_INFO structures returned
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateServersW(
                    IN LPWSTR pDomainName,
                    IN DWORD Reserved,
                    IN DWORD Version,
                    OUT PWTS_SERVER_INFOW * ppServerInfo,
                    OUT DWORD * pCount
                    )
{
    LPWSTR pServerList;
    LPWSTR pData;
    PBYTE pNameData;
    ULONG Length;
    ULONG NameCount;            // number of names
    ULONG NameLength;           // number of bytes of name data
    PWTS_SERVER_INFOW pServerW;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    if ( !ppServerInfo || !pCount) {
        SetLastError( ERROR_INVALID_USER_BUFFER);
        goto badparam;
    }

    /*
     *  Enumerate servers and check for an error
     */
    pServerList = EnumerateMultiUserServers( pDomainName );
    
    if ( pServerList == NULL ) {
        SetLastError(ERROR_INVALID_DOMAINNAME);
        goto badenum;
    }

    /*
     *  Count the number of Terminal servers
     */
    NameCount = 0;
    NameLength = 0;
    pData = pServerList;
    while ( *pData ) {
        Length = (wcslen(pData) + 1) * sizeof(WCHAR); // number of bytes
        NameCount++;
        NameLength += Length;
        (PBYTE)pData += Length;
    }

    /*
     *  Allocate user buffer
     */
    pServerW = LocalAlloc( LPTR, (NameCount * sizeof(WTS_SERVER_INFOW)) + NameLength );
    if ( pServerW == NULL )
        goto badalloc;

    /*
     *  Update user parameters
     */
    *ppServerInfo = pServerW;
    *pCount = NameCount;

    /*
     *  Copy data to new buffer
     */
    pData = pServerList;
    pNameData = (PBYTE)pServerW + (NameCount * sizeof(WTS_SERVER_INFOW));
    while ( *pData ) {

        Length = (wcslen(pData) + 1) * sizeof(WCHAR); // number of bytes

        memcpy( pNameData, pData, Length );
        pServerW->pServerName = (LPWSTR) pNameData;

        pServerW++;
        pNameData += Length;
        (PBYTE)pData += Length;
    }

    /*
     *  Free original server list buffer
     */
    LocalFree( pServerList );
    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:

    badenum:
    badparam:
    if (ppServerInfo) *ppServerInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}



/****************************************************************************
 *
 *  WTSEnumerateServersA (ANSI stub)
 *
 *    Returns a list of Terminal servers within the specified NT domain
 *
 * ENTRY:
 *
 *    see WTSEnumerateServersW
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateServersA(
                    IN LPSTR pDomainName,
                    IN DWORD Reserved,
                    IN DWORD Version,
                    OUT PWTS_SERVER_INFOA * ppServerInfo,
                    OUT DWORD * pCount
                    )
{
    LPWSTR pDomainNameW = NULL;
    ULONG DomainNameWLength;
    PWTS_SERVER_INFOW pServerW;
    PWTS_SERVER_INFOA pServerA;
    PBYTE pNameData;
    ULONG Length;
    ULONG NameLength;           // number of bytes of name data
    ULONG NameCount;
    ULONG i;

    if ( !ppServerInfo || !pCount) {
        SetLastError( ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }


    /*
     *  Convert ansi domain name to unicode
     */
    if ( pDomainName ) {
        DomainNameWLength = (strlen(pDomainName) + 1) * sizeof(WCHAR);
        if ( (pDomainNameW = LocalAlloc( LPTR, DomainNameWLength )) == NULL )
            goto badalloc1;
        AnsiToUnicode( pDomainNameW, DomainNameWLength, pDomainName );
    }

    /*
     *  Enumerate servers (UNICODE)
     */
    if ( !WTSEnumerateServersW( pDomainNameW,
                                Reserved,
                                Version,
                                &pServerW,
                                &NameCount ) ) {
        goto badenum;
    }

    /*
     *  Calculate the length of the name data
     */
    for ( i=0, NameLength=0; i < NameCount; i++ ) {
        NameLength += (wcslen(pServerW[i].pServerName) + 1);
    }

    /*
     *  Allocate user buffer
     */
    pServerA = LocalAlloc( LPTR, (NameCount * sizeof(WTS_SERVER_INFOA)) + NameLength );
    if ( pServerA == NULL )
        goto badalloc2;

    /*
     *  Convert unicode server list to ansi
     */
    pNameData = (PBYTE)pServerA + (NameCount * sizeof(WTS_SERVER_INFOA));
    for ( i=0; i < NameCount; i++ ) {
        Length = wcslen(pServerW[i].pServerName) + 1;

        pServerA[i].pServerName = pNameData;
        UnicodeToAnsi( pNameData, NameLength, pServerW[i].pServerName );

        NameLength -= Length;
        pNameData += Length;
    }

    /*
     *  Free unicode server list buffer
     */
    LocalFree( pServerW );

    /*
     *  Free domain name buffer
     */
    if ( pDomainNameW )
        LocalFree( pDomainNameW );

    /*
     *  Update user parameters
     */
    *ppServerInfo = pServerA;
    *pCount = NameCount;

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/


    badalloc2:
    LocalFree( pServerW );

    badenum:
    if ( pDomainNameW )
        LocalFree( pDomainNameW );

    badalloc1:
    *ppServerInfo = NULL;
    *pCount = 0;

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSOpenServerW (UNICODE)
 *
 *    Opens a handle to the specified server
 *
 *    NOTE: WTS_SERVER_CURRENT can be used as a handle to the current server
 *
 * ENTRY:
 *    pServerName (input)
 *       Pointer to Terminal server name
 *
 * EXIT:
 *
 *    Handle to specified server (NULL on error)
 *
 *
 ****************************************************************************/

HANDLE
WINAPI
WTSOpenServerW(
              IN LPWSTR pServerName
              )
{
    return( WinStationOpenServerW( pServerName ) );
}


/****************************************************************************
 *
 *  WTSOpenServerA (ANSI)
 *
 *    Opens a handle to the specified server
 *
 *    NOTE: WTS_SERVER_CURRENT can be used as a handle to the current server
 *
 * ENTRY:
 *    pServerName (input)
 *       Pointer to Terminal server name
 *
 * EXIT:
 *
 *    Handle to specified server
 *
 *
 ****************************************************************************/

HANDLE
WINAPI
WTSOpenServerA(
              IN LPSTR pServerName
              )
{
    return( WinStationOpenServerA( pServerName ) );
}


/****************************************************************************
 *
 *  WTSCloseServer
 *
 *    Close server handle
 *
 * ENTRY:
 *    hServer (input)
 *       handle to server
 *
 * EXIT:
 *    nothing
 *
 ****************************************************************************/

VOID
WINAPI
WTSCloseServer(
              IN HANDLE hServer
              )
{
    (void) WinStationCloseServer( hServer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wtsapi\session.c ===
/*******************************************************************************
* session.c
*
* Published Terminal Server APIs
*
* - session routines
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>
#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif
#include <utildll.h>
#include <winsock.h>    // for AF_INET, etc.

#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>


/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSEnumerateSessionsW( HANDLE, DWORD, DWORD, PWTS_SESSION_INFOW *,
                                   DWORD * );
BOOL WINAPI WTSEnumerateSessionsA( HANDLE, DWORD, DWORD, PWTS_SESSION_INFOA *,
                                   DWORD * );
BOOL WINAPI WTSQuerySessionInformationW( HANDLE, DWORD, WTS_INFO_CLASS,
                                         LPWSTR *, DWORD * );
BOOL WINAPI WTSQuerySessionInformationA( HANDLE, DWORD, WTS_INFO_CLASS,
                                         LPSTR *, DWORD * );
BOOL WINAPI WTSSendMessageW( HANDLE, DWORD, LPWSTR, DWORD, LPWSTR, DWORD,
                             DWORD, DWORD, DWORD *, BOOL );
BOOL WINAPI WTSSendMessageA( HANDLE, DWORD, LPSTR, DWORD, LPSTR, DWORD,
                             DWORD, DWORD, DWORD *, BOOL );
BOOL WINAPI WTSDisconnectSession( HANDLE, DWORD, BOOL );
BOOL WINAPI WTSLogoffSession( HANDLE, DWORD, BOOL );


/*=============================================================================
==   Internal procedures defined
=============================================================================*/

BOOL _CopyData( PVOID, ULONG, LPWSTR *, DWORD * );
BOOL _CopyStringW( LPWSTR, LPWSTR *, DWORD * );
BOOL _CopyStringA( LPSTR, LPWSTR *, DWORD * );
BOOL _CopyStringWtoA( LPWSTR, LPSTR *, DWORD * );
BOOL ValidateCopyAnsiToUnicode(LPSTR, DWORD, LPWSTR);
BOOL ValidateCopyUnicodeToUnicode(LPWSTR, DWORD, LPWSTR);


/*=============================================================================
==   Procedures used
=============================================================================*/

VOID UnicodeToAnsi( CHAR *, ULONG, WCHAR * );
VOID AnsiToUnicode( WCHAR *, ULONG, CHAR * );


/*=============================================================================
==   Local Data
=============================================================================*/

/*
 *  Table to map WINSTATIONSTATECLASS to WTS_CONNECTSTATE_CLASS
 */
WTS_CONNECTSTATE_CLASS WTSStateMapping[] =
{
    WTSActive,
    WTSConnected,
    WTSConnectQuery,
    WTSShadow,
    WTSDisconnected,
    WTSIdle,
    WTSListen,
    WTSReset,
    WTSDown,
    WTSInit,
};

/****************************************************************************
 *
 *  WTSEnumerateSessionsW (UNICODE)
 *
 *    Returns a list of Terminal Server Sessions on the specified server
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    Reserved (input)
 *       Must be zero
 *    Version (input)
 *       Version of the enumeration request (must be 1)
 *    ppSessionInfo (output)
 *       Points to the address of a variable to receive the enumeration results,
 *       which are returned as an array of WTS_SESSION_INFO structures.  The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pCount (output)
 *       Points to the address of a variable to receive the number of
 *       WTS_SESSION_INFO structures returned
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateSessionsW(
                     IN HANDLE hServer,
                     IN DWORD Reserved,
                     IN DWORD Version,
                     OUT PWTS_SESSION_INFOW * ppSessionInfo,
                     OUT DWORD * pCount
                     )
{
    PWTS_SESSION_INFOW pSessionW;
    PLOGONIDW pLogonIds;
    PLOGONIDW pLogonId;
    ULONG SessionCount;
    ULONG NameLength;
    PBYTE pNameData;
    ULONG Length;
    ULONG i;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }

    if (!ppSessionInfo || !pCount) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        goto badparam;
    }

    /*
     *  Enumerate Sessions and check for an error
     */
    if ( !WinStationEnumerateW( hServer,
                                &pLogonIds,
                                &SessionCount ) ) {
        goto badenum;
    }

    /*
     *  Total up the size of the session data
     */
    NameLength = 0;
    for ( i=0; i < SessionCount; i++ ) {
        NameLength += ((wcslen(pLogonIds[i].WinStationName) + 1) * sizeof(WCHAR)); // number of bytes
    }

    /*
     *  Allocate user buffer
     */
    pSessionW = LocalAlloc( LPTR, (SessionCount * sizeof(WTS_SESSION_INFOW)) + NameLength );
    if ( pSessionW == NULL )
        goto badalloc;

    /*
     *  Update user parameters
     */
    *ppSessionInfo = pSessionW;
    *pCount = SessionCount;

    /*
     *  Copy data to new buffer
     */
    pNameData = (PBYTE)pSessionW + (SessionCount * sizeof(WTS_SESSION_INFOW));
    for ( i=0; i < SessionCount; i++ ) {

        pLogonId = &pLogonIds[i];

        Length = (wcslen(pLogonId->WinStationName) + 1) * sizeof(WCHAR); // number of bytes

        memcpy( pNameData, pLogonId->WinStationName, Length );
        pSessionW->pWinStationName = (LPWSTR) pNameData;
        pSessionW->SessionId = pLogonId->LogonId;
        pSessionW->State = WTSStateMapping[ pLogonId->State ];

        pSessionW++;
        pNameData += Length;
    }

    /*
     *  Free original Session list buffer
     */
    WinStationFreeMemory( pLogonIds );

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:
    WinStationFreeMemory( pLogonIds );

    badenum:
    badparam:
    if (ppSessionInfo) *ppSessionInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSEnumerateSessionsA (ANSI stub)
 *
 *    Returns a list of Terminal Server Sessions on the specified server
 *
 * ENTRY:
 *
 *    see WTSEnumerateSessionsW
 *
 * EXIT:
 *
 *    TRUE  -- The enumerate operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSEnumerateSessionsA(
                     IN HANDLE hServer,
                     IN DWORD Reserved,
                     IN DWORD Version,
                     OUT PWTS_SESSION_INFOA * ppSessionInfo,
                     OUT DWORD * pCount
                     )
{
    PWTS_SESSION_INFOA pSessionA;
    PLOGONIDA pLogonIds;
    PLOGONIDA pLogonId;
    ULONG SessionCount;
    ULONG NameLength;
    PBYTE pNameData;
    ULONG Length;
    ULONG i;

    /*
     *  Validate parameters
     */
    if ( Reserved != 0 || Version != 1 ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        goto badparam;
    }


    if (!ppSessionInfo || !pCount) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        goto badparam;
    }
    /*
     *  Enumerate Sessions and check for an error
     */
    if ( !WinStationEnumerateA( hServer,
                                &pLogonIds,
                                &SessionCount ) ) {
        goto badenum;
    }

    /*
     *  Total up the size of the session data
     */
    NameLength = 0;
    for ( i=0; i < SessionCount; i++ ) {
        NameLength += (strlen(pLogonIds[i].WinStationName) + 1); // number of bytes
    }

    /*
     *  Allocate user buffer
     */
    pSessionA = LocalAlloc( LPTR, (SessionCount * sizeof(WTS_SESSION_INFOA)) + NameLength );
    if ( pSessionA == NULL )
        goto badalloc;

    /*
     *  Update user parameters
     */
    *ppSessionInfo = pSessionA;
    *pCount = SessionCount;

    /*
     *  Copy data to new buffer
     */
    pNameData = (PBYTE)pSessionA + (SessionCount * sizeof(WTS_SESSION_INFOA));
    for ( i=0; i < SessionCount; i++ ) {

        pLogonId = &pLogonIds[i];

        Length = strlen(pLogonId->WinStationName) + 1; // number of bytes

        memcpy( pNameData, pLogonId->WinStationName, Length );
        pSessionA->pWinStationName = (LPSTR) pNameData;
        pSessionA->SessionId = pLogonId->LogonId;
        pSessionA->State = WTSStateMapping[ pLogonId->State ];

        pSessionA++;
        pNameData += Length;
    }

    /*
     *  Free original Session list buffer
     */
    WinStationFreeMemory( pLogonIds );

    return( TRUE );

    /*=============================================================================
    ==   Error return
    =============================================================================*/

    badalloc:
    WinStationFreeMemory( pLogonIds );

    badenum:
    badparam:
    if (ppSessionInfo) *ppSessionInfo = NULL;
    if (pCount) *pCount = 0;

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSQuerySessionInformationW (UNICODE)
 *
 *    Query information for the specified session and server
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    WTSInfoClass (input)
 *       Specifies the type of information to retrieve from the specified
 *       session
 *    ppBuffer (output)
 *       Points to the address of a variable to receive information about
 *       the specified session.  The format and contents of the data
 *       depend on the specified information class being queried. The
 *       buffer is allocated within this API and is disposed of using
 *       WTSFreeMemory.
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQuerySessionInformationW(
                           IN HANDLE hServer,
                           IN DWORD SessionId,
                           IN WTS_INFO_CLASS WTSInfoClass,
                           OUT LPWSTR * ppBuffer,
                           OUT DWORD * pBytesReturned
                           )
{
    PWINSTATIONCONFIGW pWSConfig = NULL;
    PWINSTATIONINFORMATIONW pWSInfo = NULL;
    PWINSTATIONCLIENT pWSClient = NULL;
    WTS_CLIENT_DISPLAY ClientDisplay;
    WTS_CLIENT_ADDRESS ClientAddress;
    ULONG WSModulesLength;
    ULONG BytesReturned;
    ULONG i;
    BYTE Version;
    BOOL fSuccess = FALSE;

    if (!ppBuffer || !pBytesReturned) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    /*
     *  Query WinStation Data
     */

    switch ( WTSInfoClass ) {

    case WTSInitialProgram :
    case WTSApplicationName :
    case WTSWorkingDirectory :
    case WTSOEMId :

        pWSConfig = LocalAlloc( LPTR, sizeof(WINSTATIONCONFIGW) );

        if ( pWSConfig == NULL )
            goto no_memory;

        if ( !WinStationQueryInformationW( hServer,
                                           SessionId,
                                           WinStationConfiguration,
                                           pWSConfig,
                                           sizeof(WINSTATIONCONFIGW),
                                           &BytesReturned ) ) {
            goto badquery;
        }
        break;
    }

    switch ( WTSInfoClass ) {

    case WTSSessionId :

        pWSInfo = LocalAlloc( LPTR, sizeof(WINSTATIONINFORMATIONW) );

        if ( pWSInfo == NULL )
            goto no_memory;

        //
        // no need to make a rpc call here
        //

        if (WTS_CURRENT_SESSION == SessionId)
        {
            pWSInfo->LogonId = NtCurrentPeb()->SessionId;
        }
        else
        {
            //
            // why would anybody want to know non current sessionid ?
            //
            pWSInfo->LogonId = SessionId;
        }

        BytesReturned = sizeof(pWSInfo->LogonId);
        break;


    case WTSUserName :
    case WTSWinStationName :
    case WTSDomainName :
    case WTSConnectState :

        pWSInfo = LocalAlloc( LPTR, sizeof(WINSTATIONINFORMATIONW) );

        if ( pWSInfo == NULL )
            goto no_memory;

        if ( !WinStationQueryInformationW( hServer,
                                           SessionId,
                                           WinStationInformation,
                                           pWSInfo,
                                           sizeof(WINSTATIONINFORMATIONW),
                                           &BytesReturned ) ) {
            goto badquery;
        }
        break;
    }

    switch ( WTSInfoClass ) {

    case WTSClientBuildNumber :
    case WTSClientName :
    case WTSClientDirectory :
    case WTSClientProductId :
    case WTSClientHardwareId :
    case WTSClientAddress :
    case WTSClientDisplay :
    case WTSClientProtocolType :

        pWSClient = LocalAlloc( LPTR, sizeof(WINSTATIONCLIENT) );

        if ( pWSClient == NULL )
            goto no_memory;

        if ( !WinStationQueryInformationW( hServer,
                                           SessionId,
                                           WinStationClient,
                                           pWSClient,
                                           sizeof(WINSTATIONCLIENT),
                                           &BytesReturned ) ) {
            goto badquery;
        }
        break;
    }

    /*
     *  Copy the data to the users buffer
     */
    switch ( WTSInfoClass ) {

    case WTSInitialProgram :

        if ( SessionId == 0 )
            return( FALSE );

        fSuccess = _CopyStringW( pWSConfig->User.InitialProgram,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSApplicationName :

        if ( SessionId == 0 )
            return( FALSE );

        fSuccess = _CopyStringW( pWSConfig->User.PublishedName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSWorkingDirectory :

        fSuccess = _CopyStringW( pWSConfig->User.WorkDirectory,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSOEMId :

        fSuccess = _CopyStringA( pWSConfig->OEMId,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSSessionId :

        fSuccess = _CopyData( &(pWSInfo->LogonId),
                              sizeof(pWSInfo->LogonId),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSConnectState :

        fSuccess = _CopyData( &(pWSInfo->ConnectState),
                              sizeof(pWSInfo->ConnectState),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSWinStationName :

        fSuccess = _CopyStringW( pWSInfo->WinStationName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSUserName :

        fSuccess = _CopyStringW( pWSInfo->UserName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSDomainName :

        fSuccess = _CopyStringW( pWSInfo->Domain,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSClientBuildNumber :

        fSuccess = _CopyData( &(pWSClient->ClientBuildNumber),
                              sizeof(pWSClient->ClientBuildNumber),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientName :

        fSuccess = _CopyStringW( pWSClient->ClientName,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSClientDirectory :

        fSuccess = _CopyStringW( pWSClient->ClientDirectory,
                                 ppBuffer,
                                 pBytesReturned );
        break;

    case WTSClientProductId :

        fSuccess = _CopyData( &(pWSClient->ClientProductId),
                              sizeof(pWSClient->ClientProductId),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientHardwareId :

        fSuccess = _CopyData( &(pWSClient->ClientHardwareId),
                              sizeof(pWSClient->ClientHardwareId),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientAddress :

        ClientAddress.AddressFamily = pWSClient->ClientAddressFamily;
        switch ( ClientAddress.AddressFamily ) {

        case AF_UNSPEC :
            // force null-termination
            if ( pWSClient->ClientAddress[CLIENTADDRESS_LENGTH+1] != L'\0' )
                pWSClient->ClientAddress[CLIENTADDRESS_LENGTH+1] = L'\0';
            // We do this here instead of in the ANSI version of this
            // function because we've only got 20 bytes to work with
            // (unicode addresses over 10 chars would be truncated).
            // The return is the same for both A and W versions.
            WideCharToMultiByte( CP_ACP, 0L, pWSClient->ClientAddress,
                                 -1, ClientAddress.Address, 20, NULL, NULL );
            break;

        case AF_INET :
            // convert string to binary format
            swscanf( pWSClient->ClientAddress, L"%u.%u.%u.%u",
                     &ClientAddress.Address[2],
                     &ClientAddress.Address[3],
                     &ClientAddress.Address[4],
                     &ClientAddress.Address[5] );
            break;

        case AF_IPX :
            {
                PWCHAR pBuf = pWSClient->ClientAddress;

                _wcsupr( pWSClient->ClientAddress );
                // convert string to binary format
                for ( i=0 ; i<10 ; i++ ) {
                    if ( *pBuf != L':' ) {
                        swscanf( pBuf, L"%2X", &ClientAddress.Address[i] );
                        pBuf += 2;
                    } else {
                        // skip the colon
                        pBuf++;
                        i--;
                        continue;
                    }
                }
            }
            break;
        }

        fSuccess = _CopyData( &ClientAddress,
                              sizeof(ClientAddress),
                              ppBuffer,
                              pBytesReturned );

        break;

    case WTSClientDisplay :

        ClientDisplay.HorizontalResolution = pWSClient->HRes;
        ClientDisplay.VerticalResolution = pWSClient->VRes;
        ClientDisplay.ColorDepth = pWSClient->ColorDepth;

        fSuccess = _CopyData( &ClientDisplay,
                              sizeof(ClientDisplay),
                              ppBuffer,
                              pBytesReturned );
        break;

    case WTSClientProtocolType :

        fSuccess = _CopyData( &(pWSClient->ProtocolType),
                              sizeof(pWSClient->ProtocolType),
                              ppBuffer,
                              pBytesReturned );
        break;

    }

    badquery:

    if ( pWSConfig )
        LocalFree( pWSConfig );

    if ( pWSInfo )
        LocalFree( pWSInfo );

    if ( pWSClient )
        LocalFree( pWSClient );

    return( fSuccess );

    /*=============================================================================
    ==   Error return
    =============================================================================*/


    no_memory:

    SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    return( FALSE );
}


/****************************************************************************
 *
 *  WTSQuerySessionInformationA (ANSI)
 *
 *    Query information for the specified session and server
 *
 * ENTRY:
 *
 *    see WTSQuerySessionInformationW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSQuerySessionInformationA(
                           IN HANDLE hServer,
                           IN DWORD SessionId,
                           IN WTS_INFO_CLASS WTSInfoClass,
                           OUT LPSTR * ppBuffer,
                           OUT DWORD * pBytesReturned
                           )
{
    LPWSTR pBufferW;
    DWORD BytesReturned;
    DWORD DataLength;


    if (!ppBuffer || !pBytesReturned) {
        SetLastError(ERROR_INVALID_USER_BUFFER);
        return FALSE;
    }

    /*
     *  Query the data
     */
    if ( !WTSQuerySessionInformationW( hServer,
                                       SessionId,
                                       WTSInfoClass,
                                       &pBufferW,
                                       &BytesReturned ) ) {
        return( FALSE );
    }

    switch ( WTSInfoClass ) {

    case WTSSessionId :
    case WTSConnectState :
    case WTSClientBuildNumber :
    case WTSClientProductId :
    case WTSClientHardwareId :
    case WTSClientAddress :
    case WTSClientDisplay :
    case WTSClientProtocolType:

        /*
         *  Non-String Data - just return
         */
        *ppBuffer = (LPSTR) pBufferW;
        if ( pBytesReturned ) {
            *pBytesReturned = BytesReturned;
        }
        break;

    case WTSInitialProgram :
    case WTSWorkingDirectory :
    case WTSOEMId :
    case WTSWinStationName :
    case WTSUserName :
    case WTSDomainName :
    case WTSClientName :
    case WTSClientDirectory :
    case WTSApplicationName :

        /*
         *  String Data - Convert to ANSI
         *  lets allocate the maximum possible MultiByte length.
         */
        DataLength = (wcslen(pBufferW) + 1) * sizeof(WCHAR);
        *ppBuffer = LocalAlloc( LPTR, DataLength );
        if ( *ppBuffer == NULL ) {
            LocalFree( pBufferW );
            return( FALSE );
        }

        RtlUnicodeToMultiByteN( *ppBuffer, DataLength, pBytesReturned, pBufferW, DataLength);
        
        LocalFree( pBufferW );
        break;



    }

    return( TRUE );
}


/****************************************************************************
 *
 *  WTSSetSessionInformationW (UNICODE)
 *
 *  NOTE: THIS IS CURRENTLY JUST A STUB SO WE DON'T BREAK EXISTING PROGRAMS.
 *
 *    Modify information for the specified session and server
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    WTSInfoClass (input)
 *       Specifies the type of information to modify for the specified
 *       session
 *    pData (input)
 *       Pointer to the data used to modify the specified session information.
 *    DataLength (output)
 *       The length of the data provided.
 *
 * EXIT:
 *
 *    TRUE  -- The modify operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetSessionInformationW(
                         IN HANDLE hServer,
                         IN DWORD SessionId,
                         IN WTS_INFO_CLASS WTSInfoClass,
                         IN PVOID pData,
                         IN DWORD DataLength
                         )
{
    return( TRUE );
}


/****************************************************************************
 *
 *  WTSSetSessionInformationA (ANSI)
 *
 *  NOTE: THIS IS CURRENTLY JUST A STUB SO WE DON'T BREAK EXISTING PROGRAMS.
 *
 *    Modify information for the specified session and server
 *
 * ENTRY:
 *
 *    see WTSSetSessionInformationW
 *
 * EXIT:
 *
 *    TRUE  -- The query operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSetSessionInformationA(
                         IN HANDLE hServer,
                         IN DWORD SessionId,
                         IN WTS_INFO_CLASS WTSInfoClass,
                         IN PVOID pData,
                         IN DWORD DataLength
                         )
{
    return( TRUE );
}


/****************************************************************************
 *
 *  WTSSendMessageW (UNICODE)
 *
 *    Send a message box to the specified session
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    pTitle (input)
 *       Pointer to title for message box to display.
 *    TitleLength (input)
 *       Length of title to display in bytes.
 *    pMessage (input)
 *       Pointer to message to display.
 *    MessageLength (input)
 *       Length of message in bytes to display at the specified window station.
 *    Style (input)
 *       Standard Windows MessageBox() style parameter.
 *    Timeout (input)
 *       Response timeout in seconds.  If message is not responded to in
 *       Timeout seconds then a response code of IDTIMEOUT (cwin.h) is
 *       returned to signify the message timed out.
 *    pResponse (output)
 *       Address to return selected response. Valid only when bWait is set.
 *    bWait (input)
 *       Wait for the response
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSendMessageW(
               IN HANDLE hServer,
               IN DWORD SessionId,
               IN LPWSTR pTitle,
               IN DWORD TitleLength,
               IN LPWSTR pMessage,
               IN DWORD MessageLength,
               IN DWORD Style,
               IN DWORD Timeout,
               OUT DWORD * pResponse,
               IN BOOL bWait
               )
{
    if (!pTitle ||
        !pMessage ||
        !pResponse
       ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return( WinStationSendMessageW( hServer,
                                    SessionId,
                                    pTitle,
                                    TitleLength,
                                    pMessage,
                                    MessageLength,
                                    Style,
                                    Timeout,
                                    pResponse,
                                    (BOOLEAN) !bWait ) );
}


/****************************************************************************
 *
 *  WTSSendMessageA (ANSI)
 *
 *    Send a message box to the specified session
 *
 * ENTRY:
 *
 *    see WTSSendMessageW
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSSendMessageA(
               IN HANDLE hServer,
               IN DWORD SessionId,
               IN LPSTR pTitle,
               IN DWORD TitleLength,
               IN LPSTR pMessage,
               IN DWORD MessageLength,
               IN DWORD Style,
               IN DWORD Timeout,
               OUT DWORD * pResponse,
               IN BOOL bWait
               )
{

    if (!pTitle ||
        !pMessage ||
        !pResponse
       ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    return( WinStationSendMessageA( hServer,
                                    SessionId,
                                    pTitle,
                                    TitleLength,
                                    pMessage,
                                    MessageLength,
                                    Style,
                                    Timeout,
                                    pResponse,
                                    (BOOLEAN) !bWait ) );
}


/****************************************************************************
 *
 *  WTSDisconnectSession
 *
 *    Disconnect the specified session
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    bWait (input)
 *       Wait for the operation to complete
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSDisconnectSession(
                    IN HANDLE hServer,
                    IN DWORD SessionId,
                    IN BOOL bWait
                    )
{
    return( WinStationDisconnect( hServer, SessionId, (BOOLEAN) bWait ) );
}


/****************************************************************************
 *
 *  WTSLogoffSession
 *
 *    Logoff the specified session
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    bWait (input)
 *       Wait for the operation to complete
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSLogoffSession(
                IN HANDLE hServer,
                IN DWORD SessionId,
                IN BOOL bWait
                )
{
    return( WinStationReset( hServer, SessionId, (BOOLEAN) bWait ) );
}


/****************************************************************************
 *
 *  _CopyData
 *
 *    Allocate buffer and copy data into it
 *
 * ENTRY:
 *    pData (input)
 *       pointer to data to copy
 *    DataLength (input)
 *       length of data to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyData( PVOID pData,
           ULONG DataLength,
           LPWSTR * ppBuffer,
           DWORD * pBytesReturned )
{
    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL ) {
        return( FALSE );
    }

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    memcpy( *ppBuffer, pData, DataLength );

    return( TRUE );
}


/****************************************************************************
 *
 *  _CopyStringW
 *
 *    Allocate a buffer for a unicode string and copy unicode string into it
 *
 * ENTRY:
 *    pString (input)
 *       pointer to unicode string to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyStringW( LPWSTR pString,
              LPWSTR * ppBuffer,
              DWORD * pBytesReturned )
{
    ULONG DataLength;
    BOOL  rc = TRUE;

    /*
     *  If original string is NULL, just make copy NULL.           KLB 11-03-97
     */
    if ( pString == NULL ) {
        *ppBuffer = NULL;
        if ( pBytesReturned != NULL ) {
            *pBytesReturned = 0;
        }
        goto done;
    }

    DataLength = (wcslen( pString ) + 1) * sizeof(WCHAR);

    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL ) {
        rc = FALSE;
        goto done;
    }

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    memcpy( *ppBuffer, pString, DataLength );

    done:
    return( rc );
}


/****************************************************************************
 *
 *  _CopyStringA
 *
 *    Allocate a buffer for a unicode string and copy ansi string into it
 *
 * ENTRY:
 *    pString (input)
 *       pointer to ansi string to copy
 *    ppBuffer (output)
 *       Points to the address of a variable to receive the copied data
 *    pBytesReturned (output)
 *       An optional parameter that if specified, receives the number of
 *       bytes returned.
 *
 * EXIT:
 *
 *    TRUE  -- The copy operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
_CopyStringA( LPSTR pString,
              LPWSTR * ppBuffer,
              DWORD * pBytesReturned )
{
    ULONG DataLength;
    BOOL  rc = TRUE;

    /*
     *  If original string is NULL, just make copy NULL.           KLB 11-03-97
     */
    if ( pString == NULL ) {
        *ppBuffer = NULL;
        if ( pBytesReturned != NULL ) {
            *pBytesReturned = 0;
        }
        goto done;
    }

    DataLength = (strlen( pString ) + 1) * sizeof(WCHAR);

    *ppBuffer = LocalAlloc( LPTR, DataLength );
    if ( *ppBuffer == NULL ) {
        rc = FALSE;
        goto done;
    }

    if ( pBytesReturned != NULL ) {
        *pBytesReturned = DataLength;
    }

    AnsiToUnicode( *ppBuffer, DataLength, pString );

    done:
    return( rc );
}


/****************************************************************************
 *
 *  ValidateCopyUnicodeToUnicode
 *
 *    Determines if the source unicode character string is valid and if so,
 *    copies it to the destination.
 *
 * ENTRY:
 *    pSourceW (input)
 *       pointer to a null terminated string.
 *    MaxLength (input)
 *       The maximum allowed length (in characters).
 *    pDestW (input)
 *       The destination where pSourceW is copied.
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE.
 *
 ****************************************************************************/
BOOL
ValidateCopyUnicodeToUnicode(LPWSTR pSourceW, DWORD MaxLength, LPWSTR pDestW)
{

    DWORD Length;

    if ( wcslen(pSourceW) > MaxLength ) {
        return(FALSE);
    }
    wcscpy(pDestW,pSourceW);
    return(TRUE);
}


/****************************************************************************
 *
 *  ValidateCopyAnsiToUnicode
 *
 *    Determines if the source ANSI character string is valid and if so,
 *    converts and copies it to the unicode destination.
 *
 * ENTRY:
 *    pSourceA (input)
 *       pointer to a null terminated ANSI string.
 *    MaxLength (input)
 *       The maximum allowed length (in characters).
 *    pDestW (input)
 *       The destination where pSourceA is copied.
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE.
 *
 ****************************************************************************/
BOOL
ValidateCopyAnsiToUnicode(LPSTR pSourceA, DWORD MaxLength, LPWSTR pDestW)
{
    UINT  Length;
    DWORD DataLength;

    if ( (Length = strlen(pSourceA)) > MaxLength ) {
        return(FALSE);
    }

    DataLength = (Length+1) * sizeof(WCHAR);
    AnsiToUnicode(pDestW,DataLength,pSourceA);
    return(TRUE);
}


/****************************************************************************
 *
 *  WTSRegisterSessionNotification
 *
 *    Register a window handle for console notification
 *    Console notification, are messages sent when console session switch occurs
 *
 * ENTRY:
 *    hWnd (input)
 *       Window handle to be registered.
 *    dwFlags (input)
 *       value must be NOTIFY_FOR_THIS_SESSION
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE. Sets LastError
 *
 ****************************************************************************/

BOOL WINAPI
WTSRegisterSessionNotification (HWND hWnd, DWORD dwFlags)
{
    DWORD dwProcId;
    HMODULE User32DllHandle = NULL ; 


    //
    // make sure that window handle is valid
    //
    if (!IsWindow(hWnd))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto error ; 
    }

    GetWindowThreadProcessId(hWnd, &dwProcId);

    if (dwProcId != GetCurrentProcessId())
    {
        SetLastError(ERROR_WINDOW_OF_OTHER_THREAD);
        goto error ; 
    }

    if (dwFlags != NOTIFY_FOR_THIS_SESSION && dwFlags != NOTIFY_FOR_ALL_SESSIONS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto error ; 
    }

    return WinStationRegisterConsoleNotification (WTS_CURRENT_SERVER_HANDLE, hWnd, dwFlags);

    // -------------------------------- Handle Errors and return FALSE -----------------------

    error :

    return FALSE ;
}

/****************************************************************************
 *
 *  WTSUnRegisterSessionNotification
 *
 *    UnRegister a window handle for console notification
 *    Console notification, are messages sent when console session switch occurs
 *
 * ENTRY:
 *    dwFlags (input)
 *       NOTIFY_FOR_THIS_SESSION
 * EXIT:
 *    Returns TRUE if successful, otherwise FALSE. Sets LastError
 *
 ****************************************************************************/

BOOL WINAPI
WTSUnRegisterSessionNotification (HWND hWnd)
{
    DWORD dwProcId;
    HMODULE User32DllHandle = NULL ; 

    //
    // make sure that window handle is valid
    //
    if (!IsWindow(hWnd))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto error ; 
    }

    GetWindowThreadProcessId(hWnd, &dwProcId);

    if (dwProcId != GetCurrentProcessId())
    {
        SetLastError(ERROR_WINDOW_OF_OTHER_THREAD);
        goto error ; 
    }
    
    return WinStationUnRegisterConsoleNotification (WTS_CURRENT_SERVER_HANDLE, hWnd);

    // -------------------------------- Handle Errors and return FALSE -----------------------

    error :

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wtsapi\virtual.c ===
/*******************************************************************************
* virtual.c
*
* Published Terminal Server Virtual Channel APIs
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
    #include <icadd.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
    #include <citrix\icadd.h>
#endif
#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>

#include <wtsapi32.h>



/*
 *  Virtual Channel Name
 */
#define VIRTUALNAME_LENGTH  7

typedef CHAR VIRTUALNAME[ VIRTUALNAME_LENGTH + 1 ];  // includes null
typedef CHAR * PVIRTUALNAME;



// Handle structure used internally
typedef struct _VCHANDLE {
    ULONG Signature;
    HANDLE hServer;
    DWORD SessionId;
    HANDLE hChannel;
    VIRTUALNAME VirtualName;
} VCHANDLE, *PVCHANDLE;

#define VCHANDLE_SIGNATURE ('V' | ('C' << 8) | ('H' << 16) | ('D' << 24))
#define ValidVCHandle(hVC) ((hVC) && ((hVC)->Signature == VCHANDLE_SIGNATURE))


/****************************************************************************
 *
 *  WTSVirtualChannelOpen
 *
 *    Open the specified virtual channel
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    SessionId (input)
 *       Server Session Id (or WTS_CURRENT_SESSION)
 *    pVirtualName (input)
 *       Pointer to virtual channel name
 *
 * EXIT:
 *
 *    Handle to specified virtual channel (NULL on error)
 *
 ****************************************************************************/

HANDLE
WINAPI
WTSVirtualChannelOpen(
                     IN HANDLE hServer,
                     IN DWORD SessionId,
                     IN LPSTR pVirtualName   /* ascii name */
                     )
{
    PVCHANDLE pChannelHandle;
    HANDLE hChannel;

    if (hChannel = WinStationVirtualOpen( hServer, SessionId, pVirtualName)) {

        // Allocate the Handle
        if (!(pChannelHandle = (PVCHANDLE) LocalAlloc(LPTR,
                                                      sizeof(VCHANDLE)))) {
            CloseHandle(hChannel);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(NULL);
        }

        pChannelHandle->Signature = VCHANDLE_SIGNATURE;
        pChannelHandle->hServer = hServer;
        pChannelHandle->SessionId = SessionId;
        pChannelHandle->hChannel = hChannel;
        memcpy(pChannelHandle->VirtualName, pVirtualName, sizeof(VIRTUALNAME));
        return((HANDLE)pChannelHandle);
    }
    return(NULL);

}

/****************************************************************************
 *
 *  WTSVirtualChannelClose
 *
 *    Close the specified virtual channel
 *
 * ENTRY:
 *    hChannel (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelClose(HANDLE hChannel)
{
    PVCHANDLE VCHandle = (PVCHANDLE) hChannel;
    BOOL RetVal = FALSE;

    if(!hChannel || IsBadReadPtr(hChannel,sizeof(HANDLE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }


    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto BadParam;
    }

    if (CloseHandle(VCHandle->hChannel))
        RetVal = TRUE;

    VCHandle->Signature = 0;
    LocalFree(VCHandle);

    BadParam:
    return(RetVal);
}

/****************************************************************************
 *
 *  WTSVirtualChannelWrite
 *
 *    Write data to a virtual channel
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    Buffer (input)
 *       Buffer containing data to write.
 *    Length (input)
 *       Length of data to write (bytes)
 *    pBytesWritten (output)
 *       Returns the amount of data written.
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelWrite(HANDLE hChannel, PCHAR pBuffer, ULONG Length, PULONG pBytesWritten)
{
    PVCHANDLE VCHandle = (PVCHANDLE)hChannel;
    OVERLAPPED  Overlapped;

    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    Overlapped.hEvent = NULL;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;

    if (!WriteFile(VCHandle->hChannel,
                   pBuffer,
                   Length,
                   pBytesWritten,
                   &Overlapped)) {

        if (GetLastError() == ERROR_IO_PENDING)
            // check on the results of the asynchronous write
            return (GetOverlappedResult(VCHandle->hChannel,
                                        &Overlapped,
                                        pBytesWritten,
                                        TRUE));
        else
            return(FALSE);
    }

    return(TRUE);
}

/****************************************************************************
 *
 *  WTSVirtualChannelRead
 *
 *    Read data from a virtual channel
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    Timeout (input)
 *       The amount of time to wait for the read to complete.
 *    Buffer (input)
 *       Buffer which receive the data read.
 *    BufferLength (input)
 *       Length of the read buffer.
 *    pBytesRead (output)
 *       Returns the amount of data read.
 *
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelRead(HANDLE hChannel, ULONG Timeout, PCHAR pBuffer, ULONG BufferLength, PULONG pBytesRead)
{
    PVCHANDLE VCHandle = (PVCHANDLE)hChannel;
    OVERLAPPED  Overlapped;

    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    Overlapped.hEvent = NULL;
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;

    if (!ReadFile(VCHandle->hChannel,
                  pBuffer,
                  BufferLength,
                  pBytesRead,
                  &Overlapped)) {
        if (GetLastError() == ERROR_IO_PENDING) {
            if (!Timeout) {
                // Read with no timeout - cancel IO and return success.
                // This matches the behavior in WTS 1.7.  This is required for
                // Wyse firmware download software.
                CancelIo(VCHandle->hChannel);
                *pBytesRead = 0;
                return(TRUE);
            }
            if (WaitForSingleObject(VCHandle->hChannel, Timeout) == WAIT_TIMEOUT) {
                CancelIo(VCHandle->hChannel);
                SetLastError(ERROR_IO_INCOMPLETE);
                return(FALSE);
            }
            // check on the results of the asynchronous read
            return(GetOverlappedResult(VCHandle->hChannel,
                                       &Overlapped,
                                       pBytesRead,
                                       FALSE));
        } else {
            return(FALSE);
        }
    }

    return(TRUE);
}

/****************************************************************************
 *
 *  VirtualChannelIoctl
 *
 *    Issues an Ioctl to a virtual channel. This routine was replicated from
 *    icaapi so that OEMs don't need to link with icaapi.dll.
 *
 * ENTRY:
 *    hChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    IoctlCode (input)
 *       The type of ioctl to do.
 *    pInBuf (input)
 *       Input data required for the Ioctl.
 *    InBufLength (input)
 *       Length of input data.
 *
 *    pOutBuf (output)
 *       Buffer to receive output data.
 *    OutBufLength (input)
 *       Length of the output buffer.
 *    pBytesReturned (output)
 *       Number of bytes returned in OutputBuffer.
 * EXIT:
 *
 *    Returns TRUE if successful, otherwise FALSE.
 *
 ****************************************************************************/
BOOL
VirtualChannelIoctl (HANDLE hChannel,
                     ULONG IoctlCode,
                     PCHAR pInBuf,
                     ULONG InBufLength,
                     PCHAR pOutBuf,
                     ULONG OutBufLength,
                     PULONG pBytesReturned)
{
    IO_STATUS_BLOCK Iosb;
    NTSTATUS Status;
    PVCHANDLE VCHandle = (PVCHANDLE)hChannel;

    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return (FALSE);
    }


    /*
     *  Issue ioctl
     */
    Status = NtDeviceIoControlFile( VCHandle->hChannel,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &Iosb,
                                    IoctlCode,
                                    pInBuf,
                                    InBufLength,
                                    pOutBuf,
                                    OutBufLength );

    /*
     *  Wait for ioctl to complete
     */
    if ( Status == STATUS_PENDING ) {
        Status = NtWaitForSingleObject( VCHandle->hChannel, FALSE, NULL );
        if ( NT_SUCCESS(Status))
            Status = Iosb.Status;
    }

    /*
     *  Convert warning into error
     */
    if ( Status == STATUS_BUFFER_OVERFLOW )
        Status = STATUS_BUFFER_TOO_SMALL;

    /*
     *  Initialize bytes returned
     */
    if ( pBytesReturned )
        *pBytesReturned = (ULONG)Iosb.Information;

    /* Return success/failure indication */
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    } else {
        SetLastError(RtlNtStatusToDosError(Status));
        return(FALSE);
    }
}

/****************************************************************************
 *
 *  WTSVirtualChannelPurgeInput
 *
 *    Purge all queued input data on a virtual channel.
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelPurgeInput(IN HANDLE hChannelHandle)
{
    PVCHANDLE VCHandle = (PVCHANDLE) hChannelHandle;

    return(VirtualChannelIoctl(VCHandle,
                               IOCTL_ICA_VIRTUAL_CANCEL_INPUT,
                               (PCHAR) NULL,
                               0,
                               (PCHAR) NULL,
                               0,
                               (PULONG) NULL));

}

/****************************************************************************
 *
 *  WTSVirtualChannelPurgeOutput
 *
 *    Purge all queued output data on a virtual channel.
 *
 * ENTRY:
 *    ChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelPurgeOutput(IN HANDLE hChannelHandle)
{
    PVCHANDLE VCHandle = (PVCHANDLE)hChannelHandle;

    return(VirtualChannelIoctl(VCHandle,
                               IOCTL_ICA_VIRTUAL_CANCEL_OUTPUT,
                               (PCHAR) NULL,
                               0,
                               (PCHAR) NULL,
                               0,
                               (PULONG) NULL));

}

/****************************************************************************
 *
 *  WTSVirtualChannelQuery
 *
 *    Query data related to a virtual channel.
 *
 * ENTRY:
 *    hChannelHandle (input)
 *       Virtual Channel handle previously returned by WTSVirtualChannelOpen.
 *    VirtualClass (input)
 *       The type of information requested.
 *    ppBuffer (output)
 *       Pointer to a buffer pointer, which is allocated upon successful
 *       return.
 *    pBytesReturned (output)
 *       Pointer to a DWORD which is updated with the length of the data
 *       returned in the allocated buffer upon successful return.
 * EXIT:
 *
 *    Returns TRUE if successful otherwise FALSE.
 *    If successful, the caller is responsible for deallocating the
 *    buffer returned.
 *
 ****************************************************************************/
BOOL
WINAPI
WTSVirtualChannelQuery(IN HANDLE hChannelHandle,IN WTS_VIRTUAL_CLASS VirtualClass,
                       OUT PVOID *ppBuffer,OUT DWORD *pBytesReturned)
{
    PVCHANDLE VCHandle = (PVCHANDLE) hChannelHandle;
    PVOID DataBuffer;
    DWORD DataBufferLen;

    if (!hChannelHandle || IsBadReadPtr(hChannelHandle,sizeof(HANDLE)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (!ValidVCHandle(VCHandle)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (!ppBuffer || IsBadWritePtr(ppBuffer, sizeof(PVOID)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
    if (!pBytesReturned || IsBadWritePtr(pBytesReturned, sizeof(DWORD)))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    switch (VirtualClass) {
    case WTSVirtualFileHandle:
        DataBuffer = LocalAlloc( LPTR, sizeof(HANDLE) );
        if ( DataBuffer == NULL ) {
            return(FALSE);
        }
        memcpy(DataBuffer, &VCHandle->hChannel, sizeof(HANDLE) );
        *ppBuffer = DataBuffer;
        *pBytesReturned = sizeof(HANDLE);
        return(TRUE);
        break;
    case WTSVirtualClientData:
        DataBufferLen = sizeof(VIRTUALNAME) + 1024;
        for (;;) {

            DataBuffer = LocalAlloc( LPTR, DataBufferLen );
            if ( DataBuffer == NULL ) {
                return(FALSE);
            }

            memcpy( DataBuffer,VCHandle->VirtualName,sizeof(VIRTUALNAME));

            if (WinStationQueryInformationW( VCHandle->hServer,
                                             VCHandle->SessionId,
                                             WinStationVirtualData,
                                             DataBuffer,
                                             DataBufferLen,
                                             &DataBufferLen)) {
                *ppBuffer = DataBuffer;
                *pBytesReturned = DataBufferLen;
                return(TRUE);
            }

            if ((GetLastError() != ERROR_INSUFFICIENT_BUFFER) ||
                (DataBufferLen < sizeof(VIRTUALNAME))) {
                LocalFree(DataBuffer);
                return(FALSE);
            }
            LocalFree(DataBuffer);
        }
        break;
    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\wtsapi\wtsapi32.c ===
/*******************************************************************************
* wtsapi32.c
*
* Published Terminal Server APIs
*
* Copyright 1998, Citrix Systems Inc.
* Copyright (C) 1997-1999 Microsoft Corp.
/******************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#if(WINVER >= 0x0500)
    #include <ntstatus.h>
    #include <winsta.h>
#else
    #include <citrix\cxstatus.h>
    #include <citrix\winsta.h>
#endif
#include <utildll.h>

#include <stdio.h>
#include <stdarg.h>


#include <wtsapi32.h>

// Private User function that returns user token for session 0 only
// Used in the case when TS is not running
extern 
HANDLE
GetCurrentUserTokenW (
        WCHAR       Winsta[],
        DWORD       DesiredAccess
        );



/*=============================================================================
==   External procedures defined
=============================================================================*/

BOOL WINAPI WTSShutdownSystem( HANDLE, DWORD );
BOOL WINAPI WTSWaitSystemEvent( HANDLE, DWORD, DWORD * );
VOID WINAPI WTSFreeMemory( PVOID pMemory );
BOOL WINAPI WTSQueryUserToken(ULONG SessionId, PHANDLE phToken);




/*=============================================================================
==   Internal procedures defined
=============================================================================*/

BOOL WINAPI DllEntryPoint( HINSTANCE, DWORD, LPVOID );
BOOL IsTerminalServiceRunning(VOID);
BOOL IsProcessPrivileged(CONST PCWSTR szPrivilege);



/*=============================================================================
==   Local function prototypes
=============================================================================*/

BOOLEAN CheckShutdownPrivilege();


/****************************************************************************
 *
 *  WTSShutdowSystem
 *
 *    Shutdown and/or reboot system
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    ShutdownFlags (input)
 *       Flags which specify shutdown options.
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSShutdownSystem(
                 IN HANDLE hServer,
                 IN DWORD ShutdownFlags
                 )
{
    ULONG uiOptions = 0;
    
    // Make sure the user has the proper privilege to shutdown the system when
    // hServer is a local server handle. For remote server, the user privilege
    // is checked when WTSOpenServer is called.

    if (hServer == SERVERNAME_CURRENT && !CheckShutdownPrivilege()) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return(FALSE);
    }

    // Construct the shutdown flag 

    if (ShutdownFlags == WTS_WSD_LOGOFF) {
        // log off all users and deletes sessions
        uiOptions = WSD_LOGOFF;
    } else if (ShutdownFlags == WTS_WSD_SHUTDOWN) {
        uiOptions = WSD_LOGOFF | WSD_SHUTDOWN;
    } else if (ShutdownFlags == WTS_WSD_REBOOT) {
        uiOptions = WSD_LOGOFF | WSD_SHUTDOWN | WSD_REBOOT;
    } else if (ShutdownFlags == WTS_WSD_POWEROFF) {
        uiOptions = WSD_LOGOFF | WSD_SHUTDOWN | WSD_POWEROFF;
    } else if (ShutdownFlags == WTS_WSD_FASTREBOOT) {
        uiOptions = WSD_FASTREBOOT | WSD_REBOOT;
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return( WinStationShutdownSystem( hServer, uiOptions ));

}


/****************************************************************************
 *
 *  WTSWaitSystemEvent
 *
 *    Waits for an event (WinStation create, delete, connect, etc) before
 *    returning to the caller.
 *
 * ENTRY:
 *    hServer (input)
 *       Terminal Server handle (or WTS_CURRENT_SERVER)
 *    EventFlags (input)
 *       Bit mask that specifies which event(s) to wait for (WTS_EVENT_?)
 *    pEventFlags (output)
 *       Bit mask of event(s) that occurred.
 *
 * EXIT:
 *
 *    TRUE  -- The operation succeeded.
 *
 *    FALSE -- The operation failed.  Extended error status is available
 *             using GetLastError.
 *
 ****************************************************************************/

BOOL
WINAPI
WTSWaitSystemEvent(
                  IN HANDLE hServer,
                  IN DWORD EventMask,
                  OUT DWORD * pEventFlags
                  )
{
    BOOL fSuccess;
    ULONG WSEventMask;
    ULONG WSEventFlags = 0;

    if (IsBadWritePtr(pEventFlags, sizeof(DWORD))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;

    }


    /*
     *  Map event mask
     */
    WSEventMask = 0;
    if ( EventMask & WTS_EVENT_CREATE )
        WSEventMask |= WEVENT_CREATE;
    if ( EventMask & WTS_EVENT_DELETE )
        WSEventMask |= WEVENT_DELETE;
    if ( EventMask & WTS_EVENT_RENAME )
        WSEventMask |= WEVENT_RENAME;
    if ( EventMask & WTS_EVENT_CONNECT )
        WSEventMask |= WEVENT_CONNECT;
    if ( EventMask & WTS_EVENT_DISCONNECT )
        WSEventMask |= WEVENT_DISCONNECT;
    if ( EventMask & WTS_EVENT_LOGON )
        WSEventMask |= WEVENT_LOGON;
    if ( EventMask & WTS_EVENT_LOGOFF )
        WSEventMask |= WEVENT_LOGOFF;
    if ( EventMask & WTS_EVENT_STATECHANGE )
        WSEventMask |= WEVENT_STATECHANGE;
    if ( EventMask & WTS_EVENT_LICENSE )
        WSEventMask |= WEVENT_LICENSE;

    if ( EventMask & WTS_EVENT_FLUSH )
        WSEventMask |= WEVENT_FLUSH;

    /* 
     *  Wait for system event
     */
    fSuccess = WinStationWaitSystemEvent( hServer, WSEventMask, &WSEventFlags );

    /*
     * Map event mask
     */
    *pEventFlags = 0;
    if ( WSEventFlags & WEVENT_CREATE )
        *pEventFlags |= WTS_EVENT_CREATE;
    if ( WSEventFlags & WEVENT_DELETE )
        *pEventFlags |= WTS_EVENT_DELETE;
    if ( WSEventFlags & WEVENT_RENAME )
        *pEventFlags |= WTS_EVENT_RENAME;
    if ( WSEventFlags & WEVENT_CONNECT )
        *pEventFlags |= WTS_EVENT_CONNECT;
    if ( WSEventFlags & WEVENT_DISCONNECT )
        *pEventFlags |= WTS_EVENT_DISCONNECT;
    if ( WSEventFlags & WEVENT_LOGON )
        *pEventFlags |= WTS_EVENT_LOGON;
    if ( WSEventFlags & WEVENT_LOGOFF )
        *pEventFlags |= WTS_EVENT_LOGOFF;
    if ( WSEventFlags & WEVENT_STATECHANGE )
        *pEventFlags |= WTS_EVENT_STATECHANGE;
    if ( WSEventFlags & WEVENT_LICENSE )
        *pEventFlags |= WTS_EVENT_LICENSE;

    return( fSuccess );
}


/****************************************************************************
 *
 *  WTSFreeMemory
 *
 *    Free memory allocated by Terminal Server APIs
 *
 * ENTRY:
 *    pMemory (input)
 *       Pointer to memory to free
 *
 * EXIT:
 *    nothing
 *
 ****************************************************************************/

VOID
WINAPI
WTSFreeMemory( PVOID pMemory )
{
    LocalFree( pMemory );
}


/****************************************************************************
 *
 * DllEntryPoint
 *
 *   Function is called when the DLL is loaded and unloaded.
 *
 * ENTRY:
 *   hinstDLL (input)
 *     Handle of DLL module
 *   fdwReason (input)
 *     Why function was called
 *   lpvReserved (input)
 *     Reserved; must be NULL
 *
 * EXIT:
 *   TRUE  - Success
 *   FALSE - Error occurred
 *
 ****************************************************************************/

BOOL WINAPI
DllEntryPoint( HINSTANCE hinstDLL,
               DWORD     fdwReason,
               LPVOID    lpvReserved )
{
    switch ( fdwReason ) {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return( TRUE );
}


/*****************************************************************************
 *
 *  CheckShutdownPrivilege
 *
 *   Check whether the current process has shutdown permission.
 *
 * ENTRY:
 *
 * EXIT:
 *
 *
 ****************************************************************************/

BOOLEAN
CheckShutdownPrivilege()
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;

    //
    // Try the thread token first
    //

    Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                TRUE,
                                TRUE,
                                &WasEnabled);

    if (Status == STATUS_NO_TOKEN) {

        //
        // No thread token, use the process token
        //

        Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE,
                                    TRUE,
                                    FALSE,
                                    &WasEnabled);
    }

    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }
    return(TRUE);
}

/*++

Routine Description:
    
    Allows to read the token of the user interactively logged in the session identified by SessionId.
    The caller must be running under local system account and hold SE_TCB_NAME privilege. This API
    is intended for highly trusted services. Service Providers using it must be very cautious not to 
    leak user tokens. 
    
    NOTE : The API is RPC based and hence cannot be called with the loader lock held (specifically
    from DLL attach/detach code)
    
Arguments:

    SessionId: IN. Identifies the session the user is logged in. 
    phToken:  OUT. Points to the user token handle, if the function succeeded.
    
Return Values:

    TRUE in case of success. phToken points to the user token.
    FALSE in case of failure. Use GetLastError() to get extended error code.

    The token returned is a duplicate of a primary token.
    
--*/


BOOL
WINAPI
WTSQueryUserToken(ULONG SessionId, PHANDLE phToken)
{

    BOOL IsTsUp = FALSE;
    BOOL    Result, bHasPrivilege;
    ULONG ReturnLength;
    WINSTATIONUSERTOKEN Info;
    NTSTATUS Status;
    HANDLE hUserToken = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

    // Do parameter Validation
    if (NULL == phToken) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // We will first check if the process which is calling us, has SE_TCB_NAME privilege
    bHasPrivilege = IsProcessPrivileged(SE_TCB_NAME);
    if (!bHasPrivilege) {
        SetLastError(ERROR_PRIVILEGE_NOT_HELD);
        return(FALSE);
    }

	// If it is session 0, don't call winsta. Use GetCurrentUserToken instead. 
	if (SessionId == 0)
	{
        hUserToken = GetCurrentUserTokenW(L"WinSta0",
                                            TOKEN_QUERY |
                                            TOKEN_DUPLICATE |
                                            TOKEN_ASSIGN_PRIMARY
                                            );

        if (hUserToken == NULL)
            return FALSE;
        else 
            *phToken = hUserToken;
   	}
	else	// Non-zero sessions
	{
		// No one except TS has any idea about non-zero sessions. So, check if the TS is running.
	    IsTsUp = IsTerminalServiceRunning();
		if (IsTsUp) 
		{	// This is so that CSRSS can dup the handle to our process
			Info.ProcessId = LongToHandle(GetCurrentProcessId());
			Info.ThreadId = LongToHandle(GetCurrentThreadId());

			Result = WinStationQueryInformation(
				        SERVERNAME_CURRENT,
					    SessionId,
						WinStationUserToken,
	                    &Info,
		                sizeof(Info),
			            &ReturnLength
				        );

	        if( !Result ) 
				return FALSE;
		    else 
				*phToken = Info.UserToken ; 
		}
		else
		{	// TS is not running. So, set error for non-zero sessions: WINSTATION_NOT_FOUND.
            SetLastError(ERROR_CTX_WINSTATION_NOT_FOUND);
            return FALSE;
        }
	}
			
    return TRUE;
}

// This function determines if the Terminal Service is currently Running
BOOL IsTerminalServiceRunning (VOID)
{

    BOOL bReturn = FALSE;
    SC_HANDLE hServiceController;

    hServiceController = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (hServiceController) {
        SC_HANDLE hTermServ ;
        hTermServ = OpenService(hServiceController, L"TermService", SERVICE_QUERY_STATUS);
        if (hTermServ) {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus)) {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
            } else {
                CloseServiceHandle(hTermServ);
                CloseServiceHandle(hServiceController);
                return FALSE;
            }
            CloseServiceHandle(hTermServ);
        } else {
            CloseServiceHandle(hServiceController);
            return FALSE;
        }
        CloseServiceHandle(hServiceController);
    } else {
        return FALSE;
    }

    return bReturn;
}


/*++
Routine Description:

    This function checks to see if the specified privilege is enabled
    in the primary access token for the current thread.

Arguments:

    szPrivilege - The privilege to be checked for

Return Value:

    TRUE if the specified privilege is enabled, FALSE otherwise.

--*/
BOOL
IsProcessPrivileged(
    CONST PCWSTR szPrivilege
    )

{
    LUID luidValue;     // LUID (locally unique ID) for the privilege
    BOOL bResult = FALSE, bHasPrivilege = FALSE;
    HANDLE  hToken = NULL;
    PRIVILEGE_SET privilegeSet;

    // Get the LUID for the privilege from the privilege name
    bResult = LookupPrivilegeValue(
                NULL, 
                szPrivilege, 
                &luidValue
                );

    if (!bResult) {
        return FALSE;
    }

    // Get the token of the present thread
    bResult = OpenThreadToken(
                GetCurrentThread(),
                MAXIMUM_ALLOWED,
                FALSE,
                &hToken
                );

    if (!bResult) {
        // We want to use the token for the current process
        bResult = OpenProcessToken(
                    GetCurrentProcess(),
                    MAXIMUM_ALLOWED,
                    &hToken
                    );
        if (!bResult) {
            return FALSE;
        }
    }

    // And check for the privilege
	privilegeSet.PrivilegeCount = 1;
	privilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
	privilegeSet.Privilege[0].Luid = luidValue;
	privilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;
	
	bResult = PrivilegeCheck(hToken, &privilegeSet, &bHasPrivilege);

    CloseHandle(hToken);

    return (bResult && bHasPrivilege);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\amd64mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    amd64mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0200
!endif

#
# AMD64 option control
#
UMBASE=$(UMBASE:*=amd64)
UMLIBS=$(UMLIBS:*=amd64)
NTRES=$(NTRES:*=amd64)
UMRES=$(UMRES:*=amd64)
UMOBJS=$(UMOBJS:*=amd64)
LINKLIBS=$(LINKLIBS:*=amd64)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=amd64)
DLLBASE=$(DLLBASE:*=amd64)
DLLDEF=$(DLLDEF:*=amd64)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=amd64)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=amd64)
DYNLINK_LIB=$(DYNLINK_LIB:*=amd64)
TARGETEXEFILES=$(TARGETEXEFILES:*=amd64)
TARGETLIBFILES=$(TARGETLIBFILES:*=amd64)
TARGETOBJFILES=$(TARGETOBJFILES:*=amd64)
UMOBJFILES=$(UMOBJFILES:*=amd64)
UMEXEFILES=$(UMEXEFILES:*=amd64)
HEADERFILE=$(HEADERFILE:*=amd64)
HEADEROBJNAME=$(HEADEROBJNAME:*=amd64)
HEADEROBJ=$(HEADEROBJ:*=amd64)
PRECOMPILED=$(PRECOMPILED:*=amd64) /d1noWchar_t
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=amd64) /d1noWchar_t
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=amd64)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=amd64)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=amd64)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=amd64)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=amd64)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=amd64)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=amd64)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=amd64)
ORDER=$(ORDER:*=amd64)
OBJLIBFILES=$(OBJLIBFILES:*=amd64)
MISCFILES=$(MISCFILES) $(AMD64_MISCFILES)
SOURCES=$(SOURCES) $(AMD64_SOURCES)

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS) $(SDK_LIB_PATH)\atlamd64.lib

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=amd64)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=amd64)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=amd64)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=amd64)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x1000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF AMD64_WARNING_LEVEL
MSC_WARNING_LEVEL=$(AMD64_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Wp64 $(COMPILER_WX_SWITCH)

!ifdef AMD64_PERFFLAGS
PERFFLAGS = $(AMD64_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(AMD64_OPTIMIZATION)
MSC_OPTIMIZATION=$(AMD64_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=/Oxt
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

WIN32_LIBS=$(WIN32_LIBS) $(LIBRARY_PATH)\ntdll.lib

!IFDEF AMD64_CPPFLAGS
MSC_CPPFLAGS=$(AMD64_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

!ifndef AMD64_CPU_OPTIMIZATION
AMD64_CPU_OPTIMIZATION=
!endif

STDFLAGS= /c /Zel /Zp8 /Gy /Gi- $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(AMD64_CPU_OPTIMIZATION) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING)

!if $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!else
AMD64_ADBGFLAGS=$(AMD64_ADBGFLAGS) /Zi
!endif

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
AMD64_ADBGFLAGS=$(AMD64_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup,pdata
!ENDIF
# @@END_DDKSPLIT

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\AMD64^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\amd64\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\amd64^\
! endif
!endif

#
# amd64 option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES=-D_WIN64 -D_AMD64_ -DAMD64 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

#
# This indicates that we are compiling for a siulated (i.e. slow)
# environment.
#
# Remove this when we get a faster environment.
#

STD_DEFINES=$(STD_DEFINES) -D_AMD64_SIMULATOR_PERF_ -D_SKIP_IF_SIMULATOR_

#
# This indicates that we need to enable temp. workarounds for simulator
# bugs
#

STD_DEFINES=$(STD_DEFINES) -D_AMD64_SIMULATOR_

#
# This is here to enable (and help us find later) workarounds for AMD64
# tools such as MIDL.  Workarounds must have a tool fix in the works.
#

STD_DEFINES=$(STD_DEFINES) -D_AMD64_WORKAROUND_
MIDL_FLAGS=$(MIDL_FLAGS) -D_AMD64_WORKAROUND_


CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(AMD64_FLAGS) $(NTAMD64FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
AMD64_ASMFLAGS=$(AMD64_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

AMD64_CDEFINES=$(CDEFINES)
AMD64_CFLAGS=$(CFLAGS)

CC_NAME = cl -nologo

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef AMD64_ASSEMBLER_NAME
AMD64_ASSEMBLER_NAME  = ml64
!endif

!if $(FREEBUILD)
GLOBAL_C_FLAGS = -Iamd64\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)
!else
GLOBAL_C_FLAGS = -Iamd64\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS) -d2home
!endif

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) /d1noWchar_t -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

AMD64_ASSEMBLER=$(AMD64_ASSEMBLER_NAME) -c -Cx -nologo -Iamd64\ -I. $(INCPATH1) $(AMD64_ASMFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) 

ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

#
# Here is a workaround for a masm code generation bug having to do with
# broken interaction between the preprocessor and the code generator.
#
# The workaround is to generate a preprocessed file first, then assemble
# that.  When the assembler is fixed, delete the following !if-related
# statements and the stuff in the !else block.
#

{..\amd64\}.asm{}.pp:
    $(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$@

{amd64\}.asm{}.pp:
    $(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$@

!if 1

{..\amd64\}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$<

{amd64\}.asm{}.lst:
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$<

{..\amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{$(O)\}.asm{$(O)\}.obj:
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

!else

{..\amd64\}.asm{}.lst:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{amd64\}.asm{}.lst:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\amd64\$(@B).obj $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{..\amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{amd64\}.asm{$(_OBJ_DIR)\amd64\}.obj:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

{$(O)\}.asm{$(O)\}.obj:
    -$(AMD64_ASSEMBLER) -Zs /EP $(MAKEDIR)\$< > $(MAKEDIR)\$(@R).pp
    $(AMD64_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(@R).pp
    del $(MAKEDIR)\$(@R).pp

!endif

!IFDEF _NTAMD64LIBS
_NTLIBS=$(_NTAMD64LIBS)
!ENDIF

COPYDST=$(AMD64COPYDST)
LIB_COPY=ntamd64cp.cmd

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTTEST_LINK_OPTIONS=-entry:KiSystemStartup
!ELSE
NTTEST_LINK_OPTIONS=-base:0x80100000 -entry:KiSystemStartup
!ENDIF

LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98

DRIVER_ALIGNMENT=0x0080
KERNEL_ALIGNMENT=0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\armmk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    armmk.inc

Abstract:

        This module contains the ARM specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0200
!endif

#
# ARM option control
#
UMBASE=$(UMBASE:*=arm)
UMLIBS=$(UMLIBS:*=arm)
NTRES=$(NTRES:*=arm)
UMRES=$(UMRES:*=arm)
UMOBJS=$(UMOBJS:*=arm)
LINKLIBS=$(LINKLIBS:*=arm)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=arm)
DLLBASE=$(DLLBASE:*=arm)
DLLDEF=$(DLLDEF:*=arm)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=arm)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=arm)
DYNLINK_LIB=$(DYNLINK_LIB:*=arm)
TARGETEXEFILES=$(TARGETEXEFILES:*=arm)
TARGETLIBFILES=$(TARGETLIBFILES:*=arm)
TARGETOBJFILES=$(TARGETOBJFILES:*=arm)
UMOBJFILES=$(UMOBJFILES:*=arm)
UMEXEFILES=$(UMEXEFILES:*=arm)
HEADERFILE=$(HEADERFILE:*=arm)
HEADEROBJNAME=$(HEADEROBJNAME:*=arm)
HEADEROBJ=$(HEADEROBJ:*=arm)
PRECOMPILED=$(PRECOMPILED:*=arm)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=arm)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=arm)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=arm)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=arm)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=arm)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=arm)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=arm)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=arm)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=arm)
ORDER=$(ORDER:*=arm)
OBJLIBFILES=$(OBJLIBFILES:*=arm)
MISCFILES=$(MISCFILES) $(ARM_MISCFILES)
SOURCES=$(SOURCES) $(ARM_SOURCES)

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS) $(SDK_LIB_PATH)\atlarm.lib

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=arm)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=arm)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=arm)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=arm)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x1000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS)

!IFDEF ARM_WARNING_LEVEL
MSC_WARNING_LEVEL=$(ARM_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

!ifdef ARM_PERFFLAGS
PERFFLAGS = $(ARM_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(ARM_OPTIMIZATION)
MSC_OPTIMIZATION=$(ARM_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

WIN32_LIBS=$(WIN32_LIBS) $(LIBRARY_PATH)\ntdll.lib

!IFDEF ARM_CPPFLAGS
MSC_CPPFLAGS=$(ARM_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif


!ifdef USE_INCREMENTAL_COMPILING
C_INCREMENTAL_FLAG = /Gi
USE_PDB_TO_COMPILE = 1
!else
C_INCREMENTAL_FLAG = /Gi-
!undef USE_PDB_TO_COMPILE
!endif

!ifndef ARM_CPU_OPTIMIZATION
ARM_CPU_OPTIMIZATION=
!endif

STDFLAGS= /c /Zel /Zp8 /Gy $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(ARM_CPU_OPTIMIZATION) $(C_INCREMENTAL_FLAG) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING)

!if $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!else
ARM_ADBGFLAGS=$(ARM_ADBGFLAGS) /Zi
!endif

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
ARM_ADBGFLAGS=$(ARM_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup,pdata
!ENDIF
# @@END_DDKSPLIT

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\ARM^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\arm\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\arm^\
! endif
!endif

#
# arm option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES=-D_ARM_ -DARM $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(ARM_FLAGS) $(NTARMFLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
ARM_ASMFLAGS=$(ARM_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

ARM_CDEFINES=$(CDEFINES)
ARM_CFLAGS=$(CFLAGS)

CC_NAME = clarm -nologo

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef ARM_ASSEMBLER_NAME
ARM_ASSEMBLER_NAME  = armasm
!endif

GLOBAL_C_FLAGS = -Iarm\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

ARM_ASSEMBLER=$(ARM_ASSEMBLER_NAME) -c -coff -Cx -nologo -Iarm\ -I. $(INCPATH1) $(ARM_ASMFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
	       
ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP


{..\arm\}.asm{}.lst:
    $(ARM_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\arm\$(@B).obj $(MAKEDIR)\$<

{arm\}.asm{}.lst:
    $(ARM_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\arm\$(@B).obj $(MAKEDIR)\$<

{..\arm\}.asm{$(_OBJ_DIR)\arm\}.obj:
    $(ARM_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{arm\}.asm{$(_OBJ_DIR)\arm\}.obj:
    $(ARM_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{$(O)\}.asm{$(O)\}.obj:
    $(ARM_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

!IFDEF _NTARMLIBS
_NTLIBS=$(_NTARMLIBS)
!ENDIF

COPYDST=$(ARMCOPYDST)
LIB_COPY=ntarmcp.cmd

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTTEST_LINK_OPTIONS=-entry:KiSystemStartup
!ELSE
NTTEST_LINK_OPTIONS=-base:0x80100000 -entry:KiSystemStartup
!ENDIF

LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98

DRIVER_ALIGNMENT=0x0080
KERNEL_ALIGNMENT=0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\i386mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    i386mk.inc

Abstract:

        This module contains the x86 specific build controls.  It is included
        by makefile.def.

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
!	if $(_NT_TOOLS_VERSION) >= 0x700
DELAYLOAD_VERSION=0x0200
!	elseif $(_NT_TOOLS_VERSION) == 0x600
DELAYLOAD_VERSION=0x0100
!	else
DELAYLOAD_SUPPORTED=0
!	endif
!endif

#
# x86 option control
#
UMBASE=$(UMBASE:*=i386)
UMLIBS=$(UMLIBS:*=i386)
NTRES=$(NTRES:*=i386)
UMRES=$(UMRES:*=i386)
UMOBJS=$(UMOBJS:*=i386)
LINKLIBS=$(LINKLIBS:*=i386)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=i386)
DLLBASE=$(DLLBASE:*=i386)
DLLDEF=$(DLLDEF:*=i386)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=i386)
!ifdef USE_MSHTML_PDB_RULES
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:????????=*)
!endif
TARGET=$(TARGET:*=i386)
DYNLINK_LIB=$(DYNLINK_LIB:*=i386)
TARGETEXEFILES=$(TARGETEXEFILES:*=i386)
TARGETLIBFILES=$(TARGETLIBFILES:*=i386)
TARGETOBJFILES=$(TARGETOBJFILES:*=i386)
UMOBJFILES=$(UMOBJFILES:*=i386)
UMEXEFILES=$(UMEXEFILES:*=i386)
HEADERFILE=$(HEADERFILE:*=i386)
HEADEROBJNAME=$(HEADEROBJNAME:*=i386)
HEADEROBJ=$(HEADEROBJ:*=i386)
PRECOMPILED=$(PRECOMPILED:*=i386)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=i386)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=i386)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=i386)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=i386)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=i386)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=i386)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=i386)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=i386)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=i386)
ORDER=$(ORDER:*=i386)
OBJLIBFILES=$(OBJLIBFILES:*=i386)
MISCFILES=$(MISCFILES) $(I386_MISCFILES)
SOURCES=$(SOURCES) $(I386_SOURCES)

!ifdef CHICAGO_PRODUCT
USE_MAPSYM=1
!endif

# "$(TARGETTYPE)"=="DRIVER"     ||
# "$(TARGETTYPE)" == "HAL" ||
# "$(TARGETTYPE)" == "EXPORT_DRIVER" ||

!IF "$(TARGETTYPE)"=="GDI_DRIVER" || \
    "$(TARGETTYPE)"=="MINIPORT"
#
#Drivers don't link with link libs.
#
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ELSE
!IF defined(USE_NTDLL) || defined (USE_NOLIBS)
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!ENDIF
!ENDIF

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=i386)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=i386)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=i386)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=i386)
!endif

!IF "$(DLLENTRY)" != "-noentry"
!   IF "$(DLLENTRY:@12=)" == "$(DLLENTRY)"
DLLENTRY=$(DLLENTRY)@12
!   ENDIF
!ENDIF

!IFDEF STD_CALL_ENTRY
UMENTRY=$(UMENTRY)@4
!ENDIF

ENTRY_SUFFIX=@8
GDI_ENTRY_SUFFIX=@12

DEFAULT_STACKRESERVE=0x40000
DEFAULT_STACKCOMMIT=0x2000

!IFDEF 386_WARNING_LEVEL
MSC_WARNING_LEVEL=$(386_WARNING_LEVEL)
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) $(COMPILER_WX_SWITCH)

!ifdef 386_PERFFLAGS
PERFFLAGS = $(386_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(386_OPTIMIZATION)
MSC_OPTIMIZATION=$(386_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

LINK_TIME_CODE_GENERATION_MSC_FLAG=
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_FLAG=/GL
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_FLAG)

!IFDEF 386_CPPFLAGS
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

!ifdef USE_RTTI
RTTI_FLAGS=/GR
!else
RTTI_FLAGS=/GR-
!endif

!if "$(BUFFER_OVERFLOW_CHECKS)" == "1" || \
    ("$(BUFFER_OVERFLOW_CHECKS)" == "CHK" && !$(FREEBUILD))
! if "$(TARGETTYPE)" == "DRIVER" || \
    "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
    "$(TARGETTYPE)" == "DRIVER_LIBRARY"
!  if "$(DRIVERTYPE)" == "WDM" || "$(DRIVERTYPE)" == "wdm"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib $(DDK_LIB_PATH)\wdm.lib
DRIVER_ENTRY=GsDriverEntry
!  else
!   if "$(DRIVERTYPE)" != "VXD"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowK.lib $(DDK_LIB_PATH)\ntoskrnl.lib
DRIVER_ENTRY=GsDriverEntry
!   endif
!  endif
! else
!  if "$(TARGETTYPE)" == "GDI_DRIVER"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
GDI_DRIVER_ENTRY=GsDrvEnableDriver
!  else
!   if  "$(TARGETTYPE)" == "MINIPORT"
# Nothing for now
!   else
!    if "$(TARGETTYPE)" == "DYNLINK"
!     if !(("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss"))
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib $(SDK_LIB_PATH)\kernel32.lib
!      if !defined(RESOURCE_ONLY_DLL) && "$(DLLENTRY)" == "-noentry"
DLLENTRY=-entry:_DllMainCRTStartupForGS@12
!      endif
!     endif
!    else
!     if ("$(UMTYPE)"== "nt") || ("$(UMTYPE)"=="ntss")
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!     else
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib $(SDK_LIB_PATH)\kernel32.lib
!     endif
!    endif
!   endif
!  endif
! endif
!else
!if "$(BUFFER_OVERFLOW_CHECKS)" == "NTDLL"
# Needed for EXEs that can't link to kernel32.dll (smss.exe, sprestrt.exe, etc)
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflow.lib
!else
!if "$(BUFFER_OVERFLOW_CHECKS)" == "GDI"
# Needed for LIBs linked into drivers of type GDI_DRIVER
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowGDI.lib
!else
!if "$(BUFFER_OVERFLOW_CHECKS)" == "NO_NTDLL"
BO_FLAGS=/GS
BO_LIB=$(SDK_LIB_PATH)\BufferOverflowU.lib
!endif
!endif
!endif
!endif  # Overflow checks

!ifndef X86_CPU_OPTIMIZATION
X86_CPU_OPTIMIZATION=/G6
!endif

# Undocumented switch definitions
# /QIfdiv- : Don't emit code to test for bad pentiums
# /QIf     : Emit FPO records for every function (only if !vc7 symbols)

!if defined(VC7_SYMBOLS) || ("$(TARGETTYPE)" == "GDI_DRIVER") || ("$(TARGETTYPE)" == "DRIVER") || ("$(TARGETTYPE)" == "EXPORT_DRIVER")

ERATTA_FLAGS=/QIfdiv-
!if [set _CL_=]
!endif
!if [set _LINK_=]
!endif
!if [set _ML_=]
!endif

!else

ERATTA_FLAGS=/QIfdiv- /QIf
# Make sure _ML_ is set to /Ztmp, not /Zvc6
_ML_=$(_ML_:Zvc6=Ztmp)
!if [set _ML_=$(_ML_)]
!endif

!endif

STDFLAGS= /c /Zel /Zp8 /Gy /Gi- /Gm- $(CBSTRING) $(MSC_WARNING_LEVEL) $(MSC_CALL_TYPE) \
          $(ERATTA_FLAGS) $(X86_CPU_OPTIMIZATION) $(EH_FLAGS) \
          $(RTTI_FLAGS) $(STRING_POOLING) $(BO_FLAGS)

!IF "$(386_STDCALL)" == "0"
MSC_CALL_TYPE=/Gd
MSC_CALL_DEFINE=
!ELSE
!   IF "$(386_STDCALL)" == "2"
MSC_CALL_TYPE=/Gr
MSC_CALL_DEFINE=
!   ELSE
MSC_CALL_TYPE=/Gz
MSC_CALL_DEFINE=-DSTD_CALL
!   ENDIF
!ENDIF

!IF $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!   IFDEF NTNOFPO
!MESSAGE $(NTMAKEENV)\i386mk.inc(1) - Overriding FPO default with NTNOFPO
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
!   ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=1
DBGFLAGS=$(DBGFLAGS) /Oy
!   ENDIF
!ELSE
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0
DBGFLAGS=$(DBGFLAGS) /Oy-
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
!ENDIF

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
386_ADBGFLAGS=$(386_ADBGFLAGS) /Zi
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
!ENDIF
# @@END_DDKSPLIT

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! ifndef USE_MSHTML_PDB_RULES
!  if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
!  else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\i386^\
!  endif
! else
!  ifndef TARGETPDB
TARGETPDB=$(TARGETNAME)
!  endif
!  ifndef ROOT
ROOT=$(MAKEDIR)
!  endif
DBGFLAGS=$(DBGFLAGS) /Fd$(ROOT)\$(_OBJ_DIR)\i386\$(TARGETPDB).pdb
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\i386^\
! endif
!endif

#
# 386 option control
#

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF

STD_DEFINES= -D_X86_=1 -Di386=1 $(HALDEF) $(MSC_CALL_DEFINE) $(STD_DEFINES)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
CFLAGS=$(386_FLAGS) $(NT386FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)

!ifdef MANAGED_CXX
CFLAGS=/clr $(CFLAGS)
!endif

386_ASMFLAGS=$(386_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

386_CDEFINES=$(CDEFINES)
386_CFLAGS=$(CFLAGS)

!if "$(SUBSTITUTE_386_CC)" != ""
CC_NAME = $(SUBSTITUTE_386_CC) -nologo
!else
! if defined(RAZZLETOOLPATH) && !defined( PREFAST_ADD_PATH )
CC_NAME = $(RAZZLETOOLPATH)\x86\cl -nologo
! else
CC_NAME=cl -nologo
! endif
CC_NAME=cl -nologo
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
CS_COMPILER_NAME    = csc.exe -nologo
VB_NET_COMPILER_NAME = vbc.exe -nologo

!if "$(UNSAFE_CODE_SWITCH)" == ""
! if defined(MANAGED_VB)
UNSAFE_CODE_SWITCH=
! else
!  if "$(UNSAFE_CODE)" == "1" 
UNSAFE_CODE_SWITCH=/unsafe+
!  else
UNSAFE_CODE_SWITCH=/unsafe-
!  endif
! endif
!endif

MANAGED_STD_FLAGS        = $(MANAGED_DBG_FLAGS) /warnaserror+ $(UNSAFE_CODE_SWITCH)

!if defined(MANAGED_VB)
MANAGED_STD_FLAGS        = $(MANAGED_STD_FLAGS) $(USER_VB_NET_FLAGS)
!else
MANAGED_STD_FLAGS        = $(MANAGED_STD_FLAGS) $(USER_CS_FLAGS)
!endif

!if defined(PERF_INSTRUMENTATION)
MANAGED_STD_FLAGS=$(MANAGED_STD_FLAGS) /define:PROFILE
!endif

!ifndef 386_ASSEMBLER_NAME
386_ASSEMBLER_NAME  = ml.exe /safeseh
!endif

GLOBAL_C_FLAGS = -Ii386\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS) 

!if defined(NOMASMCOMPATIBILITY)
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) $(386_ASMFLAGS)
!else
386_ASSEMBLER=$(386_ASSEMBLER_NAME) -c -coff -Cx -nologo -Ii386\ -I. $(INCPATH1) -Zm $(386_ASMFLAGS)
!endif

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
	       
ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.asm:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(_OBJ_DIR)\i386\$(@B).obj $(MAKEDIR)\$<

{i386\}.asm{}.lst:
    $(386_ASSEMBLER) /Fl$@ /Fo$(MAKEDIR)\$(_OBJ_DIR)\i386\$(@B).obj $(MAKEDIR)\$<

{..\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{$(_OBJ_DIR)\i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

{i386\}.asm{$(_OBJ_DIR)\i386\}.obj:
    $(386_ASSEMBLER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$<

!IFDEF _NT386LIBS
_NTLIBS=$(_NT386LIBS)
!ENDIF

COPYDST=$(386COPYDST)
LIB_COPY=nti386cp.cmd

!IF "$(NTDEBUGTYPE)" == "windbg" || "$(NTDEBUGTYPE)" == "both"
NTTEST_LINK_OPTIONS=-entry:KiSystemStartup@4
!ELSE
NTTEST_LINK_OPTIONS=-base:0x80100000 -entry:KiSystemStartup@4
!ENDIF

!if "$(TARGETTYPE)" != "DRIVER"         && \
    "$(TARGETTYPE)" != "DRIVER_LIBRARY" && \
    "$(TARGETTYPE)" != "EXPORT_DRIVER"  && \
    "$(TARGETTYPE)" != "HAL"            && \
    "$(TARGETTYPE)" != "GDI_DRIVER"     && \
    "$(TARGETTYPE)" != "MINIPORT"
!	if defined(LINKER_WIN98OPT) || defined (CHICAGO_PRODUCT)
LINKER_FLAGS=$(LINKER_FLAGS) /opt:win98
!	else
LINKER_FLAGS=$(LINKER_FLAGS) /opt:nowin98
!	endif
!endif

# SEH support for libs built with an older compiler
# @@BEGIN_DDKSPLIT
!if 0
# @@END_DDKSPLIT
!if defined(_NT_TARGET_VERSION)
!    if $(_NT_TARGET_VERSION) < 0x502 && $(_NT_TOOLS_VERSION) >= 0x700
TARGETLIBS=$(TARGETLIBS) $(DDK_LIB_PATH)\sehupd.lib
!    endif
!endif
# @@BEGIN_DDKSPLIT
!endif
# @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\ia64mk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    ia64mk.inc

Abstract:

        This module contains the ia64 specific build controls.  It is included
        by makefile.def.

        Add the following variable to your env.

        1) To turn on IA64 hazard detection:

                    set _IA64_HAZARD_DETECTION=-X explicit

        2) To turn on Merced MSR access, add the following variable to your env.

                    set _IA64_MERCED_MSR =-A MERCED

Revision History:

!ENDIF

DELAYLOAD_SUPPORTED=1
!ifndef DELAYLOAD_VERSION
DELAYLOAD_VERSION=0x0200
!endif

#
# ia64 option control
#

!undef USE_MAPSYM

UMBASE=$(UMBASE:*=ia64)
UMLIBS=$(UMLIBS:*=ia64)
NTRES=$(NTRES:*=ia64)
UMRES=$(UMRES:*=ia64)
UMOBJS=$(UMOBJS:*=ia64)
LINKLIBS=$(LINKLIBS:*=ia64)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=ia64)
DLLBASE=$(DLLBASE:*=ia64)
DLLDEF=$(DLLDEF:*=ia64)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=ia64)
TARGET=$(TARGET:*=ia64)
DYNLINK_LIB=$(DYNLINK_LIB:*=ia64)
TARGETEXEFILES=$(TARGETEXEFILES:*=ia64)
TARGETLIBFILES=$(TARGETLIBFILES:*=ia64)
TARGETOBJFILES=$(TARGETOBJFILES:*=ia64)
UMOBJFILES=$(UMOBJFILES:*=ia64)
UMEXEFILES=$(UMEXEFILES:*=ia64)
HEADERFILE=$(HEADERFILE:*=ia64)
HEADEROBJNAME=$(HEADEROBJNAME:*=ia64)
HEADEROBJ=$(HEADEROBJ:*=ia64)
PRECOMPILED=$(PRECOMPILED:*=ia64)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=ia64)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=ia64)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=ia64)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=ia64)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=ia64)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=ia64)
IFSKIT_LIB_PATH=$(IFSKIT_LIB_PATH:*=ia64)
HALKIT_LIB_PATH=$(HALKIT_LIB_PATH:*=ia64)
PROCESSOR_LIB_PATH=$(PROCESSOR_LIB_PATH:*=ia64)
ORDER=$(ORDER:*=ia64)
OBJLIBFILES=$(OBJLIBFILES:*=ia64)
MISCFILES=$(MISCFILES) $(IA64_MISCFILES)
SOURCES=$(SOURCES) $(IA64_SOURCES)
# BINPLACE_FLAGS=$(BINPLACE_FLAGS) -CI 8,halo.exe,-certain,-errata,-quiet

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=ia64)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=ia64)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=ia64)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=ia64)
!endif

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=

DEFAULT_STACKRESERVE=0x100000
DEFAULT_STACKCOMMIT=0x4000

ADDITIONAL_ATL_LIBS = $(ADDITIONAL_ATL_LIBS) $(SDK_LIB_PATH)\atl21asm.lib

!if !defined(_IA64_HAZARD_DETECTION)
_IA64_HAZARD_DETECTION=-X explicit
!endif

!if !defined(_IA64_MERCED_MSR)
_IA64_MERCED_MSR=-A itanium
!endif

!ifndef GENIA64
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Wp64
!endif

!IF DEFINED(IA64_WARNING_LEVEL)
MSC_WARNING_LEVEL=$(IA64_WARNING_LEVEL)
!ENDIF

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!endif

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) $(COMPILER_WX_SWITCH)

!IF DEFINED(IA64_PERFFLAGS)
PERFFLAGS = $(IA64_PERFFLAGS)
!endif

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(IA64_OPTIMIZATION)
MSC_OPTIMIZATION=$(IA64_OPTIMIZATION)
!else
!if !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION)
!endif

LINK_TIME_CODE_GENERATION_MSC_FLAG=

!ifndef GENIA64
!if defined(IA64_DEBUGGABLE_OPTIMIZATION)
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /Zx
!endif
!ifndef IA64_FULL_FLOATING_POINT
MSC_OPTIMIZATION=$(MSC_OPTIMIZATION) /d2QIA64_fr32
!endif
!if defined(LINK_TIME_CODE_GENERATION) && !defined(FORCENATIVEOBJECT)
# Some objects must be built native, so turn off GL for those
LINK_TIME_CODE_GENERATION_MSC_FLAG=/GL
!endif
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION) $(LINK_TIME_CODE_GENERATION_MSC_FLAG)
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) -d debug

WIN32_LIBS=$(WIN32_LIBS) $(LIBRARY_PATH)\ntdll.lib

!if defined(IA64_CPPFLAGS)
MSC_CPPFLAGS=$(IA64_CPPFLAGS)
!elseif defined(386_CPPFLAGS)
MSC_CPPFLAGS=$(386_CPPFLAGS)
!ENDIF

!ifdef NO_STRING_POOLING
STRING_POOLING =
!else
!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX
!if "$(USE_NATIVE_EH)" == "ASYNC"
EH_FLAGS=$(EH_FLAGS) /EHa
!endif
!else
EH_FLAGS=/GX-
!endif

! ifdef USE_RTTI
RTTI_FLAGS=/GR
! else
RTTI_FLAGS=/GR-
! endif

ERRATA_FLAGS=

STDFLAGS= /c /Zel /Zp8 /Gy /Gi- $(CBSTRING) $(MSC_WARNING_LEVEL) \
          $(ERATTA_FLAGS) $(EH_FLAGS) $(RTTI_FLAGS) $(STRING_POOLING)

!IF $(FREEBUILD)
ASM_DBG_DEFINES=-DDBG=0
!ELSE
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) -d debug
!ENDIF

# This is only needed on x86
TARGET_DBG_DEFINES= $(TARGET_DBG_DEFINES) -DFPO=0

# @@BEGIN_DDKSPLIT
!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Zi
IA64_ADBGFLAGS=$(IA64_ADBGFLAGS) -d debug
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
!ENDIF
# @@END_DDKSPLIT

!IFDEF SECTION_ALIGNMENT
SECTION_ALIGNMENT=-align:$(SECTION_ALIGNMENT)
!ENDIF

KERNEL_ALIGNMENT=0x80
HAL_ALIGNMENT=0x80

LINKER_FLAGS = $(LINKER_FLAGS) $(SECTION_ALIGNMENT) -debugtype:pdata

LINK_LIB_IGNORE_FLAG=$(LINK_LIB_IGNORE_FLAG),4006,4044,4108,4088

!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
! else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\ia64^\
! endif
!endif

!ifndef NO_BROWSER_INFO
! ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\ia64^\
! endif
!endif

!IF "$(HALTYPE)" == ""
HALDEF=
!ELSE
HALDEF=-D$(HALTYPE)=1
!ENDIF


#
#
#
!ifdef GENIA64
STD_DEFINES= -D_WIN64 -D_IA64_=1 -DIA64=1 -DNO_HW_DETECT -D_MSC_EXTENSIONS -D_GENIA64_ $(HALDEF) $(STD_DEFINES) -D_CROSS_PLATFORM_=1
!else
STD_DEFINES= -D_WIN64 -D_IA64_=1 -DIA64=1 -DNO_HW_DETECT -D_MSC_EXTENSIONS $(PTR_SIZE) $(HALDEF) $(STD_DEFINES) -D_MERCED_A0_=1
!endif

!if defined(PC98CHANGE)
STD_DEFINES=$(STD_DEFINES) -D_PC98_
!endif

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) \
              $(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MFC_DEFINES)
ASM_DEFINES=$(ASM_DEFINES) -D__assembler=1
CFLAGS=$(IA64_FLAGS) $(NTIA64FLAGS) $(STDFLAGS) $(DBGFLAGS) $(PERFFLAGS) $(USER_C_FLAGS)
IA64_ASMFLAGS=$(IA64_ADBGFLAGS) $(STD_DEFINES) $(ASM_DBG_DEFINES)\
              $(TARGET_DBG_DEFINES) $(ASM_DEFINES)

IA64_CDEFINES=$(CDEFINES)
IA64_CFLAGS=$(CFLAGS)

!ifdef RAZZLETOOLPATH
! if "$(PROCESSOR_ARCHITECTURE)" == "IA64"  
CC_NAME = $(RAZZLETOOLPATH)\ia64\cl -nologo
! else
CC_NAME = $(RAZZLETOOLPATH)\win64\x86\cl -nologo
! endif
!else
CC_NAME=cl -nologo
!endif

C_COMPILER_NAME     = $(CC_NAME)
CXX_COMPILER_NAME   = $(CC_NAME)
C_PREPROCESSOR_NAME = $(CC_NAME)
!ifndef IA64_ASSEMBLER_NAME
IA64_ASSEMBLER_NAME  = ias
!endif

GLOBAL_C_FLAGS = -Iia64\ -I. $(INCPATH1) $(CDEFINES) $(CFLAGS)

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX) $(MSC_CPPFLAGS) $(NTCPPFLAGS)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) -EP -Tc

C_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_ASM_PREPROCESSOR = $(C_PREPROCESSOR_NAME) $(ASM_DEFINES) $(C_PREPROCESSOR_FLAGS:-EP=-E)
C_COMPILER     = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
NP_C_COMPILER  = $(C_COMPILER_NAME) $(NP_COMPILER_FLAGS)
CXX_COMPILER   = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

IA64_ASSEMBLER=$(IA64_ASSEMBLER_NAME) $(_IA64_HAZARD_DETECTION) $(_IA64_MERCED_MSR) -Nso -Iia64\ -I. $(INCPATH1) $(IA64_ADBGFLAGS)

ECHO_MSG=$(C_COMPILER) $<
ECHO_MSG_P=$(NP_C_COMPILER) $**
ECHO_CXX_MSG=$(CXX_COMPILER) $<

ECHO_PRECOMPILED_MSG1=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE)
	       
ECHO_PRECOMPILED_MSG2=$(C_COMPILER_NAME) $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) \
               $(HEADEROBJ) $(PRECOMPILED_FLAG)

{}.c{}.s:
    $(C_COMPILER_NAME) @<< /Fa $(MAKEDIR)\$(<F)
$(C_COMPILER_FLAGS: =
)
$(C_COMPILER_FLAGS:##= )
<<NOKEEP

{..\ia64\}.s{}.lst:
    $(IA64_ASSEMBLER) -o $(_OBJ_DIR)\ia64\$(@B).obj $<

{ia64\}.s{}.lst:
    $(IA64_ASSEMBLER) -o $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(@B).obj $<

{..\ia64\}.s{$(_OBJ_DIR)\ia64\}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $(MAKEDIR)\..\ia64\$(<F) >$(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    $(IA64_ASSEMBLER) -o $(MAKEDIR)\$@ $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i >nul 2>&1

{$(_OBJ_DIR)\ia64\}.s{$(_OBJ_DIR)\ia64\}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<F) >$(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    $(IA64_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i >nul 2>&1

{ia64\}.s{$(_OBJ_DIR)\ia64\}.obj:
    @-erase $@ >nul 2>&1
    $(C_ASM_PREPROCESSOR) $(MAKEDIR)\ia64\$(<F) >$(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    $(IA64_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\ia64\$(<B).i >nul 2>&1


!if defined(_NTIA64LIBS)
_NTLIBS=$(_NTIA64LIBS)
!elseif DEFINED(_NT386LIBS)
_NTLIBS=$(_NT386LIBS)
!endif

!if defined(IA64COPYDST)
COPYDST=$(IA64COPYDST)
!elseif defined(386COPYDST)
COPYDST=$(386COPYDST)
!endif
LIB_COPY=ntia64cp.cmd

NTTEST_LINK_OPTIONS=-section:ivt,,align=0x8000 -fixed:no -base:0xE000000083000000 -entry:KiSystemBegin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\mppcmk.inc ===
!IF 0

Copyright (c) 1994-1996  Microsoft Corporation

Module Name:

    mppcmk.inc

Abstract:

	This module contains the MPPC specific build controls.  It is included
	by makefile.def.

Revision History:

!ENDIF

# add the powermac stuff to the path
PATH=$(IMPORT)\msdev\bin\mppc;$(PATH)

#
# MPPC option control
#

!undef USE_MAPSYM

UMBASE=$(UMBASE:*=mppc)
UMLIBS=$(UMLIBS:*=mppc)
NTRES=$(NTRES:*=mppc)
UMRES=$(UMRES:*=mppc)
UMOBJS=$(UMOBJS:*=mppc)
LINKLIBS=$(LINKLIBS:*=mppc)
GDI_DRIVER_LIBS=$(GDI_DRIVER_LIBS:*=mppc)
DLLBASE=$(DLLBASE:*=mppc)
DLLDEF=$(DLLDEF:*=mppc)
MACHINE_TARGETLIBS=$(MACHINE_TARGETLIBS:*=mppc)
TARGET=$(TARGET:*=mppc)
DYNLINK_LIB=$(DYNLINK_LIB:*=mppc)
TARGETEXEFILES=$(TARGETEXEFILES:*=mppc)
TARGETLIBFILES=$(TARGETLIBFILES:*=mppc)
TARGETOBJFILES=$(TARGETOBJFILES:*=mppc)
UMOBJFILES=$(UMOBJFILES:*=mppc)
UMEXEFILES=$(UMEXEFILES:*=mppc)
HEADERFILE=$(HEADERFILE:*=mppc)
HEADEROBJNAME=$(HEADEROBJNAME:*=mppc)
HEADEROBJ=$(HEADEROBJ:*=mppc)
PRECOMPILED=$(PRECOMPILED:*=mppc)
PRECOMPILED_CXX=$(PRECOMPILED_CXX:*=mppc)
PRECOMPILED_TARGET=$(PRECOMPILED_TARGET:*=mppc)
MFC_STATIC_LIB=$(MFC_STATIC_LIB:*=mppc)
CRT_LIB_PATH=$(CRT_LIB_PATH:*=mppc)
SDK_LIB_PATH=$(SDK_LIB_PATH:*=mppc)
DDK_LIB_PATH=$(DDK_LIB_PATH:*=mppc)
ORDER=$(ORDER:*=mppc)
MISCFILES=$(MISCFILES) $(MPPC_MISCFILES)
SOURCES=$(SOURCES) $(MPPC_SOURCES)

#
# Include 64-bit helper library
#
!if "$(TARGETTYPE)" == "DRIVER"     || \
    "$(TARGETTYPE)" == "EXPORT_DRIVER" || \
    "$(TARGETTYPE)" == "HAL" || \
    "$(TARGETTYPE)" == "GDI_DRIVER" || \
    "$(TARGETTYPE)" == "MINIPORT"
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
!elseif defined(USE_NTDLL) || \
     defined(USE_SYSDLL) || \
     defined (USE_NOLIBS)
MACHINE_TARGETLIBS=$(SDK_LIB_PATH)\int64.lib $(MACHINE_TARGETLIBS)
! if "$(UMTYPE)" == "nt" || \
     "$(UMTYPE)" == "ntss"
# Do this to avoid multiple library warnings (and allow building csr/server)
UMLIBS=$(SDK_LIB_PATH)\int64.lib $(UMLIBS)
! endif
!elseif "$(UMTYPE)" == "nt" || \
        "$(UMTYPE)" == "ntss"
UMLIBS=$(SDK_LIB_PATH)\int64.lib $(UMLIBS)
!endif

!ifdef NTTARGETFILES
NTTARGETFILES=$(NTTARGETFILES:*=mppc)
!endif
!ifdef NTTARGETFILE0
NTTARGETFILE0=$(NTTARGETFILE0:*=mppc)
!endif
!ifdef NTTARGETFILE1
NTTARGETFILE1=$(NTTARGETFILE1:*=mppc)
!endif

!ifdef PROJECT_LIB_PATH
PROJECT_LIB_PATH=$(PROJECT_LIB_PATH:*=mppc)
!endif

!IF "$(GPSIZE)" != "0"
#
# GPSIZE is irrelevant on PowerPC
#
LINKGPSIZE=
!ENDIF

ENTRY_SUFFIX=
GDI_ENTRY_SUFFIX=


!ifndef USE_PDB_TO_COMPILE
DBGFLAGS=$(DBGFLAGS:/Zi=-Z7)
DBGFLAGS=$(DBGFLAGS:-Zi=-Z7)
!else
! if "$(TARGETTYPE)" == "LIBRARY"
DBGFLAGS=$(DBGFLAGS) /Fd$(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).pdb
! else
DBGFLAGS=$(DBGFLAGS) /Fd$(MAKEDIR)\$(_OBJ_DIR)\mppc^\
! endif
!endif

!ifdef BROWSER_INFO
DBGFLAGS=$(DBGFLAGS) /FR$(MAKEDIR)\$(_OBJ_DIR)\mppc^\
!endif

!IFDEF NTBBT
DBGFLAGS=$(DBGFLAGS) /Z7
LINKER_FLAGS=$(LINKER_FLAGS) -debug:full -debugtype:cv,fixup
!ENDIF

!IFDEF MPPC_WARNING_LEVEL
MSC_WARNING_LEVEL=$(MPPC_WARNING_LEVEL)
!ENDIF

!ifdef MPPC_PERFFLAGS
PERFFLAGS = $(MPPC_PERFFLAGS)
!endif

# DEFAULT_MSC_OPT = $(DEFAULT_MSC_OPT:/Oxs=/Ox)

# Set MSC_OPTIMIZATION.
# Order of precedence:
#   Platform specific override
#   Environment variable
#   System Default

!if defined(MPPC_OPTIMIZATION)
MSC_OPTIMIZATION=$(MPPC_OPTIMIZATION)
!elseif !defined(MSC_OPTIMIZATION)
MSC_OPTIMIZATION=$(DEFAULT_MSC_OPT)
!endif

DBGFLAGS=$(DBGFLAGS) $(MSC_OPTIMIZATION)

!IFDEF MPPC_CPPFLAGS
MSC_CPPFLAGS=$(MPPC_CPPFLAGS)
!ENDIF

!ifdef NO_READONLY_STRINGS
STRING_POOLING = /Gf
!else
STRING_POOLING = /GF
!endif

!ifdef USE_NATIVE_EH
EH_FLAGS=/GX /GR
!else
EH_FLAGS=/GX- /GR-
!endif

MPPC_AS=pas
MPPC_DIS=pdis
MPPC_AS_WARNINGS=

MPPC_START_FILE=start.obj

ENV_DEFINES=$(LIBC_DEFINES) $(C_DEFINES) $(NET_C_DEFINES) $(MSC_CPPFLAGS) $(NTCPPFLAGS) $(PM_DEFINES)
STD_DEFINES=-DMPPC=1 -D_MPPC_=1 -DNO_EXT_KEYS $(STD_DEFINES) -D_MAC

STDFLAGS=-c -Zel -Zp2 -Gy $(STRING_POOLING) $(EH_FLAGS)

MPPC_C_COMPILER_NAME = cl -nologo
# MPPC_C_COMPILER_NAME = cl
MPPC_CC = $(MPPC_C_COMPILER_NAME)

CDEFINES=$(STD_DEFINES) $(TARGET_DBG_DEFINES) $(ENV_DEFINES) $(MFC_DEFINES)
CFLAGS=$(MPPC_FLAGS) $(NTMPPCFLAGS) $(STDFLAGS) $(DBGFLAGS) $(USER_C_FLAGS) $(PERFFLAGS)

MPPC_CDEFINES= $(CDEFINES)
MPPC_CFLAGS  = $(CFLAGS)  $(MSC_WARNING_LEVEL) # -DALLOC_TEXT

!IFNDEF MPPC_OPTIONS
MPPC_OPTIONS=
!ENDIF

C_COMPILER_NAME      = $(MPPC_C_COMPILER_NAME)
C_PREPROCESSOR_NAME  = $(MPPC_C_COMPILER_NAME)
CXX_COMPILER_NAME    = $(MPPC_C_COMPILER_NAME)

GLOBAL_C_FLAGS       = -nologo -Imppc\ -I. $(INCPATH0) $(CDEFINES) $(MPPC_OPTIONS) \
                        $(MPPC_CFLAGS) -D__stdcall= -D__cdecl= -DFPO=1 -DLANGUAGE_C

# Disable -WX for now, unless explicitly allowed

!ifndef ALLOW_WX
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS:-WX=)
GLOBAL_C_FLAGS = $(GLOBAL_C_FLAGS:/WX=)
!endif

NP_COMPILER_FLAGS = $(GLOBAL_C_FLAGS) $(COMPILER_WARNINGS)

C_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED)
CXX_COMPILER_FLAGS = $(NP_COMPILER_FLAGS) $(PRECOMPILED_CXX)
C_PREPROCESSOR_FLAGS = $(GLOBAL_C_FLAGS) $(PRECOMPILED) -EP -Tc

C_PREPROCESSOR       = $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS)
C_COMPILER           = $(C_COMPILER_NAME) $(C_COMPILER_FLAGS)
CXX_COMPILER         = $(CXX_COMPILER_NAME) $(CXX_COMPILER_FLAGS)

MPPC_ASSEMBLER        = $(MPPC_AS) $(MPPC_AS_WARNINGS)

ECHO_MSG             = ClPpc $< " $(C_COMPILER) "
ECHO_CXX_MSG         = ClPpc $< " $(CXX_COMPILER) "

ECHO_PRECOMPILED_MSG1=CpPpc $(PRECOMPILED_INCLUDE) \
                     "$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) $(PRECOMPILED_SOURCEFILE) \
		      $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)"

ECHO_PRECOMPILED_MSG2=CpPpc $(PRECOMPILED_INCLUDE) \
                     "$(C_COMPILER_NAME) $(PRECOMPILED_FLAG) \
		      $(C_COMPILER_FLAGS) /Yl$(TARGETNAME) /Yc$(?F) $(HEADERFILE) $(HEADEROBJ)"

{.\}.cxx{}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{.\}.cxx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{}.cxx{$(_OBJ_DIR)\$(TARGET_DIRECTORY)\}.obj:
    @$(ECHO_MSG)
    @$(CXX_COMPILER) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\..\$(<F)

{..\mppc\}.s{$(_OBJ_DIR)\mppc\}.obj:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\..\mppc\$(<F) > $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i && $(MPPC_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i >nul 2>&1

{..\mppc\}.s.pp:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\..\mppc\$(<F) > $(MAKEDIR)\$(<B).pp

{mppc\}.s{$(_OBJ_DIR)\mppc\}.obj:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\mppc\$(<F) > $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i && $(MPPC_ASSEMBLER) -o $@ $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i
    @-erase $(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).i >nul 2>&1

{mppc\}.s.pp:
    @-erase $@ >nul 2>&1
    @echo AsPpc $<            " $(MPPC_ASSEMBLER) "
    @$(C_PREPROCESSOR) $(MAKEDIR)\mppc\$(<F) > $(MAKEDIR)\$(<B).pp

.SUFFIXES: .il

{}.il{}.cod:
    @-erase $@ >nul 2>&1
    @echo cl $<" $(C_COMPILER) "
    @$(C_COMPILER) -FAac -Fa$(<B).cod -B1..\bootbin\null.exe -Bk$(<B). -Fo$(MAKEDIR)\$(_OBJ_DIR)\mppc\$(<B).o $(MAKEDIR)\$(<B).c
    @del $(_OBJ_DIR)\mppc\$(<B).o

!IFDEF CAIRO_PRODUCT
!IFDEF _CAIROMPPCTREE
_NTTREE=$(_CAIROMPPCTREE)
_NTTREE_NO_SPLIT=$(_CAIROMPPCTREE_NS)
!ENDIF
!ELSE
!IFDEF _NTMPPCTREE
_NTTREE=$(_NTMPPCTREE)
_NTTREE_NO_SPLIT=$(_NTMPPCTREE_NS)
!ENDIF
!ENDIF

!IFDEF _NTMPPCLIBS
_NTLIBS=$(_NTMPPCLIBS)
!ENDIF

COPYDST=$(MPPCCOPYDST)

LIB_COPY=ntmppccp.cmd

NTTEST_LINK_OPTIONS= -base:0x80010000 -entry:KiSystemStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\projects.inc ===
ADMIN_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Admin\inc
ADMIN_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Admin\lib
ADMIN_LIB_PATH=$(ADMIN_LIB_DEST)\$(TARGET_DIRECTORY)

BASE_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Base\inc
BASE_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Base\lib
BASE_LIB_PATH=$(BASE_LIB_DEST)\$(TARGET_DIRECTORY)

COM_INC_PATH=$(PUBLIC_INTERNAL_PATH)\COM\inc
COM_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\COM\lib
COM_LIB_PATH=$(COM_LIB_DEST)\$(TARGET_DIRECTORY)

DRIVERS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Drivers\inc
DRIVERS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Drivers\lib
DRIVERS_LIB_PATH=$(DRIVERS_LIB_DEST)\$(TARGET_DIRECTORY)

DS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\DS\inc
DS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\DS\lib
DS_LIB_PATH=$(DS_LIB_DEST)\$(TARGET_DIRECTORY)

ENDUSER_INC_PATH=$(PUBLIC_INTERNAL_PATH)\EndUser\inc
ENDUSER_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\EndUser\lib
ENDUSER_LIB_PATH=$(ENDUSER_LIB_DEST)\$(TARGET_DIRECTORY)

INETCORE_INC_PATH=$(PUBLIC_INTERNAL_PATH)\InetCore\inc
INETCORE_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\InetCore\lib
INETCORE_LIB_PATH=$(INETCORE_LIB_DEST)\$(TARGET_DIRECTORY)

INETSRV_INC_PATH=$(PUBLIC_INTERNAL_PATH)\InetSrv\inc
INETSRV_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\InetSrv\lib
INETSRV_LIB_PATH=$(INETSRV_LIB_DEST)\$(TARGET_DIRECTORY)

MULTIMEDIA_INC_PATH=$(PUBLIC_INTERNAL_PATH)\MultiMedia\inc
MULTIMEDIA_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\MultiMedia\lib
MULTIMEDIA_LIB_PATH=$(MULTIMEDIA_LIB_DEST)\$(TARGET_DIRECTORY)

NET_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Net\inc
NET_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Net\lib
NET_LIB_PATH=$(NET_LIB_DEST)\$(TARGET_DIRECTORY)

PRINTSCAN_INC_PATH=$(PUBLIC_INTERNAL_PATH)\PrintScan\inc
PRINTSCAN_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\PrintScan\lib
PRINTSCAN_LIB_PATH=$(PRINTSCAN_LIB_DEST)\$(TARGET_DIRECTORY)

SDKTOOLS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\SdkTools\inc
SDKTOOLS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\SdkTools\lib
SDKTOOLS_LIB_PATH=$(SDKTOOLS_LIB_DEST)\$(TARGET_DIRECTORY)

SHELL_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Shell\inc
SHELL_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Shell\lib
SHELL_LIB_PATH=$(SHELL_LIB_DEST)\$(TARGET_DIRECTORY)

TERMSRV_INC_PATH=$(PUBLIC_INTERNAL_PATH)\TermSrv\inc
TERMSRV_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\TermSrv\lib
TERMSRV_LIB_PATH=$(TERMSRV_LIB_DEST)\$(TARGET_DIRECTORY)

WINDOWS_INC_PATH=$(PUBLIC_INTERNAL_PATH)\Windows\inc
WINDOWS_LIB_DEST=$(PUBLIC_INTERNAL_PATH)\Windows\lib
WINDOWS_LIB_PATH=$(WINDOWS_LIB_DEST)\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\sxsversionsmk.inc ===
# sxsversionsmk.inc

#
# This file is not used yet.
# I hope Jon uses it when he addresses 
#  586269 Need to rev versions of assemblies for .NET Server
#
# and system_defaultmk.inc should be deleted.
#
# need msvcrt versions
#
# need to be sure to policy files say like
# old = 6.0.0.0 - CURRENT_VIA_PREPROCESSING, new = CURRENT_VIA_PREPROCESSING
#
# stop using preprocessing for the names of dependent assemblies (as system_defaultmk.inc does)
# the names are frozen
#

GDIPLUS_ASSEMBLY_VERSION=1.0
GDIPLUS_ASSEMBLY_VERSION_PART_3=3000
GDIPLUS_ASSEMBLY_VERSION_PART_4=0
GDIPLUS_ASSEMBLY_FULL_VERSION=$(GDIPLUS_ASSEMBLY_VERSION).$(GDIPLUS_ASSEMBLY_VERSION_PART_3).$(GDIPLUS_ASSEMBLY_VERSION_PART_4)

# This does not need to match the nt subsystem version.
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=5.2
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=0
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=0
SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION=$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4)

COMMON_CONTROLS_ASSEMBLY_VERSION=6.0
# This changes to 100?
COMMON_CONTROLS_ASSEMBLY_VERSION_PART_3=1
COMMON_CONTROLS_ASSEMBLY_VERSION_PART_4=0
COMMON_CONTROLS_ASSEMBLY_FULL_VERSION=$(COMMON_CONTROLS_ASSEMBLY_VERSION).$(COMMON_CONTROLS_ASSEMBLY_VERSION_PART_3).$(COMMON_CONTROLS_ASSEMBLY_VERSION_PART_4)

SXS_MANIFEST_DEFINES= \
 $(SXS_MANIFEST_DEFINES) \
 -DGDIPLUS_ASSEMBLY_FULL_VERSION_STRING_A="\"$(GDIPLUS_ASSEMBLY_FULL_VERSION)\"" \
 -DSYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_A="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION)\"" \
 -DCOMMON_CONTROLS_ASSEMBLY_FULL_VERSION_STRING_A="\"$(COMMON_CONTROLS_ASSEMBLY_FULL_VERSION)\"" \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\system_defaultmk.inc ===
# system_defaultmk.inc

# This is for Fusion stuff only. It does not need to match the nt subsystem version.
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION=5.2
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3=0
SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4=0

SYSTEM_COMPATIBLE_ASSEMBLY_NAME=Microsoft.Windows.SystemCompatible
DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME=\
    -DSYSTEM_COMPATIBLE_ASSEMBLY_NAME="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\"" \
    -DLSYSTEM_COMPATIBLE_ASSEMBLY_NAME=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_NAME)\""

SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION=$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_3).$(SYSTEM_COMPATIBLE_ASSEMBLY_VERSION_PART_4)

SXS_MANIFEST_DEFINES= \
 $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
 $(SXS_MANIFEST_DEFINES) \
 -DSYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_A="\"$(SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION)\"" \

C_DEFINES=\
  $(C_DEFINES) \
  $(DEFINE_SYSTEM_COMPATIBLE_ASSEMBLY_NAME) \
  -DSYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION_STRING_W=L"\"$(SYSTEM_COMPATIBLE_ASSEMBLY_FULL_VERSION)\"" \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\buildinfo.h ===
/* BuildInfo.h
 *
 * (c) 1998 ActiveState Tool Corp. All rights reserved. 
 *
 */

#ifndef ___BuildInfo__h___
#define ___BuildInfo__h___

#define PRODUCT_BUILD_NUMBER	"630"
#define PERLFILEVERSION		"5,6,1,630\0"
#define PERLRC_VERSION		5,6,1,630
#define ACTIVEPERL_CHANGELIST   ""
#define PERLPRODUCTVERSION	"Build " PRODUCT_BUILD_NUMBER ACTIVEPERL_CHANGELIST "\0"
#define PERLPRODUCTNAME		"ActivePerl\0"

#define PERL_VENDORLIB_NAME	"ActiveState"

#define ACTIVEPERL_VERSION	"Built "##__TIME__##" "##__DATE__##"\n"
#define ACTIVEPERL_LOCAL_PATCHES_ENTRY	"ActivePerl Build " PRODUCT_BUILD_NUMBER ACTIVEPERL_CHANGELIST
#define BINARY_BUILD_NOTICE	printf("\n\
Binary build " PRODUCT_BUILD_NUMBER ACTIVEPERL_CHANGELIST " provided by ActiveState Tool Corp. http://www.ActiveState.com\n\
" ACTIVEPERL_VERSION "\n");

#endif  /* ___BuildInfo__h___ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\cc_runtime.h ===
#define DOOP(ppname) PUTBACK; PL_op = ppname(aTHX); SPAGAIN
#define CCPP(s)   OP * s(pTHX)

#define PP_LIST(g) do {			\
	dMARK;				\
	if (g != G_ARRAY) {		\
	    if (++MARK <= SP)		\
		*MARK = *SP;		\
	    else			\
		*MARK = &PL_sv_undef;	\
	    SP = MARK;			\
	}				\
   } while (0)

#define MAYBE_TAINT_SASSIGN_SRC(sv) \
    if (PL_tainting && PL_tainted && (!SvGMAGICAL(left) || !SvSMAGICAL(left) || \
                                !((mg=mg_find(left, 't')) && mg->mg_len & 1)))\
        TAINT_NOT

#define PP_PREINC(sv) do {	\
	if (SvIOK(sv)) {	\
            ++SvIVX(sv);	\
	    SvFLAGS(sv) &= ~(SVf_NOK|SVf_POK|SVp_NOK|SVp_POK); \
	}			\
	else			\
	    sv_inc(sv);		\
	SvSETMAGIC(sv);		\
    } while (0)

#define PP_UNSTACK do {		\
	TAINT_NOT;		\
	PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;	\
	FREETMPS;		\
	oldsave = PL_scopestack[PL_scopestack_ix - 1]; \
	LEAVE_SCOPE(oldsave);	\
	SPAGAIN;		\
    } while(0)

/* Anyone using eval "" deserves this mess */
#define PP_EVAL(ppaddr, nxt) do {		\
	dJMPENV;				\
	int ret;				\
	PUTBACK;				\
	JMPENV_PUSH(ret);			\
	switch (ret) {				\
	case 0:					\
	    PL_op = ppaddr(aTHX);		\
	    PL_retstack[PL_retstack_ix - 1] = Nullop;	\
	    if (PL_op != nxt) CALLRUNOPS();		\
	    JMPENV_POP;				\
	    break;				\
	case 1: JMPENV_POP; JMPENV_JUMP(1);	\
	case 2: JMPENV_POP; JMPENV_JUMP(2);	\
	case 3:					\
	    JMPENV_POP;				\
	    if (PL_restartop && PL_restartop != nxt)		\
		JMPENV_JUMP(3);			\
	}					\
	PL_op = nxt;				\
	SPAGAIN;				\
    } while (0)


#define PP_ENTERTRY(jmpbuf,label)  \
	STMT_START {                    \
		int ret;		\
		JMPENV_PUSH_ENV(jmpbuf,ret);			\
		switch (ret) {				\
			case 1: JMPENV_POP_ENV(jmpbuf); JMPENV_JUMP(1);\
			case 2: JMPENV_POP_ENV(jmpbuf); JMPENV_JUMP(2);\
			case 3: JMPENV_POP_ENV(jmpbuf); SPAGAIN; goto label;\
		}                                       \
	} STMT_END
#define PP_LEAVETRY \
	STMT_START{ PL_top_env=PL_top_env->je_prev; }STMT_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\av.h ===
/*    av.h
 *
 *    Copyright (c) 1991-2001, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct xpvav {
    char*	xav_array;      /* pointer to first array element */
    SSize_t	xav_fill;       /* Index of last element present */
    SSize_t	xav_max;        /* max index for which array has space */
    IV		xof_off;	/* ptr is incremented by offset */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
    HV*		xmg_stash;	/* class package */

    SV**	xav_alloc;	/* pointer to malloced string */
    SV*		xav_arylen;
    U8		xav_flags;
};


/* AVf_REAL is set for all AVs whose xav_array contents are refcounted.
 * Some things like "@_" and the scratchpad list do not set this, to
 * indicate that they are cheating (for efficiency) by not refcounting
 * the AV's contents.
 * 
 * AVf_REIFY is only meaningful on such "fake" AVs (i.e. where AVf_REAL
 * is not set).  It indicates that the fake AV is capable of becoming
 * real if the array needs to be modified in some way.  Functions that
 * modify fake AVs check both flags to call av_reify() as appropriate.
 *
 * Note that the Perl stack and @DB::args have neither flag set. (Thus,
 * items that go on the stack are never refcounted.)
 *
 * These internal details are subject to change any time.  AV
 * manipulations external to perl should not care about any of this.
 * GSAR 1999-09-10
 */
#define AVf_REAL 1	/* free old entries */
#define AVf_REIFY 2	/* can become real */

/* XXX this is not used anywhere */
#define AVf_REUSED 4	/* got undeffed--don't turn old memory into SVs now */

/*
=for apidoc AmU||Nullav
Null AV pointer.

=for apidoc Am|int|AvFILL|AV* av
Same as C<av_len()>.  Deprecated, use C<av_len()> instead.

=cut
*/

#define Nullav Null(AV*)

#define AvARRAY(av)	((SV**)((XPVAV*)  SvANY(av))->xav_array)
#define AvALLOC(av)	((XPVAV*)  SvANY(av))->xav_alloc
#define AvMAX(av)	((XPVAV*)  SvANY(av))->xav_max
#define AvFILLp(av)	((XPVAV*)  SvANY(av))->xav_fill
#define AvARYLEN(av)	((XPVAV*)  SvANY(av))->xav_arylen
#define AvFLAGS(av)	((XPVAV*)  SvANY(av))->xav_flags

#define AvREAL(av)	(AvFLAGS(av) & AVf_REAL)
#define AvREAL_on(av)	(AvFLAGS(av) |= AVf_REAL)
#define AvREAL_off(av)	(AvFLAGS(av) &= ~AVf_REAL)
#define AvREIFY(av)	(AvFLAGS(av) & AVf_REIFY)
#define AvREIFY_on(av)	(AvFLAGS(av) |= AVf_REIFY)
#define AvREIFY_off(av)	(AvFLAGS(av) &= ~AVf_REIFY)
#define AvREUSED(av)	(AvFLAGS(av) & AVf_REUSED)
#define AvREUSED_on(av)	(AvFLAGS(av) |= AVf_REUSED)
#define AvREUSED_off(av) (AvFLAGS(av) &= ~AVf_REUSED)

#define AvREALISH(av)	(AvFLAGS(av) & (AVf_REAL|AVf_REIFY))
                                          
#define AvFILL(av)	((SvRMAGICAL((SV *) (av))) \
			  ? mg_size((SV *) av) : AvFILLp(av))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\cop.h ===
/*    cop.h
 *
 *    Copyright (c) 1991-2001, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

struct cop {
    BASEOP
    char *	cop_label;	/* label for this construct */
#ifdef USE_ITHREADS
    char *	cop_stashpv;	/* package line was compiled in */
    char *	cop_file;	/* file name the following line # is from */
#else
    HV *	cop_stash;	/* package line was compiled in */
    GV *	cop_filegv;	/* file the following line # is from */
#endif
    U32		cop_seq;	/* parse sequence number */
    I32		cop_arybase;	/* array base this line was compiled with */
    line_t      cop_line;       /* line # of this command */
    SV *	cop_warnings;	/* lexical warnings bitmask */
};

#define Nullcop Null(COP*)

#ifdef USE_ITHREADS
#  define CopFILE(c)		((c)->cop_file)
#  define CopFILEGV(c)		(CopFILE(c) \
				 ? gv_fetchfile(CopFILE(c)) : Nullgv)
#  define CopFILE_set(c,pv)	((c)->cop_file = savepv(pv))
#  define CopFILESV(c)		(CopFILE(c) \
				 ? GvSV(gv_fetchfile(CopFILE(c))) : Nullsv)
#  define CopFILEAV(c)		(CopFILE(c) \
				 ? GvAV(gv_fetchfile(CopFILE(c))) : Nullav)
#  define CopSTASHPV(c)		((c)->cop_stashpv)
#  define CopSTASHPV_set(c,pv)	((c)->cop_stashpv = ((pv) ? savepv(pv) : Nullch))
#  define CopSTASH(c)		(CopSTASHPV(c) \
				 ? gv_stashpv(CopSTASHPV(c),GV_ADD) : Nullhv)
#  define CopSTASH_set(c,hv)	CopSTASHPV_set(c, (hv) ? HvNAME(hv) : Nullch)
#  define CopSTASH_eq(c,hv)	((hv) 					\
				 && (CopSTASHPV(c) == HvNAME(hv)	\
				     || (CopSTASHPV(c) && HvNAME(hv)	\
					 && strEQ(CopSTASHPV(c), HvNAME(hv)))))
#else
#  define CopFILEGV(c)		((c)->cop_filegv)
#  define CopFILEGV_set(c,gv)	((c)->cop_filegv = (GV*)SvREFCNT_inc(gv))
#  define CopFILE_set(c,pv)	CopFILEGV_set((c), gv_fetchfile(pv))
#  define CopFILESV(c)		(CopFILEGV(c) ? GvSV(CopFILEGV(c)) : Nullsv)
#  define CopFILEAV(c)		(CopFILEGV(c) ? GvAV(CopFILEGV(c)) : Nullav)
#  define CopFILE(c)		(CopFILESV(c) ? SvPVX(CopFILESV(c)) : Nullch)
#  define CopSTASH(c)		((c)->cop_stash)
#  define CopSTASH_set(c,hv)	((c)->cop_stash = (hv))
#  define CopSTASHPV(c)		(CopSTASH(c) ? HvNAME(CopSTASH(c)) : Nullch)
   /* cop_stash is not refcounted */
#  define CopSTASHPV_set(c,pv)	CopSTASH_set((c), gv_stashpv(pv,GV_ADD))
#  define CopSTASH_eq(c,hv)	(CopSTASH(c) == (hv))
#endif /* USE_ITHREADS */

#define CopSTASH_ne(c,hv)	(!CopSTASH_eq(c,hv))
#define CopLINE(c)		((c)->cop_line)
#define CopLINE_inc(c)		(++CopLINE(c))
#define CopLINE_dec(c)		(--CopLINE(c))
#define CopLINE_set(c,l)	(CopLINE(c) = (l))

/*
 * Here we have some enormously heavy (or at least ponderous) wizardry.
 */

/* subroutine context */
struct block_sub {
    CV *	cv;
    GV *	gv;
    GV *	dfoutgv;
#ifndef USE_THREADS
    AV *	savearray;
#endif /* USE_THREADS */
    AV *	argarray;
    U16		olddepth;
    U8		hasargs;
    U8		lval;		/* XXX merge lval and hasargs? */
    SV **	oldcurpad;
};

#define PUSHSUB(cx)							\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.olddepth = (U16)CvDEPTH(cv);			\
	cx->blk_sub.hasargs = hasargs;					\
	cx->blk_sub.lval = PL_op->op_private &                          \
	                      (OPpLVAL_INTRO|OPpENTERSUB_INARGS);

#define PUSHFORMAT(cx)							\
	cx->blk_sub.cv = cv;						\
	cx->blk_sub.gv = gv;						\
	cx->blk_sub.hasargs = 0;					\
	cx->blk_sub.dfoutgv = PL_defoutgv;				\
	(void)SvREFCNT_inc(cx->blk_sub.dfoutgv)

#ifdef USE_THREADS
#  define POP_SAVEARRAY() NOOP
#else
#  define POP_SAVEARRAY()						\
    STMT_START {							\
	SvREFCNT_dec(GvAV(PL_defgv));					\
	GvAV(PL_defgv) = cx->blk_sub.savearray;				\
    } STMT_END
#endif /* USE_THREADS */

/* junk in @_ spells trouble when cloning CVs and in pp_caller(), so don't
 * leave any (a fast av_clear(ary), basically) */
#define CLEAR_ARGARRAY(ary) \
    STMT_START {							\
	AvMAX(ary) += AvARRAY(ary) - AvALLOC(ary);			\
	SvPVX(ary) = (char*)AvALLOC(ary);				\
	AvFILLp(ary) = -1;						\
    } STMT_END

#define POPSUB(cx,sv)							\
    STMT_START {							\
	if (cx->blk_sub.hasargs) {					\
	    POP_SAVEARRAY();						\
	    /* abandon @_ if it got reified */				\
	    if (AvREAL(cx->blk_sub.argarray)) {				\
		SSize_t fill = AvFILLp(cx->blk_sub.argarray);		\
		SvREFCNT_dec(cx->blk_sub.argarray);			\
		cx->blk_sub.argarray = newAV();				\
		av_extend(cx->blk_sub.argarray, fill);			\
		AvFLAGS(cx->blk_sub.argarray) = AVf_REIFY;		\
		cx->blk_sub.oldcurpad[0] = (SV*)cx->blk_sub.argarray;	\
	    }								\
	    else {							\
		CLEAR_ARGARRAY(cx->blk_sub.argarray);			\
	    }								\
	}								\
	sv = (SV*)cx->blk_sub.cv;					\
	if (sv && (CvDEPTH((CV*)sv) = cx->blk_sub.olddepth))		\
	    sv = Nullsv;						\
    } STMT_END

#define LEAVESUB(sv)							\
    STMT_START {							\
	if (sv)								\
	    SvREFCNT_dec(sv);						\
    } STMT_END

#define POPFORMAT(cx)							\
	setdefout(cx->blk_sub.dfoutgv);					\
	SvREFCNT_dec(cx->blk_sub.dfoutgv);

/* eval context */
struct block_eval {
    I32		old_in_eval;
    I32		old_op_type;
    SV *	old_namesv;
    OP *	old_eval_root;
    SV *	cur_text;
    CV *	cv;
};

#define PUSHEVAL(cx,n,fgv)						\
    STMT_START {							\
	cx->blk_eval.old_in_eval = PL_in_eval;				\
	cx->blk_eval.old_op_type = PL_op->op_type;			\
	cx->blk_eval.old_namesv = (n ? newSVpv(n,0) : Nullsv);		\
	cx->blk_eval.old_eval_root = PL_eval_root;			\
	cx->blk_eval.cur_text = PL_linestr;				\
	cx->blk_eval.cv = Nullcv; /* set by doeval(), as applicable */	\
    } STMT_END

#define POPEVAL(cx)							\
    STMT_START {							\
	PL_in_eval = cx->blk_eval.old_in_eval;				\
	optype = cx->blk_eval.old_op_type;				\
	PL_eval_root = cx->blk_eval.old_eval_root;			\
	if (cx->blk_eval.old_namesv)					\
	    sv_2mortal(cx->blk_eval.old_namesv);			\
    } STMT_END

/* loop context */
struct block_loop {
    char *	label;
    I32		resetsp;
    OP *	redo_op;
    OP *	next_op;
    OP *	last_op;
#ifdef USE_ITHREADS
    void *	iterdata;
    SV **	oldcurpad;
#else
    SV **	itervar;
#endif
    SV *	itersave;
    SV *	iterlval;
    AV *	iterary;
    IV		iterix;
    IV		itermax;
};

#ifdef USE_ITHREADS
#  define CxITERVAR(c)							\
	((c)->blk_loop.iterdata						\
	 ? (CxPADLOOP(cx) 						\
	    ? &((c)->blk_loop.oldcurpad)[(PADOFFSET)(c)->blk_loop.iterdata]	\
	    : &GvSV((GV*)(c)->blk_loop.iterdata))			\
	 : (SV**)NULL)
#  define CX_ITERDATA_SET(cx,idata)					\
	cx->blk_loop.oldcurpad = PL_curpad;				\
	if ((cx->blk_loop.iterdata = (idata)))				\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));
#else
#  define CxITERVAR(c)		((c)->blk_loop.itervar)
#  define CX_ITERDATA_SET(cx,ivar)					\
	if ((cx->blk_loop.itervar = (SV**)(ivar)))			\
	    cx->blk_loop.itersave = SvREFCNT_inc(*CxITERVAR(cx));
#endif

#define PUSHLOOP(cx, dat, s)						\
	cx->blk_loop.label = PL_curcop->cop_label;			\
	cx->blk_loop.resetsp = s - PL_stack_base;			\
	cx->blk_loop.redo_op = cLOOP->op_redoop;			\
	cx->blk_loop.next_op = cLOOP->op_nextop;			\
	cx->blk_loop.last_op = cLOOP->op_lastop;			\
	cx->blk_loop.iterlval = Nullsv;					\
	cx->blk_loop.iterary = Nullav;					\
	cx->blk_loop.iterix = -1;					\
	CX_ITERDATA_SET(cx,dat);

#define POPLOOP(cx)							\
	SvREFCNT_dec(cx->blk_loop.iterlval);				\
	if (CxITERVAR(cx)) {						\
	    SV **s_v_p = CxITERVAR(cx);					\
	    sv_2mortal(*s_v_p);						\
	    *s_v_p = cx->blk_loop.itersave;				\
	}								\
	if (cx->blk_loop.iterary && cx->blk_loop.iterary != PL_curstack)\
	    SvREFCNT_dec(cx->blk_loop.iterary);

/* context common to subroutines, evals and loops */
struct block {
    I32		blku_oldsp;	/* stack pointer to copy stuff down to */
    COP *	blku_oldcop;	/* old curcop pointer */
    I32		blku_oldretsp;	/* return stack index */
    I32		blku_oldmarksp;	/* mark stack index */
    I32		blku_oldscopesp;	/* scope stack index */
    PMOP *	blku_oldpm;	/* values of pattern match vars */
    U8		blku_gimme;	/* is this block running in list context? */

    union {
	struct block_sub	blku_sub;
	struct block_eval	blku_eval;
	struct block_loop	blku_loop;
    } blk_u;
};
#define blk_oldsp	cx_u.cx_blk.blku_oldsp
#define blk_oldcop	cx_u.cx_blk.blku_oldcop
#define blk_oldretsp	cx_u.cx_blk.blku_oldretsp
#define blk_oldmarksp	cx_u.cx_blk.blku_oldmarksp
#define blk_oldscopesp	cx_u.cx_blk.blku_oldscopesp
#define blk_oldpm	cx_u.cx_blk.blku_oldpm
#define blk_gimme	cx_u.cx_blk.blku_gimme
#define blk_sub		cx_u.cx_blk.blk_u.blku_sub
#define blk_eval	cx_u.cx_blk.blk_u.blku_eval
#define blk_loop	cx_u.cx_blk.blk_u.blku_loop

/* Enter a block. */
#define PUSHBLOCK(cx,t,sp) CXINC, cx = &cxstack[cxstack_ix],		\
	cx->cx_type		= t,					\
	cx->blk_oldsp		= sp - PL_stack_base,			\
	cx->blk_oldcop		= PL_curcop,				\
	cx->blk_oldmarksp	= PL_markstack_ptr - PL_markstack,	\
	cx->blk_oldscopesp	= PL_scopestack_ix,			\
	cx->blk_oldretsp	= PL_retstack_ix,			\
	cx->blk_oldpm		= PL_curpm,				\
	cx->blk_gimme		= (U8)gimme;				\
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Entering block %ld, type %s\n",	\
		    (long)cxstack_ix, PL_block_type[CxTYPE(cx)]); )

/* Exit a block (RETURN and LAST). */
#define POPBLOCK(cx,pm) cx = &cxstack[cxstack_ix--],			\
	newsp		 = PL_stack_base + cx->blk_oldsp,		\
	PL_curcop	 = cx->blk_oldcop,				\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_retstack_ix	 = cx->blk_oldretsp,				\
	pm		 = cx->blk_oldpm,				\
	gimme		 = cx->blk_gimme;				\
	DEBUG_l( PerlIO_printf(Perl_debug_log, "Leaving block %ld, type %s\n",		\
		    (long)cxstack_ix+1,PL_block_type[CxTYPE(cx)]); )

/* Continue a block elsewhere (NEXT and REDO). */
#define TOPBLOCK(cx) cx  = &cxstack[cxstack_ix],			\
	PL_stack_sp	 = PL_stack_base + cx->blk_oldsp,		\
	PL_markstack_ptr = PL_markstack + cx->blk_oldmarksp,		\
	PL_scopestack_ix = cx->blk_oldscopesp,				\
	PL_retstack_ix	 = cx->blk_oldretsp,				\
	PL_curpm         = cx->blk_oldpm

/* substitution context */
struct subst {
    I32		sbu_iters;
    I32		sbu_maxiters;
    I32		sbu_rflags;
    I32		sbu_oldsave;
    bool	sbu_once;
    bool	sbu_rxtainted;
    char *	sbu_orig;
    SV *	sbu_dstr;
    SV *	sbu_targ;
    char *	sbu_s;
    char *	sbu_m;
    char *	sbu_strend;
    void *	sbu_rxres;
    REGEXP *	sbu_rx;
};
#define sb_iters	cx_u.cx_subst.sbu_iters
#define sb_maxiters	cx_u.cx_subst.sbu_maxiters
#define sb_rflags	cx_u.cx_subst.sbu_rflags
#define sb_oldsave	cx_u.cx_subst.sbu_oldsave
#define sb_once		cx_u.cx_subst.sbu_once
#define sb_rxtainted	cx_u.cx_subst.sbu_rxtainted
#define sb_orig		cx_u.cx_subst.sbu_orig
#define sb_dstr		cx_u.cx_subst.sbu_dstr
#define sb_targ		cx_u.cx_subst.sbu_targ
#define sb_s		cx_u.cx_subst.sbu_s
#define sb_m		cx_u.cx_subst.sbu_m
#define sb_strend	cx_u.cx_subst.sbu_strend
#define sb_rxres	cx_u.cx_subst.sbu_rxres
#define sb_rx		cx_u.cx_subst.sbu_rx

#define PUSHSUBST(cx) CXINC, cx = &cxstack[cxstack_ix],			\
	cx->sb_iters		= iters,				\
	cx->sb_maxiters		= maxiters,				\
	cx->sb_rflags		= r_flags,				\
	cx->sb_oldsave		= oldsave,				\
	cx->sb_once		= once,					\
	cx->sb_rxtainted	= rxtainted,				\
	cx->sb_orig		= orig,					\
	cx->sb_dstr		= dstr,					\
	cx->sb_targ		= targ,					\
	cx->sb_s		= s,					\
	cx->sb_m		= m,					\
	cx->sb_strend		= strend,				\
	cx->sb_rxres		= Null(void*),				\
	cx->sb_rx		= rx,					\
	cx->cx_type		= CXt_SUBST;				\
	rxres_save(&cx->sb_rxres, rx)

#define POPSUBST(cx) cx = &cxstack[cxstack_ix--];			\
	rxres_free(&cx->sb_rxres)

struct context {
    U32		cx_type;	/* what kind of context this is */
    union {
	struct block	cx_blk;
	struct subst	cx_subst;
    } cx_u;
};

#define CXTYPEMASK	0xff
#define CXt_NULL	0
#define CXt_SUB		1
#define CXt_EVAL	2
#define CXt_LOOP	3
#define CXt_SUBST	4
#define CXt_BLOCK	5
#define CXt_FORMAT	6

/* private flags for CXt_EVAL */
#define CXp_REAL	0x00000100	/* truly eval'', not a lookalike */
#define CXp_TRYBLOCK	0x00000200	/* eval{}, not eval'' or similar */

#ifdef USE_ITHREADS
/* private flags for CXt_LOOP */
#  define CXp_PADVAR	0x00000100	/* itervar lives on pad, iterdata
					   has pad offset; if not set,
					   iterdata holds GV* */
#  define CxPADLOOP(c)	(((c)->cx_type & (CXt_LOOP|CXp_PADVAR))		\
			 == (CXt_LOOP|CXp_PADVAR))
#endif

#define CxTYPE(c)	((c)->cx_type & CXTYPEMASK)
#define CxREALEVAL(c)	(((c)->cx_type & (CXt_EVAL|CXp_REAL))		\
			 == (CXt_EVAL|CXp_REAL))
#define CxTRYBLOCK(c)	(((c)->cx_type & (CXt_EVAL|CXp_TRYBLOCK))	\
			 == (CXt_EVAL|CXp_TRYBLOCK))

#define CXINC (cxstack_ix < cxstack_max ? ++cxstack_ix : (cxstack_ix = cxinc()))

/* "gimme" values */

/*
=for apidoc AmU||G_SCALAR
Used to indicate scalar context.  See C<GIMME_V>, C<GIMME>, and
L<perlcall>.

=for apidoc AmU||G_ARRAY
Used to indicate list context.  See C<GIMME_V>, C<GIMME> and
L<perlcall>.

=for apidoc AmU||G_VOID
Used to indicate void context.  See C<GIMME_V> and L<perlcall>.

=for apidoc AmU||G_DISCARD
Indicates that arguments returned from a callback should be discarded.  See
L<perlcall>.

=for apidoc AmU||G_EVAL

Used to force a Perl C<eval> wrapper around a callback.  See
L<perlcall>.

=for apidoc AmU||G_NOARGS

Indicates that no arguments are being sent to a callback.  See
L<perlcall>.

=cut
*/

#define G_SCALAR	0
#define G_ARRAY		1
#define G_VOID		128	/* skip this bit when adding flags below */

/* extra flags for Perl_call_* routines */
#define G_DISCARD	2	/* Call FREETMPS. */
#define G_EVAL		4	/* Assume eval {} around subroutine call. */
#define G_NOARGS	8	/* Don't construct a @_ array. */
#define G_KEEPERR      16	/* Append errors to $@, don't overwrite it */
#define G_NODEBUG      32	/* Disable debugging at toplevel.  */
#define G_METHOD       64       /* Calling method. */

/* flag bits for PL_in_eval */
#define EVAL_NULL	0	/* not in an eval */
#define EVAL_INEVAL	1	/* some enclosing scope is an eval */
#define EVAL_WARNONLY	2	/* used by yywarn() when calling yyerror() */
#define EVAL_KEEPERR	4	/* set by Perl_call_sv if G_KEEPERR */
#define EVAL_INREQUIRE	8	/* The code is being required. */

/* Support for switching (stack and block) contexts.
 * This ensures magic doesn't invalidate local stack and cx pointers.
 */

#define PERLSI_UNKNOWN		-1
#define PERLSI_UNDEF		0
#define PERLSI_MAIN		1
#define PERLSI_MAGIC		2
#define PERLSI_SORT		3
#define PERLSI_SIGNAL		4
#define PERLSI_OVERLOAD		5
#define PERLSI_DESTROY		6
#define PERLSI_WARNHOOK		7
#define PERLSI_DIEHOOK		8
#define PERLSI_REQUIRE		9

struct stackinfo {
    AV *		si_stack;	/* stack for current runlevel */
    PERL_CONTEXT *	si_cxstack;	/* context stack for runlevel */
    I32			si_cxix;	/* current context index */
    I32			si_cxmax;	/* maximum allocated index */
    I32			si_type;	/* type of runlevel */
    struct stackinfo *	si_prev;
    struct stackinfo *	si_next;
    I32			si_markoff;	/* offset where markstack begins for us.
					 * currently used only with DEBUGGING,
					 * but not #ifdef-ed for bincompat */
};

typedef struct stackinfo PERL_SI;

#define cxstack		(PL_curstackinfo->si_cxstack)
#define cxstack_ix	(PL_curstackinfo->si_cxix)
#define cxstack_max	(PL_curstackinfo->si_cxmax)

#ifdef DEBUGGING
#  define	SET_MARK_OFFSET \
    PL_curstackinfo->si_markoff = PL_markstack_ptr - PL_markstack
#else
#  define	SET_MARK_OFFSET NOOP
#endif

#define PUSHSTACKi(type) \
    STMT_START {							\
	PERL_SI *next = PL_curstackinfo->si_next;			\
	if (!next) {							\
	    next = new_stackinfo(32, 2048/sizeof(PERL_CONTEXT) - 1);	\
	    next->si_prev = PL_curstackinfo;				\
	    PL_curstackinfo->si_next = next;				\
	}								\
	next->si_type = type;						\
	next->si_cxix = -1;						\
	AvFILLp(next->si_stack) = 0;					\
	SWITCHSTACK(PL_curstack,next->si_stack);			\
	PL_curstackinfo = next;						\
	SET_MARK_OFFSET;						\
    } STMT_END

#define PUSHSTACK PUSHSTACKi(PERLSI_UNKNOWN)

/* POPSTACK works with PL_stack_sp, so it may need to be bracketed by
 * PUTBACK/SPAGAIN to flush/refresh any local SP that may be active */
#define POPSTACK \
    STMT_START {							\
	dSP;								\
	PERL_SI *prev = PL_curstackinfo->si_prev;			\
	if (!prev) {							\
	    PerlIO_printf(Perl_error_log, "panic: POPSTACK\n");		\
	    my_exit(1);							\
	}								\
	SWITCHSTACK(PL_curstack,prev->si_stack);			\
	/* don't free prev here, free them all at the END{} */		\
	PL_curstackinfo = prev;						\
    } STMT_END

#define POPSTACK_TO(s) \
    STMT_START {							\
	while (PL_curstack != s) {					\
	    dounwind(-1);						\
	    POPSTACK;							\
	}								\
    } STMT_END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\config.h ===
/*
 * This file was produced by running the config_h.SH script, which
 * gets its values from config.sh, which is generally produced by
 * running Configure.
 *
 * Feel free to modify any of this as the need arises.  Note, however,
 * that running config_h.SH again will wipe out any changes you've made.
 * For a more permanent change edit config.sh and rerun config_h.SH.
 *
 * $Id: Config_h.U,v 3.0.1.5 1997/02/28 14:57:43 ram Exp $
 */

/*
 * Package name      : perl5
 * Source directory  : 
 * Configuration time: Wed Oct 31 20:29:27 2001
 * Configured by     : gsar
 * Target system     : 
 */

#ifndef _config_h_
#define _config_h_

/* LOC_SED:
 *	This symbol holds the complete pathname to the sed program.
 */
#define LOC_SED 	""	/**/

/* HAS_ALARM:
 *	This symbol, if defined, indicates that the alarm routine is
 *	available.
 */
/*#define HAS_ALARM		/**/

/* HASATTRIBUTE:
 *	This symbol indicates the C compiler can check for function attributes,
 *	such as printf formats. This is normally only supported by GNU cc.
 */
/*#define HASATTRIBUTE 	/**/
#ifndef HASATTRIBUTE
#define __attribute__(_arg_)
#endif

/* HAS_BCMP:
 *	This symbol is defined if the bcmp() routine is available to
 *	compare blocks of memory.
 */
/*#define HAS_BCMP	/**/

/* HAS_BCOPY:
 *	This symbol is defined if the bcopy() routine is available to
 *	copy blocks of memory.
 */
/*#define HAS_BCOPY	/**/

/* HAS_BZERO:
 *	This symbol is defined if the bzero() routine is available to
 *	set a memory block to 0.
 */
/*#define HAS_BZERO	/**/

/* HAS_CHOWN:
 *	This symbol, if defined, indicates that the chown routine is
 *	available.
 */
/*#define HAS_CHOWN		/**/

/* HAS_CHROOT:
 *	This symbol, if defined, indicates that the chroot routine is
 *	available.
 */
/*#define HAS_CHROOT		/**/

/* HAS_CHSIZE:
 *	This symbol, if defined, indicates that the chsize routine is available
 *	to truncate files.  You might need a -lx to get this routine.
 */
#define	HAS_CHSIZE		/**/

/* HASCONST:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the const type. There is no need to actually test for that symbol
 *	within your programs. The mere use of the "const" keyword will
 *	trigger the necessary tests.
 */
#define HASCONST	/**/
#ifndef HASCONST
#define const
#endif

/* HAS_CRYPT:
 *	This symbol, if defined, indicates that the crypt routine is available
 *	to encrypt passwords and the like.
 */
#define HAS_CRYPT		/**/

/* HAS_CUSERID:
 *	This symbol, if defined, indicates that the cuserid routine is
 *	available to get character login names.
 */
/*#define HAS_CUSERID		/**/

/* HAS_DBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol DBL_DIG, which is the number
 *	of significant digits in a double precision number.  If this
 *	symbol is not defined, a guess of 15 is usually pretty good.
 */
#define HAS_DBL_DIG 	/**/

/* HAS_DIFFTIME:
 *	This symbol, if defined, indicates that the difftime routine is
 *	available.
 */
#define HAS_DIFFTIME		/**/

/* HAS_DLERROR:
 *	This symbol, if defined, indicates that the dlerror routine is
 *	available to return a string describing the last error that
 *	occurred from a call to dlopen(), dlclose() or dlsym().
 */
#define HAS_DLERROR	/**/

/* SETUID_SCRIPTS_ARE_SECURE_NOW:
 *	This symbol, if defined, indicates that the bug that prevents
 *	setuid scripts from being secure is not present in this kernel.
 */
/* DOSUID:
 *	This symbol, if defined, indicates that the C program should
 *	check the script that it is executing for setuid/setgid bits, and
 *	attempt to emulate setuid/setgid on systems that have disabled
 *	setuid #! scripts because the kernel can't do it securely.
 *	It is up to the package designer to make sure that this emulation
 *	is done securely.  Among other things, it should do an fstat on
 *	the script it just opened to make sure it really is a setuid/setgid
 *	script, it should make sure the arguments passed correspond exactly
 *	to the argument on the #! line, and it should not trust any
 *	subprocesses to which it must pass the filename rather than the
 *	file descriptor of the script to be executed.
 */
/*#define SETUID_SCRIPTS_ARE_SECURE_NOW	/**/
/*#define DOSUID		/**/

/* HAS_DUP2:
 *	This symbol, if defined, indicates that the dup2 routine is
 *	available to duplicate file descriptors.
 */
#define HAS_DUP2	/**/

/* HAS_FCHMOD:
 *	This symbol, if defined, indicates that the fchmod routine is available
 *	to change mode of opened files.  If unavailable, use chmod().
 */
/*#define HAS_FCHMOD		/**/

/* HAS_FCHOWN:
 *	This symbol, if defined, indicates that the fchown routine is available
 *	to change ownership of opened files.  If unavailable, use chown().
 */
/*#define HAS_FCHOWN		/**/

/* HAS_FCNTL:
 *	This symbol, if defined, indicates to the C program that
 *	the fcntl() function exists.
 */
/*#define HAS_FCNTL		/**/

/* HAS_FGETPOS:
 *	This symbol, if defined, indicates that the fgetpos routine is
 *	available to get the file position indicator, similar to ftell().
 */
#define HAS_FGETPOS	/**/

/* HAS_FLOCK:
 *	This symbol, if defined, indicates that the flock routine is
 *	available to do file locking.
 */
#define HAS_FLOCK		/**/

/* HAS_FORK:
 *	This symbol, if defined, indicates that the fork routine is
 *	available.
 */
/*#define HAS_FORK		/**/

/* HAS_FSETPOS:
 *	This symbol, if defined, indicates that the fsetpos routine is
 *	available to set the file position indicator, similar to fseek().
 */
#define HAS_FSETPOS	/**/

/* HAS_GETTIMEOFDAY:
 *	This symbol, if defined, indicates that the gettimeofday() system
 *	call is available for a sub-second accuracy clock. Usually, the file
 *	<sys/resource.h> needs to be included (see I_SYS_RESOURCE).
 *	The type "Timeval" should be used to refer to "struct timeval".
 */
/*#define HAS_GETTIMEOFDAY	/**/
#ifdef HAS_GETTIMEOFDAY
#define Timeval struct timeval	/* Structure used by gettimeofday() */
#endif

/* HAS_GETGROUPS:
 *	This symbol, if defined, indicates that the getgroups() routine is
 *	available to get the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_GETGROUPS		/**/

/* HAS_GETLOGIN:
 *	This symbol, if defined, indicates that the getlogin routine is
 *	available to get the login name.
 */
#define HAS_GETLOGIN		/**/

/* HAS_GETPGID:
 *	This symbol, if defined, indicates to the C program that 
 *	the getpgid(pid) function is available to get the
 *	process group id.
 */
/*#define HAS_GETPGID		/**/

/* HAS_GETPGRP2:
 *	This symbol, if defined, indicates that the getpgrp2() (as in DG/UX)
 *	routine is available to get the current process group.
 */
/*#define HAS_GETPGRP2		/**/

/* HAS_GETPPID:
 *	This symbol, if defined, indicates that the getppid routine is
 *	available to get the parent process ID.
 */
/*#define HAS_GETPPID		/**/

/* HAS_GETPRIORITY:
 *	This symbol, if defined, indicates that the getpriority routine is
 *	available to get a process's priority.
 */
/*#define HAS_GETPRIORITY		/**/

/* HAS_INET_ATON:
 *	This symbol, if defined, indicates to the C program that the
 *	inet_aton() function is available to parse IP address "dotted-quad"
 *	strings.
 */
/*#define HAS_INET_ATON		/**/

/* HAS_KILLPG:
 *	This symbol, if defined, indicates that the killpg routine is available
 *	to kill process groups.  If unavailable, you probably should use kill
 *	with a negative process number.
 */
/*#define HAS_KILLPG	/**/

/* HAS_LINK:
 *	This symbol, if defined, indicates that the link routine is
 *	available to create hard links.
 */
#define HAS_LINK	/**/

/* HAS_LOCALECONV:
 *	This symbol, if defined, indicates that the localeconv routine is
 *	available for numeric and monetary formatting conventions.
 */
#define HAS_LOCALECONV	/**/

/* HAS_LOCKF:
 *	This symbol, if defined, indicates that the lockf routine is
 *	available to do file locking.
 */
/*#define HAS_LOCKF		/**/

/* HAS_LSTAT:
 *	This symbol, if defined, indicates that the lstat routine is
 *	available to do file stats on symbolic links.
 */
/*#define HAS_LSTAT		/**/

/* HAS_MBLEN:
 *	This symbol, if defined, indicates that the mblen routine is available
 *	to find the number of bytes in a multibye character.
 */
#define HAS_MBLEN		/**/

/* HAS_MBSTOWCS:
 *	This symbol, if defined, indicates that the mbstowcs routine is
 *	available to covert a multibyte string into a wide character string.
 */
#define	HAS_MBSTOWCS		/**/

/* HAS_MBTOWC:
 *	This symbol, if defined, indicates that the mbtowc routine is available
 *	to covert a multibyte to a wide character.
 */
#define HAS_MBTOWC		/**/

/* HAS_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	to compare blocks of memory.
 */
#define HAS_MEMCMP	/**/

/* HAS_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy blocks of memory.
 */
#define HAS_MEMCPY	/**/

/* HAS_MEMMOVE:
 *	This symbol, if defined, indicates that the memmove routine is available
 *	to copy potentially overlapping blocks of memory. This should be used
 *	only when HAS_SAFE_BCOPY is not defined. If neither is there, roll your
 *	own version.
 */
#define HAS_MEMMOVE	/**/

/* HAS_MEMSET:
 *	This symbol, if defined, indicates that the memset routine is available
 *	to set blocks of memory.
 */
#define HAS_MEMSET	/**/

/* HAS_MKDIR:
 *	This symbol, if defined, indicates that the mkdir routine is available
 *	to create directories.  Otherwise you should fork off a new process to
 *	exec /bin/mkdir.
 */
#define HAS_MKDIR		/**/

/* HAS_MKFIFO:
 *	This symbol, if defined, indicates that the mkfifo routine is
 *	available to create FIFOs. Otherwise, mknod should be able to
 *	do it for you. However, if mkfifo is there, mknod might require
 *	super-user privileges which mkfifo will not.
 */
/*#define HAS_MKFIFO		/**/

/* HAS_MKTIME:
 *	This symbol, if defined, indicates that the mktime routine is
 *	available.
 */
#define HAS_MKTIME		/**/

/* HAS_MSYNC:
 *	This symbol, if defined, indicates that the msync system call is
 *	available to synchronize a mapped file.
 */
/*#define HAS_MSYNC		/**/

/* HAS_MUNMAP:
 *	This symbol, if defined, indicates that the munmap system call is
 *	available to unmap a region, usually mapped by mmap().
 */
/*#define HAS_MUNMAP		/**/

/* HAS_NICE:
 *	This symbol, if defined, indicates that the nice routine is
 *	available.
 */
/*#define HAS_NICE		/**/

/* HAS_PATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given filename.
 */
/* HAS_FPATHCONF:
 *	This symbol, if defined, indicates that pathconf() is available
 *	to determine file-system related limits and options associated
 *	with a given open file descriptor.
 */
/*#define HAS_PATHCONF		/**/
/*#define HAS_FPATHCONF		/**/

/* HAS_PAUSE:
 *	This symbol, if defined, indicates that the pause routine is
 *	available to suspend a process until a signal is received.
 */
#define HAS_PAUSE		/**/

/* HAS_PIPE:
 *	This symbol, if defined, indicates that the pipe routine is
 *	available to create an inter-process channel.
 */
#define HAS_PIPE		/**/

/* HAS_POLL:
 *	This symbol, if defined, indicates that the poll routine is
 *	available to poll active file descriptors. You may safely
 *	include <poll.h> when this symbol is defined.
 */
/*#define HAS_POLL		/**/

/* HAS_READDIR:
 *	This symbol, if defined, indicates that the readdir routine is
 *	available to read directory entries. You may have to include
 *	<dirent.h>. See I_DIRENT.
 */
#define HAS_READDIR		/**/

/* HAS_SEEKDIR:
 *	This symbol, if defined, indicates that the seekdir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_SEEKDIR		/**/

/* HAS_TELLDIR:
 *	This symbol, if defined, indicates that the telldir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_TELLDIR		/**/

/* HAS_REWINDDIR:
 *	This symbol, if defined, indicates that the rewinddir routine is
 *	available. You may have to include <dirent.h>. See I_DIRENT.
 */
#define HAS_REWINDDIR		/**/

/* HAS_READLINK:
 *	This symbol, if defined, indicates that the readlink routine is
 *	available to read the value of a symbolic link.
 */
/*#define HAS_READLINK		/**/

/* HAS_RENAME:
 *	This symbol, if defined, indicates that the rename routine is available
 *	to rename files.  Otherwise you should do the unlink(), link(), unlink()
 *	trick.
 */
#define HAS_RENAME	/**/

/* HAS_RMDIR:
 *	This symbol, if defined, indicates that the rmdir routine is
 *	available to remove directories. Otherwise you should fork off a
 *	new process to exec /bin/rmdir.
 */
#define HAS_RMDIR		/**/

/* HAS_SELECT:
 *	This symbol, if defined, indicates that the select routine is
 *	available to select active file descriptors. If the timeout field
 *	is used, <sys/time.h> may need to be included.
 */
#define HAS_SELECT	/**/

/* HAS_SETEGID:
 *	This symbol, if defined, indicates that the setegid routine is available
 *	to change the effective gid of the current program.
 */
/*#define HAS_SETEGID		/**/

/* HAS_SETEUID:
 *	This symbol, if defined, indicates that the seteuid routine is available
 *	to change the effective uid of the current program.
 */
/*#define HAS_SETEUID		/**/

/* HAS_SETLINEBUF:
 *	This symbol, if defined, indicates that the setlinebuf routine is
 *	available to change stderr or stdout from block-buffered or unbuffered
 *	to a line-buffered mode.
 */
/*#define HAS_SETLINEBUF		/**/

/* HAS_SETLOCALE:
 *	This symbol, if defined, indicates that the setlocale routine is
 *	available to handle locale-specific ctype implementations.
 */
#define HAS_SETLOCALE	/**/

/* HAS_SETPGID:
 *	This symbol, if defined, indicates that the setpgid(pid, gpid)
 *	routine is available to set process group ID.
 */
/*#define HAS_SETPGID	/**/

/* HAS_SETPGRP2:
 *	This symbol, if defined, indicates that the setpgrp2() (as in DG/UX)
 *	routine is available to set the current process group.
 */
/*#define HAS_SETPGRP2		/**/

/* HAS_SETPRIORITY:
 *	This symbol, if defined, indicates that the setpriority routine is
 *	available to set a process's priority.
 */
/*#define HAS_SETPRIORITY		/**/

/* HAS_SETREGID:
 *	This symbol, if defined, indicates that the setregid routine is
 *	available to change the real and effective gid of the current
 *	process.
 */
/* HAS_SETRESGID:
 *	This symbol, if defined, indicates that the setresgid routine is
 *	available to change the real, effective and saved gid of the current
 *	process.
 */
/*#define HAS_SETREGID		/**/
/*#define HAS_SETRESGID		/**/

/* HAS_SETREUID:
 *	This symbol, if defined, indicates that the setreuid routine is
 *	available to change the real and effective uid of the current
 *	process.
 */
/* HAS_SETRESUID:
 *	This symbol, if defined, indicates that the setresuid routine is
 *	available to change the real, effective and saved uid of the current
 *	process.
 */
/*#define HAS_SETREUID		/**/
/*#define HAS_SETRESUID		/**/

/* HAS_SETRGID:
 *	This symbol, if defined, indicates that the setrgid routine is available
 *	to change the real gid of the current program.
 */
/*#define HAS_SETRGID		/**/

/* HAS_SETRUID:
 *	This symbol, if defined, indicates that the setruid routine is available
 *	to change the real uid of the current program.
 */
/*#define HAS_SETRUID		/**/

/* HAS_SETSID:
 *	This symbol, if defined, indicates that the setsid routine is
 *	available to set the process group ID.
 */
/*#define HAS_SETSID	/**/

/* Shmat_t:
 *	This symbol holds the return type of the shmat() system call.
 *	Usually set to 'void *' or 'char *'.
 */
/* HAS_SHMAT_PROTOTYPE:
 *	This symbol, if defined, indicates that the sys/shm.h includes
 *	a prototype for shmat().  Otherwise, it is up to the program to
 *	guess one.  Shmat_t shmat _((int, Shmat_t, int)) is a good guess,
 *	but not always right so it should be emitted by the program only
 *	when HAS_SHMAT_PROTOTYPE is not defined to avoid conflicting defs.
 */
#define Shmat_t void *	/**/
/*#define HAS_SHMAT_PROTOTYPE	/**/

/* HAS_STRCHR:
 *	This symbol is defined to indicate that the strchr()/strrchr()
 *	functions are available for string searching. If not, try the
 *	index()/rindex() pair.
 */
/* HAS_INDEX:
 *	This symbol is defined to indicate that the index()/rindex()
 *	functions are available for string searching.
 */
#define HAS_STRCHR	/**/
/*#define HAS_INDEX	/**/

/* HAS_STRCOLL:
 *	This symbol, if defined, indicates that the strcoll routine is
 *	available to compare strings using collating information.
 */
#define HAS_STRCOLL	/**/

/* USE_STRUCT_COPY:
 *	This symbol, if defined, indicates that this C compiler knows how
 *	to copy structures.  If undefined, you'll need to use a block copy
 *	routine of some sort instead.
 */
#define	USE_STRUCT_COPY	/**/

/* HAS_STRTOD:
 *	This symbol, if defined, indicates that the strtod routine is
 *	available to provide better numeric string conversion than atof().
 */
#define HAS_STRTOD	/**/

/* HAS_STRTOL:
 *	This symbol, if defined, indicates that the strtol routine is available
 *	to provide better numeric string conversion than atoi() and friends.
 */
#define HAS_STRTOL	/**/

/* HAS_STRTOUL:
 *	This symbol, if defined, indicates that the strtoul routine is
 *	available to provide conversion of strings to unsigned long.
 */
#define HAS_STRTOUL	/**/

/* HAS_STRXFRM:
 *	This symbol, if defined, indicates that the strxfrm() routine is
 *	available to transform strings.
 */
#define HAS_STRXFRM	/**/

/* HAS_SYMLINK:
 *	This symbol, if defined, indicates that the symlink routine is available
 *	to create symbolic links.
 */
/*#define HAS_SYMLINK	/**/

/* HAS_SYSCALL:
 *	This symbol, if defined, indicates that the syscall routine is
 *	available to call arbitrary system calls. If undefined, that's tough.
 */
/*#define HAS_SYSCALL	/**/

/* HAS_SYSCONF:
 *	This symbol, if defined, indicates that sysconf() is available
 *	to determine system related limits and options.
 */
/*#define HAS_SYSCONF	/**/

/* HAS_SYSTEM:
 *	This symbol, if defined, indicates that the system routine is
 *	available to issue a shell command.
 */
#define HAS_SYSTEM	/**/

/* HAS_TCGETPGRP:
 *	This symbol, if defined, indicates that the tcgetpgrp routine is
 *	available to get foreground process group ID.
 */
/*#define HAS_TCGETPGRP		/**/

/* HAS_TCSETPGRP:
 *	This symbol, if defined, indicates that the tcsetpgrp routine is
 *	available to set foreground process group ID.
 */
/*#define HAS_TCSETPGRP		/**/

/* HAS_TRUNCATE:
 *	This symbol, if defined, indicates that the truncate routine is
 *	available to truncate files.
 */
/*#define HAS_TRUNCATE	/**/

/* HAS_TZNAME:
 *	This symbol, if defined, indicates that the tzname[] array is
 *	available to access timezone names.
 */
#define HAS_TZNAME		/**/

/* HAS_UMASK:
 *	This symbol, if defined, indicates that the umask routine is
 *	available to set and get the value of the file creation mask.
 */
#define HAS_UMASK		/**/

/* HASVOLATILE:
 *	This symbol, if defined, indicates that this C compiler knows about
 *	the volatile declaration.
 */
#define	HASVOLATILE	/**/
#ifndef HASVOLATILE
#define volatile
#endif

/* HAS_WAIT4:
 *	This symbol, if defined, indicates that wait4() exists.
 */
/*#define HAS_WAIT4	/**/

/* HAS_WAITPID:
 *	This symbol, if defined, indicates that the waitpid routine is
 *	available to wait for child process.
 */
#define HAS_WAITPID	/**/

/* HAS_WCSTOMBS:
 *	This symbol, if defined, indicates that the wcstombs routine is
 *	available to convert wide character strings to multibyte strings.
 */
#define HAS_WCSTOMBS	/**/

/* HAS_WCTOMB:
 *	This symbol, if defined, indicates that the wctomb routine is available
 *	to covert a wide character to a multibyte.
 */
#define HAS_WCTOMB		/**/

/* I_ARPA_INET:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <arpa/inet.h> to get inet_addr and friends declarations.
 */
#define	I_ARPA_INET		/**/

/* I_DBM:
 *	This symbol, if defined, indicates that <dbm.h> exists and should
 *	be included.
 */
/* I_RPCSVC_DBM:
 *	This symbol, if defined, indicates that <rpcsvc/dbm.h> exists and
 *	should be included.
 */
/*#define I_DBM	/**/
#define I_RPCSVC_DBM	/**/

/* I_DIRENT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <dirent.h>. Using this symbol also triggers the definition
 *	of the Direntry_t define which ends up being 'struct dirent' or
 *	'struct direct' depending on the availability of <dirent.h>.
 */
/* DIRNAMLEN:
 *	This symbol, if defined, indicates to the C program that the length
 *	of directory entry names is provided by a d_namlen field.  Otherwise
 *	you need to do strlen() on the d_name field.
 */
/* Direntry_t:
 *	This symbol is set to 'struct direct' or 'struct dirent' depending on
 *	whether dirent is available or not. You should use this pseudo type to
 *	portably declare your directory entries.
 */
#define I_DIRENT		/**/
#define DIRNAMLEN	/**/
#define Direntry_t struct direct

/* I_DLFCN:
 *	This symbol, if defined, indicates that <dlfcn.h> exists and should
 *	be included.
 */
#define I_DLFCN		/**/

/* I_FCNTL:
 *	This manifest constant tells the C program to include <fcntl.h>.
 */
#define I_FCNTL	/**/

/* I_FLOAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <float.h> to get definition of symbols like DBL_MAX or
 *	DBL_MIN, i.e. machine dependent floating point values.
 */
#define I_FLOAT		/**/

/* I_LIMITS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <limits.h> to get definition of symbols like WORD_BIT or
 *	LONG_MAX, i.e. machine dependant limitations.
 */
#define I_LIMITS		/**/

/* I_LOCALE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <locale.h>.
 */
#define	I_LOCALE		/**/

/* I_MATH:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <math.h>.
 */
#define I_MATH		/**/

/* I_MEMORY:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <memory.h>.
 */
/*#define I_MEMORY		/**/

/* I_NDBM:
 *	This symbol, if defined, indicates that <ndbm.h> exists and should
 *	be included.
 */
/*#define I_NDBM	/**/

/* I_NET_ERRNO:
 *	This symbol, if defined, indicates that <net/errno.h> exists and 
 *	should be included.
 */
/*#define I_NET_ERRNO		/**/

/* I_NETINET_IN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <netinet/in.h>. Otherwise, you may try <sys/in.h>.
 */
/*#define I_NETINET_IN	/**/

/* I_SFIO:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sfio.h>.
 */
/*#define	I_SFIO		/**/

/* I_STDDEF:
 *	This symbol, if defined, indicates that <stddef.h> exists and should
 *	be included.
 */
#define I_STDDEF	/**/

/* I_STDLIB:
 *	This symbol, if defined, indicates that <stdlib.h> exists and should
 *	be included.
 */
#define I_STDLIB		/**/

/* I_STRING:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <string.h> (USG systems) instead of <strings.h> (BSD systems).
 */
#define I_STRING		/**/

/* I_SYS_DIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/dir.h>.
 */
/*#define I_SYS_DIR		/**/

/* I_SYS_FILE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/file.h> to get definition of R_OK and friends.
 */
/*#define I_SYS_FILE		/**/

/* I_SYS_IOCTL:
 *	This symbol, if defined, indicates that <sys/ioctl.h> exists and should
 *	be included. Otherwise, include <sgtty.h> or <termio.h>.
 */
/*#define	I_SYS_IOCTL		/**/

/* I_SYS_NDIR:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/ndir.h>.
 */
/*#define I_SYS_NDIR	/**/

/* I_SYS_PARAM:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/param.h>.
 */
/*#define I_SYS_PARAM		/**/

/* I_SYS_RESOURCE:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/resource.h>.
 */
/*#define I_SYS_RESOURCE		/**/

/* I_SYS_SELECT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/select.h> in order to get definition of struct timeval.
 */
/*#define I_SYS_SELECT	/**/

/* I_SYS_STAT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/stat.h>.
 */
#define	I_SYS_STAT		/**/

/* I_SYS_TIMES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/times.h>.
 */
/*#define	I_SYS_TIMES		/**/

/* I_SYS_TYPES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/types.h>.
 */
#define	I_SYS_TYPES		/**/

/* I_SYS_UN:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/un.h> to get UNIX domain socket definitions.
 */
/*#define I_SYS_UN		/**/

/* I_SYS_WAIT:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/wait.h>.
 */
/*#define I_SYS_WAIT	/**/

/* I_TERMIO:
 *	This symbol, if defined, indicates that the program should include
 *	<termio.h> rather than <sgtty.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/* I_TERMIOS:
 *	This symbol, if defined, indicates that the program should include
 *	the POSIX termios.h rather than sgtty.h or termio.h.
 *	There are also differences in the ioctl() calls that depend on the
 *	value of this symbol.
 */
/* I_SGTTY:
 *	This symbol, if defined, indicates that the program should include
 *	<sgtty.h> rather than <termio.h>.  There are also differences in
 *	the ioctl() calls that depend on the value of this symbol.
 */
/*#define I_TERMIO		/**/
/*#define I_TERMIOS		/**/
/*#define I_SGTTY		/**/

/* I_UNISTD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <unistd.h>.
 */
/*#define I_UNISTD		/**/

/* I_UTIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <utime.h>.
 */
#define I_UTIME		/**/

/* I_VALUES:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <values.h> to get definition of symbols like MINFLOAT or
 *	MAXLONG, i.e. machine dependant limitations.  Probably, you
 *	should use <limits.h> instead, if it is available.
 */
/*#define I_VALUES		/**/

/* I_STDARG:
 *	This symbol, if defined, indicates that <stdarg.h> exists and should
 *	be included.
 */
/* I_VARARGS:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <varargs.h>.
 */
#define I_STDARG		/**/
/*#define I_VARARGS	/**/

/* I_VFORK:
 *	This symbol, if defined, indicates to the C program that it should
 *	include vfork.h.
 */
/*#define I_VFORK	/**/

/* CAN_PROTOTYPE:
 *	If defined, this macro indicates that the C compiler can handle
 *	function prototypes.
 */
/* _:
 *	This macro is used to declare function parameters for folks who want
 *	to make declarations with prototypes using a different style than
 *	the above macros.  Use double parentheses.  For example:
 *
 *		int main _((int argc, char *argv[]));
 */
#define	CAN_PROTOTYPE	/**/
#ifdef CAN_PROTOTYPE
#define	_(args) args
#else
#define	_(args) ()
#endif

/* SH_PATH:
 *	This symbol contains the full pathname to the shell used on this
 *	on this system to execute Bourne shell scripts.  Usually, this will be
 *	/bin/sh, though it's possible that some systems will have /bin/ksh,
 *	/bin/pdksh, /bin/ash, /bin/bash, or even something such as
 *	D:/bin/sh.exe.
 */
#define SH_PATH "cmd /x /c"  /**/

/* CROSSCOMPILE:
 *	This symbol, if defined, signifies that we our
 *	build process is a cross-compilation.
 */
/*#define CROSSCOMPILE		/**/

/* INTSIZE:
 *	This symbol contains the value of sizeof(int) so that the C
 *	preprocessor can make decisions based on it.
 */
/* LONGSIZE:
 *	This symbol contains the value of sizeof(long) so that the C
 *	preprocessor can make decisions based on it.
 */
/* SHORTSIZE:
 *	This symbol contains the value of sizeof(short) so that the C
 *	preprocessor can make decisions based on it.
 */
#define INTSIZE 4		/**/
#define LONGSIZE 4		/**/
#define SHORTSIZE 2		/**/

/* MULTIARCH:
 *	This symbol, if defined, signifies that the build
 *	process will produce some binary files that are going to be
 *	used in a cross-platform environment.  This is the case for
 *	example with the NeXT "fat" binaries that contain executables
 *	for several CPUs.
 */
/*#define MULTIARCH		/**/

/* HAS_QUAD:
 *	This symbol, if defined, tells that there's a 64-bit integer type,
 *	Quad_t, and its unsigned counterpar, Uquad_t. QUADKIND will be one
 *	of QUAD_IS_INT, QUAD_IS_LONG, QUAD_IS_LONG_LONG, or QUAD_IS_INT64_T.
 */
/*#define HAS_QUAD	/**/
#ifdef HAS_QUAD
#   define Quad_t __int64	/**/
#   define Uquad_t unsigned __int64	/**/
#   define QUADKIND 5	/**/
#   define QUAD_IS_INT	1
#   define QUAD_IS_LONG	2
#   define QUAD_IS_LONG_LONG	3
#   define QUAD_IS_INT64_T	4
#endif

/* HAS_ACCESSX:
 *	This symbol, if defined, indicates that the accessx routine is
 *	available to do extended access checks.
 */
/*#define HAS_ACCESSX		/**/

/* HAS_EACCESS:
 *	This symbol, if defined, indicates that the eaccess routine is
 *	available to do extended access checks.
 */
/*#define HAS_EACCESS		/**/

/* I_SYS_ACCESS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/access.h>.
 */
/*#define   I_SYS_ACCESS                /**/

/* I_SYS_SECURITY:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <sys/security.h>.
 */
/*#define   I_SYS_SECURITY	/**/

/* OSNAME:
 *	This symbol contains the name of the operating system, as determined
 *	by Configure.  You shouldn't rely on it too much; the specific
 *	feature tests from Configure are generally more reliable.
 */
#define OSNAME "MSWin32"		/**/

/* MEM_ALIGNBYTES:
 *	This symbol contains the number of bytes required to align a
 *	double, or a long double when applicable. Usual values are 2,
 *	4 and 8. The default is eight, for safety.
 */
#if defined(CROSSCOMPILE) || defined(MULTIARCH)
#  define MEM_ALIGNBYTES 8
#else
#define MEM_ALIGNBYTES 8
#endif

/* ARCHLIB:
 *	This variable, if defined, holds the name of the directory in
 *	which the user wants to put architecture-dependent public
 *	library files for perl5.  It is most often a local directory
 *	such as /usr/local/lib.  Programs using this variable must be
 *	prepared to deal with filename expansion.  If ARCHLIB is the
 *	same as PRIVLIB, it is not defined, since presumably the
 *	program already searches PRIVLIB.
 */
/* ARCHLIB_EXP:
 *	This symbol contains the ~name expanded version of ARCHLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define ARCHLIB "C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\lib"		/**/
/*#define ARCHLIB_EXP ""	/**/

/* ARCHNAME:
 *	This symbol holds a string representing the architecture name.
 *	It may be used to construct an architecture-dependant pathname
 *	where library files may be held under a private library, for
 *	instance.
 */
#define ARCHNAME "MSWin32-x86-multi-thread"		/**/

/* HAS_ATOLF:
 *	This symbol, if defined, indicates that the atolf routine is
 *	available to convert strings into long doubles.
 */
/*#define HAS_ATOLF		/**/

/* HAS_ATOLL:
 *	This symbol, if defined, indicates that the atoll routine is
 *	available to convert strings into long longs.
 */
/*#define HAS_ATOLL		/**/

/* BIN:
 *	This symbol holds the path of the bin directory where the package will
 *	be installed. Program must be prepared to deal with ~name substitution.
 */
/* BIN_EXP:
 *	This symbol is the filename expanded version of the BIN symbol, for
 *	programs that do not want to deal with that at run-time.
 */
#define BIN "C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\bin"	/**/
#define BIN_EXP "C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\bin"	/**/

/* PERL_BINCOMPAT_5005:
 *	This symbol, if defined, indicates that this version of Perl should be
 *	binary-compatible with Perl 5.005.  This is impossible for builds
 *	that use features like threads and multiplicity it is always undef
 *	for those versions.
 */
/*#define PERL_BINCOMPAT_5005			/**/

/* BYTEORDER:
 *	This symbol holds the hexadecimal constant defined in byteorder,
 *	i.e. 0x1234 or 0x4321, etc...
 *	If the compiler supports cross-compiling or multiple-architecture
 *	binaries (eg. on NeXT systems), use compiler-defined macros to
 *	determine the byte order.
 *	On NeXT 3.2 (and greater), you can build "Fat" Multiple Architecture
 *	Binaries (MAB) on either big endian or little endian machines.
 *	The endian-ness is available at compile-time.  This only matters
 *	for perl, where the config.h can be generated and installed on 
 *	one system, and used by a different architecture to build an
 *	extension.  Older versions of NeXT that might not have
 *	defined either *_ENDIAN__ were all on Motorola 680x0 series,
 *	so the default case (for NeXT) is big endian to catch them. 
 *	This might matter for NeXT 3.0.
 */
#if defined(CROSSCOMPILE) || defined(MULTIARCH)
#  ifdef __LITTLE_ENDIAN__
#    if LONGSIZE == 4
#      define BYTEORDER 0x1234
#    else
#      if LONGSIZE == 8
#        define BYTEORDER 0x12345678
#      endif
#    endif
#  else
#    ifdef __BIG_ENDIAN__
#      if LONGSIZE == 4
#        define BYTEORDER 0x4321
#      else
#        if LONGSIZE == 8
#          define BYTEORDER 0x87654321
#        endif
#      endif
#    endif
#  endif
#  if !defined(BYTEORDER) && (defined(NeXT) || defined(__NeXT__))
#    define BYTEORDER 0x4321
#  endif
#else
#define BYTEORDER 0x1234	/* large digits for MSB */
#endif /* NeXT */

/* CAT2:
 *	This macro catenates 2 tokens together.
 */
/* STRINGIFY:
 *	This macro surrounds its token with double quotes.
 */
#if 42 == 1
#define CAT2(a,b)	a/**/b
#define STRINGIFY(a)	"a"
		/* If you can get stringification with catify, tell me how! */
#endif
#if 42 == 42
#define PeRl_CaTiFy(a, b)	a ## b	
#define PeRl_StGiFy(a)	#a
/* the additional level of indirection enables these macros to be
 * used as arguments to other macros.  See K&R 2nd ed., page 231. */
#define CAT2(a,b)	PeRl_CaTiFy(a,b)
#define StGiFy(a)	PeRl_StGiFy(a)
#define STRINGIFY(a)	PeRl_StGiFy(a)
#endif
#if 42 != 1 && 42 != 42
#   include "Bletch: How does this C preprocessor catenate tokens?"
#endif

/* CPPSTDIN:
 *	This symbol contains the first part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.	 Typical value of "cc -E" or "/lib/cpp", but it can also
 *	call a wrapper. See CPPRUN.
 */
/* CPPMINUS:
 *	This symbol contains the second part of the string which will invoke
 *	the C preprocessor on the standard input and produce to standard
 *	output.  This symbol will have the value "-" if CPPSTDIN needs a minus
 *	to specify standard input, otherwise the value is "".
 */
/* CPPRUN:
 *	This symbol contains the string which will invoke a C preprocessor on
 *	the standard input and produce to standard output. It needs to end
 *	with CPPLAST, after all other preprocessor flags have been specified.
 *	The main difference with CPPSTDIN is that this program will never be a
 *	pointer to a shell wrapper, i.e. it will be empty if no preprocessor is
 *	available directly to the user. Note that it may well be different from
 *	the preprocessor used to compile the C program.
 */
/* CPPLAST:
 *	This symbol is intended to be used along with CPPRUN in the same manner
 *	symbol CPPMINUS is used with CPPSTDIN. It contains either "-" or "".
 */
#define CPPSTDIN "cl -nologo -E"
#define CPPMINUS ""
#define CPPRUN "cl -nologo -E"
#define CPPLAST ""

/* HAS_ACCESS:
 *	This manifest constant lets the C program know that the access()
 *	system call is available to check for accessibility using real UID/GID.
 *	(always present on UNIX.)
 */
#define HAS_ACCESS		/**/

/* CASTI32:
 *	This symbol is defined if the C compiler can cast negative
 *	or large floating point numbers to 32-bit ints.
 */
/*#define	CASTI32		/**/

/* CASTNEGFLOAT:
 *	This symbol is defined if the C compiler can cast negative
 *	numbers to unsigned longs, ints and shorts.
 */
/* CASTFLAGS:
 *	This symbol contains flags that say what difficulties the compiler
 *	has casting odd floating values to unsigned long:
 *		0 = ok
 *		1 = couldn't cast < 0
 *		2 = couldn't cast >= 0x80000000
 *		4 = couldn't cast in argument expression list
 */
#define	CASTNEGFLOAT		/**/
#define CASTFLAGS 0		/**/

/* VOID_CLOSEDIR:
 *	This symbol, if defined, indicates that the closedir() routine
 *	does not return a value.
 */
/*#define VOID_CLOSEDIR		/**/

/* HAS_CSH:
 *	This symbol, if defined, indicates that the C-shell exists.
 */
/* CSH:
 *	This symbol, if defined, contains the full pathname of csh.
 */
/*#define HAS_CSH		/**/
#ifdef HAS_CSH
#define CSH ""	/**/
#endif

/* DLSYM_NEEDS_UNDERSCORE:
 *	This symbol, if defined, indicates that we need to prepend an
 *	underscore to the symbol name before calling dlsym().  This only
 *	makes sense if you *have* dlsym, which we will presume is the
 *	case if you're using dl_dlopen.xs.
 */
/*#define 	DLSYM_NEEDS_UNDERSCORE 	/**/

/* HAS_DRAND48_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the drand48() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern double drand48 _((void));
 */
/*#define	HAS_DRAND48_PROTO	/**/

/* HAS_ENDGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the group database.
 */
/*#define HAS_ENDGRENT		/**/

/* HAS_ENDHOSTENT:
 *	This symbol, if defined, indicates that the endhostent() routine is
 *	available to close whatever was being used for host queries.
 */
/*#define HAS_ENDHOSTENT		/**/

/* HAS_ENDNETENT:
 *	This symbol, if defined, indicates that the endnetent() routine is
 *	available to close whatever was being used for network queries.
 */
/*#define HAS_ENDNETENT		/**/

/* HAS_ENDPROTOENT:
 *	This symbol, if defined, indicates that the endprotoent() routine is
 *	available to close whatever was being used for protocol queries.
 */
/*#define HAS_ENDPROTOENT		/**/

/* HAS_ENDPWENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for finalizing sequential access of the passwd database.
 */
/*#define HAS_ENDPWENT		/**/

/* HAS_ENDSERVENT:
 *	This symbol, if defined, indicates that the endservent() routine is
 *	available to close whatever was being used for service queries.
 */
/*#define HAS_ENDSERVENT		/**/

/* HAS_FD_SET:
 *	This symbol, when defined, indicates presence of the fd_set typedef
 *	in <sys/types.h>
 */
#define HAS_FD_SET	/**/

/* FLEXFILENAMES:
 *	This symbol, if defined, indicates that the system supports filenames
 *	longer than 14 characters.
 */
#define	FLEXFILENAMES		/**/

/* HAS_FPOS64_T:
 *	This symbol will be defined if the C compiler supports fpos64_t.
 */
/*#define	HAS_FPOS64_T    	/**/

/* HAS_FREXPL:
 *	This symbol, if defined, indicates that the frexpl routine is
 *	available to break a long double floating-point number into
 *	a normalized fraction and an integral power of 2.
 */
/*#define HAS_FREXPL		/**/

/* HAS_STRUCT_FS_DATA:
 *	This symbol, if defined, indicates that the struct fs_data
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_FS_DATA	/**/

/* HAS_FSEEKO:
 *	This symbol, if defined, indicates that the fseeko routine is
 *	available to fseek beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FSEEKO		/**/

/* HAS_FSTATFS:
 *	This symbol, if defined, indicates that the fstatfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATFS		/**/

/* HAS_FTELLO:
 *	This symbol, if defined, indicates that the ftello routine is
 *	available to ftell beyond 32 bits (useful for ILP32 hosts).
 */
/*#define HAS_FTELLO		/**/

/* Gconvert:
 *	This preprocessor macro is defined to convert a floating point
 *	number to a string without a trailing decimal point.  This
 *	emulates the behavior of sprintf("%g"), but is sometimes much more
 *	efficient.  If gconvert() is not available, but gcvt() drops the
 *	trailing decimal point, then gcvt() is used.  If all else fails,
 *	a macro using sprintf("%g") is used. Arguments for the Gconvert
 *	macro are: value, number of digits, whether trailing zeros should
 *	be retained, and the output buffer.
 *	Possible values are:
 *		d_Gconvert='gconvert((x),(n),(t),(b))'
 *		d_Gconvert='gcvt((x),(n),(b))'
 *		d_Gconvert='sprintf((b),"%.*g",(n),(x))'
 *	The last two assume trailing zeros should not be kept.
 */
#define Gconvert(x,n,t,b) sprintf((b),"%.*g",(n),(x))

/* HAS_GETCWD:
 *	This symbol, if defined, indicates that the getcwd routine is
 *	available to get the current working directory.
 */
/*#define HAS_GETCWD		/**/

/* HAS_GETESPWNAM:
 *	This symbol, if defined, indicates that the getespwnam system call is
 *	available to retrieve enchanced (shadow) password entries by name.
 */
/*#define HAS_GETESPWNAM		/**/

/* HAS_GETFSSTAT:
 *	This symbol, if defined, indicates that the getfsstat routine is
 *	available to stat filesystems in bulk.
 */
/*#define HAS_GETFSSTAT		/**/

/* HAS_GETGRENT:
 *	This symbol, if defined, indicates that the getgrent routine is
 *	available for sequential access of the group database.
 */
/*#define HAS_GETGRENT		/**/

/* HAS_GETHOSTBYADDR:
 *	This symbol, if defined, indicates that the gethostbyaddr() routine is
 *	available to look up hosts by their IP addresses.
 */
#define HAS_GETHOSTBYADDR		/**/

/* HAS_GETHOSTBYNAME:
 *	This symbol, if defined, indicates that the gethostbyname() routine is
 *	available to look up host names in some data base or other.
 */
#define HAS_GETHOSTBYNAME		/**/

/* HAS_GETHOSTENT:
 *	This symbol, if defined, indicates that the gethostent() routine is
 *	available to look up host names in some data base or another.
 */
/*#define HAS_GETHOSTENT		/**/

/* HAS_GETHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	gethostname() routine to derive the host name.  See also HAS_UNAME
 *	and PHOSTNAME.
 */
/* HAS_UNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	uname() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and PHOSTNAME.
 */
/* PHOSTNAME:
 *	This symbol, if defined, indicates the command to feed to the
 *	popen() routine to derive the host name.  See also HAS_GETHOSTNAME
 *	and HAS_UNAME.	Note that the command uses a fully qualified path,
 *	so that it is safe even if used by a process with super-user
 *	privileges.
 */
/* HAS_PHOSTNAME:
 *	This symbol, if defined, indicates that the C program may use the
 *	contents of PHOSTNAME as a command to feed to the popen() routine
 *	to derive the host name.
 */
#define HAS_GETHOSTNAME	/**/
#define HAS_UNAME		/**/
/*#define HAS_PHOSTNAME	/**/
#ifdef HAS_PHOSTNAME
#define PHOSTNAME ""	/* How to get the host name */
#endif

/* HAS_GETHOST_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for gethostent(), gethostbyname(), and
 *	gethostbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETHOST_PROTOS	/**/

/* HAS_GETMNT:
 *	This symbol, if defined, indicates that the getmnt routine is
 *	available to get filesystem mount info by filename.
 */
/*#define HAS_GETMNT		/**/

/* HAS_GETMNTENT:
 *	This symbol, if defined, indicates that the getmntent routine is
 *	available to iterate through mounted file systems to get their info.
 */
/*#define HAS_GETMNTENT		/**/

/* HAS_GETNETBYADDR:
 *	This symbol, if defined, indicates that the getnetbyaddr() routine is
 *	available to look up networks by their IP addresses.
 */
/*#define HAS_GETNETBYADDR		/**/

/* HAS_GETNETBYNAME:
 *	This symbol, if defined, indicates that the getnetbyname() routine is
 *	available to look up networks by their names.
 */
/*#define HAS_GETNETBYNAME		/**/

/* HAS_GETNETENT:
 *	This symbol, if defined, indicates that the getnetent() routine is
 *	available to look up network names in some data base or another.
 */
/*#define HAS_GETNETENT		/**/

/* HAS_GETNET_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getnetent(), getnetbyname(), and
 *	getnetbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
/*#define	HAS_GETNET_PROTOS	/**/

/* HAS_GETPAGESIZE:
 *	This symbol, if defined, indicates that the getpagesize system call
 *	is available to get system page size, which is the granularity of
 *	many memory management calls.
 */
/*#define HAS_GETPAGESIZE		/**/

/* HAS_GETPROTOENT:
 *	This symbol, if defined, indicates that the getprotoent() routine is
 *	available to look up protocols in some data base or another.
 */
/*#define HAS_GETPROTOENT		/**/

/* HAS_GETPROTOBYNAME:
 *	This symbol, if defined, indicates that the getprotobyname()
 *	routine is available to look up protocols by their name.
 */
/* HAS_GETPROTOBYNUMBER:
 *	This symbol, if defined, indicates that the getprotobynumber()
 *	routine is available to look up protocols by their number.
 */
#define HAS_GETPROTOBYNAME		/**/
#define HAS_GETPROTOBYNUMBER		/**/

/* HAS_GETPROTO_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getprotoent(), getprotobyname(), and
 *	getprotobyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETPROTO_PROTOS	/**/

/* HAS_GETPRPWNAM:
 *	This symbol, if defined, indicates that the getprpwnam system call is
 *	available to retrieve protected (shadow) password entries by name.
 */
/*#define HAS_GETPRPWNAM		/**/

/* HAS_GETPWENT:
 *	This symbol, if defined, indicates that the getpwent routine is
 *	available for sequential access of the passwd database.
 *	If this is not available, the older getpw() function may be available.
 */
/*#define HAS_GETPWENT		/**/

/* HAS_GETSERVENT:
 *	This symbol, if defined, indicates that the getservent() routine is
 *	available to look up network services in some data base or another.
 */
/*#define HAS_GETSERVENT		/**/

/* HAS_GETSERV_PROTOS:
 *	This symbol, if defined, indicates that <netdb.h> includes
 *	prototypes for getservent(), getservbyname(), and
 *	getservbyaddr().  Otherwise, it is up to the program to guess
 *	them.  See netdbtype.U for probing for various Netdb_xxx_t types.
 */
#define	HAS_GETSERV_PROTOS	/**/

/* HAS_GETSPNAM:
 *	This symbol, if defined, indicates that the getspnam system call is
 *	available to retrieve SysV shadow password entries by name.
 */
/*#define HAS_GETSPNAM		/**/

/* HAS_GETSERVBYNAME:
 *	This symbol, if defined, indicates that the getservbyname()
 *	routine is available to look up services by their name.
 */
/* HAS_GETSERVBYPORT:
 *	This symbol, if defined, indicates that the getservbyport()
 *	routine is available to look up services by their port.
 */
#define HAS_GETSERVBYNAME		/**/
#define HAS_GETSERVBYPORT		/**/

/* HAS_GNULIBC:
 *	This symbol, if defined, indicates to the C program that 
 *	the GNU C library is being used.
 */
/*#define HAS_GNULIBC  	/**/
#if defined(HAS_GNULIBC) && !defined(_GNU_SOURCE)
#   define _GNU_SOURCE
#endif
/* HAS_HASMNTOPT:
 *	This symbol, if defined, indicates that the hasmntopt routine is
 *	available to query the mount options of file systems.
 */
/*#define HAS_HASMNTOPT		/**/

/* HAS_HTONL:
 *	This symbol, if defined, indicates that the htonl() routine (and
 *	friends htons() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_HTONS:
 *	This symbol, if defined, indicates that the htons() routine (and
 *	friends htonl() ntohl() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHL:
 *	This symbol, if defined, indicates that the ntohl() routine (and
 *	friends htonl() htons() ntohs()) are available to do network
 *	order byte swapping.
 */
/* HAS_NTOHS:
 *	This symbol, if defined, indicates that the ntohs() routine (and
 *	friends htonl() htons() ntohl()) are available to do network
 *	order byte swapping.
 */
#define HAS_HTONL		/**/
#define HAS_HTONS		/**/
#define HAS_NTOHL		/**/
#define HAS_NTOHS		/**/

/* HAS_ICONV:
 *	This symbol, if defined, indicates that the iconv routine is
 *	available to do character set conversions.
 */
/*#define HAS_ICONV		/**/

/* HAS_INT64_T:
 *     This symbol will defined if the C compiler supports int64_t.
 *     Usually the <inttypes.h> needs to be included, but sometimes
 *	<sys/types.h> is enough.
 */
/*#define     HAS_INT64_T               /**/

/* HAS_ISASCII:
 *	This manifest constant lets the C program know that isascii 
 *	is available.
 */
#define HAS_ISASCII		/**/

/* HAS_ISNAN:
 *	This symbol, if defined, indicates that the isnan routine is
 *	available to check whether a double is a NaN.
 */
#define HAS_ISNAN		/**/

/* HAS_ISNANL:
 *	This symbol, if defined, indicates that the isnanl routine is
 *	available to check whether a long double is a NaN.
 */
/*#define HAS_ISNANL		/**/

/* HAS_LCHOWN:
 *	This symbol, if defined, indicates that the lchown routine is
 *	available to operate on a symbolic link (instead of following the
 *	link).
 */
/*#define HAS_LCHOWN		/**/

/* HAS_LDBL_DIG:
 *	This symbol, if defined, indicates that this system's <float.h>
 *	or <limits.h> defines the symbol LDBL_DIG, which is the number
 *	of significant digits in a long double precision number. Unlike
 *	for DBL_DIG, there's no good guess for LDBL_DIG if it is undefined.
 */
#define HAS_LDBL_DIG 	/**/

/* HAS_LONG_DOUBLE:
 *	This symbol will be defined if the C compiler supports long
 *	doubles.
 */
/* LONG_DOUBLESIZE:
 *	This symbol contains the size of a long double, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long doubles.
 */
#define HAS_LONG_DOUBLE		/**/
#ifdef HAS_LONG_DOUBLE
#define LONG_DOUBLESIZE 10		/**/
#endif

/* HAS_LONG_LONG:
 *	This symbol will be defined if the C compiler supports long long.
 */
/* LONGLONGSIZE:
 *	This symbol contains the size of a long long, so that the 
 *	C preprocessor can make decisions based on it.  It is only
 *	defined if the system supports long long.
 */
/*#define HAS_LONG_LONG		/**/
#ifdef HAS_LONG_LONG
#define LONGLONGSIZE 8		/**/
#endif

/* HAS_LSEEK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the lseek() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern off_t lseek(int, off_t, int);
 */
#define	HAS_LSEEK_PROTO	/**/

/* HAS_MADVISE:
 *	This symbol, if defined, indicates that the madvise system call is
 *	available to map a file into memory.
 */
/*#define HAS_MADVISE		/**/

/* HAS_MEMCHR:
 *	This symbol, if defined, indicates that the memchr routine is available
 *	to locate characters within a C string.
 */
#define HAS_MEMCHR	/**/

/* HAS_MKDTEMP:
 *	This symbol, if defined, indicates that the mkdtemp routine is
 *	available to exclusively create a uniquely named temporary directory.
 */
/*#define HAS_MKDTEMP		/**/

/* HAS_MKSTEMP:
 *	This symbol, if defined, indicates that the mkstemp routine is
 *	available to exclusively create and open a uniquely named
 *	temporary file.
 */
/*#define HAS_MKSTEMP		/**/

/* HAS_MKSTEMPS:
 *	This symbol, if defined, indicates that the mkstemps routine is
 *	available to excluslvely create and open a uniquely named
 *	(with a suffix) temporary file.
 */
/*#define HAS_MKSTEMPS		/**/

/* HAS_MMAP:
 *	This symbol, if defined, indicates that the mmap system call is
 *	available to map a file into memory.
 */
/* Mmap_t:
 *	This symbol holds the return type of the mmap() system call
 *	(and simultaneously the type of the first argument).
 *	Usually set to 'void *' or 'cadd_t'.
 */
/*#define HAS_MMAP		/**/
#define Mmap_t void *	/**/

/* HAS_MODFL:
 *	This symbol, if defined, indicates that the modfl routine is
 *	available to split a long double x into a fractional part f and
 *	an integer part i such that |f| < 1.0 and (f + i) = x.
 */
/*#define HAS_MODFL		/**/

/* HAS_MPROTECT:
 *	This symbol, if defined, indicates that the mprotect system call is
 *	available to modify the access protection of a memory mapped file.
 */
/*#define HAS_MPROTECT		/**/

/* HAS_MSG:
 *	This symbol, if defined, indicates that the entire msg*(2) library is
 *	supported (IPC mechanism based on message queues).
 */
/*#define HAS_MSG		/**/

/* HAS_OFF64_T:
 *	This symbol will be defined if the C compiler supports off64_t.
 */
/*#define	HAS_OFF64_T    		/**/

/* HAS_OPEN3:
 *	This manifest constant lets the C program know that the three
 *	argument form of open(2) is available.
 */
/*#define HAS_OPEN3		/**/

/* OLD_PTHREAD_CREATE_JOINABLE:
 *	This symbol, if defined, indicates how to create pthread
 *	in joinable (aka undetached) state.  NOTE: not defined
 *	if pthread.h already has defined PTHREAD_CREATE_JOINABLE
 *	(the new version of the constant).
 *	If defined, known values are PTHREAD_CREATE_UNDETACHED
 *	and __UNDETACHED.
 */
/*#define OLD_PTHREAD_CREATE_JOINABLE  /**/

/* HAS_PTHREAD_YIELD:
 *	This symbol, if defined, indicates that the pthread_yield 
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/* SCHED_YIELD:
 *	This symbol defines the way to yield the execution of
 *	the current thread.  Known ways are sched_yield,
 *	pthread_yield, and pthread_yield with NULL.
 */
/* HAS_SCHED_YIELD:
 *	This symbol, if defined, indicates that the sched_yield
 *	routine is available to yield the execution of the current
 *	thread.	 sched_yield is preferable to pthread_yield.
 */
/*#define HAS_PTHREAD_YIELD	/**/
#define SCHED_YIELD		/**/
/*#define HAS_SCHED_YIELD	/**/

/* HAS_SAFE_BCOPY:
 *	This symbol, if defined, indicates that the bcopy routine is available
 *	to copy potentially overlapping memory blocks. Otherwise you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_BCOPY	/**/

/* HAS_SAFE_MEMCPY:
 *	This symbol, if defined, indicates that the memcpy routine is available
 *	to copy potentially overlapping memory blocks. Otherwise you should
 *	probably use memmove() or memcpy(). If neither is defined, roll your
 *	own version.
 */
/*#define HAS_SAFE_MEMCPY	/**/

/* HAS_SANE_MEMCMP:
 *	This symbol, if defined, indicates that the memcmp routine is available
 *	and can be used to compare relative magnitudes of chars with their high
 *	bits set.  If it is not defined, roll your own version.
 */
#define HAS_SANE_MEMCMP	/**/

/* HAS_SEM:
 *	This symbol, if defined, indicates that the entire sem*(2) library is
 *	supported.
 */
/*#define HAS_SEM		/**/

/* HAS_SETGRENT:
 *	This symbol, if defined, indicates that the setgrent routine is
 *	available for initializing sequential access of the group database.
 */
/*#define HAS_SETGRENT		/**/

/* HAS_SETGROUPS:
 *	This symbol, if defined, indicates that the setgroups() routine is
 *	available to set the list of process groups.  If unavailable, multiple
 *	groups are probably not supported.
 */
/*#define HAS_SETGROUPS		/**/

/* HAS_SETHOSTENT:
 *	This symbol, if defined, indicates that the sethostent() routine is
 *	available.
 */
/*#define HAS_SETHOSTENT		/**/

/* HAS_SETNETENT:
 *	This symbol, if defined, indicates that the setnetent() routine is
 *	available.
 */
/*#define HAS_SETNETENT		/**/

/* HAS_SETPROTOENT:
 *	This symbol, if defined, indicates that the setprotoent() routine is
 *	available.
 */
/*#define HAS_SETPROTOENT		/**/

/* HAS_SETPROCTITLE:
 *	This symbol, if defined, indicates that the setproctitle routine is
 *	available to set process title.
 */
/*#define HAS_SETPROCTITLE		/**/

/* HAS_SETPWENT:
 *	This symbol, if defined, indicates that the setpwent routine is
 *	available for initializing sequential access of the passwd database.
 */
/*#define HAS_SETPWENT		/**/

/* HAS_SETSERVENT:
 *	This symbol, if defined, indicates that the setservent() routine is
 *	available.
 */
/*#define HAS_SETSERVENT		/**/

/* HAS_SETVBUF:
 *	This symbol, if defined, indicates that the setvbuf routine is
 *	available to change buffering on an open stdio stream.
 *	to a line-buffered mode.
 */
#define HAS_SETVBUF		/**/

/* USE_SFIO:
 *	This symbol, if defined, indicates that sfio should
 *	be used.
 */
/*#define	USE_SFIO		/**/

/* HAS_SHM:
 *	This symbol, if defined, indicates that the entire shm*(2) library is
 *	supported.
 */
/*#define HAS_SHM		/**/

/* HAS_SIGACTION:
 *	This symbol, if defined, indicates that Vr4's sigaction() routine
 *	is available.
 */
/*#define HAS_SIGACTION	/**/

/* HAS_SIGSETJMP:
 *	This variable indicates to the C program that the sigsetjmp()
 *	routine is available to save the calling process's registers
 *	and stack environment for later use by siglongjmp(), and
 *	to optionally save the process's signal mask.  See
 *	Sigjmp_buf, Sigsetjmp, and Siglongjmp.
 */
/* Sigjmp_buf:
 *	This is the buffer type to be used with Sigsetjmp and Siglongjmp.
 */
/* Sigsetjmp:
 *	This macro is used in the same way as sigsetjmp(), but will invoke
 *	traditional setjmp() if sigsetjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/* Siglongjmp:
 *	This macro is used in the same way as siglongjmp(), but will invoke
 *	traditional longjmp() if siglongjmp isn't available.
 *	See HAS_SIGSETJMP.
 */
/*#define HAS_SIGSETJMP	/**/
#ifdef HAS_SIGSETJMP
#define Sigjmp_buf sigjmp_buf
#define Sigsetjmp(buf,save_mask) sigsetjmp((buf),(save_mask))
#define Siglongjmp(buf,retval) siglongjmp((buf),(retval))
#else
#define Sigjmp_buf jmp_buf
#define Sigsetjmp(buf,save_mask) setjmp((buf))
#define Siglongjmp(buf,retval) longjmp((buf),(retval))
#endif

/* HAS_SOCKET:
 *	This symbol, if defined, indicates that the BSD socket interface is
 *	supported.
 */
/* HAS_SOCKETPAIR:
 *	This symbol, if defined, indicates that the BSD socketpair() call is
 *	supported.
 */
/* HAS_MSG_CTRUNC:
 *	This symbol, if defined, indicates that the MSG_CTRUNC is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_DONTROUTE:
 *	This symbol, if defined, indicates that the MSG_DONTROUTE is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_OOB:
 *	This symbol, if defined, indicates that the MSG_OOB is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PEEK:
 *	This symbol, if defined, indicates that the MSG_PEEK is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_MSG_PROXY:
 *	This symbol, if defined, indicates that the MSG_PROXY is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
/* HAS_SCM_RIGHTS:
 *	This symbol, if defined, indicates that the SCM_RIGHTS is supported.
 *	Checking just with #ifdef might not be enough because this symbol
 *	has been known to be an enum.
 */
#define	HAS_SOCKET		/**/
/*#define	HAS_SOCKETPAIR	/**/
/*#define	HAS_MSG_CTRUNC	/**/
/*#define	HAS_MSG_DONTROUTE	/**/
/*#define	HAS_MSG_OOB	/**/
/*#define	HAS_MSG_PEEK	/**/
/*#define	HAS_MSG_PROXY	/**/
/*#define	HAS_SCM_RIGHTS	/**/

/* HAS_SOCKS5_INIT:
 *	This symbol, if defined, indicates that the socks5_init routine is
 *	available to initialize SOCKS 5.
 */
/*#define HAS_SOCKS5_INIT		/**/

/* HAS_SQRTL:
 *	This symbol, if defined, indicates that the sqrtl routine is
 *	available to do long double square roots.
 */
/*#define HAS_SQRTL		/**/

/* USE_STAT_BLOCKS:
 *	This symbol is defined if this system has a stat structure declaring
 *	st_blksize and st_blocks.
 */
#ifndef USE_STAT_BLOCKS
/*#define USE_STAT_BLOCKS 	/**/
#endif

/* HAS_STRUCT_STATFS_F_FLAGS:
 *	This symbol, if defined, indicates that the struct statfs
 *	does have the f_flags member containing the mount flags of
 *	the filesystem containing the file.
 *	This kind of struct statfs is coming from <sys/mount.h> (BSD 4.3),
 *	not from <sys/statfs.h> (SYSV).  Older BSDs (like Ultrix) do not
 *	have statfs() and struct statfs, they have ustat() and getmnt()
 *	with struct ustat and struct fs_data.
 */
/*#define HAS_STRUCT_STATFS_F_FLAGS		/**/

/* HAS_STRUCT_STATFS:
 *	This symbol, if defined, indicates that the struct statfs
 *	to do statfs() is supported.
 */
/*#define HAS_STRUCT_STATFS	/**/

/* HAS_FSTATVFS:
 *	This symbol, if defined, indicates that the fstatvfs routine is
 *	available to stat filesystems by file descriptors.
 */
/*#define HAS_FSTATVFS		/**/

/* USE_STDIO_PTR:
 *	This symbol is defined if the _ptr and _cnt fields (or similar)
 *	of the stdio FILE structure can be used to access the stdio buffer
 *	for a file handle.  If this is defined, then the FILE_ptr(fp)
 *	and FILE_cnt(fp) macros will also be defined and should be used
 *	to access these fields.
 */
/* FILE_ptr:
 *	This macro is used to access the _ptr field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_PTR_LVALUE:
 *	This symbol is defined if the FILE_ptr macro can be used as an
 *	lvalue.
 */
/* FILE_cnt:
 *	This macro is used to access the _cnt field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_PTR is defined.
 */
/* STDIO_CNT_LVALUE:
 *	This symbol is defined if the FILE_cnt macro can be used as an
 *	lvalue.
 */
/* STDIO_PTR_LVAL_SETS_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n has the side effect of decreasing the
 *	value of File_cnt(fp) by n.
 */
/* STDIO_PTR_LVAL_NOCHANGE_CNT:
 *	This symbol is defined if using the FILE_ptr macro as an lvalue
 *	to increase the pointer by n leaves File_cnt(fp) unchanged.
 */
#define USE_STDIO_PTR 	/**/
#ifdef USE_STDIO_PTR
#define FILE_ptr(fp)	((fp)->_ptr)
#define STDIO_PTR_LVALUE 		/**/
#define FILE_cnt(fp)	((fp)->_cnt)
#define STDIO_CNT_LVALUE 		/**/
/*#define STDIO_PTR_LVAL_SETS_CNT	/**/
/*#define STDIO_PTR_LVAL_NOCHANGE_CNT	/**/
#endif

/* USE_STDIO_BASE:
 *	This symbol is defined if the _base field (or similar) of the
 *	stdio FILE structure can be used to access the stdio buffer for
 *	a file handle.  If this is defined, then the FILE_base(fp) macro
 *	will also be defined and should be used to access this field.
 *	Also, the FILE_bufsiz(fp) macro will be defined and should be used
 *	to determine the number of bytes in the buffer.  USE_STDIO_BASE
 *	will never be defined unless USE_STDIO_PTR is.
 */
/* FILE_base:
 *	This macro is used to access the _base field (or equivalent) of the
 *	FILE structure pointed to by its argument. This macro will always be
 *	defined if USE_STDIO_BASE is defined.
 */
/* FILE_bufsiz:
 *	This macro is used to determine the number of bytes in the I/O
 *	buffer pointed to by _base field (or equivalent) of the FILE
 *	structure pointed to its argument. This macro will always be defined
 *	if USE_STDIO_BASE is defined.
 */
#define USE_STDIO_BASE 	/**/
#ifdef USE_STDIO_BASE
#define FILE_base(fp)	((fp)->_base)
#define FILE_bufsiz(fp)	((fp)->_cnt + (fp)->_ptr - (fp)->_base)
#endif

/* HAS_STRERROR:
 *	This symbol, if defined, indicates that the strerror routine is
 *	available to translate error numbers to strings. See the writeup
 *	of Strerror() in this file before you try to define your own.
 */
/* HAS_SYS_ERRLIST:
 *	This symbol, if defined, indicates that the sys_errlist array is
 *	available to translate error numbers to strings. The extern int
 *	sys_nerr gives the size of that table.
 */
/* Strerror:
 *	This preprocessor symbol is defined as a macro if strerror() is
 *	not available to translate error numbers to strings but sys_errlist[]
 *	array is there.
 */
#define HAS_STRERROR		/**/
#define HAS_SYS_ERRLIST	/**/
#define Strerror(e) strerror(e)

/* HAS_STRTOLD:
 *	This symbol, if defined, indicates that the strtold routine is
 *	available to convert strings to long doubles.
 */
/*#define HAS_STRTOLD		/**/

/* HAS_STRTOLL:
 *	This symbol, if defined, indicates that the strtoll routine is
 *	available to convert strings to long longs.
 */
/*#define HAS_STRTOLL		/**/

/* HAS_STRTOULL:
 *	This symbol, if defined, indicates that the strtoull routine is
 *	available to convert strings to unsigned long longs.
 */
/*#define HAS_STRTOULL		/**/

/* HAS_STRTOUQ:
 *	This symbol, if defined, indicates that the strtouq routine is
 *	available to convert strings to unsigned long longs (quads).
 */
/*#define HAS_STRTOUQ		/**/

/* HAS_TELLDIR_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the telldir() function.  Otherwise, it is up
 *	to the program to supply one.  A good guess is
 *		extern long telldir _((DIR*));
 */
#define	HAS_TELLDIR_PROTO	/**/

/* Time_t:
 *	This symbol holds the type returned by time(). It can be long,
 *	or time_t on BSD sites (in which case <sys/types.h> should be
 *	included).
 */
#define Time_t time_t		/* Time type */

/* HAS_TIMES:
 *	This symbol, if defined, indicates that the times() routine exists.
 *	Note that this became obsolete on some systems (SUNOS), which now
 * use getrusage(). It may be necessary to include <sys/times.h>.
 */
#define HAS_TIMES		/**/

/* HAS_UNION_SEMUN:
 *	This symbol, if defined, indicates that the union semun is
 *	defined by including <sys/sem.h>.  If not, the user code
 *	probably needs to define it as:
 *	union semun {
 *	    int val;
 *	    struct semid_ds *buf;
 *	    unsigned short *array;
 *	}
 */
/* USE_SEMCTL_SEMUN:
 *	This symbol, if defined, indicates that union semun is
 *	used for semctl IPC_STAT.
 */
/* USE_SEMCTL_SEMID_DS:
 *	This symbol, if defined, indicates that struct semid_ds * is
 *	used for semctl IPC_STAT.
 */
#define HAS_UNION_SEMUN	/**/
/*#define USE_SEMCTL_SEMUN	/**/
/*#define USE_SEMCTL_SEMID_DS	/**/

/* HAS_USTAT:
 *	This symbol, if defined, indicates that the ustat system call is
 *	available to query file system statistics by dev_t.
 */
/*#define HAS_USTAT		/**/

/* HAS_VFORK:
 *	This symbol, if defined, indicates that vfork() exists.
 */
/*#define HAS_VFORK	/**/

/* Signal_t:
 *	This symbol's value is either "void" or "int", corresponding to the
 *	appropriate return type of a signal handler.  Thus, you can declare
 *	a signal handler using "Signal_t (*handler)()", and define the
 *	handler using "Signal_t handler(sig)".
 */
#define Signal_t void	/* Signal handler's return type */

/* HAS_VPRINTF:
 *	This symbol, if defined, indicates that the vprintf routine is available
 *	to printf with a pointer to an argument list.  If unavailable, you
 *	may need to write your own, probably in terms of _doprnt().
 */
/* USE_CHAR_VSPRINTF:
 *	This symbol is defined if this system has vsprintf() returning type
 *	(char*).  The trend seems to be to declare it as "int vsprintf()".  It
 *	is up to the package author to declare vsprintf correctly based on the
 *	symbol.
 */
#define HAS_VPRINTF	/**/
/*#define USE_CHAR_VSPRINTF 	/**/

/* USE_DYNAMIC_LOADING:
 *	This symbol, if defined, indicates that dynamic loading of
 *	some sort is available.
 */
#define USE_DYNAMIC_LOADING		/**/

/* DOUBLESIZE:
 *	This symbol contains the size of a double, so that the C preprocessor
 *	can make decisions based on it.
 */
#define DOUBLESIZE 8		/**/

/* EBCDIC:
 *     This symbol, if defined, indicates that this system uses
 *	EBCDIC encoding.
 */
/*#define	EBCDIC 		/**/

/* FFLUSH_NULL:
 *	This symbol, if defined, tells that fflush(NULL) does flush
 *	all pending stdio output.
 */
/* FFLUSH_ALL:
 *	This symbol, if defined, tells that to flush
 *	all pending stdio output one must loop through all
 *	the stdio file handles stored in an array and fflush them.
 *	Note that if fflushNULL is defined, fflushall will not
 *	even be probed for and will be left undefined.
 */
#define	FFLUSH_NULL 		/**/
/*#define	FFLUSH_ALL 		/**/

/* Fpos_t:
 *	This symbol holds the type used to declare file positions in libc.
 *	It can be fpos_t, long, uint, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Fpos_t fpos_t		/* File position type */

/* Gid_t_f:
 *	This symbol defines the format string used for printing a Gid_t.
 */
#define	Gid_t_f		"ld"		/**/

/* Gid_t_sign:
 *	This symbol holds the signedess of a Gid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Gid_t_sign	-1		/* GID sign */

/* Gid_t_size:
 *	This symbol holds the size of a Gid_t in bytes.
 */
#define Gid_t_size 4		/* GID size */

/* Gid_t:
 *	This symbol holds the return type of getgid() and the type of
 *	argument to setrgid() and related functions.  Typically,
 *	it is the type of group ids in the kernel. It can be int, ushort,
 *	gid_t, etc... It may be necessary to include <sys/types.h> to get
 *	any typedef'ed information.
 */
#define Gid_t gid_t		/* Type for getgid(), etc... */

/* Groups_t:
 *	This symbol holds the type used for the second argument to
 *	getgroups() and setgroups().  Usually, this is the same as
 *	gidtype (gid_t) , but sometimes it isn't.
 *	It can be int, ushort, gid_t, etc... 
 *	It may be necessary to include <sys/types.h> to get any 
 *	typedef'ed information.  This is only required if you have
 *	getgroups() or setgroups()..
 */
#if defined(HAS_GETGROUPS) || defined(HAS_SETGROUPS)
#define Groups_t gid_t	/* Type for 2nd arg to [sg]etgroups() */
#endif

/* DB_Prefix_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is u_int32_t.
 */
/* DB_Hash_t:
 *	This symbol contains the type of the prefix structure element
 *	in the <db.h> header file.  In older versions of DB, it was
 *	int, while in newer ones it is size_t.
 */
#define DB_Hash_t	int		/**/
#define DB_Prefix_t	int  	/**/

/* I_GRP:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <grp.h>.
 */
/* GRPASSWD:
 *	This symbol, if defined, indicates to the C program that struct group
 *	in <grp.h> contains gr_passwd.
 */
/*#define I_GRP		/**/
/*#define GRPASSWD	/**/

/* I_ICONV:
 *	This symbol, if defined, indicates that <iconv.h> exists and
 *	should be included.
 */
/*#define	I_ICONV		/**/

/* I_IEEEFP:
 *	This symbol, if defined, indicates that <ieeefp.h> exists and
 *	should be included.
 */
/*#define	I_IEEEFP		/**/

/* I_INTTYPES:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <inttypes.h>.
 */
/*#define   I_INTTYPES                /**/

/* I_LIBUTIL:
 *	This symbol, if defined, indicates that <libutil.h> exists and
 *	should be included.
 */
/*#define	I_LIBUTIL		/**/

/* I_MACH_CTHREADS:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <mach/cthreads.h>.
 */
/*#define   I_MACH_CTHREADS	/**/

/* I_MNTENT:
 *	This symbol, if defined, indicates that <mntent.h> exists and
 *	should be included.
 */
/*#define	I_MNTENT		/**/

/* I_NETDB:
 *	This symbol, if defined, indicates that <netdb.h> exists and
 *	should be included.
 */
/*#define I_NETDB		/**/

/* I_NETINET_TCP:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <netinet/tcp.h>.
 */
/*#define   I_NETINET_TCP                /**/

/* I_POLL:
 *	This symbol, if defined, indicates that <poll.h> exists and
 *	should be included.
 */
/*#define	I_POLL		/**/

/* I_PROT:
 *	This symbol, if defined, indicates that <prot.h> exists and
 *	should be included.
 */
/*#define	I_PROT		/**/

/* I_PTHREAD:
 *     This symbol, if defined, indicates to the C program that it should
 *     include <pthread.h>.
 */
/*#define   I_PTHREAD	/**/

/* I_PWD:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <pwd.h>.
 */
/* PWQUOTA:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_quota.
 */
/* PWAGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_age.
 */
/* PWCHANGE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_change.
 */
/* PWCLASS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_class.
 */
/* PWEXPIRE:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_expire.
 */
/* PWCOMMENT:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_comment.
 */
/* PWGECOS:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_gecos.
 */
/* PWPASSWD:
 *	This symbol, if defined, indicates to the C program that struct passwd
 *	contains pw_passwd.
 */
/*#define I_PWD		/**/
/*#define PWQUOTA	/**/
/*#define PWAGE	/**/
/*#define PWCHANGE	/**/
/*#define PWCLASS	/**/
/*#define PWEXPIRE	/**/
/*#define PWCOMMENT	/**/
/*#define PWGECOS	/**/
/*#define PWPASSWD	/**/

/* I_SHADOW:
 *	This symbol, if defined, indicates that <shadow.h> exists and
 *	should be included.
 */
/*#define	I_SHADOW		/**/

/* I_SOCKS:
 *	This symbol, if defined, indicates that <socks.h> exists and
 *	should be included.
 */
/*#define	I_SOCKS		/**/

/* I_SUNMATH:
 *	This symbol, if defined, indicates that <sunmath.h> exists and
 *	should be included.
 */
/*#define	I_SUNMATH		/**/

/* I_SYSLOG:
 *	This symbol, if defined, indicates that <syslog.h> exists and
 *	should be included.
 */
/*#define	I_SYSLOG		/**/

/* I_SYSMODE:
 *	This symbol, if defined, indicates that <sys/mode.h> exists and
 *	should be included.
 */
/*#define	I_SYSMODE		/**/

/* I_SYS_MOUNT:
 *	This symbol, if defined, indicates that <sys/mount.h> exists and
 *	should be included.
 */
/*#define	I_SYS_MOUNT		/**/

/* I_SYS_STATFS:
 *	This symbol, if defined, indicates that <sys/statfs.h> exists.
 */
/*#define	I_SYS_STATFS		/**/

/* I_SYS_STATVFS:
 *	This symbol, if defined, indicates that <sys/statvfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_STATVFS		/**/

/* I_SYSUIO:
 *	This symbol, if defined, indicates that <sys/uio.h> exists and
 *	should be included.
 */
/*#define	I_SYSUIO		/**/

/* I_SYSUTSNAME:
 *	This symbol, if defined, indicates that <sys/utsname.h> exists and
 *	should be included.
 */
/*#define	I_SYSUTSNAME		/**/

/* I_SYS_VFS:
 *	This symbol, if defined, indicates that <sys/vfs.h> exists and
 *	should be included.
 */
/*#define	I_SYS_VFS		/**/

/* I_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <time.h>.
 */
/* I_SYS_TIME:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h>.
 */
/* I_SYS_TIME_KERNEL:
 *	This symbol, if defined, indicates to the C program that it should
 *	include <sys/time.h> with KERNEL defined.
 */
#define I_TIME		/**/
/*#define I_SYS_TIME		/**/
/*#define I_SYS_TIME_KERNEL		/**/

/* I_USTAT:
 *	This symbol, if defined, indicates that <ustat.h> exists and
 *	should be included.
 */
/*#define	I_USTAT		/**/

/* PERL_INC_VERSION_LIST:
 *	This variable specifies the list of subdirectories in over
 *	which perl.c:incpush() and lib/lib.pm will automatically
 *	search when adding directories to @INC, in a format suitable
 *	for a C initialization string.  See the inc_version_list entry
 *	in Porting/Glossary for more details.
 */
#define PERL_INC_VERSION_LIST 0		/**/

/* INSTALL_USR_BIN_PERL:
 *	This symbol, if defined, indicates that Perl is to be installed
 * 	also as /usr/bin/perl.
 */
/*#define INSTALL_USR_BIN_PERL	/**/

/* PERL_PRIfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for output.
 */
/* PERL_PRIgldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'g') for output.
 */
/* PERL_PRIeldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'e') for output.
 */
/* PERL_SCNfldbl:
 *	This symbol, if defined, contains the string used by stdio to
 *	format long doubles (format 'f') for input.
 */
/*#define PERL_PRIfldbl	"f"	/**/
/*#define PERL_PRIgldbl	"g"	/**/
/*#define PERL_PRIeldbl	"e"	/**/
/*#define PERL_SCNfldbl	"f"	/**/

/* Off_t:
 *	This symbol holds the type used to declare offsets in the kernel.
 *	It can be int, long, off_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
/* LSEEKSIZE:
 *	This symbol holds the number of bytes used by the Off_t.
 */
/* Off_t_size:
 *	This symbol holds the number of bytes used by the Off_t.
 */
#define Off_t off_t		/* <offset> type */
#define LSEEKSIZE 4		/* <offset> size */
#define Off_t_size 4	/* <offset> size */

/* Free_t:
 *	This variable contains the return type of free().  It is usually
 * void, but occasionally int.
 */
/* Malloc_t:
 *	This symbol is the type of pointer returned by malloc and realloc.
 */
#define Malloc_t void *			/**/
#define Free_t void			/**/

/* MYMALLOC:
 *	This symbol, if defined, indicates that we're using our own malloc.
 */
/*#define MYMALLOC			/**/

/* Mode_t:
 *	This symbol holds the type used to declare file modes 
 *	for systems calls.  It is usually mode_t, but may be
 *	int or unsigned short.  It may be necessary to include <sys/types.h>
 *	to get any typedef'ed information.
 */
#define Mode_t mode_t	 /* file mode parameter for system calls */

/* VAL_O_NONBLOCK:
 *	This symbol is to be used during open() or fcntl(F_SETFL) to turn on
 *	non-blocking I/O for the file descriptor. Note that there is no way
 *	back, i.e. you cannot turn it blocking again this way. If you wish to
 *	alternatively switch between blocking and non-blocking, use the
 *	ioctl(FIOSNBIO) call instead, but that is not supported by all devices.
 */
/* VAL_EAGAIN:
 *	This symbol holds the errno error code set by read() when no data was
 *	present on the non-blocking file descriptor.
 */
/* RD_NODATA:
 *	This symbol holds the return code from read() when no data is present
 *	on the non-blocking file descriptor. Be careful! If EOF_NONBLOCK is
 *	not defined, then you can't distinguish between no data and EOF by
 *	issuing a read(). You'll have to find another way to tell for sure!
 */
/* EOF_NONBLOCK:
 *	This symbol, if defined, indicates to the C program that a read() on
 *	a non-blocking file descriptor will return 0 on EOF, and not the value
 *	held in RD_NODATA (-1 usually, in that case!).
 */
#define VAL_O_NONBLOCK O_NONBLOCK
#define VAL_EAGAIN EAGAIN
#define RD_NODATA -1
#define EOF_NONBLOCK

/* Netdb_host_t:
 *	This symbol holds the type used for the 1st argument
 *	to gethostbyaddr().
 */
/* Netdb_hlen_t:
 *	This symbol holds the type used for the 2nd argument
 *	to gethostbyaddr().
 */
/* Netdb_name_t:
 *	This symbol holds the type used for the argument to
 *	gethostbyname().
 */
/* Netdb_net_t:
 *	This symbol holds the type used for the 1st argument to
 *	getnetbyaddr().
 */
#define Netdb_host_t		char * /**/
#define Netdb_hlen_t		int /**/
#define Netdb_name_t		char * /**/
#define Netdb_net_t		long /**/

/* PERL_OTHERLIBDIRS:
 *	This variable contains a colon-separated set of paths for the perl
 *	binary to search for additional library files or modules.
 *	These directories will be tacked to the end of @INC.
 *	Perl will automatically search below each path for version-
 *	and architecture-specific directories.  See PERL_INC_VERSION_LIST
 *	for more details.
 */
/*#define PERL_OTHERLIBDIRS ""		/**/

/* IVTYPE:
 *	This symbol defines the C type used for Perl's IV.
 */
/* UVTYPE:
 *	This symbol defines the C type used for Perl's UV.
 */
/* I8TYPE:
 *	This symbol defines the C type used for Perl's I8.
 */
/* U8TYPE:
 *	This symbol defines the C type used for Perl's U8.
 */
/* I16TYPE:
 *	This symbol defines the C type used for Perl's I16.
 */
/* U16TYPE:
 *	This symbol defines the C type used for Perl's U16.
 */
/* I32TYPE:
 *	This symbol defines the C type used for Perl's I32.
 */
/* U32TYPE:
 *	This symbol defines the C type used for Perl's U32.
 */
/* I64TYPE:
 *	This symbol defines the C type used for Perl's I64.
 */
/* U64TYPE:
 *	This symbol defines the C type used for Perl's U64.
 */
/* NVTYPE:
 *	This symbol defines the C type used for Perl's NV.
 */
/* IVSIZE:
 *	This symbol contains the sizeof(IV).
 */
/* UVSIZE:
 *	This symbol contains the sizeof(UV).
 */
/* I8SIZE:
 *	This symbol contains the sizeof(I8).
 */
/* U8SIZE:
 *	This symbol contains the sizeof(U8).
 */
/* I16SIZE:
 *	This symbol contains the sizeof(I16).
 */
/* U16SIZE:
 *	This symbol contains the sizeof(U16).
 */
/* I32SIZE:
 *	This symbol contains the sizeof(I32).
 */
/* U32SIZE:
 *	This symbol contains the sizeof(U32).
 */
/* I64SIZE:
 *	This symbol contains the sizeof(I64).
 */
/* U64SIZE:
 *	This symbol contains the sizeof(U64).
 */
/* NVSIZE:
 *	This symbol contains the sizeof(NV).
 */
/* NV_PRESERVES_UV:
 *	This symbol, if defined, indicates that a variable of type NVTYPE
 *	can preserve all the bits of a variable of type UVTYPE.
 */
/* NV_PRESERVES_UV_BITS:
 *	This symbol contains the number of bits a variable of type NVTYPE
 *	can preserve of a variable of type UVTYPE.
 */
#define	IVTYPE		long		/**/
#define	UVTYPE		unsigned long		/**/
#define	I8TYPE		char		/**/
#define	U8TYPE		unsigned char		/**/
#define	I16TYPE		short	/**/
#define	U16TYPE		unsigned short	/**/
#define	I32TYPE		long	/**/
#define	U32TYPE		unsigned long	/**/
#ifdef HAS_QUAD
#define	I64TYPE		__int64	/**/
#define	U64TYPE		unsigned __int64	/**/
#endif
#define	NVTYPE		double		/**/
#define	IVSIZE		4		/**/
#define	UVSIZE		4		/**/
#define	I8SIZE		1		/**/
#define	U8SIZE		1		/**/
#define	I16SIZE		2	/**/
#define	U16SIZE		2	/**/
#define	I32SIZE		4	/**/
#define	U32SIZE		4	/**/
#ifdef HAS_QUAD
#define	I64SIZE		8	/**/
#define	U64SIZE		8	/**/
#endif
#define	NVSIZE		8		/**/
#define	NV_PRESERVES_UV
#define	NV_PRESERVES_UV_BITS	32

/* IVdf:
 *	This symbol defines the format string used for printing a Perl IV
 *	as a signed decimal integer.
 */
/* UVuf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned decimal integer.
 */
/* UVof:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned octal integer.
 */
/* UVxf:
 *	This symbol defines the format string used for printing a Perl UV
 *	as an unsigned hexadecimal integer in lowercase abcdef.
 */
/* NVef:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %e-ish floating point format.
 */
/* NVff:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %f-ish floating point format.
 */
/* NVgf:
 *	This symbol defines the format string used for printing a Perl NV
 *	using %g-ish floating point format.
 */
#define	IVdf		"ld"		/**/
#define	UVuf		"lu"		/**/
#define	UVof		"lo"		/**/
#define	UVxf		"lx"		/**/
#define	NVef		"e"		/**/
#define	NVff		"f"		/**/
#define	NVgf		"g"		/**/

/* Pid_t:
 *	This symbol holds the type used to declare process ids in the kernel.
 *	It can be int, uint, pid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Pid_t int		/* PID type */

/* PRIVLIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 */
/* PRIVLIB_EXP:
 *	This symbol contains the ~name expanded version of PRIVLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define PRIVLIB "C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\lib"		/**/
#define PRIVLIB_EXP (win32_get_privlib("5.6.1"))	/**/

/* PTRSIZE:
 *	This symbol contains the size of a pointer, so that the C preprocessor
 *	can make decisions based on it.  It will be sizeof(void *) if
 *	the compiler supports (void *); otherwise it will be
 *	sizeof(char *).
 */
#define PTRSIZE 4		/**/

/* Drand01:
 *	This macro is to be used to generate uniformly distributed
 *	random numbers over the range [0., 1.[.  You may have to supply
 *	an 'extern double drand48();' in your program since SunOS 4.1.3
 *	doesn't provide you with anything relevant in it's headers.
 *	See HAS_DRAND48_PROTO.
 */
/* Rand_seed_t:
 *	This symbol defines the type of the argument of the
 *	random seed function.
 */
/* seedDrand01:
 *	This symbol defines the macro to be used in seeding the
 *	random number generator (see Drand01).
 */
/* RANDBITS:
 *	This symbol indicates how many bits are produced by the
 *	function used to generate normalized random numbers.
 *	Values include 15, 16, 31, and 48.
 */
#define Drand01()		(rand()/(double)((unsigned)1<<RANDBITS))		/**/
#define Rand_seed_t		unsigned		/**/
#define seedDrand01(x)	srand((Rand_seed_t)x)	/**/
#define RANDBITS		15		/**/

/* SELECT_MIN_BITS:
 *	This symbol holds the minimum number of bits operated by select.
 *	That is, if you do select(n, ...), how many bits at least will be
 *	cleared in the masks if some activity is detected.  Usually this
 *	is either n or 32*ceil(n/32), especially many little-endians do
 *	the latter.  This is only useful if you have select(), naturally.
 */
#define SELECT_MIN_BITS 	32	/**/

/* Select_fd_set_t:
 *	This symbol holds the type used for the 2nd, 3rd, and 4th
 *	arguments to select.  Usually, this is 'fd_set *', if HAS_FD_SET
 *	is defined, and 'int *' otherwise.  This is only useful if you 
 *	have select(), of course.
 */
#define Select_fd_set_t 	Perl_fd_set *	/**/

/* SIG_NAME:
 *	This symbol contains a list of signal names in order of
 *	signal number. This is intended
 *	to be used as a static array initialization, like this:
 *		char *sig_name[] = { SIG_NAME };
 *	The signals in the list are separated with commas, and each signal
 *	is surrounded by double quotes. There is no leading SIG in the signal
 *	name, i.e. SIGQUIT is known as "QUIT".
 *	Gaps in the signal numbers (up to NSIG) are filled in with NUMnn,
 *	etc., where nn is the actual signal number (e.g. NUM37).
 *	The signal number for sig_name[i] is stored in sig_num[i].
 *	The last element is 0 to terminate the list with a NULL.  This
 *	corresponds to the 0 at the end of the sig_num list.
 */
/* SIG_NUM:
 *	This symbol contains a list of signal numbers, in the same order as the
 *	SIG_NAME list. It is suitable for static array initialization, as in:
 *		int sig_num[] = { SIG_NUM };
 *	The signals in the list are separated with commas, and the indices
 *	within that list and the SIG_NAME list match, so it's easy to compute
 *	the signal name from a number or vice versa at the price of a small
 *	dynamic linear lookup. 
 *	Duplicates are allowed, but are moved to the end of the list.
 *	The signal number corresponding to sig_name[i] is sig_number[i].
 *	if (i < NSIG) then sig_number[i] == i.  
 *	The last element is 0, corresponding to the 0 at the end of
 *	the sig_name list.
 */
#define SIG_NAME "ZERO", "NUM01", "INT", "QUIT", "ILL", "NUM05", "NUM06", "NUM07", "FPE", "KILL", "NUM10", "SEGV", "NUM12", "PIPE", "ALRM", "TERM", "NUM16", "NUM17", "NUM18", "NUM19", "CHLD", "BREAK", "ABRT", "STOP", "NUM24", "CONT", "CLD", 0		/**/
#define SIG_NUM  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 20, 0		/**/

/* SITEARCH:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-dependent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITEARCH_EXP:
 *	This symbol contains the ~name expanded version of SITEARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
#define SITEARCH "C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\site\\lib"		/**/
/*#define SITEARCH_EXP ""	/**/

/* SITELIB:
 *	This symbol contains the name of the private library for this package.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.  The program
 *	should be prepared to do ~ expansion.
 *	The standard distribution will put nothing in this directory.
 *	After perl has been installed, users may install their own local
 *	architecture-independent modules in this directory with
 *		MakeMaker Makefile.PL
 *	or equivalent.  See INSTALL for details.
 */
/* SITELIB_EXP:
 *	This symbol contains the ~name expanded version of SITELIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* SITELIB_STEM:
 *	This define is SITELIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
#define SITELIB "C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\site\\lib"		/**/
#define SITELIB_EXP (win32_get_sitelib("5.6.1"))	/**/
#define SITELIB_STEM ""		/**/

/* Size_t_size:
 *	This symbol holds the size of a Size_t in bytes.
 */
#define Size_t_size 4		/**/

/* Size_t:
 *	This symbol holds the type used to declare length parameters
 *	for string functions.  It is usually size_t, but may be
 *	unsigned long, int, etc.  It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Size_t size_t	 /* length paramater for string functions */

/* Sock_size_t:
 *	This symbol holds the type used for the size argument of
 *	various socket calls (just the base type, not the pointer-to).
 */
#define Sock_size_t		int /**/

/* SSize_t:
 *	This symbol holds the type used by functions that return
 *	a count of bytes or an error condition.  It must be a signed type.
 *	It is usually ssize_t, but may be long or int, etc.
 *	It may be necessary to include <sys/types.h> or <unistd.h>
 *	to get any typedef'ed information.
 *	We will pick a type such that sizeof(SSize_t) == sizeof(Size_t).
 */
#define SSize_t int	 /* signed count of bytes */

/* STARTPERL:
 *	This variable contains the string to put in front of a perl
 *	script to make sure (one hopes) that it runs with perl and not
 *	some shell.
 */
#define STARTPERL "#!perl"		/**/

/* HAS_STDIO_STREAM_ARRAY:
 *	This symbol, if defined, tells that there is an array
 *	holding the stdio streams.
 */
/* STDIO_STREAM_ARRAY:
 *	This symbol tells the name of the array holding the stdio streams.
 *	Usual values include _iob, __iob, and __sF.
 */
/*#define	HAS_STDIO_STREAM_ARRAY	/**/
#define STDIO_STREAM_ARRAY	

/* Uid_t_f:
 *	This symbol defines the format string used for printing a Uid_t.
 */
#define	Uid_t_f		"ld"		/**/

/* Uid_t_sign:
 *	This symbol holds the signedess of a Uid_t.
 *	1 for unsigned, -1 for signed.
 */
#define Uid_t_sign	-1		/* UID sign */

/* Uid_t_size:
 *	This symbol holds the size of a Uid_t in bytes.
 */
#define Uid_t_size 4		/* UID size */

/* Uid_t:
 *	This symbol holds the type used to declare user ids in the kernel.
 *	It can be int, ushort, uid_t, etc... It may be necessary to include
 *	<sys/types.h> to get any typedef'ed information.
 */
#define Uid_t uid_t		/* UID type */

/* USE_64_BIT_INT:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be employed (be they 32 or 64 bits).  The minimal possible
 *	64-bitness is used, just enough to get 64-bit integers into Perl.
 *	This may mean using for example "long longs", while your memory
 *	may still be limited to 2 gigabytes.
 */
/* USE_64_BIT_ALL:
 *	This symbol, if defined, indicates that 64-bit integers should
 *	be used when available.  If not defined, the native integers
 *	will be used (be they 32 or 64 bits).  The maximal possible
 *	64-bitness is employed: LP64 or ILP64, meaning that you will
 *	be able to use more than 2 gigabytes of memory.  This mode is
 *	even more binary incompatible than USE_64_BIT_INT. You may not
 *	be able to run the resulting executable in a 32-bit CPU at all or
 *	you may need at least to reboot your OS to 64-bit mode.
 */
#ifndef USE_64_BIT_INT
/*#define	USE_64_BIT_INT		/**/
#endif

#ifndef USE_64_BIT_ALL
/*#define	USE_64_BIT_ALL		/**/
#endif

/* USE_LARGE_FILES:
 *	This symbol, if defined, indicates that large file support
 *	should be used when available.
 */
#ifndef USE_LARGE_FILES
/*#define	USE_LARGE_FILES		/**/
#endif

/* USE_LONG_DOUBLE:
 *	This symbol, if defined, indicates that long doubles should
 *	be used when available.
 */
#ifndef USE_LONG_DOUBLE
/*#define	USE_LONG_DOUBLE		/**/
#endif

/* USE_MORE_BITS:
 *	This symbol, if defined, indicates that 64-bit interfaces and
 *	long doubles should be used when available.
 */
#ifndef USE_MORE_BITS
/*#define	USE_MORE_BITS		/**/
#endif

/* MULTIPLICITY:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use multiplicity.
 */
#ifndef MULTIPLICITY
#define	MULTIPLICITY		/**/
#endif

/* USE_PERLIO:
 *	This symbol, if defined, indicates that the PerlIO abstraction should
 *	be used throughout.  If not defined, stdio should be
 *	used in a fully backward compatible manner.
 */
#ifndef USE_PERLIO
/*#define	USE_PERLIO		/**/
#endif

/* USE_SOCKS:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use socks.
 */
#ifndef USE_SOCKS
/*#define	USE_SOCKS		/**/
#endif

/* USE_ITHREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the interpreter-based threading implementation.
 */
/* USE_5005THREADS:
 *	This symbol, if defined, indicates that Perl should be built to
 *	use the 5.005-based threading implementation.
 */
/* OLD_PTHREADS_API:
 *	This symbol, if defined, indicates that Perl should
 *	be built to use the old draft POSIX threads API.
 */
/*#define	USE_5005THREADS		/**/
#define	USE_ITHREADS		/**/
#if defined(USE_5005THREADS) && !defined(USE_ITHREADS)
#define		USE_THREADS		/* until src is revised*/
#endif
/*#define	OLD_PTHREADS_API		/**/

/* PERL_VENDORARCH:
 *	If defined, this symbol contains the name of a private library.
 *	The library is private in the sense that it needn't be in anyone's
 *	execution path, but it should be accessible by the world.
 *	It may have a ~ on the front. 
 *	The standard distribution will put nothing in this directory.
 *	Vendors who distribute perl may wish to place their own
 *	architecture-dependent modules and extensions in this directory with
 *		MakeMaker Makefile.PL INSTALLDIRS=vendor 
 *	or equivalent.  See INSTALL for details.
 */
/* PERL_VENDORARCH_EXP:
 *	This symbol contains the ~name expanded version of PERL_VENDORARCH, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/*#define PERL_VENDORARCH ""		/**/
/*#define PERL_VENDORARCH_EXP ""		/**/

/* PERL_VENDORLIB_EXP:
 *	This symbol contains the ~name expanded version of VENDORLIB, to be used
 *	in programs that are not prepared to deal with ~ expansion at run-time.
 */
/* PERL_VENDORLIB_STEM:
 *	This define is PERL_VENDORLIB_EXP with any trailing version-specific component
 *	removed.  The elements in inc_version_list (inc_version_list.U) can
 *	be tacked onto this variable to generate a list of directories to search.
 */
/*#define PERL_VENDORLIB_EXP ""		/**/
/*#define PERL_VENDORLIB_STEM ""		/**/

/* VOIDFLAGS:
 *	This symbol indicates how much support of the void type is given by this
 *	compiler.  What various bits mean:
 *
 *	    1 = supports declaration of void
 *	    2 = supports arrays of pointers to functions returning void
 *	    4 = supports comparisons between pointers to void functions and
 *		    addresses of void functions
 *	    8 = suports declaration of generic void pointers
 *
 *	The package designer should define VOIDUSED to indicate the requirements
 *	of the package.  This can be done either by #defining VOIDUSED before
 *	including config.h, or by defining defvoidused in Myinit.U.  If the
 *	latter approach is taken, only those flags will be tested.  If the
 *	level of void support necessary is not present, defines void to int.
 */
#ifndef VOIDUSED
#define VOIDUSED 15
#endif
#define VOIDFLAGS 15
#if (VOIDFLAGS & VOIDUSED) != VOIDUSED
#define void int		/* is void to be avoided? */
#define M_VOID			/* Xenix strikes again */
#endif

/* PERL_XS_APIVERSION:
 *	This variable contains the version of the oldest perl binary
 *	compatible with the present perl.  perl.c:incpush() and
 *	lib/lib.pm will automatically search in C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\site\\lib for older
 *	directories across major versions back to xs_apiversion.
 *	This is only useful if you have a perl library directory tree
 *	structured like the default one.
 *	See INSTALL for how this works.
 *	The versioned site_perl directory was introduced in 5.005,
 *	so that is the lowest possible value.
 *	Since this can depend on compile time options (such as
 *	bincompat) it is set by Configure.  Other non-default sources
 *	of potential incompatibility, such as multiplicity, threads,
 *	debugging, 64bits, sfio, etc., are not checked for currently,
 *	though in principle we could go snooping around in old
 *	Config.pm files.
 */
/* PERL_PM_APIVERSION:
 *	This variable contains the version of the oldest perl
 *	compatible with the present perl.  (That is, pure perl modules
 *	written for pm_apiversion will still work for the current
 *	version).  perl.c:incpush() and lib/lib.pm will automatically
 *	search in C:\\p4view\\Apps\\ActivePerl\\MSI\\data\\ActivePerl\\Perl\\site\\lib for older directories across major versions
 *	back to pm_apiversion.  This is only useful if you have a perl
 *	library directory tree structured like the default one.  The
 *	versioned site_perl library was introduced in 5.005, so that's
 *	the default setting for this variable.  It's hard to imagine
 *	it changing before Perl6.  It is included here for symmetry
 *	with xs_apiveprsion -- the searching algorithms will
 *	(presumably) be similar.
 *	See the INSTALL file for how this works.
 */
#define PERL_XS_APIVERSION "5.6.0"
#define PERL_PM_APIVERSION "5.005"

/* HAS_GETPGRP:
 *	This symbol, if defined, indicates that the getpgrp routine is
 *	available to get the current process group.
 */
/* USE_BSD_GETPGRP:
 *	This symbol, if defined, indicates that getpgrp needs one
 *	arguments whereas USG one needs none.
 */
/*#define HAS_GETPGRP		/**/
/*#define USE_BSD_GETPGRP	/**/

/* HAS_SETPGRP:
 *	This symbol, if defined, indicates that the setpgrp routine is
 *	available to set the current process group.
 */
/* USE_BSD_SETPGRP:
 *	This symbol, if defined, indicates that setpgrp needs two
 *	arguments whereas USG one needs none.  See also HAS_SETPGID
 *	for a POSIX interface.
 */
/*#define HAS_SETPGRP		/**/
/*#define USE_BSD_SETPGRP	/**/

/* STDCHAR:
 *	This symbol is defined to be the type of char used in stdio.h.
 *	It has the values "unsigned char" or "char".
 */
#define STDCHAR char	/**/

/* HAS__FWALK:
 *	This symbol, if defined, indicates that the _fwalk system call is
 *	available to apply a function to all the file handles.
 */
/*#define HAS__FWALK		/**/

/* FCNTL_CAN_LOCK:
 *	This symbol, if defined, indicates that fcntl() can be used
 *	for file locking.  Normally on Unix systems this is defined.
 *	It may be undefined on VMS.
 */
/*#define FCNTL_CAN_LOCK		/**/

/* HAS_FSYNC:
 *	This symbol, if defined, indicates that the fsync routine is
 *	available to write a file's modified data and attributes to
 *	permanent storage.
 */
/*#define HAS_FSYNC		/**/

/* HAS_SBRK_PROTO:
 *	This symbol, if defined, indicates that the system provides
 *	a prototype for the sbrk() function.  Otherwise, it is up
 *	to the program to supply one.  Good guesses are
 *		extern void* sbrk _((int));
 *		extern void* sbrk _((size_t));
 */
/*#define	HAS_SBRK_PROTO	/**/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\cv.h ===
/*    cv.h
 *
 *    Copyright (c) 1991-2001, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* This structure much match XPVCV in B/C.pm and the beginning of XPVFM
 * in sv.h  */

struct xpvcv {
    char *	xpv_pv;		/* pointer to malloced string */
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    IV		xof_off;	/* integer value */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    OP *	xcv_start;
    OP *	xcv_root;
    void	(*xcv_xsub) (pTHXo_ CV*);
    ANY		xcv_xsubany;
    GV *	xcv_gv;
    char *	xcv_file;
    long	xcv_depth;	/* >= 2 indicates recursive call */
    AV *	xcv_padlist;
    CV *	xcv_outside;
#ifdef USE_THREADS
    perl_mutex *xcv_mutexp;
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_THREADS */
    cv_flags_t	xcv_flags;
};

/*
=for apidoc AmU||Nullcv
Null CV pointer.

=for apidoc Am|HV*|CvSTASH|CV* cv
Returns the stash of the CV.

=cut
*/

#define Nullcv Null(CV*)

#define CvSTASH(sv)	((XPVCV*)SvANY(sv))->xcv_stash
#define CvSTART(sv)	((XPVCV*)SvANY(sv))->xcv_start
#define CvROOT(sv)	((XPVCV*)SvANY(sv))->xcv_root
#define CvXSUB(sv)	((XPVCV*)SvANY(sv))->xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)SvANY(sv))->xcv_xsubany
#define CvGV(sv)	((XPVCV*)SvANY(sv))->xcv_gv
#define CvFILE(sv)	((XPVCV*)SvANY(sv))->xcv_file
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv))
#define CvDEPTH(sv)	((XPVCV*)SvANY(sv))->xcv_depth
#define CvPADLIST(sv)	((XPVCV*)SvANY(sv))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)SvANY(sv))->xcv_outside
#ifdef USE_THREADS
#define CvMUTEXP(sv)	((XPVCV*)SvANY(sv))->xcv_mutexp
#define CvOWNER(sv)	((XPVCV*)SvANY(sv))->xcv_owner
#endif /* USE_THREADS */
#define CvFLAGS(sv)	((XPVCV*)SvANY(sv))->xcv_flags

#define CVf_CLONE	0x0001	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0002	/* a clone of one of those */
#define CVf_ANON	0x0004	/* CvGV() can't be trusted */
#define CVf_OLDSTYLE	0x0008
#define CVf_UNIQUE	0x0010	/* can't be cloned */
#define CVf_NODEBUG	0x0020	/* no DB::sub indirection for this CV
				   (esp. useful for special XSUBs) */
#define CVf_METHOD	0x0040	/* CV is explicitly marked as a method */
#define CVf_LOCKED	0x0080	/* CV locks itself or first arg on entry */
#define CVf_LVALUE	0x0100  /* CV return value can be used as lvalue */

#define CvCLONE(cv)		(CvFLAGS(cv) & CVf_CLONE)
#define CvCLONE_on(cv)		(CvFLAGS(cv) |= CVf_CLONE)
#define CvCLONE_off(cv)		(CvFLAGS(cv) &= ~CVf_CLONE)

#define CvCLONED(cv)		(CvFLAGS(cv) & CVf_CLONED)
#define CvCLONED_on(cv)		(CvFLAGS(cv) |= CVf_CLONED)
#define CvCLONED_off(cv)	(CvFLAGS(cv) &= ~CVf_CLONED)

#define CvANON(cv)		(CvFLAGS(cv) & CVf_ANON)
#define CvANON_on(cv)		(CvFLAGS(cv) |= CVf_ANON)
#define CvANON_off(cv)		(CvFLAGS(cv) &= ~CVf_ANON)

#ifdef PERL_XSUB_OLDSTYLE
#define CvOLDSTYLE(cv)		(CvFLAGS(cv) & CVf_OLDSTYLE)
#define CvOLDSTYLE_on(cv)	(CvFLAGS(cv) |= CVf_OLDSTYLE)
#define CvOLDSTYLE_off(cv)	(CvFLAGS(cv) &= ~CVf_OLDSTYLE)
#endif

#define CvUNIQUE(cv)		(CvFLAGS(cv) & CVf_UNIQUE)
#define CvUNIQUE_on(cv)		(CvFLAGS(cv) |= CVf_UNIQUE)
#define CvUNIQUE_off(cv)	(CvFLAGS(cv) &= ~CVf_UNIQUE)

#define CvNODEBUG(cv)		(CvFLAGS(cv) & CVf_NODEBUG)
#define CvNODEBUG_on(cv)	(CvFLAGS(cv) |= CVf_NODEBUG)
#define CvNODEBUG_off(cv)	(CvFLAGS(cv) &= ~CVf_NODEBUG)

#define CvMETHOD(cv)		(CvFLAGS(cv) & CVf_METHOD)
#define CvMETHOD_on(cv)		(CvFLAGS(cv) |= CVf_METHOD)
#define CvMETHOD_off(cv)	(CvFLAGS(cv) &= ~CVf_METHOD)

#define CvLOCKED(cv)		(CvFLAGS(cv) & CVf_LOCKED)
#define CvLOCKED_on(cv)		(CvFLAGS(cv) |= CVf_LOCKED)
#define CvLOCKED_off(cv)	(CvFLAGS(cv) &= ~CVf_LOCKED)

#define CvLVALUE(cv)		(CvFLAGS(cv) & CVf_LVALUE)
#define CvLVALUE_on(cv)		(CvFLAGS(cv) |= CVf_LVALUE)
#define CvLVALUE_off(cv)	(CvFLAGS(cv) &= ~CVf_LVALUE)

#define CvEVAL(cv)		(CvUNIQUE(cv) && !SvFAKE(cv))
#define CvEVAL_on(cv)		(CvUNIQUE_on(cv),SvFAKE_off(cv))
#define CvEVAL_off(cv)		CvUNIQUE_off(cv)

/* BEGIN|INIT|END */
#define CvSPECIAL(cv)		(CvUNIQUE(cv) && SvFAKE(cv))
#define CvSPECIAL_on(cv)	(CvUNIQUE_on(cv),SvFAKE_on(cv))
#define CvSPECIAL_off(cv)	(CvUNIQUE_off(cv),SvFAKE_off(cv))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\dirent.h ===
/* dirent.h */

/* djl
 * Provide UNIX compatibility
 */

#ifndef  _INC_DIRENT
#define  _INC_DIRENT

/*
 * NT versions of readdir(), etc
 * From the MSDOS implementation
 */

/* Directory entry size */
#ifdef DIRSIZ
#undef DIRSIZ
#endif
#define DIRSIZ(rp)  (sizeof(struct direct))

/* needed to compile directory stuff */
#define DIRENT direct

/* structure of a directory entry */
typedef struct direct 
{
	long	d_ino;			/* inode number (not used by MS-DOS)  */
	long	d_namlen;		/* name length  */
	char	d_name[257];		/* file name  */
} _DIRECT;

/* structure for dir operations */
typedef struct _dir_struc
{
	char	*start;			/* starting position */
	char	*curr;			/* current position */
	long	size;			/* allocated size of string table */
	long	nfiles;			/* number of filenames in table */
	struct direct dirstr;		/* directory structure to return */
	void*	handle;			/* system handle */
	char	*end;			/* position after last filename */
} DIR;

#if 0		/* these have moved to win32iop.h */
DIR *		win32_opendir(char *filename);
struct direct *	win32_readdir(DIR *dirp);
long		win32_telldir(DIR *dirp);
void		win32_seekdir(DIR *dirp,long loc);
void		win32_rewinddir(DIR *dirp);
int		win32_closedir(DIR *dirp);
#endif

#endif /* _INC_DIRENT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\tools\perl\lib\core\embed.h ===
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!! 
   This file is built by embed.pl from data in embed.pl, pp.sym, intrpvar.h,
   perlvars.h and thrdvar.h.  Any changes made here will be lost!
*/

/* (Doing namespace management portably in C is really gross.) */

/* NO_EMBED is no longer supported. i.e. EMBED is always active. */

/* provide binary compatible (but inconsistent) names */
#if defined(PERL_BINCOMPAT_5005)
#  define  Perl_call_atexit		perl_atexit
#  define  Perl_eval_sv			perl_eval_sv
#  define  Perl_eval_pv			perl_eval_pv
#  define  Perl_call_argv		perl_call_argv
#  define  Perl_call_method		perl_call_method
#  define  Perl_call_pv			perl_call_pv
#  define  Perl_call_sv			perl_call_sv
#  define  Perl_get_av			perl_get_av
#  define  Perl_get_cv			perl_get_cv
#  define  Perl_get_hv			perl_get_hv
#  define  Perl_get_sv			perl_get_sv
#  define  Perl_init_i18nl10n		perl_init_i18nl10n
#  define  Perl_init_i18nl14n		perl_init_i18nl14n
#  define  Perl_new_collate		perl_new_collate
#  define  Perl_new_ctype		perl_new_ctype
#  define  Perl_new_numeric		perl_new_numeric
#  define  Perl_require_pv		perl_require_pv
#  define  Perl_safesyscalloc		Perl_safecalloc
#  define  Perl_safesysfree		Perl_safefree
#  define  Perl_safesysmalloc		Perl_safemalloc
#  define  Perl_safesysrealloc		Perl_saferealloc
#  define  Perl_set_numeric_local	perl_set_numeric_local
#  define  Perl_set_numeric_standard	perl_set_numeric_standard
/* malloc() pollution was the default in earlier versions, so enable
 * it for bincompat; but not for systems that used to do prevent that,
 * or when they ask for {HIDE,EMBED}MYMALLOC */
#  if !defined(EMBEDMYMALLOC) && !defined(HIDEMYMALLOC)
#    if !defined(NeXT) && !defined(__NeXT) && !defined(__MACHTEN__) && \
        !defined(__QNX__)
#      define  PERL_POLLUTE_MALLOC
#    endif
#  endif
#endif

/* Hide global symbols */

#if !defined(PERL_OBJECT)
#if !defined(PERL_IMPLICIT_CONTEXT)

#if defined(PERL_IMPLICIT_SYS)
#endif
#if defined(USE_ITHREADS)
#  if defined(PERL_IMPLICIT_SYS)
#  endif
#endif
#if defined(MYMALLOC)
#define malloced_size		Perl_malloced_size
#endif
#define get_context		Perl_get_context
#define set_context		Perl_set_context
#if defined(PERL_OBJECT)
#ifndef __BORLANDC__
#endif
#endif
#if defined(PERL_OBJECT)
#else
#endif
#define amagic_call		Perl_amagic_call
#define Gv_AMupdate		Perl_Gv_AMupdate
#define append_elem		Perl_append_elem
#define append_list		Perl_append_list
#define apply			Perl_apply
#define apply_attrs_string	Perl_apply_attrs_string
#define avhv_delete_ent		Perl_avhv_delete_ent
#define avhv_exists_ent		Perl_avhv_exists_ent
#define avhv_fetch_ent		Perl_avhv_fetch_ent
#define avhv_store_ent		Perl_avhv_store_ent
#define avhv_iternext		Perl_avhv_iternext
#define avhv_iterval		Perl_avhv_iterval
#define avhv_keys		Perl_avhv_keys
#define av_clear		Perl_av_clear
#define av_delete		Perl_av_delete
#define av_exists		Perl_av_exists
#define av_extend		Perl_av_extend
#define av_fake			Perl_av_fake
#define av_fetch		Perl_av_fetch
#define av_fill			Perl_av_fill
#define av_len			Perl_av_len
#define av_make			Perl_av_make
#define av_pop			Perl_av_pop
#define av_push			Perl_av_push
#define av_reify		Perl_av_reify
#define av_shift		Perl_av_shift
#define av_store		Perl_av_store
#define av_undef		Perl_av_undef
#define av_unshift		Perl_av_unshift
#define bind_match		Perl_bind_match
#define block_end		Perl_block_end
#define block_gimme		Perl_block_gimme
#define block_start		Perl_block_start
#define boot_core_UNIVERSAL	Perl_boot_core_UNIVERSAL
#define call_list		Perl_call_list
#define cando			Perl_cando
#define cast_ulong		Perl_cast_ulong
#define cast_i32		Perl_cast_i32
#define cast_iv			Perl_cast_iv
#define cast_uv			Perl_cast_uv
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#define my_chsize		Perl_my_chsize
#endif
#if defined(USE_THREADS)
#define condpair_magic		Perl_condpair_magic
#endif
#define convert			Perl_convert
#define croak			Perl_croak
#define vcroak			Perl_vcroak
#if defined(PERL_IMPLICIT_CONTEXT)
#define croak_nocontext		Perl_croak_nocontext
#define die_nocontext		Perl_die_nocontext
#define deb_nocontext		Perl_deb_nocontext
#define form_nocontext		Perl_form_nocontext
#define load_module_nocontext	Perl_load_module_nocontext
#define mess_nocontext		Perl_mess_nocontext
#define warn_nocontext		Perl_warn_nocontext
#define warner_nocontext	Perl_warner_nocontext
#define newSVpvf_nocontext	Perl_newSVpvf_nocontext
#define sv_catpvf_nocontext	Perl_sv_catpvf_nocontext
#define sv_setpvf_nocontext	Perl_sv_setpvf_nocontext
#define sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg_nocontext
#define sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg_nocontext
#define fprintf_nocontext	Perl_fprintf_nocontext
#define printf_nocontext	Perl_printf_nocontext
#endif
#define cv_ckproto		Perl_cv_ckproto
#define cv_clone		Perl_cv_clone
#define cv_const_sv		Perl_cv_const_sv
#define op_const_sv		Perl_op_const_sv
#define cv_undef		Perl_cv_undef
#define cx_dump			Perl_cx_dump
#define filter_add		Perl_filter_add
#define filter_del		Perl_filter_del
#define filter_read		Perl_filter_read
#define get_op_descs		Perl_get_op_descs
#define get_op_names		Perl_get_op_names
#define get_no_modify		Perl_get_no_modify
#define get_opargs		Perl_get_opargs
#define get_ppaddr		Perl_get_ppaddr
#define cxinc			Perl_cxinc
#define deb			Perl_deb
#define vdeb			Perl_vdeb
#define debprofdump		Perl_debprofdump
#define debop			Perl_debop
#define debstack		Perl_debstack
#define debstackptrs		Perl_debstackptrs
#define delimcpy		Perl_delimcpy
#define deprecate		Perl_deprecate
#define die			Perl_die
#define vdie			Perl_vdie
#define die_where		Perl_die_where
#define dounwind		Perl_dounwind
#define do_aexec		Perl_do_aexec
#define do_aexec5		Perl_do_aexec5
#define do_binmode		Perl_do_binmode
#define do_chop			Perl_do_chop
#define do_close		Perl_do_close
#define do_eof			Perl_do_eof
#define do_exec			Perl_do_exec
#if defined(WIN32)
#define do_aspawn		Perl_do_aspawn
#define do_spawn		Perl_do_spawn
#define do_spawn_nowait		Perl_do_spawn_nowait
#endif
#if !defined(WIN32)
#define do_exec3		Perl_do_exec3
#endif
#define do_execfree		Perl_do_execfree
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#define do_ipcctl		Perl_do_ipcctl
#define do_ipcget		Perl_do_ipcget
#define do_msgrcv		Perl_do_msgrcv
#define do_msgsnd		Perl_do_msgsnd
#define do_semop		Perl_do_semop
#define do_shmio		Perl_do_shmio
#endif
#define do_join			Perl_do_join
#define do_kv			Perl_do_kv
#define do_open			Perl_do_open
#define do_open9		Perl_do_open9
#define do_pipe			Perl_do_pipe
#define do_print		Perl_do_print
#define do_readline		Perl_do_readline
#define do_chomp		Perl_do_chomp
#define do_seek			Perl_do_seek
#define do_sprintf		Perl_do_sprintf
#define do_sysseek		Perl_do_sysseek
#define do_tell			Perl_do_tell
#define do_trans		Perl_do_trans
#define do_vecget		Perl_do_vecget
#define do_vecset		Perl_do_vecset
#define do_vop			Perl_do_vop
#define dofile			Perl_dofile
#define dowantarray		Perl_dowantarray
#define dump_all		Perl_dump_all
#define dump_eval		Perl_dump_eval
#if defined(DUMP_FDS)
#define dump_fds		Perl_dump_fds
#endif
#define dump_form		Perl_dump_form
#define gv_dump			Perl_gv_dump
#define op_dump			Perl_op_dump
#define pmop_dump		Perl_pmop_dump
#define dump_packsubs		Perl_dump_packsubs
#define dump_sub		Perl_dump_sub
#define fbm_compile		Perl_fbm_compile
#define fbm_instr		Perl_fbm_instr
#define find_script		Perl_find_script
#if defined(USE_THREADS)
#define find_threadsv		Perl_find_threadsv
#endif
#define force_list		Perl_force_list
#define fold_constants		Perl_fold_constants
#define form			Perl_form
#define vform			Perl_vform
#define free_tmps		Perl_free_tmps
#define gen_constant_list	Perl_gen_constant_list
#if !defined(HAS_GETENV_LEN)
#define getenv_len		Perl_getenv_len
#endif
#define gp_free			Perl_gp_free
#define gp_ref			Perl_gp_ref
#define gv_AVadd		Perl_gv_AVadd
#define gv_HVadd		Perl_gv_HVadd
#define gv_IOadd		Perl_gv_IOadd
#define gv_autoload4		Perl_gv_autoload4
#define gv_check		Perl_gv_check
#define gv_efullname		Perl_gv_efullname
#define gv_efullname3		Perl_gv_efullname3
#define gv_efullname4		Perl_gv_efullname4
#define gv_fetchfile		Perl_gv_fetchfile
#define gv_fetchmeth		Perl_gv_fetchmeth
#define gv_fetchmethod		Perl_gv_fetchmethod
#define gv_fetchmethod_autoload	Perl_gv_fetchmethod_autoload
#define gv_fetchpv		Perl_gv_fetchpv
#define gv_fullname		Perl_gv_fullname
#define gv_fullname3		Perl_gv_fullname3
#define gv_fullname4		Perl_gv_fullname4
#define gv_init			Perl_gv_init
#define gv_stashpv		Perl_gv_stashpv
#define gv_stashpvn		Perl_gv_stashpvn
#define gv_stashsv		Perl_gv_stashsv
#define hv_clear		Perl_hv_clear
#define hv_delayfree_ent	Perl_hv_delayfree_ent
#define hv_delete		Perl_hv_delete
#define hv_delete_ent		Perl_hv_delete_ent
#define hv_exists		Perl_hv_exists
#define hv_exists_ent		Perl_hv_exists_ent
#define hv_fetch		Perl_hv_fetch
#define hv_fetch_ent		Perl_hv_fetch_ent
#define hv_free_ent		Perl_hv_free_ent
#define hv_iterinit		Perl_hv_iterinit
#define hv_iterkey		Perl_hv_iterkey
#define hv_iterkeysv		Perl_hv_iterkeysv
#define hv_iternext		Perl_hv_iternext
#define hv_iternextsv		Perl_hv_iternextsv
#define hv_iterval		Perl_hv_iterval
#define hv_ksplit		Perl_hv_ksplit
#define hv_magic		Perl_hv_magic
#define hv_store		Perl_hv_store
#define hv_store_ent		Perl_hv_store_ent
#define hv_undef		Perl_hv_undef
#define ibcmp			Perl_ibcmp
#define ibcmp_locale		Perl_ibcmp_locale
#define ingroup			Perl_ingroup
#define init_debugger		Perl_init_debugger
#define init_stacks		Perl_init_stacks
#define intro_my		Perl_intro_my
#define instr			Perl_instr
#define io_close		Perl_io_close
#define invert			Perl_invert
#define is_gv_magical		Perl_is_gv_magical
#define is_lvalue_sub		Perl_is_lvalue_sub
#define is_uni_alnum		Perl_is_uni_alnum
#define is_uni_alnumc		Perl_is_uni_alnumc
#define is_uni_idfirst		Perl_is_uni_idfirst
#define is_uni_alpha		Perl_is_uni_alpha
#define is_uni_ascii		Perl_is_uni_ascii
#define is_uni_space		Perl_is_uni_space
#define is_uni_cntrl		Perl_is_uni_cntrl
#define is_uni_graph		Perl_is_uni_graph
#define is_uni_digit		Perl_is_uni_digit
#define is_uni_upper		Perl_is_uni_upper
#define is_uni_lower		Perl_is_uni_lower
#define is_uni_print		Perl_is_uni_print
#define is_uni_punct		Perl_is_uni_punct
#define is_uni_xdigit		Perl_is_uni_xdigit
#define to_uni_upper		Perl_to_uni_upper
#define to_uni_title		Perl_to_uni_title
#define to_uni_lower		Perl_to_uni_lower
#define is_uni_alnum_lc		Perl_is_uni_alnum_lc
#define is_uni_alnumc_lc	Perl_is_uni_alnumc_lc
#define is_uni_idfirst_lc	Perl_is_uni_idfirst_lc
#define is_uni_alpha_lc		Perl_is_uni_alpha_lc
#define is_uni_ascii_lc		Perl_is_uni_ascii_lc
#define is_uni_space_lc		Perl_is_uni_space_lc
#define is_uni_cntrl_lc		Perl_is_uni_cntrl_lc
#define is_uni_graph_lc		Perl_is_uni_graph_lc
#define is_uni_digit_lc		Perl_is_uni_digit_lc
#define is_uni_upper_lc		Perl_is_uni_upper_lc
#define is_uni_lower_lc		Perl_is_uni_lower_lc
#define is_uni_print_lc		Perl_is_uni_print_lc
#define is_uni_punct_lc		Perl_is_uni_punct_lc
#define is_uni_xdigit_lc	Perl_is_uni_xdigit_lc
#define to_uni_upper_lc		Perl_to_uni_upper_lc
#define to_uni_title_lc		Perl_to_uni_title_lc
#define to_uni_lower_lc		Perl_to_uni_lower_lc
#define is_utf8_char		Perl_is_utf8_char
#define is_utf8_string		Perl_is_utf8_string
#define is_utf8_alnum		Perl_is_utf8_alnum
#define is_utf8_alnumc		Perl_is_utf8_alnumc
#define is_utf8_idfirst		Perl_is_utf8_idfirst
#define is_utf8_alpha		Perl_is_utf8_alpha
#define is_utf8_ascii		Perl_is_utf8_ascii
#define is_utf8_space		Perl_is_utf8_space
#define is_utf8_cntrl		Perl_is_utf8_cntrl
#define is_utf8_digit		Perl_is_utf8_digit
#define is_utf8_graph		Perl_is_utf8_graph
#define is_utf8_upper		Perl_is_utf8_upper
#define is_utf8_lower		Perl_is_utf8_lower
#define is_utf8_print		Perl_is_utf8_print
#define is_utf8_punct		Perl_is_utf8_punct
#define is_utf8_xdigit		Perl_is_utf8_xdigit
#define is_utf8_mark		Perl_is_utf8_mark
#define jmaybe			Perl_jmaybe
#define keyword			Perl_keyword
#define leave_scope		Perl_leave_scope
#define lex_end			Perl_lex_end
#define lex_start		Perl_lex_start
#define linklist		Perl_linklist
#define list			Perl_list
#define listkids		Perl_listkids
#define load_module		Perl_load_module
#define vload_module		Perl_vload_module
#define localize		Perl_localize
#define looks_like_number	Perl_looks_like_number
#define magic_clearenv		Perl_magic_clearenv
#define magic_clear_all_env	Perl_magic_clear_all_env
#define magic_clearpack		Perl_magic_clearpack
#define magic_clearsig		Perl_magic_clearsig
#define magic_existspack	Perl_magic_existspack
#define magic_freeregexp	Perl_magic_freeregexp
#define magic_get		Perl_magic_get
#define magic_getarylen		Perl_magic_getarylen
#define magic_getdefelem	Perl_magic_getdefelem
#define magic_getglob		Perl_magic_getglob
#define magic_getnkeys		Perl_magic_getnkeys
#define magic_getpack		Perl_magic_getpack
#define magic_getpos		Perl_magic_getpos
#define magic_getsig		Perl_magic_getsig
#define magic_getsubstr		Perl_magic_getsubstr
#define magic_gettaint		Perl_magic_gettaint
#define magic_getuvar		Perl_magic_getuvar
#define magic_getvec		Perl_magic_getvec
#define magic_len		Perl_magic_len
#if defined(USE_THREADS)
#define magic_mutexfree		Perl_magic_mutexfree
#endif
#define magic_nextpack		Perl_magic_nextpack
#define magic_regdata_cnt	Perl_magic_regdata_cnt
#define magic_regdatum_get	Perl_magic_regdatum_get
#define magic_regdatum_set	Perl_magic_regdatum_set
#define magic_set		Perl_magic_set
#define magic_setamagic		Perl_magic_setamagic
#define magic_setarylen		Perl_magic_setarylen
#define magic_setbm		Perl_magic_setbm
#define magic_setdbline		Perl_magic_setdbline
#if defined(USE_LOCALE_COLLATE)
#define magic_setcollxfrm	Perl_magic_setcollxfrm
#endif
#define magic_setdefelem	Perl_magic_setdefelem
#define magic_setenv		Perl_magic_setenv
#define magic_setfm		Perl_magic_setfm
#define magic_setisa		Perl_magic_setisa
#define magic_setglob		Perl_magic_setglob
#define magic_setmglob		Perl_magic_setmglob
#define magic_setnkeys		Perl_magic_setnkeys
#define magic_setpack		Perl_magic_setpack
#define magic_setpos		Perl_magic_setpos
#define magic_setsig		Perl_magic_setsig
#define magic_setsubstr		Perl_magic_setsubstr
#define magic_settaint		Perl_magic_settaint
#define magic_setuvar		Perl_magic_setuvar
#define magic_setvec		Perl_magic_setvec
#define magic_set_all_env	Perl_magic_set_all_env
#define magic_sizepack		Perl_magic_sizepack
#define magic_wipepack		Perl_magic_wipepack
#define magicname		Perl_magicname
#define markstack_grow		Perl_markstack_grow
#if defined(USE_LOCALE_COLLATE)
#define mem_collxfrm		Perl_mem_collxfrm
#endif
#define mess			Perl_mess
#define vmess			Perl_vmess
#define qerror			Perl_qerror
#define mg_clear		Perl_mg_clear
#define mg_copy			Perl_mg_copy
#define mg_find			Perl_mg_find
#define mg_free			Perl_mg_free
#define mg_get			Perl_mg_get
#define mg_length		Perl_mg_length
#define mg_magical		Perl_mg_magical
#define mg_set			Perl_mg_set
#define mg_size			Perl_mg_size
#define mod			Perl_mod
#define mode_from_discipline	Perl_mode_from_discipline
#define moreswitches		Perl_moreswitches
#define my			Perl_my
#define my_atof			Perl_my_atof
#if !defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)
#define my_bcopy		Perl_my_bcopy
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
#define my_bzero		Perl_my_bzero
#endif
#define my_exit			Perl_my_exit
#define my_failure_exit		Perl_my_failure_exit
#define my_fflush_all		Perl_my_fflush_all
#define my_lstat		Perl_my_lstat
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
#define my_memcmp		Perl_my_memcmp
#endif
#if !defined(HAS_MEMSET)
#define my_memset		Perl_my_memset
#endif
#if !defined(PERL_OBJECT)
#define my_pclose		Perl_my_pclose
#define my_popen		Perl_my_popen
#endif
#define my_setenv		Perl_my_setenv
#define my_stat			Perl_my_stat
#if defined(MYSWAP)
#define my_swap			Perl_my_swap
#define my_htonl		Perl_my_htonl
#define my_ntohl		Perl_my_ntohl
#endif
#define my_unexec		Perl_my_unexec
#define newANONLIST		Perl_newANONLIST
#define newANONHASH		Perl_newANONHASH
#define newANONSUB		Perl_newANONSUB
#define newASSIGNOP		Perl_newASSIGNOP
#define newCONDOP		Perl_newCONDOP
#define newCONSTSUB		Perl_newCONSTSUB
#define newFORM			Perl_newFORM
#define newFOROP		Perl_newFOROP
#define newLOGOP		Perl_newLOGOP
#define newLOOPEX		Perl_newLOOPEX
#define newLOOPOP		Perl_newLOOPOP
#define newNULLLIST		Perl_newNULLLIST
#define newOP			Perl_newOP
#define newPROG			Perl_newPROG
#define newRANGE		Perl_newRANGE
#define newSLICEOP		Perl_newSLICEOP
#define newSTATEOP		Perl_newSTATEOP
#define newSUB			Perl_newSUB
#define newXS			Perl_newXS
#define newAV			Perl_newAV
#define newAVREF		Perl_newAVREF
#define newBINOP		Perl_newBINOP
#define newCVREF		Perl_newCVREF
#define newGVOP			Perl_newGVOP
#define newGVgen		Perl_newGVgen
#define newGVREF		Perl_newGVREF
#define newHVREF		Perl_newHVREF
#define newHV			Perl_newHV
#define newHVhv			Perl_newHVhv
#define newIO			Perl_newIO
#define newLISTOP		Perl_newLISTOP
#define newPADOP		Perl_newPADOP
#define newPMOP			Perl_newPMOP
#define newPVOP			Perl_newPVOP
#define newRV			Perl_newRV
#define newRV_noinc		Perl_newRV_noinc
#define newSV			Perl_newSV
#define newSVREF		Perl_newSVREF
#define newSVOP			Perl_newSVOP
#define newSViv			Perl_newSViv
#define newSVuv			Perl_newSVuv
#define newSVnv			Perl_newSVnv
#define newSVpv			Perl_newSVpv
#define newSVpvn		Perl_newSVpvn
#define newSVpvf		Perl_newSVpvf
#define vnewSVpvf		Perl_vnewSVpvf
#define newSVrv			Perl_newSVrv
#define newSVsv			Perl_newSVsv
#define newUNOP			Perl_newUNOP
#define newWHILEOP		Perl_newWHILEOP
#define new_stackinfo		Perl_new_stackinfo
#define nextargv		Perl_nextargv
#define ninstr			Perl_ninstr
#define oopsCV			Perl_oopsCV
#define op_free			Perl_op_free
#define package			Perl_package
#define pad_alloc		Perl_pad_alloc
#define pad_allocmy		Perl_pad_allocmy
#define pad_findmy		Perl_pad_findmy
#define oopsAV			Perl_oopsAV
#define oopsHV			Perl_oopsHV
#define pad_leavemy		Perl_pad_leavemy
#define pad_sv			Perl_pad_sv
#define pad_free		Perl_pad_free
#define pad_reset		Perl_pad_reset
#define pad_swipe		Perl_pad_swipe
#define peep			Perl_peep
#if defined(PERL_OBJECT)
#endif
#if defined(USE_THREADS)
#define new_struct_thread	Perl_new_struct_thread
#endif
#define call_atexit		Perl_call_atexit
#define call_argv		Perl_call_argv
#define call_method		Perl_call_method
#define call_pv			Perl_call_pv
#define call_sv			Perl_call_sv
#define eval_pv			Perl_eval_pv
#define eval_sv			Perl_eval_sv
#define get_sv			Perl_get_sv
#define get_av			Perl_get_av
#define get_hv			Perl_get_hv
#define get_cv			Perl_get_cv
#define init_i18nl10n		Perl_init_i18nl10n
#define init_i18nl14n		Perl_init_i18nl14n
#define new_collate		Perl_new_collate
#define new_ctype		Perl_new_ctype
#define new_numeric		Perl_new_numeric
#define set_numeric_local	Perl_set_numeric_local
#define set_numeric_radix	Perl_set_numeric_radix
#define set_numeric_standard	Perl_set_numeric_standard
#define require_pv		Perl_require_pv
#define pidgone			Perl_pidgone
#define pmflag			Perl_pmflag
#define pmruntime		Perl_pmruntime
#define pmtrans			Perl_pmtrans
#define pop_return		Perl_pop_return
#define pop_scope		Perl_pop_scope
#define prepend_elem		Perl_prepend_elem
#define push_return		Perl_push_return
#define push_scope		Perl_push_scope
#define ref			Perl_ref
#define refkids			Perl_refkids
#define regdump			Perl_regdump
#define pregexec		Perl_pregexec
#define pregfree		Perl_pregfree
#define pregcomp		Perl_pregcomp
#define re_intuit_start		Perl_re_intuit_start
#define re_intuit_string	Perl_re_intuit_string
#define regexec_flags		Perl_regexec_flags
#define regnext			Perl_regnext
#define regprop			Perl_regprop
#define repeatcpy		Perl_repeatcpy
#define rninstr			Perl_rninstr
#define rsignal			Perl_rsignal
#define rsignal_restore		Perl_rsignal_restore
#define rsignal_save		Perl_rsignal_save
#define rsignal_state		Perl_rsignal_state
#define rxres_free		Perl_rxres_free
#define rxres_restore		Perl_rxres_restore
#define rxres_save		Perl_rxres_save
#if !defined(HAS_RENAME)
#define same_dirent		Perl_same_dirent
#endif
#define savepv			Perl_savepv
#define savepvn			Perl_savepvn
#define savestack_grow		Perl_savestack_grow
#define save_aelem		Perl_save_aelem
#define save_alloc		Perl_save_alloc
#define save_aptr		Perl_save_aptr
#define save_ary		Perl_save_ary
#define save_clearsv		Perl_save_clearsv
#define save_delete		Perl_save_delete
#define save_destructor		Perl_save_destructor
#define save_destructor_x	Perl_save_destructor_x
#define save_freesv		Perl_save_freesv
#define save_freeop		Perl_save_freeop
#define save_freepv		Perl_save_freepv
#define save_generic_svref	Perl_save_generic_svref
#define save_generic_pvref	Perl_save_generic_pvref
#define save_gp			Perl_save_gp
#define save_hash		Perl_save_hash
#define save_helem		Perl_save_helem
#define save_hints		Perl_save_hints
#define save_hptr		Perl_save_hptr
#define save_I16		Perl_save_I16
#define save_I32		Perl_save_I32
#define save_I8			Perl_save_I8
#define save_int		Perl_save_int
#define save_item		Perl_save_item
#define save_iv			Perl_save_iv
#define save_list		Perl_save_list
#define save_long		Perl_save_long
#define save_mortalizesv	Perl_save_mortalizesv
#define save_nogv		Perl_save_nogv
#define save_op			Perl_save_op
#define save_scalar		Perl_save_scalar
#define save_pptr		Perl_save_pptr
#define save_vptr		Perl_save_vptr
#define save_re_context		Perl_save_re_context
#define save_padsv		Perl_save_padsv
#define save_sptr		Perl_save_sptr
#define save_svref		Perl_save_svref
#define save_threadsv		Perl_save_threadsv
#define sawparens		Perl_sawparens
#define scalar			Perl_scalar
#define scalarkids		Perl_scalarkids
#define scalarseq		Perl_scalarseq
#define scalarvoid		Perl_scalarvoid
#define scan_bin		Perl_scan_bin
#define scan_hex		Perl_scan_hex
#define scan_num		Perl_scan_num
#define scan_oct		Perl_scan_oct
#define scope			Perl_scope
#define screaminstr		Perl_screaminstr
#if !defined(VMS)
#define setenv_getix		Perl_setenv_getix
#endif
#define setdefout		Perl_setdefout
#define sharepvn		Perl_sharepvn
#define share_hek		Perl_share_hek
#define sighandler		Perl_sighandler
#define stack_grow		Perl_stack_grow
#define start_subparse		Perl_start_subparse
#define sub_crush_depth		Perl_sub_crush_depth
#define sv_2bool		Perl_sv_2bool
#define sv_2cv			Perl_sv_2cv
#define sv_2io			Perl_sv_2io
#define sv_2iv			Perl_sv_2iv
#define sv_2mortal		Perl_sv_2mortal
#define sv_2nv			Perl_sv_2nv
#define sv_2pv			Perl_sv_2pv
#define sv_2pvutf8		Perl_sv_2pvutf8
#define sv_2pvbyte		Perl_sv_2pvbyte
#define sv_2uv			Perl_sv_2uv
#define sv_iv			Perl_sv_iv
#define sv_uv			Perl_sv_uv
#define sv_nv			Perl_sv_nv
#define sv_pvn			Perl_sv_pvn
#define sv_pvutf8n		Perl_sv_pvutf8n
#define sv_pvbyten		Perl_sv_pvbyten
#define sv_true			Perl_sv_true
#define sv_add_arena		Perl_sv_add_arena
#define sv_backoff		Perl_sv_backoff
#define sv_bless		Perl_sv_bless
#define sv_catpvf		Perl_sv_catpvf
#define sv_vcatpvf		Perl_sv_vcatpvf
#define sv_catpv		Perl_sv_catpv
#define sv_catpvn		Perl_sv_catpvn
#define sv_catsv		Perl_sv_catsv
#define sv_chop			Perl_sv_chop
#define sv_clean_all		Perl_sv_clean_all
#define sv_clean_objs		Perl_sv_clean_objs
#define sv_clear		Perl_sv_clear
#define sv_cmp			Perl_sv_cmp
#define sv_cmp_locale		Perl_sv_cmp_locale
#if defined(USE_LOCALE_COLLATE)
#define sv_collxfrm		Perl_sv_collxfrm
#endif
#define sv_compile_2op		Perl_sv_compile_2op
#define sv_dec			Perl_sv_dec
#define sv_dump			Perl_sv_dump
#define sv_derived_from		Perl_sv_derived_from
#define sv_eq			Perl_sv_eq
#define sv_free			Perl_sv_free
#define sv_free_arenas		Perl_sv_free_arenas
#define sv_gets			Perl_sv_gets
#define sv_grow			Perl_sv_grow
#define sv_inc			Perl_sv_inc
#define sv_insert		Perl_sv_insert
#define sv_isa			Perl_sv_isa
#define sv_isobject		Perl_sv_isobject
#define sv_len			Perl_sv_len
#define sv_len_utf8		Perl_sv_len_utf8
#define sv_magic		Perl_sv_magic
#define sv_mortalcopy		Perl_sv_mortalcopy
#define sv_newmortal		Perl_sv_newmortal
#define sv_newref		Perl_sv_newref
#define sv_peek			Perl_sv_peek
#define sv_pos_u2b		Perl_sv_pos_u2b
#define sv_pos_b2u		Perl_sv_pos_b2u
#define sv_pvn_force		Perl_sv_pvn_force
#define sv_pvutf8n_force	Perl_sv_pvutf8n_force
#define sv_pvbyten_force	Perl_sv_pvbyten_force
#define sv_reftype		Perl_sv_reftype
#define sv_replace		Perl_sv_replace
#define sv_report_used		Perl_sv_report_used
#define sv_reset		Perl_sv_reset
#define sv_setpvf		Perl_sv_setpvf
#define sv_vsetpvf		Perl_sv_vsetpvf
#define sv_setiv		Perl_sv_setiv
#define sv_setpviv		Perl_sv_setpviv
#define sv_setuv		Perl_sv_setuv
#define sv_setnv		Perl_sv_setnv
#define sv_setref_iv		Perl_sv_setref_iv
#define sv_setref_nv		Perl_sv_setref_nv
#define sv_setref_pv		Perl_sv_setref_pv
#define sv_setref_pvn		Perl_sv_setref_pvn
#define sv_setpv		Perl_sv_setpv
#define sv_setpvn		Perl_sv_setpvn
#define sv_setsv		Perl_sv_setsv
#define sv_taint		Perl_sv_taint
#define sv_tainted		Perl_sv_tainted
#define sv_unmagic		Perl_sv_unmagic
#define sv_unref		Perl_sv_unref
#define sv_untaint		Perl_sv_untaint
#define sv_upgrade		Perl_sv_upgrade
#define sv_usepvn		Perl_sv_usepvn
#define sv_vcatpvfn		Perl_sv_vcatpvfn
#define sv_vsetpvfn		Perl_sv_vsetpvfn
#define str_to_version		Perl_str_to_version
#define swash_init		Perl_swash_init
#define swash_fetch		Perl_swash_fetch
#define taint_env		Perl_taint_env
#define taint_proper		Perl_taint_proper
#define to_utf8_lower		Perl_to_utf8_lower
#define to_utf8_upper		Perl_to_utf8_upper
#define to_utf8_title		Perl_to_utf8_title
#if defined(UNLINK_ALL_VERSIONS)
#define unlnk			Perl_unlnk
#endif
#if defined(USE_THREADS)
#define unlock_condpair		Perl_unlock_condpair
#endif
#define unsharepvn		Perl_unsharepvn
#define unshare_hek		Perl_unshare_hek
#define utilize			Perl_utilize
#define utf16_to_utf8		Perl_utf16_to_utf8
#define utf16_to_utf8_reversed	Perl_utf16_to_utf8_reversed
#define utf8_length		Perl_utf8_length
#define utf8_distance		Perl_utf8_distance
#define utf8_hop		Perl_utf8_hop
#define utf8_to_bytes		Perl_utf8_to_bytes
#define bytes_from_utf8		Perl_bytes_from_utf8
#define bytes_to_utf8		Perl_bytes_to_utf8
#define utf8_to_uv_simple	Perl_utf8_to_uv_simple
#define utf8_to_uv		Perl_utf8_to_uv
#define uv_to_utf8		Perl_uv_to_utf8
#define vivify_defelem		Perl_vivify_defelem
#define vivify_ref		Perl_vivify_ref
#define wait4pid		Perl_wait4pid
#define report_evil_fh		Perl_report_evil_fh
#define report_uninit		Perl_report_uninit
#define warn			Perl_warn
#define vwarn			Perl_vwarn
#define warner			Perl_warner
#define vwarner			Perl_vwarner
#define watch			Perl_watch
#define whichsig		Perl_whichsig
#define yyerror			Perl_yyerror
#ifdef USE_PURE_BISON
#define yylex_r			Perl_yylex_r
#endif
#define yylex			Perl_yylex
#define yyparse			Perl_yyparse
#define yywarn			Perl_yywarn
#if defined(MYMALLOC)
#define dump_mstats		Perl_dump_mstats
#define get_mstats		Perl_get_mstats
#endif
#define safesysmalloc		Perl_safesysmalloc
#define safesyscalloc		Perl_safesyscalloc
#define safesysrealloc		Perl_safesysrealloc
#define safesysfree		Perl_safesysfree
#if defined(LEAKTEST)
#define safexmalloc		Perl_safexmalloc
#define safexcalloc		Perl_safexcalloc
#define safexrealloc		Perl_safexrealloc
#define safexfree		Perl_safexfree
#endif
#if defined(PERL_GLOBAL_STRUCT)
#define GetVars			Perl_GetVars
#endif
#define runops_standard		Perl_runops_standard
#define runops_debug		Perl_runops_debug
#if defined(USE_THREADS)
#define sv_lock			Perl_sv_lock
#endif
#define sv_catpvf_mg		Perl_sv_catpvf_mg
#define sv_vcatpvf_mg		Perl_sv_vcatpvf_mg
#define sv_catpv_mg		Perl_sv_catpv_mg
#define sv_catpvn_mg		Perl_sv_catpvn_mg
#define sv_catsv_mg		Perl_sv_catsv_mg
#define sv_setpvf_mg		Perl_sv_setpvf_mg
#define sv_vsetpvf_mg		Perl_sv_vsetpvf_mg
#define sv_setiv_mg		Perl_sv_setiv_mg
#define sv_setpviv_mg		Perl_sv_setpviv_mg
#define sv_setuv_mg		Perl_sv_setuv_mg
#define sv_setnv_mg		Perl_sv_setnv_mg
#define sv_setpv_mg		Perl_sv_setpv_mg
#define sv_setpvn_mg		Perl_sv_setpvn_mg
#define sv_setsv_mg		Perl_sv_setsv_mg
#define sv_usepvn_mg		Perl_sv_usepvn_mg
#define get_vtbl		Perl_get_vtbl
#define pv_display		Perl_pv_display
#define dump_indent		Perl_dump_indent
#define dump_vindent		Perl_dump_vindent
#define do_gv_dump		Perl_do_gv_dump
#define do_gvgv_dump		Perl_do_gvgv_dump
#define do_hv_dump		Perl_do_hv_dump
#define do_magic_dump		Perl_do_magic_dump
#define do_op_dump		Perl_do_op_dump
#define do_pmop_dump		Perl_do_pmop_dump
#define do_sv_dump		Perl_do_sv_dump
#define magic_dump		Perl_magic_dump
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
#define default_protect		Perl_default_protect
#define vdefault_protect	Perl_vdefault_protect
#endif
#define reginitcolors		Perl_reginitcolors
#define sv_2pv_nolen		Perl_sv_2pv_nolen
#define sv_2pvutf8_nolen	Perl_sv_2pvutf8_nolen
#define sv_2pvbyte_nolen	Perl_sv_2pvbyte_nolen
#define sv_pv			Perl_sv_pv
#define sv_pvutf8		Perl_sv_pvutf8
#define sv_pvbyte		Perl_sv_pvbyte
#define sv_utf8_upgrade		Perl_sv_utf8_upgrade
#define sv_utf8_downgrade	Perl_sv_utf8_downgrade
#define sv_utf8_encode		Perl_sv_utf8_encode
#define sv_utf8_decode		Perl_sv_utf8_decode
#define sv_force_normal		Perl_sv_force_normal
#define sv_add_backref		Perl_sv_add_backref
#define sv_del_backref		Perl_sv_del_backref
#define tmps_grow		Perl_tmps_grow
#define sv_rvweaken		Perl_sv_rvweaken
#define magic_killbackrefs	Perl_magic_killbackrefs
#define newANONATTRSUB		Perl_newANONATTRSUB
#define newATTRSUB		Perl_newATTRSUB
#define newMYSUB		Perl_newMYSUB
#define my_attrs		Perl_my_attrs
#define boot_core_xsutils	Perl_boot_core_xsutils
#if defined(USE_ITHREADS)
#define cx_dup			Perl_cx_dup
#define si_dup			Perl_si_dup
#define ss_dup			Perl_ss_dup
#define any_dup			Perl_any_dup
#define he_dup			Perl_he_dup
#define re_dup			Perl_re_dup
#define fp_dup			Perl_fp_dup
#define dirp_dup		Perl_dirp_dup
#define gp_dup			Perl_gp_dup
#define mg_dup			Perl_mg_dup
#define sv_dup			Perl_sv_dup
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_dup		Perl_sys_intern_dup
#endif
#define ptr_table_new		Perl_ptr_table_new
#define ptr_table_fetch		Perl_ptr_table_fetch
#define ptr_table_store		Perl_ptr_table_store
#define ptr_table_split		Perl_ptr_table_split
#define ptr_table_clear		Perl_ptr_table_clear
#define ptr_table_free		Perl_ptr_table_free
#endif
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_clear	Perl_sys_intern_clear
#define sys_intern_init		Perl_sys_intern_init
#endif
#if defined(PERL_OBJECT)
#else
#endif
#if defined(PERL_IN_AV_C) || defined(PERL_DECL_PROT)
#define avhv_index_sv		S_avhv_index_sv
#define avhv_index		S_avhv_index
#endif
#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
#define do_trans_simple		S_do_trans_simple
#define do_trans_count		S_do_trans_count
#define do_trans_complex	S_do_trans_complex
#define do_trans_simple_utf8	S_do_trans_simple_utf8
#define do_trans_count_utf8	S_do_trans_count_utf8
#define do_trans_complex_utf8	S_do_trans_complex_utf8
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
#define gv_init_sv		S_gv_init_sv
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
#define hsplit			S_hsplit
#define hfreeentries		S_hfreeentries
#define more_he			S_more_he
#define new_he			S_new_he
#define del_he			S_del_he
#define save_hek		S_save_hek
#define hv_magic_check		S_hv_magic_check
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
#define save_magic		S_save_magic
#define magic_methpack		S_magic_methpack
#define magic_methcall		S_magic_methcall
#endif
#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
#define list_assignment		S_list_assignment
#define bad_type		S_bad_type
#define cop_free		S_cop_free
#define modkids			S_modkids
#define no_bareword_allowed	S_no_bareword_allowed
#define no_fh_allowed		S_no_fh_allowed
#define scalarboolean		S_scalarboolean
#define too_few_arguments	S_too_few_arguments
#define too_many_arguments	S_too_many_arguments
#define trlist_upgrade		S_trlist_upgrade
#define op_clear		S_op_clear
#define null			S_null
#define pad_addlex		S_pad_addlex
#define pad_findlex		S_pad_findlex
#define newDEFSVOP		S_newDEFSVOP
#define new_logop		S_new_logop
#define simplify_sort		S_simplify_sort
#define is_handle_constructor	S_is_handle_constructor
#define gv_ename		S_gv_ename
#define cv_dump			S_cv_dump
#define cv_clone2		S_cv_clone2
#define scalar_mod_type		S_scalar_mod_type
#define my_kid			S_my_kid
#define dup_attrlist		S_dup_attrlist
#define apply_attrs		S_apply_attrs
#  if defined(PL_OP_SLAB_ALLOC)
#define Slab_Alloc		S_Slab_Alloc
#  endif
#endif
#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
#define find_beginning		S_find_beginning
#define forbid_setid		S_forbid_setid
#define incpush			S_incpush
#define init_interp		S_init_interp
#define init_ids		S_init_ids
#define init_lexer		S_init_lexer
#define init_main_stash		S_init_main_stash
#define init_perllib		S_init_perllib
#define init_postdump_symbols	S_init_postdump_symbols
#define init_predump_symbols	S_init_predump_symbols
#define my_exit_jump		S_my_exit_jump
#define nuke_stacks		S_nuke_stacks
#define open_script		S_open_script
#define usage			S_usage
#define validate_suid		S_validate_suid
#  if defined(IAMSUID)
#define fd_on_nosuid_fs		S_fd_on_nosuid_fs
#  endif
#define parse_body		S_parse_body
#define run_body		S_run_body
#define call_body		S_call_body
#define call_list_body		S_call_list_body
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
#define vparse_body		S_vparse_body
#define vrun_body		S_vrun_body
#define vcall_body		S_vcall_body
#define vcall_list_body		S_vcall_list_body
#endif
#  if defined(USE_THREADS)
#define init_main_thread	S_init_main_thread
#  endif
#endif
#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
#define doencodes		S_doencodes
#define refto			S_refto
#define seed			S_seed
#define mul128			S_mul128
#define is_an_int		S_is_an_int
#define div128			S_div128
#endif
#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
#define docatch			S_docatch
#define docatch_body		S_docatch_body
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
#define vdocatch_body		S_vdocatch_body
#endif
#define dofindlabel		S_dofindlabel
#define doparseform		S_doparseform
#define dopoptoeval		S_dopoptoeval
#define dopoptolabel		S_dopoptolabel
#define dopoptoloop		S_dopoptoloop
#define dopoptosub		S_dopoptosub
#define dopoptosub_at		S_dopoptosub_at
#define save_lines		S_save_lines
#define doeval			S_doeval
#define doopen_pmc		S_doopen_pmc
#define qsortsv			S_qsortsv
#endif
#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
#define do_maybe_phash		S_do_maybe_phash
#define do_oddball		S_do_oddball
#define get_db_sub		S_get_db_sub
#define method_common		S_method_common
#endif
#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
#define doform			S_doform
#define emulate_eaccess		S_emulate_eaccess
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#define dooneliner		S_dooneliner
#  endif
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
#define reg			S_reg
#define reganode		S_reganode
#define regatom			S_regatom
#define regbranch		S_regbranch
#define reguni			S_reguni
#define regclass		S_regclass
#define regclassutf8		S_regclassutf8
#define regcurly		S_regcurly
#define reg_node		S_reg_node
#define regpiece		S_regpiece
#define reginsert		S_reginsert
#define regoptail		S_regoptail
#define regtail			S_regtail
#define regwhite		S_regwhite
#define nextchar		S_nextchar
#define dumpuntil		S_dumpuntil
#define put_byte		S_put_byte
#define scan_commit		S_scan_commit
#define cl_anything		S_cl_anything
#define cl_is_anything		S_cl_is_anything
#define cl_init			S_cl_init
#define cl_init_zero		S_cl_init_zero
#define cl_and			S_cl_and
#define cl_or			S_cl_or
#define study_chunk		S_study_chunk
#define add_data		S_add_data
#define re_croak2		S_re_croak2
#define regpposixcc		S_regpposixcc
#define checkposixcc		S_checkposixcc
#endif
#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
#define regmatch		S_regmatch
#define regrepeat		S_regrepeat
#define regrepeat_hard		S_regrepeat_hard
#define regtry			S_regtry
#define reginclass		S_reginclass
#define reginclassutf8		S_reginclassutf8
#define regcppush		S_regcppush
#define regcppop		S_regcppop
#define regcp_set_to		S_regcp_set_to
#define cache_re		S_cache_re
#define reghop			S_reghop
#define reghopmaybe		S_reghopmaybe
#define find_byclass		S_find_byclass
#endif
#if defined(PERL_IN_RUN_C) || defined(PERL_DECL_PROT)
#define debprof			S_debprof
#endif
#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
#define save_scalar_at		S_save_scalar_at
#endif
#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#define asIV			S_asIV
#define asUV			S_asUV
#define more_sv			S_more_sv
#define more_xiv		S_more_xiv
#define more_xnv		S_more_xnv
#define more_xpv		S_more_xpv
#define more_xpviv		S_more_xpviv
#define more_xpvnv		S_more_xpvnv
#define more_xpvcv		S_more_xpvcv
#define more_xpvav		S_more_xpvav
#define more_xpvhv		S_more_xpvhv
#define more_xpvmg		S_more_xpvmg
#define more_xpvlv		S_more_xpvlv
#define more_xpvbm		S_more_xpvbm
#define more_xrv		S_more_xrv
#define new_xiv			S_new_xiv
#define new_xnv			S_new_xnv
#define new_xpv			S_new_xpv
#define new_xpviv		S_new_xpviv
#define new_xpvnv		S_new_xpvnv
#define new_xpvcv		S_new_xpvcv
#define new_xpvav		S_new_xpvav
#define new_xpvhv		S_new_xpvhv
#define new_xpvmg		S_new_xpvmg
#define new_xpvlv		S_new_xpvlv
#define new_xpvbm		S_new_xpvbm
#define new_xrv			S_new_xrv
#define del_xiv			S_del_xiv
#define del_xnv			S_del_xnv
#define del_xpv			S_del_xpv
#define del_xpviv		S_del_xpviv
#define del_xpvnv		S_del_xpvnv
#define del_xpvcv		S_del_xpvcv
#define del_xpvav		S_del_xpvav
#define del_xpvhv		S_del_xpvhv
#define del_xpvmg		S_del_xpvmg
#define del_xpvlv		S_del_xpvlv
#define del_xpvbm		S_del_xpvbm
#define del_xrv			S_del_xrv
#define sv_unglob		S_sv_unglob
#define not_a_number		S_not_a_number
#define visit			S_visit
#  if defined(DEBUGGING)
#define del_sv			S_del_sv
#  endif
#endif
#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
#define check_uni		S_check_uni
#define force_next		S_force_next
#define force_version		S_force_version
#define force_word		S_force_word
#define tokeq			S_tokeq
#define scan_const		S_scan_const
#define scan_formline		S_scan_formline
#define scan_heredoc		S_scan_heredoc
#define scan_ident		S_scan_ident
#define scan_inputsymbol	S_scan_inputsymbol
#define scan_pat		S_scan_pat
#define scan_str		S_scan_str
#define scan_subst		S_scan_subst
#define scan_trans		S_scan_trans
#define scan_word		S_scan_word
#define skipspace		S_skipspace
#define swallow_bom		S_swallow_bom
#define checkcomma		S_checkcomma
#define force_ident		S_force_ident
#define incline			S_incline
#define intuit_method		S_intuit_method
#define intuit_more		S_intuit_more
#define lop			S_lop
#define missingterm		S_missingterm
#define no_op			S_no_op
#define set_csh			S_set_csh
#define sublex_done		S_sublex_done
#define sublex_push		S_sublex_push
#define sublex_start		S_sublex_start
#define filter_gets		S_filter_gets
#define find_in_my_stash	S_find_in_my_stash
#define new_constant		S_new_constant
#define ao			S_ao
#define depcom			S_depcom
#define incl_perldb		S_incl_perldb
#if 0
#define utf16_textfilter	S_utf16_textfilter
#define utf16rev_textfilter	S_utf16rev_textfilter
#endif
#  if defined(CRIPPLED_CC)
#define uni			S_uni
#  endif
#  if defined(PERL_CR_FILTER)
#define cr_textfilter		S_cr_textfilter
#  endif
#endif
#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
#define isa_lookup		S_isa_lookup
#endif
#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
#define stdize_locale		S_stdize_locale
#define mess_alloc		S_mess_alloc
#  if defined(LEAKTEST)
#define xstat			S_xstat
#  endif
#endif
#if defined(PERL_OBJECT)
#endif
#define ck_anoncode		Perl_ck_anoncode
#define ck_bitop		Perl_ck_bitop
#define ck_concat		Perl_ck_concat
#define ck_defined		Perl_ck_defined
#define ck_delete		Perl_ck_delete
#define ck_eof			Perl_ck_eof
#define ck_eval			Perl_ck_eval
#define ck_exec			Perl_ck_exec
#define ck_exists		Perl_ck_exists
#define ck_exit			Perl_ck_exit
#define ck_ftst			Perl_ck_ftst
#define ck_fun			Perl_ck_fun
#define ck_glob			Perl_ck_glob
#define ck_grep			Perl_ck_grep
#define ck_index		Perl_ck_index
#define ck_join			Perl_ck_join
#define ck_lengthconst		Perl_ck_lengthconst
#define ck_lfun			Perl_ck_lfun
#define ck_listiob		Perl_ck_listiob
#define ck_match		Perl_ck_match
#define ck_method		Perl_ck_method
#define ck_null			Perl_ck_null
#define ck_open			Perl_ck_open
#define ck_repeat		Perl_ck_repeat
#define ck_require		Perl_ck_require
#define ck_return		Perl_ck_return
#define ck_rfun			Perl_ck_rfun
#define ck_rvconst		Perl_ck_rvconst
#define ck_sassign		Perl_ck_sassign
#define ck_select		Perl_ck_select
#define ck_shift		Perl_ck_shift
#define ck_sort			Perl_ck_sort
#define ck_spair		Perl_ck_spair
#define ck_split		Perl_ck_split
#define ck_subr			Perl_ck_subr
#define ck_substr		Perl_ck_substr
#define ck_svconst		Perl_ck_svconst
#define ck_trunc		Perl_ck_trunc
#define pp_aassign		Perl_pp_aassign
#define pp_abs			Perl_pp_abs
#define pp_accept		Perl_pp_accept
#define pp_add			Perl_pp_add
#define pp_aelem		Perl_pp_aelem
#define pp_aelemfast		Perl_pp_aelemfast
#define pp_alarm		Perl_pp_alarm
#define pp_and			Perl_pp_and
#define pp_andassign		Perl_pp_andassign
#define pp_anoncode		Perl_pp_anoncode
#define pp_anonhash		Perl_pp_anonhash
#define pp_anonlist		Perl_pp_anonlist
#define pp_aslice		Perl_pp_aslice
#define pp_atan2		Perl_pp_atan2
#define pp_av2arylen		Perl_pp_av2arylen
#define pp_backtick		Perl_pp_backtick
#define pp_bind			Perl_pp_bind
#define pp_binmode		Perl_pp_binmode
#define pp_bit_and		Perl_pp_bit_and
#define pp_bit_or		Perl_pp_bit_or
#define pp_bit_xor		Perl_pp_bit_xor
#define pp_bless		Perl_pp_bless
#define pp_caller		Perl_pp_caller
#define pp_chdir		Perl_pp_chdir
#define pp_chmod		Perl_pp_chmod
#define pp_chomp		Perl_pp_chomp
#define pp_chop			Perl_pp_chop
#define pp_chown		Perl_pp_chown
#define pp_chr			Perl_pp_chr
#define pp_chroot		Perl_pp_chroot
#define pp_close		Perl_pp_close
#define pp_closedir		Perl_pp_closedir
#define pp_complement		Perl_pp_complement
#define pp_concat		Perl_pp_concat
#define pp_cond_expr		Perl_pp_cond_expr
#define pp_connect		Perl_pp_connect
#define pp_const		Perl_pp_const
#define pp_cos			Perl_pp_cos
#define pp_crypt		Perl_pp_crypt
#define pp_dbmclose		Perl_pp_dbmclose
#define pp_dbmopen		Perl_pp_dbmopen
#define pp_dbstate		Perl_pp_dbstate
#define pp_defined		Perl_pp_defined
#define pp_delete		Perl_pp_delete
#define pp_die			Perl_pp_die
#define pp_divide		Perl_pp_divide
#define pp_dofile		Perl_pp_dofile
#define pp_dump			Perl_pp_dump
#define pp_each			Perl_pp_each
#define pp_egrent		Perl_pp_egrent
#define pp_ehostent		Perl_pp_ehostent
#define pp_enetent		Perl_pp_enetent
#define pp_enter		Perl_pp_enter
#define pp_entereval		Perl_pp_entereval
#define pp_enteriter		Perl_pp_enteriter
#define pp_enterloop		Perl_pp_enterloop
#define pp_entersub		Perl_pp_entersub
#define pp_entertry		Perl_pp_entertry
#define pp_enterwrite		Perl_pp_enterwrite
#define pp_eof			Perl_pp_eof
#define pp_eprotoent		Perl_pp_eprotoent
#define pp_epwent		Perl_pp_epwent
#define pp_eq			Perl_pp_eq
#define pp_eservent		Perl_pp_eservent
#define pp_exec			Perl_pp_exec
#define pp_exists		Perl_pp_exists
#define pp_exit			Perl_pp_exit
#define pp_exp			Perl_pp_exp
#define pp_fcntl		Perl_pp_fcntl
#define pp_fileno		Perl_pp_fileno
#define pp_flip			Perl_pp_flip
#define pp_flock		Perl_pp_flock
#define pp_flop			Perl_pp_flop
#define pp_fork			Perl_pp_fork
#define pp_formline		Perl_pp_formline
#define pp_ftatime		Perl_pp_ftatime
#define pp_ftbinary		Perl_pp_ftbinary
#define pp_ftblk		Perl_pp_ftblk
#define pp_ftchr		Perl_pp_ftchr
#define pp_ftctime		Perl_pp_ftctime
#define pp_ftdir		Perl_pp_ftdir
#define pp_fteexec		Perl_pp_fteexec
#define pp_fteowned		Perl_pp_fteowned
#define pp_fteread		Perl_pp_fteread
#define pp_ftewrite		Perl_pp_ftewrite
#define pp_ftfile		Perl_pp_ftfile
#define pp_ftis			Perl_pp_ftis
#define pp_ftlink		Perl_pp_ftlink
#define pp_ftmtime		Perl_pp_ftmtime
#define pp_ftpipe		Perl_pp_ftpipe
#define pp_ftrexec		Perl_pp_ftrexec
#define pp_ftrowned		Perl_pp_ftrowned
#define pp_ftrread		Perl_pp_ftrread
#define pp_ftrwrite		Perl_pp_ftrwrite
#define pp_ftsgid		Perl_pp_ftsgid
#define pp_ftsize		Perl_pp_ftsize
#define pp_ftsock		Perl_pp_ftsock
#define pp_ftsuid		Perl_pp_ftsuid
#define pp_ftsvtx		Perl_pp_ftsvtx
#define pp_fttext		Perl_pp_fttext
#define pp_fttty		Perl_pp_fttty
#define pp_ftzero		Perl_pp_ftzero
#define pp_ge			Perl_pp_ge
#define pp_gelem		Perl_pp_gelem
#define pp_getc			Perl_pp_getc
#define pp_getlogin		Perl_pp_getlogin
#define pp_getpeername		Perl_pp_getpeername
#define pp_getpgrp		Perl_pp_getpgrp
#define pp_getppid		Perl_pp_getppid
#define pp_getpriority		Perl_pp_getpriority
#define pp_getsockname		Perl_pp_getsockname
#define pp_ggrent		Perl_pp_ggrent
#define pp_ggrgid		Perl_pp_ggrgid
#define pp_ggrnam		Perl_pp_ggrnam
#define pp_ghbyaddr		Perl_pp_ghbyaddr
#define pp_ghbyname		Perl_pp_ghbyname
#define pp_ghostent		Perl_pp_ghostent
#define pp_glob			Perl_pp_glob
#define pp_gmtime		Perl_pp_gmtime
#define pp_gnbyaddr		Perl_pp_gnbyaddr
#define pp_gnbyname		Perl_pp_gnbyname
#define pp_gnetent		Perl_pp_gnetent
#define pp_goto			Perl_pp_goto
#define pp_gpbyname		Perl_pp_gpbyname
#define pp_gpbynumber		Perl_pp_gpbynumber
#define pp_gprotoent		Perl_pp_gprotoent
#define pp_gpwent		Perl_pp_gpwent
#define pp_gpwnam		Perl_pp_gpwnam
#define pp_gpwuid		Perl_pp_gpwuid
#define pp_grepstart		Perl_pp_grepstart
#define pp_grepwhile		Perl_pp_grepwhile
#define pp_gsbyname		Perl_pp_gsbyname
#define pp_gsbyport		Perl_pp_gsbyport
#define pp_gservent		Perl_pp_gservent
#define pp_gsockopt		Perl_pp_gsockopt
#define pp_gt			Perl_pp_gt
#define pp_gv			Perl_pp_gv
#define pp_gvsv			Perl_pp_gvsv
#define pp_helem		Perl_pp_helem
#define pp_hex			Perl_pp_hex
#define pp_hslice		Perl_pp_hslice
#define pp_i_add		Perl_pp_i_add
#define pp_i_divide		Perl_pp_i_divide
#define pp_i_eq			Perl_pp_i_eq
#define pp_i_ge			Perl_pp_i_ge
#define pp_i_gt			Perl_pp_i_gt
#define pp_i_le			Perl_pp_i_le
#define pp_i_lt			Perl_pp_i_lt
#define pp_i_modulo		Perl_pp_i_modulo
#define pp_i_multiply		Perl_pp_i_multiply
#define pp_i_ncmp		Perl_pp_i_ncmp
#define pp_i_ne			Perl_pp_i_ne
#define pp_i_negate		Perl_pp_i_negate
#define pp_i_subtract		Perl_pp_i_subtract
#define pp_index		Perl_pp_index
#define pp_int			Perl_pp_int
#define pp_ioctl		Perl_pp_ioctl
#define pp_iter			Perl_pp_iter
#define pp_join			Perl_pp_join
#define pp_keys			Perl_pp_keys
#define pp_kill			Perl_pp_kill
#define pp_last			Perl_pp_last
#define pp_lc			Perl_pp_lc
#define pp_lcfirst		Perl_pp_lcfirst
#define pp_le			Perl_pp_le
#define pp_leave		Perl_pp_leave
#define pp_leaveeval		Perl_pp_leaveeval
#define pp_leaveloop		Perl_pp_leaveloop
#define pp_leavesub		Perl_pp_leavesub
#define pp_leavesublv		Perl_pp_leavesublv
#define pp_leavetry		Perl_pp_leavetry
#define pp_leavewrite		Perl_pp_leavewrite
#define pp_left_shift		Perl_pp_left_shift
#define pp_length		Perl_pp_length
#define pp_lineseq		Perl_pp_lineseq
#define pp_link			Perl_pp_link
#define pp_list			Perl_pp_list
#define pp_listen		Perl_pp_listen
#define pp_localtime		Perl_pp_localtime
#define pp_lock			Perl_pp_lock
#define pp_log			Perl_pp_log
#define pp_lslice		Perl_pp_lslice
#define pp_lstat		Perl_pp_lstat
#define pp_lt			Perl_pp_lt
#define pp_mapstart		Perl_pp_mapstart
#define pp_mapwhile		Perl_pp_mapwhile
#define pp_match		Perl_pp_match
#define pp_method		Perl_pp_method
#define pp_method_named		Perl_pp_method_named
#define pp_mkdir		Perl_pp_mkdir
#define pp_modulo		Perl_pp_modulo
#define pp_msgctl		Perl_pp_msgctl
#define pp_msgget		Perl_pp_msgget
#define pp_msgrcv		Perl_pp_msgrcv
#define pp_msgsnd		Perl_pp_msgsnd
#define pp_multiply		Perl_pp_multiply
#define pp_ncmp			Perl_pp_ncmp
#define pp_ne			Perl_pp_ne
#define pp_negate		Perl_pp_negate
#define pp_next			Perl_pp_next
#define pp_nextstate		Perl_pp_nextstate
#define pp_not			Perl_pp_not
#define pp_null			Perl_pp_null
#define pp_oct			Perl_pp_oct
#define pp_open			Perl_pp_open
#define pp_open_dir		Perl_pp_open_dir
#define pp_or			Perl_pp_or
#define pp_orassign		Perl_pp_orassign
#define pp_ord			Perl_pp_ord
#define pp_pack			Perl_pp_pack
#define pp_padany		Perl_pp_padany
#define pp_padav		Perl_pp_padav
#define pp_padhv		Perl_pp_padhv
#define pp_padsv		Perl_pp_padsv
#define pp_pipe_op		Perl_pp_pipe_op
#define pp_pop			Perl_pp_pop
#define pp_pos			Perl_pp_pos
#define pp_postdec		Perl_pp_postdec
#define pp_postinc		Perl_pp_postinc
#define pp_pow			Perl_pp_pow
#define pp_predec		Perl_pp_predec
#define pp_preinc		Perl_pp_preinc
#define pp_print		Perl_pp_print
#define pp_prototype		Perl_pp_prototype
#define pp_prtf			Perl_pp_prtf
#define pp_push			Perl_pp_push
#define pp_pushmark		Perl_pp_pushmark
#define pp_pushre		Perl_pp_pushre
#define pp_qr			Perl_pp_qr
#define pp_quotemeta		Perl_pp_quotemeta
#define pp_rand			Perl_pp_rand
#define pp_range		Perl_pp_range
#define pp_rcatline		Perl_pp_rcatline
#define pp_read			Perl_pp_read
#define pp_readdir		Perl_pp_readdir
#define pp_readline		Perl_pp_readline
#define pp_readlink		Perl_pp_readlink
#define pp_recv			Perl_pp_recv
#define pp_redo			Perl_pp_redo
#define pp_ref			Perl_pp_ref
#define pp_refgen		Perl_pp_refgen
#define pp_regcmaybe		Perl_pp_regcmaybe
#define pp_regcomp		Perl_pp_regcomp
#define pp_regcreset		Perl_pp_regcreset
#define pp_rename		Perl_pp_rename
#define pp_repeat		Perl_pp_repeat
#define pp_require		Perl_pp_require
#define pp_reset		Perl_pp_reset
#define pp_return		Perl_pp_return
#define pp_reverse		Perl_pp_reverse
#define pp_rewinddir		Perl_pp_rewinddir
#define pp_right_shift		Perl_pp_right_shift
#define pp_rindex		Perl_pp_rindex
#define pp_rmdir		Perl_pp_rmdir
#define pp_rv2av		Perl_pp_rv2av
#define pp_rv2cv		Perl_pp_rv2cv
#define pp_rv2gv		Perl_pp_rv2gv
#define pp_rv2hv		Perl_pp_rv2hv
#define pp_rv2sv		Perl_pp_rv2sv
#define pp_sassign		Perl_pp_sassign
#define pp_scalar		Perl_pp_scalar
#define pp_schomp		Perl_pp_schomp
#define pp_schop		Perl_pp_schop
#define pp_scmp			Perl_pp_scmp
#define pp_scope		Perl_pp_scope
#define pp_seek			Perl_pp_seek
#define pp_seekdir		Perl_pp_seekdir
#define pp_select		Perl_pp_select
#define pp_semctl		Perl_pp_semctl
#define pp_semget		Perl_pp_semget
#define pp_semop		Perl_pp_semop
#define pp_send			Perl_pp_send
#define pp_seq			Perl_pp_seq
#define pp_setpgrp		Perl_pp_setpgrp
#define pp_setpriority		Perl_pp_setpriority
#define pp_setstate		Perl_pp_setstate
#define pp_sge			Perl_pp_sge
#define pp_sgrent		Perl_pp_sgrent
#define pp_sgt			Perl_pp_sgt
#define pp_shift		Perl_pp_shift
#define pp_shmctl		Perl_pp_shmctl
#define pp_shmget		Perl_pp_shmget
#define pp_shmread		Perl_pp_shmread
#define pp_shmwrite		Perl_pp_shmwrite
#define pp_shostent		Perl_pp_shostent
#define pp_shutdown		Perl_pp_shutdown
#define pp_sin			Perl_pp_sin
#define pp_sle			Perl_pp_sle
#define pp_sleep		Perl_pp_sleep
#define pp_slt			Perl_pp_slt
#define pp_sne			Perl_pp_sne
#define pp_snetent		Perl_pp_snetent
#define pp_socket		Perl_pp_socket
#define pp_sockpair		Perl_pp_sockpair
#define pp_sort			Perl_pp_sort
#define pp_splice		Perl_pp_splice
#define pp_split		Perl_pp_split
#define pp_sprintf		Perl_pp_sprintf
#define pp_sprotoent		Perl_pp_sprotoent
#define pp_spwent		Perl_pp_spwent
#define pp_sqrt			Perl_pp_sqrt
#define pp_srand		Perl_pp_srand
#define pp_srefgen		Perl_pp_srefgen
#define pp_sselect		Perl_pp_sselect
#define pp_sservent		Perl_pp_sservent
#define pp_ssockopt		Perl_pp_ssockopt
#define pp_stat			Perl_pp_stat
#define pp_stringify		Perl_pp_stringify
#define pp_stub			Perl_pp_stub
#define pp_study		Perl_pp_study
#define pp_subst		Perl_pp_subst
#define pp_substcont		Perl_pp_substcont
#define pp_substr		Perl_pp_substr
#define pp_subtract		Perl_pp_subtract
#define pp_symlink		Perl_pp_symlink
#define pp_syscall		Perl_pp_syscall
#define pp_sysopen		Perl_pp_sysopen
#define pp_sysread		Perl_pp_sysread
#define pp_sysseek		Perl_pp_sysseek
#define pp_system		Perl_pp_system
#define pp_syswrite		Perl_pp_syswrite
#define pp_tell			Perl_pp_tell
#define pp_telldir		Perl_pp_telldir
#define pp_threadsv		Perl_pp_threadsv
#define pp_tie			Perl_pp_tie
#define pp_tied			Perl_pp_tied
#define pp_time			Perl_pp_time
#define pp_tms			Perl_pp_tms
#define pp_trans		Perl_pp_trans
#define pp_truncate		Perl_pp_truncate
#define pp_uc			Perl_pp_uc
#define pp_ucfirst		Perl_pp_ucfirst
#define pp_umask		Perl_pp_umask
#define pp_undef		Perl_pp_undef
#define pp_unlink		Perl_pp_unlink
#define pp_unpack		Perl_pp_unpack
#define pp_unshift		Perl_pp_unshift
#define pp_unstack		Perl_pp_unstack
#define pp_untie		Perl_pp_untie
#define pp_utime		Perl_pp_utime
#define pp_values		Perl_pp_values
#define pp_vec			Perl_pp_vec
#define pp_wait			Perl_pp_wait
#define pp_waitpid		Perl_pp_waitpid
#define pp_wantarray		Perl_pp_wantarray
#define pp_warn			Perl_pp_warn
#define pp_xor			Perl_pp_xor

#else	/* PERL_IMPLICIT_CONTEXT */

#if defined(PERL_IMPLICIT_SYS)
#endif
#if defined(USE_ITHREADS)
#  if defined(PERL_IMPLICIT_SYS)
#  endif
#endif
#if defined(MYMALLOC)
#define malloced_size		Perl_malloced_size
#endif
#define get_context		Perl_get_context
#define set_context		Perl_set_context
#if defined(PERL_OBJECT)
#ifndef __BORLANDC__
#endif
#endif
#if defined(PERL_OBJECT)
#else
#endif
#define amagic_call(a,b,c,d)	Perl_amagic_call(aTHX_ a,b,c,d)
#define Gv_AMupdate(a)		Perl_Gv_AMupdate(aTHX_ a)
#define append_elem(a,b,c)	Perl_append_elem(aTHX_ a,b,c)
#define append_list(a,b,c)	Perl_append_list(aTHX_ a,b,c)
#define apply(a,b,c)		Perl_apply(aTHX_ a,b,c)
#define apply_attrs_string(a,b,c,d)	Perl_apply_attrs_string(aTHX_ a,b,c,d)
#define avhv_delete_ent(a,b,c,d)	Perl_avhv_delete_ent(aTHX_ a,b,c,d)
#define avhv_exists_ent(a,b,c)	Perl_avhv_exists_ent(aTHX_ a,b,c)
#define avhv_fetch_ent(a,b,c,d)	Perl_avhv_fetch_ent(aTHX_ a,b,c,d)
#define avhv_store_ent(a,b,c,d)	Perl_avhv_store_ent(aTHX_ a,b,c,d)
#define avhv_iternext(a)	Perl_avhv_iternext(aTHX_ a)
#define avhv_iterval(a,b)	Perl_avhv_iterval(aTHX_ a,b)
#define avhv_keys(a)		Perl_avhv_keys(aTHX_ a)
#define av_clear(a)		Perl_av_clear(aTHX_ a)
#define av_delete(a,b,c)	Perl_av_delete(aTHX_ a,b,c)
#define av_exists(a,b)		Perl_av_exists(aTHX_ a,b)
#define av_extend(a,b)		Perl_av_extend(aTHX_ a,b)
#define av_fake(a,b)		Perl_av_fake(aTHX_ a,b)
#define av_fetch(a,b,c)		Perl_av_fetch(aTHX_ a,b,c)
#define av_fill(a,b)		Perl_av_fill(aTHX_ a,b)
#define av_len(a)		Perl_av_len(aTHX_ a)
#define av_make(a,b)		Perl_av_make(aTHX_ a,b)
#define av_pop(a)		Perl_av_pop(aTHX_ a)
#define av_push(a,b)		Perl_av_push(aTHX_ a,b)
#define av_reify(a)		Perl_av_reify(aTHX_ a)
#define av_shift(a)		Perl_av_shift(aTHX_ a)
#define av_store(a,b,c)		Perl_av_store(aTHX_ a,b,c)
#define av_undef(a)		Perl_av_undef(aTHX_ a)
#define av_unshift(a,b)		Perl_av_unshift(aTHX_ a,b)
#define bind_match(a,b,c)	Perl_bind_match(aTHX_ a,b,c)
#define block_end(a,b)		Perl_block_end(aTHX_ a,b)
#define block_gimme()		Perl_block_gimme(aTHX)
#define block_start(a)		Perl_block_start(aTHX_ a)
#define boot_core_UNIVERSAL()	Perl_boot_core_UNIVERSAL(aTHX)
#define call_list(a,b)		Perl_call_list(aTHX_ a,b)
#define cando(a,b,c)		Perl_cando(aTHX_ a,b,c)
#define cast_ulong(a)		Perl_cast_ulong(aTHX_ a)
#define cast_i32(a)		Perl_cast_i32(aTHX_ a)
#define cast_iv(a)		Perl_cast_iv(aTHX_ a)
#define cast_uv(a)		Perl_cast_uv(aTHX_ a)
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#define my_chsize(a,b)		Perl_my_chsize(aTHX_ a,b)
#endif
#if defined(USE_THREADS)
#define condpair_magic(a)	Perl_condpair_magic(aTHX_ a)
#endif
#define convert(a,b,c)		Perl_convert(aTHX_ a,b,c)
#define vcroak(a,b)		Perl_vcroak(aTHX_ a,b)
#if defined(PERL_IMPLICIT_CONTEXT)
#endif
#define cv_ckproto(a,b,c)	Perl_cv_ckproto(aTHX_ a,b,c)
#define cv_clone(a)		Perl_cv_clone(aTHX_ a)
#define cv_const_sv(a)		Perl_cv_const_sv(aTHX_ a)
#define op_const_sv(a,b)	Perl_op_const_sv(aTHX_ a,b)
#define cv_undef(a)		Perl_cv_undef(aTHX_ a)
#define cx_dump(a)		Perl_cx_dump(aTHX_ a)
#define filter_add(a,b)		Perl_filter_add(aTHX_ a,b)
#define filter_del(a)		Perl_filter_del(aTHX_ a)
#define filter_read(a,b,c)	Perl_filter_read(aTHX_ a,b,c)
#define get_op_descs()		Perl_get_op_descs(aTHX)
#define get_op_names()		Perl_get_op_names(aTHX)
#define get_no_modify()		Perl_get_no_modify(aTHX)
#define get_opargs()		Perl_get_opargs(aTHX)
#define get_ppaddr()		Perl_get_ppaddr(aTHX)
#define cxinc()			Perl_cxinc(aTHX)
#define vdeb(a,b)		Perl_vdeb(aTHX_ a,b)
#define debprofdump()		Perl_debprofdump(aTHX)
#define debop(a)		Perl_debop(aTHX_ a)
#define debstack()		Perl_debstack(aTHX)
#define debstackptrs()		Perl_debstackptrs(aTHX)
#define delimcpy(a,b,c,d,e,f)	Perl_delimcpy(aTHX_ a,b,c,d,e,f)
#define deprecate(a)		Perl_deprecate(aTHX_ a)
#define vdie(a,b)		Perl_vdie(aTHX_ a,b)
#define die_where(a,b)		Perl_die_where(aTHX_ a,b)
#define dounwind(a)		Perl_dounwind(aTHX_ a)
#define do_aexec(a,b,c)		Perl_do_aexec(aTHX_ a,b,c)
#define do_aexec5(a,b,c,d,e)	Perl_do_aexec5(aTHX_ a,b,c,d,e)
#define do_binmode(a,b,c)	Perl_do_binmode(aTHX_ a,b,c)
#define do_chop(a,b)		Perl_do_chop(aTHX_ a,b)
#define do_close(a,b)		Perl_do_close(aTHX_ a,b)
#define do_eof(a)		Perl_do_eof(aTHX_ a)
#define do_exec(a)		Perl_do_exec(aTHX_ a)
#if defined(WIN32)
#define do_aspawn(a,b,c)	Perl_do_aspawn(aTHX_ a,b,c)
#define do_spawn(a)		Perl_do_spawn(aTHX_ a)
#define do_spawn_nowait(a)	Perl_do_spawn_nowait(aTHX_ a)
#endif
#if !defined(WIN32)
#define do_exec3(a,b,c)		Perl_do_exec3(aTHX_ a,b,c)
#endif
#define do_execfree()		Perl_do_execfree(aTHX)
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#define do_ipcctl(a,b,c)	Perl_do_ipcctl(aTHX_ a,b,c)
#define do_ipcget(a,b,c)	Perl_do_ipcget(aTHX_ a,b,c)
#define do_msgrcv(a,b)		Perl_do_msgrcv(aTHX_ a,b)
#define do_msgsnd(a,b)		Perl_do_msgsnd(aTHX_ a,b)
#define do_semop(a,b)		Perl_do_semop(aTHX_ a,b)
#define do_shmio(a,b,c)		Perl_do_shmio(aTHX_ a,b,c)
#endif
#define do_join(a,b,c,d)	Perl_do_join(aTHX_ a,b,c,d)
#define do_kv()			Perl_do_kv(aTHX)
#define do_open(a,b,c,d,e,f,g)	Perl_do_open(aTHX_ a,b,c,d,e,f,g)
#define do_open9(a,b,c,d,e,f,g,h,i)	Perl_do_open9(aTHX_ a,b,c,d,e,f,g,h,i)
#define do_pipe(a,b,c)		Perl_do_pipe(aTHX_ a,b,c)
#define do_print(a,b)		Perl_do_print(aTHX_ a,b)
#define do_readline()		Perl_do_readline(aTHX)
#define do_chomp(a)		Perl_do_chomp(aTHX_ a)
#define do_seek(a,b,c)		Perl_do_seek(aTHX_ a,b,c)
#define do_sprintf(a,b,c)	Perl_do_sprintf(aTHX_ a,b,c)
#define do_sysseek(a,b,c)	Perl_do_sysseek(aTHX_ a,b,c)
#define do_tell(a)		Perl_do_tell(aTHX_ a)
#define do_trans(a)		Perl_do_trans(aTHX_ a)
#define do_vecget(a,b,c)	Perl_do_vecget(aTHX_ a,b,c)
#define do_vecset(a)		Perl_do_vecset(aTHX_ a)
#define do_vop(a,b,c,d)		Perl_do_vop(aTHX_ a,b,c,d)
#define dofile(a)		Perl_dofile(aTHX_ a)
#define dowantarray()		Perl_dowantarray(aTHX)
#define dump_all()		Perl_dump_all(aTHX)
#define dump_eval()		Perl_dump_eval(aTHX)
#if defined(DUMP_FDS)
#define dump_fds(a)		Perl_dump_fds(aTHX_ a)
#endif
#define dump_form(a)		Perl_dump_form(aTHX_ a)
#define gv_dump(a)		Perl_gv_dump(aTHX_ a)
#define op_dump(a)		Perl_op_dump(aTHX_ a)
#define pmop_dump(a)		Perl_pmop_dump(aTHX_ a)
#define dump_packsubs(a)	Perl_dump_packsubs(aTHX_ a)
#define dump_sub(a)		Perl_dump_sub(aTHX_ a)
#define fbm_compile(a,b)	Perl_fbm_compile(aTHX_ a,b)
#define fbm_instr(a,b,c,d)	Perl_fbm_instr(aTHX_ a,b,c,d)
#define find_script(a,b,c,d)	Perl_find_script(aTHX_ a,b,c,d)
#if defined(USE_THREADS)
#define find_threadsv(a)	Perl_find_threadsv(aTHX_ a)
#endif
#define force_list(a)		Perl_force_list(aTHX_ a)
#define fold_constants(a)	Perl_fold_constants(aTHX_ a)
#define vform(a,b)		Perl_vform(aTHX_ a,b)
#define free_tmps()		Perl_free_tmps(aTHX)
#define gen_constant_list(a)	Perl_gen_constant_list(aTHX_ a)
#if !defined(HAS_GETENV_LEN)
#define getenv_len(a,b)		Perl_getenv_len(aTHX_ a,b)
#endif
#define gp_free(a)		Perl_gp_free(aTHX_ a)
#define gp_ref(a)		Perl_gp_ref(aTHX_ a)
#define gv_AVadd(a)		Perl_gv_AVadd(aTHX_ a)
#define gv_HVadd(a)		Perl_gv_HVadd(aTHX_ a)
#define gv_IOadd(a)		Perl_gv_IOadd(aTHX_ a)
#define gv_autoload4(a,b,c,d)	Perl_gv_autoload4(aTHX_ a,b,c,d)
#define gv_check(a)		Perl_gv_check(aTHX_ a)
#define gv_efullname(a,b)	Perl_gv_efullname(aTHX_ a,b)
#define gv_efullname3(a,b,c)	Perl_gv_efullname3(aTHX_ a,b,c)
#define gv_efullname4(a,b,c,d)	Perl_gv_efullname4(aTHX_ a,b,c,d)
#define gv_fetchfile(a)		Perl_gv_fetchfile(aTHX_ a)
#define gv_fetchmeth(a,b,c,d)	Perl_gv_fetchmeth(aTHX_ a,b,c,d)
#define gv_fetchmethod(a,b)	Perl_gv_fetchmethod(aTHX_ a,b)
#define gv_fetchmethod_autoload(a,b,c)	Perl_gv_fetchmethod_autoload(aTHX_ a,b,c)
#define gv_fetchpv(a,b,c)	Perl_gv_fetchpv(aTHX_ a,b,c)
#define gv_fullname(a,b)	Perl_gv_fullname(aTHX_ a,b)
#define gv_fullname3(a,b,c)	Perl_gv_fullname3(aTHX_ a,b,c)
#define gv_fullname4(a,b,c,d)	Perl_gv_fullname4(aTHX_ a,b,c,d)
#define gv_init(a,b,c,d,e)	Perl_gv_init(aTHX_ a,b,c,d,e)
#define gv_stashpv(a,b)		Perl_gv_stashpv(aTHX_ a,b)
#define gv_stashpvn(a,b,c)	Perl_gv_stashpvn(aTHX_ a,b,c)
#define gv_stashsv(a,b)		Perl_gv_stashsv(aTHX_ a,b)
#define hv_clear(a)		Perl_hv_clear(aTHX_ a)
#define hv_delayfree_ent(a,b)	Perl_hv_delayfree_ent(aTHX_ a,b)
#define hv_delete(a,b,c,d)	Perl_hv_delete(aTHX_ a,b,c,d)
#define hv_delete_ent(a,b,c,d)	Perl_hv_delete_ent(aTHX_ a,b,c,d)
#define hv_exists(a,b,c)	Perl_hv_exists(aTHX_ a,b,c)
#define hv_exists_ent(a,b,c)	Perl_hv_exists_ent(aTHX_ a,b,c)
#define hv_fetch(a,b,c,d)	Perl_hv_fetch(aTHX_ a,b,c,d)
#define hv_fetch_ent(a,b,c,d)	Perl_hv_fetch_ent(aTHX_ a,b,c,d)
#define hv_free_ent(a,b)	Perl_hv_free_ent(aTHX_ a,b)
#define hv_iterinit(a)		Perl_hv_iterinit(aTHX_ a)
#define hv_iterkey(a,b)		Perl_hv_iterkey(aTHX_ a,b)
#define hv_iterkeysv(a)		Perl_hv_iterkeysv(aTHX_ a)
#define hv_iternext(a)		Perl_hv_iternext(aTHX_ a)
#define hv_iternextsv(a,b,c)	Perl_hv_iternextsv(aTHX_ a,b,c)
#define hv_iterval(a,b)		Perl_hv_iterval(aTHX_ a,b)
#define hv_ksplit(a,b)		Perl_hv_ksplit(aTHX_ a,b)
#define hv_magic(a,b,c)		Perl_hv_magic(aTHX_ a,b,c)
#define hv_store(a,b,c,d,e)	Perl_hv_store(aTHX_ a,b,c,d,e)
#define hv_store_ent(a,b,c,d)	Perl_hv_store_ent(aTHX_ a,b,c,d)
#define hv_undef(a)		Perl_hv_undef(aTHX_ a)
#define ibcmp(a,b,c)		Perl_ibcmp(aTHX_ a,b,c)
#define ibcmp_locale(a,b,c)	Perl_ibcmp_locale(aTHX_ a,b,c)
#define ingroup(a,b)		Perl_ingroup(aTHX_ a,b)
#define init_debugger()		Perl_init_debugger(aTHX)
#define init_stacks()		Perl_init_stacks(aTHX)
#define intro_my()		Perl_intro_my(aTHX)
#define instr(a,b)		Perl_instr(aTHX_ a,b)
#define io_close(a,b)		Perl_io_close(aTHX_ a,b)
#define invert(a)		Perl_invert(aTHX_ a)
#define is_gv_magical(a,b,c)	Perl_is_gv_magical(aTHX_ a,b,c)
#define is_lvalue_sub()		Perl_is_lvalue_sub(aTHX)
#define is_uni_alnum(a)		Perl_is_uni_alnum(aTHX_ a)
#define is_uni_alnumc(a)	Perl_is_uni_alnumc(aTHX_ a)
#define is_uni_idfirst(a)	Perl_is_uni_idfirst(aTHX_ a)
#define is_uni_alpha(a)		Perl_is_uni_alpha(aTHX_ a)
#define is_uni_ascii(a)		Perl_is_uni_ascii(aTHX_ a)
#define is_uni_space(a)		Perl_is_uni_space(aTHX_ a)
#define is_uni_cntrl(a)		Perl_is_uni_cntrl(aTHX_ a)
#define is_uni_graph(a)		Perl_is_uni_graph(aTHX_ a)
#define is_uni_digit(a)		Perl_is_uni_digit(aTHX_ a)
#define is_uni_upper(a)		Perl_is_uni_upper(aTHX_ a)
#define is_uni_lower(a)		Perl_is_uni_lower(aTHX_ a)
#define is_uni_print(a)		Perl_is_uni_print(aTHX_ a)
#define is_uni_punct(a)		Perl_is_uni_punct(aTHX_ a)
#define is_uni_xdigit(a)	Perl_is_uni_xdigit(aTHX_ a)
#define to_uni_upper(a)		Perl_to_uni_upper(aTHX_ a)
#define to_uni_title(a)		Perl_to_uni_title(aTHX_ a)
#define to_uni_lower(a)		Perl_to_uni_lower(aTHX_ a)
#define is_uni_alnum_lc(a)	Perl_is_uni_alnum_lc(aTHX_ a)
#define is_uni_alnumc_lc(a)	Perl_is_uni_alnumc_lc(aTHX_ a)
#define is_uni_idfirst_lc(a)	Perl_is_uni_idfirst_lc(aTHX_ a)
#define is_uni_alpha_lc(a)	Perl_is_uni_alpha_lc(aTHX_ a)
#define is_uni_ascii_lc(a)	Perl_is_uni_ascii_lc(aTHX_ a)
#define is_uni_space_lc(a)	Perl_is_uni_space_lc(aTHX_ a)
#define is_uni_cntrl_lc(a)	Perl_is_uni_cntrl_lc(aTHX_ a)
#define is_uni_graph_lc(a)	Perl_is_uni_graph_lc(aTHX_ a)
#define is_uni_digit_lc(a)	Perl_is_uni_digit_lc(aTHX_ a)
#define is_uni_upper_lc(a)	Perl_is_uni_upper_lc(aTHX_ a)
#define is_uni_lower_lc(a)	Perl_is_uni_lower_lc(aTHX_ a)
#define is_uni_print_lc(a)	Perl_is_uni_print_lc(aTHX_ a)
#define is_uni_punct_lc(a)	Perl_is_uni_punct_lc(aTHX_ a)
#define is_uni_xdigit_lc(a)	Perl_is_uni_xdigit_lc(aTHX_ a)
#define to_uni_upper_lc(a)	Perl_to_uni_upper_lc(aTHX_ a)
#define to_uni_title_lc(a)	Perl_to_uni_title_lc(aTHX_ a)
#define to_uni_lower_lc(a)	Perl_to_uni_lower_lc(aTHX_ a)
#define is_utf8_char(a)		Perl_is_utf8_char(aTHX_ a)
#define is_utf8_string(a,b)	Perl_is_utf8_string(aTHX_ a,b)
#define is_utf8_alnum(a)	Perl_is_utf8_alnum(aTHX_ a)
#define is_utf8_alnumc(a)	Perl_is_utf8_alnumc(aTHX_ a)
#define is_utf8_idfirst(a)	Perl_is_utf8_idfirst(aTHX_ a)
#define is_utf8_alpha(a)	Perl_is_utf8_alpha(aTHX_ a)
#define is_utf8_ascii(a)	Perl_is_utf8_ascii(aTHX_ a)
#define is_utf8_space(a)	Perl_is_utf8_space(aTHX_ a)
#define is_utf8_cntrl(a)	Perl_is_utf8_cntrl(aTHX_ a)
#define is_utf8_digit(a)	Perl_is_utf8_digit(aTHX_ a)
#define is_utf8_graph(a)	Perl_is_utf8_graph(aTHX_ a)
#define is_utf8_upper(a)	Perl_is_utf8_upper(aTHX_ a)
#define is_utf8_lower(a)	Perl_is_utf8_lower(aTHX_ a)
#define is_utf8_print(a)	Perl_is_utf8_print(aTHX_ a)
#define is_utf8_punct(a)	Perl_is_utf8_punct(aTHX_ a)
#define is_utf8_xdigit(a)	Perl_is_utf8_xdigit(aTHX_ a)
#define is_utf8_mark(a)		Perl_is_utf8_mark(aTHX_ a)
#define jmaybe(a)		Perl_jmaybe(aTHX_ a)
#define keyword(a,b)		Perl_keyword(aTHX_ a,b)
#define leave_scope(a)		Perl_leave_scope(aTHX_ a)
#define lex_end()		Perl_lex_end(aTHX)
#define lex_start(a)		Perl_lex_start(aTHX_ a)
#define linklist(a)		Perl_linklist(aTHX_ a)
#define list(a)			Perl_list(aTHX_ a)
#define listkids(a)		Perl_listkids(aTHX_ a)
#define vload_module(a,b,c,d)	Perl_vload_module(aTHX_ a,b,c,d)
#define localize(a,b)		Perl_localize(aTHX_ a,b)
#define looks_like_number(a)	Perl_looks_like_number(aTHX_ a)
#define magic_clearenv(a,b)	Perl_magic_clearenv(aTHX_ a,b)
#define magic_clear_all_env(a,b)	Perl_magic_clear_all_env(aTHX_ a,b)
#define magic_clearpack(a,b)	Perl_magic_clearpack(aTHX_ a,b)
#define magic_clearsig(a,b)	Perl_magic_clearsig(aTHX_ a,b)
#define magic_existspack(a,b)	Perl_magic_existspack(aTHX_ a,b)
#define magic_freeregexp(a,b)	Perl_magic_freeregexp(aTHX_ a,b)
#define magic_get(a,b)		Perl_magic_get(aTHX_ a,b)
#define magic_getarylen(a,b)	Perl_magic_getarylen(aTHX_ a,b)
#define magic_getdefelem(a,b)	Perl_magic_getdefelem(aTHX_ a,b)
#define magic_getglob(a,b)	Perl_magic_getglob(aTHX_ a,b)
#define magic_getnkeys(a,b)	Perl_magic_getnkeys(aTHX_ a,b)
#define magic_getpack(a,b)	Perl_magic_getpack(aTHX_ a,b)
#define magic_getpos(a,b)	Perl_magic_getpos(aTHX_ a,b)
#define magic_getsig(a,b)	Perl_magic_getsig(aTHX_ a,b)
#define magic_getsubstr(a,b)	Perl_magic_getsubstr(aTHX_ a,b)
#define magic_gettaint(a,b)	Perl_magic_gettaint(aTHX_ a,b)
#define magic_getuvar(a,b)	Perl_magic_getuvar(aTHX_ a,b)
#define magic_getvec(a,b)	Perl_magic_getvec(aTHX_ a,b)
#define magic_len(a,b)		Perl_magic_len(aTHX_ a,b)
#if defined(USE_THREADS)
#define magic_mutexfree(a,b)	Perl_magic_mutexfree(aTHX_ a,b)
#endif
#define magic_nextpack(a,b,c)	Perl_magic_nextpack(aTHX_ a,b,c)
#define magic_regdata_cnt(a,b)	Perl_magic_regdata_cnt(aTHX_ a,b)
#define magic_regdatum_get(a,b)	Perl_magic_regdatum_get(aTHX_ a,b)
#define magic_regdatum_set(a,b)	Perl_magic_regdatum_set(aTHX_ a,b)
#define magic_set(a,b)		Perl_magic_set(aTHX_ a,b)
#define magic_setamagic(a,b)	Perl_magic_setamagic(aTHX_ a,b)
#define magic_setarylen(a,b)	Perl_magic_setarylen(aTHX_ a,b)
#define magic_setbm(a,b)	Perl_magic_setbm(aTHX_ a,b)
#define magic_setdbline(a,b)	Perl_magic_setdbline(aTHX_ a,b)
#if defined(USE_LOCALE_COLLATE)
#define magic_setcollxfrm(a,b)	Perl_magic_setcollxfrm(aTHX_ a,b)
#endif
#define magic_setdefelem(a,b)	Perl_magic_setdefelem(aTHX_ a,b)
#define magic_setenv(a,b)	Perl_magic_setenv(aTHX_ a,b)
#define magic_setfm(a,b)	Perl_magic_setfm(aTHX_ a,b)
#define magic_setisa(a,b)	Perl_magic_setisa(aTHX_ a,b)
#define magic_setglob(a,b)	Perl_magic_setglob(aTHX_ a,b)
#define magic_setmglob(a,b)	Perl_magic_setmglob(aTHX_ a,b)
#define magic_setnkeys(a,b)	Perl_magic_setnkeys(aTHX_ a,b)
#define magic_setpack(a,b)	Perl_magic_setpack(aTHX_ a,b)
#define magic_setpos(a,b)	Perl_magic_setpos(aTHX_ a,b)
#define magic_setsig(a,b)	Perl_magic_setsig(aTHX_ a,b)
#define magic_setsubstr(a,b)	Perl_magic_setsubstr(aTHX_ a,b)
#define magic_settaint(a,b)	Perl_magic_settaint(aTHX_ a,b)
#define magic_setuvar(a,b)	Perl_magic_setuvar(aTHX_ a,b)
#define magic_setvec(a,b)	Perl_magic_setvec(aTHX_ a,b)
#define magic_set_all_env(a,b)	Perl_magic_set_all_env(aTHX_ a,b)
#define magic_sizepack(a,b)	Perl_magic_sizepack(aTHX_ a,b)
#define magic_wipepack(a,b)	Perl_magic_wipepack(aTHX_ a,b)
#define magicname(a,b,c)	Perl_magicname(aTHX_ a,b,c)
#define markstack_grow()	Perl_markstack_grow(aTHX)
#if defined(USE_LOCALE_COLLATE)
#define mem_collxfrm(a,b,c)	Perl_mem_collxfrm(aTHX_ a,b,c)
#endif
#define vmess(a,b)		Perl_vmess(aTHX_ a,b)
#define qerror(a)		Perl_qerror(aTHX_ a)
#define mg_clear(a)		Perl_mg_clear(aTHX_ a)
#define mg_copy(a,b,c,d)	Perl_mg_copy(aTHX_ a,b,c,d)
#define mg_find(a,b)		Perl_mg_find(aTHX_ a,b)
#define mg_free(a)		Perl_mg_free(aTHX_ a)
#define mg_get(a)		Perl_mg_get(aTHX_ a)
#define mg_length(a)		Perl_mg_length(aTHX_ a)
#define mg_magical(a)		Perl_mg_magical(aTHX_ a)
#define mg_set(a)		Perl_mg_set(aTHX_ a)
#define mg_size(a)		Perl_mg_size(aTHX_ a)
#define mod(a,b)		Perl_mod(aTHX_ a,b)
#define mode_from_discipline(a)	Perl_mode_from_discipline(aTHX_ a)
#define moreswitches(a)		Perl_moreswitches(aTHX_ a)
#define my(a)			Perl_my(aTHX_ a)
#define my_atof(a)		Perl_my_atof(aTHX_ a)
#if !defined(HAS_BCOPY) || !defined(HAS_SAFE_BCOPY)
#define my_bcopy		Perl_my_bcopy
#endif
#if !defined(HAS_BZERO) && !defined(HAS_MEMSET)
#define my_bzero		Perl_my_bzero
#endif
#define my_exit(a)		Perl_my_exit(aTHX_ a)
#define my_failure_exit()	Perl_my_failure_exit(aTHX)
#define my_fflush_all()		Perl_my_fflush_all(aTHX)
#define my_lstat()		Perl_my_lstat(aTHX)
#if !defined(HAS_MEMCMP) || !defined(HAS_SANE_MEMCMP)
#define my_memcmp		Perl_my_memcmp
#endif
#if !defined(HAS_MEMSET)
#define my_memset		Perl_my_memset
#endif
#if !defined(PERL_OBJECT)
#define my_pclose(a)		Perl_my_pclose(aTHX_ a)
#define my_popen(a,b)		Perl_my_popen(aTHX_ a,b)
#endif
#define my_setenv(a,b)		Perl_my_setenv(aTHX_ a,b)
#define my_stat()		Perl_my_stat(aTHX)
#if defined(MYSWAP)
#define my_swap(a)		Perl_my_swap(aTHX_ a)
#define my_htonl(a)		Perl_my_htonl(aTHX_ a)
#define my_ntohl(a)		Perl_my_ntohl(aTHX_ a)
#endif
#define my_unexec()		Perl_my_unexec(aTHX)
#define newANONLIST(a)		Perl_newANONLIST(aTHX_ a)
#define newANONHASH(a)		Perl_newANONHASH(aTHX_ a)
#define newANONSUB(a,b,c)	Perl_newANONSUB(aTHX_ a,b,c)
#define newASSIGNOP(a,b,c,d)	Perl_newASSIGNOP(aTHX_ a,b,c,d)
#define newCONDOP(a,b,c,d)	Perl_newCONDOP(aTHX_ a,b,c,d)
#define newCONSTSUB(a,b,c)	Perl_newCONSTSUB(aTHX_ a,b,c)
#define newFORM(a,b,c)		Perl_newFORM(aTHX_ a,b,c)
#define newFOROP(a,b,c,d,e,f,g)	Perl_newFOROP(aTHX_ a,b,c,d,e,f,g)
#define newLOGOP(a,b,c,d)	Perl_newLOGOP(aTHX_ a,b,c,d)
#define newLOOPEX(a,b)		Perl_newLOOPEX(aTHX_ a,b)
#define newLOOPOP(a,b,c,d)	Perl_newLOOPOP(aTHX_ a,b,c,d)
#define newNULLLIST()		Perl_newNULLLIST(aTHX)
#define newOP(a,b)		Perl_newOP(aTHX_ a,b)
#define newPROG(a)		Perl_newPROG(aTHX_ a)
#define newRANGE(a,b,c)		Perl_newRANGE(aTHX_ a,b,c)
#define newSLICEOP(a,b,c)	Perl_newSLICEOP(aTHX_ a,b,c)
#define newSTATEOP(a,b,c)	Perl_newSTATEOP(aTHX_ a,b,c)
#define newSUB(a,b,c,d)		Perl_newSUB(aTHX_ a,b,c,d)
#define newXS(a,b,c)		Perl_newXS(aTHX_ a,b,c)
#define newAV()			Perl_newAV(aTHX)
#define newAVREF(a)		Perl_newAVREF(aTHX_ a)
#define newBINOP(a,b,c,d)	Perl_newBINOP(aTHX_ a,b,c,d)
#define newCVREF(a,b)		Perl_newCVREF(aTHX_ a,b)
#define newGVOP(a,b,c)		Perl_newGVOP(aTHX_ a,b,c)
#define newGVgen(a)		Perl_newGVgen(aTHX_ a)
#define newGVREF(a,b)		Perl_newGVREF(aTHX_ a,b)
#define newHVREF(a)		Perl_newHVREF(aTHX_ a)
#define newHV()			Perl_newHV(aTHX)
#define newHVhv(a)		Perl_newHVhv(aTHX_ a)
#define newIO()			Perl_newIO(aTHX)
#define newLISTOP(a,b,c,d)	Perl_newLISTOP(aTHX_ a,b,c,d)
#define newPADOP(a,b,c)		Perl_newPADOP(aTHX_ a,b,c)
#define newPMOP(a,b)		Perl_newPMOP(aTHX_ a,b)
#define newPVOP(a,b,c)		Perl_newPVOP(aTHX_ a,b,c)
#define newRV(a)		Perl_newRV(aTHX_ a)
#define newRV_noinc(a)		Perl_newRV_noinc(aTHX_ a)
#define newSV(a)		Perl_newSV(aTHX_ a)
#define newSVREF(a)		Perl_newSVREF(aTHX_ a)
#define newSVOP(a,b,c)		Perl_newSVOP(aTHX_ a,b,c)
#define newSViv(a)		Perl_newSViv(aTHX_ a)
#define newSVuv(a)		Perl_newSVuv(aTHX_ a)
#define newSVnv(a)		Perl_newSVnv(aTHX_ a)
#define newSVpv(a,b)		Perl_newSVpv(aTHX_ a,b)
#define newSVpvn(a,b)		Perl_newSVpvn(aTHX_ a,b)
#define vnewSVpvf(a,b)		Perl_vnewSVpvf(aTHX_ a,b)
#define newSVrv(a,b)		Perl_newSVrv(aTHX_ a,b)
#define newSVsv(a)		Perl_newSVsv(aTHX_ a)
#define newUNOP(a,b,c)		Perl_newUNOP(aTHX_ a,b,c)
#define newWHILEOP(a,b,c,d,e,f,g)	Perl_newWHILEOP(aTHX_ a,b,c,d,e,f,g)
#define new_stackinfo(a,b)	Perl_new_stackinfo(aTHX_ a,b)
#define nextargv(a)		Perl_nextargv(aTHX_ a)
#define ninstr(a,b,c,d)		Perl_ninstr(aTHX_ a,b,c,d)
#define oopsCV(a)		Perl_oopsCV(aTHX_ a)
#define op_free(a)		Perl_op_free(aTHX_ a)
#define package(a)		Perl_package(aTHX_ a)
#define pad_alloc(a,b)		Perl_pad_alloc(aTHX_ a,b)
#define pad_allocmy(a)		Perl_pad_allocmy(aTHX_ a)
#define pad_findmy(a)		Perl_pad_findmy(aTHX_ a)
#define oopsAV(a)		Perl_oopsAV(aTHX_ a)
#define oopsHV(a)		Perl_oopsHV(aTHX_ a)
#define pad_leavemy(a)		Perl_pad_leavemy(aTHX_ a)
#define pad_sv(a)		Perl_pad_sv(aTHX_ a)
#define pad_free(a)		Perl_pad_free(aTHX_ a)
#define pad_reset()		Perl_pad_reset(aTHX)
#define pad_swipe(a)		Perl_pad_swipe(aTHX_ a)
#define peep(a)			Perl_peep(aTHX_ a)
#if defined(PERL_OBJECT)
#endif
#if defined(USE_THREADS)
#define new_struct_thread(a)	Perl_new_struct_thread(aTHX_ a)
#endif
#define call_atexit(a,b)	Perl_call_atexit(aTHX_ a,b)
#define call_argv(a,b,c)	Perl_call_argv(aTHX_ a,b,c)
#define call_method(a,b)	Perl_call_method(aTHX_ a,b)
#define call_pv(a,b)		Perl_call_pv(aTHX_ a,b)
#define call_sv(a,b)		Perl_call_sv(aTHX_ a,b)
#define eval_pv(a,b)		Perl_eval_pv(aTHX_ a,b)
#define eval_sv(a,b)		Perl_eval_sv(aTHX_ a,b)
#define get_sv(a,b)		Perl_get_sv(aTHX_ a,b)
#define get_av(a,b)		Perl_get_av(aTHX_ a,b)
#define get_hv(a,b)		Perl_get_hv(aTHX_ a,b)
#define get_cv(a,b)		Perl_get_cv(aTHX_ a,b)
#define init_i18nl10n(a)	Perl_init_i18nl10n(aTHX_ a)
#define init_i18nl14n(a)	Perl_init_i18nl14n(aTHX_ a)
#define new_collate(a)		Perl_new_collate(aTHX_ a)
#define new_ctype(a)		Perl_new_ctype(aTHX_ a)
#define new_numeric(a)		Perl_new_numeric(aTHX_ a)
#define set_numeric_local()	Perl_set_numeric_local(aTHX)
#define set_numeric_radix()	Perl_set_numeric_radix(aTHX)
#define set_numeric_standard()	Perl_set_numeric_standard(aTHX)
#define require_pv(a)		Perl_require_pv(aTHX_ a)
#define pidgone(a,b)		Perl_pidgone(aTHX_ a,b)
#define pmflag(a,b)		Perl_pmflag(aTHX_ a,b)
#define pmruntime(a,b,c)	Perl_pmruntime(aTHX_ a,b,c)
#define pmtrans(a,b,c)		Perl_pmtrans(aTHX_ a,b,c)
#define pop_return()		Perl_pop_return(aTHX)
#define pop_scope()		Perl_pop_scope(aTHX)
#define prepend_elem(a,b,c)	Perl_prepend_elem(aTHX_ a,b,c)
#define push_return(a)		Perl_push_return(aTHX_ a)
#define push_scope()		Perl_push_scope(aTHX)
#define ref(a,b)		Perl_ref(aTHX_ a,b)
#define refkids(a,b)		Perl_refkids(aTHX_ a,b)
#define regdump(a)		Perl_regdump(aTHX_ a)
#define pregexec(a,b,c,d,e,f,g)	Perl_pregexec(aTHX_ a,b,c,d,e,f,g)
#define pregfree(a)		Perl_pregfree(aTHX_ a)
#define pregcomp(a,b,c)		Perl_pregcomp(aTHX_ a,b,c)
#define re_intuit_start(a,b,c,d,e,f)	Perl_re_intuit_start(aTHX_ a,b,c,d,e,f)
#define re_intuit_string(a)	Perl_re_intuit_string(aTHX_ a)
#define regexec_flags(a,b,c,d,e,f,g,h)	Perl_regexec_flags(aTHX_ a,b,c,d,e,f,g,h)
#define regnext(a)		Perl_regnext(aTHX_ a)
#define regprop(a,b)		Perl_regprop(aTHX_ a,b)
#define repeatcpy(a,b,c,d)	Perl_repeatcpy(aTHX_ a,b,c,d)
#define rninstr(a,b,c,d)	Perl_rninstr(aTHX_ a,b,c,d)
#define rsignal(a,b)		Perl_rsignal(aTHX_ a,b)
#define rsignal_restore(a,b)	Perl_rsignal_restore(aTHX_ a,b)
#define rsignal_save(a,b,c)	Perl_rsignal_save(aTHX_ a,b,c)
#define rsignal_state(a)	Perl_rsignal_state(aTHX_ a)
#define rxres_free(a)		Perl_rxres_free(aTHX_ a)
#define rxres_restore(a,b)	Perl_rxres_restore(aTHX_ a,b)
#define rxres_save(a,b)		Perl_rxres_save(aTHX_ a,b)
#if !defined(HAS_RENAME)
#define same_dirent(a,b)	Perl_same_dirent(aTHX_ a,b)
#endif
#define savepv(a)		Perl_savepv(aTHX_ a)
#define savepvn(a,b)		Perl_savepvn(aTHX_ a,b)
#define savestack_grow()	Perl_savestack_grow(aTHX)
#define save_aelem(a,b,c)	Perl_save_aelem(aTHX_ a,b,c)
#define save_alloc(a,b)		Perl_save_alloc(aTHX_ a,b)
#define save_aptr(a)		Perl_save_aptr(aTHX_ a)
#define save_ary(a)		Perl_save_ary(aTHX_ a)
#define save_clearsv(a)		Perl_save_clearsv(aTHX_ a)
#define save_delete(a,b,c)	Perl_save_delete(aTHX_ a,b,c)
#define save_destructor(a,b)	Perl_save_destructor(aTHX_ a,b)
#define save_destructor_x(a,b)	Perl_save_destructor_x(aTHX_ a,b)
#define save_freesv(a)		Perl_save_freesv(aTHX_ a)
#define save_freeop(a)		Perl_save_freeop(aTHX_ a)
#define save_freepv(a)		Perl_save_freepv(aTHX_ a)
#define save_generic_svref(a)	Perl_save_generic_svref(aTHX_ a)
#define save_generic_pvref(a)	Perl_save_generic_pvref(aTHX_ a)
#define save_gp(a,b)		Perl_save_gp(aTHX_ a,b)
#define save_hash(a)		Perl_save_hash(aTHX_ a)
#define save_helem(a,b,c)	Perl_save_helem(aTHX_ a,b,c)
#define save_hints()		Perl_save_hints(aTHX)
#define save_hptr(a)		Perl_save_hptr(aTHX_ a)
#define save_I16(a)		Perl_save_I16(aTHX_ a)
#define save_I32(a)		Perl_save_I32(aTHX_ a)
#define save_I8(a)		Perl_save_I8(aTHX_ a)
#define save_int(a)		Perl_save_int(aTHX_ a)
#define save_item(a)		Perl_save_item(aTHX_ a)
#define save_iv(a)		Perl_save_iv(aTHX_ a)
#define save_list(a,b)		Perl_save_list(aTHX_ a,b)
#define save_long(a)		Perl_save_long(aTHX_ a)
#define save_mortalizesv(a)	Perl_save_mortalizesv(aTHX_ a)
#define save_nogv(a)		Perl_save_nogv(aTHX_ a)
#define save_op()		Perl_save_op(aTHX)
#define save_scalar(a)		Perl_save_scalar(aTHX_ a)
#define save_pptr(a)		Perl_save_pptr(aTHX_ a)
#define save_vptr(a)		Perl_save_vptr(aTHX_ a)
#define save_re_context()	Perl_save_re_context(aTHX)
#define save_padsv(a)		Perl_save_padsv(aTHX_ a)
#define save_sptr(a)		Perl_save_sptr(aTHX_ a)
#define save_svref(a)		Perl_save_svref(aTHX_ a)
#define save_threadsv(a)	Perl_save_threadsv(aTHX_ a)
#define sawparens(a)		Perl_sawparens(aTHX_ a)
#define scalar(a)		Perl_scalar(aTHX_ a)
#define scalarkids(a)		Perl_scalarkids(aTHX_ a)
#define scalarseq(a)		Perl_scalarseq(aTHX_ a)
#define scalarvoid(a)		Perl_scalarvoid(aTHX_ a)
#define scan_bin(a,b,c)		Perl_scan_bin(aTHX_ a,b,c)
#define scan_hex(a,b,c)		Perl_scan_hex(aTHX_ a,b,c)
#define scan_num(a,b)		Perl_scan_num(aTHX_ a,b)
#define scan_oct(a,b,c)		Perl_scan_oct(aTHX_ a,b,c)
#define scope(a)		Perl_scope(aTHX_ a)
#define screaminstr(a,b,c,d,e,f)	Perl_screaminstr(aTHX_ a,b,c,d,e,f)
#if !defined(VMS)
#define setenv_getix(a)		Perl_setenv_getix(aTHX_ a)
#endif
#define setdefout(a)		Perl_setdefout(aTHX_ a)
#define sharepvn(a,b,c)		Perl_sharepvn(aTHX_ a,b,c)
#define share_hek(a,b,c)	Perl_share_hek(aTHX_ a,b,c)
#define sighandler		Perl_sighandler
#define stack_grow(a,b,c)	Perl_stack_grow(aTHX_ a,b,c)
#define start_subparse(a,b)	Perl_start_subparse(aTHX_ a,b)
#define sub_crush_depth(a)	Perl_sub_crush_depth(aTHX_ a)
#define sv_2bool(a)		Perl_sv_2bool(aTHX_ a)
#define sv_2cv(a,b,c,d)		Perl_sv_2cv(aTHX_ a,b,c,d)
#define sv_2io(a)		Perl_sv_2io(aTHX_ a)
#define sv_2iv(a)		Perl_sv_2iv(aTHX_ a)
#define sv_2mortal(a)		Perl_sv_2mortal(aTHX_ a)
#define sv_2nv(a)		Perl_sv_2nv(aTHX_ a)
#define sv_2pv(a,b)		Perl_sv_2pv(aTHX_ a,b)
#define sv_2pvutf8(a,b)		Perl_sv_2pvutf8(aTHX_ a,b)
#define sv_2pvbyte(a,b)		Perl_sv_2pvbyte(aTHX_ a,b)
#define sv_2uv(a)		Perl_sv_2uv(aTHX_ a)
#define sv_iv(a)		Perl_sv_iv(aTHX_ a)
#define sv_uv(a)		Perl_sv_uv(aTHX_ a)
#define sv_nv(a)		Perl_sv_nv(aTHX_ a)
#define sv_pvn(a,b)		Perl_sv_pvn(aTHX_ a,b)
#define sv_pvutf8n(a,b)		Perl_sv_pvutf8n(aTHX_ a,b)
#define sv_pvbyten(a,b)		Perl_sv_pvbyten(aTHX_ a,b)
#define sv_true(a)		Perl_sv_true(aTHX_ a)
#define sv_add_arena(a,b,c)	Perl_sv_add_arena(aTHX_ a,b,c)
#define sv_backoff(a)		Perl_sv_backoff(aTHX_ a)
#define sv_bless(a,b)		Perl_sv_bless(aTHX_ a,b)
#define sv_vcatpvf(a,b,c)	Perl_sv_vcatpvf(aTHX_ a,b,c)
#define sv_catpv(a,b)		Perl_sv_catpv(aTHX_ a,b)
#define sv_catpvn(a,b,c)	Perl_sv_catpvn(aTHX_ a,b,c)
#define sv_catsv(a,b)		Perl_sv_catsv(aTHX_ a,b)
#define sv_chop(a,b)		Perl_sv_chop(aTHX_ a,b)
#define sv_clean_all()		Perl_sv_clean_all(aTHX)
#define sv_clean_objs()		Perl_sv_clean_objs(aTHX)
#define sv_clear(a)		Perl_sv_clear(aTHX_ a)
#define sv_cmp(a,b)		Perl_sv_cmp(aTHX_ a,b)
#define sv_cmp_locale(a,b)	Perl_sv_cmp_locale(aTHX_ a,b)
#if defined(USE_LOCALE_COLLATE)
#define sv_collxfrm(a,b)	Perl_sv_collxfrm(aTHX_ a,b)
#endif
#define sv_compile_2op(a,b,c,d)	Perl_sv_compile_2op(aTHX_ a,b,c,d)
#define sv_dec(a)		Perl_sv_dec(aTHX_ a)
#define sv_dump(a)		Perl_sv_dump(aTHX_ a)
#define sv_derived_from(a,b)	Perl_sv_derived_from(aTHX_ a,b)
#define sv_eq(a,b)		Perl_sv_eq(aTHX_ a,b)
#define sv_free(a)		Perl_sv_free(aTHX_ a)
#define sv_free_arenas()	Perl_sv_free_arenas(aTHX)
#define sv_gets(a,b,c)		Perl_sv_gets(aTHX_ a,b,c)
#define sv_grow(a,b)		Perl_sv_grow(aTHX_ a,b)
#define sv_inc(a)		Perl_sv_inc(aTHX_ a)
#define sv_insert(a,b,c,d,e)	Perl_sv_insert(aTHX_ a,b,c,d,e)
#define sv_isa(a,b)		Perl_sv_isa(aTHX_ a,b)
#define sv_isobject(a)		Perl_sv_isobject(aTHX_ a)
#define sv_len(a)		Perl_sv_len(aTHX_ a)
#define sv_len_utf8(a)		Perl_sv_len_utf8(aTHX_ a)
#define sv_magic(a,b,c,d,e)	Perl_sv_magic(aTHX_ a,b,c,d,e)
#define sv_mortalcopy(a)	Perl_sv_mortalcopy(aTHX_ a)
#define sv_newmortal()		Perl_sv_newmortal(aTHX)
#define sv_newref(a)		Perl_sv_newref(aTHX_ a)
#define sv_peek(a)		Perl_sv_peek(aTHX_ a)
#define sv_pos_u2b(a,b,c)	Perl_sv_pos_u2b(aTHX_ a,b,c)
#define sv_pos_b2u(a,b)		Perl_sv_pos_b2u(aTHX_ a,b)
#define sv_pvn_force(a,b)	Perl_sv_pvn_force(aTHX_ a,b)
#define sv_pvutf8n_force(a,b)	Perl_sv_pvutf8n_force(aTHX_ a,b)
#define sv_pvbyten_force(a,b)	Perl_sv_pvbyten_force(aTHX_ a,b)
#define sv_reftype(a,b)		Perl_sv_reftype(aTHX_ a,b)
#define sv_replace(a,b)		Perl_sv_replace(aTHX_ a,b)
#define sv_report_used()	Perl_sv_report_used(aTHX)
#define sv_reset(a,b)		Perl_sv_reset(aTHX_ a,b)
#define sv_vsetpvf(a,b,c)	Perl_sv_vsetpvf(aTHX_ a,b,c)
#define sv_setiv(a,b)		Perl_sv_setiv(aTHX_ a,b)
#define sv_setpviv(a,b)		Perl_sv_setpviv(aTHX_ a,b)
#define sv_setuv(a,b)		Perl_sv_setuv(aTHX_ a,b)
#define sv_setnv(a,b)		Perl_sv_setnv(aTHX_ a,b)
#define sv_setref_iv(a,b,c)	Perl_sv_setref_iv(aTHX_ a,b,c)
#define sv_setref_nv(a,b,c)	Perl_sv_setref_nv(aTHX_ a,b,c)
#define sv_setref_pv(a,b,c)	Perl_sv_setref_pv(aTHX_ a,b,c)
#define sv_setref_pvn(a,b,c,d)	Perl_sv_setref_pvn(aTHX_ a,b,c,d)
#define sv_setpv(a,b)		Perl_sv_setpv(aTHX_ a,b)
#define sv_setpvn(a,b,c)	Perl_sv_setpvn(aTHX_ a,b,c)
#define sv_setsv(a,b)		Perl_sv_setsv(aTHX_ a,b)
#define sv_taint(a)		Perl_sv_taint(aTHX_ a)
#define sv_tainted(a)		Perl_sv_tainted(aTHX_ a)
#define sv_unmagic(a,b)		Perl_sv_unmagic(aTHX_ a,b)
#define sv_unref(a)		Perl_sv_unref(aTHX_ a)
#define sv_untaint(a)		Perl_sv_untaint(aTHX_ a)
#define sv_upgrade(a,b)		Perl_sv_upgrade(aTHX_ a,b)
#define sv_usepvn(a,b,c)	Perl_sv_usepvn(aTHX_ a,b,c)
#define sv_vcatpvfn(a,b,c,d,e,f,g)	Perl_sv_vcatpvfn(aTHX_ a,b,c,d,e,f,g)
#define sv_vsetpvfn(a,b,c,d,e,f,g)	Perl_sv_vsetpvfn(aTHX_ a,b,c,d,e,f,g)
#define str_to_version(a)	Perl_str_to_version(aTHX_ a)
#define swash_init(a,b,c,d,e)	Perl_swash_init(aTHX_ a,b,c,d,e)
#define swash_fetch(a,b)	Perl_swash_fetch(aTHX_ a,b)
#define taint_env()		Perl_taint_env(aTHX)
#define taint_proper(a,b)	Perl_taint_proper(aTHX_ a,b)
#define to_utf8_lower(a)	Perl_to_utf8_lower(aTHX_ a)
#define to_utf8_upper(a)	Perl_to_utf8_upper(aTHX_ a)
#define to_utf8_title(a)	Perl_to_utf8_title(aTHX_ a)
#if defined(UNLINK_ALL_VERSIONS)
#define unlnk(a)		Perl_unlnk(aTHX_ a)
#endif
#if defined(USE_THREADS)
#define unlock_condpair(a)	Perl_unlock_condpair(aTHX_ a)
#endif
#define unsharepvn(a,b,c)	Perl_unsharepvn(aTHX_ a,b,c)
#define unshare_hek(a)		Perl_unshare_hek(aTHX_ a)
#define utilize(a,b,c,d,e)	Perl_utilize(aTHX_ a,b,c,d,e)
#define utf16_to_utf8(a,b,c,d)	Perl_utf16_to_utf8(aTHX_ a,b,c,d)
#define utf16_to_utf8_reversed(a,b,c,d)	Perl_utf16_to_utf8_reversed(aTHX_ a,b,c,d)
#define utf8_length(a,b)	Perl_utf8_length(aTHX_ a,b)
#define utf8_distance(a,b)	Perl_utf8_distance(aTHX_ a,b)
#define utf8_hop(a,b)		Perl_utf8_hop(aTHX_ a,b)
#define utf8_to_bytes(a,b)	Perl_utf8_to_bytes(aTHX_ a,b)
#define bytes_from_utf8(a,b,c)	Perl_bytes_from_utf8(aTHX_ a,b,c)
#define bytes_to_utf8(a,b)	Perl_bytes_to_utf8(aTHX_ a,b)
#define utf8_to_uv_simple(a,b)	Perl_utf8_to_uv_simple(aTHX_ a,b)
#define utf8_to_uv(a,b,c,d)	Perl_utf8_to_uv(aTHX_ a,b,c,d)
#define uv_to_utf8(a,b)		Perl_uv_to_utf8(aTHX_ a,b)
#define vivify_defelem(a)	Perl_vivify_defelem(aTHX_ a)
#define vivify_ref(a,b)		Perl_vivify_ref(aTHX_ a,b)
#define wait4pid(a,b,c)		Perl_wait4pid(aTHX_ a,b,c)
#define report_evil_fh(a,b,c)	Perl_report_evil_fh(aTHX_ a,b,c)
#define report_uninit()		Perl_report_uninit(aTHX)
#define vwarn(a,b)		Perl_vwarn(aTHX_ a,b)
#define vwarner(a,b,c)		Perl_vwarner(aTHX_ a,b,c)
#define watch(a)		Perl_watch(aTHX_ a)
#define whichsig(a)		Perl_whichsig(aTHX_ a)
#define yyerror(a)		Perl_yyerror(aTHX_ a)
#ifdef USE_PURE_BISON
#define yylex_r(a,b)		Perl_yylex_r(aTHX_ a,b)
#endif
#define yylex()			Perl_yylex(aTHX)
#define yyparse()		Perl_yyparse(aTHX)
#define yywarn(a)		Perl_yywarn(aTHX_ a)
#if defined(MYMALLOC)
#define dump_mstats(a)		Perl_dump_mstats(aTHX_ a)
#define get_mstats(a,b,c)	Perl_get_mstats(aTHX_ a,b,c)
#endif
#define safesysmalloc		Perl_safesysmalloc
#define safesyscalloc		Perl_safesyscalloc
#define safesysrealloc		Perl_safesysrealloc
#define safesysfree		Perl_safesysfree
#if defined(LEAKTEST)
#define safexmalloc		Perl_safexmalloc
#define safexcalloc		Perl_safexcalloc
#define safexrealloc		Perl_safexrealloc
#define safexfree		Perl_safexfree
#endif
#if defined(PERL_GLOBAL_STRUCT)
#define GetVars()		Perl_GetVars(aTHX)
#endif
#define runops_standard()	Perl_runops_standard(aTHX)
#define runops_debug()		Perl_runops_debug(aTHX)
#if defined(USE_THREADS)
#define sv_lock(a)		Perl_sv_lock(aTHX_ a)
#endif
#define sv_vcatpvf_mg(a,b,c)	Perl_sv_vcatpvf_mg(aTHX_ a,b,c)
#define sv_catpv_mg(a,b)	Perl_sv_catpv_mg(aTHX_ a,b)
#define sv_catpvn_mg(a,b,c)	Perl_sv_catpvn_mg(aTHX_ a,b,c)
#define sv_catsv_mg(a,b)	Perl_sv_catsv_mg(aTHX_ a,b)
#define sv_vsetpvf_mg(a,b,c)	Perl_sv_vsetpvf_mg(aTHX_ a,b,c)
#define sv_setiv_mg(a,b)	Perl_sv_setiv_mg(aTHX_ a,b)
#define sv_setpviv_mg(a,b)	Perl_sv_setpviv_mg(aTHX_ a,b)
#define sv_setuv_mg(a,b)	Perl_sv_setuv_mg(aTHX_ a,b)
#define sv_setnv_mg(a,b)	Perl_sv_setnv_mg(aTHX_ a,b)
#define sv_setpv_mg(a,b)	Perl_sv_setpv_mg(aTHX_ a,b)
#define sv_setpvn_mg(a,b,c)	Perl_sv_setpvn_mg(aTHX_ a,b,c)
#define sv_setsv_mg(a,b)	Perl_sv_setsv_mg(aTHX_ a,b)
#define sv_usepvn_mg(a,b,c)	Perl_sv_usepvn_mg(aTHX_ a,b,c)
#define get_vtbl(a)		Perl_get_vtbl(aTHX_ a)
#define pv_display(a,b,c,d,e)	Perl_pv_display(aTHX_ a,b,c,d,e)
#define dump_vindent(a,b,c,d)	Perl_dump_vindent(aTHX_ a,b,c,d)
#define do_gv_dump(a,b,c,d)	Perl_do_gv_dump(aTHX_ a,b,c,d)
#define do_gvgv_dump(a,b,c,d)	Perl_do_gvgv_dump(aTHX_ a,b,c,d)
#define do_hv_dump(a,b,c,d)	Perl_do_hv_dump(aTHX_ a,b,c,d)
#define do_magic_dump(a,b,c,d,e,f,g)	Perl_do_magic_dump(aTHX_ a,b,c,d,e,f,g)
#define do_op_dump(a,b,c)	Perl_do_op_dump(aTHX_ a,b,c)
#define do_pmop_dump(a,b,c)	Perl_do_pmop_dump(aTHX_ a,b,c)
#define do_sv_dump(a,b,c,d,e,f,g)	Perl_do_sv_dump(aTHX_ a,b,c,d,e,f,g)
#define magic_dump(a)		Perl_magic_dump(aTHX_ a)
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
#define vdefault_protect(a,b,c,d)	Perl_vdefault_protect(aTHX_ a,b,c,d)
#endif
#define reginitcolors()		Perl_reginitcolors(aTHX)
#define sv_2pv_nolen(a)		Perl_sv_2pv_nolen(aTHX_ a)
#define sv_2pvutf8_nolen(a)	Perl_sv_2pvutf8_nolen(aTHX_ a)
#define sv_2pvbyte_nolen(a)	Perl_sv_2pvbyte_nolen(aTHX_ a)
#define sv_pv(a)		Perl_sv_pv(aTHX_ a)
#define sv_pvutf8(a)		Perl_sv_pvutf8(aTHX_ a)
#define sv_pvbyte(a)		Perl_sv_pvbyte(aTHX_ a)
#define sv_utf8_upgrade(a)	Perl_sv_utf8_upgrade(aTHX_ a)
#define sv_utf8_downgrade(a,b)	Perl_sv_utf8_downgrade(aTHX_ a,b)
#define sv_utf8_encode(a)	Perl_sv_utf8_encode(aTHX_ a)
#define sv_utf8_decode(a)	Perl_sv_utf8_decode(aTHX_ a)
#define sv_force_normal(a)	Perl_sv_force_normal(aTHX_ a)
#define sv_add_backref(a,b)	Perl_sv_add_backref(aTHX_ a,b)
#define sv_del_backref(a)	Perl_sv_del_backref(aTHX_ a)
#define tmps_grow(a)		Perl_tmps_grow(aTHX_ a)
#define sv_rvweaken(a)		Perl_sv_rvweaken(aTHX_ a)
#define magic_killbackrefs(a,b)	Perl_magic_killbackrefs(aTHX_ a,b)
#define newANONATTRSUB(a,b,c,d)	Perl_newANONATTRSUB(aTHX_ a,b,c,d)
#define newATTRSUB(a,b,c,d,e)	Perl_newATTRSUB(aTHX_ a,b,c,d,e)
#define newMYSUB(a,b,c,d,e)	Perl_newMYSUB(aTHX_ a,b,c,d,e)
#define my_attrs(a,b)		Perl_my_attrs(aTHX_ a,b)
#define boot_core_xsutils()	Perl_boot_core_xsutils(aTHX)
#if defined(USE_ITHREADS)
#define cx_dup(a,b,c)		Perl_cx_dup(aTHX_ a,b,c)
#define si_dup(a)		Perl_si_dup(aTHX_ a)
#define ss_dup(a)		Perl_ss_dup(aTHX_ a)
#define any_dup(a,b)		Perl_any_dup(aTHX_ a,b)
#define he_dup(a,b)		Perl_he_dup(aTHX_ a,b)
#define re_dup(a)		Perl_re_dup(aTHX_ a)
#define fp_dup(a,b)		Perl_fp_dup(aTHX_ a,b)
#define dirp_dup(a)		Perl_dirp_dup(aTHX_ a)
#define gp_dup(a)		Perl_gp_dup(aTHX_ a)
#define mg_dup(a)		Perl_mg_dup(aTHX_ a)
#define sv_dup(a)		Perl_sv_dup(aTHX_ a)
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_dup(a,b)	Perl_sys_intern_dup(aTHX_ a,b)
#endif
#define ptr_table_new()		Perl_ptr_table_new(aTHX)
#define ptr_table_fetch(a,b)	Perl_ptr_table_fetch(aTHX_ a,b)
#define ptr_table_store(a,b,c)	Perl_ptr_table_store(aTHX_ a,b,c)
#define ptr_table_split(a)	Perl_ptr_table_split(aTHX_ a)
#define ptr_table_clear(a)	Perl_ptr_table_clear(aTHX_ a)
#define ptr_table_free(a)	Perl_ptr_table_free(aTHX_ a)
#endif
#if defined(HAVE_INTERP_INTERN)
#define sys_intern_clear()	Perl_sys_intern_clear(aTHX)
#define sys_intern_init()	Perl_sys_intern_init(aTHX)
#endif
#if defined(PERL_OBJECT)
#else
#endif
#if defined(PERL_IN_AV_C) || defined(PERL_DECL_PROT)
#define avhv_index_sv(a)	S_avhv_index_sv(aTHX_ a)
#define avhv_index(a,b,c)	S_avhv_index(aTHX_ a,b,c)
#endif
#if defined(PERL_IN_DOOP_C) || defined(PERL_DECL_PROT)
#define do_trans_simple(a)	S_do_trans_simple(aTHX_ a)
#define do_trans_count(a)	S_do_trans_count(aTHX_ a)
#define do_trans_complex(a)	S_do_trans_complex(aTHX_ a)
#define do_trans_simple_utf8(a)	S_do_trans_simple_utf8(aTHX_ a)
#define do_trans_count_utf8(a)	S_do_trans_count_utf8(aTHX_ a)
#define do_trans_complex_utf8(a)	S_do_trans_complex_utf8(aTHX_ a)
#endif
#if defined(PERL_IN_GV_C) || defined(PERL_DECL_PROT)
#define gv_init_sv(a,b)		S_gv_init_sv(aTHX_ a,b)
#endif
#if defined(PERL_IN_HV_C) || defined(PERL_DECL_PROT)
#define hsplit(a)		S_hsplit(aTHX_ a)
#define hfreeentries(a)		S_hfreeentries(aTHX_ a)
#define more_he()		S_more_he(aTHX)
#define new_he()		S_new_he(aTHX)
#define del_he(a)		S_del_he(aTHX_ a)
#define save_hek(a,b,c)		S_save_hek(aTHX_ a,b,c)
#define hv_magic_check(a,b,c)	S_hv_magic_check(aTHX_ a,b,c)
#endif
#if defined(PERL_IN_MG_C) || defined(PERL_DECL_PROT)
#define save_magic(a,b)		S_save_magic(aTHX_ a,b)
#define magic_methpack(a,b,c)	S_magic_methpack(aTHX_ a,b,c)
#define magic_methcall(a,b,c,d,e,f)	S_magic_methcall(aTHX_ a,b,c,d,e,f)
#endif
#if defined(PERL_IN_OP_C) || defined(PERL_DECL_PROT)
#define list_assignment(a)	S_list_assignment(aTHX_ a)
#define bad_type(a,b,c,d)	S_bad_type(aTHX_ a,b,c,d)
#define cop_free(a)		S_cop_free(aTHX_ a)
#define modkids(a,b)		S_modkids(aTHX_ a,b)
#define no_bareword_allowed(a)	S_no_bareword_allowed(aTHX_ a)
#define no_fh_allowed(a)	S_no_fh_allowed(aTHX_ a)
#define scalarboolean(a)	S_scalarboolean(aTHX_ a)
#define too_few_arguments(a,b)	S_too_few_arguments(aTHX_ a,b)
#define too_many_arguments(a,b)	S_too_many_arguments(aTHX_ a,b)
#define trlist_upgrade(a,b)	S_trlist_upgrade(aTHX_ a,b)
#define op_clear(a)		S_op_clear(aTHX_ a)
#define null(a)			S_null(aTHX_ a)
#define pad_addlex(a)		S_pad_addlex(aTHX_ a)
#define pad_findlex(a,b,c,d,e,f,g)	S_pad_findlex(aTHX_ a,b,c,d,e,f,g)
#define newDEFSVOP()		S_newDEFSVOP(aTHX)
#define new_logop(a,b,c,d)	S_new_logop(aTHX_ a,b,c,d)
#define simplify_sort(a)	S_simplify_sort(aTHX_ a)
#define is_handle_constructor(a,b)	S_is_handle_constructor(aTHX_ a,b)
#define gv_ename(a)		S_gv_ename(aTHX_ a)
#define cv_dump(a)		S_cv_dump(aTHX_ a)
#define cv_clone2(a,b)		S_cv_clone2(aTHX_ a,b)
#define scalar_mod_type(a,b)	S_scalar_mod_type(aTHX_ a,b)
#define my_kid(a,b)		S_my_kid(aTHX_ a,b)
#define dup_attrlist(a)		S_dup_attrlist(aTHX_ a)
#define apply_attrs(a,b,c)	S_apply_attrs(aTHX_ a,b,c)
#  if defined(PL_OP_SLAB_ALLOC)
#define Slab_Alloc(a,b)		S_Slab_Alloc(aTHX_ a,b)
#  endif
#endif
#if defined(PERL_IN_PERL_C) || defined(PERL_DECL_PROT)
#define find_beginning()	S_find_beginning(aTHX)
#define forbid_setid(a)		S_forbid_setid(aTHX_ a)
#define incpush(a,b,c)		S_incpush(aTHX_ a,b,c)
#define init_interp()		S_init_interp(aTHX)
#define init_ids()		S_init_ids(aTHX)
#define init_lexer()		S_init_lexer(aTHX)
#define init_main_stash()	S_init_main_stash(aTHX)
#define init_perllib()		S_init_perllib(aTHX)
#define init_postdump_symbols(a,b,c)	S_init_postdump_symbols(aTHX_ a,b,c)
#define init_predump_symbols()	S_init_predump_symbols(aTHX)
#define my_exit_jump()		S_my_exit_jump(aTHX)
#define nuke_stacks()		S_nuke_stacks(aTHX)
#define open_script(a,b,c,d)	S_open_script(aTHX_ a,b,c,d)
#define usage(a)		S_usage(aTHX_ a)
#define validate_suid(a,b,c)	S_validate_suid(aTHX_ a,b,c)
#  if defined(IAMSUID)
#define fd_on_nosuid_fs(a)	S_fd_on_nosuid_fs(aTHX_ a)
#  endif
#define parse_body(a,b)		S_parse_body(aTHX_ a,b)
#define run_body(a)		S_run_body(aTHX_ a)
#define call_body(a,b)		S_call_body(aTHX_ a,b)
#define call_list_body(a)	S_call_list_body(aTHX_ a)
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
#define vparse_body(a)		S_vparse_body(aTHX_ a)
#define vrun_body(a)		S_vrun_body(aTHX_ a)
#define vcall_body(a)		S_vcall_body(aTHX_ a)
#define vcall_list_body(a)	S_vcall_list_body(aTHX_ a)
#endif
#  if defined(USE_THREADS)
#define init_main_thread()	S_init_main_thread(aTHX)
#  endif
#endif
#if defined(PERL_IN_PP_C) || defined(PERL_DECL_PROT)
#define doencodes(a,b,c)	S_doencodes(aTHX_ a,b,c)
#define refto(a)		S_refto(aTHX_ a)
#define seed()			S_seed(aTHX)
#define mul128(a,b)		S_mul128(aTHX_ a,b)
#define is_an_int(a,b)		S_is_an_int(aTHX_ a,b)
#define div128(a,b)		S_div128(aTHX_ a,b)
#endif
#if defined(PERL_IN_PP_CTL_C) || defined(PERL_DECL_PROT)
#define docatch(a)		S_docatch(aTHX_ a)
#define docatch_body()		S_docatch_body(aTHX)
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
#define vdocatch_body(a)	S_vdocatch_body(aTHX_ a)
#endif
#define dofindlabel(a,b,c,d)	S_dofindlabel(aTHX_ a,b,c,d)
#define doparseform(a)		S_doparseform(aTHX_ a)
#define dopoptoeval(a)		S_dopoptoeval(aTHX_ a)
#define dopoptolabel(a)		S_dopoptolabel(aTHX_ a)
#define dopoptoloop(a)		S_dopoptoloop(aTHX_ a)
#define dopoptosub(a)		S_dopoptosub(aTHX_ a)
#define dopoptosub_at(a,b)	S_dopoptosub_at(aTHX_ a,b)
#define save_lines(a,b)		S_save_lines(aTHX_ a,b)
#define doeval(a,b)		S_doeval(aTHX_ a,b)
#define doopen_pmc(a,b)		S_doopen_pmc(aTHX_ a,b)
#define qsortsv(a,b,c)		S_qsortsv(aTHX_ a,b,c)
#endif
#if defined(PERL_IN_PP_HOT_C) || defined(PERL_DECL_PROT)
#define do_maybe_phash(a,b,c,d,e)	S_do_maybe_phash(aTHX_ a,b,c,d,e)
#define do_oddball(a,b,c)	S_do_oddball(aTHX_ a,b,c)
#define get_db_sub(a,b)		S_get_db_sub(aTHX_ a,b)
#define method_common(a,b)	S_method_common(aTHX_ a,b)
#endif
#if defined(PERL_IN_PP_SYS_C) || defined(PERL_DECL_PROT)
#define doform(a,b,c)		S_doform(aTHX_ a,b,c)
#define emulate_eaccess(a,b)	S_emulate_eaccess(aTHX_ a,b)
#  if !defined(HAS_MKDIR) || !defined(HAS_RMDIR)
#define dooneliner(a,b)		S_dooneliner(aTHX_ a,b)
#  endif
#endif
#if defined(PERL_IN_REGCOMP_C) || defined(PERL_DECL_PROT)
#define reg(a,b)		S_reg(aTHX_ a,b)
#define reganode(a,b)		S_reganode(aTHX_ a,b)
#define regatom(a)		S_regatom(aTHX_ a)
#define regbranch(a,b)		S_regbranch(aTHX_ a,b)
#define reguni(a,b,c)		S_reguni(aTHX_ a,b,c)
#define regclass()		S_regclass(aTHX)
#define regclassutf8()		S_regclassutf8(aTHX)
#define regcurly(a)		S_regcurly(aTHX_ a)
#define reg_node(a)		S_reg_node(aTHX_ a)
#define regpiece(a)		S_regpiece(aTHX_ a)
#define reginsert(a,b)		S_reginsert(aTHX_ a,b)
#define regoptail(a,b)		S_regoptail(aTHX_ a,b)
#define regtail(a,b)		S_regtail(aTHX_ a,b)
#define regwhite(a,b)		S_regwhite(aTHX_ a,b)
#define nextchar()		S_nextchar(aTHX)
#define dumpuntil(a,b,c,d,e)	S_dumpuntil(aTHX_ a,b,c,d,e)
#define put_byte(a,b)		S_put_byte(aTHX_ a,b)
#define scan_commit(a)		S_scan_commit(aTHX_ a)
#define cl_anything(a)		S_cl_anything(aTHX_ a)
#define cl_is_anything(a)	S_cl_is_anything(aTHX_ a)
#define cl_init(a)		S_cl_init(aTHX_ a)
#define cl_init_zero(a)		S_cl_init_zero(aTHX_ a)
#define cl_and(a,b)		S_cl_and(aTHX_ a,b)
#define cl_or(a,b)		S_cl_or(aTHX_ a,b)
#define study_chunk(a,b,c,d,e)	S_study_chunk(aTHX_ a,b,c,d,e)
#define add_data(a,b)		S_add_data(aTHX_ a,b)
#define regpposixcc(a)		S_regpposixcc(aTHX_ a)
#define checkposixcc()		S_checkposixcc(aTHX)
#endif
#if defined(PERL_IN_REGEXEC_C) || defined(PERL_DECL_PROT)
#define regmatch(a)		S_regmatch(aTHX_ a)
#define regrepeat(a,b)		S_regrepeat(aTHX_ a,b)
#define regrepeat_hard(a,b,c)	S_regrepeat_hard(aTHX_ a,b,c)
#define regtry(a,b)		S_regtry(aTHX_ a,b)
#define reginclass(a,b)		S_reginclass(aTHX_ a,b)
#define reginclassutf8(a,b)	S_reginclassutf8(aTHX_ a,b)
#define regcppush(a)		S_regcppush(aTHX_ a)
#define regcppop()		S_regcppop(aTHX)
#define regcp_set_to(a)		S_regcp_set_to(aTHX_ a)
#define cache_re(a)		S_cache_re(aTHX_ a)
#define reghop(a,b)		S_reghop(aTHX_ a,b)
#define reghopmaybe(a,b)	S_reghopmaybe(aTHX_ a,b)
#define find_byclass(a,b,c,d,e,f)	S_find_byclass(aTHX_ a,b,c,d,e,f)
#endif
#if defined(PERL_IN_RUN_C) || defined(PERL_DECL_PROT)
#define debprof(a)		S_debprof(aTHX_ a)
#endif
#if defined(PERL_IN_SCOPE_C) || defined(PERL_DECL_PROT)
#define save_scalar_at(a)	S_save_scalar_at(aTHX_ a)
#endif
#if defined(PERL_IN_SV_C) || defined(PERL_DECL_PROT)
#define asIV(a)			S_asIV(aTHX_ a)
#define asUV(a)			S_asUV(aTHX_ a)
#define more_sv()		S_more_sv(aTHX)
#define more_xiv()		S_more_xiv(aTHX)
#define more_xnv()		S_more_xnv(aTHX)
#define more_xpv()		S_more_xpv(aTHX)
#define more_xpviv()		S_more_xpviv(aTHX)
#define more_xpvnv()		S_more_xpvnv(aTHX)
#define more_xpvcv()		S_more_xpvcv(aTHX)
#define more_xpvav()		S_more_xpvav(aTHX)
#define more_xpvhv()		S_more_xpvhv(aTHX)
#define more_xpvmg()		S_more_xpvmg(aTHX)
#define more_xpvlv()		S_more_xpvlv(aTHX)
#define more_xpvbm()		S_more_xpvbm(aTHX)
#define more_xrv()		S_more_xrv(aTHX)
#define new_xiv()		S_new_xiv(aTHX)
#define new_xnv()		S_new_xnv(aTHX)
#define new_xpv()		S_new_xpv(aTHX)
#define new_xpviv()		S_new_xpviv(aTHX)
#define new_xpvnv()		S_new_xpvnv(aTHX)
#define new_xpvcv()		S_new_xpvcv(aTHX)
#define new_xpvav()		S_new_xpvav(aTHX)
#define new_xpvhv()		S_new_xpvhv(aTHX)
#define new_xpvmg()		S_new_xpvmg(aTHX)
#define new_xpvlv()		S_new_xpvlv(aTHX)
#define new_xpvbm()		S_new_xpvbm(aTHX)
#define new_xrv()		S_new_xrv(aTHX)
#define del_xiv(a)		S_del_xiv(aTHX_ a)
#define del_xnv(a)		S_del_xnv(aTHX_ a)
#define del_xpv(a)		S_del_xpv(aTHX_ a)
#define del_xpviv(a)		S_del_xpviv(aTHX_ a)
#define del_xpvnv(a)		S_del_xpvnv(aTHX_ a)
#define del_xpvcv(a)		S_del_xpvcv(aTHX_ a)
#define del_xpvav(a)		S_del_xpvav(aTHX_ a)
#define del_xpvhv(a)		S_del_xpvhv(aTHX_ a)
#define del_xpvmg(a)		S_del_xpvmg(aTHX_ a)
#define del_xpvlv(a)		S_del_xpvlv(aTHX_ a)
#define del_xpvbm(a)		S_del_xpvbm(aTHX_ a)
#define del_xrv(a)		S_del_xrv(aTHX_ a)
#define sv_unglob(a)		S_sv_unglob(aTHX_ a)
#define not_a_number(a)		S_not_a_number(aTHX_ a)
#define visit(a)		S_visit(aTHX_ a)
#  if defined(DEBUGGING)
#define del_sv(a)		S_del_sv(aTHX_ a)
#  endif
#endif
#if defined(PERL_IN_TOKE_C) || defined(PERL_DECL_PROT)
#define check_uni()		S_check_uni(aTHX)
#define force_next(a)		S_force_next(aTHX_ a)
#define force_version(a)	S_force_version(aTHX_ a)
#define force_word(a,b,c,d,e)	S_force_word(aTHX_ a,b,c,d,e)
#define tokeq(a)		S_tokeq(aTHX_ a)
#define scan_const(a)		S_scan_const(aTHX_ a)
#define scan_formline(a)	S_scan_formline(aTHX_ a)
#define scan_heredoc(a)		S_scan_heredoc(aTHX_ a)
#define scan_ident(a,b,c,d,e)	S_scan_ident(aTHX_ a,b,c,d,e)
#define scan_inputsymbol(a)	S_scan_inputsymbol(aTHX_ a)
#define scan_pat(a,b)		S_scan_pat(aTHX_ a,b)
#define scan_str(a,b,c)		S_scan_str(aTHX_ a,b,c)
#define scan_subst(a)		S_scan_subst(aTHX_ a)
#define scan_trans(a)		S_scan_trans(aTHX_ a)
#define scan_word(a,b,c,d,e)	S_scan_word(aTHX_ a,b,c,d,e)
#define skipspace(a)		S_skipspace(aTHX_ a)
#define swallow_bom(a)		S_swallow_bom(aTHX_ a)
#define checkcomma(a,b,c)	S_checkcomma(aTHX_ a,b,c)
#define force_ident(a,b)	S_force_ident(aTHX_ a,b)
#define incline(a)		S_incline(aTHX_ a)
#define intuit_method(a,b)	S_intuit_method(aTHX_ a,b)
#define intuit_more(a)		S_intuit_more(aTHX_ a)
#define lop(a,b,c)		S_lop(aTHX_ a,b,c)
#define missingterm(a)		S_missingterm(aTHX_ a)
#define no_op(a,b)		S_no_op(aTHX_ a,b)
#define set_csh()		S_set_csh(aTHX)
#define sublex_done()		S_sublex_done(aTHX)
#define sublex_push()		S_sublex_push(aTHX)
#define sublex_start()		S_sublex_start(aTHX)
#define filter_gets(a,b,c)	S_filter_gets(aTHX_ a,b,c)
#define find_in_my_stash(a,b)	S_find_in_my_stash(aTHX_ a,b)
#define new_constant(a,b,c,d,e,f)	S_new_constant(aTHX_ a,b,c,d,e,f)
#define ao(a)			S_ao(aTHX_ a)
#define depcom()		S_depcom(aTHX)
#define incl_perldb()		S_incl_perldb(aTHX)
#if 0
#define utf16_textfilter(a,b,c)	S_utf16_textfilter(aTHX_ a,b,c)
#define utf16rev_textfilter(a,b,c)	S_utf16rev_textfilter(aTHX_ a,b,c)
#endif
#  if defined(CRIPPLED_CC)
#define uni(a,b)		S_uni(aTHX_ a,b)
#  endif
#  if defined(PERL_CR_FILTER)
#define cr_textfilter(a,b,c)	S_cr_textfilter(aTHX_ a,b,c)
#  endif
#endif
#if defined(PERL_IN_UNIVERSAL_C) || defined(PERL_DECL_PROT)
#define isa_lookup(a,b,c,d)	S_isa_lookup(aTHX_ a,b,c,d)
#endif
#if defined(PERL_IN_UTIL_C) || defined(PERL_DECL_PROT)
#define stdize_locale(a)	S_stdize_locale(aTHX_ a)
#define mess_alloc()		S_mess_alloc(aTHX)
#  if defined(LEAKTEST)
#define xstat(a)		S_xstat(aTHX_ a)
#  endif
#endif
#if defined(PERL_OBJECT)
#endif
#define ck_anoncode(a)		Perl_ck_anoncode(aTHX_ a)
#define ck_bitop(a)		Perl_ck_bitop(aTHX_ a)
#define ck_concat(a)		Perl_ck_concat(aTHX_ a)
#define ck_defined(a)		Perl_ck_defined(aTHX_ a)
#define ck_delete(a)		Perl_ck_delete(aTHX_ a)
#define ck_eof(a)		Perl_ck_eof(aTHX_ a)
#define ck_eval(a)		Perl_ck_eval(aTHX_ a)
#define ck_exec(a)		Perl_ck_exec(aTHX_ a)
#define ck_exists(a)		Perl_ck_exists(aTHX_ a)
#define ck_exit(a)		Perl_ck_exit(aTHX_ a)
#define ck_ftst(a)		Perl_ck_ftst(aTHX_ a)
#define ck_fun(a)		Perl_ck_fun(aTHX_ a)
#define ck_glob(a)		Perl_ck_glob(aTHX_ a)
#define ck_grep(a)		Perl_ck_grep(aTHX_ a)
#define ck_index(a)		Perl_ck_index(aTHX_ a)
#define ck_join(a)		Perl_ck_join(aTHX_ a)
#define ck_lengthconst(a)	Perl_ck_lengthconst(aTHX_ a)
#define ck_lfun(a)		Perl_ck_lfun(aTHX_ a)
#define ck_listiob(a)		Perl_ck_listiob(aTHX_ a)
#define ck_match(a)		Perl_ck_match(aTHX_ a)
#define ck_method(a)		Perl_ck_method(aTHX_ a)
#define ck_null(a)		Perl_ck_null(aTHX_ a)
#define ck_open(a)		Perl_ck_open(aTHX_ a)
#define ck_repeat(a)		Perl_ck_repeat(aTHX_ a)
#define ck_require(a)		Perl_ck_require(aTHX_ a)
#define ck_return(a)		Perl_ck_return(aTHX_ a)
#define ck_rfun(a)		Perl_ck_rfun(aTHX_ a)
#define ck_rvconst(a)		Perl_ck_rvconst(aTHX_ a)
#define ck_sassign(a)		Perl_ck_sassign(aTHX_ a)
#define ck_select(a)		Perl_ck_select(aTHX_ a)
#define ck_shift(a)		Perl_ck_shift(aTHX_ a)
#define ck_sort(a)		Perl_ck_sort(aTHX_ a)
#define ck_spair(a)		Perl_ck_spair(aTHX_ a)
#define ck_split(a)		Perl_ck_split(aTHX_ a)
#define ck_subr(a)		Perl_ck_subr(aTHX_ a)
#define ck_substr(a)		Perl_ck_substr(aTHX_ a)
#define ck_svconst(a)		Perl_ck_svconst(aTHX_ a)
#define ck_trunc(a)		Perl_ck_trunc(aTHX_ a)
#define pp_aassign()		Perl_pp_aassign(aTHX)
#define pp_abs()		Perl_pp_abs(aTHX)
#define pp_accept()		Perl_pp_accept(aTHX)
#define pp_add()		Perl_pp_add(aTHX)
#define pp_aelem()		Perl_pp_aelem(aTHX)
#define pp_aelemfast()		Perl_pp_aelemfast(aTHX)
#define pp_alarm()		Perl_pp_alarm(aTHX)
#define pp_and()		Perl_pp_and(aTHX)
#define pp_andassign()		Perl_pp_andassign(aTHX)
#define pp_anoncode()		Perl_pp_anoncode(aTHX)
#define pp_anonhash()		Perl_pp_anonhash(aTHX)
#define pp_anonlist()		Perl_pp_anonlist(aTHX)
#define pp_aslice()		Perl_pp_aslice(aTHX)
#define pp_atan2()		Perl_pp_atan2(aTHX)
#define pp_av2arylen()		Perl_pp_av2arylen(aTHX)
#define pp_backtick()		Perl_pp_backtick(aTHX)
#define pp_bind()		Perl_pp_bind(aTHX)
#define pp_binmode()		Perl_pp_binmode(aTHX)
#define pp_bit_and()		Perl_pp_bit_and(aTHX)
#define pp_bit_or()		Perl_pp_bit_or(aTHX)
#define pp_bit_xor()		Perl_pp_bit_xor(aTHX)
#define pp_bless()		Perl_pp_bless(aTHX)
#define pp_caller()		Perl_pp_caller(aTHX)
#define pp_chdir()		Perl_pp_chdir(aTHX)
#define pp_chmod()		Perl_pp_chmod(aTHX)
#define pp_chomp()		Perl_pp_chomp(aTHX)
#define pp_chop()		Perl_pp_chop(aTHX)
#define pp_chown()		Perl_pp_chown(aTHX)
#define pp_chr()		Perl_pp_chr(aTHX)
#define pp_chroot()		Perl_pp_chroot(aTHX)
#define pp_close()		Perl_pp_close(aTHX)
#define pp_closedir()		Perl_pp_closedir(aTHX)
#define pp_complement()		Perl_pp_complement(aTHX)
#define pp_concat()		Perl_pp_concat(aTHX)
#define pp_cond_expr()		Perl_pp_cond_expr(aTHX)
#define pp_connect()		Perl_pp_connect(aTHX)
#define pp_const()		Perl_pp_const(aTHX)
#define pp_cos()		Perl_pp_cos(aTHX)
#define pp_crypt()		Perl_pp_crypt(aTHX)
#define pp_dbmclose()		Perl_pp_dbmclose(aTHX)
#define pp_dbmopen()		Perl_pp_dbmopen(aTHX)
#define pp_dbstate()		Perl_pp_dbstate(aTHX)
#define pp_defined()		Perl_pp_defined(aTHX)
#define pp_delete()		Perl_pp_delete(aTHX)
#define pp_die()		Perl_pp_die(aTHX)
#define pp_divide()		Perl_pp_divide(aTHX)
#define pp_dofile()		Perl_pp_dofile(aTHX)
#define pp_dump()		Perl_pp_dump(aTHX)
#define pp_each()		Perl_pp_each(aTHX)
#define pp_egrent()		Perl_pp_egrent(aTHX)
#define pp_ehostent()		Perl_pp_ehostent(aTHX)
#define pp_enetent()		Perl_pp_enetent(aTHX)
#define pp_enter()		Perl_pp_enter(aTHX)
#define pp_entereval()		Perl_pp_entereval(aTHX)
#define pp_enteriter()		Perl_pp_enteriter(aTHX)
#define pp_enterloop()		Perl_pp_enterloop(aTHX)
#define pp_entersub()		Perl_pp_entersub(aTHX)
#define pp_entertry()		Perl_pp_entertry(aTHX)
#define pp_enterwrite()		Perl_pp_enterwrite(aTHX)
#define pp_eof()		Perl_pp_eof(aTHX)
#define pp_eprotoent()		Perl_pp_eprotoent(aTHX)
#define pp_epwent()		Perl_pp_epwent(aTHX)
#define pp_eq()			Perl_pp_eq(aTHX)
#define pp_eservent()		Perl_pp_eservent(aTHX)
#define pp_exec()		Perl_pp_exec(aTHX)
#define pp_exists()		Perl_pp_exists(aTHX)
#define pp_exit()		Perl_pp_exit(aTHX)
#define pp_exp()		Perl_pp_exp(aTHX)
#define pp_fcntl()		Perl_pp_fcntl(aTHX)
#define pp_fileno()		Perl_pp_fileno(aTHX)
#define pp_flip()		Perl_pp_flip(aTHX)
#define pp_flock()		Perl_pp_flock(aTHX)
#define pp_flop()		Perl_pp_flop(aTHX)
#define pp_fork()		Perl_pp_fork(aTHX)
#define pp_formline()		Perl_pp_formline(aTHX)
#define pp_ftatime()		Perl_pp_ftatime(aTHX)
#define pp_ftbinary()		Perl_pp_ftbinary(aTHX)
#define pp_ftblk()		Perl_pp_ftblk(aTHX)
#define pp_ftchr()		Perl_pp_ftchr(aTHX)
#define pp_ftctime()		Perl_pp_ftctime(aTHX)
#define pp_ftdir()		Perl_pp_ftdir(aTHX)
#define pp_fteexec()		Perl_pp_fteexec(aTHX)
#define pp_fteowned()		Perl_pp_fteowned(aTHX)
#define pp_fteread()		Perl_pp_fteread(aTHX)
#define pp_ftewrite()		Perl_pp_ftewrite(aTHX)
#define pp_ftfile()		Perl_pp_ftfile(aTHX)
#define pp_ftis()		Perl_pp_ftis(aTHX)
#define pp_ftlink()		Perl_pp_ftlink(aTHX)
#define pp_ftmtime()		Perl_pp_ftmtime(aTHX)
#define pp_ftpipe()		Perl_pp_ftpipe(aTHX)
#define pp_ftrexec()		Perl_pp_ftrexec(aTHX)
#define pp_ftrowned()		Perl_pp_ftrowned(aTHX)
#define pp_ftrread()		Perl_pp_ftrread(aTHX)
#define pp_ftrwrite()		Perl_pp_ftrwrite(aTHX)
#define pp_ftsgid()		Perl_pp_ftsgid(aTHX)
#define pp_ftsize()		Perl_pp_ftsize(aTHX)
#define pp_ftsock()		Perl_pp_ftsock(aTHX)
#define pp_ftsuid()		Perl_pp_ftsuid(aTHX)
#define pp_ftsvtx()		Perl_pp_ftsvtx(aTHX)
#define pp_fttext()		Perl_pp_fttext(aTHX)
#define pp_fttty()		Perl_pp_fttty(aTHX)
#define pp_ftzero()		Perl_pp_ftzero(aTHX)
#define pp_ge()			Perl_pp_ge(aTHX)
#define pp_gelem()		Perl_pp_gelem(aTHX)
#define pp_getc()		Perl_pp_getc(aTHX)
#define pp_getlogin()		Perl_pp_getlogin(aTHX)
#define pp_getpeername()	Perl_pp_getpeername(aTHX)
#define pp_getpgrp()		Perl_pp_getpgrp(aTHX)
#define pp_getppid()		Perl_pp_getppid(aTHX)
#define pp_getpriority()	Perl_pp_getpriority(aTHX)
#define pp_getsockname()	Perl_pp_getsockname(aTHX)
#define pp_ggrent()		Perl_pp_ggrent(aTHX)
#define pp_ggrgid()		Perl_pp_ggrgid(aTHX)
#define pp_ggrnam()		Perl_pp_ggrnam(aTHX)
#define pp_ghbyaddr()		Perl_pp_ghbyaddr(aTHX)
#define pp_ghbyname()		Perl_pp_ghbyname(aTHX)
#define pp_ghostent()		Perl_pp_ghostent(aTHX)
#define pp_glob()		Perl_pp_glob(aTHX)
#define pp_gmtime()		Perl_pp_gmtime(aTHX)
#define pp_gnbyaddr()		Perl_pp_gnbyaddr(aTHX)
#define pp_gnbyname()		Perl_pp_gnbyname(aTHX)
#define pp_gnetent()		Perl_pp_gnetent(aTHX)
#define pp_goto()		Perl_pp_goto(aTHX)
#define pp_gpbyname()		Perl_pp_gpbyname(aTHX)
#define pp_gpbynumber()		Perl_pp_gpbynumber(aTHX)
#define pp_gprotoent()		Perl_pp_gprotoent(aTHX)
#define pp_gpwent()		Perl_pp_gpwent(aTHX)
#define pp_gpwnam()		Perl_pp_gpwnam(aTHX)
#define pp_gpwuid()		Perl_pp_gpwuid(aTHX)
#define pp_grepstart()		Perl_pp_grepstart(aTHX)
#define pp_grepwhile()		Perl_pp_grepwhile(aTHX)
#define pp_gsbyname()		Perl_pp_gsbyname(aTHX)
#define pp_gsbyport()		Perl_pp_gsbyport(aTHX)
#define pp_gservent()		Perl_pp_gservent(aTHX)
#define pp_gsockopt()		Perl_pp_gsockopt(aTHX)
#define pp_gt()			Perl_pp_gt(aTHX)
#define pp_gv()			Perl_pp_gv(aTHX)
#define pp_gvsv()		Perl_pp_gvsv(aTHX)
#define pp_helem()		Perl_pp_helem(aTHX)
#define pp_hex()		Perl_pp_hex(aTHX)
#define pp_hslice()		Perl_pp_hslice(aTHX)
#define pp_i_add()		Perl_pp_i_add(aTHX)
#define pp_i_divide()		Perl_pp_i_divide(aTHX)
#define pp_i_eq()		Perl_pp_i_eq(aTHX)
#define pp_i_ge()		Perl_pp_i_ge(aTHX)
#define pp_i_gt()		Perl_pp_i_gt(aTHX)
#define pp_i_le()		Perl_pp_i_le(aTHX)
#define pp_i_lt()		Perl_pp_i_lt(aTHX)
#define pp_i_modulo()		Perl_pp_i_modulo(aTHX)
#define pp_i_multiply()		Perl_pp_i_multiply(aTHX)
#define pp_i_ncmp()		Perl_pp_i_ncmp(aTHX)
#define pp_i_ne()		Perl_pp_i_ne(aTHX)
#define pp_i_negate()		Perl_pp_i_negate(aTHX)
#define pp_i_subtract()		Perl_pp_i_subtract(aTHX)
#define pp_index()		Perl_pp_index(aTHX)
#define pp_int()		Perl_pp_int(aTHX)
#define pp_ioctl()		Perl_pp_ioctl(aTHX)
#define pp_iter()		Perl_pp_iter(aTHX)
#define pp_join()		Perl_pp_join(aTHX)
#define pp_keys()		Perl_pp_keys(aTHX)
#define pp_kill()		Perl_pp_kill(aTHX)
#define pp_last()		Perl_pp_last(aTHX)
#define pp_lc()			Perl_pp_lc(aTHX)
#define pp_lcfirst()		Perl_pp_lcfirst(aTHX)
#define pp_le()			Perl_pp_le(aTHX)
#define pp_leave()		Perl_pp_leave(aTHX)
#define pp_leaveeval()		Perl_pp_leaveeval(aTHX)
#define pp_leaveloop()		Perl_pp_leaveloop(aTHX)
#define pp_leavesub()		Perl_pp_leavesub(aTHX)
#define pp_leavesublv()		Perl_pp_leavesublv(aTHX)
#define pp_leavetry()		Perl_pp_leavetry(aTHX)
#define pp_leavewrite()		Perl_pp_leavewrite(aTHX)
#define pp_left_shift()		Perl_pp_left_shift(aTHX)
#define pp_length()		Perl_pp_length(aTHX)
#define pp_lineseq()		Perl_pp_lineseq(aTHX)
#define pp_link()		Perl_pp_link(aTHX)
#define pp_list()		Perl_pp_list(aTHX)
#define pp_listen()		Perl_pp_listen(aTHX)
#define pp_localtime()		Perl_pp_localtime(aTHX)
#define pp_lock()		Perl_pp_lock(aTHX)
#define pp_log()		Perl_pp_log(aTHX)
#define pp_lslice()		Perl_pp_lslice(aTHX)
#define pp_lstat()		Perl_pp_lstat(aTHX)
#define pp_lt()			Perl_pp_lt(aTHX)
#define pp_mapstart()		Perl_pp_mapstart(aTHX)
#define pp_mapwhile()		Perl_pp_mapwhile(aTHX)
#define pp_match()		Perl_pp_match(aTHX)
#define pp_method()		Perl_pp_method(aTHX)
#define pp_method_named()	Perl_pp_method_named(aTHX)
#define pp_mkdir()		Perl_pp_mkdir(aTHX)
#define pp_modulo()		Perl_pp_modulo(aTHX)
#define pp_msgctl()		Perl_pp_msgctl(aTHX)
#define pp_msgget()		Perl_pp_msgget(aTHX)
#define pp_msgrcv()		Perl_pp_msgrcv(aTHX)
#define pp_msgsnd()		Perl_pp_msgsnd(aTHX)
#define pp_multiply()		Perl_pp_multiply(aTHX)
#define pp_ncmp()		Perl_pp_ncmp(aTHX)
#define pp_ne()			Perl_pp_ne(aTHX)
#define pp_negate()		Perl_pp_negate(aTHX)
#define pp_next()		Perl_pp_next(aTHX)
#define pp_nextstate()		Perl_pp_nextstate(aTHX)
#define pp_not()		Perl_pp_not(aTHX)
#define pp_null()		Perl_pp_null(aTHX)
#define pp_oct()		Perl_pp_oct(aTHX)
#define pp_open()		Perl_pp_open(aTHX)
#define pp_open_dir()		Perl_pp_open_dir(aTHX)
#define pp_or()			Perl_pp_or(aTHX)
#define pp_orassign()		Perl_pp_orassign(aTHX)
#define pp_ord()		Perl_pp_ord(aTHX)
#define pp_pack()		Perl_pp_pack(aTHX)
#define pp_padany()		Perl_pp_padany(aTHX)
#define pp_padav()		Perl_pp_padav(aTHX)
#define pp_padhv()		Perl_pp_padhv(aTHX)
#define pp_padsv()		Perl_pp_padsv(aTHX)
#define pp_pipe_op()		Perl_pp_pipe_op(aTHX)
#define pp_pop()		Perl_pp_pop(aTHX)
#define pp_pos()		Perl_pp_pos(aTHX)
#define pp_postdec()		Perl_pp_postdec(aTHX)
#define pp_postinc()		Perl_pp_postinc(aTHX)
#define pp_pow()		Perl_pp_pow(aTHX)
#define pp_predec()		Perl_pp_predec(aTHX)
#define pp_preinc()		Perl_pp_preinc(aTHX)
#define pp_print()		Perl_pp_print(aTHX)
#define pp_prototype()		Perl_pp_prototype(aTHX)
#define pp_prtf()		Perl_pp_prtf(aTHX)
#define pp_push()		Perl_pp_push(aTHX)
#define pp_pushmark()		Perl_pp_pushmark(aTHX)
#define pp_pushre()		Perl_pp_pushre(aTHX)
#define pp_qr()			Perl_pp_qr(aTHX)
#define pp_quotemeta()		Perl_pp_quotemeta(aTHX)
#define pp_rand()		Perl_pp_rand(aTHX)
#define pp_range()		Perl_pp_range(aTHX)
#define pp_rcatline()		Perl_pp_rcatline(aTHX)
#define pp_read()		Perl_pp_read(aTHX)
#define pp_readdir()		Perl_pp_readdir(aTHX)
#define pp_readline()		Perl_pp_readline(aTHX)
#define pp_readlink()		Perl_pp_readlink(aTHX)
#define pp_recv()		Perl_pp_recv(aTHX)
#define pp_redo()		Perl_pp_redo(aTHX)
#define pp_ref()		Perl_pp_ref(aTHX)
#define pp_refgen()		Perl_pp_refgen(aTHX)
#define pp_regcmaybe()		Perl_pp_regcmaybe(aTHX)
#define pp_regcomp()		Perl_pp_regcomp(aTHX)
#define pp_regcreset()		Perl_pp_regcreset(aTHX)
#define pp_rename()		Perl_pp_rename(aTHX)
#define pp_repeat()		Perl_pp_repeat(aTHX)
#define pp_require()		Perl_pp_require(aTHX)
#define pp_reset()		Perl_pp_reset(aTHX)
#define pp_return()		Perl_pp_return(aTHX)
#define pp_reverse()		Perl_pp_reverse(aTHX)
#define pp_rewinddir()		Perl_pp_rewinddir(aTHX)
#define pp_right_shift()	Perl_pp_right_shift(aTHX)
#define pp_rindex()		Perl_pp_rindex(aTHX)
#define pp_rmdir()		Perl_pp_rmdir(aTHX)
#define pp_rv2av()		Perl_pp_rv2av(aTHX)
#define pp_rv2cv()		Perl_pp_rv2cv(aTHX)
#define pp_rv2gv()		Perl_pp_rv2gv(aTHX)
#define pp_rv2hv()		Perl_pp_rv2hv(aTHX)
#define pp_rv2sv()		Perl_pp_rv2sv(aTHX)
#define pp_sassign()		Perl_pp_sassign(aTHX)
#define pp_scalar()		Perl_pp_scalar(aTHX)
#define pp_schomp()		Perl_pp_schomp(aTHX)
#define pp_schop()		Perl_pp_schop(aTHX)
#define pp_scmp()		Perl_pp_scmp(aTHX)
#define pp_scope()		Perl_pp_scope(aTHX)
#define pp_seek()		Perl_pp_seek(aTHX)
#define pp_seekdir()		Perl_pp_seekdir(aTHX)
#define pp_select()		Perl_pp_select(aTHX)
#define pp_semctl()		Perl_pp_semctl(aTHX)
#define pp_semget()		Perl_pp_semget(aTHX)
#define pp_semop()		Perl_pp_semop(aTHX)
#define pp_send()		Perl_pp_send(aTHX)
#define pp_seq()		Perl_pp_seq(aTHX)
#define pp_setpgrp()		Perl_pp_setpgrp(aTHX)
#define pp_setpriority()	Perl_pp_setpriority(aTHX)
#define pp_setstate()		Perl_pp_setstate(aTHX)
#define pp_sge()		Perl_pp_sge(aTHX)
#define pp_sgrent()		Perl_pp_sgrent(aTHX)
#define pp_sgt()		Perl_pp_sgt(aTHX)
#define pp_shift()		Perl_pp_shift(aTHX)
#define pp_shmctl()		Perl_pp_shmctl(aTHX)
#define pp_shmget()		Perl_pp_shmget(aTHX)
#define pp_shmread()		Perl_pp_shmread(aTHX)
#define pp_shmwrite()		Perl_pp_shmwrite(aTHX)
#define pp_shostent()		Perl_pp_shostent(aTHX)
#define pp_shutdown()		Perl_pp_shutdown(aTHX)
#define pp_sin()		Perl_pp_sin(aTHX)
#define pp_sle()		Perl_pp_sle(aTHX)
#define pp_sleep()		Perl_pp_sleep(aTHX)
#define pp_slt()		Perl_pp_slt(aTHX)
#define pp_sne()		Perl_pp_sne(aTHX)
#define pp_snetent()		Perl_pp_snetent(aTHX)
#define pp_socket()		Perl_pp_socket(aTHX)
#define pp_sockpair()		Perl_pp_sockpair(aTHX)
#define pp_sort()		Perl_pp_sort(aTHX)
#define pp_splice()		Perl_pp_splice(aTHX)
#define pp_split()		Perl_pp_split(aTHX)
#define pp_sprintf()		Perl_pp_sprintf(aTHX)
#define pp_sprotoent()		Perl_pp_sprotoent(aTHX)
#define pp_spwent()		Perl_pp_spwent(aTHX)
#define pp_sqrt()		Perl_pp_sqrt(aTHX)
#define pp_srand()		Perl_pp_srand(aTHX)
#define pp_srefgen()		Perl_pp_srefgen(aTHX)
#define pp_sselect()		Perl_pp_sselect(aTHX)
#define pp_sservent()		Perl_pp_sservent(aTHX)
#define pp_ssockopt()		Perl_pp_ssockopt(aTHX)
#define pp_stat()		Perl_pp_stat(aTHX)
#define pp_stringify()		Perl_pp_stringify(aTHX)
#define pp_stub()		Perl_pp_stub(aTHX)
#define pp_study()		Perl_pp_study(aTHX)
#define pp_subst()		Perl_pp_subst(aTHX)
#define pp_substcont()		Perl_pp_substcont(aTHX)
#define pp_substr()		Perl_pp_substr(aTHX)
#define pp_subtract()		Perl_pp_subtract(aTHX)
#define pp_symlink()		Perl_pp_symlink(aTHX)
#define pp_syscall()		Perl_pp_syscall(aTHX)
#define pp_sysopen()		Perl_pp_sysopen(aTHX)
#define pp_sysread()		Perl_pp_sysread(aTHX)
#define pp_sysseek()		Perl_pp_sysseek(aTHX)
#define pp_system()		Perl_pp_system(aTHX)
#define pp_syswrite()		Perl_pp_syswrite(aTHX)
#define pp_tell()		Perl_pp_tell(aTHX)
#define pp_telldir()		Perl_pp_telldir(aTHX)
#define pp_threadsv()		Perl_pp_threadsv(aTHX)
#define pp_tie()		Perl_pp_tie(aTHX)
#define pp_tied()		Perl_pp_tied(aTHX)
#define pp_time()		Perl_pp_time(aTHX)
#define pp_tms()		Perl_pp_tms(aTHX)
#define pp_trans()		Perl_pp_trans(aTHX)
#define pp_truncate()		Perl_pp_truncate(aTHX)
#define pp_uc()			Perl_pp_uc(aTHX)
#define pp_ucfirst()		Perl_pp_ucfirst(aTHX)
#define pp_umask()		Perl_pp_umask(aTHX)
#define pp_undef()		Perl_pp_undef(aTHX)
#define pp_unlink()		Perl_pp_unlink(aTHX)
#define pp_unpack()		Perl_pp_unpack(aTHX)
#define pp_unshift()		Perl_pp_unshift(aTHX)
#define pp_unstack()		Perl_pp_unstack(aTHX)
#define pp_untie()		Perl_pp_untie(aTHX)
#define pp_utime()		Perl_pp_utime(aTHX)
#define pp_values()		Perl_pp_values(aTHX)
#define pp_vec()		Perl_pp_vec(aTHX)
#define pp_wait()		Perl_pp_wait(aTHX)
#define pp_waitpid()		Perl_pp_waitpid(aTHX)
#define pp_wantarray()		Perl_pp_wantarray(aTHX)
#define pp_warn()		Perl_pp_warn(aTHX)
#define pp_xor()		Perl_pp_xor(aTHX)

#endif	/* PERL_IMPLICIT_CONTEXT */
#else	/* PERL_OBJECT */

#if defined(PERL_IMPLICIT_SYS)
#endif
#if defined(USE_ITHREADS)
#  if defined(PERL_IMPLICIT_SYS)
#  endif
#endif
#define malloc			Perl_malloc
#define calloc			Perl_calloc
#define realloc			Perl_realloc
#define mfree			Perl_mfree
#if defined(MYMALLOC)
#define malloced_size		Perl_malloced_size
#endif
#define get_context		Perl_get_context
#define set_context		Perl_set_context
#if defined(PERL_OBJECT)
#ifndef __BORLANDC__
#endif
#endif
#if defined(PERL_OBJECT)
#else
#endif
#define Perl_amagic_call	CPerlObj::Perl_amagic_call
#define amagic_call		Perl_amagic_call
#define Perl_Gv_AMupdate	CPerlObj::Perl_Gv_AMupdate
#define Gv_AMupdate		Perl_Gv_AMupdate
#define Perl_append_elem	CPerlObj::Perl_append_elem
#define append_elem		Perl_append_elem
#define Perl_append_list	CPerlObj::Perl_append_list
#define append_list		Perl_append_list
#define Perl_apply		CPerlObj::Perl_apply
#define apply			Perl_apply
#define Perl_apply_attrs_string	CPerlObj::Perl_apply_attrs_string
#define apply_attrs_string	Perl_apply_attrs_string
#define Perl_avhv_delete_ent	CPerlObj::Perl_avhv_delete_ent
#define avhv_delete_ent		Perl_avhv_delete_ent
#define Perl_avhv_exists_ent	CPerlObj::Perl_avhv_exists_ent
#define avhv_exists_ent		Perl_avhv_exists_ent
#define Perl_avhv_fetch_ent	CPerlObj::Perl_avhv_fetch_ent
#define avhv_fetch_ent		Perl_avhv_fetch_ent
#define Perl_avhv_store_ent	CPerlObj::Perl_avhv_store_ent
#define avhv_store_ent		Perl_avhv_store_ent
#define Perl_avhv_iternext	CPerlObj::Perl_avhv_iternext
#define avhv_iternext		Perl_avhv_iternext
#define Perl_avhv_iterval	CPerlObj::Perl_avhv_iterval
#define avhv_iterval		Perl_avhv_iterval
#define Perl_avhv_keys		CPerlObj::Perl_avhv_keys
#define avhv_keys		Perl_avhv_keys
#define Perl_av_clear		CPerlObj::Perl_av_clear
#define av_clear		Perl_av_clear
#define Perl_av_delete		CPerlObj::Perl_av_delete
#define av_delete		Perl_av_delete
#define Perl_av_exists		CPerlObj::Perl_av_exists
#define av_exists		Perl_av_exists
#define Perl_av_extend		CPerlObj::Perl_av_extend
#define av_extend		Perl_av_extend
#define Perl_av_fake		CPerlObj::Perl_av_fake
#define av_fake			Perl_av_fake
#define Perl_av_fetch		CPerlObj::Perl_av_fetch
#define av_fetch		Perl_av_fetch
#define Perl_av_fill		CPerlObj::Perl_av_fill
#define av_fill			Perl_av_fill
#define Perl_av_len		CPerlObj::Perl_av_len
#define av_len			Perl_av_len
#define Perl_av_make		CPerlObj::Perl_av_make
#define av_make			Perl_av_make
#define Perl_av_pop		CPerlObj::Perl_av_pop
#define av_pop			Perl_av_pop
#define Perl_av_push		CPerlObj::Perl_av_push
#define av_push			Perl_av_push
#define Perl_av_reify		CPerlObj::Perl_av_reify
#define av_reify		Perl_av_reify
#define Perl_av_shift		CPerlObj::Perl_av_shift
#define av_shift		Perl_av_shift
#define Perl_av_store		CPerlObj::Perl_av_store
#define av_store		Perl_av_store
#define Perl_av_undef		CPerlObj::Perl_av_undef
#define av_undef		Perl_av_undef
#define Perl_av_unshift		CPerlObj::Perl_av_unshift
#define av_unshift		Perl_av_unshift
#define Perl_bind_match		CPerlObj::Perl_bind_match
#define bind_match		Perl_bind_match
#define Perl_block_end		CPerlObj::Perl_block_end
#define block_end		Perl_block_end
#define Perl_block_gimme	CPerlObj::Perl_block_gimme
#define block_gimme		Perl_block_gimme
#define Perl_block_start	CPerlObj::Perl_block_start
#define block_start		Perl_block_start
#define Perl_boot_core_UNIVERSAL	CPerlObj::Perl_boot_core_UNIVERSAL
#define boot_core_UNIVERSAL	Perl_boot_core_UNIVERSAL
#define Perl_call_list		CPerlObj::Perl_call_list
#define call_list		Perl_call_list
#define Perl_cando		CPerlObj::Perl_cando
#define cando			Perl_cando
#define Perl_cast_ulong		CPerlObj::Perl_cast_ulong
#define cast_ulong		Perl_cast_ulong
#define Perl_cast_i32		CPerlObj::Perl_cast_i32
#define cast_i32		Perl_cast_i32
#define Perl_cast_iv		CPerlObj::Perl_cast_iv
#define cast_iv			Perl_cast_iv
#define Perl_cast_uv		CPerlObj::Perl_cast_uv
#define cast_uv			Perl_cast_uv
#if !defined(HAS_TRUNCATE) && !defined(HAS_CHSIZE) && defined(F_FREESP)
#define Perl_my_chsize		CPerlObj::Perl_my_chsize
#define my_chsize		Perl_my_chsize
#endif
#if defined(USE_THREADS)
#define Perl_condpair_magic	CPerlObj::Perl_condpair_magic
#define condpair_magic		Perl_condpair_magic
#endif
#define Perl_convert		CPerlObj::Perl_convert
#define convert			Perl_convert
#define Perl_croak		CPerlObj::Perl_croak
#define croak			Perl_croak
#define Perl_vcroak		CPerlObj::Perl_vcroak
#define vcroak			Perl_vcroak
#if defined(PERL_IMPLICIT_CONTEXT)
#define Perl_croak_nocontext	CPerlObj::Perl_croak_nocontext
#define croak_nocontext		Perl_croak_nocontext
#define Perl_die_nocontext	CPerlObj::Perl_die_nocontext
#define die_nocontext		Perl_die_nocontext
#define Perl_deb_nocontext	CPerlObj::Perl_deb_nocontext
#define deb_nocontext		Perl_deb_nocontext
#define Perl_form_nocontext	CPerlObj::Perl_form_nocontext
#define form_nocontext		Perl_form_nocontext
#define Perl_load_module_nocontext	CPerlObj::Perl_load_module_nocontext
#define load_module_nocontext	Perl_load_module_nocontext
#define Perl_mess_nocontext	CPerlObj::Perl_mess_nocontext
#define mess_nocontext		Perl_mess_nocontext
#define Perl_warn_nocontext	CPerlObj::Perl_warn_nocontext
#define warn_nocontext		Perl_warn_nocontext
#define Perl_warner_nocontext	CPerlObj::Perl_warner_nocontext
#define warner_nocontext	Perl_warner_nocontext
#define Perl_newSVpvf_nocontext	CPerlObj::Perl_newSVpvf_nocontext
#define newSVpvf_nocontext	Perl_newSVpvf_nocontext
#define Perl_sv_catpvf_nocontext	CPerlObj::Perl_sv_catpvf_nocontext
#define sv_catpvf_nocontext	Perl_sv_catpvf_nocontext
#define Perl_sv_setpvf_nocontext	CPerlObj::Perl_sv_setpvf_nocontext
#define sv_setpvf_nocontext	Perl_sv_setpvf_nocontext
#define Perl_sv_catpvf_mg_nocontext	CPerlObj::Perl_sv_catpvf_mg_nocontext
#define sv_catpvf_mg_nocontext	Perl_sv_catpvf_mg_nocontext
#define Perl_sv_setpvf_mg_nocontext	CPerlObj::Perl_sv_setpvf_mg_nocontext
#define sv_setpvf_mg_nocontext	Perl_sv_setpvf_mg_nocontext
#define Perl_fprintf_nocontext	CPerlObj::Perl_fprintf_nocontext
#define fprintf_nocontext	Perl_fprintf_nocontext
#define Perl_printf_nocontext	CPerlObj::Perl_printf_nocontext
#define printf_nocontext	Perl_printf_nocontext
#endif
#define Perl_cv_ckproto		CPerlObj::Perl_cv_ckproto
#define cv_ckproto		Perl_cv_ckproto
#define Perl_cv_clone		CPerlObj::Perl_cv_clone
#define cv_clone		Perl_cv_clone
#define Perl_cv_const_sv	CPerlObj::Perl_cv_const_sv
#define cv_const_sv		Perl_cv_const_sv
#define Perl_op_const_sv	CPerlObj::Perl_op_const_sv
#define op_const_sv		Perl_op_const_sv
#define Perl_cv_undef		CPerlObj::Perl_cv_undef
#define cv_undef		Perl_cv_undef
#define Perl_cx_dump		CPerlObj::Perl_cx_dump
#define cx_dump			Perl_cx_dump
#define Perl_filter_add		CPerlObj::Perl_filter_add
#define filter_add		Perl_filter_add
#define Perl_filter_del		CPerlObj::Perl_filter_del
#define filter_del		Perl_filter_del
#define Perl_filter_read	CPerlObj::Perl_filter_read
#define filter_read		Perl_filter_read
#define Perl_get_op_descs	CPerlObj::Perl_get_op_descs
#define get_op_descs		Perl_get_op_descs
#define Perl_get_op_names	CPerlObj::Perl_get_op_names
#define get_op_names		Perl_get_op_names
#define Perl_get_no_modify	CPerlObj::Perl_get_no_modify
#define get_no_modify		Perl_get_no_modify
#define Perl_get_opargs		CPerlObj::Perl_get_opargs
#define get_opargs		Perl_get_opargs
#define Perl_get_ppaddr		CPerlObj::Perl_get_ppaddr
#define get_ppaddr		Perl_get_ppaddr
#define Perl_cxinc		CPerlObj::Perl_cxinc
#define cxinc			Perl_cxinc
#define Perl_deb		CPerlObj::Perl_deb
#define deb			Perl_deb
#define Perl_vdeb		CPerlObj::Perl_vdeb
#define vdeb			Perl_vdeb
#define Perl_debprofdump	CPerlObj::Perl_debprofdump
#define debprofdump		Perl_debprofdump
#define Perl_debop		CPerlObj::Perl_debop
#define debop			Perl_debop
#define Perl_debstack		CPerlObj::Perl_debstack
#define debstack		Perl_debstack
#define Perl_debstackptrs	CPerlObj::Perl_debstackptrs
#define debstackptrs		Perl_debstackptrs
#define Perl_delimcpy		CPerlObj::Perl_delimcpy
#define delimcpy		Perl_delimcpy
#define Perl_deprecate		CPerlObj::Perl_deprecate
#define deprecate		Perl_deprecate
#define Perl_die		CPerlObj::Perl_die
#define die			Perl_die
#define Perl_vdie		CPerlObj::Perl_vdie
#define vdie			Perl_vdie
#define Perl_die_where		CPerlObj::Perl_die_where
#define die_where		Perl_die_where
#define Perl_dounwind		CPerlObj::Perl_dounwind
#define dounwind		Perl_dounwind
#define Perl_do_aexec		CPerlObj::Perl_do_aexec
#define do_aexec		Perl_do_aexec
#define Perl_do_aexec5		CPerlObj::Perl_do_aexec5
#define do_aexec5		Perl_do_aexec5
#define Perl_do_binmode		CPerlObj::Perl_do_binmode
#define do_binmode		Perl_do_binmode
#define Perl_do_chop		CPerlObj::Perl_do_chop
#define do_chop			Perl_do_chop
#define Perl_do_close		CPerlObj::Perl_do_close
#define do_close		Perl_do_close
#define Perl_do_eof		CPerlObj::Perl_do_eof
#define do_eof			Perl_do_eof
#define Perl_do_exec		CPerlObj::Perl_do_exec
#define do_exec			Perl_do_exec
#if defined(WIN32)
#define Perl_do_aspawn		CPerlObj::Perl_do_aspawn
#define do_aspawn		Perl_do_aspawn
#define Perl_do_spawn		CPerlObj::Perl_do_spawn
#define do_spawn		Perl_do_spawn
#define Perl_do_spawn_nowait	CPerlObj::Perl_do_spawn_nowait
#define do_spawn_nowait		Perl_do_spawn_nowait
#endif
#if !defined(WIN32)
#define Perl_do_exec3		CPerlObj::Perl_do_exec3
#define do_exec3		Perl_do_exec3
#endif
#define Perl_do_execfree	CPerlObj::Perl_do_execfree
#define do_execfree		Perl_do_execfree
#if defined(HAS_MSG) || defined(HAS_SEM) || defined(HAS_SHM)
#define Perl_do_ipcctl		CPerlObj::Perl_do_ipcctl
#define do_ipcctl		Perl_do_ipcctl
#define Perl_do_ipcget		CPerlObj::Perl_do_ipcget
#define do_ipcget		Perl_do_ipcget
#define Perl_do_msgrcv		CPerlObj::Perl_do_msgrcv
#define do_msgrcv		Perl_do_msgrcv
#define Perl_do_msgsnd		CPerlObj::Perl_do_msgsnd
#define do_msgsnd		Perl_do_msgsnd
#define Perl_do_semop		CPerlObj::Perl_do_semop
#define do_semop		Perl_do_semop
#define Perl_do_shmio		CPerlObj::Perl_do_shmio
#define do_shmio		Perl_do_shmio
#endif
#define Perl_do_join		CPerlObj::Perl_do_join
#define do_join			Perl_do_join
#define Perl_do_kv		CPerlObj::Perl_do_kv
#define do_kv			Perl_do_kv
#define Perl_do_open		CPerlObj::Perl_do_open
#define do_open			Perl_do_open
#define Perl_do_open9		CPerlObj::Perl_do_open9
#define do_open9		Perl_do_open9
#define Perl_do_pipe		CPerlObj::Perl_do_pipe
#define do_pipe			Perl_do_pipe
#define Perl_do_print		CPerlObj::Perl_do_print
#define do_print		Perl_do_print
#define Perl_do_readline	CPerlObj::Perl_do_readline
#define do_readline		Perl_do_readline
#define Perl_do_chomp		CPerlObj::Perl_do_chomp
#define do_chomp		Perl_do_chomp
#define Perl_do_seek		CPerlObj::Perl_do_seek
#define do_seek			Perl_do_seek
#define Perl_do_sprintf		CPerlObj::Perl_do_sprintf
#define do_sprintf		Perl_do_sprintf
#define Perl_do_sysseek		CPerlObj::Perl_do_sysseek
#define do_sysseek		Perl_do_sysseek
#define Perl_do_tell		CPerlObj::Perl_do_tell
#define do_tell			Perl_do_tell
#define Perl_do_trans		CPerlObj::Perl_do_trans
#define do_trans		Perl_do_trans
#define Perl_do_vecget		CPerlObj::Perl_do_vecget
#define do_vecget		Perl_do_vecget
#define Perl_do_vecset		CPerlObj::Perl_do_vecset
#define do_vecset		Perl_do_vecset
#define Perl_do_vop		CPerlObj::Perl_do_vop
#define do_vop			Perl_do_vop
#define Perl_dofile		CPerlObj::Perl_dofile
#define dofile			Perl_dofile
#define Perl_dowantarray	CPerlObj::Perl_dowantarray
#define dowantarray		Perl_dowantarray
#define Perl_dump_all		CPerlObj::Perl_dump_all
#define dump_all		Perl_dump_all
#define Perl_dump_eval		CPerlObj::Perl_dump_eval
#define dump_eval		Perl_dump_eval
#if defined(DUMP_FDS)
#define Perl_dump_fds		CPerlObj::Perl_dump_fds
#define dump_fds		Perl_dump_fds
#endif
#define Perl_dump_form		CPerlObj::Perl_dump_form
#define dump_form		Perl_dump_form
#define Perl_gv_dump		CPerlObj::Perl_gv_dump
#define gv_dump			Perl_gv_dump
#define Perl_op_dump		CPerlObj::Perl_op_dump
#define op_dump			Perl_op_dump
#define Perl_pmop_dump		CPerlObj::Perl_pmop_dump
#define pmop_dump		Perl_pmop_dump
#define Perl_dump_packsubs	CPerlObj::Perl_dump_packsubs
#define dump_packsubs		Perl_dump_packsubs
#define Perl_dump_sub		CPerlObj::Perl_dump_sub
#define dump_sub		Perl_dump_sub
#define Perl_fbm_compile	CPerlObj::Perl_fbm_compile
#define fbm_compile		Perl_fbm_compile
#define Perl_fbm_instr		CPerlObj::Perl_fbm_instr
#define fbm_instr		Perl_fbm_instr
#define Perl_find_script	CPerlObj::Perl_find_script
#define find_script		Perl_find_script
#if defined(USE_THREADS)
#define Perl_find_threadsv	CPerlObj::Perl_find_threadsv
#define find_threadsv		Perl_find_threadsv
#endif
#define Perl_force_list		CPerlObj::Perl_force_list
#define force_list		Perl_force_list
#define Perl_fold_constants	CPerlObj::Perl_fold_constants
#define fold_constants		Perl_fold_constants
#define Perl_form		CPerlObj::Perl_form
#define form			Perl_form
#define Perl_vform		CPerlObj::Perl_vform
#define vform			Perl_vform
#define Perl_free_tmps		CPerlObj::Perl_free_tmps
#define free_tmps		Perl_free_tmps
#define Perl_gen_constant_list	CPerlObj::Perl_gen_constant_list
#define gen_constant_list	Perl_gen_constant_list
#if !defined(HAS_GETENV_LEN)
#define Perl_getenv_len		CPerlObj::Perl_getenv_len
#define getenv_len		Perl_getenv_len
#endif
#define Perl_gp_free		CPerlObj::Perl_gp_free
#define gp_free			Perl_gp_free
#define Perl_gp_ref		CPerlObj::Perl_gp_ref
#define gp_ref			Perl_gp_ref
#define Perl_gv_AVadd		CPerlObj::Perl_gv_AVadd
#define gv_AVadd		Perl_gv_AVadd
#define Perl_gv_HVadd		CPerlObj::Perl_gv_HVadd
#define gv_HVadd		Perl_gv_HVadd
#define Perl_gv_IOadd		CPerlObj::Perl_gv_IOadd
#define gv_IOadd		Perl_gv_IOadd
#define Perl_gv_autoload4	CPerlObj::Perl_gv_autoload4
#define gv_autoload4		Perl_gv_autoload4
#define Perl_gv_check		CPerlObj::Perl_gv_check
#define gv_check		Perl_gv_check
#define Perl_gv_efullname	CPerlObj::Perl_gv_efullname
#define gv_efullname		Perl_gv_efullname
#define Perl_gv_efullname3	CPerlObj::Perl_gv_efullname3
#define gv_efullname3		Perl_gv_efullname3
#define Perl_gv_efullname4	CPerlObj::Perl_gv_efullname4
#define gv_efullname4		Perl_gv_efullname4
#define Perl_gv_fetchfile	CPerlObj::Perl_gv_fetchfile
#define gv_fetchfile		Perl_gv_fetchfile
#define Perl_gv_fetchmeth	CPerlObj::Perl_gv_fetchmeth
#define gv_fetchmeth		Perl_gv_fetchmeth
#define Perl_gv_fetchmethod	CPerlObj::Perl_gv_fetchmethod
#define gv_fetchmethod		Perl_gv_fetchmethod
#define Perl_gv_fetchmethod_autoload	CPerlObj::Perl_gv_fetchmethod_autoload
#define gv_fetchmethod_autoload	Perl_gv_fetchmethod_autoload
#define Perl_gv_fetchpv		CPerlObj::Perl_gv_fetchpv
#define gv_fetchpv		Perl_gv_fetchpv
#define Perl_gv_fullname	CPerlObj::Perl_gv_fullname
#define gv_fullname		Perl_gv_fullname
#define Perl_gv_fullname3	CPerlObj::Perl_gv_fullname3
#define gv_fullname3		Perl_gv_fullname3
#define Perl_gv_fullname4	CPerlObj::Perl_gv_fullname4
#define gv_fullname4		Perl_gv_fullname4
#define Perl_gv_init		CPerlObj::Perl_gv_init
#define gv_init			Perl_gv_init
#define Perl_gv_stashpv		CPerlObj::Perl_gv_stashpv
#define gv_stashpv		Perl_gv_stashpv
#define Perl_gv_stashpvn	CPerlObj::Perl_gv_stashpvn
#define gv_stashpvn		Perl_gv_stashpvn
#define Perl_gv_stashsv		CPerlObj::Perl_gv_stashsv
#define gv_stashsv		Perl_gv_stashsv
#define Perl_hv_clear		CPerlObj::Perl_hv_clear
#define hv_clear		Perl_hv_clear
#define Perl_hv_delayfree_ent	CPerlObj::Perl_hv_delayfree_ent
#define hv_delayfree_ent	Perl_hv_delayfree_ent
#define Perl_hv_delete		CPerlObj::Perl_hv_delete
#define hv_delete		Perl_hv_delete
#define Perl_hv_delete_ent	CPerlObj::Perl_hv_delete_ent
#define hv_delete_ent		Perl_hv_delete_ent
#define Perl_hv_exists		CPerlObj::Perl_hv_exists
#define hv_exists		Perl_hv_exists
#define Perl_hv_exists_ent	CPerlObj::Perl_hv_exists_ent
#define hv_exists_ent		Perl_hv_exists_ent
#define Perl_hv_fetch		CPerlObj::Perl_hv_fetch
#define hv_fetch		Perl_hv_fetch
#define Perl_hv_fetch_ent	CPerlObj::Perl_hv_fetch_ent
#define hv_fetch_ent		Perl_hv_fetch_ent
#define Perl_hv_free_ent	CPerlObj::Perl_hv_free_ent
#define hv_free_ent		Perl_hv_free_ent
#define Perl_hv_iterinit	CPerlObj::Perl_hv_iterinit
#define hv_iterinit		Perl_hv_iterinit
#define Perl_hv_iterkey		CPerlObj::Perl_hv_iterkey
#define hv_iterkey		Perl_hv_iterkey
#define Perl_hv_iterkeysv	CPerlObj::Perl_hv_iterkeysv
#define hv_iterkeysv		Perl_hv_iterkeysv
#define Perl_hv_iternext	CPerlObj::Perl_hv_iternext
#define hv_iternext		Perl_hv_iternext
#define Perl_hv_iternextsv	CPerlObj::Perl_hv_iternextsv
#define hv_iternextsv		Perl_hv_iternextsv
#define Perl_hv_iterval		CPerlObj::Perl_hv_iterval
#define hv_iterval		Perl_hv_iterval
#define Perl_hv_ksplit		CPerlObj::Perl_hv_ksplit
#define hv_ksplit		Perl_hv_ksplit
#define Perl_hv_magic		CPerlObj::Perl_hv_magic
#define hv_magic		Perl_hv_magic
#define Perl_hv_store		CPerlObj::Perl_hv_store
#define hv_store		Perl_hv_store
#define Perl_hv_store_ent	CPerlObj::Perl_hv_store_ent
#define hv_store_ent		Perl_hv_store_ent
#define Perl_hv_undef		CPerlObj::Perl_hv_undef
#define hv_undef		Perl_hv_undef
#define Perl_ibcmp		CPerlObj::Perl_ibcmp
#define ibcmp			Perl_ibcmp
#define Perl_ibcmp_locale	CPerlObj::Perl_ibcmp_locale
#define ibcmp_locale		Perl_ibcmp_locale
#define Perl_ingroup		CPerlObj::Perl_ingroup
#define ingroup			Perl_ingroup
#define Perl_init_debugger	CPerlObj::Perl_init_debugger
#define init_debugger		Perl_init_debugger
#define Perl_init_stacks	CPerlObj::Perl_init_stacks
#define init_stacks		Perl_init_stacks
#define Perl_intro_my		CPerlObj::Perl_intro_my
#define intro_my		Perl_intro_my
#define Perl_instr		CPerlObj::Perl_instr
#define instr			Perl_instr
#define Perl_io_close		CPerlObj::Perl_io_close
#define io_close		Perl_io_close
#define Perl_invert		CPerlObj::Perl_invert
#define invert			Perl_invert
#define Perl_is_gv_magical	CPerlObj::Perl_is_gv_magical
#define is_gv_magical		Perl_is_gv_magical
#define Perl_is_lvalue_sub	CPerlObj::Perl_is_lvalue_sub
#define is_lvalue_sub		Perl_is_lvalue_sub
#define Perl_is_uni_alnum	CPerlObj::Perl_is_uni_alnum
#define is_uni_alnum		Perl_is_uni_alnum
#define Perl_is_uni_alnumc	CPerlObj::Perl_is_uni_alnumc
#define is_uni_alnumc		Perl_is_uni_alnumc
#define Perl_is_uni_idfirst	CPerlObj::Perl_is_uni_idfirst
#define is_uni_idfirst		Perl_is_uni_idfirst
#define Perl_is_uni_alpha	CPerlObj::Perl_is_uni_alpha
#define is_uni_alpha		Perl_is_uni_alpha
#define Perl_is_uni_ascii	CPerlObj::Perl_is_uni_ascii
#define is_uni_ascii		Perl_is_uni_ascii
#define Perl_is_uni_space	CPerlObj::Perl_is_uni_space
#define is_uni_space		Perl_is_uni_space
#define Perl_is_uni_cntrl	CPerlObj::Perl_is_uni_cntrl
#define is_uni_cntrl		Perl_is_uni_cntrl
#define Perl_is_uni_graph	CPerlObj::Perl_is_uni_graph
#define is_uni_graph		Perl_is_uni_graph
#define Perl_is_uni_digit	CPerlObj::Perl_is_uni_digit
#define is_uni_digit		Perl_is_uni_digit
#define Perl_is_uni_upper	CPerlObj::Perl_is_uni_upper
#define is_uni_upper		Perl_is_uni_upper
#define Perl_is_uni_lower	CPerlObj::Perl_is_uni_lower
#define is_uni_lower		Perl_is_uni_lower
#define Perl_is_uni_print	CPerlObj::Perl_is_uni_print
#define is_uni_print		Perl_is_uni_print
#define Perl_is_uni_punct	CPerlObj::Perl_is_uni_punct
#define is_uni_punct		Perl_is_uni_punct
#define Perl_is_uni_xdigit	CPerlObj::Perl_is_uni_xdigit
#define is_uni_xdigit		Perl_is_uni_xdigit
#define Perl_to_uni_upper	CPerlObj::Perl_to_uni_upper
#define to_uni_upper		Perl_to_uni_upper
#define Perl_to_uni_title	CPerlObj::Perl_to_uni_title
#define to_uni_title		Perl_to_uni_title
#define Perl_to_uni_lower	CPerlObj::Perl_to_uni_lower
#define to_uni_lower		Perl_to_uni_lower
#define Perl_is_uni_alnum_lc	CPerlObj::Perl_is_uni_alnum_lc
#define is_uni_alnum_lc		Perl_is_uni_alnum_lc
#define Perl_is_uni_alnumc_lc	CPerlObj::Perl_is_uni_alnumc_lc
#define is_uni_alnumc_lc	Perl_is_uni_alnumc_lc
#define Perl_is_uni_idfirst_lc	CPerlObj::Perl_is_uni_idfirst_lc
#define is_uni_idfirst_lc	Perl_is_uni_idfirst_lc
#define Perl_is_uni_alpha_lc	CPerlObj::Perl_is_uni_alpha_lc
#define is_uni_alpha_lc		Perl_is_uni_alpha_lc
#define Perl_is_uni_ascii_lc	CPerlObj::Perl_is_uni_ascii_lc
#define is_uni_ascii_lc		Perl_is_uni_ascii_lc
#define Perl_is_uni_space_lc	CPerlObj::Perl_is_uni_space_lc
#define is_uni_space_lc		Perl_is_uni_space_lc
#define Perl_is_uni_cntrl_lc	CPerlObj::Perl_is_uni_cntrl_lc
#define is_uni_cntrl_lc		Perl_is_uni_cntrl_lc
#define Perl_is_uni_graph_lc	CPerlObj::Perl_is_uni_graph_lc
#define is_uni_graph_lc		Perl_is_uni_graph_lc
#define Perl_is_uni_digit_lc	CPerlObj::Perl_is_uni_digit_lc
#define is_uni_digit_lc		Perl_is_uni_digit_lc
#define Perl_is_uni_upper_lc	CPerlObj::Perl_is_uni_upper_lc
#define is_uni_upper_lc		Perl_is_uni_upper_lc
#define Perl_is_uni_lower_lc	CPerlObj::Perl_is_uni_lower_lc
#define is_uni_lower_lc		Perl_is_uni_lower_lc
#define Perl_is_uni_print_lc	CPerlObj::Perl_is_uni_print_lc
#define is_uni_print_lc		Perl_is_uni_print_lc
#define Perl_is_uni_punct_lc	CPerlObj::Perl_is_uni_punct_lc
#define is_uni_punct_lc		Perl_is_uni_punct_lc
#define Perl_is_uni_xdigit_lc	CPerlObj::Perl_is_uni_xdigit_lc
#define is_uni_xdigit_lc	Perl_is_uni_xdigit_lc
#define Perl_to_uni_upper_lc	CPerlObj::Perl_to_uni_upper_lc
#define to_uni_upper_lc		Perl_to_uni_upper_lc
#define Perl_to_uni_title_lc	CPerlObj::Perl_to_uni_title_lc
#define to_uni_title_lc		Perl_to_uni_title_lc
#define Perl_to_uni_lower_lc	CPerlObj::Perl_to_uni_lower_lc
#define to_uni_lower_lc		Perl_to_uni_lower_lc
#define Perl_is_utf8_char	CPerlObj::Perl_is_utf8_char
#define is_utf8_char		Perl_is_utf8_char
#define Perl_is_utf8_string	CPerlObj::Perl_is_utf8_string
#define is_utf8_string		Perl_is_utf8_string
#define Perl_is_utf8_alnum	CPerlObj::Perl_is_utf8_alnum
#define is_utf8_alnum		Perl_is_utf8_alnum
#define Perl_is_utf8_alnumc	CPerlObj::Perl_is_utf8_alnumc
#define is_utf8_alnumc		Perl_is_utf8_alnumc
#define Perl_is_utf8_idfirst	CPerlObj::Perl_is_utf8_idfirst
#define is_utf8_idfirst		Perl_is_utf8_idfirst
#define Perl_is_utf8_alpha	CPerlObj::Perl_is_utf8_alpha
#define is_utf8_alpha		Perl_is_utf8_alpha
#define Perl_i