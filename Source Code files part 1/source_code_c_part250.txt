essageBox is used.
        // Return IDABORT to terminate the process.

        HANDLE h; 
 
        h = RegisterEventSourceA(NULL,  // uses local computer 
                 ".NET Runtime");           // source name 
        if (h != NULL)
        {
            LPWSTR lpMsg = new WCHAR[Wszlstrlen (lpText) + Wszlstrlen (lpCaption)
                + Wszlstrlen (L".NET Runtime version : ") + 3 + Wszlstrlen(VER_FILEVERSION_WSTR)];
            if (lpMsg)
            {
                Wszlstrcpy (lpMsg, L".NET Runtime version ");
                Wszlstrcat (lpMsg, VER_FILEVERSION_WSTR );
                Wszlstrcat (lpMsg, L"- " );
                if( lpCaption)
                    Wszlstrcat (lpMsg, lpCaption);
                Wszlstrcat (lpMsg, L": ");
                if(lpText)
                    Wszlstrcat (lpMsg, lpText);
                ReportEventW(h,           // event log handle 
                    EVENTLOG_ERROR_TYPE,  // event type 
                    0,                    // category zero 
                    0,                    // event identifier 
                    NULL,                 // no user security identifier 
                    1,                    // one substitution string 
                    0,                    // no data 
                    (LPCWSTR *)&lpMsg,    // pointer to string array 
                    NULL);                // pointer to data 
                delete [] lpMsg;
            }
            
            DeregisterEventSource(h);
        }

        if( lpCaption)
            WszOutputDebugString (lpCaption);
        if( lpText)
            WszOutputDebugString (lpText);
        
        hWnd = NULL;                            // Set hWnd to NULL since MB_SERVICE_NOTIFICATION requires it
        if(!(uType & MB_SERVICE_NOTIFICATION))  // return IDABORT if MB_SERVICE_NOTIFICATION is not set
            return IDABORT;
    }

    if (UseUnicodeAPI())
        return MessageBoxW(hWnd, lpText, lpCaption, uType);

    int iRtn = IDABORT;
    LPSTR szString=NULL, szString2=NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpText,
                      &szString, 0, NULL, TRUE)) ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCaption,
                      &szString2, 0, NULL, TRUE)) )
    {
        goto Exit;
    }

    iRtn = MessageBoxA(hWnd, szString, szString2, uType);

Exit:
    delete [] szString;
    delete [] szString2;
    return iRtn;
}

int Wszwsprintf(
  LPWSTR lpOut, 
  LPCWSTR lpFmt,
  ...)
{
    va_list arglist;

    va_start(arglist, lpFmt);
    int count =  vswprintf(lpOut, lpFmt, arglist);
    va_end(arglist);
    return count;
}

DWORD
WszGetWorkingSet()
{
    DWORD dwMemUsage = 0;
    if (RunningOnWinNT()) {
        // This only works on NT versions from version 4.0 onwards.
        // Consider also calling GetProcessWorkingSetSize to get the min & max working
        // set size.  I don't know how to get the current working set though...
        PROCESS_MEMORY_COUNTERS pmc;
        
        int pid = GetCurrentProcessId();
        HANDLE hCurrentProcess = OpenProcess(PROCESS_ALL_ACCESS, false, pid);
        _ASSERTE(hCurrentProcess != INVALID_HANDLE_VALUE);

        HINSTANCE hPSapi;
        typedef BOOL (GET_PROCESS_MEMORY_INFO)(HANDLE, PROCESS_MEMORY_COUNTERS*, DWORD);
        GET_PROCESS_MEMORY_INFO* pGetProcessMemoryInfo;

        hPSapi = WszLoadLibrary(L"psapi.dll");
        if (hPSapi == NULL) {
            _ASSERTE(0);
            CloseHandle(hCurrentProcess);
            return 0;
        }

        pGetProcessMemoryInfo = 
            (GET_PROCESS_MEMORY_INFO*)GetProcAddress(hPSapi, "GetProcessMemoryInfo");
        _ASSERTE(pGetProcessMemoryInfo != NULL);

        BOOL r = pGetProcessMemoryInfo(hCurrentProcess, &pmc, (DWORD) sizeof(PROCESS_MEMORY_COUNTERS));
        FreeLibrary(hPSapi);
        _ASSERTE(r);
        
        dwMemUsage = (DWORD)pmc.WorkingSetSize;
        CloseHandle(hCurrentProcess);
    }
    else { //Running on Win9x or Win2000
        // There is no good way of finding working set on Win9x.
        dwMemUsage = 0;
    }
    return dwMemUsage;
}

VOID
WszReleaseActCtx(HANDLE hActCtx)
{
    if(RunningOnWinNT5()) {
        typedef BOOL (WINAPI* RELEASE_ACT_CTX)(HANDLE);
        HINSTANCE hKernel = WszLoadLibrary(L"kernel32.dll");
        if(hKernel != NULL) {
            RELEASE_ACT_CTX pReleaseActCtx = (RELEASE_ACT_CTX) GetProcAddress(hKernel, "ReleaseActCtx");
            if(pReleaseActCtx) 
                pReleaseActCtx(hActCtx);
        }
    }
}

BOOL
WszGetCurrentActCtx(HANDLE *lphActCtx)
{
    if(RunningOnWinNT5()) {
        typedef BOOL (WINAPI* GET_CURRENT_ACT_CTX)(HANDLE*);
        HINSTANCE hKernel = WszLoadLibrary(L"kernel32.dll");
        if(hKernel != NULL) {
            GET_CURRENT_ACT_CTX pGetCurrentActCtx = (GET_CURRENT_ACT_CTX) GetProcAddress(hKernel, "GetCurrentActCtx");
            if(pGetCurrentActCtx) 
                return pGetCurrentActCtx(lphActCtx);
        }
    }
    return FALSE;
}

BOOL
WszQueryActCtxW(IN DWORD dwFlags,
                IN HANDLE hActCtx,
                IN PVOID pvSubInstance,
                IN ULONG ulInfoClass,
                OUT PVOID pvBuffer,
                IN SIZE_T cbBuffer OPTIONAL,
                OUT SIZE_T *pcbWrittenOrRequired OPTIONAL
                )
{
    if(RunningOnWinNT5()) { 
        typedef BOOL (WINAPI* PQUERYACTCTXW_FUNC)(DWORD,HANDLE,PVOID,ULONG,PVOID,SIZE_T,SIZE_T*);
        HINSTANCE hKernel = WszLoadLibrary(L"kernel32.dll");
        if(hKernel != NULL) {
            PQUERYACTCTXW_FUNC pFunc = (PQUERYACTCTXW_FUNC) GetProcAddress(hKernel, "QueryActCtxW");
            if(pFunc != NULL) {
                return pFunc(dwFlags,
                             hActCtx,
                             pvSubInstance,
                             ulInfoClass,
                             pvBuffer,
                             cbBuffer,
                             pcbWrittenOrRequired);
            }
        }
    }
    else {
        SetLastError(ERROR_PROC_NOT_FOUND);
    }

    return FALSE;
    
}

LRESULT
WszSendDlgItemMessage(
    HWND    hDlg,
    int     nIDDlgItem,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    if (UseUnicodeAPI()) {
        return SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam);
    }
    else {

        // We call into SendMessage so we get the
        // Msg wrapped for A version's
        HWND hWnd = GetDlgItem(hDlg, nIDDlgItem);
        if(hWnd == NULL) {
            return ERROR_INVALID_WINDOW_HANDLE;
        }
        
        return WszSendMessage(hWnd, Msg, wParam, lParam);
    }    
}

LRESULT WINAPI
SendMessageAThunk(
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (Msg)
    {
    case WM_GETTEXT:
    {
        LRESULT nLen = 0;
        LPSTR   lpStr = NULL;
        int     iSize = (int) wParam;
        
        lpStr = new char[iSize];

        if(!lpStr) {
            _ASSERTE(!"SendMessageAThunk Mem Alloc failure in message WM_GETTEXT");
            SetLastError(ERROR_OUTOFMEMORY);
            return 0;
        }

        nLen = SendMessageA(hWnd, Msg, (WPARAM) iSize, (LPARAM) (LPSTR) lpStr);
        if(nLen) {
            if(FAILED(WszConvertToUnicode((LPSTR) lpStr, -1,
                (LPWSTR *) &lParam, (ULONG *) &wParam, FALSE)) ) {
                _ASSERTE(!"SendMessageAThunk::WszConvertToUnicode failure in message WM_GETTEXT");
                SetLastError(ERROR_OUTOFMEMORY);
                return 0;
            }
        }

        SAFEDELARRAY(lpStr);
        return nLen;
    }

    case EM_GETLINE:
    {
        LRESULT nLen;
        LPSTR   lpStr = NULL;
        int     iSize = (* (SHORT *) lParam);

        lpStr = new char[iSize + 1];  // +1 for NULL termination
        if(!lpStr) {
            _ASSERTE(!"SendMessageAThunk Mem Alloc failure in message EM_GETLINE");
            SetLastError(ERROR_OUTOFMEMORY);
            return 0;
        }

        * (SHORT *) (LPSTR) lpStr = * (SHORT *) lParam;
        
        nLen = SendMessageA(hWnd, Msg, (WPARAM) wParam, (LPARAM) (LPSTR) lpStr);
        if(nLen > 0) {
            lpStr[nLen] = '\0';

            if(FAILED(WszConvertToUnicode((LPSTR) lpStr, -1,
                (LPWSTR *) &lParam, (ULONG *) &iSize, FALSE)) ) {
                _ASSERTE(!"SendMessageAThunk::WszConvertToUnicode failure in message EM_GETLINE");
                SetLastError(ERROR_OUTOFMEMORY);
                return 0;
            }
        }

        SAFEDELARRAY(lpStr);
        return nLen;
    }

    case WM_SETTEXT:
    case LB_ADDSTRING:
    case CB_ADDSTRING:
    case EM_REPLACESEL:
        _ASSERTE(wParam == 0 && "wParam should be 0 for these messages");
        // fall through
    case CB_SELECTSTRING:
    case CB_FINDSTRINGEXACT:
    case CB_FINDSTRING:
    case CB_INSERTSTRING:
    case LB_INSERTSTRING:
    case LB_FINDSTRINGEXACT:
    {
        LRESULT nRet;
        LPSTR lpStr=NULL;

        if(FAILED(WszConvertToAnsi((LPWSTR) lParam,
            &lpStr, 0, NULL, TRUE)) ) {
            _ASSERTE(!"SendMessageAThunk Mem Alloc failure in set/find messages");
            SetLastError(ERROR_OUTOFMEMORY);
            return 0;
        }

        nRet = SendMessageA(hWnd, Msg, wParam, (LPARAM) (LPSTR) lpStr);
        SAFEDELARRAY(lpStr);
        return nRet;
    }

    // @TODO:  Need to implement a safe version for W9x platforms, no idea
    //         how big the buffers are that this call uses
    case LB_GETTEXT:
    case CB_GETLBTEXT:
        _ASSERTE(!"SendMessageAThunk - Need to wrap LB_GETTEXT || CB_GETLBTEXT messages if your going to use them");
        return SendMessageA(hWnd, Msg, wParam, lParam);

    case EM_SETPASSWORDCHAR:
    {
        WPARAM  wp;

        _ASSERTE(HIWORD64(wParam) == 0);

        if( FAILED(WszConvertToAnsi((LPWSTR)wParam,
              (LPSTR *) &wp, sizeof(wp), NULL, FALSE)) )
        {
            _ASSERTE(!"SendMessageAThunk::WszConvertToAnsi failure in message EM_SETPASSWORDCHAR");
            SetLastError(ERROR_OUTOFMEMORY);
            return 0;
        }
        _ASSERTE(HIWORD64(wp) == 0);

        return SendMessageA(hWnd, Msg, wp, lParam);
    }

    // The new unicode comctl32.dll handles these correctly so we don't need to thunk:
    // TTM_DELTOOL, TTM_ADDTOOL, TVM_INSERTITEM, TVM_GETITEM, TCM_INSERTITEM, TCM_SETITEM

    default:
        return SendMessageA(hWnd, Msg, wParam, lParam);
    }
}

LRESULT
WszSendMessage(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
{
    if(UseUnicodeAPI()) {
        return SendMessageW(hWnd, Msg, wParam, lParam);
    }
    else {
        return SendMessageAThunk(hWnd, Msg, wParam, lParam);
    }
}

HMENU
WszLoadMenu(
    HINSTANCE hInst,
    LPCWSTR lpMenuName)
{
    HMENU   hMenu = NULL;
    LPSTR   szString = NULL;

    if (UseUnicodeAPI()) {
        hMenu = LoadMenuW(hInst, lpMenuName);
        goto Exit;
    }
    
    if(IS_INTRESOURCE(lpMenuName)) {
        hMenu = LoadMenuA(hInst, (LPCSTR) lpMenuName);
        goto Exit;
    }

    if(FAILED(WszConvertToAnsi((LPWSTR) lpMenuName,
        &szString, 0, NULL, TRUE)) ) {
        goto Exit;
    }

    hMenu = LoadMenuA(hInst, szString);
    
Exit:
    SAFEDELARRAY(szString);
    return hMenu;
}

HRSRC
WszFindResource(
  HMODULE hModule,
  LPCWSTR lpName,
  LPCWSTR lpType)
{
    if (UseUnicodeAPI()) {
        return FindResourceW(hModule, lpName, lpType);
    }

    HRSRC   hSrc = NULL;
    LPSTR   pName = NULL;
    LPSTR   pType = NULL;
    BOOL    bNameIsInt = IS_INTRESOURCE(lpName);
    BOOL    bTypeIsInt = IS_INTRESOURCE(lpType);

    if (!bNameIsInt) {
        if(FAILED(WszConvertToAnsi((LPWSTR) lpName,
            &pName, 0, NULL, TRUE)) ) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }
    }
    else {
        pName = (LPSTR) lpName;
    }
    
    if (!bTypeIsInt) {
        if(FAILED(WszConvertToAnsi((LPWSTR) lpType,
            &pType, 0, NULL, TRUE)) ) {
            SetLastError(ERROR_OUTOFMEMORY);
            goto Exit;
        }
    }
    else {
        pType = (LPSTR) lpType;
    }

    hSrc = FindResourceA(hModule, pName, pType);
    // Fall thru

Exit:

    if (!bNameIsInt)
        SAFEDELARRAY(pName);
    if (!bTypeIsInt)
        SAFEDELARRAY(pType);

    return hSrc;
}

BOOL
WszGetClassInfo(
  HINSTANCE hModule,
  LPCWSTR lpClassName,
  LPWNDCLASSW lpWndClassW)
{
    if(UseUnicodeAPI()) {
        return GetClassInfoW(hModule, lpClassName, lpWndClassW);
    }

    BOOL    fRet;
    LPSTR   pStrClassName = NULL;
    
    if( FAILED(WszConvertToAnsi((LPWSTR)lpClassName,
        &pStrClassName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }
    
    _ASSERTE(sizeof(WNDCLASSA) == sizeof(WNDCLASSW));

    fRet = GetClassInfoA(hModule, pStrClassName, (LPWNDCLASSA) lpWndClassW);

    // @TODO:  Need to implement a safe version for W9x platforms instead of
    //         nulling them out. We have no idea how big these buffers are
    //         so we can not do a translate with potential overruns
    lpWndClassW->lpszMenuName = NULL;
    lpWndClassW->lpszClassName = NULL;

    SAFEDELARRAY(pStrClassName);
    return fRet;
}

ATOM
WszRegisterClass(
  CONST WNDCLASSW *lpWndClass)
{
    if(UseUnicodeAPI()) {
        return RegisterClassW(lpWndClass);
    }

    WNDCLASSA   wc;
    ATOM        atom = 0;
    LPSTR       pStrMenuName = NULL;
    LPSTR       pStrClassName = NULL;
    
    if( FAILED(WszConvertToAnsi((LPWSTR)lpWndClass->lpszMenuName,
        &pStrMenuName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    if( FAILED(WszConvertToAnsi((LPWSTR)lpWndClass->lpszClassName,
        &pStrClassName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    _ASSERTE(sizeof(wc) == sizeof(*lpWndClass));
    memcpy(&wc, lpWndClass, sizeof(wc));

    wc.lpszMenuName = pStrMenuName;
    wc.lpszClassName = pStrClassName;

    atom = RegisterClassA(&wc);

Exit:
    SAFEDELARRAY(pStrMenuName);
    SAFEDELARRAY(pStrClassName);

    return atom;
}

HWND
WszCreateWindowEx(
  DWORD       dwExStyle,
  LPCWSTR     lpClassName,
  LPCWSTR     lpWindowName,
  DWORD       dwStyle,
  int         X,
  int         Y,
  int         nWidth,
  int         nHeight,
  HWND        hWndParent,
  HMENU       hMenu,
  HINSTANCE   hInstance,
  LPVOID      lpParam)
{
    if(UseUnicodeAPI()) {
        return CreateWindowExW(
                dwExStyle,
                lpClassName,
                lpWindowName,
                dwStyle,
                X,
                Y,
                nWidth,
                nHeight,
                hWndParent,
                hMenu,
                hInstance,
                lpParam);
    }

    LPSTR   pStrWindowName = NULL;
    LPSTR   pStrClassName = NULL;
    HWND    hWnd = NULL;
    
    if( FAILED(WszConvertToAnsi((LPWSTR)lpClassName,
        &pStrClassName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    if( FAILED(WszConvertToAnsi((LPWSTR)lpWindowName,
        &pStrWindowName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }


    hWnd = CreateWindowExA(
            dwExStyle,
            pStrClassName,
            pStrWindowName,
            dwStyle,
            X,
            Y,
            nWidth,
            nHeight,
            hWndParent,
            hMenu,
            hInstance,
            lpParam);

Exit:
    
    SAFEDELARRAY(pStrClassName);
    SAFEDELARRAY(pStrWindowName);
    return hWnd;
}

LRESULT WszDefWindowProc(
  HWND hWnd,
  UINT Msg,
  WPARAM wParam,
  LPARAM lParam)
{
    if(UseUnicodeAPI()) {
        return DefWindowProcW(hWnd, Msg, wParam, lParam);
    }
    else {
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
}

int 
WszTranslateAccelerator(
  HWND hWnd,
  HACCEL hAccTable,
  LPMSG lpMsg)
{
    if(UseUnicodeAPI()) {
        return TranslateAcceleratorW(hWnd, hAccTable, lpMsg);
    }
    else {
        return TranslateAcceleratorA(hWnd, hAccTable, lpMsg);
    }
}

BOOL WszGetDiskFreeSpaceEx(
  LPCWSTR lpDirectoryName,
  PULARGE_INTEGER lpFreeBytesAvailable,
  PULARGE_INTEGER lpTotalNumberOfBytes,
  PULARGE_INTEGER lpTotalNumberOfFreeBytes)
{
    BOOL    fRet = FALSE;

    if(UseUnicodeAPI()) {
        fRet = GetDiskFreeSpaceExW(lpDirectoryName, lpFreeBytesAvailable, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        goto Exit;
    }

    LPSTR   pszPath = NULL;
    
    if( FAILED(WszConvertToAnsi((LPWSTR)lpDirectoryName,
        &pszPath, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    fRet = GetDiskFreeSpaceExA(pszPath, lpFreeBytesAvailable, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
    SAFEDELARRAY(pszPath);

Exit:
    return fRet;
}


HANDLE
WszFindFirstChangeNotification(
  LPWSTR lpPathName,
  BOOL bWatchSubtree,
  DWORD dwNotifyFilter)
{
    HANDLE  retHandle = INVALID_HANDLE_VALUE;
    
    if(UseUnicodeAPI()) {
        retHandle = FindFirstChangeNotificationW(lpPathName, bWatchSubtree, dwNotifyFilter);
        goto Exit;
    }

    LPSTR   pszPath = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpPathName,
        &pszPath, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    retHandle = FindFirstChangeNotificationA(pszPath, bWatchSubtree, dwNotifyFilter);
    SAFEDELARRAY(pszPath);
    
Exit:
    return retHandle;

}

HACCEL
WszLoadAccelerators(
  HINSTANCE hInstance,
  LPCWSTR lpTableName)
{
    HACCEL  hAcc = NULL;

    if(UseUnicodeAPI()) {
        hAcc = LoadAcceleratorsW(hInstance, lpTableName);
        goto Exit;
    }

    if(IS_INTRESOURCE(lpTableName)) {
        hAcc = LoadAcceleratorsA(hInstance, (LPCSTR) lpTableName);
        goto Exit;
    }

    LPSTR   pStr = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpTableName,
        &pStr, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hAcc = LoadAcceleratorsA(hInstance, (LPCSTR) pStr);
    SAFEDELARRAY(pStr);

Exit:
    return hAcc;
}

HANDLE
WszLoadImage(
  HINSTANCE hInst,
  LPCWSTR lpszName,
  UINT uType,
  int cxDesired,
  int cyDesired,
  UINT fuLoad)
{
    LPSTR   szString = NULL;
    HANDLE  hImage = NULL;
    
    if(UseUnicodeAPI()) { 
        hImage = LoadImageW(hInst, lpszName, uType, cxDesired, cyDesired, fuLoad);
        goto Exit;
    }
    
    if(IS_INTRESOURCE(lpszName)) {
        hImage = LoadImageA(hInst, (LPCSTR) lpszName, uType, cxDesired, cyDesired, fuLoad);
        goto Exit;
    }

    if(FAILED(WszConvertToAnsi((LPWSTR) lpszName,
        &szString, 0, NULL, TRUE)) ) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hImage = LoadImageA(hInst, szString, uType, cxDesired, cyDesired, fuLoad);

    // Fall thru
    
Exit:
    SAFEDELARRAY(szString);
    return hImage;
}

int WszMessageBox(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType)
{
    if(UseUnicodeAPI()) {
        return MessageBoxW(hWnd, lpText, lpCaption, uType);
    }

    LPSTR   szString = NULL;
    LPSTR   szString2 =NULL;
    int     iRtn = IDABORT;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpText,
                      &szString, 0, NULL, TRUE)) ||
        FAILED(WszConvertToAnsi((LPWSTR)lpCaption,
                      &szString2, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    iRtn = MessageBoxA(hWnd, szString, szString2, uType);

    // Fall thru

Exit:
    SAFEDELARRAY(szString);
    SAFEDELARRAY(szString2);
    return iRtn;
}

LONG
WszGetWindowLong(
    HWND hWnd,
    int nIndex)
{
    if(UseUnicodeAPI()) {
        return GetWindowLongW(hWnd, nIndex);
    }
    else {
        return GetWindowLongA(hWnd, nIndex);
    }
}

LONG
WszSetWindowLong(
    HWND hWnd,
    int  nIndex,
    LONG lNewVal)
{
    if(UseUnicodeAPI()) {
        return SetWindowLongW(hWnd, nIndex, lNewVal);
    }
    else {
        return SetWindowLongA(hWnd, nIndex, lNewVal);
    }
}

HWND
WszCreateDialog(
    HINSTANCE   hInstance,
    LPCWSTR     lpTemplateName,
    HWND        hWndParent,
    DLGPROC     lpDialogFunc)
{
    return WszCreateDialogParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, 0L);
}

HWND
WszCreateDialogParam(
    HINSTANCE   hInstance,
    LPCWSTR     lpTemplateName,
    HWND        hWndParent,
    DLGPROC     lpDialogFunc,
    LPARAM      dwInitParam)
{
    LPSTR       pszTemplate = NULL;
    HWND        hWnd = NULL;
    
    _ASSERTE(HIWORD64(lpTemplateName) == 0);

    if(UseUnicodeAPI()) {
        hWnd = CreateDialogParamW(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        goto Exit;
    }

    if(IS_INTRESOURCE(lpTemplateName)) {
        hWnd = CreateDialogParamA(hInstance, (LPSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        goto Exit;
    }

    if(FAILED(WszConvertToAnsi((LPWSTR) lpTemplateName,
        &pszTemplate, 0, NULL, TRUE)) ) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hWnd = CreateDialogParamA(hInstance, pszTemplate, hWndParent, lpDialogFunc, dwInitParam);

    // Fall thru
    
Exit:
    SAFEDELARRAY(pszTemplate);
    return hWnd;
}

INT_PTR
WszDialogBoxParam(
    HINSTANCE   hInstance,
    LPCWSTR     lpszTemplate,
    HWND        hWndParent,
    DLGPROC     lpDialogFunc,
    LPARAM      dwInitParam)
{
    LPSTR       pStrTemplateName = NULL;
    INT_PTR     iResult;
    
    if(UseUnicodeAPI()) {
        iResult = DialogBoxParamW(hInstance, lpszTemplate, hWndParent,
            lpDialogFunc, dwInitParam);
        goto Exit;
    }

    if(IS_INTRESOURCE(lpszTemplate)) {
        iResult = DialogBoxParamA(hInstance, (LPCSTR) lpszTemplate, hWndParent,
            lpDialogFunc, dwInitParam);
        goto Exit;
    }

    if(FAILED(WszConvertToAnsi((LPWSTR) lpszTemplate,
        &pStrTemplateName, 0, NULL, TRUE)) ) {
        SetLastError(ERROR_OUTOFMEMORY);
        iResult = -1;
        goto Exit;
    }

    iResult = DialogBoxParamA(hInstance, (LPCSTR) pStrTemplateName, hWndParent,
        lpDialogFunc, dwInitParam);

    SAFEDELARRAY(pStrTemplateName);

    // Fall thru

Exit:
    return iResult;
}

BOOL
WszIsDialogMessage(
    HWND    hDlg,
    LPMSG   lpMsg)
{
    if(UseUnicodeAPI()) {
        return IsDialogMessageW(hDlg, lpMsg);
    }
    else {
        return IsDialogMessageA(hDlg, lpMsg);
    }
}

BOOL
WszGetMessage(
    LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax)
{
    if(UseUnicodeAPI()) {
        return GetMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    }
    else {
        return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    }
}

HICON
WszLoadIcon(
    HINSTANCE hInstance,
    LPCWSTR lpIconName)
{
    LPSTR   pStr = NULL;
    HICON   hIcon = NULL;
    
    if(UseUnicodeAPI()) {
        hIcon = LoadIconW(hInstance, lpIconName);
        goto Exit;
    }

    if(IS_INTRESOURCE(lpIconName)) {
        hIcon = LoadIconA(hInstance, (LPCSTR) lpIconName);
        goto Exit;
    }

    if(FAILED(WszConvertToAnsi((LPWSTR) lpIconName,
        &pStr, 0, NULL, TRUE)) ) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hIcon = LoadIconA(hInstance, (LPCSTR) pStr);

    // Fall thru

Exit:
    SAFEDELARRAY(pStr);
    return hIcon;
}

HCURSOR
WszLoadCursor(
    HINSTANCE hInstance,
    LPCWSTR lpCursorName)
{
    HCURSOR hCursor = NULL;
    LPSTR   pStr = NULL;

    _ASSERTE(HIWORD64(lpCursorName) == 0);

    if(UseUnicodeAPI()) {
        return LoadCursorW(hInstance, lpCursorName);
    }

    if(IS_INTRESOURCE(lpCursorName)) {
        return LoadCursorA(hInstance, (LPCSTR) lpCursorName);
    }

    if(FAILED(WszConvertToAnsi((LPWSTR) lpCursorName,
        &pStr, 0, NULL, TRUE)) ) {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    hCursor = LoadCursorA(hInstance, (LPCSTR) pStr);

    // Fall thru

Exit:
    SAFEDELARRAY(pStr);
    return hCursor;
}

BOOL
WszLookupPrivilegeValue(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID lpLuid)
{
    if(UseUnicodeAPI()) {
        return LookupPrivilegeValueW(lpSystemName, lpName, lpLuid);
    }

    LPSTR   szSystemName = NULL;
    LPSTR   szName = NULL;

    if( FAILED(WszConvertToAnsi((LPWSTR)lpSystemName,
                      &szSystemName, 0, NULL, TRUE)) ||
        FAILED(WszConvertToAnsi((LPWSTR)lpName,
                      &szName, 0, NULL, TRUE)) )
    {
        SetLastError(ERROR_OUTOFMEMORY);
        goto Exit;
    }

    BOOL fRtn = LookupPrivilegeValueA(szSystemName, szName, lpLuid);

    // Fall thru

Exit:
    SAFEDELARRAY(szSystemName);
    SAFEDELARRAY(szName);
    return fRtn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\util.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
//  util.cpp
//
//  This contains a bunch of C++ utility classes.
//
//*****************************************************************************
#include "stdafx.h"                     // Precompiled header key.
#include "utilcode.h"
#include "MetaData.h"

#include <rotate.h>
#include <version\__file__.ver>

extern RunningOnStatusEnum gRunningOnStatus = RUNNING_ON_STATUS_UNINITED;

LPCSTR g_RTMVersion= "v1.0.3705";

//********** Code. ************************************************************



//
//
// CHashTable
//
//

//*****************************************************************************
// This is the second part of construction where we do all of the work that
// can fail.  We also take the array of structs here because the calling class
// presumably needs to allocate it in its NewInit.
//*****************************************************************************
HRESULT CHashTable::NewInit(            // Return status.
    BYTE        *pcEntries,             // Array of structs we are managing.
    USHORT      iEntrySize)             // Size of the entries.
{
    _ASSERTE(iEntrySize >= sizeof(FREEHASHENTRY));

    // Allocate the bucket chain array and init it.
    if ((m_piBuckets = new USHORT [m_iBuckets]) == NULL)
        return (OutOfMemory());
    memset(m_piBuckets, 0xff, m_iBuckets * sizeof(USHORT));

    // Save the array of structs we are managing.
    m_pcEntries = pcEntries;
    m_iEntrySize = iEntrySize;
    return (S_OK);
}

//*****************************************************************************
// Add the struct at the specified index in m_pcEntries to the hash chains.
//*****************************************************************************
BYTE *CHashTable::Add(                  // New entry.
    USHORT      iHash,                  // Hash value of entry to add.
    USHORT      iIndex)                 // Index of struct in m_pcEntries.
{
    HASHENTRY   *psEntry;               // The struct we are adding.

    // Get a pointer to the entry we are adding.
    psEntry = EntryPtr(iIndex);

    // Compute the hash value for the entry.
    iHash %= m_iBuckets;

    _ASSERTE(m_piBuckets[iHash] != iIndex &&
        (m_piBuckets[iHash] == 0xffff || EntryPtr(m_piBuckets[iHash])->iPrev != iIndex));

    // Setup this entry.
    psEntry->iPrev = 0xffff;
    psEntry->iNext = m_piBuckets[iHash];

    // Link it into the hash chain.
    if (m_piBuckets[iHash] != 0xffff)
        EntryPtr(m_piBuckets[iHash])->iPrev = iIndex;
    m_piBuckets[iHash] = iIndex;
    return ((BYTE *) psEntry);
}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
void CHashTable::Delete(
    USHORT      iHash,                  // Hash value of entry to delete.
    USHORT      iIndex)                 // Index of struct in m_pcEntries.
{
    HASHENTRY   *psEntry;               // Struct to delete.
    
    // Get a pointer to the entry we are deleting.
    psEntry = EntryPtr(iIndex);
    Delete(iHash, psEntry);
}

//*****************************************************************************
// Delete the struct at the specified index in m_pcEntries from the hash chains.
//*****************************************************************************
void CHashTable::Delete(
    USHORT      iHash,                  // Hash value of entry to delete.
    HASHENTRY   *psEntry)               // The struct to delete.
{
    // Compute the hash value for the entry.
    iHash %= m_iBuckets;

    _ASSERTE(psEntry->iPrev != psEntry->iNext || psEntry->iPrev == 0xffff);

    // Fix the predecessor.
    if (psEntry->iPrev == 0xffff)
        m_piBuckets[iHash] = psEntry->iNext;
    else
        EntryPtr(psEntry->iPrev)->iNext = psEntry->iNext;

    // Fix the successor.
    if (psEntry->iNext != 0xffff)
        EntryPtr(psEntry->iNext)->iPrev = psEntry->iPrev;
}

//*****************************************************************************
// The item at the specified index has been moved, update the previous and
// next item.
//*****************************************************************************
void CHashTable::Move(
    USHORT      iHash,                  // Hash value for the item.
    USHORT      iNew)                   // New location.
{
    HASHENTRY   *psEntry;               // The struct we are deleting.

    psEntry = EntryPtr(iNew);
    _ASSERTE(psEntry->iPrev != iNew && psEntry->iNext != iNew);

    if (psEntry->iPrev != 0xffff)
        EntryPtr(psEntry->iPrev)->iNext = iNew;
    else
        m_piBuckets[iHash % m_iBuckets] = iNew;
    if (psEntry->iNext != 0xffff)
        EntryPtr(psEntry->iNext)->iPrev = iNew;
}

//*****************************************************************************
// Search the hash table for an entry with the specified key value.
//*****************************************************************************
BYTE *CHashTable::Find(                 // Index of struct in m_pcEntries.
    USHORT      iHash,                  // Hash value of the item.
    BYTE        *pcKey)                 // The key to match.
{
    USHORT      iNext;                  // Used to traverse the chains.
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    // Start at the top of the chain.
    iNext = m_piBuckets[iHash % m_iBuckets];

    // Search until we hit the end.
    while (iNext != 0xffff)
    {
        // Compare the keys.
        psEntry = EntryPtr(iNext);
        if (!Cmp(pcKey, psEntry))
            return ((BYTE *) psEntry);

        // Advance to the next item in the chain.
        iNext = psEntry->iNext;
    }

    // We couldn't find it.
    return (0);
}

//*****************************************************************************
// Search the hash table for the next entry with the specified key value.
//*****************************************************************************
USHORT CHashTable::FindNext(            // Index of struct in m_pcEntries.
    BYTE        *pcKey,                 // The key to match.
    USHORT      iIndex)                 // Index of previous match.
{
    USHORT      iNext;                  // Used to traverse the chains.
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    // Start at the next entry in the chain.
    iNext = EntryPtr(iIndex)->iNext;

    // Search until we hit the end.
    while (iNext != 0xffff)
    {
        // Compare the keys.
        psEntry = EntryPtr(iNext);
        if (!Cmp(pcKey, psEntry))
            return (iNext);

        // Advance to the next item in the chain.
        iNext = psEntry->iNext;
    }

    // We couldn't find it.
    return (0xffff);
}

//*****************************************************************************
// Returns the next entry in the list.
//*****************************************************************************
BYTE *CHashTable::FindNextEntry(        // The next entry, or0 for end of list.
    HASHFIND    *psSrch)                // Search object.
{
    HASHENTRY   *psEntry;               // Used to traverse the chains.

    for (;;)
    {
        // See if we already have one to use and if so, use it.
        if (psSrch->iNext != 0xffff)
        {
            psEntry = EntryPtr(psSrch->iNext);
            psSrch->iNext = psEntry->iNext;
            return ((BYTE *) psEntry);
        }

        // Advance to the next bucket.
        if (psSrch->iBucket < m_iBuckets)
            psSrch->iNext = m_piBuckets[psSrch->iBucket++];
        else
            break;
    }

    // There were no more entries to be found.
    return (0);
}


//
//
// CClosedHashBase
//
//

//*****************************************************************************
// Delete the given value.  This will simply mark the entry as deleted (in
// order to keep the collision chain intact).  There is an optimization that
// consecutive deleted entries leading up to a free entry are themselves freed
// to reduce collisions later on.
//*****************************************************************************
void CClosedHashBase::Delete(
    void        *pData)                 // Key value to delete.
{
    BYTE        *ptr;

    // Find the item to delete.
    if ((ptr = Find(pData)) == 0)
    {
        // You deleted something that wasn't there, why?
        _ASSERTE(0);
        return;
    }

    // One less active entry.
    --m_iCount;

    // For a perfect system, there are no collisions so it is free.
    if (m_bPerfect)
    {
        SetStatus(ptr, FREE);
        return;
    }

    // Mark this entry deleted.
    SetStatus(ptr, DELETED);

    // If the next item is free, then we can go backwards freeing
    // deleted entries which are no longer part of a chain.  This isn't
    // 100% great, but it will reduce collisions.
    BYTE        *pnext;
    if ((pnext = ptr + m_iEntrySize) > EntryPtr(m_iSize - 1))
        pnext = &m_rgData[0];
    if (Status(pnext) != FREE)
        return;
    
    // We can now free consecutive entries starting with the one
    // we just deleted, up to the first non-deleted one.
    while (Status(ptr) == DELETED)
    {
        // Free this entry.
        SetStatus(ptr, FREE);

        // Check the one before it, handle wrap around.
        if ((ptr -= m_iEntrySize) < &m_rgData[0])
            ptr = EntryPtr(m_iSize - 1);
    }
}


//*****************************************************************************
// Iterates over all active values, passing each one to pDeleteLoopFunc.
// If pDeleteLoopFunc returns TRUE, the entry is deleted. This is safer
// and faster than using FindNext() and Delete().
//*****************************************************************************
void CClosedHashBase::DeleteLoop(
    DELETELOOPFUNC pDeleteLoopFunc,     // Decides whether to delete item
    void *pCustomizer)                  // Extra value passed to deletefunc.
{
    int i;

    if (m_rgData == 0)
    {
        return;
    }

    for (i = 0; i < m_iSize; i++)
    {
        BYTE *pEntry = EntryPtr(i);
        if (Status(pEntry) == USED)
        {
            if (pDeleteLoopFunc(pEntry, pCustomizer))
            {
                SetStatus(pEntry, m_bPerfect ? FREE : DELETED);
                --m_iCount;  // One less active entry
            }
        }
    }

    if (!m_bPerfect)
    {
        // Now free DELETED entries that are no longer part of a chain.
        for (i = 0; i < m_iSize; i++)
        {
            if (Status(EntryPtr(i)) == FREE)
            {
                break;
            }
        }
        if (i != m_iSize)
        {
            int iFirstFree = i;
    
            do
            {
                if (i-- == 0)
                {
                    i = m_iSize - 1;
                }
                while (Status(EntryPtr(i)) == DELETED)
                {
                    SetStatus(EntryPtr(i), FREE);
                    if (i-- == 0)
                    {
                        i = m_iSize - 1;
                    }
                }
    
                while (Status(EntryPtr(i)) != FREE)
                {
                    if (i-- == 0)
                    {
                        i = m_iSize - 1;
                    }
                }
    
            }
            while (i != iFirstFree);
        }
    }

}

//*****************************************************************************
// Lookup a key value and return a pointer to the element if found.
//*****************************************************************************
BYTE *CClosedHashBase::Find(            // The item if found, 0 if not.
    void        *pData)                 // The key to lookup.
{
    unsigned long iHash;                // Hash value for this data.
    int         iBucket;                // Which bucke to start at.
    int         i;                      // Loop control.

    // Safety check.
    if (!m_rgData || m_iCount == 0)
        return (0);

    // Hash to the bucket.
    iHash = Hash(pData);
    iBucket = iHash % m_iBuckets;

    // For a perfect table, the bucket is the correct one.
    if (m_bPerfect)
    {
        // If the value is there, it is the correct one.
        if (Status(EntryPtr(iBucket)) != FREE)
            return (EntryPtr(iBucket));
        return (0);
    }

    // Walk the bucket list looking for the item.
    for (i=iBucket;  Status(EntryPtr(i)) != FREE;  )
    {
        // Don't look at deleted items.
        if (Status(EntryPtr(i)) == DELETED)
        {
            // Handle wrap around.
            if (++i >= m_iSize)
                i = 0;
            continue;
        }

        // Check this one.
        if (Compare(pData, EntryPtr(i)) == 0)
            return (EntryPtr(i));

        // If we never collided while adding items, then there is
        // no point in scanning any further.
        if (!m_iCollisions)
            return (0);

        // Handle wrap around.
        if (++i >= m_iSize)
            i = 0;
    }
    return (0);
}



//*****************************************************************************
// Look for an item in the table.  If it isn't found, then create a new one and
// return that.
//*****************************************************************************
BYTE *CClosedHashBase::FindOrAdd(       // The item if found, 0 if not.
    void        *pData,                 // The key to lookup.
    bool        &bNew)                  // true if created.
{
    unsigned long iHash;                // Hash value for this data.
    int         iBucket;                // Which bucke to start at.
    int         i;                      // Loop control.

    // If we haven't allocated any memory, or it is too small, fix it.
    if (!m_rgData || ((m_iCount + 1) > (m_iSize * 3 / 4) && !m_bPerfect))
    {
        if (!ReHash())
            return (0);
    }

    // Assume we find it.
    bNew = false;

    // Hash to the bucket.
    iHash = Hash(pData);
    iBucket = iHash % m_iBuckets;

    // For a perfect table, the bucket is the correct one.
    if (m_bPerfect)
    {
        // If the value is there, it is the correct one.
        if (Status(EntryPtr(iBucket)) != FREE)
            return (EntryPtr(iBucket));
        i = iBucket;
    }
    else
    {
        // Walk the bucket list looking for the item.
        for (i=iBucket;  Status(EntryPtr(i)) != FREE;  )
        {
            // Don't look at deleted items.
            if (Status(EntryPtr(i)) == DELETED)
            {
                // Handle wrap around.
                if (++i >= m_iSize)
                    i = 0;
                continue;
            }

            // Check this one.
            if (Compare(pData, EntryPtr(i)) == 0)
                return (EntryPtr(i));

            // One more to count.
            ++m_iCollisions;

            // Handle wrap around.
            if (++i >= m_iSize)
                i = 0;
        }
    }

    // We've found an open slot, use it.
    _ASSERTE(Status(EntryPtr(i)) == FREE);
    bNew = true;
    ++m_iCount;
    return (EntryPtr(i));
}

//*****************************************************************************
// This helper actually does the add for you.
//*****************************************************************************
BYTE *CClosedHashBase::DoAdd(void *pData, BYTE *rgData, int &iBuckets, int iSize, 
            int &iCollisions, int &iCount)
{
    unsigned long iHash;                // Hash value for this data.
    int         iBucket;                // Which bucke to start at.
    int         i;                      // Loop control.

    // Hash to the bucket.
    iHash = Hash(pData);
    iBucket = iHash % iBuckets;

    // For a perfect table, the bucket is free.
    if (m_bPerfect)
    {
        i = iBucket;
        _ASSERTE(Status(EntryPtr(i, rgData)) == FREE);
    }
    // Need to scan.
    else
    {
        // Walk the bucket list looking for a slot.
        for (i=iBucket;  Status(EntryPtr(i, rgData)) != FREE;  )
        {
            // Handle wrap around.
            if (++i >= iSize)
                i = 0;

            // If we made it this far, we collided.
            ++iCollisions;
        }
    }

    // One more item in list.
    ++iCount;

    // Return the new slot for the caller.
    return (EntryPtr(i, rgData));
}

//*****************************************************************************
// This function is called either to init the table in the first place, or
// to rehash the table if we ran out of room.
//*****************************************************************************
bool CClosedHashBase::ReHash()          // true if successful.
{
    // Allocate memory if we don't have any.
    if (!m_rgData)
    {
        if ((m_rgData = new BYTE [m_iSize * m_iEntrySize]) == 0)
            return (false);
        InitFree(&m_rgData[0], m_iSize);
        return (true);
    }

    // We have entries already, allocate a new table.
    BYTE        *rgTemp, *p;
    int         iBuckets = m_iBuckets * 2 - 1;
    int         iSize = iBuckets + 7;
    int         iCollisions = 0;
    int         iCount = 0;

    if ((rgTemp = new BYTE [iSize * m_iEntrySize]) == 0)
        return (false);
    InitFree(&rgTemp[0], iSize);
    m_bPerfect = false;

    // Rehash the data.
    for (int i=0;  i<m_iSize;  i++)
    {
        // Only copy used entries.
        if (Status(EntryPtr(i)) != USED)
            continue;
        
        // Add this entry to the list again.
        VERIFY((p = DoAdd(GetKey(EntryPtr(i)), rgTemp, iBuckets, 
                iSize, iCollisions, iCount)) != 0);
        memmove(p, EntryPtr(i), m_iEntrySize);
    }
    
    // Reset internals.
    delete [] m_rgData;
    m_rgData = rgTemp;
    m_iBuckets = iBuckets;
    m_iSize = iSize;
    m_iCollisions = iCollisions;
    m_iCount = iCount;
    return (true);
}


//
//
// CStructArray
//
//


//*****************************************************************************
// Returns a pointer to the (iIndex)th element of the array, shifts the elements 
// in the array if the location is already full. The iIndex cannot exceed the count 
// of elements in the array.
//*****************************************************************************
void *CStructArray::Insert(
    int         iIndex)
{
    _ASSERTE(iIndex >= 0);
    
    // We can not insert an element further than the end of the array.
    if (iIndex > m_iCount)
        return (NULL);
    
    // The array should grow, if we can't fit one more element into the array.
    if (Grow(1) == FALSE)
        return (NULL);

    // The pointer to be returned.
    char *pcList = ((char *) m_pList) + iIndex * m_iElemSize;

    // See if we need to slide anything down.
    if (iIndex < m_iCount)
        memmove(pcList + m_iElemSize, pcList, (m_iCount - iIndex) * m_iElemSize);
    ++m_iCount;
    return(pcList);
}


//*****************************************************************************
// Allocate a new element at the end of the dynamic array and return a pointer
// to it.
//*****************************************************************************
void *CStructArray::Append()
{
    // The array should grow, if we can't fit one more element into the array.
    if (Grow(1) == FALSE)
        return (NULL);

    return (((char *) m_pList) + m_iCount++ * m_iElemSize);
}


//*****************************************************************************
// Allocate enough memory to have at least iCount items.  This is a one shot
// check for a block of items, instead of requiring singleton inserts.  It also
// avoids realloc headaches caused by growth, since you can do the whole block
// in one piece of code.  If the array is already large enough, this is a no-op.
//*****************************************************************************
int CStructArray::AllocateBlock(int iCount)
{
    if (m_iSize < m_iCount+iCount)
    {
        if (!Grow(iCount))
            return (FALSE);
    }
    m_iCount += iCount;
    return (TRUE);
}



//*****************************************************************************
// Deletes the specified element from the array.
//*****************************************************************************
void CStructArray::Delete(
    int         iIndex)
{
    _ASSERTE(iIndex >= 0);

    // See if we need to slide anything down.
    if (iIndex < --m_iCount)
    {
        char *pcList = ((char *) m_pList) + iIndex * m_iElemSize;
        memmove(pcList, pcList + m_iElemSize, (m_iCount - iIndex) * m_iElemSize);
    }
}


//*****************************************************************************
// Grow the array if it is not possible to fit iCount number of new elements.
//*****************************************************************************
int CStructArray::Grow(
    int         iCount)
{
    void        *pTemp;                 // temporary pointer used in realloc.
    int         iGrow;

    if (m_iSize < m_iCount+iCount)
    {
        if (m_pList == NULL)
        {
            iGrow = max(m_iGrowInc, iCount);

            //@todo this is a hack because I don't want to do resize right now.
            if ((m_pList = malloc(iGrow * m_iElemSize)) == NULL)
                return (FALSE);
            m_iSize = iGrow;
            m_bFree = true;
        }
        else
        {
            // Adjust grow size as a ratio to avoid too many reallocs.
            if (m_iSize / m_iGrowInc >= 3)
                m_iGrowInc *= 2;

            iGrow = max(m_iGrowInc, iCount);

            // try to allocate memory for reallocation.
            if (m_bFree)
            {   // We already own memory.
                if((pTemp = realloc(m_pList, (m_iSize+iGrow) * m_iElemSize)) == NULL)
                    return (FALSE);
            }
            else
            {   // We don't own memory; get our own.
                if((pTemp = malloc((m_iSize+iGrow) * m_iElemSize)) == NULL)
                    return (FALSE);
                memcpy(pTemp, m_pList, m_iSize * m_iElemSize);
                m_bFree = true;
            }
            m_pList = pTemp;
            m_iSize += iGrow;
        }
    }
    return (TRUE);
}


//*****************************************************************************
// Free the memory for this item.
//*****************************************************************************
void CStructArray::Clear()
{
    // Free the chunk of memory.
    if (m_bFree && m_pList != NULL)
        free(m_pList);

    m_pList = NULL;
    m_iSize = 0;
    m_iCount = 0;
}



//
//
// CStringSet
//
//

//*****************************************************************************
// Free memory.
//*****************************************************************************
CStringSet::~CStringSet()
{
    if (m_pStrings)
        free(m_pStrings);
}

//*****************************************************************************
// Delete the specified string from the string set.
//*****************************************************************************
int CStringSet::Delete(
    int     iStr)
{
    void        *pTemp = (char *) m_pStrings + iStr;
    int         iDelSize = Wszlstrlen((LPCTSTR) pTemp) + 1;

    if ((char *) pTemp + iDelSize > (char *) m_pStrings + m_iUsed)
        return (-1);

    memmove(pTemp, (char *) pTemp + iDelSize, m_iUsed - (iStr + iDelSize));
    m_iUsed -= iDelSize;
    return (0);
}


//*****************************************************************************
// Save the specified string and return its index in the storage space.
//*****************************************************************************
int CStringSet::Save(
    LPCTSTR     szStr)
{

    void        *pTemp;                 // temporary pointer used in realloc.
    int         iNeeded = Wszlstrlen(szStr) +1; // amount of memory needed in the StringSet.
    
    _ASSERTE(!(m_pStrings == NULL && m_iSize != 0));
    
    if (m_iSize < m_iUsed + iNeeded)
    {
        if (m_pStrings == NULL)
        {
            // Allocate memory for the string set..
            if ((m_pStrings = malloc(m_iGrowInc)) == NULL)

                return (-1);
            m_iSize = m_iGrowInc;
        }
        else
        {
            // try to allocate memory for reallocation. 
            if((pTemp = realloc(m_pStrings, m_iSize + m_iGrowInc)) == NULL)
                return (-1);
            // copy the pointer and update the set size.
            m_iSize += m_iGrowInc;
            m_pStrings = pTemp;
        }
    }

    Wszlstrcpy((TCHAR *) m_pStrings + m_iUsed, szStr);
    int iTmp = m_iUsed;
    m_iUsed += iNeeded;
    return (iTmp);
}

//*****************************************************************************
// Shrink the StringSet so that it does not keep more space than it needs.
//*****************************************************************************
int CStringSet::Shrink()                // return code
{
    void    *pTemp;

    if((pTemp = realloc(m_pStrings, m_iUsed)) == NULL)
        return (-1);

    m_pStrings = pTemp;
    return (0);
}





//*****************************************************************************
// Convert a string of hex digits into a hex value of the specified # of bytes.
//*****************************************************************************
HRESULT GetHex(                         // Return status.
    LPCSTR      szStr,                  // String to convert.
    int         size,                   // # of bytes in pResult.
    void        *pResult)               // Buffer for result.
{
    int         count = size * 2;       // # of bytes to take from string.
    unsigned long Result = 0;           // Result value.
    char          ch;

    _ASSERTE(size == 1 || size == 2 || size == 4);

    while (count-- && (ch = *szStr++) != '\0')
    {
        switch (ch)
        {
            case '0': case '1': case '2': case '3': case '4': 
            case '5': case '6': case '7': case '8': case '9': 
            Result = 16 * Result + (ch - '0');
            break;

            case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
            Result = 16 * Result + 10 + (ch - 'A');
            break;

            case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
            Result = 16 * Result + 10 + (ch - 'a');
            break;

            default:
            return (E_FAIL);
        }
    }

    // Set the output.
    switch (size)
    {
        case 1:
        *((BYTE *) pResult) = (BYTE) Result;
        break;

        case 2:
        *((WORD *) pResult) = (WORD) Result;
        break;

        case 4:
        *((DWORD *) pResult) = Result;
        break;

        default:
        _ASSERTE(0);
        break;
    }
    return (S_OK);
}

//*****************************************************************************
// Convert hex value into a wide string of hex digits 
//*****************************************************************************
HRESULT GetStr (DWORD hHexNum, LPWSTR szHexNum, DWORD cbHexNum)
{
    _ASSERTE (szHexNum);
    cbHexNum *= 2; // each nibble is a char
    while (cbHexNum)
    {
        DWORD thisHexDigit = hHexNum % 16;
        hHexNum /= 16;
        cbHexNum--;
        if (thisHexDigit < 10)
            *(szHexNum+cbHexNum) = (BYTE)(thisHexDigit + L'0');
        else
            *(szHexNum+cbHexNum) = (BYTE)(thisHexDigit - 10 + L'A');
    }
    return S_OK;
}

//*****************************************************************************
// Convert a GUID into a pointer to a Wide char string
//*****************************************************************************
int GuidToLPWSTR(                  // Return status.
    GUID        Guid,                  // The GUID to convert.
    LPWSTR      szGuid,                // String into which the GUID is stored
    DWORD       cchGuid)                // Count in wchars
{
    int         i;
    
    // successive fields break the GUID into the form DWORD-WORD-WORD-WORD-WORD.DWORD 
    // covering the 128-bit GUID. The string includes enclosing braces, which are an OLE convention.

    if (cchGuid < 39) // 38 chars + 1 null terminating.
        return 0;

    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    // ^
    szGuid[0]  = L'{';

    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //  ^^^^^^^^
    if (FAILED (GetStr(Guid.Data1, szGuid+1 , 4))) return 0;

    szGuid[9]  = L'-';
    
    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //           ^^^^
    if (FAILED (GetStr(Guid.Data2, szGuid+10, 2))) return 0;

    szGuid[14] = L'-';
    
    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //                ^^^^
    if (FAILED (GetStr(Guid.Data3, szGuid+15, 2))) return 0;

    szGuid[19] = L'-';
    
    // Get the last two fields (which are byte arrays).
    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //                     ^^^^
    for (i=0; i < 2; ++i)
        if (FAILED(GetStr(Guid.Data4[i], szGuid + 20 + (i * 2), 1)))
            return (0);

    szGuid[24] = L'-';
    
    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //                          ^^^^^^^^^^^^
    for (i=0; i < 6; ++i)
        if (FAILED(GetStr(Guid.Data4[i+2], szGuid + 25 + (i * 2), 1)))
            return (0);

    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //                                      ^
    szGuid[37] = L'}';
    szGuid[38] = L'\0';

#ifdef _DEBUG
    WCHAR      __szGuid[39];
    DWORD retVal = StringFromGUID2(Guid, __szGuid, cchGuid);
    _ASSERTE (retVal >= 39);
    _ASSERTE (_wcsicmp (__szGuid, szGuid) == 0);
#endif // _DEBUG
    return 39;
}

//*****************************************************************************
// Convert a pointer to a string into a GUID.
//*****************************************************************************
HRESULT LPCSTRToGuid(                   // Return status.
    LPCSTR      szGuid,                 // String to convert.
    GUID        *psGuid)                // Buffer for converted GUID.
{
    int         i;

    // Verify the surrounding syntax.
    if (strlen(szGuid) != 38 || szGuid[0] != '{' || szGuid[9] != '-' ||
        szGuid[14] != '-' || szGuid[19] != '-' || szGuid[24] != '-' || szGuid[37] != '}')
        return (E_FAIL);

    // Parse the first 3 fields.
    if (FAILED(GetHex(szGuid+1, 4, &psGuid->Data1))) return (E_FAIL);
    if (FAILED(GetHex(szGuid+10, 2, &psGuid->Data2))) return (E_FAIL);
    if (FAILED(GetHex(szGuid+15, 2, &psGuid->Data3))) return (E_FAIL);

    // Get the last two fields (which are byte arrays).
    for (i=0; i < 2; ++i)
        if (FAILED(GetHex(szGuid + 20 + (i * 2), 1, &psGuid->Data4[i])))
            return (E_FAIL);
    for (i=0; i < 6; ++i)
        if (FAILED(GetHex(szGuid + 25 + (i * 2), 1, &psGuid->Data4[i+2])))
            return (E_FAIL);
    return (S_OK);
}


//*****************************************************************************
// Parse a string that is a list of strings separated by the specified
// character.  This eliminates both leading and trailing whitespace.  Two
// important notes: This modifies the supplied buffer and changes the szEnv
// parameter to point to the location to start searching for the next token.
// This also skips empty tokens (e.g. two adjacent separators).  szEnv will be
// set to NULL when no tokens remain.  NULL may also be returned if no tokens
// exist in the string.
//*****************************************************************************
char *StrTok(                           // Returned token.
    char        *&szEnv,                // Location to start searching.
    char        ch)                     // Separator character.
{
    char        *tok;                   // Returned token.
    char        *next;                  // Used to find separator.

    do
    {
        // Handle the case that we have thrown away a bunch of white space.
        if (szEnv == NULL) return(NULL);

        // Skip leading whitespace.
        while (*szEnv == ' ' || *szEnv == '\t') ++szEnv;

        // Parse the next component.
        tok = szEnv;
        if ((next = strchr(szEnv, ch)) == NULL)
            szEnv = NULL;
        else
        {
            szEnv = next+1;

            // Eliminate trailing white space.
            while (--next >= tok && (*next == ' ' || *next == '\t'));
            *++next = '\0';
        }
    }
    while (*tok == '\0');
    return (tok);
}


//
//
// Global utility functions.
//
//



#ifdef _DEBUG
// Only write if tracing is allowed.
int _cdecl DbgWrite(LPCTSTR szFmt, ...)
{
    static WCHAR rcBuff[1024];
    static int  bChecked = 0;
    static int  bWrite = 1;
    va_list     marker;

    if (!bChecked)
    {
        bWrite = REGUTIL::GetLong(L"Trace", FALSE);
        bChecked = 1;
    }

    if (!bWrite)
        return (0);

    va_start(marker, szFmt);
    _vsnwprintf(rcBuff, NumItems(rcBuff), szFmt, marker);
    va_end(marker);
    WszOutputDebugString(rcBuff);
    return (lstrlenW(rcBuff));
}

// Always write regardless of registry.
int _cdecl DbgWriteEx(LPCTSTR szFmt, ...)
{
    static WCHAR rcBuff[1024];
    va_list     marker;

    va_start(marker, szFmt);
    _vsnwprintf(rcBuff, NumItems(rcBuff), szFmt, marker);
    va_end(marker);
    WszOutputDebugString(rcBuff);
    return (lstrlenW(rcBuff));
}
#endif


// Writes a wide, formatted string to the standard output.
//@ todo: Is 1024 big enough?  what does printf do?

int _cdecl PrintfStdOut(LPCWSTR szFmt, ...)
{
    WCHAR rcBuff[1024];
    CHAR  sMbsBuff[1024 * sizeof(WCHAR)];
    va_list     marker;
    DWORD       cWritten;
    int         cChars;
    

    va_start(marker, szFmt);
    _vsnwprintf(rcBuff, NumItems(rcBuff), szFmt, marker);
    va_end(marker);
    cChars = lstrlenW(rcBuff);
    int cBytes = WszWideCharToMultiByte(CP_ACP, 0, rcBuff, -1, sMbsBuff, sizeof(sMbsBuff)-1, NULL, NULL);
    
    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), sMbsBuff, cBytes, &cWritten, NULL);
    
    return (cChars);
}


//
// A private function to do the equavilent of a CoCreateInstance in
// cases where we can't make the real call. Use this when, for
// instance, you need to create a symbol reader in the Runtime but
// we're not CoInitialized. Obviously, this is only good for COM
// objects for which CoCreateInstance is just a glorified
// find-and-load-me operation.
//
typedef HRESULT __stdcall DLLGETCLASSOBJECT(REFCLSID rclsid,
                                            REFIID   riid,
                                            void   **ppv);

IID IID_ICF = {0x00000001, 0x0000, 0x0000, {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46}};

HRESULT FakeCoCreateInstance(REFCLSID   rclsid,
                             REFIID     riid,
                             void     **ppv)
{
    HRESULT hr = S_OK;

    // Convert the clsid to a string so we can find the InprocServer32
    // in the registry.
    WCHAR guidString[64];
    WCHAR keyString[1024];

    GuidToLPWSTR(rclsid, guidString, 64);
    swprintf(keyString, L"CLSID\\%s\\InprocServer32", guidString);

    // Lets grab the DLL name now.
    HKEY key;
    DWORD len;
    LONG result = WszRegOpenKeyEx(HKEY_CLASSES_ROOT, keyString, 0, KEY_READ, &key);
    WCHAR dllName[MAX_PATH];

    if (result == ERROR_SUCCESS)
    {
        DWORD type;
            
        result = WszRegQueryValueEx(key, NULL, NULL, &type, NULL, &len);
        
        if ((result == ERROR_SUCCESS) && ((type == REG_SZ) ||
                                          (type == REG_EXPAND_SZ)))
        {
            _ASSERTE(len <= sizeof(dllName));
            if( len <= sizeof(dllName)) {
                DWORD len2 = sizeof(dllName);
                result = WszRegQueryValueEx(key, NULL, NULL, &type,
                                        (BYTE*) dllName, &len2);
                if (result != ERROR_SUCCESS)
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
                hr = ResultFromScode(E_INVALIDARG);  // invalid registry value, too long
        }
        else if (result == ERROR_SUCCESS) {
            hr = ResultFromScode(E_INVALIDARG);    // invalid registry value type, better error code can be used
        } 
        else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    
        RegCloseKey(key);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
        
    if (FAILED(hr))
        return hr;

    // We've got the name of the DLL to load, so load it.
    HINSTANCE dll = WszLoadLibraryEx(dllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

    if (dll != NULL)
    {
        // We've loaded the DLL, so find the DllGetClassObject function.
        FARPROC func = GetProcAddress(dll, "DllGetClassObject");

        if (func != NULL)
        {
            // Cool, lets call the function to get a class factory for
            // the rclsid passed in.
            IClassFactory *classFactory;
            DLLGETCLASSOBJECT *dllGetClassObject = (DLLGETCLASSOBJECT*)func;

            hr = dllGetClassObject(rclsid,
                                   IID_ICF,
                                   (void**)&classFactory);

            if (SUCCEEDED(hr))
            {
                // Ask the class factory to create an instance of the
                // necessary object.
                hr = classFactory->CreateInstance(NULL, riid, ppv);

                // Release that class factory!
                classFactory->Release();
            }
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}

// We either want space after all the modules (start at the top & work down)
// (pModule == NULL), or after a specific address (a module's IL Base)
// (start there & work up)(pModule != NULL).  
HRESULT FindFreeSpaceWithinRange(const BYTE *&pStart, 
                                 const BYTE *&pNext, 
                                 const BYTE *&pLast, 
                                 const BYTE *pBaseAddr,
                                 const BYTE *pMaxAddr,
                                 int sizeToFind)
{
#ifdef _DEBUG
    if (REGUTIL::GetConfigDWORD(L"FFSWR",0))
        _ASSERTE( !"Stop in FindFreeSpaceWithinRange?");
#endif

    _ASSERTE(sizeToFind >= 0);
    
    MEMORY_BASIC_INFORMATION info;
    memset((void *)&info, 0, sizeof(info));

    // If we're given 0, default to 1 meg
    if (sizeToFind == 0)
    {
        sizeToFind = 1024*1024;
    }

    // Start looking either at the hard coded min, or higher if we're
    // give a higher base address.
    BYTE *tryAddr = max((BYTE *)pBaseAddr, (BYTE *)BOT_MEMORY);

    // Now scan memory and try to find a free block of the size requested.
    while ((DWORD)tryAddr < (DWORD)TOP_MEMORY &&
           (const BYTE *)(tryAddr + sizeToFind) < pMaxAddr)
    {
        VirtualQuery((LPCVOID)tryAddr, &info, sizeof(info));
 
        // Is there enough memory free from this start location?
        if(info.State == MEM_FREE && info.RegionSize >= (SIZE_T)sizeToFind) 
        {
            // Try actually commiting now
            pStart = (const BYTE*) VirtualAlloc(tryAddr, 
                                                sizeToFind, 
                                                MEM_RESERVE, 
                                                PAGE_READWRITE);

            // Success!
            if (pStart) 
            {
                pNext = pStart;
                pLast = pStart + sizeToFind;
                return S_OK;
            }

            // We could fail in a race.  Just fall out and move on to next region.
        }

        // Try another section of memory
        tryAddr = max(tryAddr+(SIZE_T)sizeToFind, 
                      (BYTE *)info.AllocationBase+info.RegionSize);
    }

    // If we've cycled through all the memory and can't find an opening, we've failed
    return E_OUTOFMEMORY;
}

//******************************************************************************
// Returns the number of processors that a process has been configured to run on
//******************************************************************************
int GetCurrentProcessCpuCount()
{
    DWORD pmask, smask;

    if (!GetProcessAffinityMask(GetCurrentProcess(), &pmask, &smask))
        return 1;

    if (pmask == 1)
        return 1;

    int count = 0;

    for (DWORD m = 0x80000000; m != 0; m >>= 1) {
        if ((smask & m) != 0 && (pmask & m) != 0)
            count++;
    }

    return count;
}

/**************************************************************************/
void ConfigMethodSet::init() 
{
    OnUnicodeSystem();
    LPWSTR str = REGUTIL::GetConfigString(m_keyName);
    if (str) 
    {
        m_list.Insert(str);
        REGUTIL::FreeConfigString(str);
    }
    m_inited = true;
}

/**************************************************************************/
bool ConfigMethodSet::contains(LPCUTF8 methodName, LPCUTF8 className, PCCOR_SIGNATURE sig)
{
    if (!m_inited) 
        init();
    if (m_list.IsEmpty())
        return false;
    return(m_list.IsInList(methodName, className, sig));
}

/**************************************************************************/
void ConfigDWORD::init() 
{
    OnUnicodeSystem();
    m_value = REGUTIL::GetConfigDWORD(m_keyName, m_value);
    m_inited = true;
}


/**************************************************************************/
void ConfigString::init() 
{
    OnUnicodeSystem();
    m_value = REGUTIL::GetConfigString(m_keyName);
    m_inited = true;
}

/**************************************************************************/
ConfigString::~ConfigString() 
{
    delete [] m_value;
}


//=============================================================================
// MethodNamesList
//=============================================================================
//  str should be of the form :
// "foo1 MyNamespace.MyClass:foo3 *:foo4 foo5(x,y,z)"
// "MyClass:foo2 MyClass:*" will match under _DEBUG
//

void MethodNamesList::Insert(LPWSTR str)
{
    enum State { NO_NAME, CLS_NAME, FUNC_NAME, ARG_LIST }; // parsing state machine

    const char   SEP_CHAR = ' ';     // current character use to separate each entry
//  const char   SEP_CHAR = ';';     // better  character use to separate each entry

    WCHAR        lastChar = '?';     // dummy
    LPWSTR       nameStart;          // while walking over the classname or methodname, this points to start
    MethodName   nameBuf;            // Buffer used while parsing the current entry
    MethodName** lastName = &pNames; // last entry inserted into the list
    bool         bQuote   = false;

    for(State state = NO_NAME; lastChar != '\0'; str++)
    {
        lastChar = *str;

        switch(state)
        {
        case NO_NAME:
            if (*str != SEP_CHAR)
            {
                nameStart = str;
                state = CLS_NAME; // we have found the start of the next entry
            }
            break;

        case CLS_NAME:
            if (*nameStart == '"')
            {
                while (*str && *str!='"')
                {
                    str++;
                }
                nameStart++;
                bQuote=true;
            }

            if (*str == ':')
            {
                if (*nameStart == '*' && !bQuote)
                {
                    // Is the classname string a wildcard. Then set it to NULL
                    nameBuf.className = NULL;
                }
                else
                {
                    int len = (int)(str - nameStart);

                    // Take off the quote
                    if (bQuote) { len--; bQuote=false; }
                    
                    nameBuf.className = new char[len + 1];
                    MAKE_UTF8PTR_FROMWIDE(temp, nameStart);
                    memcpy(nameBuf.className, temp, len*sizeof(nameBuf.className[0]));
                    nameBuf.className[len] = '\0';
                }
                if (str[1] == ':')      // Accept class::name syntax too
                    str++;
                nameStart = str + 1;
                state = FUNC_NAME;
            }
            else if (*str == '\0' || *str == SEP_CHAR || *str == '(')
            {
            /* This was actually a method name without any class */
                nameBuf.className = NULL;
                goto DONE_FUNC_NAME;
            }
            break;

        case FUNC_NAME:
            if (*nameStart == '"')
            {
                while ( (nameStart==str)    || // Hack to handle when className!=NULL
                        (*str && *str!='"'))
                {
                    str++;
                }
                       
                nameStart++;
                bQuote=true;
            }

            if (*str == '\0' || *str == SEP_CHAR || *str == '(')
            {
DONE_FUNC_NAME:
                _ASSERTE(*str == '\0' || *str == SEP_CHAR || *str == '(');
                
                if (*nameStart == '*' && !bQuote)
                {
                    // Is the name string a wildcard. Then set it to NULL
                    nameBuf.methodName = NULL;
                }
                else
                {
                    int len = (int)(str - nameStart);

                    // Take off the quote
                    if (bQuote) { len--; bQuote=false; }

                    nameBuf.methodName = new char[len + 1];
                    MAKE_UTF8PTR_FROMWIDE(temp, nameStart);
                    memcpy(nameBuf.methodName, temp, len*sizeof(nameBuf.methodName[0]));
                    nameBuf.methodName[len] = '\0';
                }

                if (*str == '\0' || *str == SEP_CHAR)
                {
                    nameBuf.numArgs = -1;
                    goto DONE_ARG_LIST;
                }
                else
                {
                    _ASSERTE(*str == '(');
                    nameBuf.numArgs = -1;
                    state = ARG_LIST;
                }
            }
            break;

        case ARG_LIST:
            if (*str == '\0' || *str == ')')
            {
                if (nameBuf.numArgs == -1)
                    nameBuf.numArgs = 0;
                
DONE_ARG_LIST:
                _ASSERTE(*str == '\0' || *str == SEP_CHAR || *str == ')');

        // We have parsed an entire method name.
        // Create a new entry in the list for it

                MethodName * newName = new MethodName();
                *newName      = nameBuf;
                newName->next = NULL;
                *lastName     = newName;
                lastName      = &newName->next;
                state         = NO_NAME;
            }
            else
            {
                if (*str != SEP_CHAR && nameBuf.numArgs == -1)
                    nameBuf.numArgs = 1;
                if (*str == ',')
                    nameBuf.numArgs++;
            }
            break;

        default: _ASSERTE(!"Bad state"); break;
        }
    }
}

/**************************************************************/

MethodNamesList::~MethodNamesList() 
{
    for(MethodName * pName = pNames; pName; /**/)
    {
        if (pName->className)
            delete [] pName->className;
        if (pName->methodName)
            delete [] pName->methodName;

        MethodName * curName = pName;
        pName = pName->next;
        delete curName;
    }
}

/**************************************************************/
bool MethodNamesList::IsInList(LPCUTF8 methName, LPCUTF8 clsName, PCCOR_SIGNATURE sig) 
{
    sig++;      // Skip calling convention
    int numArgs = CorSigUncompressData(sig);    

    // Try to match all the entries in the list

    for(MethodName * pName = pNames; pName; pName = pName->next)
    {
        // If numArgs is valid, check for mismatch
        if (pName->numArgs != -1 && pName->numArgs != numArgs)
            continue;

        // If methodName is valid, check for mismatch
        if (pName->methodName) {
            if (strcmp(pName->methodName, methName) != 0) {

                // C++ embeds the class name into the method name,
                // deal with that here (Hack)
                char* ptr = strchr(methName, ':');
                if (ptr != 0 && ptr[1] == ':' && strcmp(&ptr[2], pName->methodName) == 0) {
                    unsigned clsLen = (unsigned)(ptr - methName);
                    if (pName->className == 0 || strncmp(pName->className, methName, clsLen) == 0)
                        return true;
                }
                continue;
            }
        }


        // check for class Name exact match
        if (pName->className == 0 || strcmp(pName->className, clsName) == 0)
            return true;

        // check for suffix wildcard like System.*
        unsigned len = (unsigned)strlen(pName->className);
        if (len > 0 && pName->className[len-1] == '*' && strncmp(pName->className, clsName, len-1) == 0)
            return true;

#ifdef _DEBUG
            // Maybe className doesnt include namespace. Try to match that
        LPCUTF8 onlyClass = ns::FindSep(clsName);
        if (onlyClass && strcmp(pName->className, onlyClass+1) == 0)
            return true;
#endif
    }
    return(false);
}

//=============================================================================
// Signature Validation Functions (scaled down version from MDValidator
//=============================================================================

//*****************************************************************************
// This function validates that the given Method signature is consistent as per
// the compression scheme.
//*****************************************************************************
HRESULT validateSigCompression(
    mdToken     tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE pbSig,              // [IN] Signature.
    ULONG       cbSig)                  // [IN] Size in bytes of the signature.
{
    ULONG       ulCurByte = 0;          // Current index into the signature.
    ULONG       ulSize;                 // Size of uncompressed data at each point.

    // Check for NULL signature.
    if (!pbSig || !cbSig) return VLDTR_E_SIGNULL;

    // Walk through the signature.  At each point make sure there is enough
    // room left in the signature based on the encoding in the current byte.
    while (cbSig - ulCurByte)
    {
        _ASSERTE(ulCurByte <= cbSig);
        // Get next chunk of uncompressed data size.
        if ((ulSize = CorSigUncompressedDataSize(pbSig)) > (cbSig - ulCurByte)) return VLDTR_E_SIGNODATA;
        // Go past this chunk.
        ulCurByte += ulSize;
        CorSigUncompressData(pbSig);
    }
    return S_OK;
}   // validateSigCompression()

//*****************************************************************************
// This function validates one argument given an offset into the signature
// where the argument begins.  This function assumes that the signature is well
// formed as far as the compression scheme is concerned.
// @todo: Validate tokens embedded.
//*****************************************************************************
HRESULT validateOneArg(
    mdToken     tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE &pbSig,             // [IN] Pointer to the beginning of argument.
    ULONG       cbSig,                  // [IN] Size in bytes of the full signature.
    ULONG       *pulCurByte,            // [IN/OUT] Current offset into the signature..
    ULONG       *pulNSentinels,         // [IN/OUT] Number of sentinels
    IMDInternalImport*  pImport,        // [IN] Internal MD Import interface ptr
    BOOL        bNoVoidAllowed)         // [IN] Flag indicating whether "void" is disallowed for this arg

{
    ULONG       ulElementType;          // Current element type being processed.
    ULONG       ulElemSize;             // Size of the element type.
    mdToken     token;                  // Embedded token.
    ULONG       ulArgCnt;               // Argument count for function pointer.
    ULONG       ulRank;                 // Rank of the array.
    ULONG       ulSizes;                // Count of sized dimensions of the array.
    ULONG       ulLbnds;                // Count of lower bounds of the array.
    ULONG       ulTkSize;               // Token size.
    ULONG       ulCallConv;

    HRESULT     hr = S_OK;              // Value returned.
    BOOL        bRepeat = TRUE;         // MODOPT and MODREQ belong to the arg after them

    _ASSERTE (pulCurByte);

    while(bRepeat)
    {
        bRepeat = FALSE;
        // Validate that the argument is not missing.
        _ASSERTE(*pulCurByte <= cbSig);
        if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSARG;

        // Get the element type.
        *pulCurByte += (ulElemSize = CorSigUncompressedDataSize(pbSig));
        ulElementType = CorSigUncompressData(pbSig);

        // Walk past all the modifier types.
        while (ulElementType & ELEMENT_TYPE_MODIFIER)
        {
            _ASSERTE(*pulCurByte <= cbSig);
            if(ulElementType == ELEMENT_TYPE_SENTINEL)
            {
                if(pulNSentinels) *pulNSentinels+=1;
                if(TypeFromToken(tk) != mdtMemberRef) return VLDTR_E_SIG_SENTINMETHODDEF;
                if (cbSig == *pulCurByte) return VLDTR_E_SIG_LASTSENTINEL;
            }
            if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSELTYPE;
            *pulCurByte += (ulElemSize = CorSigUncompressedDataSize(pbSig));
            ulElementType = CorSigUncompressData(pbSig);
        }

        switch (ulElementType)
        {
            case ELEMENT_TYPE_VOID:
                if(bNoVoidAllowed) return VLDTR_E_SIG_BADVOID;

            case ELEMENT_TYPE_BOOLEAN:
            case ELEMENT_TYPE_CHAR:
            case ELEMENT_TYPE_I1:
            case ELEMENT_TYPE_U1:
            case ELEMENT_TYPE_I2:
            case ELEMENT_TYPE_U2:
            case ELEMENT_TYPE_I4:
            case ELEMENT_TYPE_U4:
            case ELEMENT_TYPE_I8:
            case ELEMENT_TYPE_U8:
            case ELEMENT_TYPE_R4:
            case ELEMENT_TYPE_R8:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_TYPEDBYREF:
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_I:
                break;
            case ELEMENT_TYPE_BYREF:  //fallthru
                if(TypeFromToken(tk)==mdtFieldDef) return VLDTR_E_SIG_BYREFINFIELD;
            case ELEMENT_TYPE_PTR:
                // Validate the referenced type.
                if(FAILED(hr = validateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,pImport,FALSE))) return hr;
                break;
            case ELEMENT_TYPE_PINNED:
            case ELEMENT_TYPE_SZARRAY:
                // Validate the referenced type.
                if(FAILED(hr = validateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,pImport,TRUE))) return hr;
                break;
            case ELEMENT_TYPE_CMOD_OPT:
            case ELEMENT_TYPE_CMOD_REQD:
                bRepeat = TRUE; // go on validating, we're not done with this arg
            case ELEMENT_TYPE_VALUETYPE: //fallthru
            case ELEMENT_TYPE_CLASS:
                // See if the token is missing.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSTKN;
                // See if the token is a valid token.
                ulTkSize = CorSigUncompressedDataSize(pbSig);
                token = CorSigUncompressToken(pbSig);
                // Token validation .
                if(pImport)
                {
                    ULONG   rid = RidFromToken(token);
                    ULONG   typ = TypeFromToken(token);
                    ULONG   maxrid = pImport->GetCountWithTokenKind(typ);
                    if(typ == mdtTypeDef) maxrid++;
                    if((rid==0)||(rid > maxrid)) return VLDTR_E_SIG_TKNBAD;
                }
                *pulCurByte += ulTkSize;
                break;

            case ELEMENT_TYPE_FNPTR: 
                // @todo: More function pointer validation?
                // Validate that calling convention is present.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSFPTR;
                // Consume calling convention.
                *pulCurByte += CorSigUncompressedDataSize(pbSig);
                ulCallConv = CorSigUncompressData(pbSig);
                if(((ulCallConv & IMAGE_CEE_CS_CALLCONV_MASK) >= IMAGE_CEE_CS_CALLCONV_MAX) 
                    ||((ulCallConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
                    &&(!(ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS)))) return VLDTR_E_MD_BADCALLINGCONV;

                // Validate that argument count is present.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSFPTRARGCNT;
                // Consume argument count.
                *pulCurByte += CorSigUncompressedDataSize(pbSig);
                ulArgCnt = CorSigUncompressData(pbSig);

                // Validate and consume return type.
                if(FAILED(hr = validateOneArg(tk, pbSig, cbSig, pulCurByte,NULL,pImport,FALSE))) return hr;

                // Validate and consume the arguments.
                while(ulArgCnt--)
                {
                    if(FAILED(hr = validateOneArg(tk, pbSig, cbSig, pulCurByte,NULL,pImport,TRUE))) return hr;
                }
                break;

            case ELEMENT_TYPE_ARRAY:
                // Validate and consume the base type.
                if(FAILED(hr = validateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,pImport,TRUE))) return hr;

                // Validate that the rank is present.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSRANK;
                // Consume the rank.
                *pulCurByte += CorSigUncompressedDataSize(pbSig);
                ulRank = CorSigUncompressData(pbSig);

                // Process the sizes.
                if (ulRank)
                {
                    // Validate that the count of sized-dimensions is specified.
                    _ASSERTE(*pulCurByte <= cbSig);
                    if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSNSIZE;
                    // Consume the count of sized dimensions.
                    *pulCurByte += CorSigUncompressedDataSize(pbSig);
                    ulSizes = CorSigUncompressData(pbSig);

                    // Loop over the sizes.
                    while(ulSizes--)
                    {
                        // Validate the current size.
                        _ASSERTE(*pulCurByte <= cbSig);
                        if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSSIZE;
                        // Consume the current size.
                        *pulCurByte += CorSigUncompressedDataSize(pbSig);
                        CorSigUncompressData(pbSig);
                    }

                    // Validate that the count of lower bounds is specified.
                    _ASSERTE(*pulCurByte <= cbSig);
                    if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSNLBND;
                    // Consume the count of lower bound.
                    *pulCurByte += CorSigUncompressedDataSize(pbSig);
                    ulLbnds = CorSigUncompressData(pbSig);

                    // Loop over the lower bounds.
                    while(ulLbnds--)
                    {
                        // Validate the current lower bound.
                        _ASSERTE(*pulCurByte <= cbSig);
                        if (cbSig == *pulCurByte) return VLDTR_E_SIG_MISSLBND;
                        // Consume the current size.
                        *pulCurByte += CorSigUncompressedDataSize(pbSig);
                        CorSigUncompressData(pbSig);
                    }
                }
                break;
            case ELEMENT_TYPE_SENTINEL: // this case never works because all modifiers are skipped before switch
                if(TypeFromToken(tk) == mdtMethodDef) return VLDTR_E_SIG_SENTINMETHODDEF;
                break;

            default:
                return VLDTR_E_SIG_BADELTYPE;
                break;
        }   // switch (ulElementType)
    } // end while(bRepeat)
    return S_OK;
}   // validateOneArg()

//*****************************************************************************
// This function validates the given Method/Field/Standalone signature.  
//*****************************************************************************
HRESULT validateTokenSig(
    mdToken             tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE     pbSig,                  // [IN] Signature.
    ULONG               cbSig,                  // [IN] Size in bytes of the signature.
    DWORD               dwFlags,                // [IN] Method flags.
    IMDInternalImport*  pImport)               // [IN] Internal MD Import interface ptr
{
    ULONG       ulCurByte = 0;          // Current index into the signature.
    ULONG       ulCallConv;             // Calling convention.
    ULONG       ulArgCount = 1;         // Count of arguments (1 because of the return type)
    ULONG       ulArgIx = 0;            // Starting index of argument (standalone sig: 1)
    ULONG       i;                      // Looping index.
    HRESULT     hr = S_OK;              // Value returned.
    ULONG       ulNSentinels = 0;

    _ASSERTE(TypeFromToken(tk) == mdtMethodDef ||
             TypeFromToken(tk) == mdtMemberRef ||
             TypeFromToken(tk) == mdtSignature ||
             TypeFromToken(tk) == mdtFieldDef);

    // Validate the signature is well-formed with respect to the compression
    // scheme.  If this fails, no further validation needs to be done.
    if ( FAILED(hr = validateSigCompression(tk, pbSig, cbSig))) return hr;

    // Validate the calling convention.
    ulCurByte += CorSigUncompressedDataSize(pbSig);
    ulCallConv = CorSigUncompressData(pbSig);
    i = ulCallConv & IMAGE_CEE_CS_CALLCONV_MASK;
    switch(TypeFromToken(tk))
    {
        case mdtMethodDef: // MemberRefs have no flags available
            // If HASTHIS is set on the calling convention, the method should not be static.
            if ((ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS) &&
                IsMdStatic(dwFlags)) return VLDTR_E_MD_THISSTATIC;

            // If HASTHIS is not set on the calling convention, the method should be static.
            if (!(ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS) &&
                !IsMdStatic(dwFlags)) return VLDTR_E_MD_NOTTHISNOTSTATIC;
            // fall thru to callconv check;

        case mdtMemberRef:
            if(i == IMAGE_CEE_CS_CALLCONV_FIELD) return validateOneArg(tk, pbSig, cbSig, &ulCurByte,NULL,pImport,TRUE);

            // EXPLICITTHIS and native call convs are for stand-alone sigs only (for calli)
            if((i != IMAGE_CEE_CS_CALLCONV_DEFAULT)&&( i != IMAGE_CEE_CS_CALLCONV_VARARG)
                || (ulCallConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)) return VLDTR_E_MD_BADCALLINGCONV;
            break;

        case mdtSignature:
            if(i != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG) // then it is function sig for calli
            {
                if((i >= IMAGE_CEE_CS_CALLCONV_MAX) 
                    ||((ulCallConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
                    &&(!(ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS)))) return VLDTR_E_MD_BADCALLINGCONV;
            }
            else
                ulArgIx = 1;        // Local variable signatures don't have a return type 
            break;

        case mdtFieldDef:
            if(i != IMAGE_CEE_CS_CALLCONV_FIELD) return VLDTR_E_MD_BADCALLINGCONV;
            return validateOneArg(tk, pbSig, cbSig, &ulCurByte,NULL,pImport,TRUE);
    }
    // Is there any sig left for arguments?
    _ASSERTE(ulCurByte <= cbSig);
    if (cbSig == ulCurByte) return VLDTR_E_MD_NOARGCNT;

    // Get the argument count.
    ulCurByte += CorSigUncompressedDataSize(pbSig);
    ulArgCount += CorSigUncompressData(pbSig);

    // Validate the return type and the arguments.
    // (at this moment ulArgCount = num.args+1, ulArgIx = (standalone sig. ? 1 :0); )
    for(; ulArgIx < ulArgCount; ulArgIx++)
    {
        if(FAILED(hr = validateOneArg(tk, pbSig, cbSig, &ulCurByte,&ulNSentinels,pImport, (ulArgIx!=0)))) return hr;
    }
    
    // @todo: we allow junk to be at the end of the signature (we may not consume it all)
    // do we care?

    if((ulNSentinels != 0) && ((ulCallConv & IMAGE_CEE_CS_CALLCONV_MASK) != IMAGE_CEE_CS_CALLCONV_VARARG ))
        return VLDTR_E_SIG_SENTMUSTVARARG;
    if(ulNSentinels > 1) return VLDTR_E_SIG_MULTSENTINELS;
    return S_OK;
}   // validateTokenSig()


CHAR g_VersionBase[] = "v1.";
CHAR g_DevelopmentVersion[] = "x86";
CHAR g_RetString[] = "retail";
CHAR g_ComplusString[] = "COMPLUS";

//*****************************************************************************
// Determine the version number of the runtime that was used to build the
// specified image. The pMetadata pointer passed in is the pointer to the
// metadata contained in the image.
//*****************************************************************************
HRESULT GetImageRuntimeVersionString(PVOID pMetaData, LPCSTR* pString)
{
    _ASSERTE(pString);
    STORAGESIGNATURE* pSig = (STORAGESIGNATURE*) pMetaData;

    // Verify the signature. 

    // If signature didn't match, you shouldn't be here.
    if (pSig->lSignature != STORAGE_MAGIC_SIG)
        return CLDB_E_FILE_CORRUPT;

    // The version started in version 1.1
    if (pSig->iMajorVer < 1)
        return CLDB_E_FILE_OLDVER;

    if (pSig->iMajorVer == 1 && pSig->iMinorVer < 1)
        return CLDB_E_FILE_OLDVER;
    
    // Header data starts after signature.
    *pString = (LPCSTR) pSig->pVersion;
    if(*pString) {
        DWORD lgth = sizeof(g_VersionBase) / sizeof(char) - 1;
        DWORD foundLgth = strlen(*pString);

        // Have normal version, v1.*
        if ( (foundLgth >= lgth+2) &&
             !strncmp(*pString, g_VersionBase, lgth) ) {

            // v1.0.* means RTM
            if ((*pString)[lgth+1] == '.') {
                if ((*pString)[lgth] == '0')
                    *pString = g_RTMVersion;
            }
            
            // Check for dev version (v1.x86ret, v1.x86fstchk...)
            else if(!strncmp(&(*pString)[lgth], g_DevelopmentVersion,
                             (sizeof(g_DevelopmentVersion) / sizeof(char) - 1)))
                *pString = g_RTMVersion;
        }

        // Some weird version...
        else if( (!strcmp(*pString, g_RetString)) ||
                 (!strcmp(*pString, g_ComplusString)) )
            *pString = g_RTMVersion;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\utsem.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/******************************************************************************
	FILE : UTSEM.CPP

	Purpose: Part of the utilities library for the VIPER project

	Abstract : Implements the UTSemReadWrite class.
-------------------------------------------------------------------------------
Revision History:

[0]		06/06/97	JimLyon		Created
*******************************************************************************/
#include "stdafx.h"


#include <UTSem.H>




/******************************************************************************
Static Function : VipInitializeCriticalSectionIgnoreSpinCount

Abstract: Just call InitializeCriticalSection. This routine is used on systems
		  that don't support InitializeCriticalSectionAndSpinCount (Win95, or
		  WinNT prior to NT4.0 SP3)
******************************************************************************/
static BOOL VipInitializeCriticalSectionIgnoreSpinCount (CRITICAL_SECTION* cs, unsigned long lcCount)
{
	InitializeCriticalSection (cs);
	return TRUE;
}



/******************************************************************************
Function : UTSemExclusive::UTSemExclusive

Abstract: Constructor.
******************************************************************************/
CSemExclusive::CSemExclusive (unsigned long ulcSpinCount)
{
	typedef BOOL (*TpInitCSSpin) (CRITICAL_SECTION* cs, unsigned long lcCount);
							// pointer to function with InitializeCriticalSectionAndSpinCount's signature
	static TpInitCSSpin pInitCSSpin = VipInitializeCriticalSectionIgnoreSpinCount;
							// pointer to InitializeCriticalSectionAndSpinCount, or thunk
	static BOOL fInitialized = FALSE;


	if (!fInitialized)
	{
		// this code may be executed by several threads simultaneously, but it's safe
		HMODULE hModule;
		FARPROC pProc;

		OSVERSIONINFOA	osVer ;
		osVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA) ;
		GetVersionExA(&osVer) ;

		// TODO - enable this for Memphis once 
		// InitializeCriticalSectionAndSpinCount works properly
		if (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			hModule = GetModuleHandleA ("KERNEL32.DLL");
			if (hModule != NULL)
			{
				pProc = GetProcAddress (hModule, "InitializeCriticalSectionAndSpinCount");
				if (pProc != NULL)
					pInitCSSpin = (TpInitCSSpin) pProc;
			}
		}

        fInitialized = TRUE;
	}

	(*pInitCSSpin) (&m_csx, ulcSpinCount);

	DEBUG_STMT(m_iLocks = 0);
}


/******************************************************************************
Definitions of the bit fields in UTSemReadWrite::m_dwFlag:

Warning: The code assume that READER_MASK is in the low-order bits of the DWORD.
******************************************************************************/

const unsigned long READERS_MASK      = 0x000003FF;	// field that counts number of readers
const unsigned long READERS_INCR      = 0x00000001;	// amount to add to increment number of readers

// The following field is 2 bits long to make it easier to catch errors.
// (If the number of writers ever exceeds 1, we've got problems.)
const unsigned long WRITERS_MASK      = 0x00000C00;	// field that counts number of writers
const unsigned long WRITERS_INCR      = 0x00000400;	// amount to add to increment number of writers

const unsigned long READWAITERS_MASK  = 0x003FF000;	// field that counts number of threads waiting to read
const unsigned long READWAITERS_INCR  = 0x00001000;	// amount to add to increment number of read waiters

const unsigned long WRITEWAITERS_MASK = 0xFFC00000;	// field that counts number of threads waiting to write
const unsigned long WRITEWAITERS_INCR = 0x00400000;	// amoun to add to increment number of write waiters

/******************************************************************************
Function : UTSemReadWrite::UTSemReadWrite

Abstract: Constructor.
******************************************************************************/
UTSemReadWrite::UTSemReadWrite (unsigned long ulcSpinCount,
		LPCSTR szSemaphoreName, LPCSTR szEventName)
{
	static BOOL fInitialized = FALSE;
	static unsigned long maskMultiProcessor;	// 0 => uniprocessor, all 1 bits => multiprocessor

	if (!fInitialized)
	{
		SYSTEM_INFO SysInfo;

		GetSystemInfo (&SysInfo);
		if (SysInfo.dwNumberOfProcessors > 1)
			maskMultiProcessor = 0xFFFFFFFF;
		else
			maskMultiProcessor = 0;

		fInitialized = TRUE;
	}


	m_ulcSpinCount = ulcSpinCount & maskMultiProcessor;
	m_dwFlag = 0;
	m_hReadWaiterSemaphore = NULL;
	m_hWriteWaiterEvent = NULL;
	m_szSemaphoreName = szSemaphoreName;
	m_szEventName = szEventName;
}


/******************************************************************************
Function : UTSemReadWrite::~UTSemReadWrite

Abstract: Destructor
******************************************************************************/
UTSemReadWrite::~UTSemReadWrite ()
{
	_ASSERTE (m_dwFlag == 0 && "Destroying a UTSemReadWrite while in use");

	if (m_hReadWaiterSemaphore != NULL)
		CloseHandle (m_hReadWaiterSemaphore);

	if (m_hWriteWaiterEvent != NULL)
		CloseHandle (m_hWriteWaiterEvent);
}


/******************************************************************************
Function : UTSemReadWrite::LockRead

Abstract: Obtain a shared lock
******************************************************************************/
void UTSemReadWrite::LockRead ()
{
	unsigned long dwFlag;
	unsigned long ulcLoopCount = 0;


	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag < READERS_MASK)
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag + READERS_INCR, dwFlag))
				break;
		}

		else if ((dwFlag & READERS_MASK) == READERS_MASK)
			Sleep(1000);

		else if ((dwFlag & READWAITERS_MASK) == READWAITERS_MASK)
			Sleep(1000);

		else if (ulcLoopCount++ < m_ulcSpinCount)
			/* nothing */ ;

		else
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag + READWAITERS_INCR, dwFlag))
			{
				WaitForSingleObject (GetReadWaiterSemaphore(), INFINITE);
				break;
			}
		}
	}

	_ASSERTE ((m_dwFlag & READERS_MASK) != 0 && "reader count is zero after acquiring read lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == 0 && "writer count is nonzero after acquiring write lock");
}



/******************************************************************************
Function : UTSemReadWrite::LockWrite

Abstract: Obtain an exclusive lock
******************************************************************************/
void UTSemReadWrite::LockWrite ()
{
	unsigned long dwFlag;
	unsigned long ulcLoopCount = 0;


	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag == 0)
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, WRITERS_INCR, dwFlag))
				break;
		}

		else if ((dwFlag & WRITEWAITERS_MASK) == WRITEWAITERS_MASK)
			Sleep(1000);

		else if (ulcLoopCount++ < m_ulcSpinCount)
			/*nothing*/ ;

		else
		{
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag + WRITEWAITERS_INCR, dwFlag))
			{
				WaitForSingleObject (GetWriteWaiterEvent(), INFINITE);
				break;
			}
		}

	}

	_ASSERTE ((m_dwFlag & READERS_MASK) == 0 && "reader count is nonzero after acquiring write lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == WRITERS_INCR && "writer count is not 1 after acquiring write lock");
}



/******************************************************************************
Function : UTSemReadWrite::UnlockRead

Abstract: Release a shared lock
******************************************************************************/
void UTSemReadWrite::UnlockRead ()
{
	unsigned long dwFlag;


	_ASSERTE ((m_dwFlag & READERS_MASK) != 0 && "reader count is zero before releasing read lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == 0 && "writer count is nonzero before releasing read lock");

	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag == READERS_INCR)
		{		// we're the last reader, and nobody is waiting
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, 0, dwFlag))
				break;
		}

		else if ((dwFlag & READERS_MASK) > READERS_INCR)
		{		// we're not the last reader
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag - READERS_INCR, dwFlag))
				break;
		}

		else
		{
			// here, there should be exactly 1 reader (us), and at least one waiting writer.
			_ASSERTE ((dwFlag & READERS_MASK) == READERS_INCR && "UnlockRead consistency error 1");
			_ASSERTE ((dwFlag & WRITEWAITERS_MASK) != 0 && "UnlockRead consistency error 2");

			// one or more writers is waiting, do one of them next
			// (remove a reader (us), remove a write waiter, add a writer
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag,
					dwFlag - READERS_INCR - WRITEWAITERS_INCR + WRITERS_INCR, dwFlag))
			{
				SetEvent (GetWriteWaiterEvent());
				break;
			}
		}
	}
}


/******************************************************************************
Function : UTSemReadWrite::UnlockWrite

Abstract: Release an exclusive lock
******************************************************************************/
void UTSemReadWrite::UnlockWrite ()
{
	unsigned long dwFlag;
	unsigned long count;


	_ASSERTE ((m_dwFlag & READERS_MASK) == 0 && "reader count is nonzero before releasing write lock");
	_ASSERTE ((m_dwFlag & WRITERS_MASK) == WRITERS_INCR && "writer count is not 1 before releasing write lock");


	for (;;)
	{
		dwFlag = m_dwFlag;

		if (dwFlag == WRITERS_INCR)
		{		// nobody is waiting
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, 0, dwFlag))
				break;
		}

		else if ((dwFlag & READWAITERS_MASK) != 0)
		{		// one or more readers are waiting, do them all next
			count = (dwFlag & READWAITERS_MASK) / READWAITERS_INCR;
			// remove a writer (us), remove all read waiters, turn them into readers
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag,
					dwFlag - WRITERS_INCR - count * READWAITERS_INCR + count * READERS_INCR, dwFlag))
			{
				ReleaseSemaphore (GetReadWaiterSemaphore(), count, NULL);
				break;
			}
		}

		else
		{		// one or more writers is waiting, do one of them next
			_ASSERTE ((dwFlag & WRITEWAITERS_MASK) != 0 && "UnlockWrite consistency error");
				// (remove a writer (us), remove a write waiter, add a writer
			if (dwFlag == VipInterlockedCompareExchange (&m_dwFlag, dwFlag - WRITEWAITERS_INCR, dwFlag))
			{
				SetEvent (GetWriteWaiterEvent());
				break;
			}
		}
	}
}

/******************************************************************************
Function : UTSemReadWrite::GetReadWaiterSemaphore

Abstract: Return the semaphore to use for read waiters
******************************************************************************/
HANDLE UTSemReadWrite::GetReadWaiterSemaphore()
{
	HANDLE h;

	if (m_hReadWaiterSemaphore == NULL)
	{
		h = CreateSemaphoreA (NULL, 0, MAXLONG, m_szSemaphoreName);
		_ASSERTE (h != NULL && "GetReadWaiterSemaphore can't CreateSemaphore");
		if (NULL != VipInterlockedCompareExchange (&m_hReadWaiterSemaphore, h, NULL))
			CloseHandle (h);
	}

	return m_hReadWaiterSemaphore;
}


/******************************************************************************
Function : UTSemReadWrite::GetWriteWaiterEvent

Abstract: Return the semaphore to use for write waiters
******************************************************************************/
HANDLE UTSemReadWrite::GetWriteWaiterEvent()
{
	HANDLE h;

	if (m_hWriteWaiterEvent == NULL)
	{
		h = CreateEventA (NULL, FALSE, FALSE, m_szEventName);	// auto-reset event
		_ASSERTE (h != NULL && "GetWriteWaiterEvent can't CreateEvent");
		if (NULL != VipInterlockedCompareExchange (&m_hWriteWaiterEvent, h, NULL))
			CloseHandle (h);
	}

	return m_hWriteWaiterEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\utilcode\wsperf.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "stdafx.h"
#include "wsperf.h"

#if defined(ENABLE_WORKING_SET_PERF)
//-----------------------------------------------------------------------------
// All non trivial code in here. Look below for the #else part...
#ifdef WS_PERF

// Global Handle to the perf log file
HANDLE g_hWSPerfLogFile = 0;

// Global Handle to the detailed perf log file
#ifdef WS_PERF_DETAIL
HANDLE g_hWSPerfDetailLogFile = 0;
#endif

// Runtime switch to display the stats. Ofcourse this is valid only if WS_PERF was defined 
// during compilation
int g_fWSPerfOn = 0;


// Temp space to work for formatting the output.
static const int FMT_STR_SIZE = 160;
wchar_t wszOutStr[FMT_STR_SIZE];    
char szPrintStr[FMT_STR_SIZE];    
DWORD dwWriteByte;   


//-----------------------------------------------------------------------------
// LoaderHeap stats related declarations
// Maximum number of LoaderHeaps that we maintain stats about. Note that this is not
// the heaps that are enumed by HeapTypeEnum. 
const int MAX_HEAPS = 20; 

// The number of such heaps that we actually encounter. This is incremented
// as we construct more Loaderheap objects.
DWORD g_HeapCount = 0;

// Allocate static mem for the Loaderheap stats array. Initialize the data to 0.
size_t g_HeapCountCommit[NUM_HEAP] = {0};

// Keep track of committed, reserved, wasted memory for each heap type.
size_t g_HeapAccounts[MAX_HEAPS][4];

//Initialize the heap type to OTHER_HEAP
HeapTypeEnum g_HeapType=OTHER_HEAP;

//-----------------------------------------------------------------------------
// Common data structures stats related declarations (Special counters)

// Number of fields of data maintained for the common data structs e.g. MethodDesc
#define NUM_FIELDS 2

// Allocate static mem for these special counters and init them to 0.
size_t g_SpecialCounter[NUM_COUNTERS][NUM_FIELDS] = {0};

// @TODO:agk clean up.
// Size Of
//    METHOD_DESC, -> 8
//    COMPLUS_METHOD_DESC, -> 48
//    NDIRECT_METHOD_DESC, ->32
//    FIELD_DESC, -> 12
//    METHOD_TABLE, -> 48
//    VTABLES, 
//    GCINFO,
//    INTERFACE_MAPS,
//    STATIC_FIELDS,
//    EECLASSHASH_TABLE_BYTES,
//    EECLASSHASH_TABLE, -> 16
// HACK: Keep in the same order as CounterTypeEnum defined in wsperf.h
// hlepful in doing calculations before displaying data.
DWORD g_CounterSize[] = {8, 48, 32, 12, 48, 0, 0, 0, 0, 0, 16};

// Private helper routine
void UpdateWSPerfStats(size_t size)
{
    if(g_fWSPerfOn)
    {
        g_HeapCountCommit[g_HeapType] += size;                  
        g_HeapCount += size;
    }
}

// Private helper routine
void WS_PERF_OUTPUT_MEM_STATS()
{
    if (g_fWSPerfOn)
    {
        for (int i=0; i<NUM_HEAP; i++)                          
        {                                                       
            swprintf(wszOutStr, L"\n%d;%d\t", i, g_HeapCountCommit[i]); 
            //TODO can be done outside the loop.
            WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
            WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
        }
    
        swprintf(wszOutStr, L"\n\nTotal:%d\n", g_HeapCount); 
        WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
        WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   

        swprintf(wszOutStr, L"\n\nDetails:\nIndex;HeapType;NumVal;Alloced(bytes)\n"); 
        WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
        WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
        
        for (i=0; i<NUM_COUNTERS; i++)                          
        {                                                       
            swprintf(wszOutStr, L"\n%d;%d;%d;%d\t", i, g_SpecialCounter[i][0], g_SpecialCounter[i][1], g_SpecialCounter[i][1]*g_CounterSize[i]); 
            WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
            WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
        }
    }
}

// Private helper routine
void WS_PERF_OUTPUT_HEAP_ACCOUNTS() 
{
    if(g_fWSPerfOn)
    {
        int i = 0, dwAlloc = 0, dwCommit = 0;
        
        swprintf(wszOutStr, L"Heap\t\tHptr\t\tAlloc\t\tCommit\t\tWaste\n"); 
        WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
        WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
        while (i<MAX_HEAPS)
        {
            if(g_HeapAccounts[i][1] == -1)
                break;
            swprintf(wszOutStr, L"%d\t\t0x%08x\t%d\t\t%d\t\t%d\n", g_HeapAccounts[i][0], g_HeapAccounts[i][1], g_HeapAccounts[i][2], g_HeapAccounts[i][3], g_HeapAccounts[i][3] - g_HeapAccounts[i][2]);
            WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
            WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
            dwAlloc += g_HeapAccounts[i][2];
            dwCommit += g_HeapAccounts[i][3];
            i++;
        }
        swprintf(wszOutStr, L"Total\t\t\t\t%d\t\t%d\t\t%d\n", dwAlloc, dwCommit, dwCommit - dwAlloc);
        WszWideCharToMultiByte (CP_ACP, 0, wszOutStr, -1, szPrintStr, FMT_STR_SIZE-1, 0, 0);                    
        WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
    }
}

// public interface routine
void InitWSPerf()
{
    wchar_t lpszValue[2];
    DWORD cchValue = 2;

#ifdef _WS_PERF_OUTPUT
    g_fWSPerfOn = WszGetEnvironmentVariable (L"WS_PERF_OUTPUT", lpszValue, cchValue);
    if (g_fWSPerfOn)
    {
        g_hWSPerfLogFile = WszCreateFile (L"WSPerf.log",
                                          GENERIC_WRITE,
                                          0,    
                                          0,
                                          CREATE_ALWAYS,
                                          FILE_ATTRIBUTE_NORMAL,
                                          0);

        if (g_hWSPerfLogFile == INVALID_HANDLE_VALUE) 
            g_fWSPerfOn = 0;
        
#ifdef WS_PERF_DETAIL
        g_hWSPerfDetailLogFile = WszCreateFile (L"WSPerfDetail.log",
                                          GENERIC_WRITE,
                                          0,    
                                          0,
                                          CREATE_ALWAYS,
                                          FILE_ATTRIBUTE_NORMAL,
                                          0);

        if (g_hWSPerfDetailLogFile == INVALID_HANDLE_VALUE) 
            g_fWSPerfOn = 0;
#endif
        g_HeapAccounts[0][1] = -1; //null list
    
        sprintf(szPrintStr, "HPtr\t\tPage Range\t\tReserved Size\n");
        WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
    }
#endif
}

// public interface routine
void OutputWSPerfStats()
{
    if (g_fWSPerfOn)
    {
        WS_PERF_OUTPUT_HEAP_ACCOUNTS();
        WS_PERF_OUTPUT_MEM_STATS();
        CloseHandle(g_hWSPerfLogFile);
#ifdef WS_PERF_DETAIL
        CloseHandle(g_hWSPerfDetailLogFile);
#endif
    }
}


// public interface routine
void WS_PERF_UPDATE(char *str, size_t size, void *addr)    
{                                                               
    if (g_fWSPerfOn)                                            
    {                                                           
#ifdef WS_PERF_DETAIL
        sprintf(szPrintStr, "C;%d;%s;0x%0x;%d;0x%0x\n", g_HeapType, str, size, size, addr);
        WriteFile (g_hWSPerfDetailLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
#endif // WS_PERF_DETAIL

        UpdateWSPerfStats(size);                                
    }                                                           
}

// public interface routine
void WS_PERF_UPDATE_DETAIL(char *str, size_t size, void *addr)    
{
#ifdef WS_PERF_DETAIL
    if(g_fWSPerfOn)
    {
        sprintf(szPrintStr, "D;%d;%s;0x%0x;%d;0x%0x\n", g_HeapType, str, size, size, addr);
        WriteFile (g_hWSPerfDetailLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
    }

#endif //WS_PERF_DETAIL
}

// public interface routine
void WS_PERF_UPDATE_COUNTER(CounterTypeEnum counter, HeapTypeEnum heap, DWORD dwField1)
{
    if (g_fWSPerfOn)
    {
        g_SpecialCounter[counter][0] = (size_t)heap;
        g_SpecialCounter[counter][1] += dwField1;
    }
}

// public interface routine
void WS_PERF_SET_HEAP(HeapTypeEnum heap)
{                                 
    g_HeapType = heap;            
}
 
// public interface routine
void WS_PERF_ADD_HEAP(HeapTypeEnum heap, void *pHeap)
{
    if (g_fWSPerfOn)
    {
        int i=0;
        while (i<MAX_HEAPS)
        {
            if (g_HeapAccounts[i][1] == -1)
                break;
            i++;
        }
        if (i != MAX_HEAPS)
        {
            g_HeapAccounts[i][0] = (size_t)heap;
            g_HeapAccounts[i][1] = (size_t)pHeap;
            g_HeapAccounts[i][2] = 0;
            g_HeapAccounts[i][3] = 0;
            if (i != MAX_HEAPS - 1)
            {
                g_HeapAccounts[i+1][1] = -1;
            }
        }
    }
}

// public interface routine
void WS_PERF_ALLOC_HEAP(void *pHeap, size_t dwSize)
{
    if(g_fWSPerfOn)
    {
        int i = 0;
        while (i<MAX_HEAPS)
        {
            if (g_HeapAccounts[i][1] == (size_t)pHeap) 
            {
                g_HeapAccounts[i][2] += dwSize;
                break;
            }
            i++;
        }
    }
}

// public interface routine
void WS_PERF_COMMIT_HEAP(void *pHeap, size_t dwSize)
{
    if(g_fWSPerfOn)
    {
        int i = 0;
        while (i<MAX_HEAPS)
        {
            if (g_HeapAccounts[i][1] == (size_t)pHeap) 
            {
                g_HeapAccounts[i][3] += dwSize;
                break;
            }
            i++;
        }
    }
}

void WS_PERF_LOG_PAGE_RANGE(void *pHeap, void *pFirstPageAddr, void *pLastPageAddr, size_t dwsize)
{
    if (g_fWSPerfOn)                                            
    {                                                           
        sprintf(szPrintStr, "0x%08x\t0x%08x->0x%08x\t%d\n", pHeap, pFirstPageAddr, pLastPageAddr, dwsize);
        WriteFile (g_hWSPerfLogFile, szPrintStr, strlen(szPrintStr), &dwWriteByte, NULL);   
    }
}

#else //WS_PERF

//-----------------------------------------------------------------------------
// If WS_PERF is not defined then define these as empty and hope that the 
// compiler would optimize it away.

void InitWSPerf() {}
void OutputWSPerfStats() {}
void WS_PERF_UPDATE(char *str, size_t size, void *addr)  {}
void WS_PERF_UPDATE_DETAIL(char *str, size_t size, void *addr)    {}
void WS_PERF_UPDATE_COUNTER(CounterTypeEnum counter, HeapTypeEnum heap, DWORD dwField1) {}
void WS_PERF_SET_HEAP(HeapTypeEnum heap) {}
void WS_PERF_ADD_HEAP(HeapTypeEnum heap, void *pHeap) {}
void WS_PERF_ALLOC_HEAP(void *pHeap, size_t dwSize) {}
void WS_PERF_COMMIT_HEAP(void *pHeap, size_t dwSize) {}
void WS_PERF_LOG_PAGE_RANGE(void *pHeap, void *pFirstPageAddr, void *pLastPageAddr, size_t dwsize) {}

#endif //WS_PERF

#else

// This duplication is needed to fix GOLDEN build break
void InitWSPerf() {}
void OutputWSPerfStats() {}
void WS_PERF_UPDATE(char *str, size_t size, void *addr)  {}
void WS_PERF_UPDATE_DETAIL(char *str, size_t size, void *addr)    {}
void WS_PERF_UPDATE_COUNTER(CounterTypeEnum counter, HeapTypeEnum heap, DWORD dwField1) {}
void WS_PERF_SET_HEAP(HeapTypeEnum heap) {}
void WS_PERF_ADD_HEAP(HeapTypeEnum heap, void *pHeap) {}
void WS_PERF_ALLOC_HEAP(void *pHeap, size_t dwSize) {}
void WS_PERF_COMMIT_HEAP(void *pHeap, size_t dwSize) {}
void WS_PERF_LOG_PAGE_RANGE(void *pHeap, void *pFirstPageAddr, void *pLastPageAddr, size_t dwsize) {}

#endif //#if defined(ENABLE_WORKING_SET_PERF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vbhelper\vbhelper.asm ===
; ==++==
; 
;   Copyright (c) Microsoft Corporation.  All rights reserved.
; 
; ==--==
.namespace System
.class VBHelper

######################################################################
#This method will take in a RefAny and return a Variant...

.staticmethod value class System.Variant TypedByRefToVariant(refany)
.localsSig(value class System.Variant)

	ldloca		0x0
 	ldarga		0x1				 
	call	 	void System.Variant::TypedByRefToVariant(value class System.Variant&, int32)
	ldloc		0x0
	ret
.endmethod

######################################################################
# old style version.  Remove after 7/30/99

.staticmethod void TypedByRefToVariant(value class System.Variant&, refany)
	ldarg		0x0
 	ldarga		0x1				 
	call	 	void System.Variant::TypedByRefToVariant(value class System.Variant&, int32)
	ret
.endmethod


######################################################################
.staticmethod void VariantToTypedByRef(refany, value class System.Variant)
	ldarga		0x0
	ldarga		0x1
	ldobj		System.Variant
	call		void System.Variant::VariantToTypedByRef(int32,value class System.Variant)
	ret
.endmethod

.end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vbhelper\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "VBHELPER.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Visual BASIC Helper Library\0"
#define VER_ORIGFILENAME_STR    "VBHelper.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\apartmentcallbackhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Helper class used to transition between apartments
**          on platforms that do not support contexts.
**  
**      //  %%Created by: dmortens
===========================================================*/

#ifndef _APARTMENTCALLBACKHELPER_H
#define _APARTMENTCALLBACKHELPER_H

#include "vars.hpp"

//==============================================================
// Apartment callback class used on non legacy platforms to 
// simulate IContextCallback::DoCallback().
class ApartmentCallbackHelper : IApartmentCallback
{
public:
    // Constructor.
    ApartmentCallbackHelper()
    : m_dwRefCount(0)
    {
    }

    // Destructor.
    ~ApartmentCallbackHelper()
    {
    }

    // IUnknown methods.
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID *ppUnk)
    {
	    *ppUnk = NULL;

	    if (riid == IID_IUnknown)
		    *ppUnk = (IUnknown *)this;
	    else if (riid == IID_IApartmentCallback)
    		*ppUnk = (IUnknown *) (IApartmentCallback *) this;
        else
		    return E_NOINTERFACE;

	    AddRef();

	    return S_OK;
    }

    ULONG   STDMETHODCALLTYPE AddRef()
    {
        return FastInterlockIncrement((LONG *)&m_dwRefCount);
    }

    ULONG   STDMETHODCALLTYPE Release()
    {
        _ASSERTE(m_dwRefCount > 0);
        ULONG cbRef = FastInterlockDecrement((LONG *)&m_dwRefCount);
        if (cbRef == 0)
            delete this;

        return cbRef;
    }

    // IApartmentCallback method.
    HRESULT STDMETHODCALLTYPE DoCallback(SIZE_T pFunc, SIZE_T pData)
    {
        return ((PFNCONTEXTCALL)pFunc)((ComCallData *)pData);
    }

    // Static factory method.
    static void CreateInstance(IUnknown **ppUnk)
    {
        ApartmentCallbackHelper *pCallbackHelper = new (throws) ApartmentCallbackHelper();
        *ppUnk = (IUnknown*)pCallbackHelper;
        pCallbackHelper->AddRef();
    }

private:
    // Ref count.
    DWORD m_dwRefCount;
};

#endif _APARTMENTCALLBACKHELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vbhelper\makefile.inc ===
# 
# Makefile include stuff for VBHelper
#

# If one of these commands fails, notice it.
!CMDSWITCHES -I

$(O)\VBHelper.res: VBHelper.rc
	@set include=$(INCPATHRC)
		rc -l 409 -z "MS Sans Serif,Helv/MS Shell Dlg" -r -fo $(O)\VBHelper.res -D_X86_=1 -Di386=1 -DSTD_CALL -DCONDITION_HANDLING=1 -DNT_UP=1 -DNT_INST=0 -DWIN32=100 -D_NT1X_=100 -DWINNT=1 -D_WIN32_WINNT=0x0400 -DWINVER=0x0400 -D_WIN32_IE=0x0400 -DWIN32_LEAN_AND_MEAN=1 -DDBG=1 -DDEVL=1 -DFPO=0 -D_DEBUG -D_DLL=1 -D_MT=1 -DNTMAKEENV -D_DEBUG  VBHelper.rc
	@set include=

$(TARGETNAME): VBHelper.il $(O)\VBHelper.res ..\inc\opcode.def
	ilasm /RES=$(O)\VBHelper.res /DLL VBHelper.il
	copy VBHelper.dll $(TARGETNAME)
	-del VBHelper.dll

!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETNAME) $(TARGETCOMPLUS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomain.inl ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AppDomain.i
**
** Purpose: Implements AppDomain (loader domain) architecture
** inline functions
**
** Date:  June 27, 2000
**
===========================================================*/
#ifndef _APPDOMAIN_I
#define _APPDOMAIN_I

#include "appdomain.hpp"

inline void AppDomain::SetUnloadInProgress()
{
    SystemDomain::System()->SetUnloadInProgress(this);
}

inline void AppDomain::SetUnloadComplete()
{
    SystemDomain::System()->SetUnloadComplete();
}


#endif _APPDOMAIN_I
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomain.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AppDomain.cpp
**
** Purpose: Implements AppDomain (loader domain) architecture
**
** Date:  Dec 1, 1998
**
===========================================================*/
#ifndef _APPDOMAIN_H
#define _APPDOMAIN_H

#include "Assembly.hpp"
#include "clsload.hpp"
#include "EEHash.h"
#ifdef FUSION_SUPPORTED
#include "fusion.h"
#endif // FUSION_SUPPORTED
#include "arraylist.h"
#include "COMReflectionCache.hpp"
#include "COMReflectionCommon.h"
#include <member-offset-info.h>


class BaseDomain;
class SystemDomain;
class AppDomain;
class AppDomainEnum;
class SecurityDescriptor;
class ApplicationSecurityDescriptor;
class AssemblySink;
class EEMarshalingData;
class ComCallWrapperCache;
struct SimpleComCallWrapper;
class Context;
class GlobalStringLiteralMap;
class AppDomainStringLiteralMap;
struct SecurityContext;
class MngStdInterfacesInfo;
class ComCallMLStubCache;
class ArgBasedStubCache;


#pragma warning(push)
#pragma warning(disable : 4200) // Disable zero-sized array warning


struct DomainLocalClass
{
    BYTE            statics[0];

    BYTE *GetStaticSpace() 
    { 
        return statics; 
    }

    static SIZE_T GetOffsetOfStatics() { return offsetof(DomainLocalClass, statics); }

};

class DomainLocalBlock
{
  friend struct MEMBER_OFFSET_INFO(DomainLocalBlock);

  private:
    AppDomain        *m_pDomain;
    SIZE_T            m_cSlots;
    SIZE_T           *m_pSlots;

  public: // used by code generators

    static SIZE_T GetOffsetOfSlotsPointer() { return offsetof(DomainLocalBlock, m_pSlots); }
    static SIZE_T GetOffsetOfSlotsCount() { return offsetof(DomainLocalBlock, m_cSlots); }

    enum
    {
        INITIALIZED_FLAG_BIT    = 0,
        INITIALIZED_FLAG        = 1<<INITIALIZED_FLAG_BIT,
        ERROR_FLAG_BIT          = 1,
        ERROR_FLAG              = 1<<ERROR_FLAG_BIT,
        MASK                    = ~(INITIALIZED_FLAG|ERROR_FLAG),
    };

  private:
        
    // 
    // Low level routines to get & set class entries
    //

    DomainLocalClass *AllocateClass(MethodTable *pClass);

    DomainLocalClass *GetRawClass(SIZE_T ID)
    {
        _ASSERTE(m_cSlots > ID);
        _ASSERTE(GetClass(ID) == (DomainLocalClass *) m_pSlots[ID]);

        return (DomainLocalClass *) (m_pSlots[ID]);
    }

    inline void SetClass(SIZE_T ID, DomainLocalClass *pLocalClass);

    void EnsureMaxIndex ();

  public:

    DomainLocalBlock()
      : m_pDomain(NULL), m_cSlots(0), m_pSlots(NULL) {}

    void Init(AppDomain *pDomain) { m_pDomain = pDomain; }

    void EnsureIndex(SIZE_T index);
    HRESULT SafeEnsureIndex(SIZE_T index);

    //
    // Low level accessors.
    //

    SIZE_T GetClassCount() 
    { 
        return m_cSlots; 
    }

    DomainLocalClass *GetClass(SIZE_T ID)
    {
        _ASSERTE(m_cSlots > ID);
        return (DomainLocalClass *) (m_pSlots[ID] & MASK);
    }

    BOOL IsClassInitialized(SIZE_T ID)
    {
        EnsureIndex(ID);
        _ASSERTE(m_cSlots > ID);
        return (m_pSlots[ID] & INITIALIZED_FLAG) != 0;
    }

    BOOL IsClassInitError(SIZE_T ID)
    {
        _ASSERTE(m_cSlots > ID);
        return (m_pSlots[ID] & ERROR_FLAG) != 0;
    }

    void SetClassInitialized(SIZE_T ID);

    void SetClassInitError(SIZE_T ID);

    //
    // PopulateClass: use this method to access domain local class which has 
    // not necessarily been properly initialized.  Guaranteed to return valid
    // space or throw.
    //

    DomainLocalClass *PopulateClass(MethodTable *pMT);
    void PopulateClass(MethodTable *pMT, DomainLocalClass *pData);

    //
    // GetInitializedClass: use this to get space when you know that it's been
    // properly initialized.
    //

    DomainLocalClass *GetInitializedClass(SIZE_T ID)
    {
        _ASSERTE(m_cSlots > ID);
        _ASSERTE(IsClassInitialized(ID) && !IsClassInitError(ID));

        return GetClass(ID); 
    }

    //
    // FetchClass: High level routine to get initialized domain local class.
    // This will allocate & trigger .cctors if necessary.
    //

    DomainLocalClass *FetchClass(MethodTable *pClass);

    //
    // Routine to access non-class related DLS slots
    //

    void *GetSlot(SIZE_T index) 
    {
        if (m_cSlots <= index)
            EnsureIndex (index);

        return (void *) m_pSlots[index]; 
    }

    void SetSlot(SIZE_T index, void *value);
};

// This structure is embedded inside each AppDomain.
class InterfaceVTableMapMgr
{
    public:
    // Marks the interface map as the shared interface map.  The shared
    // map uses a different range of IDs than the other maps.
    void SetShared();

    // Each interface is assigned a unique (within the appdomain)
    // integer id. This method hands out new ids.
    //
    // Returns -1 if no more id's available. Note that each id
    // takes up a slot in the global table used to resolve COM wrapper
    // interface invokes, so there is really is a hard limit.
    UINT32 AllocInterfaceId();

    // Ensures the interface id is allocated mapped in the array. If not 
    // the memory is mapped.
    // @TODO: CTS, remove when the JIT handles the shared interface
    //    table
    UINT32 EnsureInterfaceId(UINT res);

    // Creates and returns a pointer to an array whose index corresponds
    // to interface ids. If the class in question implements an interface,
    // the corresponding element points to the start of the methodtable
    // for that interface. Otherwise, the corresponding element is *undefined*
    // (because we will attempt to overlap tables to minimize memory space,
    // it probably won't be NULL!)
    //
    // This function may fail and return NULL, due to lack of resources.
    LPVOID *GetInterfaceVTableMap(const InterfaceInfo_t *pInterfaceInfo, const MethodTable *pMethodTableStart, DWORD numInterfaces);

    // One-time init
    HRESULT Init(BYTE * initReservedMem, DWORD initReservedMemSize);

    // Cleanup
    VOID Terminate();

    // We can this pointer out with impunity since it can never move.
    LPVOID * GetAddrOfGlobalTableForComWrappers()
    {
        return m_pGlobalTableForComWrappers;
    }


    private:

    // Maps in the array. If the index is beyond the available memory
    // -1 is returned. The Interface critical section must be held
    // prior to calling this routine.
    UINT32 GrowInterfaceArray(UINT res);

    Crst   *m_pInterfaceVTableMapMgrCrst;
    LoaderHeap *m_pInterfaceVTableMapHeap;
    UINT32  m_nextInterfaceId;

    // @TODO: CTS, remove when the JIT handles the shared interface
    //    table
    UINT32  m_dwHighestId; // Next page to be allocated

    // One big common table for COM+ wrappers. This grows to have as
    // many entries as the number of id's handed out.
    LPVOID *m_pGlobalTableForComWrappers;

    enum
    {
        SHARED_MAP = 0x1,

        // # of pages to reserve for m_pGlobalTableForComWrappers.
        //
        // This number imposes a hard limit on the # of unique interfaces
        // that can be loaded into an appdomain. For a 32-bit intel (4K page),
        // each page holds entries for 1024 interfaces.
        //
        // Raising this number increases the amount of contiguous addresses
        // needed by each appdomain on startup. Memory is committed only
        // an as-needed basis.
        kNumPagesAllocedForGlobalTable = 16,
    };


    DWORD m_dwFlag;
    struct MapHeader
    {
        MapHeader *m_pNext;
        UINT       m_numSlots;
        UINT       m_firstFreeSlot;
        LPVOID     m_slotTab[];
    };

    MapHeader *m_pFirstMap;
};


#pragma warning(pop)

// The large heap handle bucket class is used to contain handles allocated
// from an array contained in the large heap.
class LargeHeapHandleBucket
{
public:
    // Constructor and desctructor.
    LargeHeapHandleBucket(LargeHeapHandleBucket *pNext, DWORD Size, BaseDomain *pDomain);
    ~LargeHeapHandleBucket();

    // This returns the next bucket.
    LargeHeapHandleBucket *GetNext()
    {
        return m_pNext;
    }

    // This returns the number of remaining handle slots.
    DWORD GetNumRemainingHandles()
    {
        return m_ArraySize - m_CurrentPos;
    }

    // Allocate handles from the bucket.
    void AllocateHandles(DWORD nRequested, OBJECTREF **apObjRefs);

private:
    LargeHeapHandleBucket *m_pNext;
    int m_ArraySize;
    int m_CurrentPos;
    OBJECTHANDLE m_hndHandleArray;
    OBJECTREF *m_pArrayDataPtr;
};


// Entry in the list of available object handles.
struct LargeHeapAvailableHandleEntry
{
    LargeHeapAvailableHandleEntry(OBJECTREF *pObjRef) 
    : m_pObjRef(pObjRef) 
    {
    }

    SLink m_link;
    OBJECTREF *m_pObjRef;
};


// Typedef for the singly linked list of available handle entries.
typedef SList<LargeHeapAvailableHandleEntry, offsetof(LargeHeapAvailableHandleEntry, m_link), true> LARGEHEAPAVAILABLEHANDLEENTRYLIST;   


// The large heap handle table is used to allocate handles that are pointers 
// to objects stored in an array in the large object heap.
class LargeHeapHandleTable
{
public:
    // Constructor and desctructor.
    LargeHeapHandleTable(BaseDomain *pDomain, DWORD BucketSize);
    ~LargeHeapHandleTable();

    // Allocate handles from the large heap handle table.
    void AllocateHandles(DWORD nRequested, OBJECTREF **apObjRefs);   

    // Release object handles allocated using AllocateHandles().
    void ReleaseHandles(DWORD nReleased, OBJECTREF **apObjRefs);

private:
    // The buckets of object handles.
    LargeHeapHandleBucket *m_pHead;

    // The list of object handle's that have been released and are available for reuse.
    LARGEHEAPAVAILABLEHANDLEENTRYLIST m_AvailableHandleList;

    // We need to know the containing domain so we know where to allocate handles
    BaseDomain *m_pDomain;

    // The size of the LargeHeapHandleBuckets.
    DWORD m_BucketSize;
};


//--------------------------------------------------------------------------------------
// Base class for domains. It provides an abstract way of finding the first assembly and
// for creating assemblies in the the domain. The system domain only has one assembly, it
// contains the classes that are logically shared between domains. All other domains can
// have multiple assemblies. Iteration is done be getting the first assembly and then
// calling the Next() method on the assembly.
//
// The system domain should be as small as possible, it includes object, exceptions, etc. 
// which are the basic classes required to load other assemblies. All other classes
// should be loaded into the domain. Of coarse there is a trade off between loading the
// same classes multiple times, requiring all domains to load certain assemblies (working
// set) and being able to specify specific versions.
//

#define LOW_FREQUENCY_HEAP_RESERVE_SIZE 8192
#define LOW_FREQUENCY_HEAP_COMMIT_SIZE  4096

#define HIGH_FREQUENCY_HEAP_RESERVE_SIZE 32768
#define HIGH_FREQUENCY_HEAP_COMMIT_SIZE   4096

#define STUB_HEAP_RESERVE_SIZE 8192
#define STUB_HEAP_COMMIT_SIZE  4096

#define INTERFACE_VTABLE_MAP_MGR_RESERVE_SIZE 4096
#define INTERFACE_VTABLE_MAP_MGR_COMMIT_SIZE 4096

struct CreateDynamicAssemblyArgs
{
    DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
    DECLARE_ECALL_OBJECTREF_ARG(INT32, access);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, refusedPset);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, optionalPset);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, requiredPset);
    DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
    DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, identity);
    DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYNAMEREF, assemblyName);
};

struct LoadingAssemblyRecord
{
    const BYTE              *pBase;
    Assembly                *pAssembly;     
    LoadingAssemblyRecord   *pNext;
};

class AssemblyLockedListElement: public DeadlockAwareLockedListElement
{
    Assembly* m_pAssembly;
public:
    Assembly* GetAssembly()
    {
        return m_pAssembly;
    }

    void SetAssembly(Assembly* pAssembly)
    {
        m_pAssembly = pAssembly;
    }
};

class BaseDomain
{
    friend Assembly;
    friend AssemblySpec;
    friend AppDomain;
    friend AppDomainNative;
    friend struct MEMBER_OFFSET_INFO(BaseDomain);


public:   

    enum SharePolicy
    {
        // Attributes to control when to use domain neutral assemblies
        SHARE_POLICY_UNSPECIFIED,
        SHARE_POLICY_NEVER,
        SHARE_POLICY_ALWAYS,
        SHARE_POLICY_STRONG_NAMED,
        
        SHARE_POLICY_COUNT,
        SHARE_POLICY_MASK = 0x3,
        SHARE_POLICY_DEFAULT = SHARE_POLICY_NEVER,

        SHARE_DEFAULT_DISALLOW_BINDINGS = 4,
        SHARE_DEFAULT_FLAG_MASK = 0xC
    };

    class AssemblyIterator;
    friend AssemblyIterator;

    //****************************************************************************************
    // 
    // Initialization/shutdown routines for every instance of an BaseDomain.

    HRESULT Init();
    void Stop();
    void Terminate();

    void ShutdownAssemblies();

    virtual BOOL IsAppDomain() { return FALSE; }
    virtual BOOL IsSharedDomain() { return FALSE; }
    
    //****************************************************************************************
    //
    // Create a quick lookup for classes loaded into this domain based on their GUID. 
    // 
    PtrHashMap* GetGuidHashMap()
    {
        return &m_clsidHash;
    }
    void InsertClassForCLSID(EEClass* pClass, BOOL fForceInsert = FALSE);
    EEClass* LookupClass(REFIID iid);

    EEClass* LookupClassDirect(REFIID iid)
    {
        EEClass *pClass = (EEClass*) m_clsidHash.LookupValue((UPTR) GetKeyFromGUID(&iid), (LPVOID)&iid);
        return (pClass == (EEClass*) INVALIDENTRY
            ? NULL
            : pClass);
    }

    //@todo get a better key
    ULONG GetKeyFromGUID(const GUID *pguid)
    {
        ULONG key = *(ULONG *) pguid;

        if (key <= DELETED)
            key = DELETED+1;

        return key;
    }

    //****************************************************************************************
    // For in-place new()
    LoaderHeap* GetLowFrequencyHeap()
    {
        return m_pLowFrequencyHeap;
    }

    LoaderHeap* GetHighFrequencyHeap()
    {
        return m_pHighFrequencyHeap;
    }

    LoaderHeap* GetStubHeap()
    {
        return m_pStubHeap;
    }

    // We will use the LowFrequencyHeap for reflection purpose.  Reflection is based on EEClass
    // which sits on LowFrequencyHeap.
    LoaderHeap* GetReflectionHeap()
    {
        return m_pLowFrequencyHeap;
    }

    InterfaceVTableMapMgr & GetInterfaceVTableMapMgr()
    {
        return m_InterfaceVTableMapMgr;
    }

    MngStdInterfacesInfo *GetMngStdInterfacesInfo()
    {
        return m_pMngStdInterfacesInfo;
    }

    static void SetStrongAssemblyStatus();
    static BOOL GetStrongAssemblyStatus()
    {
        return m_fStrongAssemblyStatus;
    }

    // NOTE!  This will not check the internal modules of the assembly
    // for private types.
    TypeHandle FindAssemblyQualifiedTypeHandle(LPCUTF8 szAssemblyQualifiedName, 
                                               BOOL fPublicTypeOnly,
                                               Assembly *pCallingAssembly,
                                               BOOL *pfNameIsAsmQualified,
                                               OBJECTREF *pThrowable = NULL);


    //****************************************************************************************
    // This method returns marshaling data that the EE uses that is stored on a per app domain
    // basis.
    EEMarshalingData *GetMarshalingData();

    //****************************************************************************************
    // Methods to retrieve a pointer to the COM+ string STRINGREF for a string constant.
    // If the string is not currently in the hash table it will be added and if the 
    // copy string flag is set then the string will be copied before it is inserted.
    STRINGREF *GetStringObjRefPtrFromUnicodeString(EEStringData *pStringData);

    //****************************************************************************************
    // Synchronization methods.
    void EnterLock()
    {
        _ASSERTE(m_pDomainCrst);
        BEGIN_ENSURE_PREEMPTIVE_GC();
        m_pDomainCrst->Enter();
        END_ENSURE_PREEMPTIVE_GC();
    }

    void LeaveLock()
    {
        _ASSERTE(m_pDomainCrst);
        m_pDomainCrst->Leave();
    }

    void EnterCacheLock()
    {
        _ASSERTE(m_pDomainCacheCrst);
        BEGIN_ENSURE_PREEMPTIVE_GC();
        m_pDomainCacheCrst->Enter();
        END_ENSURE_PREEMPTIVE_GC();
    }

    void LeaveCacheLock()
    {
        _ASSERTE(m_pDomainCacheCrst);
        m_pDomainCacheCrst->Leave();
    }

    void EnterLoadLock()
    {
        _ASSERTE(m_AssemblyLoadLock.IsInitialized());
        m_AssemblyLoadLock.Enter();

    }

    void LeaveLoadLock()
    {
        _ASSERTE(m_AssemblyLoadLock.IsInitialized());
        m_AssemblyLoadLock.Leave();
    }

    void EnterDomainLocalBlockLock()
    {
        _ASSERTE(m_pDomainLocalBlockCrst);
        BEGIN_ENSURE_PREEMPTIVE_GC();
        m_pDomainLocalBlockCrst->Enter();
        END_ENSURE_PREEMPTIVE_GC();
    }

    void LeaveDomainLocalBlockLock()
    {
        _ASSERTE(m_pDomainLocalBlockCrst);
        m_pDomainLocalBlockCrst->Leave();
    }
    
    void EnterLoadingAssemblyListLock()
    {
        // We don't switch into preemptive mode here because 
        // we use this lock for a very limited set of operations.
        // If you will decide to use this function somewhere else
        // make sure you don't introduce a deadlock
        _ASSERTE(m_pLoadingAssemblyListLockCrst);
        m_pLoadingAssemblyListLockCrst->Enter();
    }

    void LeaveLoadingAssemblyListLock()
    {
        _ASSERTE(m_pLoadingAssemblyListLockCrst);
        m_pLoadingAssemblyListLockCrst->Leave();
    }

#ifdef _DEBUG
    BOOL OwnDomainLocalBlockLock()
    {
        return m_pDomainLocalBlockCrst->OwnedByCurrentThread();
    }
#endif

    //****************************************************************************************
    // Find the first occurence of a module in the domain. The current plan will
    // allow the same module to be part of different assemblies. Currently, a module
    // needs to be unique but this requirement will be relaxed later on. 
    // @TODO: CTS, Remove the need for a lock
    // Currently, a lock needs to be taken because models are added to the system domain.
    // The system domain should be static and this restriction can be removed later.
    virtual Module* FindModule(BYTE *pBase);
    virtual Module* FindModule__Fixed(BYTE *pBase);
    virtual Assembly* FindAssembly(BYTE *pBase);

    // determine if the module has been loaded into the system process and attached to 
    // a module other then the one supplied. This routine is used to determine if the PE
    // imaged has had its vtable fixed up.
    Module* FindModuleInProcess(BYTE *pBase, Module* pExcept);

    // Returns an existing assembly, or creates a new one.  Returns S_FALSE if 
    // an existing assembly is returned.  Returns S_OK if fPolicyLoad is true and
    // you attempt to load an assembly that is still trying to be loaded (Note: ppModule
    // and ppAssembly will both point to null).
    HRESULT LoadAssembly(PEFile *pFile, 
                         IAssembly *pIAssembly,
                         Module** ppModule, 
                         Assembly** ppAssembly,
                         OBJECTREF* pExtraEvidence,
                         OBJECTREF* pEvidence = NULL,
                         BOOL fPolicyLoad = FALSE,
                         OBJECTREF *pThrowable=NULL);

    static HRESULT LoadAssemblyHelper(LPCWSTR wszAssembly,
                                      LPCWSTR wszCodeBase,
                                      Assembly **ppAssembly,
                                      OBJECTREF *pThrowable);

    HRESULT CreateDynamicAssembly(CreateDynamicAssemblyArgs *args, Assembly** ppAssembly);

    // Low level assembly creation routine
    HRESULT CreateAssembly(Assembly** ppAssembly);

    //****************************************************************************************

    // Remembers that an assembly is loading, to handle recursive loops
    BOOL PostLoadingAssembly(const BYTE *pBase, Assembly *pAssembly);
    Assembly *FindLoadingAssembly(const BYTE *pBase);
    void RemoveLoadingAssembly(const BYTE *pBase);

    //****************************************************************************************
    //
    // Adds an assembly to the domain.
    void AddAssembly(Assembly* assem);

    BOOL ContainsAssembly(Assembly *assem);

    //****************************************************************************************
    //
    //  Set the shadow copy option for the domain.
    HRESULT SetShadowCopy();
    BOOL IsShadowCopyOn();

    //****************************************************************************************
    //
    LPCWSTR GetFriendlyName();  

    //****************************************************************************************
    //
    void SetExecutable(BOOL value) { m_fExecutable = value != 0; }
    BOOL IsExecutable() { return m_fExecutable; }

    virtual ApplicationSecurityDescriptor* GetSecurityDescriptor() { return NULL; }


    //****************************************************************************************
    // Returns and Inserts assemblies into a lookup cache based on the binding information
    // in the AssemblySpec. There can be many AssemblySpecs to a single assembly.
    Assembly* FindCachedAssembly(AssemblySpec* pSpec)
    {
        return (Assembly*) m_AssemblyCache.LookupEntry(pSpec, 0);
    }

    HRESULT AddAssemblyToCache(AssemblySpec* pSpec, Assembly* pAssembly)
    {
        return m_AssemblyCache.InsertEntry(pSpec, pAssembly);
    }

    HRESULT AddUnmanagedImageToCache(LPCWSTR libraryName, HMODULE hMod)
    {
        if(libraryName) {
            AssemblySpec spec;
            spec.SetCodeBase(libraryName, (DWORD)(wcslen(libraryName)+1));
            return m_UnmanagedCache.InsertEntry(&spec, hMod);
        }
        return S_OK;
    }

    HMODULE FindUnmanagedImageInCache(LPCWSTR libraryName)
    {
        if(libraryName == NULL) return NULL;

        AssemblySpec spec;
        spec.SetCodeBase(libraryName, (DWORD)(wcslen(libraryName) + 1));
        return (HMODULE) m_UnmanagedCache.LookupEntry(&spec, 0);
    }

    //****************************************************************************************
    // Get the class init lock. The method is limited to friends because inappropriate use
    // will cause deadlocks in the system
    ListLock*  GetClassInitLock()
    {
        return &m_ClassInitLock;
    }

    ListLock* GetJitLock()
    {
        return &m_JITLock;
    }
    

    STRINGREF *IsStringInterned(STRINGREF *pString);
    STRINGREF *GetOrInternString(STRINGREF *pString);

    virtual BOOL CanUnload()   { return FALSE; }    // can never unload BaseDomain

    HRESULT SetSharePolicy(SharePolicy policy);
    SharePolicy GetSharePolicy();

    // Returns an array of OBJECTREF* that can be used to store domain specific data.
    // Statics and reflection info (Types, MemberInfo,..) are stored this way
    void AllocateObjRefPtrsInLargeTable(int nRequested, OBJECTREF **apObjRefs);
    
    //****************************************************************************************
    // Handles

    OBJECTHANDLE CreateTypedHandle(OBJECTREF object, int type)
    { 
        return ::CreateTypedHandle(m_hHandleTable, object, type); 
    }

    OBJECTHANDLE CreateHandle(OBJECTREF object)
    { 
        return ::CreateHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreateWeakHandle(OBJECTREF object)
    { 
        return ::CreateWeakHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreateShortWeakHandle(OBJECTREF object)
    { 
        return ::CreateShortWeakHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreateLongWeakHandle(OBJECTREF object)
    { 
        return ::CreateLongWeakHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreateStrongHandle(OBJECTREF object)
    { 
        return ::CreateStrongHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreatePinningHandle(OBJECTREF object)
    { 
        return ::CreatePinningHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreateRefcountedHandle(OBJECTREF object)
    { 
        return ::CreateRefcountedHandle(m_hHandleTable, object); 
    }

    OBJECTHANDLE CreateVariableHandle(OBJECTREF object, UINT type)
    {
        ::CreateVariableHandle(m_hHandleTable, object, type);
    }

    IApplicationContext *GetFusionContext() { return m_pFusionContext; }


protected:

    //****************************************************************************************
    //
    // Creates a new assembly.
    // Note. A lock should be taken before calling this routine.
    HRESULT CreateAssemblyNoLock(PEFile* pFile,
                                 IAssembly* pIAssembly,
                                 Assembly** ppAssembly);

    // Creates a new shareable assembly.
    // Note. A lock should be taken before calling this routine.
    HRESULT CreateShareableAssemblyNoLock(PEFile* pFile,
                                          IAssembly* pIAssembly,
                                          Assembly** ppAssembly);

    HRESULT SetAssemblyManifestModule(Assembly *pAssembly,
                                      Module *pModule,
                                      OBJECTREF *pThrowable);

    //****************************************************************************************
    // Notification when an assembly is loaded into the app domain
    virtual void OnAssemblyLoad(Assembly *assem) { }
    virtual void OnAssemblyLoadUnlocked(Assembly *assem) { }

    //****************************************************************************************
    // Notification on an unhandled exception.  Returns TRUE if event was sent to listeners.
    // Returns FALSE if there are no listeners.
    virtual BOOL OnUnhandledException(OBJECTREF *pThrowable, BOOL isTerminating = TRUE) { return FALSE; }

    //****************************************************************************************
    //
    HRESULT CreateFusionContext(IApplicationContext**);

    void ReleaseFusionInterfaces();

    //****************************************************************************************
    // Helper method to initialize the large heap handle table.
    void InitLargeHeapHandleTable();

    //****************************************************************************************
    //
    // Adds an assembly to the domain.
    void AddAssemblyNoLock(Assembly* assem);

    //****************************************************************************************
    //
    // Hash table that maps a clsid to a EEClass
    PtrHashMap          m_clsidHash;

    //****************************************************************************************
    //
    // @TODO: this is very similar to the Binding cache in AppDomain. Can they be
    // merged.
    DomainAssemblyCache  m_AssemblyCache;
    DomainAssemblyCache  m_UnmanagedCache;

    // Heaps for allocating data that persists for the life of the AppDomain
    // Objects that are allocated frequently should be allocated into the HighFreq heap for
    // better page management
    BYTE *              m_InitialReservedMemForLoaderHeaps;
    BYTE                m_LowFreqHeapInstance[sizeof(LoaderHeap)];
    BYTE                m_HighFreqHeapInstance[sizeof(LoaderHeap)];
    BYTE                m_StubHeapInstance[sizeof(LoaderHeap)];
    LoaderHeap *        m_pLowFrequencyHeap;
    LoaderHeap *        m_pHighFrequencyHeap;
    LoaderHeap *        m_pStubHeap;

    // Critical sections & locks
    ListLock                 m_AssemblyLoadLock;      // Protects the list of assemblies in the domain
    Crst                     *m_pDomainCrst;          // General Protection for the Domain
    Crst                     *m_pDomainCacheCrst;     // Protects the Assembly and Unmanaged caches
    Crst                     *m_pDomainLocalBlockCrst;
    Crst                     *m_pLoadingAssemblyListLockCrst;
    ListLock                  m_ClassInitLock;
    ListLock                  m_JITLock;

    // Indicates where assemblies will be loaded for 
    // this domain. By default all assemblies are loaded into the domain. 
    // There are two additional settings, all
    // assemblies can be loaded into the shared domain or assemblies 
    // that are strong named are loaded into the shared area.
    SharePolicy m_SharePolicy; 

    // Fusion context, used for adding assemblies to the is domain. It defines
    // fusion properties for finding assemblyies such as SharedBinPath,
    // PrivateBinPath, Application Directory, etc.
    IApplicationContext* m_pFusionContext; // Binding context for the domain

    // Recursive loading list
    LoadingAssemblyRecord *m_pLoadingAssemblies;

    HHANDLETABLE                m_hHandleTable;

    // The AppDomain specific string literal map.
    AppDomainStringLiteralMap   *m_pStringLiteralMap;

    // The large heap handle table.
    LargeHeapHandleTable        *m_pLargeHeapHandleTable;

    // The large heap handle table critical section.
    Crst *m_pLargeHeapHandleTableCrst;

    EEMarshalingData            *m_pMarshalingData; 

    // Manage the global interface map
    InterfaceVTableMapMgr       m_InterfaceVTableMapMgr;

    // Information regarding the managed standard interfaces.
    MngStdInterfacesInfo        *m_pMngStdInterfacesInfo;

    static BOOL         m_fStrongAssemblyStatus;  // True: assemblies found on corpath must be strong
    static BOOL         m_fShadowCopy;
    static BOOL         m_fExecutable;

    ArrayList           m_Assemblies;

  public:

    class AssemblyIterator
    {
        ArrayList::Iterator i;

      public:
        BOOL Next() { return i.Next(); }
        Assembly *GetAssembly() 
        { 
            return (Assembly *) i.GetElement(); 
        }
        SIZE_T GetIndex() 
        { 
            return i.GetIndex(); 
        }

      private:
        friend BaseDomain;
        // Cannot have constructor so this iterator can be used inside a union
        static AssemblyIterator Create(BaseDomain *pDomain) 
        {
#pragma warning(disable:4238)
            return (AssemblyIterator&) pDomain->m_Assemblies.Iterate();
#pragma warning(default:4238)
        }
    };

    AssemblyIterator IterateAssemblies() 
    { 
        return AssemblyIterator::Create(this); 
    }
    SIZE_T GetAssemblyCount() 
    { 
        return m_Assemblies.GetCount(); 
    }

private:
    // Only call this routine when you can guarantee there are no
    // loads in progress. 
    void ClearFusionContext();

    // The template for thread local statics of this domain
    DWORD m_dwUnsharedTLS;

    // The template for thread local statics shared across all domains
    static DWORD m_dwSharedTLS;

    // The template for context local statics of this domain
    DWORD m_dwUnsharedCLS;

    // The template for context local statics shared across all domains
    static DWORD m_dwSharedCLS;


    //****************************************************************************************
    // Creates a dead lock aware entry for loading assemblies. These routines are used
    // by LoadAssembly 
    AssemblyLockedListElement* CreateAssemblyLockEntry(BYTE* baseAddress);
    void AddAssemblyLeaveLock(Assembly* pAssembly, AssemblyLockedListElement* pEntry);

    //****************************************************************************************
    // Determines if the image is to be loaded into the shared assembly or an individual 
    // appdomains.
    HRESULT ApplySharePolicy(PEFile *pFile, BOOL* pfCreateShared);
    
public:
    // A few helper methods to increment the offsets per class. At each offset
    // is stored a pointer to the static storage per thread/context for this
    // domain.
    DWORD IncUnsharedTLSOffset()
    {
         DWORD dwCurr = FastInterlockIncrement((LONG *)&m_dwUnsharedTLS);
         return dwCurr -= 1;
    }

    static DWORD IncSharedTLSOffset()
    {
         DWORD dwCurr = FastInterlockIncrement((LONG *)&m_dwSharedTLS);
         return dwCurr -= 1;
    }

    DWORD IncUnsharedCLSOffset()
    {
         DWORD dwCurr = FastInterlockIncrement((LONG *)&m_dwUnsharedCLS);
         return dwCurr -= 1;
    }

    static DWORD IncSharedCLSOffset()
    {
         DWORD dwCurr = FastInterlockIncrement((LONG *)&m_dwSharedCLS);
         return dwCurr -= 1;
    }
    
private:
    // Crst for Reflection Heap
    Crst *m_pReflectionCrst;
    BYTE m_pReflectionCrstMemory[sizeof(Crst)];
    
    MemberMethodsCache *m_pRefMemberMethodsCache;
    DispIDCache *m_pRefDispIDCache;

    Crst *m_pRefClassFactCrst;
    BYTE m_pRefClassFactCrstMemory[sizeof(Crst)];
    EEClassFactoryInfoHashTable *m_pRefClassFactHash;   // Hash table that maps a class factory info to a COM comp.
    
public:
    MemberMethodsCache* GetRefMemberMethodsCache()
    {
        if (m_pRefMemberMethodsCache == NULL) {
            SetupRefMemberMethodsCache();
        }
        return m_pRefMemberMethodsCache;
    }

    DispIDCache* GetRefDispIDCache()
    {
        if (m_pRefDispIDCache == NULL) {
            SetupRefDispIDCache();
        }
        return m_pRefDispIDCache;
    }

    Crst *GetRefClassFactCrst()
    {
        return m_pRefClassFactCrst;
    }

    EEClassFactoryInfoHashTable* GetClassFactHash()
    {
        if (m_pRefClassFactHash == NULL) {
            SetupClassFactHash();
        }
        return m_pRefClassFactHash;
    }
    
private:
    void EnterReflectionCrst()
    {
        m_pReflectionCrst->Enter();
    }
    void LeaveReflectionCrst()
    {
        m_pReflectionCrst->Leave();
    }

    void SetupRefMemberMethodsCache()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_pRefMemberMethodsCache == NULL) {
            EnterReflectionCrst();
            if (m_pRefMemberMethodsCache == NULL) {
                void * pCache = m_pLowFrequencyHeap->AllocMem(sizeof (MemberMethodsCache));
                if (pCache != NULL)
                {
                    MemberMethodsCache *tmp = new (pCache) MemberMethodsCache;
                    if (tmp->Init())
                        m_pRefMemberMethodsCache = tmp;
                }
            }
            LeaveReflectionCrst();

            if (m_pRefMemberMethodsCache == NULL)
                COMPlusThrowOM();
        }
    }
    void SetupRefDispIDCache()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_pRefDispIDCache == NULL) {
            EnterReflectionCrst();
            if (m_pRefDispIDCache == NULL) {
                void * pCache = m_pLowFrequencyHeap->AllocMem(sizeof (DispIDCache));
                if (pCache != NULL)
                {
                    DispIDCache *tmp = new (pCache) DispIDCache;
                    if (tmp->Init())
                        m_pRefDispIDCache = tmp;
                }
            }
            LeaveReflectionCrst();

            if (m_pRefDispIDCache == NULL)
                COMPlusThrowOM();
        }
    }
    void SetupClassFactHash()
    {
        THROWSCOMPLUSEXCEPTION();

        if (m_pRefClassFactHash == NULL) {
            EnterReflectionCrst();
            if (m_pRefClassFactHash == NULL) {
                void * pCache = m_pLowFrequencyHeap->AllocMem(sizeof (EEClassFactoryInfoHashTable));
                if (pCache != NULL)
                {
                    EEClassFactoryInfoHashTable *tmp = new (pCache) EEClassFactoryInfoHashTable;
                    LockOwner lock = {m_pRefClassFactCrst,IsOwnerOfCrst};
                    if (tmp->Init(20, &lock))
                        m_pRefClassFactHash = tmp;
                }
            }
            LeaveReflectionCrst();

            if (m_pRefClassFactHash == NULL)
                COMPlusThrowOM();
        }
    }
};

enum
{
        ATTACH_ASSEMBLY_LOAD = 0x1,
        ATTACH_MODULE_LOAD = 0x2,
        ATTACH_CLASS_LOAD = 0x4,

        ATTACH_ALL = 0x7
};

typedef EEHashTable<EEClass *, EEPtrHashTableHelper<EEClass *, FALSE>, FALSE> EEHashTableOfEEClass;

class AppDomain : public BaseDomain
{
    friend SystemDomain;
    friend AssemblySink;
    friend ApplicationSecurityDescriptor;
    friend AppDomainNative;
    friend AssemblyNative;
    friend ClassLoader;
    friend ComPlusWrapperCache;
    friend AssemblySpec;
    friend struct MEMBER_OFFSET_INFO(AppDomain);


public:
    AppDomain();
    virtual ~AppDomain();

    //****************************************************************************************
    // 
    // Initializes an AppDomain. (this functions is not called from the SystemDomain)
    HRESULT Init();

    //****************************************************************************************
    //
    // Stop deletes all the assemblies but does not remove other resources like
    // the critical sections
    void Stop();

    // Gets rid of resources
    void Terminate();

    // Remove the Appdomain for the system and cleans up. This call should not be
    // called from shut down code.
    HRESULT CloseDomain();

    BOOL IsAppDomain() { return TRUE; }
    
    // Write any zap logs entries for the domain
    void WriteZapLogs();

    OBJECTREF GetExposedObject();
    OBJECTREF GetRawExposedObject() { return ObjectFromHandle(m_ExposedObject); }

    //****************************************************************************************


    ApplicationSecurityDescriptor* GetSecurityDescriptor()
    {
        return m_pSecDesc;
    }

    void CreateSecurityDescriptor();

    //****************************************************************************************
    //
    // Reference count. When an appdomain is first created the reference is bump
    // to one when it is added to the list of domains (see SystemDomain). An explicit 
    // Removal from the list is necessary before it will be deleted.
    ULONG AddRef(void); 
    ULONG Release(void);

    //****************************************************************************************
    LPCWSTR GetFriendlyName(BOOL fDebuggerCares = TRUE);  
    void SetFriendlyName(LPCWSTR pwzFriendlyName, BOOL fDebuggerCares = TRUE);
    void ResetFriendlyName(BOOL fDebuggerCares = TRUE);

    //****************************************************************************************

    // This can be used to override the binding behavior of the appdomain.   It
    // is overridden in the compilation domain.  It is important that all 
    // static binding goes through this path.
    virtual HRESULT BindAssemblySpec(AssemblySpec *pSpec, 
                                     PEFile **ppFile,
                                     IAssembly** ppIAssembly,
                                     Assembly **ppDynamicAssembly,
                                     OBJECTREF *pExtraEvidence,
                                     OBJECTREF *pThrowable);

    virtual HRESULT PredictAssemblySpecBinding(AssemblySpec *pSpec, GUID *pmvid, BYTE *pbHash, DWORD *pcbHash);

    // This is overridden by a compilation domain to record the linktime checks made
    // when compiling an assembly
    virtual void OnLinktimeCheck(Assembly *pAssembly, 
                                 OBJECTREF refCasDemands,
                                 OBJECTREF refNonCasDemands) { return; }
    virtual void OnLinktimeCanCallUnmanagedCheck(Assembly *pAssembly) { return; }
    virtual void OnLinktimeCanSkipVerificationCheck(Assembly * pAssembly) { return; }
    virtual void OnLinktimeFullTrustCheck(Assembly *pAssembly) { return; }

    //
    // This checks cached assembly specs directly - it will never perform
    // an actual bind.
    //
    HRESULT LookupAssemblySpec(AssemblySpec *pSpec, 
                               PEFile **ppFile,
                               IAssembly **ppIAssembly,
                               OBJECTREF *pThrowable)
    {
        if (m_pBindingCache == NULL)
            return S_FALSE;
        else
            return m_pBindingCache->Lookup(pSpec, ppFile, ppIAssembly, pThrowable);
    }

    // Store a successful binding into the cache.  This will keep the file from
    // being physically unmapped, as well as shortcutting future attempts to bind
    // the same spec throught the Cached entry point.
    //
    // Right now we only cache assembly binds for "probing" type
    // binding situations, basically when loading shared assemblies or
    // zap files.  
    //
    // @todo: We may want to be more aggressive about this if
    // there are other situations where we are repeatedly binding the
    // same assembly specs, though.
    //
    // Returns TRUE if stored
    //         FALSE if it's a duplicate (caller should clean up args)
    BOOL StoreBindAssemblySpecResult(AssemblySpec *pSpec, 
                                     PEFile *pFile,
                                     IAssembly* pIAssembly,
                                     BOOL clone = TRUE); 

    BOOL StoreBindAssemblySpecError(AssemblySpec *pSpec, 
                                    HRESULT hr,
                                    OBJECTREF *pThrowable,
                                    BOOL clone = TRUE); 

    //****************************************************************************************
    //
    static BOOL SetContextProperty(IApplicationContext* pFusionContext, 
                                   LPCWSTR pProperty, 
                                   OBJECTREF* obj);

    //****************************************************************************************
    //
    // Uses the first assembly to add an application base to the Context. This is done 
    // in a lazy fashion so executables do not take the perf hit unless the load other 
    // assemblies
    HRESULT GetDynamicDir(LPWSTR* pDynamicDir);
    
    void OnAssemblyLoad(Assembly *assem);
    void OnAssemblyLoadUnlocked(Assembly *assem);
    BOOL OnUnhandledException(OBJECTREF *pThrowable, BOOL isTerminating = TRUE);

#ifdef DEBUGGING_SUPPORTED
    void SetDebuggerAttached (DWORD dwStatus);
    DWORD GetDebuggerAttached (void);
    BOOL IsDebuggerAttached (void);
    BOOL NotifyDebuggerAttach(int flags, BOOL attaching);
    void NotifyDebuggerDetach();
#endif // DEBUGGING_SUPPORTED

    void SetSystemAssemblyLoadEventSent (BOOL fFlag);
    BOOL WasSystemAssemblyLoadEventSent (void);
    BOOL IsDomainBeingCreated (void);
    void SetDomainBeingCreated (BOOL flag);

    void AllocateStaticFieldObjRefPtrs(int nRequested, OBJECTREF **apObjRefs) 
    {
        AllocateObjRefPtrsInLargeTable(nRequested, apObjRefs);
    }

    DomainLocalBlock *GetDomainLocalBlock() 
    { 
        return &m_sDomainLocalBlock; 
    }
    static SIZE_T GetOffsetOfSlotsPointer() 
    { 
        return offsetof(AppDomain,m_sDomainLocalBlock) + DomainLocalBlock::GetOffsetOfSlotsPointer();
    }
    static SIZE_T GetOffsetOfSlotsCount() 
    { 
        return offsetof(AppDomain,m_sDomainLocalBlock) + DomainLocalBlock::GetOffsetOfSlotsCount();
    }

    HRESULT SetupSharedStatics();

    OBJECTREF GetUnloadWorker();

    //****************************************************************************************
    // Get the default method table for unknown COM interfaces
    MethodTable* ComMethodTable()
    {
        InitializeComObject();
        return m_pComObjectMT;
    }


    MethodTable* GetLicenseInteropHelperMethodTable(ClassLoader *pLoader);


    //****************************************************************************************
    // Get the proxy for this app domain
    OBJECTREF GetAppDomainProxy();

    ComCallWrapperCache* GetComCallWrapperCache();
    ComPlusWrapperCache* GetComPlusWrapperCache();

    void ResetComCallWrapperCache()
    {
        m_pComCallWrapperCache = NULL;
    }

    void ResetComPlusWrapperCache()
    {
        m_pComPlusWrapperCache = NULL;
    }

    DWORD GetIndex()
    {
        return m_dwIndex;
    }

    //****************************************************************************************
    //   
    HRESULT CreateFusionContext(IApplicationContext** ppFusionContext);

    void ReleaseFusionInterfaces();

    HRESULT InitializeDomainContext(DWORD optimization, LPCWSTR pwszPath, LPCWSTR pwszConfig);

    //****************************************************************************************
    // Create a domain context rooted at the fileName. The directory containing the file name 
    // is the application base and the configuration file is the fileName appended with 
    // .config. If no name is passed in then no domain is created.
    static AppDomain* CreateDomainContext(WCHAR* fileName);

    // Sets up the current domain's fusion context based on the given exe file name
    // (app base & config file)
    void SetupExecutableFusionContext(WCHAR *exePath);

    //****************************************************************************************
    // Manage a pool of asyncrhonous objects used to fetch assemblies.  When a sink is released
    // it places itself back on the pool list.  Only one object is kept in the pool.
    AssemblySink* GetAssemblySink();

    void SetIsUserCreatedDomain()
    {
        m_dwFlags |= USER_CREATED_DOMAIN;
    }

    BOOL IsUserCreatedDomain()
    {
        return m_dwFlags |= USER_CREATED_DOMAIN;
    }

    void SetCompilationDomain()
    {
        m_dwFlags |= COMPILATION_DOMAIN;
    }

    BOOL IsCompilationDomain()
    {
        return (m_dwFlags & COMPILATION_DOMAIN) != 0;
    }

    void SetCanUnload()   
    { 
        m_dwFlags |= APP_DOMAIN_CAN_BE_UNLOADED;
    }

    BOOL CanUnload()   
    { 
        return m_dwFlags & APP_DOMAIN_CAN_BE_UNLOADED;
    }

    void SetRemotingConfigured()
    {
        m_dwFlags |= REMOTING_CONFIGURED_FOR_DOMAIN;
    }

    BOOL IsRemotingConfigured()
    {
        return m_dwFlags & REMOTING_CONFIGURED_FOR_DOMAIN;
    }

    static void ExceptionUnwind(Frame *pFrame);

#ifdef _DEBUG
    void TrackADThreadEnter(Thread *pThread, Frame *pFrame);
    void TrackADThreadExit(Thread *pThread, Frame *pFrame);
    void DumpADThreadTrack();
#endif

    void ThreadEnter(Thread *pThread, Frame *pFrame)
    {
#ifdef _DEBUG
        if (LoggingOn(LF_APPDOMAIN, LL_INFO100))
            TrackADThreadEnter(pThread, pFrame);
        else 
#endif
        {
            InterlockedIncrement((LONG*)&m_dwThreadEnterCount);
            LOG((LF_APPDOMAIN, LL_INFO1000, "AppDomain::ThreadEnter %x to (%8.8x) %S count %d\n", pThread->GetThreadId(), this, 
                    GetFriendlyName(FALSE), GetThreadEnterCount()));
#if _DEBUG_AD_UNLOAD
            printf("AppDomain::ThreadEnter %x to (%8.8x) %S count %d\n", pThread->GetThreadId(), this, 
                    GetFriendlyName(FALSE), GetThreadEnterCount());
#endif
        }
    }

    void ThreadExit(Thread *pThread, Frame *pFrame)
    {
#ifdef _DEBUG
        if (LoggingOn(LF_APPDOMAIN, LL_INFO100))
            TrackADThreadExit(pThread, pFrame);
        else 
#endif
        {
            LONG result = InterlockedDecrement((LONG*)&m_dwThreadEnterCount);
            _ASSERTE(result >= 0);
            LOG((LF_APPDOMAIN, LL_INFO1000, "AppDomain::ThreadExit from (%8.8x) %S count %d\n", this, 
                    GetFriendlyName(FALSE), GetThreadEnterCount()));
#if _DEBUG_ADUNLOAD
            printf("AppDomain::ThreadExit %x from (%8.8x) %S count %d\n", pThread->GetThreadId(), this, 
                    GetFriendlyName(FALSE), GetThreadEnterCount());
#endif
        }
    }

    ULONG GetThreadEnterCount()
    {
        return m_dwThreadEnterCount;
    }

    Context *GetDefaultContext()
    {
        return m_pDefaultContext;
    }
    
    BOOL IsOpen() 
    { 
        return m_Stage >= STAGE_OPEN && m_Stage < STAGE_CLOSED; 
    }
    BOOL IsUnloading() 
    { 
        return m_Stage > STAGE_OPEN; 
    }

    BOOL IsFinalizing() 
    { 
        return m_Stage >= STAGE_FINALIZING; 
    }

    BOOL IsFinalized() 
    { 
        return m_Stage >= STAGE_FINALIZED; 
    }

    // Checks whether the given thread can enter the app domain
    BOOL CanThreadEnter(Thread *pThread);

    // Following two are needed for the HOLDER/TAKER macros
    void SetUnloadInProgress();
    void SetUnloadComplete();
    
    // Predicates for GC asserts
    BOOL ShouldHaveFinalization()   
    { 
        return ((DWORD) m_Stage) < STAGE_COLLECTED; 
    }     
    BOOL ShouldHaveCode()           
    { 
        return ((DWORD) m_Stage) < STAGE_COLLECTED; 
    }     
    BOOL ShouldHaveRoots()          
    { 
        return ((DWORD) m_Stage) < STAGE_CLOSED;
    }
    BOOL ShouldHaveInstances()      
    { 
        return ((DWORD) m_Stage) < STAGE_COLLECTED; 
    }

    HRESULT ShouldContainAssembly(Assembly *pAssembly, BOOL doNecessaryLoad = TRUE);
    HRESULT IsUnloadedDependency(Assembly *pAssembly);

    static void RaiseExitProcessEvent();
    Assembly* RaiseResourceResolveEvent(LPCSTR szName, OBJECTREF *pThrowable);
    Assembly* RaiseTypeResolveEvent(LPCSTR szName, OBJECTREF *pThrowable);
    Assembly* RaiseAssemblyResolveEvent(LPCWSTR wszName, OBJECTREF *pThrowable);

    // Sets the process win32 SxS activation context on the Fusion ActivationContext.
    // This call must be down while the thread is outside the appdomain 
    HRESULT SetDefaultActivationContext(Frame* pFrame);
protected:
    //****************************************************************************************
    // If the ComObject for this domain has not been initialized then create one using the
    // object defined in the system domain.
    void InitializeComObject();
    LPWSTR m_pwDynamicDir;

    PEFile* m_pRootFile;     // Used by the shell host to set the application (do not delete or release)

    void ReleaseComPlusWrapper(LPVOID pCtxCookie);

private:

    static HRESULT GetServerObject(OBJECTREF proxy, OBJECTREF* result); // GCPROTECTED result

    void RaiseUnloadDomainEvent();
    static void RaiseUnloadDomainEvent_Wrapper(AppDomain *);

    void RaiseLoadingAssemblyEvent(Assembly* pAssembly);
    struct RaiseLoadingAssembly_Args
    {
        AppDomain *pDomain;
        Assembly *pAssembly;
    };
    static void RaiseLoadingAssembly_Wrapper(RaiseLoadingAssembly_Args *);

    BOOL RaiseUnhandledExceptionEvent(OBJECTREF *pThrowable, BOOL isTerminating);
    struct RaiseUnhandled_Args
    {
        AppDomain *pDomain;
        OBJECTREF *pThrowable;
        BOOL isTerminating;
        BOOL *pResult;
    };
    static void RaiseUnhandledExceptionEvent_Wrapper(RaiseUnhandled_Args *);


    HRESULT SignalProcessDetach();

    enum Stage {
        STAGE_CREATING,
        STAGE_OPEN,
        STAGE_EXITING,
        STAGE_EXITED,
        STAGE_FINALIZING,
        STAGE_FINALIZED,
        STAGE_CLEARED,
        STAGE_COLLECTED,
        STAGE_CLOSED
    };

    void Exit(BOOL fRunFinalizers);

    void ClearGCRoots();
    void ClearGCHandles();
    void UnwindThreads();
    void StopEEAndUnwindThreads(int retryCount);
    void ReleaseDomainStores(LocalDataStore **pStores, int *numStores);
    void StartUnlinkClasses();
    void EndUnlinkClasses();

public:
    // ID to uniquely identify this AppDomain - used by the AppDomain publishing
    // service (to publish the list of all appdomains present in the process), 
    // which in turn is used by, for eg., the debugger (to decide which App-
    // Domain(s) to attach to).
    // This is also used by Remoting for routing cross-appDomain calls.
    ULONG GetId (void) 
    { 
        return m_dwId; 
    }

    static USHORT GetOffsetOfId()
    {
        size_t ofs = offsetof(class AppDomain, m_dwId);
        _ASSERTE(FitsInI2(ofs));
        return (USHORT)ofs;
    }

    void Unload(BOOL fForceUnload, Thread *pRequestingThread = NULL);

    void UnlinkClass(EEClass *pClass);

    // Support for external object & string classes
    
    static HRESULT ReadSpecialClassesRegistry();
    void NoticeSpecialClassesAssembly(Assembly *pAssembly);

    BOOL HasSpecialClasses() 
    { 
        return g_pSpecialAssemblySpec != NULL; 
    }

    BOOL IsSpecialObjectClass(MethodTable *pMT)
    {
        return pMT == m_pSpecialObjectClass;
    }

    BOOL IsSpecialStringClass(MethodTable *pMT)
    {
        return pMT == m_pSpecialStringClass;
    }

    BOOL IsSpecialStringBuilderClass(MethodTable *pMT)
    {
        return pMT == m_pSpecialStringBuilderClass;
    }

    OBJECTREF ConvertStringToSpecialString(OBJECTREF pString);
    OBJECTREF ConvertStringBuilderToSpecialStringBuilder(OBJECTREF pString);
    OBJECTREF ConvertSpecialStringToString(OBJECTREF pString);
    OBJECTREF ConvertSpecialStringBuilderToStringBuilder(OBJECTREF pString);
    Module* LoadModuleIfSharedDependency(LPCBYTE pAssemblyBase,LPCBYTE pModuleBase);
private:
    LPWSTR      m_pwzFriendlyName;

    Assembly*          m_pRootAssembly;    // Used by the shell host to set the application evidence.

    // General purpose flags. 
    DWORD           m_dwFlags;

    // When an application domain is created the ref count is artifically incremented
    // by one. For it to hit zero an explicit close must have happened.
    ULONG       m_cRef;                    // Ref count.

    ApplicationSecurityDescriptor *m_pSecDesc;  // Application Security Descriptor

    // The method table used for unknown COM interfaces. The initial MT is created
    // in the system domain and copied to each active domain.
    MethodTable*    m_pComObjectMT;  // global method table for ComObject class

    // The method table used for LicenseInteropHelper
    MethodTable*    m_pLicenseInteropHelperMT;

    OBJECTHANDLE    m_ExposedObject;

    // The wrapper cache for this domain - it has it's onw CCacheLineAllocator on a per domain basis
    // to allow the domain to go away and eventually kill the memory when all refs are gone
    ComCallWrapperCache *m_pComCallWrapperCache;
    // this cache stores the ComPlusWrappers in this domain
    ComPlusWrapperCache *m_pComPlusWrapperCache;

    AssemblySink*      m_pAsyncPool;  // asynchronous retrival object pool (only one is kept)

    // The index of this app domain among existing app domains (starting from 1)
    DWORD m_dwIndex;
    // The creation sequence number of this app domain (starting from 1)
    DWORD m_dwId;
    
#ifdef _DEBUG
    struct ThreadTrackInfo;
    typedef CDynArray<ThreadTrackInfo *> ThreadTrackInfoList;    
    ThreadTrackInfoList *m_pThreadTrackInfoList;
    DWORD m_TrackSpinLock;
#endif

    DomainLocalBlock    m_sDomainLocalBlock;
    
    // The count of the number of threads that have entered this AD
    ULONG m_dwThreadEnterCount;

    Stage m_Stage;

    // The default context for this domain
    Context *m_pDefaultContext;

    AssemblySpecBindingCache    *m_pBindingCache;
    
    // List of shared dependencies which may not have been loaded yet
    PtrHashMap                  m_sharedDependenciesMap;

    // Aggressive backpatching must be coordinated with appdomain unloading.  The unload
    // code calls Start/Continue/End to achieve this coordination.  It is guaranteed
    // (by Jen!) that only one unload is active at any time.
    EEHashTableOfEEClass *m_UnlinkClasses;

    //---------------------------------------------------------
    // Stub caches for ComCall Method stubs
    //---------------------------------------------------------
    ComCallMLStubCache *m_pComCallMLStubCache;
    ArgBasedStubCache *m_pFieldCallStubCache;

    void AllocateComCallMLStubCache();
    void AllocateFieldCallStubCache();


    //---------------------------------------------------------
    // Method for reseting the binding redirect. This should never 
    // be done on any domain except the default domain. This operation
    // is inherently in-secure. We are doinging it on the default domain
    // for completeness. The security issues with this call need to be 
    // addressed later.

    void ResetBindingRedirect();
    //---------------------------------------------------------

public:

    ComCallMLStubCache *GetComCallMLStubCache()
    {
        if (! m_pComCallMLStubCache)
            AllocateComCallMLStubCache();
        return m_pComCallMLStubCache;
    }

    ArgBasedStubCache *GetFieldCallStubCache()
    {
        if (! m_pFieldCallStubCache)
            AllocateFieldCallStubCache();
        return m_pFieldCallStubCache;
    }

    enum {
        CONTEXT_INITIALIZED =               0x1,
        USER_CREATED_DOMAIN =               0x2,    // created by call to AppDomain.CreateDomain
        ALLOCATEDCOM =                      0x8,
        DEBUGGER_NOT_ATTACHED =             0x10,
        DEBUGGER_ATTACHING =                0x20, // assemblies & modules
        DEBUGGER_ATTACHED =                 0x30,
        DEBUGGER_STATUS_BITS_MASK =         0x230,
        LOAD_SYSTEM_ASSEMBLY_EVENT_SENT =   0x40,
        APP_DOMAIN_BEING_CREATED =          0x80,
        REMOTING_CONFIGURED_FOR_DOMAIN =    0x100,
        DEBUGGER_ATTACHING_THREAD =         0x200,
        COMPILATION_DOMAIN =                0x400,
        APP_DOMAIN_CAN_BE_UNLOADED =        0x800, // if need extra bits, can derive this at runtime
        APP_DOMAIN_LOGGED =                 0x1000,        
    };

    SecurityContext *m_pSecContext;

    // Special class info
        
    static AssemblySpec *g_pSpecialAssemblySpec;
    static LPUTF8 g_pSpecialObjectName;
    static LPUTF8 g_pSpecialStringName;
    static LPUTF8 g_pSpecialStringBuilderName;

    Assembly *m_pSpecialAssembly;

    MethodTable *m_pSpecialObjectClass;
    MethodTable *m_pSpecialStringClass;
    MethodTable *m_pSpecialStringBuilderClass;

    MethodDesc *m_pStringToSpecialStringMD;
    MethodDesc *m_pSpecialStringToStringMD;
    MethodDesc *m_pStringBuilderToSpecialStringBuilderMD;
    MethodDesc *m_pSpecialStringBuilderToStringBuilderMD;
};

class SystemDomain : public BaseDomain
{
    friend class AppDomainNative;
    friend class AppDomainIterator;

    friend struct MEMBER_OFFSET_INFO(SystemDomain);

public:
    //****************************************************************************************
    //
    // To be run during the initial start up of the EE. This must be
    // performed prior to any class operations.
    static HRESULT Attach();

    //****************************************************************************************
    //
    // To be run during shutdown. This must be done after all operations
    // that require the use of system classes (i.e., exceptions).
    // DetachBegin stops all domains, while DetachEnd deallocates domain resources.
    static BOOL DetachBegin();
#ifdef SHOULD_WE_CLEANUP
    static BOOL DetachEnd();
#endif /* SHOULD_WE_CLEANUP */

    void ReleaseFusionInterfaces();

    void WriteZapLogs();
      
    //****************************************************************************************
    //
    // Initializes and shutdowns the single instance of the SystemDomain
    // in the EE
    void *operator new(size_t size, void *pInPlace);
    void operator delete(void *pMem);
    HRESULT Init();
    void Stop();
    void Terminate();

    //****************************************************************************************
    //
    // Returns the domain associated with the module. This can be null if the module has not
    // been added to an Assembly.
    static HRESULT GetDomainFromModule(Module* pModule, BaseDomain** ppDomain);

    //****************************************************************************************
    //
    // Load the base system classes, these classes are required before
    // any other classes are loaded
    HRESULT LoadBaseSystemClasses();

    HRESULT LoadSystemAssembly(Assembly **pAssemblyOut = NULL);

    //****************************************************************************************
    // Loads a module returning the Handle
    static HRESULT LoadFile(LPCWSTR pswModuleName, 
                            Assembly* pParent,               // If file is a module you need to pass in the Assembly
                            mdFile kFile,                    // File token in the assembly associated with the file
                            BOOL fIgnoreVerification,        // Verify the entry points and stubs
                            IAssembly* pFusionAssembly,      // [Optional] Interface holding onto th lifetime of the file
                            LPCWSTR pCodeBase,               // If origin is different then file
                            OBJECTREF* pExtraEvidence,
                            PEFile** ppFile, 
                            BOOL fResource);
    static HRESULT LoadFile(LPCSTR  psModuleName, 
                            Assembly* pParent,               // If file is a module you need to pass in the Assembly
                            mdFile kFile,                    // File token in the assembly associated with the file
                            BOOL fIgnoreVerification,
                            IAssembly* pFusionAssembly,      // [Optional] Interface holding onto th lifetime of the file
                            LPCWSTR pCodeBase,               // If origin is different then file
                            OBJECTREF* pExtraEvidence,
                            PEFile** ppFile);

    AppDomain* DefaultDomain()
    {
        return m_pDefaultDomain;
    }

    //****************************************************************************************
    //
    // Global Static to get the one and only system domain
    static SystemDomain* System()
    {
        return m_pSystemDomain;
    }

    //****************************************************************************************
    //
    // Global static to get the loader of the one and only system assembly and loader
    static ClassLoader* Loader()
    {
        // Since system only has one assembly we
        // can provide quick access
        _ASSERTE(m_pSystemDomain);
        return System()->m_pSystemAssembly->GetLoader();
    }

    static Assembly* SystemAssembly()
    {
        _ASSERTE(m_pSystemDomain);
        return System()->m_pSystemAssembly;
    }

    static Module* SystemModule()
    {
        Assembly *pAssembly = SystemAssembly();
        if (pAssembly == NULL)
            return NULL;
        else
            return pAssembly->GetManifestModule();
    }

    static BOOL IsSystemLoaded()
    {
        return System()->m_pSystemAssembly != NULL;
    }

    static ICorRuntimeHost* GetCorHost();

    static GlobalStringLiteralMap *GetGlobalStringLiteralMap()
    {
        return m_pGlobalStringLiteralMap;
    }

    static BOOL BeforeFusionShutdown()
    {
        return FusionBind::BeforeFusionShutdown();
    }

    // Notification when an assembly is loaded into the system domain
    void OnAssemblyLoad(Assembly *assem);

    // Notification when new app domain is created (and inherits system assemblies)
    void NotifyNewDomainLoads(AppDomain *pDomain);

    // Execute a module in the system domain. This is used by executable
    // entry points where there are no children domains directly created.
    static HRESULT ExecuteMainMethod(PEFile *pFile, LPWSTR wszImageName);
    static HRESULT InitializeDefaultDomain(DWORD optimization);
    static HRESULT SetupDefaultDomain();

    // @Todo: Craig, this guy is for IJW in M10 and doesn't support everything.
    static HRESULT RunDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);

    //****************************************************************************************
    //
    // Create a new Application Domain.
    static HRESULT CreateDomain(LPCWSTR     pswFriendlyName,
                                AppDomain** ppDomain);

    //****************************************************************************************
    //
    // Use an already exising & inited Application Domain (e.g. a subclass).
    static HRESULT LoadDomain(AppDomain     *pDomain,
                              LPCWSTR       pswFriendlyName);

    typedef void (*ExternalCreateDomainWorker)(void *args);
    //****************************************************************************************
    //
    // This function will not throw exceptions and will disable GC. It calls CreateDomain to add
    // the domain.
    static HRESULT ExternalCreateDomain(LPCWSTR pswAssembly, Module** ppChild = NULL, AppDomain** ppDomain = NULL,
                                        ExternalCreateDomainWorker workerFcn = NULL, void *workerArgs = NULL);

    // This function propogates a newly loaded shared interface to all other appdomains
    static HRESULT PropogateSharedInterface(UINT32 id, SLOT *pVtable);

    //****************************************************************************************
    // Locates a class via a class id, loads the assembly into the com application domain and 
    // returns a pointer to the domain.
    static EEClass *LoadCOMClass(GUID clsid, BaseDomain** ppParent = NULL, BOOL bLoadRecord = FALSE, BOOL* pfAssemblyInReg = NULL);

    //****************************************************************************************
    // Method used to get the callers module and hence assembly and app domain.
    
    // these are obsolete and should not be used. Use the stackMark version instead
    static Module* GetCallersModule(int skip);
    static Assembly* GetCallersAssembly(int skip);

    static EEClass* GetCallersClass(StackCrawlMark* stackMark, AppDomain **ppAppDomain = NULL);
    static Module* GetCallersModule(StackCrawlMark* stackMark, AppDomain **ppAppDomain = NULL);
    static Assembly* GetCallersAssembly(StackCrawlMark* stackMark, AppDomain **ppAppDomain = NULL);

    //****************************************************************************************
    // Returns the domain associated with the current context. (this can only be a child domain)
    static inline AppDomain* GetCurrentDomain()
    {
        return GetAppDomain();
    }

    //****************************************************************************************
    // Returns the default COM object ain associated with the current context. 
    static MethodTable* GetDefaultComObject();
    static MethodTable* GetDefaultComObjectNoInit();    // This one might return NULL

    static void EnsureComObjectInitialized();

    //****************************************************************************************
    // Find the first occurence of a module in the system domain. Modules loaded into the
    // system area cannot be reloaded into the system.
    virtual Module* FindModule(BYTE *pBase);
    virtual Assembly* FindAssembly(BYTE *pBase);


    // determine if the module has been loaded into the system process and attached to 
    // a module other then the one supplied. This routine is used to determine if the PE
    // imaged has had its vtable fixed up.
    Module* FindModuleInProcess(BYTE *pBase, Module* pModule);
    //****************************************************************************************
    // 
    // This lock controls adding and removing domains from the system domain
    static void Enter()
    {
        BEGIN_ENSURE_PREEMPTIVE_GC();
        m_pSystemDomainCrst->Enter();
        END_ENSURE_PREEMPTIVE_GC();
    }
    static void Leave()
    {
        m_pSystemDomainCrst->Leave();
    }

    HRESULT FixupSystemTokenTables();

#ifdef DEBUGGING_SUPPORTED
    //****************************************************************************************
    // Debugger/Publisher helper function to indicate creation of new app domain to debugger
    // and publishing it in the IPC block
    static void PublishAppDomainAndInformDebugger (AppDomain *pDomain);
#endif // DEBUGGING_SUPPORTED

    //****************************************************************************************
    // Helper function to remove a domain from the system
    HRESULT RemoveDomain(AppDomain* pDomain); // Does not decrement the reference

#ifdef PROFILING_SUPPORTED
    //****************************************************************************************
    // Tell profiler about system created domains which are created before the profiler is
    // actually activated.
    static HRESULT NotifyProfilerStartup();

    //****************************************************************************************
    // Tell profiler at shutdown that system created domains are going away.  They are not
    // torn down using the normal sequence.
    static HRESULT NotifyProfilerShutdown();
#endif // PROFILING_SUPPORTED

    //****************************************************************************************
    // Return the base COM object. This routine is used by AppDomain to create a local verion
    // of the default COM object used to wrap all unknown IP's seen in that domain.
    MethodTable* BaseComObject()
    {
        if (m_pBaseComObjectClass)
            return m_pBaseComObjectClass;

        MethodTable *pComObjectClass = g_Mscorlib.FetchClass(CLASS__COM_OBJECT);
        pComObjectClass->SetComObjectType(); //mark the object as com object type
        pComObjectClass->m_pInterfaceVTableMap = SystemDomain::System()->GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers();

        m_pBaseComObjectClass = pComObjectClass;

        return m_pBaseComObjectClass;

    }

    ApplicationSecurityDescriptor* GetSecurityDescriptor()
    {
        return NULL;
    }

    //****************************************************************************************
    // return the dev path
    HRESULT GetDevpathW(LPWSTR* pPath, DWORD* pSize);

    void IncrementNumAppDomains ()
    {
        s_dNumAppDomains++; 
    }
    
    void DecrementNumAppDomains ()
    {
        s_dNumAppDomains--; 
    }

    ULONG GetNumAppDomains ()
    {
        return s_dNumAppDomains;
    }

    //
    // AppDomains currently have both an index and an ID.  The
    // index is "densely" assigned; indices are reused as domains
    // are unloaded.  The Id's on the other hand, are not reclaimed
    // so may be sparse.  
    // 
    // Another important difference - it's OK to call GetAppDomainAtId for 
    // an unloaded domain (it will return NULL), while GetAppDomainAtIndex 
    // will assert if the domain is unloaded.
    //
    // @todo:
    // I'm not really happy with this situation, but 
    //  (a) we need an ID for a domain which will last the process lifetime for the
    //      remoting code.
    //  (b) we need a dense ID, for the handle table index.
    // So for now, I'm leaving both, but hopefully in the future we can come up 
    // with something better.
    //

    static DWORD GetNewAppDomainIndex(AppDomain *pAppDomain);
    static void ReleaseAppDomainIndex(DWORD indx);
    static AppDomain *GetAppDomainAtIndex(DWORD indx);
    static AppDomain *TestGetAppDomainAtIndex(DWORD indx);
    static DWORD GetCurrentAppDomainMaxIndex() { return m_appDomainIndexList.GetCount(); }

    static DWORD GetNewAppDomainId(AppDomain *pAppDomain);
    static void ReleaseAppDomainId(DWORD indx);
    static void RestoreAppDomainId(DWORD indx, AppDomain *pDomain);
    static AppDomain *GetAppDomainAtId(DWORD indx);
    static DWORD GetCurrentAppDomainMaxId() { return m_appDomainIdList.GetCount(); }

    static void SetUnloadInProgress(AppDomain *pDomain)
    {
        _ASSERTE(m_pAppDomainBeingUnloaded == NULL);
        m_pAppDomainBeingUnloaded = pDomain;
        m_dwIndexOfAppDomainBeingUnloaded = pDomain->GetIndex();
    }

    static void SetUnloadDomainClosed()
    {
        // about to delete, so clear this pointer so nobody uses it
        m_pAppDomainBeingUnloaded = NULL;
    }
    
    static void SetUnloadComplete()
    {
        // should have already cleared the AppDomain* prior to delete
        // either we succesfully unloaded and cleared or we failed and restored the ID
        _ASSERTE(m_pAppDomainBeingUnloaded == NULL && m_dwIndexOfAppDomainBeingUnloaded != 0 
            || m_pAppDomainBeingUnloaded && SystemDomain::GetAppDomainAtId(m_pAppDomainBeingUnloaded->GetId()) != NULL);
        m_pAppDomainBeingUnloaded = NULL;
        m_dwIndexOfAppDomainBeingUnloaded = 0;
        m_pAppDomainUnloadingThread = NULL;
    }

    static AppDomain *AppDomainBeingUnloaded()
    {
        return m_pAppDomainBeingUnloaded;
    }

    static DWORD IndexOfAppDomainBeingUnloaded()
    {
        return m_dwIndexOfAppDomainBeingUnloaded;
    }

    static void SetUnloadRequestingThread(Thread *pRequestingThread)
    {
        m_pAppDomainUnloadRequestingThread = pRequestingThread;
    }

    static Thread *GetUnloadRequestingThread()
    {
        return m_pAppDomainUnloadRequestingThread;
    }

    static void SetUnloadingThread(Thread *pUnloadingThread)
    {
        m_pAppDomainUnloadingThread = pUnloadingThread;
    }

    static Thread *GetUnloadingThread()
    {
        return m_pAppDomainUnloadingThread;
    }

    static UINT32 AllocateGlobalInterfaceId();

    static LPVOID * GetAddressOfGlobalInterfaceVTableMap()
    {
        return m_pGlobalInterfaceVTableMap;
    }

    //****************************************************************************************
    // Routines to deal with the base library (currently mscorlib.dll)
    LPWSTR BaseLibrary()
    {
        return m_pBaseLibrary.String();
    }

    BOOL IsBaseLibrary(LPCWSTR file)
    {
        if(file == NULL) return FALSE;
        if(_wcsicmp(file, m_pBaseLibrary.String()) == 0) 
            return TRUE;
        else
            return FALSE;
    }

    // Return the system directory
    LPWSTR SystemDirectory()
    {
        return m_pSystemDirectory.String();
    }

    // Returns true if the given path points to a file to be loaded into the 
    // system domain
    BOOL IsSystemFile(LPCWSTR file);

private:

    //****************************************************************************************
    // Helper function to create and a new domain. pRoot is the list of domains and
    // it returns the new domain in ppDomain. A lock must be taken before calling this routine
    static HRESULT NewDomain(AppDomain** ppDomain);

    //****************************************************************************************
    // Helper function to create the single COM domain
    HRESULT CreateDefaultDomain(); 
    static HRESULT SetDefaultDomainAttributes(IMDInternalImport* pScope, mdMethodDef mdMethod);
    
    //****************************************************************************************
    // Helper function to add a domain to the global list
    void AddDomain(AppDomain* pDomain);

    HRESULT CreatePreallocatedExceptions();

    //****************************************************************************************
    //
    static StackWalkAction CallersMethodCallback(CrawlFrame* pCrawlFrame, VOID* pClientData);
    static StackWalkAction CallersMethodCallbackWithStackMark(CrawlFrame* pCrawlFrame, VOID* pClientData);

    // This class is not to be created through normal allocation.
    SystemDomain()
    {
        m_pChildren = NULL;
        m_pDefaultDomain = NULL;
        m_pPool = NULL;
        m_pBaseComObjectClass = NULL;
        m_dwZapLogDirectory = 0;
    }

    Assembly*   m_pSystemAssembly;  // Single assembly (here for quicker reference);
    AppDomain*  m_pChildren;        // Children domain
    AppDomain*  m_pDefaultDomain;   // Default domain for COM+ classes exposed through IClassFactory.
    AppDomain*  m_pPool;            // Created and pooled objects
    MethodTable* m_pBaseComObjectClass; // The default wrapper class for COM
    
    CQuickString m_pBaseLibrary;
    CQuickString m_pSystemDirectory;

    WCHAR       m_pZapLogDirectory[MAX_PATH];
    DWORD       m_dwZapLogDirectory;

    LPWSTR      m_pwDevpath;
    DWORD       m_dwDevpath;
    BOOL        m_fDevpath;  // have we searched the environment

    // @TODO: CTS, we can keep the com modules in a single assembly or in different assemblies.
    // We are currently using different assemblies but this is potentitially to slow...

    // Global domain that every one uses
    static SystemDomain* m_pSystemDomain;

    // Note: this class cannot have a constructor. It is defined globally
    // and we do not want to have the CRT call class constructors
    static Crst   *m_pSystemDomainCrst;
    static BYTE    m_pSystemDomainCrstMemory[sizeof(Crst)];

    static ICorRuntimeHost* m_pCorHost;

    static ArrayList    m_appDomainIndexList;
    static ArrayList    m_appDomainIdList; 

    // only one ad can be unloaded at a time
    static AppDomain*   m_pAppDomainBeingUnloaded;
    // need this so can determine AD being unloaded after it has been deleted
    static DWORD        m_dwIndexOfAppDomainBeingUnloaded;

    // if had to spin off a separate thread to do the unload, this is the original thread.
    // allows us to delay aborting it until it's the last one so that it can receive
    // notification of an unload failure
    static Thread *m_pAppDomainUnloadRequestingThread;

    // this is the thread doing the actual unload. He's allowed to enter the domain
    // even if have started unloading.
    static Thread *m_pAppDomainUnloadingThread;

    static GlobalStringLiteralMap *m_pGlobalStringLiteralMap;

    static ULONG       s_dNumAppDomains;  // Maintain a count of children app domains.

    static DWORD        m_dwLowestFreeIndex;

    //-------------------------------------------------------------------
    // Allocation of global interface ids and the global interface vtable map
    //-------------------------------------------------------------------
    enum {
        // This constant places an upper limit on the total number of unique interfaces
        // that can be loaded across all appdomains (non-shared interfaces loaded into
        // multiple appdomains count multiply.)
        //
        // @todo: This can be made more flexible by allocating larger sized vtable maps
        // if the limit is exceeded. However, the old ones cannot be reclaimed and must
        // be continued to be updated in parallel with the new ones.
        kNumPagesForGlobalInterfaceVTableMap = 64,
    };

    // This points to a large reserved area of memory (pages are committed as needed.)
    // that serves as a single vtable map for ComWrappers and transparent proxies (these
    // classes "acquire" interfaces on demand.)
    //
    // If id #N is use, the Nth slot points to the vtable for that interface.
    //
    // Slots corresponding to unused ids are reserved for the SystemDomain's private use
    // (we use it to maintain a free list.)
    static LPVOID *m_pGlobalInterfaceVTableMap;

    static DWORD   m_dwNumPagesCommitted;
    static size_t   m_dwFirstFreeId;
};

//
// an AppDomainIterator is used to iterate over all existing domains. 
//
// The iteration is guaranteed to include all domains that exist at the
// start & end of the iteration.  Any domains added or deleted during 
// iteration may or may not be included.  The iterator also guarantees
// that the current iterated appdomain (GetDomain()) will not be deleted.
//

class AppDomainIterator
{
    friend SystemDomain;

  public:
    AppDomainIterator()
    {
        m_i = SystemDomain::System()->m_appDomainIndexList.Iterate();
        m_pCurrent = NULL;
    }
        
    ~AppDomainIterator()
    {
        if (m_pCurrent != NULL)
            m_pCurrent->Release();
    }

    BOOL Next()
    {
        if (m_pCurrent != NULL)
            m_pCurrent->Release();

        SystemDomain::Enter();

        while (m_i.Next())
        {
            m_pCurrent = (AppDomain*) m_i.GetElement();
            if (m_pCurrent != NULL && m_pCurrent->IsOpen())
            {
                m_pCurrent->AddRef();
                SystemDomain::Leave();
                return TRUE;
            }
        }

        SystemDomain::Leave();

        m_pCurrent = NULL;
        return FALSE;
    }

    AppDomain *GetDomain()
    {
        return m_pCurrent;
    }
        
  private:

    ArrayList::Iterator m_i;
    AppDomain           *m_pCurrent;
};


class SharedDomain : public BaseDomain
{
    friend struct MEMBER_OFFSET_INFO(SharedDomain);


    struct DLSRecord
    {
        Module *pModule;
        DWORD   DLSBase;
    };

  public:

    static HRESULT Attach();
    static void Detach();

    virtual BOOL IsSharedDomain() { return TRUE; }

    static SharedDomain *GetDomain();

    HRESULT Init();
    void Terminate();

    HRESULT FindShareableAssembly(BYTE *pBase, Assembly **ppAssembly);
    HRESULT AddShareableAssembly(Assembly **ppAssembly, AssemblySecurityDescriptor **ppSecDesc);

    SIZE_T AllocateSharedClassIndices(SIZE_T count);
    SIZE_T AllocateSharedClassIndices(Module *pModule, SIZE_T count);
    SIZE_T GetMaxSharedClassIndex() { return m_nextClassIndex; }

    MethodTable *FindIndexClass(SIZE_T index);

    void ReleaseFusionInterfaces();

    class SharedAssemblyIterator
    {
        PtrHashMap::PtrIterator i;
        Assembly *m_pAssembly;

      public:
        SharedAssemblyIterator() : 
          i(GetDomain()->m_assemblyMap.begin()) { }

        BOOL Next() 
        { 
            if (i.end()) 
                return FALSE; 

            m_pAssembly = (Assembly *) i.GetValue();
            ++i;
            return TRUE;
        }

        Assembly *GetAssembly() 
        { 
            return m_pAssembly; 
        }

      private:
        friend SharedDomain;
    };

  private:
    friend SharedAssemblyIterator;

    void *operator new(size_t size, void *pInPlace);
    void operator delete(void *pMem);

    static SharedDomain     *m_pSharedDomain;
    static Crst             *m_pSharedDomainCrst;
    static BYTE             m_pSharedDomainCrstMemory[sizeof(Crst)];

    SIZE_T                  m_nextClassIndex;
    PtrHashMap              m_assemblyMap;

    DLSRecord               *m_pDLSRecords;
    DWORD                   m_cDLSRecords;
    DWORD                   m_aDLSRecords;

    // Hash map comparison function`
    static BOOL CanLoadAssembly(UPTR u1, UPTR u2);
};

inline void DomainLocalBlock::SetClass(SIZE_T ID, DomainLocalClass *pLocalClass)
{
    _ASSERTE(m_cSlots > ID);
    _ASSERTE(GetRawClass(ID) == NULL);

    _ASSERTE(m_pDomain->OwnDomainLocalBlockLock());

    m_pSlots[ID] = (SIZE_T) pLocalClass;

    _ASSERTE(!IsClassInitialized(ID));
    _ASSERTE(!IsClassInitError(ID));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include <wchar.h>
#include <winbase.h>
#include "process.h"

#include "AppDomain.hpp"
#include "Field.h"
#include "security.h"
#include "COMString.h"
#include "COMStringBuffer.h"
#include "COMClass.h"
#include "CorPermE.h"
#include "utilcode.h"
#include "excep.h"
#include "wsperf.h"
#include "eeconfig.h"
#include "gc.h"
#include "AssemblySink.h"
#include "PerfCounters.h"
#include "AssemblyName.hpp"
#include "fusion.h"
#include "EEProfInterfaces.h"
#include "DbgInterface.h"
#include "EEDbgInterfaceImpl.h"
#include "COMDynamic.h"
#include "ComPlusWrapper.h"
#include "mlinfo.h"
#include "remoting.h"
#include "ComCallWrapper.h"
#include "PostError.h"
#include "AssemblyNative.hpp"
#include "jumptargettable.h"
#include "compile.h"
#include "FusionBind.h"
#include "ShimLoad.h"
#include "StringLiteralMap.h"
#include "Timeline.h"
#include "nlog.h"
#include "AppDomainHelper.h"
#include "MngStdInterfaces.h"
#include <version/corver.ver>
#include "codeman.h"
#include "comcall.h"
#include "sxshelpers.h"

#include "listlock.inl"
#include "threads.inl"
#include "appdomain.inl"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED

// Define these macro's to do strict validation for jit lock and class
// init entry leaks.  This defines determine if the asserts that
// verify for these leaks are defined or not.  These asserts can
// sometimes go off even if no entries have been leaked so this
// defines should be used with caution.
//
// If we are inside a .cctor when the application shut's down then the
// class init lock's head will be set and this will cause the assert
// to go off.
//
// If we are jitting a method when the application shut's down then
// the jit lock's head will be set causing the assert to go off.

//#define STRICT_CLSINITLOCK_ENTRY_LEAK_DETECTION

#ifdef DEBUGGING_SUPPORTED
extern EEDebugInterface      *g_pEEInterface;
#endif // DEBUGGING_SUPPORTED

// The initial number of buckets in the constant string literal hash tables.
#define INIT_NUM_UNICODE_STR_BUCKETS 64
#define INIT_NUM_UTF8_STR_BUCKETS 64

#define DEFAULT_DOMAIN_FRIENDLY_NAME L"DefaultDomain"

// the following two constants must be updated together.
// the CCH_ one is the number of characters in the string,
// not including the terminating null.
#define OTHER_DOMAIN_FRIENDLY_NAME_PREFIX L"Domain"
#define CCH_OTHER_DOMAIN_FRIENDLY_NAME_PREFIX 6

#define STATIC_OBJECT_TABLE_BUCKET_SIZE 1020

typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE  hActCtx;
    DWORD   dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

//#define _DEBUG_ADUNLOAD 1

HRESULT RunDllMain(MethodDesc *pMD, HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved); // clsload.cpp

// Statics
// Static fields in BaseDomain
BOOL                BaseDomain::m_fStrongAssemblyStatus      = FALSE;
BOOL                BaseDomain::m_fShadowCopy                = FALSE;
BOOL                BaseDomain::m_fExecutable                = FALSE;

DWORD BaseDomain::m_dwSharedTLS;
DWORD BaseDomain::m_dwSharedCLS;

// Shared Domain Statics
SharedDomain*       SharedDomain::m_pSharedDomain = NULL;
static              g_pSharedDomainMemory[sizeof(SharedDomain)];

Crst*               SharedDomain::m_pSharedDomainCrst = NULL;
BYTE                SharedDomain::m_pSharedDomainCrstMemory[sizeof(Crst)];

// System Domain Statics
SystemDomain*       SystemDomain::m_pSystemDomain = NULL;
ICorRuntimeHost*    SystemDomain::m_pCorHost = NULL;
GlobalStringLiteralMap* SystemDomain::m_pGlobalStringLiteralMap = NULL;

static              g_pSystemDomainMemory[sizeof(SystemDomain)];

Crst *              SystemDomain::m_pSystemDomainCrst = NULL;
BYTE                SystemDomain::m_pSystemDomainCrstMemory[sizeof(Crst)];

ULONG               SystemDomain::s_dNumAppDomains = 0;

AppDomain *         SystemDomain::m_pAppDomainBeingUnloaded = NULL;
DWORD               SystemDomain::m_dwIndexOfAppDomainBeingUnloaded = 0;
Thread            *SystemDomain::m_pAppDomainUnloadRequestingThread = 0;
Thread            *SystemDomain::m_pAppDomainUnloadingThread = 0;

ArrayList           SystemDomain::m_appDomainIndexList;
ArrayList           SystemDomain::m_appDomainIdList;

LPVOID              *SystemDomain::m_pGlobalInterfaceVTableMap = NULL;
DWORD               SystemDomain::m_dwNumPagesCommitted       = 0;
size_t              SystemDomain::m_dwFirstFreeId            = -1;

DWORD               SystemDomain::m_dwLowestFreeIndex        = 0;

// App domain statics
AssemblySpec        *AppDomain::g_pSpecialAssemblySpec        = NULL;
LPUTF8              AppDomain::g_pSpecialObjectName          = NULL;
LPUTF8              AppDomain::g_pSpecialStringName          = NULL;
LPUTF8              AppDomain::g_pSpecialStringBuilderName   = NULL;


// comparison function to be used for matching clsids in our clsid hash table
BOOL CompareCLSID(UPTR u1, UPTR u2)
{
    GUID *pguid = (GUID *)(u1 << 1);
    _ASSERTE(pguid != NULL);

    EEClass* pClass = (EEClass *)u2;
    _ASSERTE(pClass != NULL);

    GUID guid;
    pClass->GetGuid(&guid, TRUE);
    if (!IsEqualIID(guid, *pguid))
        return FALSE;

    // Make sure this class is really loaded in the current app domain.
    // (See comments in InsertClassForCLSID for more info.)

    if (GetAppDomain()->ShouldContainAssembly(pClass->GetAssembly(), TRUE) == S_OK)
        return TRUE;
    else
        return FALSE;
}


// Constructor for the LargeHeapHandleBucket class.
LargeHeapHandleBucket::LargeHeapHandleBucket(LargeHeapHandleBucket *pNext, DWORD Size, BaseDomain *pDomain)
: m_pNext(pNext)
, m_ArraySize(Size)
, m_CurrentPos(0)
{
    _ASSERTE(pDomain);

#if defined(_DEBUG)
    // In a debug build lets stress the large heap handle table by limiting the size
    // of each bucket.
    if (DbgRandomOnExe(.5))
        m_ArraySize = 50;
#endif

    // Allocate the array in the large object heap.
    PTRARRAYREF HandleArrayObj = (PTRARRAYREF)AllocateObjectArray(Size, g_pObjectClass, TRUE);

    // Retrieve the pointer to the data inside the array. This is legal since the array
    // is located in the large object heap and is guaranteed not to move.
    m_pArrayDataPtr = (OBJECTREF *)HandleArrayObj->GetDataPtr();

    // Store the array in a strong handle to keep it alive.
    m_hndHandleArray = pDomain->CreateHandle((OBJECTREF)HandleArrayObj);
}


// Destructor for the LargeHeapHandleBucket class.
LargeHeapHandleBucket::~LargeHeapHandleBucket()
{
    if (m_hndHandleArray)
    {
        DestroyHandle(m_hndHandleArray);
        m_hndHandleArray = NULL;
    }
}


// Allocate handles from the bucket.
void LargeHeapHandleBucket::AllocateHandles(DWORD nRequested, OBJECTREF **apObjRefs)
{
    _ASSERTE(nRequested > 0 && nRequested <= GetNumRemainingHandles());
    _ASSERTE(m_pArrayDataPtr == (OBJECTREF*)((PTRARRAYREF)ObjectFromHandle(m_hndHandleArray))->GetDataPtr());

    // Store the handles in the buffer that was passed in.
    for (DWORD i = 0; i < nRequested; i++)
        apObjRefs[i] = &m_pArrayDataPtr[m_CurrentPos++];
}


// Constructor for the LargeHeapHandleTable class.
LargeHeapHandleTable::LargeHeapHandleTable(BaseDomain *pDomain, DWORD BucketSize)
: m_pDomain(pDomain)
, m_BucketSize(BucketSize)
{
    THROWSCOMPLUSEXCEPTION();

    m_pHead = new (throws) LargeHeapHandleBucket(NULL, BucketSize, pDomain);
}


// Destructor for the LargeHeapHandleTable class.
LargeHeapHandleTable::~LargeHeapHandleTable()
{
    // Delete the buckets.
    while (m_pHead)
    {
        LargeHeapHandleBucket *pOld = m_pHead;
        m_pHead = pOld->GetNext();
        delete pOld;
    }

    // Delete the available entries.
    LargeHeapAvailableHandleEntry *pEntry = m_AvailableHandleList.RemoveHead();
    while (pEntry)
    {
        delete pEntry;
        pEntry = m_AvailableHandleList.RemoveHead();
    }
}


// Allocate handles from the large heap handle table.
void LargeHeapHandleTable::AllocateHandles(DWORD nRequested, OBJECTREF **apObjRefs)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(nRequested > 0);
    _ASSERTE(apObjRefs);

    // Start by re-using the available handles.
    for (; nRequested > 0; nRequested--)
    {
        // Retrieve the next available handle to use.
        LargeHeapAvailableHandleEntry *pEntry = m_AvailableHandleList.RemoveHead();
        if (!pEntry)
            break;

        // Set the handle in the array of requested handles.
        apObjRefs[0] = pEntry->m_pObjRef;
        apObjRefs++;

        // Delete the entry that contained the handle.
        delete pEntry;
    }

    // Allocate new handles from the buckets.
    while (nRequested > 0)
    {
        // Retrieve the remaining number of handles in the bucket.
        DWORD NumRemainingHandlesInBucket = m_pHead->GetNumRemainingHandles();

        if (NumRemainingHandlesInBucket >= nRequested)
        {
            // The handle bucket has enough handles to satisfy the request.
            m_pHead->AllocateHandles(nRequested, apObjRefs);
            break;
        }
        else
        {
            if (NumRemainingHandlesInBucket > 0)
            {
                // The handle bucket has some handles left but not enough so allocate
                // all the remaining ones.
                m_pHead->AllocateHandles(NumRemainingHandlesInBucket, apObjRefs);

                // Update the remaining number of reqested handles and the pointer to the
                // buffer that will contain the handles.
                nRequested -= NumRemainingHandlesInBucket;
                apObjRefs += NumRemainingHandlesInBucket;
            }

            // Create a new bucket from which we will allocate the remainder of
            // the requested handles.
            m_pHead = new (throws) LargeHeapHandleBucket(m_pHead, m_BucketSize, m_pDomain);
        }
    }
}


// Release object handles allocated using AllocateHandles().
void LargeHeapHandleTable::ReleaseHandles(DWORD nReleased, OBJECTREF **apObjRefs)
{
    // Add the released handles to the list of available handles.
    for (DWORD i = 0; i < nReleased; i++)
    {
        *apObjRefs[i] = NULL;
        LargeHeapAvailableHandleEntry *pEntry = new (nothrow) LargeHeapAvailableHandleEntry(apObjRefs[i]);
        if (pEntry)
            m_AvailableHandleList.InsertHead(pEntry);
    }
}


//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

HRESULT BaseDomain::Init()
{
    HRESULT     hr = S_OK;

    // initialize all members up front to NULL so that short-circuit failure won't cause invalid values
    m_InitialReservedMemForLoaderHeaps = NULL;
    m_pLowFrequencyHeap = NULL;
    m_pHighFrequencyHeap = NULL;
    m_pStubHeap = NULL;
    m_pDomainCrst = NULL;
    m_pDomainCacheCrst = NULL;
    m_pDomainLocalBlockCrst = NULL;
    m_pLoadingAssemblyListLockCrst = NULL;
    m_pFusionContext = NULL;
    m_pLoadingAssemblies = NULL;
    m_pLargeHeapHandleTableCrst = NULL;

    // Make sure the container is set to NULL so that it gets loaded when it is used.
    m_pLargeHeapHandleTable = NULL;

    // Note that m_hHandleTable is overriden by app domains
    m_hHandleTable = g_hGlobalHandleTable;

    m_pStringLiteralMap = NULL;
    m_pMarshalingData = NULL;
    m_pMngStdInterfacesInfo = NULL;

    // Init the template for thread local statics of this domain
    m_dwUnsharedTLS = 0;

    // Init the template for context local statics of this domain
    m_dwUnsharedCLS = 0;

    // Initialize Shared state. Assemblies are loaded
    // into each domain by default.
    m_SharePolicy = SHARE_POLICY_UNSPECIFIED;

    m_pRefMemberMethodsCache = NULL;
    m_pRefDispIDCache = NULL;
    m_pRefClassFactHash = NULL;
    m_pReflectionCrst = NULL;
    m_pRefClassFactHash = NULL;

#ifdef PROFILING_SUPPORTED
    // Signal profile if present.
    if (CORProfilerTrackAppDomainLoads())
        g_profControlBlock.pProfInterface->AppDomainCreationStarted((ThreadID) GetThread(), (AppDomainID) this);
#endif // PROFILING_SUPPORTED

    DWORD dwTotalReserveMemSize = LOW_FREQUENCY_HEAP_RESERVE_SIZE + HIGH_FREQUENCY_HEAP_RESERVE_SIZE + STUB_HEAP_RESERVE_SIZE + INTERFACE_VTABLE_MAP_MGR_RESERVE_SIZE;
    dwTotalReserveMemSize = (dwTotalReserveMemSize + MIN_VIRTUAL_ALLOC_RESERVE_SIZE - 1) & ~(MIN_VIRTUAL_ALLOC_RESERVE_SIZE - 1);

    DWORD dwInitialReservedMemSize = max (dwTotalReserveMemSize, MIN_VIRTUAL_ALLOC_RESERVE_SIZE);

    BYTE * initReservedMem = m_InitialReservedMemForLoaderHeaps = (BYTE *)VirtualAlloc (0, dwInitialReservedMemSize, MEM_RESERVE, PAGE_READWRITE);

    if (initReservedMem == NULL)
        IfFailGo(E_OUTOFMEMORY);

    m_pLowFrequencyHeap = new (&m_LowFreqHeapInstance) LoaderHeap(LOW_FREQUENCY_HEAP_RESERVE_SIZE, LOW_FREQUENCY_HEAP_COMMIT_SIZE,
                                                                  initReservedMem, LOW_FREQUENCY_HEAP_RESERVE_SIZE,
                                                                  &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize),
                                                                  &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize));
    initReservedMem += LOW_FREQUENCY_HEAP_RESERVE_SIZE;
    dwInitialReservedMemSize -= LOW_FREQUENCY_HEAP_RESERVE_SIZE;

    if (m_pLowFrequencyHeap == NULL)
        IfFailGo(E_OUTOFMEMORY);
    WS_PERF_ADD_HEAP(LOW_FREQ_HEAP, m_pLowFrequencyHeap);

    m_pHighFrequencyHeap = new (&m_HighFreqHeapInstance) LoaderHeap(HIGH_FREQUENCY_HEAP_RESERVE_SIZE, HIGH_FREQUENCY_HEAP_COMMIT_SIZE, 
                                                                    initReservedMem, HIGH_FREQUENCY_HEAP_RESERVE_SIZE,
                                                                    &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize),
                                                                    &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize),
                                                                    &MethodDescPrestubManager::g_pManager->m_rangeList);
    initReservedMem += HIGH_FREQUENCY_HEAP_RESERVE_SIZE;
    dwInitialReservedMemSize -= HIGH_FREQUENCY_HEAP_RESERVE_SIZE;
    
    if (m_pHighFrequencyHeap == NULL)
        IfFailGo(E_OUTOFMEMORY);
    WS_PERF_ADD_HEAP(HIGH_FREQ_HEAP, m_pHighFrequencyHeap);

    m_pStubHeap = new (&m_StubHeapInstance) LoaderHeap(STUB_HEAP_RESERVE_SIZE, STUB_HEAP_COMMIT_SIZE, 
                                                       initReservedMem, STUB_HEAP_RESERVE_SIZE,
                                                       &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize),
                                                       &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize),
                                                       &StubLinkStubManager::g_pManager->m_rangeList);

    initReservedMem += STUB_HEAP_RESERVE_SIZE;
    dwInitialReservedMemSize -= STUB_HEAP_RESERVE_SIZE;

    if (m_pStubHeap == NULL)
        IfFailGo(E_OUTOFMEMORY);
    WS_PERF_ADD_HEAP(STUB_HEAP, m_pStubHeap);

    if (this == (BaseDomain*) g_pSharedDomainMemory)
        m_pDomainCrst = ::new Crst("SharedBaseDomain", CrstSharedBaseDomain, FALSE, FALSE);
    else if (this == (BaseDomain*) g_pSystemDomainMemory)
        m_pDomainCrst = ::new Crst("SystemBaseDomain", CrstSystemBaseDomain, FALSE, FALSE);
    else
        m_pDomainCrst = ::new Crst("BaseDomain", CrstBaseDomain, FALSE, FALSE);
    if(m_pDomainCrst == NULL)
        IfFailGo(E_OUTOFMEMORY);

    m_pDomainCacheCrst = ::new Crst("AppDomainCache", CrstAppDomainCache, FALSE, FALSE);
    if(m_pDomainCacheCrst == NULL)
        IfFailGo(E_OUTOFMEMORY);

    m_pDomainLocalBlockCrst = ::new Crst("DomainLocalBlock", CrstDomainLocalBlock, FALSE, FALSE);
    if(m_pDomainLocalBlockCrst == NULL)
        IfFailGo(E_OUTOFMEMORY);

    m_pLoadingAssemblyListLockCrst = ::new Crst("LoadingAssemblyList", CrstSyncHashLock,TRUE, TRUE);
    if(m_pLoadingAssemblyListLockCrst == NULL)
        IfFailGo(E_OUTOFMEMORY);

    m_AssemblyLoadLock.Init("AppDomainAssembly", CrstAssemblyLoader, TRUE, TRUE);
    m_JITLock.Init("JitLock", CrstClassInit, TRUE, TRUE);
    m_ClassInitLock.Init("ClassInitLock", CrstClassInit, TRUE, TRUE);

    // Large heap handle table CRST.
    m_pLargeHeapHandleTableCrst = ::new Crst("CrstAppDomainLargeHeapHandleTable", CrstAppDomainHandleTable);
    if(m_pLargeHeapHandleTableCrst == NULL)
        IfFailGo(E_OUTOFMEMORY);

    // The AppDomain specific string literal map.
    m_pStringLiteralMap = new (nothrow) AppDomainStringLiteralMap(this);
    if (m_pStringLiteralMap == NULL)
        IfFailGo(E_OUTOFMEMORY);
    IfFailGo(m_pStringLiteralMap->Init());

    // Initialize the EE marshaling data to NULL.
    m_pMarshalingData = NULL;

    if (FAILED(m_InterfaceVTableMapMgr.Init(initReservedMem, dwInitialReservedMemSize)))
        IfFailRet(E_OUTOFMEMORY);

    // Allocate the managed standard interfaces information.
    m_pMngStdInterfacesInfo = new (nothrow) MngStdInterfacesInfo();
    if (m_pMngStdInterfacesInfo == NULL)
        IfFailGo(E_OUTOFMEMORY);

    {
        LockOwner lock = {m_pDomainCrst, IsOwnerOfCrst};
        m_clsidHash.Init(0,&CompareCLSID,true, &lock); // init hash table
    }

    // Set up the file cache
    m_AssemblyCache.InitializeTable(this, m_pDomainCacheCrst);
    m_UnmanagedCache.InitializeTable(this, m_pDomainCacheCrst);

    m_pReflectionCrst = new (m_pReflectionCrstMemory) Crst("CrstReflection", CrstReflection, FALSE, FALSE);
    m_pRefClassFactCrst = new (m_pRefClassFactCrstMemory) Crst("CrstClassFactInfoHash", CrstClassFactInfoHash, FALSE, FALSE);
    
ErrExit:
    // If the load failed, then give back the error data now.
#ifdef PROFILING_SUPPORTED
    if (FAILED(hr) && CORProfilerTrackAppDomainLoads())
        g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) this, hr);
#endif // PROFILING_SUPPORTED
    return hr;
}

void BaseDomain::Terminate()
{
//     LOG((
//         LF_CLASSLOADER,
//         INFO3,
//         "Deleting Domain %x\n"
//         "LowFrequencyHeap:    %10d bytes\n"
//         "  >Loaderheap waste: %10d bytes\n"
//         "HighFrequencyHeap:   %10d bytes\n"
//         "  >Loaderheap waste: %10d bytes\n",
//         "StubHeap:            %10d bytes\n"
//         "  >Loaderheap waste: %10d bytes\n",
//         this,
//         m_pLowFrequencyHeap->m_dwDebugTotalAlloc,
//         m_pLowFrequencyHeap->DebugGetWastedBytes(),
//         m_pHighFrequencyHeap->m_dwDebugTotalAlloc,
//         m_pHighFrequencyHeap->DebugGetWastedBytes(),
//         m_pStubHeap->m_dwDebugTotalAlloc,
//         m_pStubHeap->DebugGetWastedBytes()
//     ));

    if (m_pRefClassFactHash)
    {
        m_pRefClassFactHash->ClearHashTable();
        // storage for m_pRefClassFactHash itself is allocated on the loader heap
    }
    if (m_pReflectionCrst)
    {
        delete m_pReflectionCrst;
        m_pReflectionCrst = NULL;
    }
    
    ShutdownAssemblies();

#ifdef PROFILING_SUPPORTED
    // Signal profile if present.
    if (CORProfilerTrackAppDomainLoads())
        g_profControlBlock.pProfInterface->AppDomainShutdownStarted((ThreadID) GetThread(), (AppDomainID) this);
#endif // PROFILING_SUPPORTED

    // This must be deleted before the loader heaps are deleted.
    if (m_pMarshalingData != NULL)
    {
        delete m_pMarshalingData;
        m_pMarshalingData = NULL;
    }

    if (m_pLowFrequencyHeap != NULL)
    {
        delete(m_pLowFrequencyHeap);
        m_pLowFrequencyHeap = NULL;
    }

    if (m_pHighFrequencyHeap != NULL)
    {
        delete(m_pHighFrequencyHeap);
        m_pHighFrequencyHeap = NULL;
    }

    if (m_pStubHeap != NULL)
    {
        delete(m_pStubHeap);
        m_pStubHeap = NULL;
    }

    if (m_pDomainCrst != NULL)
    {
        ::delete m_pDomainCrst;
        m_pDomainCrst = NULL;
    }

    if (m_pDomainCacheCrst != NULL)
    {
        ::delete m_pDomainCacheCrst;
        m_pDomainCacheCrst = NULL;
    }

    if (m_pDomainLocalBlockCrst != NULL)
    {
        ::delete m_pDomainLocalBlockCrst;
        m_pDomainLocalBlockCrst = NULL;
    }

    if (m_pLoadingAssemblyListLockCrst != NULL)
    {
        ::delete m_pLoadingAssemblyListLockCrst;
        m_pLoadingAssemblyListLockCrst = NULL;
    }

    if (m_pRefClassFactCrst) {
        m_pRefClassFactCrst->Destroy();
    }

    if (m_pReflectionCrst) {
        m_pReflectionCrst->Destroy();
    }

    DeadlockAwareLockedListElement* pElement2;
    LockedListElement* pElement;

    // All the threads that are in this domain had better be stopped by this
    // point.
    //
    // We might be jitting or running a .cctor so we need to empty that queue.
    pElement = m_JITLock.Pop(TRUE);
    while (pElement)
    {
#ifdef STRICT_JITLOCK_ENTRY_LEAK_DETECTION
        _ASSERTE ((m_JITLock.m_pHead->m_dwRefCount == 1
            && m_JITLock.m_pHead->m_hrResultCode == E_FAIL) ||
            dbg_fDrasticShutdown || g_fInControlC);
#endif
        pElement->Clear();
        delete(pElement);
        pElement = m_JITLock.Pop(TRUE);

    }
    m_JITLock.Destroy();

    pElement2 = (DeadlockAwareLockedListElement*) m_ClassInitLock.Pop(TRUE);
    while (pElement2)
    {
#ifdef STRICT_CLSINITLOCK_ENTRY_LEAK_DETECTION
        _ASSERTE (dbg_fDrasticShutdown || g_fInControlC);
#endif
        pElement2->Clear();
        delete(pElement2);
        pElement2 = (DeadlockAwareLockedListElement*) m_ClassInitLock.Pop(TRUE);
    }
    m_ClassInitLock.Destroy();

    AssemblyLockedListElement* pAssemblyElement;
    pAssemblyElement = (AssemblyLockedListElement*) m_AssemblyLoadLock.Pop(TRUE);
    while (pAssemblyElement)
    {
#ifdef STRICT_CLSINITLOCK_ENTRY_LEAK_DETECTION
        _ASSERTE (dbg_fDrasticShutdown || g_fInControlC);
#endif
        pAssemblyElement->Clear();
        delete(pAssemblyElement);
        pAssemblyElement = (AssemblyLockedListElement*) m_AssemblyLoadLock.Pop(TRUE);
    }
    m_AssemblyLoadLock.Destroy();

    if (m_pLargeHeapHandleTableCrst != NULL)
    {
        ::delete m_pLargeHeapHandleTableCrst;
        m_pLargeHeapHandleTableCrst = NULL;
    }

    if (m_pLargeHeapHandleTable != NULL)
    {
        delete m_pLargeHeapHandleTable;
        m_pLargeHeapHandleTable = NULL;
    }

    if (!IsAppDomain())
    {
        // Kind of a hack - during unloading, we need to have an EE halt
        // around deleting this stuff. So it gets deleted in AppDomain::Terminate()
        // for those things (because there is a convenient place there.)

        if (m_pStringLiteralMap != NULL)
        {
            delete m_pStringLiteralMap;
            m_pStringLiteralMap = NULL;
        }
    }

    m_InterfaceVTableMapMgr.Terminate();

    if (m_pMngStdInterfacesInfo)
    {
        delete m_pMngStdInterfacesInfo;
        m_pMngStdInterfacesInfo = NULL;
    }

    // This was the block reserved by BaseDomain::Init for the loaderheaps.
    if (m_InitialReservedMemForLoaderHeaps)
        VirtualFree (m_InitialReservedMemForLoaderHeaps, 0, MEM_RELEASE);

    ClearFusionContext();

#ifdef PROFILING_SUPPORTED
    // Always signal profile if present, even when failed.
    if (CORProfilerTrackAppDomainLoads())
        g_profControlBlock.pProfInterface->AppDomainShutdownFinished((ThreadID) GetThread(), (AppDomainID) this, S_OK);
#endif // PROFILING_SUPPORTED
}

void BaseDomain::ClearFusionContext()
{
    if(m_pFusionContext) {
        m_pFusionContext->Release();
        m_pFusionContext = NULL;
    }
}

void BaseDomain::ShutdownAssemblies()
{
    // Shutdown assemblies
    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        if (i.GetAssembly()->Parent() == this)
        {
            delete i.GetAssembly();
        }
        else
            i.GetAssembly()->DecrementShareCount();
    }

    m_Assemblies.Clear();
}

void BaseDomain::AllocateObjRefPtrsInLargeTable(int nRequested, OBJECTREF **apObjRefs)
{
    THROWSCOMPLUSEXCEPTION();
    CHECKGC();

    _ASSERTE((nRequested > 0) && apObjRefs);

    Thread *pThread = SetupThread();
    if (NULL == pThread)
    {
        COMPlusThrowOM();
    }

    // Enter preemptive state, take the lock and go back to cooperative mode.
    pThread->EnablePreemptiveGC();
    m_pLargeHeapHandleTableCrst->Enter();
    pThread->DisablePreemptiveGC();

    EE_TRY_FOR_FINALLY
    {
        // Make sure the large heap handle table is initialized.
        if (!m_pLargeHeapHandleTable)
            InitLargeHeapHandleTable();

        // Allocate the handles.
        m_pLargeHeapHandleTable->AllocateHandles(nRequested, apObjRefs);
    }
    EE_FINALLY
    {
        // Release the lock now that the operation is finished.
        m_pLargeHeapHandleTableCrst->Leave();
    } EE_END_FINALLY;
}

void STDMETHODCALLTYPE
ReleaseFusionInterfaces()
{
    // Called during process detach
    g_fProcessDetach = TRUE;

    //@TODO: Need to fix shutdown to handle this more gracefully.
    // Unfortunately, if someone calls ExitProcess during a GC, we
    // could have a deadlock if we call ReleaseFusionInterfaces.
    // For now, only calling it if it's 'safe'.
    Thread *pThread = GetThread();
    if (pThread &&
        (! (g_pGCHeap->IsGCInProgress()
            && (pThread != g_pGCHeap->GetGCThread()
                || !g_fSuspendOnShutdown)) )) {
        
        if (SystemDomain::System())
            SystemDomain::System()->ReleaseFusionInterfaces();
    }
}

void SystemDomain::ReleaseFusionInterfaces()
{
#ifdef FUSION_SUPPORTED
    AppDomainIterator i;

    while (i.Next())
        i.GetDomain()->ReleaseFusionInterfaces();

    // Now release the fusion interfaces for the system domain
    BaseDomain::ReleaseFusionInterfaces();

    // And release the fusion interfaces for the shared domain
    SharedDomain::GetDomain()->ReleaseFusionInterfaces();

    FusionBind::DontReleaseFusionInterfaces();
#endif // FUSION_SUPPORTED
}

//@todo get a better key
static ULONG GetKeyFromGUID(const GUID *pguid)
{
    ULONG key = *(ULONG *) pguid;

    if (key <= DELETED)
        key = DELETED+1;

    return key;
}

EEClass*  BaseDomain::LookupClass(REFIID iid)
{
    EEClass* pClass = SystemDomain::System()->LookupClassDirect(iid);
    if (pClass != NULL)
        return pClass;

    EEClass *localFound = LookupClassDirect(iid);
    if (localFound || this == SharedDomain::GetDomain())
        return localFound;

    // so we didn't find it in our list. Now check to see if it's in
    // the shared domain list. When we initially load the class, it's
    // inserted into the shared domain table but not propogated. So if
    // we find it here and if the assembly is loaded into our
    // appdomain, then we can insert it into our table.

    pClass = SharedDomain::GetDomain()->LookupClassDirect(iid);
    if (!pClass)
        return NULL;

    // add it to our list
    InsertClassForCLSID(pClass);

    return pClass;
}

// Insert class in the hash table
void BaseDomain::InsertClassForCLSID(EEClass* pClass, BOOL fForceInsert)
{
    CVID cvid;

    //
    // Note that it is possible for multiple classes to claim the same CLSID, and in such a
    // case it is arbitrary which one we will return for a future query for a given app domain.
    //
    // There is also a more obscure but more insidious case where we have multiple classes for
    // a CLSID, and that is in the case of the shared domain.  Since the shared domain can 
    // contain multiple Assembly objects for a single dll, it may contain multiple instances of 
    // the same class.  Of course if such a class has a CLSID, there will be multiple entries of 
    // the GUID in the table.  But we still must pick an "appropriate" one for a given app domain;
    // otherwise we may hand a class out in an app domain in which it is not intended to be used.
    //
    // To deal with the latter problem, the Compare function for this hash table has extra logic
    // which checks that a class's assembly is loaded into the current app domain before returning
    // that class as a match.  Thus we should be able to have multiple entries for a single 
    // CLSID in the table, and each app domain will get the correct one when doing a lookup.
    //

    pClass->GetGuid(&cvid, fForceInsert);

    if (!IsEqualIID(cvid, GUID_NULL))
    {
        //@todo get a better key
        LPVOID val = (LPVOID)pClass;
        EnterLock();
        m_clsidHash.InsertValue(GetKeyFromGUID(&cvid), val);
        LeaveLock();
    }
}


EEMarshalingData *BaseDomain::GetMarshalingData()
{
    if (!m_pMarshalingData)
    {
        LoaderHeap *pHeap = GetLowFrequencyHeap();
        m_pMarshalingData = new (pHeap) EEMarshalingData(this, pHeap, m_pDomainCrst);
    }

    return m_pMarshalingData;
}


STRINGREF *BaseDomain::GetStringObjRefPtrFromUnicodeString(EEStringData *pStringData)
{
    CHECKGC();
    _ASSERTE(pStringData && m_pStringLiteralMap);
    return m_pStringLiteralMap->GetStringLiteral(pStringData, TRUE, !CanUnload() /* bAppDOmainWontUnload */);
}

STRINGREF *BaseDomain::IsStringInterned(STRINGREF *pString)
{
    CHECKGC();
    _ASSERTE(pString && m_pStringLiteralMap);
    return m_pStringLiteralMap->GetInternedString(pString, FALSE, !CanUnload() /* bAppDOmainWontUnload */);
}

STRINGREF *BaseDomain::GetOrInternString(STRINGREF *pString)
{
    CHECKGC();
    _ASSERTE(pString && m_pStringLiteralMap);
    return m_pStringLiteralMap->GetInternedString(pString, TRUE, !CanUnload() /* bAppDOmainWontUnload */);
}

void BaseDomain::InitLargeHeapHandleTable()
{
    THROWSCOMPLUSEXCEPTION();

    // Make sure this method is not called twice.
    _ASSERTE( !m_pLargeHeapHandleTable );

    m_pLargeHeapHandleTable = new (throws) LargeHeapHandleTable(this, STATIC_OBJECT_TABLE_BUCKET_SIZE);
}

void BaseDomain::SetStrongAssemblyStatus()
{
#ifdef _DEBUG
    m_fStrongAssemblyStatus = EEConfig::GetConfigDWORD(L"RequireStrongAssemblies", m_fStrongAssemblyStatus);
#endif
}

HRESULT AppDomain::GetServerObject(OBJECTREF proxy, OBJECTREF* result) // GCPROTECT proxy and result!
{
    CHECKGC();
    HRESULT hr = S_OK;

    COMPLUS_TRY {

        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__GET_SERVER_OBJECT);
        
        INT64 arg = ObjToInt64(proxy);

        *result = Int64ToObj(pMD->Call(&arg, METHOD__APP_DOMAIN__GET_SERVER_OBJECT));
    }
    COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH
    return hr;
}


MethodTable* AppDomain::GetLicenseInteropHelperMethodTable(ClassLoader *pLoader)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(g_EnableLicensingInterop);

    if(m_pLicenseInteropHelperMT == NULL) {

        BEGIN_ENSURE_PREEMPTIVE_GC();
        EnterLock();
        END_ENSURE_PREEMPTIVE_GC();

        EE_TRY_FOR_FINALLY
        {
        if(m_pLicenseInteropHelperMT == NULL) {

            TypeHandle licenseMgrTypeHnd;
            MethodDesc *pLoadLMMD = g_Mscorlib.GetMethod(METHOD__MARSHAL__LOAD_LICENSE_MANAGER);
            //INT64 arg = (INT64) &licenseMgrTypeHnd;
            *(PTR_TYPE *) &licenseMgrTypeHnd = (PTR_TYPE) pLoadLMMD->Call( NULL, METHOD__MARSHAL__LOAD_LICENSE_MANAGER);

            //
            // Look up this method by name, because the type is actually declared in System.dll.  @todo: why?
            // 

            MethodDesc *pGetLIHMD = licenseMgrTypeHnd.AsMethodTable()->GetClass()->FindMethod("GetLicenseInteropHelperType", 
                                                                                              &gsig_IM_Void_RetRuntimeTypeHandle);
            _ASSERTE(pGetLIHMD);

            TypeHandle lihTypeHnd;
            //TypeHandle* args = &lihTypeHnd;
            MetaSig msig2(pGetLIHMD->GetSig(), pGetLIHMD->GetModule());
            *(PTR_TYPE *) &lihTypeHnd = (PTR_TYPE) pGetLIHMD->Call( (BYTE *) NULL, &msig2);

            m_pLicenseInteropHelperMT = lihTypeHnd.AsMethodTable();
            }
        }
        EE_FINALLY
        {
        LeaveLock();
        }
        EE_END_FINALLY

    }
    return m_pLicenseInteropHelperMT;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

void *SystemDomain::operator new(size_t size, void *pInPlace)
{
    return pInPlace;
}


void SystemDomain::operator delete(void *pMem)
{
    // Do nothing - new() was in-place
}


HRESULT SystemDomain::Attach()
{
    _ASSERTE(m_pSystemDomain == NULL);
    if(m_pSystemDomain != NULL)
        return COR_E_EXECUTIONENGINE;

    // Initialize stub managers
    if (!MethodDescPrestubManager::Init()
        || !StubLinkStubManager::Init()
        || !X86JumpTargetTableStubManager::Init()
        || !ThunkHeapStubManager::Init()
        || !IJWNOADThunkStubManager::Init())
        return COR_E_OUTOFMEMORY;

    if(m_pSystemDomainCrst == NULL)
        m_pSystemDomainCrst = new (&m_pSystemDomainCrstMemory) Crst("SystemDomain", CrstSystemDomain, TRUE, FALSE);
    if(m_pSystemDomainCrst == NULL)
        return COR_E_OUTOFMEMORY;

    if (m_pGlobalInterfaceVTableMap == NULL)
    {
        m_pGlobalInterfaceVTableMap = (LPVOID*)VirtualAlloc(NULL, kNumPagesForGlobalInterfaceVTableMap * OS_PAGE_SIZE, MEM_RESERVE, PAGE_READWRITE);
        if (!m_pGlobalInterfaceVTableMap)
            return COR_E_OUTOFMEMORY;
    }

    // Create the global SystemDomain and initialize it.
    m_pSystemDomain = new (&g_pSystemDomainMemory) SystemDomain();
    if(m_pSystemDomain == NULL) return COR_E_OUTOFMEMORY;

    LOG((LF_CLASSLOADER,
         LL_INFO10,
         "Created system domain at %x\n",
         m_pSystemDomain));

    // We need to initialize the memory pools etc. for the system domain.
    HRESULT hr = m_pSystemDomain->BaseDomain::Init(); // Setup the memory heaps
    if(FAILED(hr)) return hr;

    m_pSystemDomain->GetInterfaceVTableMapMgr().SetShared();

    // Create the default domain
    hr = m_pSystemDomain->CreateDefaultDomain();
    if(FAILED(hr)) return hr;

    hr = SharedDomain::Attach();

    return hr;
}


BOOL SystemDomain::DetachBegin()
{
    // Shut down the domain and its children (but don't deallocate anything just
    // yet).
    if(m_pSystemDomain)
        m_pSystemDomain->Stop();

    if(m_pCorHost)
        m_pCorHost->Release();

    return TRUE;
}


#ifdef SHOULD_WE_CLEANUP
BOOL SystemDomain::DetachEnd()
{

    // Now we can start deleting things.
    if(m_pSystemDomain) {
        m_pSystemDomain->Terminate();
        delete m_pSystemDomain;
        m_pSystemDomain = NULL;
    }

    // Uninitialize stub managers
    MethodDescPrestubManager::Uninit();
    StubLinkStubManager::Uninit();
    X86JumpTargetTableStubManager::Uninit();
    UpdateableMethodStubManager::Uninit();
    ThunkHeapStubManager::Uninit();
    IJWNOADThunkStubManager::Uninit();

    if(m_pSystemDomainCrst) {
        delete m_pSystemDomainCrst;
        m_pSystemDomainCrst = NULL;
    }

    if (m_pGlobalInterfaceVTableMap)
    {
        BOOL success;
        success = VirtualFree(m_pGlobalInterfaceVTableMap, m_dwNumPagesCommitted * OS_PAGE_SIZE, MEM_DECOMMIT);
        _ASSERTE(success);

        success = VirtualFree(m_pGlobalInterfaceVTableMap, 0, MEM_RELEASE);
        _ASSERTE(success);
    }


    return TRUE;
}
#endif /* SHOULD_WE_CLEANUP */


void SystemDomain::Stop()
{
    AppDomainIterator i;

    while (i.Next())
        i.GetDomain()->Stop();
}


void SystemDomain::Terminate()
{

    if (SystemDomain::BeforeFusionShutdown())
        ReleaseFusionInterfaces();

    // This ignores the refences and terminates the appdomains
    AppDomainIterator i;

    while (i.Next())
    {
        delete i.GetDomain();
        // Keep the iterator from Releasing the current domain
        i.m_pCurrent = NULL;
    }

    m_pSystemAssembly = NULL;

    if(m_pwDevpath) {
        delete m_pwDevpath;
        m_pwDevpath = NULL;
    }
    m_dwDevpath = 0;
    m_fDevpath = FALSE;
    
    if (m_pGlobalStringLiteralMap) {
        delete m_pGlobalStringLiteralMap;
        m_pGlobalStringLiteralMap = NULL;
    }

    ShutdownAssemblies();

    SharedDomain::Detach();

    BaseDomain::Terminate();

    if (AppDomain::g_pSpecialAssemblySpec != NULL)
        delete AppDomain::g_pSpecialAssemblySpec;
    if (AppDomain::g_pSpecialObjectName != NULL)
        delete [] AppDomain::g_pSpecialObjectName;
    if (AppDomain::g_pSpecialStringName != NULL)
        delete [] AppDomain::g_pSpecialStringName;
    if (AppDomain::g_pSpecialStringBuilderName != NULL)
        delete [] AppDomain::g_pSpecialStringBuilderName;

    if (g_pRCWCleanupList != NULL)
        delete g_pRCWCleanupList;
}

HRESULT SystemDomain::CreatePreallocatedExceptions()
{
    HRESULT hr = S_OK;

    if (g_pPreallocatedOutOfMemoryException)
        return hr;

    if (g_pPreallocatedOutOfMemoryException == NULL)
        g_pPreallocatedOutOfMemoryException = CreateHandle( NULL );

    if (g_pPreallocatedStackOverflowException == NULL)
        g_pPreallocatedStackOverflowException = CreateHandle( NULL );

    if (g_pPreallocatedExecutionEngineException == NULL)
        g_pPreallocatedExecutionEngineException = CreateHandle( NULL );

    COMPLUS_TRY
    {
        FieldDesc   *pFDhr = g_Mscorlib.GetField(FIELD__EXCEPTION__HRESULT);
        FieldDesc   *pFDxcode = g_Mscorlib.GetField(FIELD__EXCEPTION__XCODE);
        if (ObjectFromHandle(g_pPreallocatedOutOfMemoryException) == 0)
        {
            OBJECTREF pOutOfMemory = AllocateObject(g_pOutOfMemoryExceptionClass);
            StoreObjectInHandle(g_pPreallocatedOutOfMemoryException, pOutOfMemory);
            pFDhr->SetValue32(pOutOfMemory, COR_E_OUTOFMEMORY);
            pFDxcode->SetValue32(pOutOfMemory, EXCEPTION_COMPLUS);
        }
        if (ObjectFromHandle(g_pPreallocatedStackOverflowException) == 0)
        {
            OBJECTREF pStackOverflow = AllocateObject(g_pStackOverflowExceptionClass);
            StoreObjectInHandle(g_pPreallocatedStackOverflowException, pStackOverflow);
            pFDhr->SetValue32(pStackOverflow, COR_E_STACKOVERFLOW);
            pFDxcode->SetValue32(pStackOverflow, EXCEPTION_COMPLUS);
        }
        if (ObjectFromHandle(g_pPreallocatedExecutionEngineException) == 0)
        {
            OBJECTREF pExecutionEngine = AllocateObject(g_pExecutionEngineExceptionClass);
            StoreObjectInHandle(g_pPreallocatedExecutionEngineException, pExecutionEngine);
            pFDhr->SetValue32(pExecutionEngine, COR_E_EXECUTIONENGINE);
            pFDxcode->SetValue32(pExecutionEngine, EXCEPTION_COMPLUS);
        }
    }
    COMPLUS_CATCH
    {
        hr = E_OUTOFMEMORY;
    }
    COMPLUS_END_CATCH

    return hr;
}


HRESULT SystemDomain::Init()
{
    HRESULT hr = S_OK;

#ifdef _DEBUG
    LOG((
        LF_EEMEM,
        LL_INFO10,
        "(adjusted to remove debug fields)\n"
        "sizeof(EEClass)     = %d\n"
        "sizeof(MethodTable) = %d\n"
        "sizeof(MethodDesc)= %d\n"
        "sizeof(MethodDesc)  = %d\n"
        "sizeof(FieldDesc)   = %d\n"
        "sizeof(Module)      = %d\n",
        sizeof(EEClass) - sizeof(LPCUTF8),
        sizeof(MethodTable),
        sizeof(MethodDesc) - 3*sizeof(void*),
        sizeof(MethodDesc) - 3*sizeof(void*),
        sizeof(FieldDesc),
        sizeof(Module)
    ));
#endif

    // The base domain is initialized in SystemDomain::Attach()
    // to allow stub caches to use the memory pool. Do not
    // initialze it here!

    Context     *curCtx = GetCurrentContext();
    _ASSERTE(curCtx);
    _ASSERTE(curCtx->GetDomain() != NULL);

    Thread      *pCurThread = GetThread();
    BOOL         toggleGC = !pCurThread->PreemptiveGCDisabled();
    
#ifdef _DEBUG
    g_fVerifierOff = g_pConfig->IsVerifierOff();
#endif

    SetStrongAssemblyStatus();

    m_pSystemAssembly = NULL;

    // The system domain always contains shared assemblies
    m_SharePolicy = SHARE_POLICY_ALWAYS;

    // Get the install directory so we can find mscorlib
    DWORD size = m_pSystemDirectory.MaxSize();
    hr = GetInternalSystemDirectory(m_pSystemDirectory.String(), &size);
    if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
        IfFailGo(m_pSystemDirectory.ReSize(size));
        size = m_pSystemDirectory.MaxSize();
        hr = GetInternalSystemDirectory(m_pSystemDirectory.String(), &size);
    }
    else {
        hr = m_pSystemDirectory.ReSize(size);
    }
    IfFailGo(hr);

    m_pBaseLibrary.ReSize(m_pSystemDirectory.Size() + sizeof(g_pwBaseLibrary) / sizeof(WCHAR));
    wcscpy(m_pBaseLibrary.String(), m_pSystemDirectory.String());
    wcscat(m_pBaseLibrary.String(), g_pwBaseLibrary);

    // We are about to start allocating objects, so we must be in cooperative mode.
    // However, many of the entrypoints to the system (DllGetClassObject and all
    // N/Direct exports) get called multiple times.  Sometimes they initialize the EE,
    // but generally they remain in preemptive mode.  So we really want to push/pop
    // the state here:

    if (toggleGC)
        pCurThread->DisablePreemptiveGC();

    if (FAILED(hr = LoadBaseSystemClasses()))
        goto ErrExit;

    if (FAILED(hr = CreatePreallocatedExceptions()))
        goto ErrExit;

    // Allocate the global string literal map.
    m_pGlobalStringLiteralMap = new (nothrow) GlobalStringLiteralMap();
    if(!m_pGlobalStringLiteralMap) return COR_E_OUTOFMEMORY;

    // Initialize the global string literal map.
    if (FAILED(hr = m_pGlobalStringLiteralMap->Init()))
        return hr;

    hr = S_OK;

 ErrExit:

    if (toggleGC)
        pCurThread->EnablePreemptiveGC();

#ifdef _DEBUG
    BOOL fPause = EEConfig::GetConfigDWORD(L"PauseOnLoad", FALSE);

    while(fPause) 
    {
        SleepEx(20, TRUE);
    }
#endif

    return hr;
}

BOOL SystemDomain::IsSystemFile(LPCWSTR path)
{
    LPCWSTR dir = wcsrchr(path, '\\');
    if (dir == NULL)
        return FALSE;

    // note: -2 is for \ && \0 in m_dwSystemDirectory
    if (((m_pSystemDirectory.Size()-2) != (DWORD)(dir - path))
        || _wcsnicmp(m_pSystemDirectory.String(), path, dir - path) != 0)
        return FALSE;

    if (_wcsicmp(dir+1, g_pwBaseLibrary) == 0)
        return TRUE;

    return FALSE;
}

HRESULT AppDomain::ReadSpecialClassesRegistry()
{
    HRESULT hr;
    DWORD dwResult;
    HKEY hKey;

    dwResult = WszRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               FRAMEWORK_REGISTRY_KEY_W L"\\Startup\\System",
                               0,
                               KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                               &hKey);

    if (dwResult == ERROR_SUCCESS)
    {
        CQuickString wszDllName;
        CQuickString wszSpecialName;

        LONG lRes;

        // Read the registry settings which identify special classes

        if ((lRes = UtilRegEnumKey (hKey,
                                    0,
                                    &wszDllName
                                    )) == ERROR_SUCCESS)
        {
            // make sure the value type is REG_SZ
            if (wszDllName.Size() > 0)
            {
                HKEY    hSubKey;
                // check for any special classes to be preloaded
                DWORD dwResult1 = WszRegOpenKeyEx(hKey,
                                                  wszDllName.String(),
                                                  0,
                                                  KEY_ENUMERATE_SUB_KEYS | KEY_READ,
                                                  &hSubKey);

                if (dwResult1 == ERROR_SUCCESS)
                {
                    // check for special classes to preloaded

                    if (UtilRegQueryStringValueEx(hSubKey, L"Object", 
                                                  0, 0, &wszSpecialName) == ERROR_SUCCESS)
                    {
                        #define MAKE_TRANSLATIONFAILED return E_UNEXPECTED
                        MAKE_UTF8PTR_FROMWIDE(name, wszSpecialName.String());
                        #undef MAKE_TRANSLATIONFAILED

                        g_pSpecialObjectName = new (nothrow) CHAR [ strlen(name) + 1 ];
                        if (g_pSpecialObjectName == NULL)
                            return E_OUTOFMEMORY;
                        strcpy(g_pSpecialObjectName, name);
                    }

                    if (UtilRegQueryStringValueEx(hSubKey, L"String", 
                                                  0, 0, &wszSpecialName) == ERROR_SUCCESS)
                    {
                        #define MAKE_TRANSLATIONFAILED return E_UNEXPECTED
                        MAKE_UTF8PTR_FROMWIDE(name, wszSpecialName.String());
                        #undef MAKE_TRANSLATIONFAILED

                        g_pSpecialStringName = new (nothrow) CHAR [ strlen(name) + 1 ];
                        if (g_pSpecialStringName == NULL)
                            return E_OUTOFMEMORY;
                        strcpy(g_pSpecialStringName, name);
                    }

                    if (UtilRegQueryStringValueEx(hSubKey, L"StringBuilder", 
                                                  0, 0, &wszSpecialName) == ERROR_SUCCESS)
                    {
                        #define MAKE_TRANSLATIONFAILED return E_UNEXPECTED
                        MAKE_UTF8PTR_FROMWIDE(name, wszSpecialName.String());
                        #undef MAKE_TRANSLATIONFAILED

                        g_pSpecialStringBuilderName = new (nothrow) CHAR [ strlen(name) + 1 ];
                        if (g_pSpecialStringBuilderName == NULL)
                            return E_OUTOFMEMORY;
                        strcpy(g_pSpecialStringBuilderName, name);
                    }

                    RegCloseKey(hSubKey);
                }

                if (g_pSpecialObjectName != NULL
                    || g_pSpecialStringName != NULL
                    || g_pSpecialStringBuilderName != NULL)
                {
                    g_pSpecialAssemblySpec = new (nothrow) AssemblySpec;
                    if (g_pSpecialAssemblySpec == NULL)
                        return E_OUTOFMEMORY;

                    #define MAKE_TRANSLATIONFAILED return E_UNEXPECTED
                    MAKE_UTF8PTR_FROMWIDE(name, wszDllName.String());
                    #undef MAKE_TRANSLATIONFAILED

                    IfFailRet(g_pSpecialAssemblySpec->Init(name));

                    // Parse the name right away since the string is a temp
                    IfFailRet(g_pSpecialAssemblySpec->ParseName()); 
                }
            }
        }
    }
    
    return S_OK;
}

void AppDomain::NoticeSpecialClassesAssembly(Assembly *pAssembly)
{
    THROWSCOMPLUSEXCEPTION();

    //
    // This routine should be called on every assembly load, so we can identify the special
    // classes more or less lazily.
    //

    //
    // If we already have our special assembly, or if there was none specified, don't bother
    // to do anything.

    if (m_pSpecialAssembly != NULL
        || g_pSpecialAssemblySpec == NULL)
        return;

    //
    // Note that we allow 2 thread to race & initialize these fields, since the computation
    // is idempotent.
    //

    //
    // If this assembly has the same name as the special assembly, go ahead and load the
    // special assembly.  Note that the "same name" check is just an approximation for 
    // checking if pAssembly is the special assembly - the only real test is to load the
    // assembly.  But of course once we've loaded it (we either get the same assembly or
    // a different one) we know that one is the special assembly so we remember it.
    //

    if (pAssembly->GetName() != NULL
        && strcmp(g_pSpecialAssemblySpec->GetName(), pAssembly->GetName()) == 0)
    {
        Assembly *pSpecialAssembly = NULL;

        BEGIN_ENSURE_COOPERATIVE_GC();

        OBJECTREF throwable = NULL;
        GCPROTECT_BEGIN(throwable);
        if (FAILED(g_pSpecialAssemblySpec->LoadAssembly(&pSpecialAssembly, &throwable)))
            COMPlusThrow(throwable);
        GCPROTECT_END();

        END_ENSURE_COOPERATIVE_GC();

        IMDInternalImport *pInternalImport = pSpecialAssembly->GetManifestImport();

        if (g_pSpecialObjectName != NULL)
        {
            NameHandle typeName(g_pSpecialObjectName);
            TypeHandle type = pSpecialAssembly->GetLoader()->FindTypeHandle(&typeName,
                                                                              RETURN_ON_ERROR);
            if (!type.IsNull())
                m_pSpecialObjectClass = type.AsMethodTable();
        }

        if (g_pSpecialStringName != NULL)
        {
            NameHandle typeName(g_pSpecialStringName);
            TypeHandle type = pSpecialAssembly->GetLoader()->FindTypeHandle(&typeName,
                                                                              RETURN_ON_ERROR);
            if (!type.IsNull())
            {
                m_pSpecialStringClass = type.AsMethodTable();

                //
                // Lookup the special String conversion methods
                //

                m_pSpecialStringToStringMD = m_pSpecialStringClass->GetClass()->FindMethodByName("ToString");
                if (m_pSpecialStringToStringMD == NULL)
                    COMPlusThrowMember(kMissingMethodException, pInternalImport, m_pSpecialStringClass, L"ToString", gsig_IM_RetStr.GetBinarySig());

                m_pStringToSpecialStringMD 
                  = m_pSpecialStringClass->GetClass()->FindMethodByName("FromString");

                if (m_pStringToSpecialStringMD == NULL)
                    COMPlusThrowMember(kMissingMethodException, pInternalImport, m_pSpecialStringClass, L"FromString", NULL);
            }
        }

        if (g_pSpecialStringBuilderName != NULL)
        {
            NameHandle typeName(g_pSpecialStringBuilderName);
            TypeHandle type = pSpecialAssembly->GetLoader()->FindTypeHandle(&typeName,
                                                                              RETURN_ON_ERROR);
            if (!type.IsNull())
            {
                m_pSpecialStringBuilderClass = type.AsMethodTable();

                // 
                // Lookup the special StringBuilder conversion methods
                //

                m_pSpecialStringBuilderToStringBuilderMD 
                  = m_pSpecialStringBuilderClass->GetClass()->FindMethodByName("ToStringBuilder");

                if (m_pSpecialStringBuilderToStringBuilderMD == NULL)
                    COMPlusThrowMember(kMissingMethodException, pInternalImport, m_pSpecialStringBuilderClass, L"ToStringBuilder", NULL);

                m_pStringBuilderToSpecialStringBuilderMD 
                  = m_pSpecialStringBuilderClass->GetClass()->FindMethodByName("FromStringBuilder");

                if (m_pStringBuilderToSpecialStringBuilderMD == NULL)
                    COMPlusThrowMember(kMissingMethodException, pInternalImport, m_pSpecialStringBuilderClass, L"FromStringBuilder", NULL);
            }
        }

        m_pSpecialAssembly = pSpecialAssembly;
    }
}

OBJECTREF AppDomain::ConvertStringToSpecialString(OBJECTREF pString)
{
    _ASSERTE(m_pStringToSpecialStringMD != NULL);

    THROWSCOMPLUSEXCEPTION();

    INT64 args[] = {
        ObjToInt64(pString)
    };

    INT64 out = m_pStringToSpecialStringMD->Call(args);

    return Int64ToObj(out);
}

OBJECTREF AppDomain::ConvertStringBuilderToSpecialStringBuilder(OBJECTREF pString)
{
    _ASSERTE(m_pStringBuilderToSpecialStringBuilderMD != NULL);

    THROWSCOMPLUSEXCEPTION();

    INT64 args[] = {
        ObjToInt64(pString)
    };

    INT64 out = m_pStringBuilderToSpecialStringBuilderMD->Call(args);

    return Int64ToObj(out);
}

OBJECTREF AppDomain::ConvertSpecialStringToString(OBJECTREF pString)
{
    _ASSERTE(m_pSpecialStringToStringMD != NULL);

    THROWSCOMPLUSEXCEPTION();

    INT64 args[] = {
        ObjToInt64(pString)
    };

    INT64 out = m_pSpecialStringToStringMD->Call(args);

    return Int64ToObj(out);
}

OBJECTREF AppDomain::ConvertSpecialStringBuilderToStringBuilder(OBJECTREF pString)
{
    _ASSERTE(m_pSpecialStringBuilderToStringBuilderMD != NULL);

    THROWSCOMPLUSEXCEPTION();

    INT64 args[] = {
        ObjToInt64(pString)
    };

    INT64 out = m_pSpecialStringBuilderToStringBuilderMD->Call(args);

    return Int64ToObj(out);
}


/*static*/
UINT32 SystemDomain::AllocateGlobalInterfaceId()
{
    UINT32 id;
    SystemDomain::System()->Enter();

    _ASSERTE(0 == (OS_PAGE_SIZE % sizeof(LPVOID)));

    if (m_dwFirstFreeId == -1)
    {
        // First, check if there are free slots from appdomain unloading. If so,
        // add him to the freelist.
        for (size_t i = 0; i < m_dwNumPagesCommitted * OS_PAGE_SIZE / sizeof(LPVOID); i++)
        {
            if (m_pGlobalInterfaceVTableMap[i] == (LPVOID)(-2))
            {
                m_pGlobalInterfaceVTableMap[i] = (LPVOID)m_dwFirstFreeId;
                m_dwFirstFreeId = i;

            }
        }

        if (m_dwFirstFreeId == -1)
        {

            if (m_dwNumPagesCommitted < kNumPagesForGlobalInterfaceVTableMap)
            {
                LPVOID pv = VirtualAlloc(m_pGlobalInterfaceVTableMap, OS_PAGE_SIZE * (m_dwNumPagesCommitted + 1), MEM_COMMIT, PAGE_READWRITE);



                if (pv == (LPVOID)m_pGlobalInterfaceVTableMap)
                {
                    m_dwFirstFreeId = m_dwNumPagesCommitted * OS_PAGE_SIZE / sizeof(LPVOID);
                    for (size_t i = m_dwFirstFreeId;
                         i < m_dwFirstFreeId + (OS_PAGE_SIZE / sizeof(LPVOID)) - 1;
                         i++)
                    {
                             m_pGlobalInterfaceVTableMap[i] = (LPVOID)(i+1);
                    }
                    m_pGlobalInterfaceVTableMap[i] = (LPVOID)(size_t)(-1);

                    m_dwNumPagesCommitted++;
                }

            }
        }
    }

    id = (UINT32) m_dwFirstFreeId;
    if (id != -1)
    {
        m_dwFirstFreeId = (size_t)m_pGlobalInterfaceVTableMap[m_dwFirstFreeId];
#ifdef _DEBUG
        m_pGlobalInterfaceVTableMap[id] = (LPVOID)(size_t)0xcccccccc;
#endif
    }

    SystemDomain::System()->Leave();

    return id;
}

HRESULT SystemDomain::LoadBaseSystemClasses()
{
    HRESULT hr = LoadSystemAssembly(&m_pSystemAssembly);
    if (FAILED(hr))
        return hr;

    // Never verify any hashes for the system libraries (we skip strong name
    // verification too) since we know everything comes from a safe place.
    m_pSystemAssembly->GetManifestFile()->SetHashesVerified();

    // Set this flag to avoid security checks when callers ask for mscorlib
    m_pSystemAssembly->GetManifestFile()->SetDisplayAsm();

    // Loading system libraries bumps up the ref count on the EE.
    // The system libraries are never unloaded therefore will not
    // push the ref count back to zero.
    //
    // To get around this problem we unitialize the EE reducing the
    // refcount by one. The refcount can be 1 when someone does
    // a load library on mscorlib.dll before initializing the EE.
    if(g_RefCount > 1)
        CoUninitializeEE(COINITEE_DLL);

    // must set this to null before loading classes becuase class loader will use it
    g_pDelegateClass = NULL;
    g_pMultiDelegateClass = NULL;

    // Set up binder for mscorlib
    Binder::StartupMscorlib(m_pSystemAssembly->GetManifestModule());

    // Load Object
    g_pObjectClass = g_Mscorlib.FetchClass(CLASS__OBJECT);

    // Now that ObjectClass is loaded, we can set up
    // the system for finalizers.  There is no point in deferring this, since we need
    // to know this before we allocate our first object.
    MethodTable::InitForFinalization();

    // Initialize the JIT helpers before we execute any JITed code
    if (!InitJITHelpers2())
        return BadError(E_FAIL);

    // Load the ValueType class
    g_pValueTypeClass = g_Mscorlib.FetchClass(CLASS__VALUE_TYPE);

    // Load Array class
    g_pArrayClass = g_Mscorlib.FetchClass(CLASS__ARRAY);

    // Load the Object array class.
    g_pPredefinedArrayTypes[ELEMENT_TYPE_OBJECT] = g_Mscorlib.FetchType(TYPE__OBJECT_ARRAY).AsArray();

    // Load String
    g_pStringClass = g_Mscorlib.FetchClass(CLASS__STRING);

    // Strings are not "normal" objects, so we need to mess with their method table a bit
    // so that the GC can figure out how big each string is...
    g_pStringClass->m_BaseSize = ObjSizeOf(StringObject);
    g_pStringClass->m_ComponentSize = 2;

    // Load the enum class
    g_pEnumClass = g_Mscorlib.FetchClass(CLASS__ENUM);
    _ASSERTE(!g_pEnumClass->IsValueClass());

    if (!SUCCEEDED(COMStringBuffer::LoadStringBuffer()))
        return BadError(E_FAIL);

    g_pExceptionClass = g_Mscorlib.FetchClass(CLASS__EXCEPTION);
    g_pOutOfMemoryExceptionClass = g_Mscorlib.GetException(kOutOfMemoryException);
    g_pStackOverflowExceptionClass = g_Mscorlib.GetException(kStackOverflowException);
    g_pExecutionEngineExceptionClass = g_Mscorlib.GetException(kExecutionEngineException);

    // unfortunately, the following cannot be delay loaded since the jit 
    // uses it to compute method attributes within a function that cannot 
    // handle Complus exception and the following call goes through a path
    // where a complus exception can be thrown. It is unfortunate, because
    // we know that the delegate class and multidelegate class are always 
    // guaranteed to be found.
    g_pDelegateClass = g_Mscorlib.FetchClass(CLASS__DELEGATE);
    g_pMultiDelegateClass = g_Mscorlib.FetchClass(CLASS__MULTICAST_DELEGATE);

#ifdef _DEBUG
    // used by gc to handle predefined agility checking
    g_pThreadClass = g_Mscorlib.FetchClass(CLASS__THREAD);
#endif

#ifdef _DEBUG
    Binder::CheckMscorlib();
#endif
    
    // DO the BJ_HACK stuff
    hr = AppDomain::ReadSpecialClassesRegistry();
    IfFailRet(hr);

    return S_OK;
}

HRESULT SystemDomain::LoadSystemAssembly(Assembly **pAssemblyOut)
{
    // Only load if have our thread setup (which is after we
    // have created the default domain and are in SystemDomain::Init())
    
    if (GetThread() == 0)
        return S_OK;
    
    HRESULT hr = E_FAIL;
    
    // Setup fusion context for the system domain - this is used during zap binding
    IfFailGo(FusionBind::SetupFusionContext(m_pSystemDirectory.String(), NULL, &m_pFusionContext));
    
    Module* pModule;
    
    {
        PEFile *pFile = NULL;
        IfFailGo(SystemDomain::LoadFile(SystemDomain::System()->BaseLibrary(), 
                                        NULL, 
                                        mdFileNil, 
                                        TRUE, 
                                        NULL, 
                                        NULL, // Code Base is not different then file name
                                        NULL, // Extra Evidence
                                        &pFile,
                                        FALSE));
                               
        Assembly *pAssembly = NULL;
        IfFailGo(LoadAssembly(pFile, 
                              NULL, 
                              &pModule, 
                              &pAssembly, 
                              NULL,  //ExtraEvidence
                              FALSE,
                              NULL));
        
        _ASSERTE(pAssembly->IsSystem());
        
        if (pAssemblyOut)
            *pAssemblyOut = pAssembly;
    }
    
    return hr;
    
 ErrExit:
    DWORD   errCode = GetLastError();
    PostError(MSEE_E_LOADLIBFAILED, g_psBaseLibrary, (unsigned long) errCode);
    return(hr);
}

/*static*/
HRESULT SystemDomain::CreateDomain(LPCWSTR pswFriendlyName,
                                   AppDomain **ppDomain)
{
    HRESULT hr;

    AppDomain *pDomain;

    hr = NewDomain(&pDomain);
    if (FAILED(hr))
        return hr;
        
    hr = LoadDomain(pDomain, pswFriendlyName);
    if (FAILED(hr))
    {
#ifdef PROFILING_SUPPORTED
        // Need the first assembly loaded in to get any data on an app domain.
        if (CORProfilerTrackAppDomainLoads())
            g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) pDomain, hr);
#endif // PROFILING_SUPPORTED

        pDomain->Release();
        return hr;
    }

    if (ppDomain != NULL)
    {
        *ppDomain = pDomain;
#ifdef DEBUGGING_SUPPORTED    
        // Notify the debugger here, before the thread transitions into the 
        // AD to finish the setup.  If we don't, stepping won't work right (RAID 67173)
        PublishAppDomainAndInformDebugger (pDomain);
#endif // DEBUGGING_SUPPORTED
    }

#ifdef PROFILING_SUPPORTED
    // Need the first assembly loaded in to get any data on an app domain.
    if (CORProfilerTrackAppDomainLoads())
        g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) pDomain, hr);
#endif // PROFILING_SUPPORTED

    
#ifdef _DEBUG
    if (pDomain)
        LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomainNative::CreateDomain domain [%d] %#08x %S\n", pDomain->GetIndex(), pDomain, pDomain->GetFriendlyName(FALSE)));
#endif

    return hr;
}

/*static*/
HRESULT SystemDomain::LoadDomain(AppDomain *pDomain,
                                 LPCWSTR pswFriendlyName)
{
    _ASSERTE(System());

    HRESULT hr = S_OK;

    pDomain->SetFriendlyName(pswFriendlyName);

    pDomain->SetCanUnload();    // by default can unload any domain

    SystemDomain::System()->AddDomain(pDomain);

    return hr;
}

struct LoadAssembly_Args
{
    AppDomain *pDomain;
    LPCWSTR pswModuleName;
    Module** ppModule;
    SystemDomain::ExternalCreateDomainWorker workerFcn;
    void *workerArgs;
    HRESULT hr;
};

void LoadAssembly_Wrapper(LoadAssembly_Args *args)
{
    PEFile *pFile;
    args->hr = PEFile::Create(args->pswModuleName, 
                              NULL, 
                              mdFileNil, 
                              FALSE, 
                              NULL, 
                              NULL,  // Code base is the same as the Name
                              NULL,  // Extra Evidence
                              &pFile);
    if (SUCCEEDED(args->hr)) {
        Assembly *pAssembly;
        args->hr = args->pDomain->LoadAssembly(pFile, 
                                               NULL, 
                                               args->ppModule, 
                                               &pAssembly, 
                                               NULL, 
                                               FALSE,
                                               NULL);
    }

    if (FAILED(args->hr) || ! args->workerFcn)
        return;

    // the point of having this workerFcn here is so that we can allow code to create an appdomain
    // and do some work in it w/o having to transition into the domain twice. 
    args->workerFcn(args->workerArgs);
}

/*static*/
HRESULT SystemDomain::ExternalCreateDomain(LPCWSTR pswModuleName, Module** ppModule, AppDomain** ppDomain,
                                           ExternalCreateDomainWorker workerFcn, void *workerArgs)
{
    HRESULT hr = E_FAIL;

    COMPLUS_TRY {
        AppDomain *pDomain;
        hr = SystemDomain::CreateDomain(pswModuleName, &pDomain);
        if (SUCCEEDED(hr) && pswModuleName != NULL)
        {
            LoadAssembly_Args args = { pDomain, pswModuleName, ppModule, workerFcn, workerArgs, S_OK };
            // call through DoCallBack with a domain transition
            GetThread()->DoADCallBack(pDomain->GetDefaultContext(), LoadAssembly_Wrapper, &args);
            hr = args.hr;
        }
        if (SUCCEEDED(hr) && ppDomain)
            *ppDomain = pDomain;
    }
    COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH
    return hr;
}


// This function propogates a newly loaded shared interface to all other appdomains
HRESULT SystemDomain::PropogateSharedInterface(UINT32 id, SLOT *pVtable)
{
    AppDomainIterator i;

    while (i.Next())
    {
        AppDomain *pDomain = i.GetDomain();

        pDomain->GetInterfaceVTableMapMgr().EnsureInterfaceId(id);
        (pDomain->GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers())[id] = (LPVOID)pVtable;
    }

    return S_OK;
}


DWORD SystemDomain::GetNewAppDomainIndex(AppDomain *pAppDomain)
{
    DWORD count = m_appDomainIndexList.GetCount();
    DWORD i;

#ifdef _DEBUG
    i = count;
#else
    //
    // Look for an unused index.  Note that in a checked build,
    // we never reuse indexes - this makes it easier to tell
    // when we are looking at a stale app domain.
    //

    i = m_appDomainIndexList.FindElement(m_dwLowestFreeIndex, NULL);
    if (i == ArrayList::NOT_FOUND)
        i = count;
    m_dwLowestFreeIndex = i;
#endif

    if (i == count)
        m_appDomainIndexList.Append(pAppDomain);
    else
        m_appDomainIndexList.Set(i, pAppDomain);

    _ASSERTE(i < m_appDomainIndexList.GetCount());

    // Note that index 0 means domain agile.
    return i+1;
}

void SystemDomain::ReleaseAppDomainIndex(DWORD index)
{
    // Note that index 0 means domain agile.
    index--;

    _ASSERTE(m_appDomainIndexList.Get(index) != NULL);

    m_appDomainIndexList.Set(index, NULL);

#ifndef _DEBUG
    if (index < m_dwLowestFreeIndex)
        m_dwLowestFreeIndex = index;
#endif
}

AppDomain *SystemDomain::GetAppDomainAtIndex(DWORD index)
{
    _ASSERTE(index != 0);

    AppDomain *pAppDomain = TestGetAppDomainAtIndex(index);

    _ASSERTE(pAppDomain || !"Attempt to access unloaded app domain");

    return pAppDomain;
}

AppDomain *SystemDomain::TestGetAppDomainAtIndex(DWORD index)
{
    _ASSERTE(index != 0);
    index--;

    _ASSERTE(index < (DWORD)m_appDomainIndexList.GetCount());

    AppDomain *pAppDomain = (AppDomain*) m_appDomainIndexList.Get(index);

    return pAppDomain;
}

DWORD SystemDomain::GetNewAppDomainId(AppDomain *pAppDomain)
{
    DWORD i = m_appDomainIdList.GetCount();

    m_appDomainIdList.Append(pAppDomain);

    _ASSERTE(i < m_appDomainIdList.GetCount());

    return i+1;
}

AppDomain *SystemDomain::GetAppDomainAtId(DWORD index)
{
    _ASSERTE(index != 0);
    index--;

    _ASSERTE(index < (DWORD)m_appDomainIdList.GetCount());

    return (AppDomain*) m_appDomainIdList.Get(index);
}

void SystemDomain::ReleaseAppDomainId(DWORD index)
{
    index--;

    _ASSERTE(index < (DWORD)m_appDomainIdList.GetCount());
    _ASSERTE(m_appDomainIdList.Get(index) != NULL);

    m_appDomainIdList.Set(index, NULL);
}

void SystemDomain::RestoreAppDomainId(DWORD index, AppDomain *pDomain)
{
    index--;

    _ASSERTE(index < (DWORD)m_appDomainIdList.GetCount());
    _ASSERTE(m_appDomainIdList.Get(index) == NULL);

    m_appDomainIdList.Set(index, pDomain);
}

Module* BaseDomain::FindModuleInProcess(BYTE *pBase, Module* pExcept)
{
    Module* result = NULL;

    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        result = i.GetAssembly()->FindModule(pBase);

        if (result == pExcept)
            result = NULL;

        if (result != NULL)
            break;
    }

    return result;
}

Module* SystemDomain::FindModuleInProcess(BYTE *pBase, Module* pModule)
{
    Module* result = NULL;

    result = BaseDomain::FindModuleInProcess(pBase, pModule);
    if(result == NULL) {
        AppDomainIterator i;
        while (i.Next()) {
            result = i.GetDomain()->FindModuleInProcess(pBase, pModule);
            if(result != NULL) break;
        }
    }
    return result;
}


// Currently, there is no lock required to find system modules. However,
// when shared assemblies are implemented this may no longer be the case.
Module* SystemDomain::FindModule(BYTE *pBase)
{
    Assembly* assem = NULL;
    Module* result = NULL;
    _ASSERTE(SystemDomain::System());

    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        result = i.GetAssembly()->FindModule(pBase);
        if (result != NULL)
            break;
    }

    return result;
}

// Currently, there is no lock required to find system asseblies. However,
// when shared assemblies are implemented this may no longer be the case.
Assembly* SystemDomain::FindAssembly(BYTE *pBase)
{
    Assembly* assem = NULL;
    _ASSERTE(SystemDomain::System());

    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        if (pBase == i.GetAssembly()->GetManifestFile()->GetBase())
        {
            assem = i.GetAssembly();
            break;
        }
    }

    return assem;
}

// Looks in all the modules for the DefaultDomain attribute
// The order is assembly and then the modules. It is first
// come first serve.c
HRESULT SystemDomain::SetDefaultDomainAttributes(IMDInternalImport* pScope, mdMethodDef mdMethod)
{
    BOOL fIsSTA = FALSE;
    Thread* pThread = GetThread();
    _ASSERTE(pThread);
    HRESULT hr;


    IfFailRet(pScope->GetCustomAttributeByName(mdMethod,
                                               DEFAULTDOMAIN_STA_TYPE,
                                               NULL,
                                               NULL));
    if(hr == S_OK)
        fIsSTA = TRUE;

    IfFailRet(pScope->GetCustomAttributeByName(mdMethod,
                                               DEFAULTDOMAIN_MTA_TYPE,
                                               NULL,
                                               NULL));
    if(hr == S_OK) {
        if(fIsSTA) {
            return E_FAIL; 
        }
        Thread::ApartmentState pState = pThread->SetApartment(Thread::ApartmentState::AS_InMTA);
        _ASSERTE(pState == Thread::ApartmentState::AS_InMTA);
    }
    else if(fIsSTA) {
        Thread::ApartmentState pState = pThread->SetApartment(Thread::ApartmentState::AS_InSTA);
        _ASSERTE(pState == Thread::ApartmentState::AS_InSTA);
    }

    //
    // Check to see if the assembly has the LoaderOptimization attribute set.
    //

    DWORD cbVal;
    BYTE *pVal;
    hr = pScope->GetCustomAttributeByName(mdMethod,
                                          DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE,
                                          (const void**)&pVal, &cbVal);
    if (hr == S_OK)
    {
        // Using evil knowledge of serialization, we know that the byte
        // value is in the third byte.
        _ASSERTE(pVal != NULL && cbVal > 3);

        DWORD policy = *(pVal+2);

        g_dwGlobalSharePolicy = policy;
        
    }

    return S_OK;
}

HRESULT SystemDomain::SetupDefaultDomain()
{
    HRESULT hr = S_OK;

    COMPLUS_TRY {
        Thread *pThread = GetThread();
        _ASSERTE(pThread);
        
        pThread->DisablePreemptiveGC();
        
        ContextTransitionFrame frame;
        pThread->EnterContextRestricted(SystemDomain::System()->DefaultDomain()->GetDefaultContext(), &frame, TRUE);
        
        AppDomain *pDomain = pThread->GetDomain();
        _ASSERTE(pDomain);
        
        // Get the Default domain on to the stack we maintain on the thread
        // EnterContext will do so only if it sees a real AppDomain transition
        pThread->PushDomain(pDomain);
        
        // Push this frame around loading the main assembly to ensure the
        // debugger can properly recgonize any managed code that gets run
        // as "class initializaion" code.
        DebuggerClassInitMarkFrame __dcimf;
        
        hr = InitializeDefaultDomain(SharePolicy::SHARE_POLICY_UNSPECIFIED);

        if(SUCCEEDED(hr))
            hr = pDomain->SetDefaultActivationContext(&frame);

        __dcimf.Pop();
        pThread->EnablePreemptiveGC();
        
        pThread->PopDomain();
        
        pThread->ReturnToContext(&frame, TRUE);

    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH

    return hr;
}


// This routine completes the initialization of the default domaine.
// After this call mananged code can be executed. 
HRESULT SystemDomain::InitializeDefaultDomain(DWORD optimization)
{
    // Setup the default AppDomain. This must be done prior to CORActivateRemoteDebugging
    // which can force a load to happen. 
    HRESULT hr = S_OK;

    // Determine the application base and the configuration file name
    CQuickString sPathName;
    CQuickString sConfigName;

    DWORD   dwSize;
    hr = GetConfigFileFromWin32Manifest(sConfigName.String(),
                                        sConfigName.MaxSize(),
                                        &dwSize);
    if(FAILED(hr)) {
        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            sConfigName.ReSize(dwSize);
            hr = GetConfigFileFromWin32Manifest(sConfigName.String(),
                                                sConfigName.MaxSize(),
                                                &dwSize);
        }
        if(FAILED(hr)) return hr;
    }
 
    hr = GetApplicationPathFromWin32Manifest(sPathName.String(),
                                             sPathName.MaxSize(),
                                             &dwSize);
    if(FAILED(hr)) {
        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            sPathName.ReSize(dwSize);
            hr = GetApplicationPathFromWin32Manifest(sPathName.String(),
                                                     sPathName.MaxSize(),
                                                     &dwSize);
        }
        if(FAILED(hr)) return hr;
    }
    
    WCHAR* pwsConfig = (sConfigName.Size() > 0 ? sConfigName.String() : NULL);
    WCHAR* pwsPath = (sPathName.Size() > 0 ? sPathName.String() : NULL);

    AppDomain* pDefaultDomain = SystemDomain::System()->DefaultDomain();
    hr = pDefaultDomain->InitializeDomainContext(optimization, pwsPath, pwsConfig);

    return hr;
}


HRESULT SystemDomain::ExecuteMainMethod(PEFile *pFile, LPWSTR wszImageName)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    Assembly* pAssembly = NULL;

    Thread *pThread = GetThread();
    _ASSERTE(pThread);

    pThread->DisablePreemptiveGC();

    ContextTransitionFrame frame;
    pThread->EnterContextRestricted(SystemDomain::System()->DefaultDomain()->GetDefaultContext(), &frame, TRUE);

    AppDomain *pDomain = pThread->GetDomain();
    _ASSERTE(pDomain);

    // Get the Default domain on to the stack we maintain on the thread
    // EnterContext will do so only if it sees a real AppDomain transition
    pThread->PushDomain(pDomain);

    OBJECTREF Throwable = NULL;
    GCPROTECT_BEGIN(Throwable);
    // Push this frame around loading the main assembly to ensure the
    // debugger can properly recognize any managed code that gets run
    // as "class initializaion" code.
    DebuggerClassInitMarkFrame __dcimf;

    // This works because the main assembly can never currently be
    // a fusion assembly.  This will probably change in the future so we
    // might have to squirrel away the fusion assembly too.
    _ASSERTE(!pDomain->m_pRootFile);
    pDomain->m_pRootFile = pFile;

    // Set up the DefaultDomain and the main thread
    if(pFile &&
       TypeFromToken(pFile->GetCORHeader()->EntryPointToken) != mdtFile)
    {
        IMDInternalImport* scope = pFile->GetMDImport(&hr);
        if(SUCCEEDED(hr)) {
            hr = SystemDomain::SetDefaultDomainAttributes(scope, pFile->GetCORHeader()->EntryPointToken);
            if(SUCCEEDED(hr))
                // Reset the friendly name, now that we have a root file.  This should
                // be set before our context is created.
                pDomain->ResetFriendlyName(TRUE);
        }            
    }

    hr = InitializeDefaultDomain(g_dwGlobalSharePolicy  | SHARE_DEFAULT_DISALLOW_BINDINGS);
    if(FAILED(hr))
        goto exit;

    hr = SystemDomain::System()->DefaultDomain()->SetDefaultActivationContext(&frame);
    if(FAILED(hr))
        goto exit;

    HCORMODULE hModule = NULL;
    hr = CorMap::OpenFile(wszImageName, CorLoadOSMap, &hModule);
    if(SUCCEEDED(hr))   
    {
        BOOL fPreBindAllowed = FALSE;
        hr = PEFile::VerifyModule(hModule,
                                  NULL,      
                                  NULL,
                                  wszImageName,
                                  NULL,
                                  wszImageName,
                                  NULL,
                                  NULL,
                                  &fPreBindAllowed);      

        if (FAILED(hr))
            COMPlusThrow(kPolicyException, hr, wszImageName);

        if(fPreBindAllowed) 
            pDomain->ResetBindingRedirect();

        Module* pModule;
        if (FAILED(hr = pDomain->LoadAssembly(pFile, NULL, &pModule, &pAssembly, NULL, NULL, FALSE, &Throwable))) {  

#define MAKE_TRANSLATIONFAILED  szFileName=""
            MAKE_UTF8PTR_FROMWIDE(szFileName, wszImageName);
#undef MAKE_TRANSLATIONFAILED
            PostFileLoadException(szFileName, TRUE, NULL, hr, &Throwable);
        }

    }
    
    __dcimf.Pop();

    if (Throwable != NULL)
        COMPlusThrow(Throwable);

    if (FAILED(hr)) {
        if(wszImageName)
            COMPlusThrowHR(hr, IDS_EE_FAILED_TO_LOAD, wszImageName, L"");
        else
            COMPlusThrowHR(hr);
    }
    else {
        if(pDomain == SystemDomain::System()->DefaultDomain()) {

            _ASSERTE(!pAssembly->GetFusionAssemblyName());
        
            AssemblySpec spec;
            if (FAILED(hr = spec.Init(pAssembly->m_psName, 
                                      pAssembly->m_Context, 
                                      pAssembly->m_pbPublicKey, pAssembly->m_cbPublicKey, 
                                      pAssembly->m_dwFlags)))
                COMPlusThrowHR(hr);
            
            if (FAILED(hr = spec.CreateFusionName(&pAssembly->m_pFusionAssemblyName, FALSE)))
                COMPlusThrowHR(hr);
            
            if (FAILED(hr = pDomain->m_pFusionContext->RegisterKnownAssembly(pAssembly->m_pFusionAssemblyName,
                                                                             pDomain->m_pRootFile->GetFileName(),
                                                                             &pAssembly->m_pFusionAssembly)))
                COMPlusThrowHR(hr);
        }


        pThread->EnablePreemptiveGC();

        if(wszImageName) {
            // Set the application name as the domain name for the debugger.
            LPCWSTR sep;
            if ((sep = wcsrchr(wszImageName, L'\\')) != NULL)
                sep++;
            else
                sep = wszImageName;
            pDomain->SetFriendlyName(sep);
        }

        pDomain->m_pRootAssembly = pAssembly;

        LOG((LF_CLASSLOADER | LF_CORDB,
             LL_INFO10,
             "Created domain for an executable at %#x\n",
             (pAssembly!=NULL?pAssembly->Parent():NULL)));

        hr = pAssembly->ExecuteMainMethod();
    }

exit:
    BOOL fToggle = !pThread->PreemptiveGCDisabled();    
    if (fToggle) 
        pThread->DisablePreemptiveGC();    

    GCPROTECT_END();
    pThread->ReturnToContext(&frame, TRUE);
    pThread->PopDomain();

    return hr;
}

//*****************************************************************************
// This guy will set up the proper thread state, look for the module given
// the hinstance, and then run the entry point if there is one.
//*****************************************************************************
HRESULT SystemDomain::RunDllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    MethodDesc  *pMD;
    Module      *pModule;
    Thread      *pThread = NULL;
    BOOL        fEnterCoop = FALSE;
    BOOL        fEnteredDomain = FALSE;
    HRESULT     hr = S_FALSE;           // Assume no entry point.

    pThread = GetThread();
    if ((!pThread && (dwReason == DLL_PROCESS_DETACH || dwReason == DLL_THREAD_DETACH)) ||
        g_fEEShutDown)
    {
        return S_OK;
    }

    // ExitProcess is called while a thread is doing GC.
    if (dwReason == DLL_PROCESS_DETACH && g_pGCHeap->IsGCInProgress())
    {
        return S_OK;
    }

    // ExitProcess is called on a thread that we don't know about
    if (dwReason == DLL_PROCESS_DETACH && GetThread() == NULL)
    {
        return S_OK;
    }

    // Need to setup the thread since this might be the first time the EE has
    // seen it if the thread was created in unmanaged code and this is a thread
    // attach event.
    if (pThread)
    {
        fEnterCoop = pThread->PreemptiveGCDisabled();
    }
    else
    {
        pThread = SetupThread();
        if (!pThread)
            return E_OUTOFMEMORY;
    }

    // Setup the thread state to cooperative to run managed code.
    if (!pThread->PreemptiveGCDisabled())
        pThread->DisablePreemptiveGC();

    // Get the old domain from the thread.  Legacy dll entry points must always
    // be run from the default domain.
    //
    // We cannot support legacy dlls getting loaded into all domains!!
    ContextTransitionFrame frame;
    COMPLUS_TRY {
        pThread->EnterContextRestricted(SystemDomain::System()->DefaultDomain()->GetDefaultContext(), &frame, TRUE);
        fEnteredDomain = TRUE;
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH

    AppDomain *pDomain;
    if (!fEnteredDomain)
        goto ErrExit;

    pDomain = pThread->GetDomain();

    // The module needs to be in the current list if you are coming here.
    pModule = pDomain->FindModule((BYTE *) hInst);
    if (!pModule)
        goto ErrExit;

    // See if there even is an entry point.
    pMD = pModule->GetDllEntryPoint();
    if (!pMD)
        goto ErrExit;

    // Run through the helper which will do exception handling for us.
    hr = ::RunDllMain(pMD, hInst, dwReason, lpReserved);

ErrExit:
    COMPLUS_TRY {
        if (fEnteredDomain)
            pThread->ReturnToContext(&frame, TRUE);
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH

    // Update thread state for the case where we are returning to unmanaged code.
    if (!fEnterCoop && pThread->PreemptiveGCDisabled())
        pThread->EnablePreemptiveGC();

    return (hr);
}


/*static*/
HRESULT SystemDomain::LoadFile(LPCSTR psModuleName, 
                               Assembly* pParent, 
                               mdFile kFile,                  // File token in the assembly associated with the file
                               BOOL fIgnoreVerification, 
                               IAssembly* pFusionAssembly, 
                               LPCWSTR pCodeBase,
                               OBJECTREF* pExtraEvidence,
                               PEFile** ppFile)
{
    if (!psModuleName || !*psModuleName)
        return COR_E_FILENOTFOUND;

    #define MAKE_TRANSLATIONFAILED return COR_E_FILENOTFOUND
    MAKE_WIDEPTR_FROMUTF8(pswModuleName, psModuleName);
    #undef MAKE_TRANSLATIONFAILED
    return LoadFile(pswModuleName, 
                    pParent, 
                    kFile, 
                    fIgnoreVerification, 
                    pFusionAssembly, 
                    pCodeBase,
                    pExtraEvidence,
                    ppFile,
                    FALSE);
}


typedef struct _StressLoadArgs
{
    LPCWSTR pswModuleName;
    Assembly* pParent;
    mdFile kFile;
    BOOL fIgnoreVerification;
    IAssembly* pFusionAssembly;
    LPCWSTR pCodeBase;
    OBJECTREF* pExtraEvidence;
    PEFile *pFile;
    Thread* pThread;
    DWORD *pThreadCount;
    HRESULT hr;
} StressLoadArgs;

static ULONG WINAPI StressLoadRun(void* args)
{
    StressLoadArgs* parameters = (StressLoadArgs*) args;
    parameters->pThread->HasStarted();
    parameters->hr = PEFile::Create(parameters->pswModuleName, 
                                    parameters->pParent, 
                                    parameters->kFile,
                                    parameters->fIgnoreVerification, 
                                    parameters->pFusionAssembly, 
                                    parameters->pCodeBase,
                                    parameters->pExtraEvidence,
                                    &(parameters->pFile));
    InterlockedDecrement((LONG*) parameters->pThreadCount);
    parameters->pThread->EnablePreemptiveGC();
    return parameters->hr;
}


/*static*/
HRESULT SystemDomain::LoadFile(LPCWSTR pswModuleName, 
                               Assembly* pParent,
                               mdFile kFile,                  // File token in the assembly associated with the file
                               BOOL fIgnoreVerification, 
                               IAssembly* pFusionAssembly, 
                               LPCWSTR pCodeBase,
                               OBJECTREF* pExtraEvidence,
                               PEFile** ppFile, 
                               BOOL fResource/*=FALSE*/)
{
    _ASSERTE(pswModuleName);
    _ASSERTE(ppFile);

    HRESULT hr;

    UINT last = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS);

    PEFile *pFile = NULL;
    if (fResource) {
        hr = PEFile::CreateResource(pswModuleName, 
                                    &pFile);
    }
    else {
        if(SystemDomain::IsSystemLoaded() && g_pConfig->GetStressLoadThreadCount() > 0) {
            DWORD threads = g_pConfig->GetStressLoadThreadCount();
            DWORD count = threads;

            Thread** LoadThreads = (Thread**) alloca(sizeof(Thread*) * threads);
            StressLoadArgs* args = (StressLoadArgs*) alloca(sizeof(StressLoadArgs) * threads);
            for(DWORD x = 0; x < threads; x++) {
                LoadThreads[x] = SetupUnstartedThread();
                if (!LoadThreads[x])
                    IfFailGo(E_OUTOFMEMORY);

                LoadThreads[x]->IncExternalCount();
                DWORD newThreadId;
                HANDLE h;
                args[x].pswModuleName = pswModuleName;
                args[x].pParent = pParent;
                args[x].kFile = kFile;
                args[x].fIgnoreVerification = fIgnoreVerification;
                args[x].pFusionAssembly = pFusionAssembly;
                args[x].pCodeBase = pCodeBase;
                args[x].pExtraEvidence = pExtraEvidence;
                args[x].pFile = NULL;
                args[x].pThreadCount = &threads;
                args[x].pThread = LoadThreads[x];
                h = LoadThreads[x]->CreateNewThread(0, StressLoadRun, &(args[x]), &newThreadId);
                ::SetThreadPriority (h, THREAD_PRIORITY_NORMAL);
                LoadThreads[x]->SetThreadId(newThreadId);
            }            
            for(DWORD x = 0; x < threads; x++) {
                ::ResumeThread(LoadThreads[x]->GetThreadHandle());
            }

            while(threads != 0)
                __SwitchToThread(0);

            for(DWORD x = 0; x < threads; x++) {
                _ASSERTE(SUCCEEDED(args[x].hr));
                delete args[x].pFile;
            }
                    
        }
        hr = PEFile::Create(pswModuleName, 
                            pParent, 
                            kFile,
                            fIgnoreVerification, 
                            pFusionAssembly, 
                            pCodeBase,
                            pExtraEvidence,
                            &pFile);
    }

    SetErrorMode(last);

    if (SUCCEEDED(hr))
        *ppFile = pFile;

 ErrExit:
    return hr;
}

/*static*/
// The module must have been added to a domain before this routine is called.
// This routine is no longer valid. Domains can only be obtained from the thread
HRESULT SystemDomain::GetDomainFromModule(Module* pModule, BaseDomain** ppDomain)
{
    _ASSERTE(pModule);
    _ASSERTE(pModule->GetAssembly());

    Assembly* pAssembly = pModule->GetAssembly();
    if(pAssembly == NULL) {
        _ASSERTE(!"Could not find caller's assembly");
        return E_FAIL;
    }

    BaseDomain* pDomain = pAssembly->Parent();
    if(pDomain == NULL) {
        _ASSERTE(!"System domain is not reachable");
        return E_FAIL;
    }
    if(ppDomain)
        *ppDomain = pDomain;
    return S_OK;
}

/* static */
MethodTable* SystemDomain::GetDefaultComObjectNoInit()
{
//    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
//    _ASSERTE(pDomain);
//    return pDomain->m_pComObjectMT;
    MethodTable *pComObjectClass = SystemDomain::System()->BaseComObject();
    if (pComObjectClass)
    {
        return pComObjectClass;
    }
    else
    {
        return NULL;
    }
}

/* static */
void SystemDomain::EnsureComObjectInitialized()
{
    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);

    // @todo: This is for the m_ClassFactHash table - which should be changed to be per domain anyway.
    // When this happens, remove this call:
    COMClass::EnsureReflectionInitialized();

    pDomain->InitializeComObject();
}



/* static */
MethodTable* SystemDomain::GetDefaultComObject()
{
    Thread* pThread = GetThread();
    BOOL fGCEnabled = !pThread->PreemptiveGCDisabled();
    if (fGCEnabled)
        pThread->DisablePreemptiveGC();

    EnsureComObjectInitialized();
    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);
    pDomain->InitializeComObject();

    if (fGCEnabled)
        pThread->EnablePreemptiveGC();

    _ASSERTE(pDomain->m_pComObjectMT);
    return pDomain->m_pComObjectMT;

}

/* static */
ICorRuntimeHost* SystemDomain::GetCorHost()
{
    _ASSERTE(m_pSystemDomain);

    if (!(System()->m_pCorHost)) {
        IClassFactory *pFactory;

        if (SUCCEEDED(DllGetClassObject(CLSID_CorRuntimeHost, IID_IClassFactory, (void**)&pFactory))) {
            pFactory->CreateInstance(NULL, IID_ICorRuntimeHost, (void**)&(System()->m_pCorHost));
            pFactory->Release();
        }

        _ASSERTE(System()->m_pCorHost);
    }

    return System()->m_pCorHost;
}

// Helper function to load an assembly. This is called from LoadCOMClass.
/* static */
HRESULT BaseDomain::LoadAssemblyHelper(LPCWSTR wszAssembly,
                                       LPCWSTR wszCodeBase,
                                       Assembly **ppAssembly,
                                       OBJECTREF *pThrowable)
{
    _ASSERTE(IsProtectedByGCFrame(pThrowable));

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    if(!(wszAssembly || wszCodeBase)) {
        PostFileLoadException("", FALSE, NULL, COR_E_FILENOTFOUND, pThrowable);
        return hr;
    }

    if(wszAssembly) {
        AssemblySpec spec;
        #define MAKE_TRANSLATIONFAILED  {PostFileLoadException("", FALSE, NULL, COR_E_FILENOTFOUND, pThrowable);return hr;}
        MAKE_UTF8PTR_FROMWIDE(szAssembly, wszAssembly);
        #undef  MAKE_TRANSLATIONFAILED
        spec.Init(szAssembly);
        hr = spec.LoadAssembly(ppAssembly, pThrowable);
    }

    // If the module was not found by display name, try the codebase.
    if((!Assembly::ModuleFound(hr)) && wszCodeBase) {
        AssemblySpec spec;
        spec.SetCodeBase(wszCodeBase, (DWORD)(wcslen(wszCodeBase)+1));
        hr = spec.LoadAssembly(ppAssembly, pThrowable);

        if (SUCCEEDED(hr) && wszAssembly && (*ppAssembly)->GetFusionAssemblyName() != NULL) {
            IAssemblyName* pReqName = NULL;
            hr = CreateAssemblyNameObject(&pReqName, wszAssembly, CANOF_PARSE_DISPLAY_NAME, NULL);
            if (SUCCEEDED(hr)) {
                hr = (*ppAssembly)->GetFusionAssemblyName()->IsEqual(pReqName, ASM_CMPF_DEFAULT);
                if(hr == S_FALSE)
                    hr = FUSION_E_REF_DEF_MISMATCH;
            }
            if (pReqName)
                pReqName->Release();
        }
    }

    return hr;
}

static WCHAR* wszClass = L"Class";
static WCHAR* wszAssembly =  L"Assembly";
static WCHAR* wszCodeBase =  L"CodeBase";
EEClass *SystemDomain::LoadCOMClass(GUID clsid, BaseDomain** ppParent, BOOL bLoadRecord, BOOL* pfAssemblyInReg)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(System());
    EEClass* pClass = NULL;

    LPSTR   szClass = NULL;
    LPWSTR  wszClassName = NULL;
    LPWSTR  wszAssemblyString = NULL;
    LPWSTR  wszCodeBaseString = NULL;
    DWORD   cbAssembly = 0;
    DWORD   cbCodeBase = 0;
    Assembly *pAssembly = NULL;
    OBJECTREF Throwable = NULL;

    HRESULT hr = S_OK;

    if (pfAssemblyInReg != NULL)
        *pfAssemblyInReg = FALSE;
   
    EE_TRY_FOR_FINALLY
    {
        // with sxs.dll help
        hr = FindShimInfoFromWin32(clsid, bLoadRecord, NULL, &wszClassName, &wszAssemblyString);

        if(FAILED(hr))
        {                
            hr = FindShimInfoFromRegistry(clsid, bLoadRecord, &wszClassName, 
                                          &wszAssemblyString, &wszCodeBaseString);
            if (FAILED(hr))
                return NULL;
        }

        if (pfAssemblyInReg != NULL)
            *pfAssemblyInReg = TRUE;

        GCPROTECT_BEGIN(Throwable)
        {
            #define MAKE_TRANSLATIONFAILED COMPlusThrowHR(E_UNEXPECTED);
            MAKE_UTF8PTR_FROMWIDE(szClass,wszClassName);
            #undef MAKE_TRANSLATIONFAILED

            NameHandle typeName(szClass);
            if (wszAssemblyString != NULL)
            {
                AppDomain *pDomain = GetCurrentDomain();
                if(SUCCEEDED(LoadAssemblyHelper(wszAssemblyString, wszCodeBaseString, &pAssembly, &Throwable))) 
                {
                    pClass = pAssembly->FindNestedTypeHandle(&typeName, &Throwable).GetClass();
                    if (!pClass)
                        goto ErrExit;

                    if(ppParent)
                        *ppParent = pDomain;
                }
            }

            if (pClass == NULL) 
            {
            ErrExit:
                if (Throwable != NULL)
                    COMPlusThrow(Throwable);

                // Convert the GUID to its string representation.
                WCHAR szClsid[64];
                if (GuidToLPWSTR(clsid, szClsid, NumItems(szClsid)) == 0)
                    szClsid[0] = 0;

                // Throw an exception indicating we failed to load the type with
                // the requested CLSID.
                COMPlusThrow(kTypeLoadException, IDS_CLASSLOAD_NOCLSIDREG, szClsid);
            }
        }
        GCPROTECT_END();
    }
    EE_FINALLY
    {
        if (wszClassName)
            delete[] wszClassName;
        if (wszAssemblyString)
            delete[] wszAssemblyString;
        if (wszCodeBaseString)
            delete[] wszCodeBaseString;
    }
    EE_END_FINALLY;

    return pClass;
}

struct CallersDataWithStackMark
{
    StackCrawlMark* stackMark;
    BOOL foundMe;
    BOOL skippingRemoting;
    MethodDesc* pFoundMethod;
    MethodDesc* pPrevMethod;
    AppDomain*  pAppDomain;
};

/*static*/
EEClass* SystemDomain::GetCallersClass(StackCrawlMark* stackMark, AppDomain **ppAppDomain)
{
    CallersDataWithStackMark cdata;
    ZeroMemory(&cdata, sizeof(CallersDataWithStackMark));
    cdata.stackMark = stackMark;

    StackWalkAction action = StackWalkFunctions(GetThread(), CallersMethodCallbackWithStackMark, &cdata);

    if(cdata.pFoundMethod) {
        if (ppAppDomain)
            *ppAppDomain = cdata.pAppDomain;
        return cdata.pFoundMethod->GetClass();
    } else
        return NULL;
}

/*static*/
Module* SystemDomain::GetCallersModule(StackCrawlMark* stackMark, AppDomain **ppAppDomain)
{
    CallersDataWithStackMark cdata;
    ZeroMemory(&cdata, sizeof(CallersDataWithStackMark));
    cdata.stackMark = stackMark;

    StackWalkAction action = StackWalkFunctions(GetThread(), CallersMethodCallbackWithStackMark, &cdata);

    if(cdata.pFoundMethod) {
        if (ppAppDomain)
            *ppAppDomain = cdata.pAppDomain;
        return cdata.pFoundMethod->GetModule();
    } else
        return NULL;
}

struct CallersData
{
    int skip;
    MethodDesc* pMethod;
};

/*static*/
Assembly* SystemDomain::GetCallersAssembly(StackCrawlMark *stackMark, AppDomain **ppAppDomain)
{
    Module* mod = GetCallersModule(stackMark, ppAppDomain);
    if (mod)
        return mod->GetAssembly();
    return NULL;
}

/*static*/
Module* SystemDomain::GetCallersModule(int skip)
{
    CallersData cdata;
    ZeroMemory(&cdata, sizeof(CallersData));
    cdata.skip = skip;

    StackWalkAction action = StackWalkFunctions(GetThread(), CallersMethodCallback, &cdata);

    if(cdata.pMethod)
        return cdata.pMethod->GetModule();
    else
        return NULL;
}

/*static*/
Assembly* SystemDomain::GetCallersAssembly(int skip)
{
    Module* mod = GetCallersModule(skip);
    if (mod)
        return mod->GetAssembly();
    return NULL;
}

/*private static*/
StackWalkAction SystemDomain::CallersMethodCallbackWithStackMark(CrawlFrame* pCf, VOID* data)
{
#ifdef _X86_
    MethodDesc *pFunc = pCf->GetFunction();

    /* We asked to be called back only for functions */
    _ASSERTE(pFunc);

    CallersDataWithStackMark* pCaller = (CallersDataWithStackMark*) data;
    if (pCaller->stackMark)
    {
        PREGDISPLAY regs = pCf->GetRegisterSet();
        // The address of the return address (AofRA) from this function into its caller will bound the
        // locals of this function, so we can use it to tell if we have reached our mark.
        // However, we don't get the AofRA until we crawl to the next frame, as regs->pPC is the
        // AofRA into this function, not the AofRA from this function to its caller.
        if ((size_t)regs->pPC < (size_t)pCaller->stackMark) {
            // save the current in case it is the one we want
            pCaller->pPrevMethod = pFunc;
            pCaller->pAppDomain = pCf->GetAppDomain();
            return SWA_CONTINUE;
        }

        // LookForMe stack crawl marks needn't worry about reflection or
        // remoting frames on the stack. Each frame above (newer than) the
        // target will be captured by the logic above. Once we transition to
        // finding the stack mark below the AofRA, we know that we hit the
        // target last time round and immediately exit with the cached result.
        if (*(pCaller->stackMark) == LookForMe)
        {
            pCaller->pFoundMethod = pCaller->pPrevMethod;
            return SWA_ABORT;
        }
    }

    // Skip reflection and remoting frames that could lie between a stack marked
    // method and its true caller (or that caller and its own caller). These
    // frames are infrastructure and logically transparent to the stack crawling
    // algorithm.

    // Skipping remoting frames. We always skip entire client to server spans
    // (though we see them in the order server then client during a stack crawl
    // obviously).

    // We spot the server dispatcher end because all calls are dispatched
    // through a single method: StackBuilderSink.PrivateProcessMessage.
    if (pFunc == g_Mscorlib.GetMethod(METHOD__STACK_BUILDER_SINK__PRIVATE_PROCESS_MESSAGE))
    {
        _ASSERTE(!pCaller->skippingRemoting);
        pCaller->skippingRemoting = true;
        return SWA_CONTINUE;
    }

    // And we spot the client end because there's a transparent proxy transition
    // frame pushed.
    if (!pCf->IsFrameless() && pCf->GetFrame()->GetFrameType() == Frame::TYPE_TP_METHOD_FRAME)
    {
        _ASSERTE(pCaller->skippingRemoting);
        pCaller->skippingRemoting = false;
        return SWA_CONTINUE;
    }

    // Skip any frames into between the server and client remoting endpoints.
    if (pCaller->skippingRemoting)
        return SWA_CONTINUE;

    // Skipping reflection frames. We don't need to be quite as exhaustive here
    // as the security or reflection stack walking code since we know this logic
    // is only invoked for selected methods in mscorlib itself. So we're
    // reasonably sure we won't have any sensitive methods late bound invoked on
    // constructors, properties or events. This leaves being invoked via
    // MethodInfo, Type or Delegate (and depending on which invoke overload is
    // being used, several different reflection classes may be involved).
    MethodTable *pMT = pFunc->GetMethodTable();
    if (g_Mscorlib.IsClass(pMT, CLASS__METHOD) ||
        g_Mscorlib.IsClass(pMT, CLASS__METHOD_BASE) ||
        g_Mscorlib.IsClass(pMT, CLASS__CLASS) ||
        g_Mscorlib.IsClass(pMT, CLASS__TYPE) ||
        pMT->GetClass()->IsAnyDelegateClass() ||
        pMT->GetClass()->IsAnyDelegateExact())
        return SWA_CONTINUE;
    
    // Return the first non-reflection/remoting frame if no stack mark was
    // supplied.
    if (!pCaller->stackMark)
    {
        pCaller->pFoundMethod = pFunc;
        pCaller->pAppDomain = pCf->GetAppDomain();
        return SWA_ABORT;
    }

    // When looking for caller's caller, we delay returning results for another
    // round (the way this is structured, we will still be able to skip
    // reflection and remoting frames between the caller and the caller's
    // caller).
    if ((*(pCaller->stackMark) == LookForMyCallersCaller) &&
        (pCaller->pFoundMethod == NULL))
    {
        pCaller->pFoundMethod = pFunc;
        return SWA_CONTINUE;
    }

    // We must either be looking for the caller, or the caller's caller when
    // we've already found the caller (we used a non-null value in pFoundMethod
    // simply as a flag, the correct method to return in both case is the
    // current method).
    pCaller->pFoundMethod = pFunc;
    pCaller->pAppDomain = pCf->GetAppDomain();
    return SWA_ABORT;

#else // !_X86_
    _ASSERTE(!"NYI");
    return SWA_CONTINUE;
#endif // _X86_
}

/*private static*/
StackWalkAction SystemDomain::CallersMethodCallback(CrawlFrame* pCf, VOID* data)
{
    MethodDesc *pFunc = pCf->GetFunction();

    /* We asked to be called back only for functions */
    _ASSERTE(pFunc);

    // Ignore intercepted frames
    if(pFunc->IsIntercepted())
        return SWA_CONTINUE;

    CallersData* pCaller = (CallersData*) data;
    if(pCaller->skip == 0) {
        pCaller->pMethod = pFunc;
        return SWA_ABORT;
    }
    else {
        pCaller->skip--;
        return SWA_CONTINUE;
    }

}


/*private*/
// A lock must be taken before calling this routine
HRESULT SystemDomain::NewDomain(AppDomain** ppDomain)
{
    _ASSERT(ppDomain);
    AppDomain* app = NULL;
    HRESULT hr = E_FAIL;

    {
        SYSTEMDOMAIN_LOCK();
        app = new (nothrow) AppDomain();
        if (! app)
            hr = E_OUTOFMEMORY;
        else
            hr = app->Init();
        if (FAILED(hr))
        {
            // if generic fail then change to CANNOTCREATEAPPDOMAIN
            if (hr == E_FAIL)
                hr = MSEE_E_CANNOTCREATEAPPDOMAIN;
            goto fail;
        }
    }

    //
    // Add all stuff which is currently in the system domain
    //

    SystemDomain::System()->NotifyNewDomainLoads(app);

    if (FAILED(hr = app->SetupSharedStatics()))
        goto fail;

    *ppDomain = app;
    return S_OK;

fail:
    if (app)
        delete app;
    *ppDomain = NULL;
    return hr;
}


HRESULT SystemDomain::CreateDefaultDomain()
{
    HRESULT hr = S_OK;

    if (m_pDefaultDomain != NULL)
        return S_OK;

    AppDomain* pDomain = NULL;
    if (FAILED(hr = NewDomain(&pDomain)))
        return hr;

    pDomain->GetSecurityDescriptor()->SetDefaultAppDomainProperty();

    // need to make this assignment here since we'll be releasing
    // the lock before calling AddDomain. So any other thread
    // grabbing this lock after we release it will find that
    // the COM Domain has already been created
    m_pDefaultDomain = pDomain;

    pDomain->m_Stage = AppDomain::STAGE_OPEN;

    LOG((LF_CLASSLOADER | LF_CORDB,
         LL_INFO10,
         "Created default domain at %#x\n", m_pDefaultDomain));

    return S_OK;
}

#ifdef DEBUGGING_SUPPORTED

void SystemDomain::PublishAppDomainAndInformDebugger (AppDomain *pDomain)
{
    LOG((LF_CORDB, LL_INFO100, "SD::PADAID: Adding 0x%x\n", pDomain));

    // The DefaultDomain is a special case since it gets created before any
    // assemblies, etc. have been loaded yet. Don't send an event for it
    // if the EE is not yet initialized.
    if ((pDomain == m_pSystemDomain->m_pDefaultDomain) && g_fEEInit == TRUE)
    {
        LOG((LF_CORDB, LL_INFO1000, "SD::PADAID:Returning early b/c of init!\n"));
        return;
    }
    
    // Indication (for the debugger) that this app domain is being created
    pDomain->SetDomainBeingCreated (TRUE);

    // Call the publisher API to add this appdomain entry to the list
    _ASSERTE (g_pDebugInterface != NULL);
    HRESULT hr = g_pDebugInterface->AddAppDomainToIPC(pDomain);
    _ASSERTE (SUCCEEDED (hr) || (g_fEEShutDown & ShutDown_Finalize2));

    // Indication (for the debugger) that the app domain is finished being created
    pDomain->SetDomainBeingCreated (FALSE);
}

#endif // DEBUGGING_SUPPORTED

void SystemDomain::AddDomain(AppDomain* pDomain)
{
    _ASSERTE(pDomain);

    Enter();
    pDomain->m_Stage = AppDomain::STAGE_OPEN;
    pDomain->AddRef();
    IncrementNumAppDomains(); // Maintain a count of app domains added to the list.
    Leave();

    // Note that if you add another path that can reach here without calling
    // PublishAppDomainAndInformDebugger, then you should go back & make sure
    // that PADAID gets called.  Right after this call, if not sooner.
    LOG((LF_CORDB, LL_INFO1000, "SD::AD:Would have added domain here! 0x%x\n",
        pDomain));
}

HRESULT SystemDomain::RemoveDomain(AppDomain* pDomain)
{
    _ASSERTE(pDomain);

    // You can not remove the system assembly or
    // the com assembly.
    if (pDomain == m_pDefaultDomain)
        return E_FAIL;

    if (!pDomain->IsOpen())
        return S_FALSE;

    pDomain->Release();

    return S_OK;
}

#ifdef PROFILING_SUPPORTED
HRESULT SystemDomain::NotifyProfilerStartup()
{
    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System());
        g_profControlBlock.pProfInterface->AppDomainCreationStarted((ThreadID) GetThread(), (AppDomainID) System());
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System());
        g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) System(), S_OK);
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System()->DefaultDomain());
        g_profControlBlock.pProfInterface->AppDomainCreationStarted((ThreadID) GetThread(), (AppDomainID) System()->DefaultDomain());
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System()->DefaultDomain());
        g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) System()->DefaultDomain(), S_OK);
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(SharedDomain::GetDomain());
        g_profControlBlock.pProfInterface->AppDomainCreationStarted((ThreadID) GetThread(), (AppDomainID) SharedDomain::GetDomain());
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(SharedDomain::GetDomain());
        g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) SharedDomain::GetDomain(), S_OK);
    }
    return (S_OK);
}

HRESULT SystemDomain::NotifyProfilerShutdown()
{
    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System());
        g_profControlBlock.pProfInterface->AppDomainShutdownStarted((ThreadID) GetThread(), (AppDomainID) System());
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System());
        g_profControlBlock.pProfInterface->AppDomainShutdownFinished((ThreadID) GetThread(), (AppDomainID) System(), S_OK);
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System()->DefaultDomain());
        g_profControlBlock.pProfInterface->AppDomainShutdownStarted((ThreadID) GetThread(), (AppDomainID) System()->DefaultDomain());
    }

    if (CORProfilerTrackAppDomainLoads())
    {
        _ASSERTE(System()->DefaultDomain());
        g_profControlBlock.pProfInterface->AppDomainShutdownFinished((ThreadID) GetThread(), (AppDomainID) System()->DefaultDomain(), S_OK);
    }
    return (S_OK);
}
#endif // PROFILING_SUPPORTED


static HRESULT GetVersionPath(HKEY root, LPWSTR key, LPWSTR* pDevpath, DWORD* pdwDevpath)
{
    DWORD rtn;
    HKEY versionKey;
    rtn = WszRegOpenKeyEx(root, key, 0, KEY_READ, &versionKey);
    if(rtn == ERROR_SUCCESS) {
        DWORD type;
        DWORD cbDevpath;
        if(WszRegQueryValueEx(versionKey, L"devpath", 0, &type, (LPBYTE) NULL, &cbDevpath) == ERROR_SUCCESS && type == REG_SZ) {
            *pDevpath = (LPWSTR) new (nothrow) BYTE[cbDevpath];
            if(*pDevpath == NULL) 
                rtn = ERROR_OUTOFMEMORY;
            else {
                rtn = WszRegQueryValueEx(versionKey, L"devpath", 0, &type, (LPBYTE) *pDevpath, &cbDevpath);
                if ((rtn == ERROR_SUCCESS) && (type == REG_SZ))
                    *pdwDevpath = (DWORD) wcslen(*pDevpath);
            }
            RegCloseKey(versionKey);
        } 
        else {
            RegCloseKey(versionKey);
            return REGDB_E_INVALIDVALUE;
        }
    }

    return HRESULT_FROM_WIN32(rtn);
}

// Get the developers path from the environment. This can only be set through the environment and
// cannot be added through configuration files, registry etc. This would make it to easy for 
// developers to deploy apps that are not side by side. The environment variable should only
// be used on developers machines where exact matching to versions makes build and testing to
// difficult.
HRESULT SystemDomain::GetDevpathW(LPWSTR* pDevpath, DWORD* pdwDevpath)
{
    HRESULT hr = S_OK;
    if(g_pConfig->DeveloperInstallation() && m_fDevpath == FALSE) {
        Enter();
        if(m_fDevpath == FALSE) {
            DWORD dwPath = 0;
            dwPath = WszGetEnvironmentVariable(APPENV_DEVPATH, 0, 0);
            if(dwPath) {
                m_pwDevpath = (WCHAR*) new (nothrow) WCHAR[dwPath];
                if(m_pwDevpath == NULL) 
                    hr = E_OUTOFMEMORY;
                else 
                    m_dwDevpath = WszGetEnvironmentVariable(APPENV_DEVPATH, 
                                                            m_pwDevpath,
                                                            
                                                            dwPath) - 1;
            }
            else {
                HKEY userKey;
                HKEY machineKey;

                WCHAR pVersion[MAX_PATH];
                DWORD dwVersion = MAX_PATH;
                hr = FusionBind::GetVersion(pVersion, &dwVersion);
                if(SUCCEEDED(hr)) {
                    long rslt;
                    rslt = WszRegOpenKeyEx(HKEY_CURRENT_USER, FRAMEWORK_REGISTRY_KEY_W,0,KEY_READ, &userKey); 
                    hr = HRESULT_FROM_WIN32(rslt); 
                    if (SUCCEEDED(hr)) {
                        hr = GetVersionPath(userKey, pVersion, &m_pwDevpath, &m_dwDevpath);
                        RegCloseKey(userKey);
                    }
                    
                    if (FAILED(hr) && WszRegOpenKeyEx(HKEY_LOCAL_MACHINE, FRAMEWORK_REGISTRY_KEY_W,0,KEY_READ, &machineKey) == ERROR_SUCCESS) {
                        hr = GetVersionPath(machineKey, pVersion, &m_pwDevpath, &m_dwDevpath);
                        RegCloseKey(machineKey);
                    }
                }
            }

            m_fDevpath = TRUE;
        }
        Leave();
    }
    
    if(SUCCEEDED(hr)) {
        if(pDevpath) *pDevpath = m_pwDevpath;
        if(pdwDevpath) *pdwDevpath = m_dwDevpath;
    }
    return hr;
}
        

#ifdef _DEBUG
struct AppDomain::ThreadTrackInfo {
    Thread *pThread;
    CDynArray<Frame *> frameStack;
};
#endif

AppDomain::AppDomain()
{
    m_pSecContext = new SecurityContext();
}

AppDomain::~AppDomain()
{
    Terminate();
    
    delete m_pSecContext;

#ifdef _DEBUG
    // If we were tracking thread AD transitions, nuke the list on shutdown
    if (m_pThreadTrackInfoList)
    {
        while (m_pThreadTrackInfoList->Count() > 0)
        {
            // Get the very last element
            ThreadTrackInfo *pElem = *(m_pThreadTrackInfoList->Get(m_pThreadTrackInfoList->Count() - 1));
            _ASSERTE(pElem);

            // Free the memory
            delete pElem;

            // Remove pointer entry from the list
            m_pThreadTrackInfoList->Delete(m_pThreadTrackInfoList->Count() - 1);
        }

        // Now delete the list itself
        delete m_pThreadTrackInfoList;
        m_pThreadTrackInfoList = NULL;
    }
#endif // _DEBUG
}


HRESULT SystemDomain::FixupSystemTokenTables()
{
    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        for (Module *m = i.GetAssembly()->GetLoader()->m_pHeadModule;
             m != NULL; m = m->GetNextModule())
        {
            if (!m->LoadTokenTables())
                return E_FAIL;
        }
    }

    return S_OK;
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

HRESULT AppDomain::Init()
{
    THROWSCOMPLUSEXCEPTION();

    // This needs to be initialized for the profiler
    m_pRootFile = NULL;
    m_pwzFriendlyName = NULL;
    m_pRootAssembly = NULL;
    m_pwDynamicDir = NULL;
    m_dwId = 0;

    m_dwFlags = 0;
    m_cRef = 0;
    m_pSecDesc = NULL;
    m_pComObjectMT = NULL;
    m_pLicenseInteropHelperMT = NULL;
    m_pDefaultContext = NULL;
    m_pComCallWrapperCache = NULL;
    m_pComPlusWrapperCache = NULL;
    m_pAsyncPool = NULL;

    m_hHandleTable = NULL;
    SetExecutable(TRUE);

    m_ExposedObject = NULL;
    m_pDefaultContext = NULL;

 #ifdef _DEBUG
    m_pThreadTrackInfoList = NULL;
    m_TrackSpinLock = 0;
#endif

    m_pBindingCache = NULL;

    m_dwThreadEnterCount = 0;

    m_Stage = STAGE_CREATING;

    m_UnlinkClasses = NULL;

    m_pComCallMLStubCache = NULL;
    m_pFieldCallStubCache = NULL;

    m_pSpecialAssembly = NULL;
    m_pSpecialObjectClass = NULL;
    m_pSpecialStringClass = NULL;
    m_pSpecialStringBuilderClass = NULL;
    m_pStringToSpecialStringMD = NULL;
    m_pSpecialStringToStringMD = NULL;
    m_pStringBuilderToSpecialStringBuilderMD = NULL;
    m_pSpecialStringBuilderToStringBuilderMD = NULL;

    m_pSecDesc = NULL;

    HRESULT hr = BaseDomain::Init();

    m_dwIndex = SystemDomain::GetNewAppDomainIndex(this);
    m_dwId = SystemDomain::GetNewAppDomainId(this);

    m_hHandleTable = Ref_CreateHandleTable(m_dwIndex);

    m_pDefaultContext = Context::SetupDefaultContext(this);

    m_ExposedObject = CreateHandle(NULL);

    m_sDomainLocalBlock.Init(this);

    {
        LockOwner lock = {m_pDomainCacheCrst, IsOwnerOfCrst};
        m_sharedDependenciesMap.Init(TRUE, &lock);
    }

    // Bump up the reference count
    AddRef();

    // Create the Application Security Descriptor
    CreateSecurityDescriptor();

    COUNTER_ONLY(GetPrivatePerfCounters().m_Loading.cAppDomains++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Loading.cAppDomains++);

    if (!m_pDefaultContext)
        COMPlusThrowOM();

    return hr;
}

void AppDomain::Stop()
{
    if(m_pDomainCrst == NULL) return;

    if (SystemDomain::GetAppDomainAtId(m_dwId) != NULL)
        SystemDomain::ReleaseAppDomainId(m_dwId);

    // Any DLL's with user entry points need their detach callback
    // done now, because if the DLL was loaded via COM, the OS
    // callback won't come until after the EE is shut down.
    SignalProcessDetach();

    // @TODO: Shut down the threads

#ifdef DEBUGGING_SUPPORTED
    if (IsDebuggerAttached())
        NotifyDebuggerDetach();
#endif // DEBUGGING_SUPPORTED

    m_pRootFile = NULL; // This assembly is in the assembly list;

    if (m_pSecDesc != NULL)
    {
        delete m_pSecDesc;
        m_pSecDesc = NULL;
    }

#ifdef DEBUGGING_SUPPORTED
    _ASSERTE(NULL != g_pDebugInterface);

    // Call the publisher API to delete this appdomain entry from the list
    g_pDebugInterface->RemoveAppDomainFromIPC (this);
#endif
}

void AppDomain::Terminate()
{
    if(m_pDomainCrst == NULL) return;

    _ASSERTE(m_dwThreadEnterCount == 0 || this == SystemDomain::System()->DefaultDomain());

    if (SystemDomain::BeforeFusionShutdown())
        ReleaseFusionInterfaces();

    Context::CleanupDefaultContext(this);
    m_pDefaultContext = NULL;

    if (m_pComPlusWrapperCache)
    {
        //  m_pComPlusWrapperCache->ReleaseAllComPlusWrappers();
        //@todo this needs to be cleaned up correctly
        // rajak
        //delete m_pComPlusWrapperCache;
        m_pComPlusWrapperCache->Release();
        m_pComPlusWrapperCache = NULL;
    }

    if (m_pComCallWrapperCache) {
        m_pComCallWrapperCache->Terminate();
    }

    // if the above released the wrapper cache, then it will call back and reset our
    // m_pComCallWrapperCache to null. If not null, then need to set it's domain pointer to
    // null.
    if (! m_pComCallWrapperCache) 
    {
        LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::Terminate ComCallWrapperCache released\n"));
    }
#ifdef _DEBUG
    else
    {
        m_pComCallWrapperCache->ClearDomain();
        m_pComCallWrapperCache = NULL;
        LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::Terminate ComCallWrapperCache not released\n"));
    }
#endif

    if (m_pComCallMLStubCache)
    {
        delete m_pComCallMLStubCache;
    }
    m_pComCallMLStubCache = NULL;
    
    if (m_pFieldCallStubCache)
    {
        delete m_pFieldCallStubCache;
    }
    m_pFieldCallStubCache = NULL;

    if(m_pAsyncPool != NULL)
        delete m_pAsyncPool;

    COUNTER_ONLY(GetPrivatePerfCounters().m_Loading.cAppDomains--);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Loading.cAppDomains--);

    COUNTER_ONLY(GetPrivatePerfCounters().m_Loading.cAppDomainsUnloaded++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Loading.cAppDomainsUnloaded++);

    if (!g_fProcessDetach)
    {
        // Suspend the EE to do some clean up that can only occur
        // while no threads are running.
        GCHeap::SuspendEE(GCHeap::SUSPEND_FOR_APPDOMAIN_SHUTDOWN);
    }

    // We need to release all the string literals used by this AD.
    // This has to happen while the EE is suspended so this is a
    // convenient place to do it.
    if (m_pStringLiteralMap)
    {
        delete m_pStringLiteralMap;
        m_pStringLiteralMap = NULL;
    }

    // Remove any function pointer types associated with this domain
    // TODO if g_sFuncTypeDescHash was assocated with the appdomain
    // in the first place, this hack would not be needed.  
    EnterCriticalSection(&g_sFuncTypeDescHashLock);
    EEHashTableIteration iter;
    g_sFuncTypeDescHash.IterateStart(&iter);
    BOOL notDone = g_sFuncTypeDescHash.IterateNext(&iter);
    while (notDone) {
        FunctionTypeDesc* ftnType = (FunctionTypeDesc*) g_sFuncTypeDescHash.IterateGetValue(&iter);
        ExpandSig*            key = g_sFuncTypeDescHash.IterateGetKey(&iter);

            // Have to advance the pointer before we delete the entry we are on. 
        notDone = g_sFuncTypeDescHash.IterateNext(&iter);
        if (ftnType->GetModule()->GetDomain() == this) {
            g_sFuncTypeDescHash.DeleteValue(key);
            delete ftnType;
        }
    }
    LeaveCriticalSection(&g_sFuncTypeDescHashLock);


    if (!g_fProcessDetach)
    {
        // Resume the EE.
        GCHeap::RestartEE(FALSE, TRUE);
    }

    BaseDomain::Terminate();

    if (m_pwzFriendlyName) {
        delete[] m_pwzFriendlyName;
        m_pwzFriendlyName = NULL;
    }

    if (m_pBindingCache) {
        delete m_pBindingCache;
        m_pBindingCache = NULL;
    }

    Ref_DestroyHandleTable(m_hHandleTable);

    SystemDomain::ReleaseAppDomainIndex(m_dwIndex);
}



HRESULT AppDomain::CloseDomain()
{
    CHECKGC();
    if(m_pDomainCrst == NULL) return E_FAIL;

    AddRef();  // Hold a reference
    SystemDomain::System()->Enter(); // Take the lock
    SystemDomain::System()->DecrementNumAppDomains(); // Maintain a count of app domains added to the list.
    HRESULT hr = SystemDomain::System()->RemoveDomain(this);
    SystemDomain::System()->Leave();
    // Remove will return S_FALSE if the domain has already
    // been removed
    if(hr == S_OK)
        Stop();

    Release(); // If there are no references then this will delete the domain
    return hr;
}

void SystemDomain::WriteZapLogs()
{
    if (g_pConfig->UseZaps()
        && g_pConfig->LogMissingZaps())
    {
        AppDomainIterator i;

        while (i.Next())
            i.GetDomain()->WriteZapLogs();
    }
}

void AppDomain::WriteZapLogs()
{
    if (g_pConfig->UseZaps()
        && g_pConfig->LogMissingZaps()
        && !IsCompilationDomain() 
        && m_pFusionContext != NULL 
        && (m_dwFlags & APP_DOMAIN_LOGGED) == 0)
    {
        // @todo: stash Directory away somewhere global so we only make it once?
        NLogDirectory dir; 

        NLog log(&dir, m_pFusionContext);

        NLogRecord record;

        AssemblyIterator i = IterateAssemblies();

        while (i.Next())
        {
            Assembly *a = i.GetAssembly();

            NLogAssembly *pAssembly = a->CreateAssemblyLog();
            if (pAssembly != NULL)
                record.AppendAssembly(pAssembly);
        }

        i = SystemDomain::System()->IterateAssemblies();

        while (i.Next())
        {
            Assembly *a = i.GetAssembly();

            NLogAssembly *pAssembly = a->CreateAssemblyLog();
            if (pAssembly != NULL)
                record.AppendAssembly(pAssembly);
        }

        log.AppendRecord(&record);

        m_dwFlags |= APP_DOMAIN_LOGGED;
    }
}

HRESULT AppDomain::SignalProcessDetach()
{
    HRESULT hr = S_OK;
    Assembly* assem = NULL;
    Module* pmod = NULL;

    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        // if are unloading, don't signal detach for shared assemblies
        if (i.GetAssembly()->IsShared() && SystemDomain::IndexOfAppDomainBeingUnloaded() == GetIndex())
            continue;
        ClassLoader *pcl = i.GetAssembly()->GetLoader();
        for (pmod = pcl->m_pHeadModule;  pmod != NULL;  pmod = pmod->GetNextModule()) {
            hr = pcl->RunDllMain(DLL_PROCESS_DETACH);
            if (FAILED(hr))
                break;
        }
    }

    return hr;
}

struct GetExposedObject_Args
{
    AppDomain *pDomain;
    OBJECTREF *ref;
};

static void GetExposedObject_Wrapper(GetExposedObject_Args *args)
{
    *(args->ref) = args->pDomain->GetExposedObject();
}


OBJECTREF AppDomain::GetExposedObject()
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF ref = GetRawExposedObject();
    if (ref == NULL)
    {
        APPDOMAINREF obj = NULL;

        Thread *pThread = GetThread();
        if (pThread->GetDomain() != this)
        {
            GCPROTECT_BEGIN(ref);
            GetExposedObject_Args args = {this, &ref};
            // call through DoCallBack with a domain transition
            pThread->DoADCallBack(GetDefaultContext(), GetExposedObject_Wrapper, &args);
            GCPROTECT_END();
            return ref;
        }
        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__APP_DOMAIN);

        // Create the module object
        obj = (APPDOMAINREF) AllocateObject(pMT);
        obj->SetDomain(this);

        if(StoreFirstObjectInHandle(m_ExposedObject, (OBJECTREF) obj) == FALSE) {
            obj = (APPDOMAINREF) GetRawExposedObject();
            _ASSERTE(obj);
        }

        return (OBJECTREF) obj;
    }

    return ref;
}

void AppDomain::CreateSecurityDescriptor()
{
    if (m_pSecDesc != NULL)
        delete m_pSecDesc;

    m_pSecDesc = new ApplicationSecurityDescriptor(this);
}

void BaseDomain::AddAssemblyNoLock(Assembly* assem)
{
    _ASSERTE(assem);

    // Make sure that only system assemblies are added to the system domain,
    // and vice versa.
    _ASSERTE((SystemDomain::System() == this) == (assem->IsSystem()));

    // Make sure that all assemblies in the system domain are shared
    _ASSERTE(!assem->IsSystem() || assem->GetDomain() == SharedDomain::GetDomain());

    m_Assemblies.Append(assem);
}

void AppDomain::AllocateComCallMLStubCache()
{
    APPDOMAIN_LOCK(this);
    if (m_pComCallMLStubCache == NULL)
        m_pComCallMLStubCache = new ComCallMLStubCache();
}

void AppDomain::AllocateFieldCallStubCache()
{
    APPDOMAIN_LOCK(this);
    if (m_pFieldCallStubCache == NULL)
        m_pFieldCallStubCache = new ArgBasedStubCache();
}

void AppDomain::OnAssemblyLoad(Assembly *assem)
{
    if (assem->GetDomain() == SharedDomain::GetDomain())
    {
        //
        // @todo: ideally we should use the max index in this assembly, rather than
        // the global max.
        //
        GetDomainLocalBlock()->EnsureIndex(SharedDomain::GetDomain()->GetMaxSharedClassIndex());
        
        //
        // Allocate our exposed object handle, if it hasn't already been allocated.
        // This avoids the need to have to take a lock to allocate it later.
        //
        assem->AllocateExposedObjectHandle(this);
    }

#ifdef DEBUGGING_SUPPORTED
    if (IsDebuggerAttached())
    {
        // If this is the first assembly in the AppDomain, it may be possible to get a better name than the
        // default.
        if (m_Assemblies.Get(0) == assem && !IsUserCreatedDomain())
            ResetFriendlyName();

            assem->NotifyDebuggerAttach(this, ATTACH_ALL, FALSE);
    }

    if (assem->IsShared() && !assem->IsSystem())
    {
        // This shared assembly may be a dependency of other
        // shared assemblies, which have already been loaded into
        // other domains.  If so, we would expect to run
        // LoadAssembly logic in those domains as well.  However,
        // the loader currently doesn't implement this.  So we
        // manually implement the logic here for the sake of the
        // debugger.

        AppDomainIterator i;
    
        while (i.Next())
        {
            AppDomain *pDomain = i.GetDomain();
            if (pDomain != this 
                && pDomain->IsDebuggerAttached()
                && !pDomain->ContainsAssembly(assem)
                && pDomain->IsUnloadedDependency(assem) == S_OK)
            {
                // Note that we are a bit loose about synchronization here, so we
                // may actually call NotifyDebuggerAttach more than once for the
                // same domain/assembly. But the out of process debugger is smart
                // enough to notice & ignore duplicates.

                assem->NotifyDebuggerAttach(pDomain, ATTACH_ALL, FALSE);
            }
        }
    }
#endif // DEBUGGING_SUPPORTED

    // For shared assemblies, we need to record all the PE files that we depend on for later use

    PEFileBinding *pDeps;
    DWORD cDeps;

    if (assem->GetSharingProperties(&pDeps, &cDeps) == S_OK)
    {
        PEFileBinding *pDepsEnd = pDeps + cDeps;
        while (pDeps < pDepsEnd)
        {
            if (pDeps->pPEFile != NULL)
            {
                BOOL added = FALSE;

                if (m_sharedDependenciesMap.LookupValue((UPTR)pDeps->pPEFile->GetBase(), pDeps)
                    == (LPVOID) INVALIDENTRY)
                {
                    APPDOMAIN_CACHE_LOCK(this);
                        
                    // Check again now that we have the lock
                    if (m_sharedDependenciesMap.LookupValue((UPTR)pDeps->pPEFile->GetBase(), pDeps)
                        == (LPVOID) INVALIDENTRY)
                    {
                        m_sharedDependenciesMap.InsertValue((UPTR)pDeps->pPEFile->GetBase(), pDeps);
                        added = TRUE;
                    }
                }

#ifdef DEBUGGING_SUPPORTED
                if (added && IsDebuggerAttached())
                {
                    // The new dependency may have an existing shared assembly for it.
                    Assembly *pDepAssembly;

                    if (SharedDomain::GetDomain()->FindShareableAssembly(pDeps->pPEFile->GetBase(), 
                                                                         &pDepAssembly) == S_OK)
                    {
                        if (!ContainsAssembly(pDepAssembly))
                        {
                            LOG((LF_CORDB, LL_INFO100, "AD::NDA: Iterated shared assembly dependency AD:%#08x %s\n", 
                                 pDepAssembly, pDepAssembly->GetName()));
                        
                            pDepAssembly->NotifyDebuggerAttach(this, ATTACH_ALL, FALSE);
                        }
                    }
                }
#endif // DEBUGGING_SUPPORTED

            }

            pDeps++;
        }
    }

}

void AppDomain::OnAssemblyLoadUnlocked(Assembly *assem)
{
    // Notice if this is the special classes dll
    NoticeSpecialClassesAssembly(assem);

    RaiseLoadingAssemblyEvent(assem);
}

void SystemDomain::OnAssemblyLoad(Assembly *assem)
{
    if (!g_fEEInit)
    {
        //
        // Notify all attached app domains of the new assembly.
        //

        AppDomainIterator i;

        while (i.Next())
        {
            AppDomain *pDomain = i.GetDomain();

            pDomain->OnAssemblyLoad(assem);
        }
    }
}

void SystemDomain::NotifyNewDomainLoads(AppDomain *pDomain)
{
    if (!g_fEEInit)
    {
        AssemblyIterator i = IterateAssemblies();

        while (i.Next())
            pDomain->OnAssemblyLoad(i.GetAssembly());
    }
}

void BaseDomain::AddAssembly(Assembly* assem)
{
    BEGIN_ENSURE_PREEMPTIVE_GC();
    EnterLoadLock();
    END_ENSURE_PREEMPTIVE_GC();

    AddAssemblyNoLock(assem);
    OnAssemblyLoad(assem);

    LeaveLoadLock();

    OnAssemblyLoadUnlocked(assem);
}

BOOL BaseDomain::ContainsAssembly(Assembly *assem)
{
    AssemblyIterator i = IterateAssemblies();

    while (i.Next())
    {
        if (i.GetAssembly() == assem)
            return TRUE;
    }

    return FALSE;
}

HRESULT BaseDomain::CreateAssembly(Assembly** ppAssembly)
{
    _ASSERTE(ppAssembly);

    Assembly* assem = new (nothrow) Assembly();
    if(assem == NULL)
        return E_OUTOFMEMORY;

    // Intialize the assembly
    assem->SetParent(this);
    HRESULT hr = assem->Init(false);
    if(FAILED(hr)) {
        delete assem;
        return hr;
    }

    *ppAssembly = assem;
    return S_OK;
}


//******************************
//
// Create dynamic assembly
//
//******************************
HRESULT BaseDomain::CreateDynamicAssembly(CreateDynamicAssemblyArgs *args, Assembly** ppAssembly)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(ppAssembly);

    Assembly *pAssem = new (throws) Assembly();
    pAssem->SetParent(this);

    // it is a dynamic assembly
    HRESULT hr = pAssem->Init(true);
    if(FAILED(hr)) {
        delete pAssem;
        return hr;
    }
    // Set the dynamic assembly access
    pAssem->m_dwDynamicAssemblyAccess = args->access;

#ifdef PROFILING_SUPPORTED
    if (CORProfilerTrackAssemblyLoads())
        g_profControlBlock.pProfInterface->AssemblyLoadStarted((ThreadID) GetThread(), (AssemblyID) pAssem);
#endif // PROFILING_SUPPORTED

    AssemblySecurityDescriptor *pSecDesc = AssemSecDescHelper::Allocate(SystemDomain::GetCurrentDomain());
    if (pSecDesc == NULL) {
        delete pAssem;
        COMPlusThrowOM();
    }

    pSecDesc = pSecDesc->Init(pAssem);
    
    // Propagate identity and permission request information into the assembly's
    // security descriptor. Then when policy is resolved we'll end up with the
    // correct grant set.
    // If identity has not been provided then the caller's assembly will be
    // calculated instead and we'll just copy the granted permissions from the
    // caller to the new assembly and mark policy as resolved (done
    // automatically by SetGrantedPermissionSet).
    pSecDesc->SetRequestedPermissionSet(args->requiredPset,
                                        args->optionalPset,
                                        args->refusedPset);
    
    // Don't bother with setting up permissions if this isn't allowed to run
    if ((args->identity != NULL) &&
        (args->access != ASSEMBLY_ACCESS_SAVE))
        pSecDesc->SetEvidence(args->identity);
    else {
        AssemblySecurityDescriptor *pCallerSecDesc = NULL;
        AppDomain *pCallersDomain;
        Assembly *pCaller = SystemDomain::GetCallersAssembly(args->stackMark, &pCallersDomain);
        if (pCaller) { // can be null if caller is interop
            struct _gc {
                OBJECTREF granted;
                OBJECTREF denied;
                
            } gc;
            ZeroMemory(&gc, sizeof(gc));
            GCPROTECT_BEGIN(gc);
            pCallerSecDesc = pCaller->GetSecurityDescriptor(pCallersDomain);
            gc.granted = pCallerSecDesc->GetGrantedPermissionSet(&(gc.denied));
            // Caller may be in another appdomain context, in which case we'll
            // need to marshal/unmarshal the grant and deny sets across.
            if (pCallersDomain != GetAppDomain()) {
                gc.granted = AppDomainHelper::CrossContextCopyFrom(pCallersDomain->GetId(), &(gc.granted));
                if (gc.denied != NULL)
                    gc.denied = AppDomainHelper::CrossContextCopyFrom(pCallersDomain->GetId(), &(gc.denied));
            }
            pSecDesc->SetGrantedPermissionSet(gc.granted, gc.denied);
            pAssem->GetSharedSecurityDescriptor()->SetResolved();
            GCPROTECT_END();
        }
        
        if (!pCaller || pCallerSecDesc->IsFullyTrusted()) // interop gets full trust
            pSecDesc->MarkAsFullyTrusted();
    }

    struct _gc {
        STRINGREF strRefName;
        OBJECTREF cultureinfo;
        STRINGREF pString;
        OBJECTREF throwable;
        OBJECTREF orArrayOrContainer;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    
    GCPROTECT_BEGIN(gc);
    IMetaDataAssemblyEmit *pAssemEmitter = NULL;

    // Allocate the dynamic module for the runtime working copy manifest.
    // When we create dynamic assembly, we always use a working copy of IMetaDataAssemblyEmit
    // to store temporary runtime assembly information. This is due to how assembly is currently
    // working. It is very hard to plug in things if we don't have a copy of IMetaDataAssemblyImport.
    // This working copy of IMetaDataAssemblyEmit will store every AssemblyRef as a simple name
    // reference as we must have an instance of Assembly(can be dynamic assembly) before we can
    // add such a reference. Also because the referenced assembly if dynamic strong name, it may
    // not be ready to be hashed!
    //
    CorModule *pWrite = allocateReflectionModule();
    if (!pWrite)
        IfFailGo(E_OUTOFMEMORY);

    // intiailize the dynamic module
    hr = pWrite->Initialize(CORMODULE_NEW, IID_ICeeGen, IID_IMetaDataEmit);
    if (FAILED(hr))
        IfFailGo(E_OUTOFMEMORY);

    // set up the data members!
    pAssem->m_pDynamicCode = pWrite;;
    pAssem->m_pManifest = (Module *)pWrite->GetReflectionModule();
    pAssem->m_kManifest = TokenFromRid(1, mdtManifestResource);
    pAssem->m_pManifestImport = pAssem->m_pManifest->GetMDImport();
    pAssem->m_pManifestImport->AddRef();

    // remember the hash algorithm
    pAssem->m_ulHashAlgId = args->assemblyName->GetAssemblyHashAlgorithm();
    if (pAssem->m_ulHashAlgId == 0)
        pAssem->m_ulHashAlgId = CALG_SHA1;
    pAssem->m_Context = new (nothrow) AssemblyMetaDataInternal;
    if (!pAssem->m_Context)
        IfFailGo(E_OUTOFMEMORY);

    memset(pAssem->m_Context, 0, sizeof(AssemblyMetaDataInternal));

    // get the version info if there is any
    if (args->assemblyName->GetVersion() != NULL) {
        pAssem->m_Context->usMajorVersion = ((VERSIONREF) args->assemblyName->GetVersion())->GetMajor();
        pAssem->m_Context->usMinorVersion = ((VERSIONREF) args->assemblyName->GetVersion())->GetMinor();
        pAssem->m_Context->usBuildNumber = ((VERSIONREF) args->assemblyName->GetVersion())->GetBuild();
        pAssem->m_Context->usRevisionNumber = ((VERSIONREF) args->assemblyName->GetVersion())->GetRevision();
    }

    // This code is kind of duplicated from AssemblyName.ConvertToAssemblyMetaData.
    // Unfortunately, we are talking to the public APIs. We need to fill AssemblyMetaData not AssemblyMetaDataInternal.
    // @FUTURE: Maybe expose a metadata internal API to take AssemblyMetaDataInternal. We also need to keep these data
    // @FUTURE: around rather than stack allocating.

    // get the culture info if there is any
    {
        gc.cultureinfo = args->assemblyName->GetCultureInfo();
        if (gc.cultureinfo != NULL) {

            MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__CULTURE_INFO__GET_NAME);

            INT64 args2[] = {
                ObjToInt64(gc.cultureinfo)
            };

            // convert culture info into a managed string form
            INT64 ret = pMD->Call(args2, METHOD__CULTURE_INFO__GET_NAME);
            gc.pString = ObjectToSTRINGREF(*(StringObject**)(&ret));

            // retrieve the string and copy it into unmanaged space
            if (gc.pString != NULL) {
                DWORD lgth = gc.pString->GetStringLength();
                if(lgth) {
                    LPSTR lpLocale = new (nothrow) char[(lgth+1)*3];
                    if (lpLocale) {
                        VERIFY(WszWideCharToMultiByte(CP_UTF8, 0, gc.pString->GetBuffer(), -1,
                                               lpLocale, (lgth+1)*3, NULL, NULL));
                        pAssem->m_Context->szLocale = lpLocale;
                        pAssem->m_FreeFlag |= Assembly::FREE_LOCALE;
                    }
                    else
                        IfFailGo(E_OUTOFMEMORY);
                }
            }
        }
        else
            pAssem->m_Context->szLocale = 0;
    }

    _ASSERTE(pAssem->m_pbPublicKey == NULL);
    _ASSERTE(pAssem->m_cbPublicKey == 0);

    pAssem->SetStrongNameLevel(Assembly::SN_NONE);

    if (args->assemblyName->GetPublicKey() != NULL) {
        pAssem->m_cbPublicKey = args->assemblyName->GetPublicKey()->GetNumComponents();
        if (pAssem->m_cbPublicKey) {
            pAssem->m_pbPublicKey = new (nothrow) BYTE[pAssem->m_cbPublicKey];
            if (!pAssem->m_pbPublicKey)
                IfFailGo(E_OUTOFMEMORY);

            pAssem->m_FreeFlag |= pAssem->FREE_PUBLIC_KEY;
            memcpy(pAssem->m_pbPublicKey, args->assemblyName->GetPublicKey()->GetDataPtr(), pAssem->m_cbPublicKey);

            pAssem->SetStrongNameLevel(Assembly::SN_PUBLIC_KEY);

            // If there's a public key, there might be a strong name key pair.
            if (args->assemblyName->GetStrongNameKeyPair() != NULL) {
                MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__STRONG_NAME_KEY_PAIR__GET_KEY_PAIR);

                INT64 arglist[] = {
                    ObjToInt64(args->assemblyName->GetStrongNameKeyPair()),
                    (INT64)(&gc.orArrayOrContainer)
                };

                BOOL bKeyInArray;
                bKeyInArray = (BOOL)pMD->Call(arglist, METHOD__STRONG_NAME_KEY_PAIR__GET_KEY_PAIR);

                if (bKeyInArray) {
                    pAssem->m_cbStrongNameKeyPair = ((U1ARRAYREF)gc.orArrayOrContainer)->GetNumComponents();
                    pAssem->m_pbStrongNameKeyPair = new (nothrow) BYTE[pAssem->m_cbStrongNameKeyPair];
                    if (!pAssem->m_pbStrongNameKeyPair)
                        IfFailGo(E_OUTOFMEMORY);

                    pAssem->m_FreeFlag |= pAssem->FREE_KEY_PAIR;
                    memcpy(pAssem->m_pbStrongNameKeyPair, ((U1ARRAYREF)gc.orArrayOrContainer)->GetDataPtr(), pAssem->m_cbStrongNameKeyPair);
                    pAssem->SetStrongNameLevel(Assembly::SN_FULL_KEYPAIR_IN_ARRAY);
                }
                else {
                    DWORD cchContainer = ((STRINGREF)gc.orArrayOrContainer)->GetStringLength();
                    pAssem->m_pwStrongNameKeyContainer = new (nothrow) WCHAR[cchContainer + 1];
                    if (!pAssem->m_pwStrongNameKeyContainer)
                        IfFailGo(E_OUTOFMEMORY);

                    pAssem->m_FreeFlag |= pAssem->FREE_KEY_CONTAINER;
                    memcpy(pAssem->m_pwStrongNameKeyContainer, ((STRINGREF)gc.orArrayOrContainer)->GetBuffer(), cchContainer * sizeof(WCHAR));
                    pAssem->m_pwStrongNameKeyContainer[cchContainer] = L'\0';
                    pAssem->SetStrongNameLevel(Assembly::SN_FULL_KEYPAIR_IN_CONTAINER);
                }
            }
        }
    }

    // assign simple name
    int len = 0;
    gc.strRefName = (STRINGREF) args->assemblyName->GetSimpleName();
    if ((gc.strRefName == NULL) ||
        (0 == (len = gc.strRefName->GetStringLength()) ) ||
        (*(gc.strRefName->GetBuffer()) == L'\0'))
        COMPlusThrow(kArgumentException, L"ArgumentNull_AssemblyNameName");

    if (COMCharacter::nativeIsWhiteSpace(*(gc.strRefName->GetBuffer())) ||
        wcschr(gc.strRefName->GetBuffer(), '\\') ||
        wcschr(gc.strRefName->GetBuffer(), ':') ||
        wcschr(gc.strRefName->GetBuffer(), '/'))
        COMPlusThrow(kArgumentException, L"Argument_InvalidAssemblyName");

    
    int cStr = WszWideCharToMultiByte(CP_UTF8,
                                      0,
                                      gc.strRefName->GetBuffer(),
                                      len,
                                      0,
                                      0,
                                      NULL,
                                      NULL);
    pAssem->m_psName = new (nothrow) char[cStr+1];
    if (!pAssem->m_psName)
        IfFailGo(E_OUTOFMEMORY);

    pAssem->m_FreeFlag |= pAssem->FREE_NAME;

    cStr = WszWideCharToMultiByte(CP_UTF8,
                                  0,
                                  gc.strRefName->GetBuffer(),
                                  len,
                                  (char *)pAssem->m_psName,
                                  cStr,
                                  NULL,
                                  NULL);
    if(cStr == 0)
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

    ((char *)(pAssem->m_psName))[cStr] = 0;


    // get flags
    pAssem->m_dwFlags = args->assemblyName->GetFlags();

    // Define the mdAssembly info
    IMetaDataEmit *pEmitter = pAssem->m_pManifest->GetEmitter();
    _ASSERTE(pEmitter);

    IfFailGo( pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &pAssemEmitter) );
    _ASSERTE(pAssemEmitter);

    ASSEMBLYMETADATA assemData;
    memset(&assemData, 0, sizeof(ASSEMBLYMETADATA));

    assemData.usMajorVersion = pAssem->m_Context->usMajorVersion;
    assemData.usMinorVersion = pAssem->m_Context->usMinorVersion;
    assemData.usBuildNumber = pAssem->m_Context->usBuildNumber;
    assemData.usRevisionNumber = pAssem->m_Context->usRevisionNumber;
    if (pAssem->m_Context->szLocale) {
        assemData.cbLocale = (ULONG)(strlen(pAssem->m_Context->szLocale) + 1);
        #define MAKE_TRANSLATIONFAILED  IfFailGo(E_INVALIDARG)
        MAKE_WIDEPTR_FROMUTF8(wzLocale, pAssem->m_Context->szLocale);
        #undef MAKE_TRANSLATIONFAILED
        assemData.szLocale = wzLocale;
    }

    mdAssembly ma;
    IfFailGo( pAssemEmitter->DefineAssembly(
        pAssem->m_pbPublicKey,  // [IN] Public key of the assembly.
        pAssem->m_cbPublicKey,  // [IN] Count of bytes in the public key blob.
        pAssem->m_ulHashAlgId,  // [IN] Hash Algorithm.
        gc.strRefName->GetBuffer(),// [IN] Name of the assembly.
        &assemData,             // [IN] Assembly MetaData.
        pAssem->m_dwFlags,      // [IN] Flags.
        &ma) );                 // [OUT] Returned Assembly token.

    // Create the File hash table
    if (!pAssem->m_pAllowedFiles->Init(2, NULL))
        IfFailGo(E_OUTOFMEMORY);

    // Add the manifest module to the assembly because cache is set up by AddModule.
    IfFailGo(pAssem->AddModule(pAssem->m_pManifest,
                               mdFileNil,
                               TRUE,
                               &gc.throwable) );

    // Add the assembly security descriptor to a list of descriptors to be
    // processed later by the appdomain permission list set security
    // optimization.
    pSecDesc->AddDescriptorToDomainList();

    *ppAssembly = pAssem;

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

#ifdef PROFILING_SUPPORTED
    if (CORProfilerTrackAssemblyLoads())
          g_profControlBlock.pProfInterface->AssemblyLoadFinished(
          (ThreadID) GetThread(), (AssemblyID) pAssem, hr);
#endif // PROFILING_SUPPORTED

    if (gc.throwable != NULL)
        COMPlusThrow(gc.throwable);

    GCPROTECT_END();

    return hr;
}

// Lock must be taken before creating this entry
AssemblyLockedListElement* BaseDomain::CreateAssemblyLockEntry(BYTE* baseAddress)
{
    AssemblyLockedListElement* pEntry = new (nothrow) AssemblyLockedListElement;
    if(pEntry == NULL) return NULL;

    pEntry->AddEntryToList(&m_AssemblyLoadLock, baseAddress);
    pEntry->m_hrResultCode = S_OK;
    pEntry->SetAssembly(NULL);
    return pEntry;
}



void BaseDomain::AddAssemblyLeaveLock(Assembly* pAssembly, AssemblyLockedListElement* pEntry)
{
    COMPLUS_TRY 
    {
        EnterLoadLock();
        // We successfully added the domain to the
        AddAssemblyNoLock(pAssembly);
        OnAssemblyLoad(pAssembly);
        LeaveLoadLock();
        pEntry->SetAssembly(pAssembly);
        pEntry->Leave();

        OnAssemblyLoadUnlocked(pAssembly);
    }
    COMPLUS_CATCH
    {
        //@TODO: Fix this.
        _ASSERTE(!"AddAssemblyLeaveLock() -- took exception, but not exception safe");
        FreeBuildDebugBreak();
    }
    COMPLUS_END_CATCH
}


HRESULT BaseDomain::ApplySharePolicy(PEFile *pFile, BOOL* pfCreateShared)
{
    HRESULT hr = S_OK;
    _ASSERTE(pfCreateShared);

    *pfCreateShared = FALSE;
    switch(GetSharePolicy()) {

    case SHARE_POLICY_ALWAYS:
        *pfCreateShared = TRUE;
        break;

    case SHARE_POLICY_STRONG_NAMED:
    {
        // Lets look at the PE file and see what the shared information is
        IMDInternalImport *pMDImport = pFile->GetMDImport();
        mdAssembly kManifest;
        PBYTE pbPublicKey;
        DWORD cbPublicKey;

        /*hr = */pMDImport->GetAssemblyFromScope(&kManifest);
        /*hr = */pMDImport->GetAssemblyProps(kManifest,                    // [IN] The Assembly for which to get the properties.         
                                    (const void**) &pbPublicKey,  // [OUT] Pointer to the public key blob.                      
                                    &cbPublicKey,                 // [OUT] Count of bytes in the public key blob.               
                                    NULL,                         // [OUT] Hash Algorithm.                                      
                                    NULL,                         // [OUT] Buffer to fill with name.                            
                                    NULL,                         // [OUT] Assembly MetaData.                                   
                                    NULL);                        // [OUT] Flags.                                               

        if(pbPublicKey && cbPublicKey)
            *pfCreateShared = TRUE;
    }
    break;

    case SHARE_POLICY_NEVER:
        break;

    default:
        _ASSERTE(!"Unknown share policy");
        break;
    }

    return hr;
}

// Returns
//   S_OK: success
//   S_FALSE: already loaded in this domain
HRESULT BaseDomain::LoadAssembly(PEFile *pFile,
                                 IAssembly* pIAssembly,
                                 Module** ppModule,
                                 Assembly** ppAssembly,
                                 OBJECTREF *pExtraEvidence,
                                 OBJECTREF *pEvidence,
                                 BOOL fPolicyLoad,
                                 OBJECTREF *pThrowable)
{
    _ASSERTE(pEvidence == NULL || pExtraEvidence == NULL);
    _ASSERTE(pFile);

    HRESULT hr;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    Module *pModule;
    Assembly *pAssembly = NULL;
    BOOL zapFound = FALSE;
    AssemblyLockedListElement *pEntry = NULL;
    BOOL fCreateShared = FALSE;

    // Always load system files into the system domain.
    if (pFile->IsSystem() && this != SystemDomain::System()) {
        return SystemDomain::System()->LoadAssembly(pFile, 
                                                    pIAssembly,
                                                    ppModule, 
                                                    ppAssembly,
                                                    pExtraEvidence,
                                                    pEvidence,
                                                    fPolicyLoad,
                                                    pThrowable);
    }

    TIMELINE_START(LOADER, ("LoadAssembly %S", pFile->GetLeafFileName()));

    // Enable pre-emptive GC. We are not touching managed code
    // for quite awhile and we can tolerate GC's
    Thread *td = GetThread();
    _ASSERTE(td != NULL && "The current thread is not known by the EE");

    BEGIN_ENSURE_PREEMPTIVE_GC();

    EnterLoadLock();

    //
    // It is the responsibility of the caller to detect and handle
    // circular loading loops.
    //
    //_ASSERTE(FindLoadingAssembly(pFile->GetBase()) == NULL);

    //
    // See if we have already loaded the module into the
    // system domain or into the current domain.
    //

    pModule = FindModule(pFile->GetBase());
    if (pModule) {
        LeaveLoadLock();

        BEGIN_ENSURE_COOPERATIVE_GC();
        if (((pExtraEvidence != NULL) && (*pExtraEvidence != NULL)) ||
            ((pEvidence != NULL) && (*pEvidence != NULL))) {
            hr = SECURITY_E_INCOMPATIBLE_EVIDENCE;
            #define MAKE_TRANSLATIONFAILED szName=""
            MAKE_UTF8PTR_FROMWIDE(szName,
                                  pFile->GetFileName() ? pFile->GetFileName() : L"<Unknown>");
            #undef MAKE_TRANSLATIONFAILED
            PostFileLoadException(szName, TRUE, NULL,
                                  SECURITY_E_INCOMPATIBLE_EVIDENCE, pThrowable);
        }
        else {
            pAssembly = pModule->GetAssembly();
            hr = S_FALSE;
            delete pFile;
            pFile = NULL;
        }

        END_ENSURE_COOPERATIVE_GC();
        goto FinalExit;
    }


    pEntry = (AssemblyLockedListElement*) m_AssemblyLoadLock.Find(pFile->GetBase());
    if(pEntry == NULL) {
        pEntry = CreateAssemblyLockEntry(pFile->GetBase());
        if(pEntry == NULL) {
            hr = E_OUTOFMEMORY;
            LeaveLoadLock();
            goto FinalExit;
        }

        if(!pEntry->DeadlockAwareEnter()) {
            pEntry->m_hrResultCode = HRESULT_FROM_WIN32(ERROR_POSSIBLE_DEADLOCK);
            LeaveLoadLock();
            goto Exit;
        }

        LeaveLoadLock();

        if (FAILED(hr = Assembly::CheckFileForAssembly(pFile))) {
            pEntry->m_hrResultCode = hr;
            pEntry->Leave();
            goto Exit;
        }

        // Allocate a security descriptor for the assembly.
        AssemblySecurityDescriptor *pSecDesc = AssemSecDescHelper::Allocate(SystemDomain::GetCurrentDomain());
        if (pSecDesc == NULL) {
            pEntry->m_hrResultCode = E_OUTOFMEMORY;
            pEntry->Leave();
            goto Exit;
        }

        if (pExtraEvidence!=NULL)
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            if(*pExtraEvidence!=NULL)
                pSecDesc->SetAdditionalEvidence(*pExtraEvidence);
            END_ENSURE_COOPERATIVE_GC();
        }
        else if (pEvidence!=NULL)
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            if(*pEvidence!=NULL)
                pSecDesc->SetEvidence(*pEvidence);
            END_ENSURE_COOPERATIVE_GC();
        }

        // Determine if we are in a LoadFrom context.  If so, we must
        // disable sharing & zaps.  This is because the eager binding required
        // to do version checking in those scenarios interferes with the behavior
        // of LoadFrom.

        BOOL fLoadFrom = FALSE;
        if (pIAssembly) {
            IFusionLoadContext *pLoadContext;
            hr = pIAssembly->GetFusionLoadContext(&pLoadContext);
            _ASSERTE(SUCCEEDED(hr));
            if (SUCCEEDED(hr)) {
                if (pLoadContext->GetContextType() == LOADCTX_TYPE_LOADFROM) {
                    fLoadFrom = TRUE;
                }
                                pLoadContext->Release();
            }
        }
                    
        // Determine whether we are suppose to load the assembly as a shared
        // assembly or into the base domain.
        if (!fLoadFrom) {
            hr = ApplySharePolicy(pFile, &fCreateShared);
            if(FAILED(hr)) {
                pEntry->m_hrResultCode = hr;
                pEntry->Leave();
                goto Exit;
            }
        }

        //
        // Now, look for a shared module we can use.
        //
        // @todo: We have to be careful about the cost of this.  If
        // we allow per-app-domain decisions about whether to share
        // modules, we need to check that preference here.  (If it's
        // not supposed to be shared, we don't want the extra-slow
        // shared code, and we don't want the up-front expense of
        // checking dependencies.) -seantrow
        //
        // For now, assume this decision will be made on a process-wide
        // basis so don't bother to check. (Note that FindShareableAssembly is
        // cheap if we haven't loaded the module shared anywhere yet - it's only
        // expensive when we need to verify compatibility with one or more
        // existing shared module.)
        //

        if (fCreateShared) {
            //
            // Try to find an existing shared version of the assembly which
            // is compatible with our domain.
            //

            SharedDomain *pSharedDomain = SharedDomain::GetDomain();

            TIMELINE_START(LOADER, ("FindShareableAssembly %S", 
                                    pFile->GetLeafFileName()));

            hr = pSharedDomain->FindShareableAssembly(pFile->GetBase(), &pAssembly);

            TIMELINE_END(LOADER, ("FindShareableAssembly %S", 
                                  pFile->GetLeafFileName()));

            if (hr == S_OK) {
                //
                // If the either the current load, or any of the previous loads
                // of this assembly were performed with extra security evidence,
                // or into an appdomain with a specific policy level set, we
                // stand a chance of generating a different grant set for this
                // instance of the assembly. This is not permissable (since
                // we're sharing code, and code potentially has the results of
                // security linktime checks burned in). So we must check what
                // policy would resolve to and if it differs, throw a load
                // exception. 
                //

                BOOL fCanLoad = FALSE;

                TIMELINE_START(LOADER, ("Resolve %S", 
                                        pFile->GetLeafFileName()));

                BEGIN_ENSURE_COOPERATIVE_GC();
                COMPLUS_TRY {

                    SharedSecurityDescriptor *pSharedSecDesc = pAssembly->GetSharedSecurityDescriptor();
                    BOOL fExtraPolicy = ((APPDOMAINREF)GetAppDomain()->GetExposedObject())->HasSetPolicy();

                    if (!pSharedSecDesc->IsSystem() &&
                        (pSharedSecDesc->IsModifiedGrant() ||
                         fExtraPolicy ||
                         (pExtraEvidence != NULL && *pExtraEvidence != NULL) ||
                         (pEvidence != NULL && *pEvidence != NULL))) {
                        // Make sure the current appdomain has expanded its DLS
                        // to at least include the index for this assembly.
                        GetAppDomain()->GetDomainLocalBlock()->EnsureIndex(pAssembly->m_ExposedObjectIndex);

                        // Force policy resolve in the existing assemblies if this
                        // hasn't happened yet. Note that this resolution will
                        // take place in an arbitrary appdomain context, with
                        // the exception that it won't be the current appdomain
                        // (this is important if this appdomain has additional
                        // policy set).
                        pSharedSecDesc->Resolve();

                        // If the previous step didn't do anything, we're in the
                        // edge condition where a shared assembly was loaded
                        // into another appdomain, which was then unloaded
                        // before the assembly resolved policy. In this case,
                        // it's OK to allow the current load to proceed (it
                        // can't generate a conflicting grant set by
                        // definition), but we should mark the grant set as
                        // modified since it could conflict with the next
                        // unmodified load.
                        if (!pSharedSecDesc->IsResolved()) {
                            fCanLoad = TRUE;
                            pSharedSecDesc->SetModifiedGrant();
                        }
                        else {
                            // Gather evidence for the current assembly instance and
                            // resolve and compare grant sets in one managed
                            // operation.
                            struct _gc {
                                OBJECTREF orEvidence;
                                OBJECTREF orMinimal;
                                OBJECTREF orOptional;
                                OBJECTREF orRefuse;
                                OBJECTREF orGranted;
                                OBJECTREF orDenied;
                            } gc;
                            ZeroMemory(&gc, sizeof(gc));

                            GCPROTECT_BEGIN(gc);

                            // We need to partially initialize the assembly security
                            // descriptor for the code below to work.
                            pSecDesc->Init(pAssembly, false);

                            if (pSecDesc->GetProperties(CORSEC_EVIDENCE_COMPUTED))
                                gc.orEvidence = pSecDesc->GetAdditionalEvidence();
                            else
                                gc.orEvidence = pSecDesc->GetEvidence();
                            gc.orMinimal = pSecDesc->GetRequestedPermissionSet(&gc.orOptional, &gc.orRefuse);
                            gc.orGranted = pSharedSecDesc->GetGrantedPermissionSet(&gc.orDenied);

                            INT64 args[] = {
                                ObjToInt64(gc.orDenied),
                                ObjToInt64(gc.orGranted),
                                ObjToInt64(gc.orRefuse),
                                ObjToInt64(gc.orOptional),
                                ObjToInt64(gc.orMinimal),
                                ObjToInt64(gc.orEvidence)
                            };

                            fCanLoad = Security::CheckGrantSets(args);

                            GCPROTECT_END();
                        }
                    }
                    else
                        fCanLoad = TRUE;

                } COMPLUS_CATCH {
#ifdef _DEBUG                   
                    HRESULT caughtHr = SecurityHelper::MapToHR(GETTHROWABLE());
#endif //_DEBUG
                } COMPLUS_END_CATCH
                END_ENSURE_COOPERATIVE_GC();

                TIMELINE_END(LOADER, ("Resolve %S", 
                                      pFile->GetLeafFileName()));

                if (fCanLoad) {
                    //
                    // Post the fact that we are loading the assembly.
                    // 
                    if (SUCCEEDED(pEntry->m_hrResultCode)) {
                        pAssembly->IncrementShareCount();
                        pModule = pAssembly->GetManifestModule();
                        delete pFile;
                        pFile = NULL;

                        pSecDesc = pSecDesc->Init(pAssembly);
                        if (pAssembly->IsSystem())
                            pSecDesc->GetSharedSecDesc()->SetSystem();

                        // Add the assembly security descriptor to a list of descriptors to be
                        // processed later by the appdomain permission list set security
                        // optimization.
                        pSecDesc->AddDescriptorToDomainList();

                        AddAssemblyLeaveLock(pAssembly, pEntry);
                    }
                    else {
                        pEntry->Leave();
                    }

                    goto Exit;
                }
                else {
                    // Can't load this assembly since its security grant set
                    // would conflict with shared instances already loaded.
                    pEntry->m_hrResultCode = SECURITY_E_INCOMPATIBLE_SHARE;
                    #define MAKE_TRANSLATIONFAILED szName=""
                    MAKE_UTF8PTR_FROMWIDE(szName,
                                          pFile->GetFileName() ? pFile->GetFileName() : L"<Unknown>");
                    #undef MAKE_TRANSLATIONFAILED

                    PostFileLoadException(szName, TRUE, NULL,
                                          SECURITY_E_INCOMPATIBLE_SHARE, pThrowable);
                    pEntry->Leave();
                    goto Exit;
                }
            }
            else {
                // Go ahead and create new shared version of the assembly if possible
                hr = CreateShareableAssemblyNoLock(pFile,
                                                   pIAssembly,
                                                   &pAssembly);

                if (SUCCEEDED(hr)) {

                    if (FAILED(pEntry->m_hrResultCode)) {
                        pEntry->Leave();
                        goto Exit;
                    }

                    //
                    // If this new shared assembly has been loaded in an unusual
                    // security environment (additional evidence was supplied on
                    // the load or appdomain specific policy is present), record
                    // the fact so that, if we attempt to load the assembly in
                    // another context, we'll be warned to check that the grant
                    // sets for each instance of the assembly are the same. 
                    //

                    BOOL fModifiedGrant = TRUE;
#ifndef _IA64_
                    //
                    // @TODO_IA64: the SystemDomain isn't present on IA64 yet
                    //
                    if (this == SystemDomain::System())
                        fModifiedGrant = FALSE;
                    else {
                        BEGIN_ENSURE_COOPERATIVE_GC();
                        COMPLUS_TRY {
                            BOOL fExtraPolicy = ((APPDOMAINREF)GetAppDomain()->GetExposedObject())->HasSetPolicy();
                            if (!fExtraPolicy && ((pExtraEvidence == NULL || *pExtraEvidence == NULL) && (pEvidence == NULL || *pEvidence == NULL)))
                                fModifiedGrant = FALSE;
                        } COMPLUS_CATCH {
#if _DEBUG
                            HRESULT caughtHr = SecurityHelper::MapToHR(GETTHROWABLE());
#endif  //_DEBUG
                        } COMPLUS_END_CATCH
                        END_ENSURE_COOPERATIVE_GC();
                    }
#endif
                    if (fModifiedGrant)
                        pAssembly->GetSharedSecurityDescriptor()->SetModifiedGrant();
                }
            }
        }

        //
        // Make a new assembly.
        //

        if (pAssembly == NULL) {
            pEntry->m_hrResultCode = CreateAssemblyNoLock(pFile,
                                                          pIAssembly,
                                                          &pAssembly);
            if(FAILED(pEntry->m_hrResultCode)) {
                pEntry->Leave();
                goto Exit;
            }
        }

        // Security needs to know about the manifest file in case it needs to
        // resolve policy in the forthcoming zap file calculations.
        pAssembly->GetSharedSecurityDescriptor()->SetManifestFile(pFile);
        pSecDesc = pSecDesc->Init(pAssembly);
        if (pAssembly->IsSystem())
            pSecDesc->GetSharedSecDesc()->SetSystem();
               
#ifdef _IA64_
        //
        // @TODO_IA64: loading zaps is currently broken
        //
        _ASSERTE(!g_pConfig->UseZaps() && 
            "IA64 requires Zaps to be disabled in the registry: HKLM" FRAMEWORK_REGISTRY_KEY_W ": DWORD ZapDisable = 1");
#endif
        BOOL bExtraEvidence=FALSE;
        if (pExtraEvidence)
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            bExtraEvidence=(*pExtraEvidence!=NULL);
            END_ENSURE_COOPERATIVE_GC();
        }
        else if (pEvidence)
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            bExtraEvidence=(*pEvidence!=NULL);
            END_ENSURE_COOPERATIVE_GC();
        }

        PEFile *pZapFile = NULL;

        if ((!bExtraEvidence)
            && !fLoadFrom
            && g_pConfig->UseZaps()
            && !SystemDomain::GetCurrentDomain()->IsCompilationDomain()) {
            TIMELINE_START(LOADER, ("Locate zap %S", 
                                               pFile->GetLeafFileName()));

            if (PostLoadingAssembly(pFile->GetBase(), pAssembly)) {
                pEntry->m_hrResultCode = pAssembly->LoadZapAssembly();
                RemoveLoadingAssembly(pFile->GetBase());
            }
            else
                pEntry->m_hrResultCode = E_OUTOFMEMORY;
                

            TIMELINE_END(LOADER, ("Locate zap %S", 
                                  pFile->GetLeafFileName()));

            if(FAILED(pEntry->m_hrResultCode)) {
                pEntry->Leave();
                goto Exit;
            }
            else if (pEntry->m_hrResultCode == S_OK)
                zapFound = TRUE;

            pEntry->m_hrResultCode = S_OK;

            //
            // Fail load if we're requiring zaps
            // (This logic is really for testing only.)
            //

            if (!zapFound && g_pConfig->RequireZaps()) {
                _ASSERTE(!"Couldn't get zap file");
                pEntry->m_hrResultCode = COR_E_FILENOTFOUND;
                delete pAssembly;
                pEntry->Leave();
                goto Exit;
            }

            pZapFile = pAssembly->GetZapFile(pFile);
            if (pZapFile == NULL && g_pConfig->RequireZaps()) {
                _ASSERTE(!"Couldn't get zap file module");
                pEntry->m_hrResultCode = COR_E_FILENOTFOUND;
                pEntry->Leave();
                delete pAssembly;
                goto Exit;
            }
        }

        //
        // Create the module
        //


        pEntry->m_hrResultCode = Module::Create(pFile, pZapFile, &pModule,
                                                CORDebuggerEnCMode(pAssembly->GetDebuggerInfoBits()));
        if(FAILED(pEntry->m_hrResultCode)) {
            pEntry->Leave();
            delete pAssembly;
            goto Exit;
        }

        if (PostLoadingAssembly(pFile->GetBase(), pAssembly)) {
            BEGIN_ENSURE_COOPERATIVE_GC();
            pEntry->m_hrResultCode = SetAssemblyManifestModule(pAssembly, pModule, pThrowable);
            END_ENSURE_COOPERATIVE_GC();
            RemoveLoadingAssembly(pFile->GetBase());
        }
        else
            pEntry->m_hrResultCode = E_OUTOFMEMORY;

        pFile = NULL;
        if(FAILED(pEntry->m_hrResultCode)) {
            pEntry->Leave();
            delete pAssembly;
            goto Exit;
        }
        
        if (pAssembly->IsShared()) {
            SharedDomain *pSharedDomain = SharedDomain::GetDomain();
            hr = pSharedDomain->AddShareableAssembly(&pAssembly, &pSecDesc);
            if (hr == S_FALSE)
                pModule = pAssembly->GetManifestModule();
        }

        // Add the assembly security descriptor to a list of descriptors to be
        // processed later by the appdomain permission list set security
        // optimization.
        pSecDesc->AddDescriptorToDomainList();

        AddAssemblyLeaveLock(pAssembly, pEntry);
    }
    else {
        if (pFile) {
            delete pFile;
            pFile = NULL;
        }

        pEntry->m_dwRefCount++;
        LeaveLoadLock();

        // Wait for it
        pEntry->Enter();
        pEntry->Leave();

        if(SUCCEEDED(pEntry->m_hrResultCode)) {
            pAssembly = pEntry->GetAssembly();
            if (pAssembly)
                pModule = pAssembly->GetManifestModule();
            else {
                // We are in the process of loading policy and have tried to load
                // the assembly that is currently being loaded.  We return success
                // but set the module and assembly to null.
                // Note: we don't have to check the ref count being zero because the
                // only way we get in this situation is that someone is still in
                // the process of loading the assembly.

                _ASSERTE(fPolicyLoad &&
                         "A recursive assembly load occurred.");

                EnterLoadLock();
                pEntry->m_dwRefCount--;
                _ASSERTE( pEntry->m_dwRefCount != 0 );
                LeaveLoadLock();
                hr = MSEE_E_ASSEMBLYLOADINPROGRESS;
                goto FinalExit;
            }
        }
    }

 Exit:

    hr = pEntry->m_hrResultCode;
    EnterLoadLock();
    if(--pEntry->m_dwRefCount == 0) {
        m_AssemblyLoadLock.Unlink(pEntry);
        pEntry->Clear();
        delete(pEntry);
    }
    LeaveLoadLock();

 FinalExit:


    END_ENSURE_PREEMPTIVE_GC();

    TIMELINE_END(LOADER, ("LoadAssembly"));

    if (SUCCEEDED(hr)) {
        if (ppModule)
            *ppModule = pModule;

        if (ppAssembly)
            *ppAssembly = pAssembly;
    }
    else {
        if (pFile)
            delete pFile;

        /*
        if (pThrowable == THROW_ON_ERROR) {
            DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
            COMPlusThrow(GETTHROWABLE());
        }
        */
    }

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}

HRESULT AppDomain::ShouldContainAssembly(Assembly *pAssembly, BOOL fDoNecessaryLoad)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_FALSE;

    // 
    // This checks if the domain has load an assembly,
    // _or_ if it probably should have loaded an assembly, but in fact hasn't,
    // due to the bug in shared assemblies where we don't get a proper
    // load event when a different domain sharing our assembly loads one of
    // its dependencies.
    //
    // Note that by necessity this routine can trigger an assembly load.
    //

    // First check is the obvious one.
    if (ContainsAssembly(pAssembly)
        || SystemDomain::System()->ContainsAssembly(pAssembly))
        return S_OK;

    // If the assembly isn't shared, no further checking is needed.
    if (!pAssembly->IsShared())
        return S_FALSE;

    // If we are currently loading this assembly, don't report it as contained
    if (FindLoadingAssembly(pAssembly->GetManifestFile()->GetBase()) != NULL)
        return S_FALSE;

    //
    // Unless we've seen this PE file as on of the dependencies of our shared assemblies,
    // we know it shouldn't have been loaded.
    //
    hr = IsUnloadedDependency(pAssembly);

    if (hr == S_OK && fDoNecessaryLoad)
    {
        PEFile *pFile;
        hr = PEFile::Clone(pAssembly->GetManifestFile(), &pFile);
        if (SUCCEEDED(hr))
        {
            OBJECTREF throwable = NULL;
            GCPROTECT_BEGIN(throwable);

            Module *pLoadedModule;
            Assembly *pLoadedAssembly;
            hr = LoadAssembly(pFile, NULL, &pLoadedModule, &pLoadedAssembly, 
                              NULL, NULL, FALSE, &throwable);

            _ASSERTE(FAILED(hr) || pAssembly == pLoadedAssembly);

            if (throwable != NULL)
                COMPlusThrow(throwable);

            GCPROTECT_END();
        }
    }

    return hr;
}

HRESULT AppDomain::IsUnloadedDependency(Assembly *pAssembly)
{
    HRESULT hr = S_FALSE;

    if (m_sharedDependenciesMap.LookupValue((UPTR) pAssembly->GetManifestModule()->GetILBase(), 
                                            NULL) != (LPVOID) INVALIDENTRY)
    {
        if (pAssembly->CanShare(this, NULL, TRUE) == S_OK)
            hr = S_OK;
    }

    return hr;
}

HRESULT BaseDomain::SetSharePolicy(SharePolicy policy)
{
    if ((int)policy > SHARE_POLICY_COUNT)
        return E_FAIL;

    m_SharePolicy = policy;
    return S_OK;
}

BaseDomain::SharePolicy BaseDomain::GetSharePolicy()
{
    // If the policy has been explicitly set for
    // the domain, use that.
    SharePolicy policy = m_SharePolicy;

    // Pick up the a specified config policy
    if (policy == SHARE_POLICY_UNSPECIFIED)
        policy = g_pConfig->DefaultSharePolicy();

    // Next, honor a host's request for global policy.
    if (policy == SHARE_POLICY_UNSPECIFIED)
        policy = (SharePolicy) g_dwGlobalSharePolicy;

    // If all else fails, use the hardwired default policy.
    if (policy == SHARE_POLICY_UNSPECIFIED)
        policy = SHARE_POLICY_DEFAULT;

    return policy;
}


// Should only be called from routines that have taken the lock
HRESULT BaseDomain::CreateAssemblyNoLock(PEFile* pFile,
                                         IAssembly* pIAssembly,
                                         Assembly** ppAssembly)
{
    HRESULT hr;
    // We are not allowed to add assemblies or modules to the system domain

    Assembly* pAssembly;
    if(FAILED(hr = CreateAssembly(&pAssembly)))
        return hr;

    hr = pAssembly->AddManifest(pFile, pIAssembly);
    if(SUCCEEDED(hr)) {
        if(ppAssembly)
            *ppAssembly = pAssembly;

        // Setup the DebuggerAssemblyControlFlags
        pAssembly->SetupDebuggingConfig();
    }
    else
        delete pAssembly;

    return hr;
}

HRESULT BaseDomain::CreateShareableAssemblyNoLock(PEFile *pFile,
                                                  IAssembly* pIAssembly,
                                                  Assembly **ppAssembly)

{
    HRESULT hr;

    LOG((LF_CODESHARING,
         LL_INFO100,
         "Trying to create a shared assembly for module: \"%S\" in domain 0x%x.\n",
         pFile->GetFileName(), SystemDomain::GetCurrentDomain()));

    //
    // We cannot share a module with no manifest
    //

    if (FAILED(hr = Assembly::CheckFileForAssembly(pFile)))
    {
        LOG((LF_CODESHARING,
             LL_INFO100,
             "Failed module \"%S\": module has no manifest.\n",
             pFile->GetFileName()));

        return hr;
    }

    Assembly *pAssembly;
    hr = SharedDomain::GetDomain()->CreateAssemblyNoLock(pFile,
                                                         pIAssembly,
                                                         &pAssembly);
    if (FAILED(hr))
    {
        delete pFile;

        LOG((LF_CODESHARING,
             LL_INFO10,
             "Failed assembly \"%S\": error 0x%x creating shared assembly.\n",
             pFile->GetFileName(), hr));

        return hr;
    }

    //
    // First, compute the closure assembly dependencies
    // of the code & layout of given assembly.
    //
    // We assume that an assembly has dependencies
    // on all refs listed in its manifest.  This is a pretty solid assumption.
    //
    // We cannot assume, however, that we also inherit all of
    // those dependencies' dependencies.  After all, we may be only using a small
    // portion of the assembly.
    //
    // However, since all dependent assemblies must also be shared (so that
    // the shared data in this assembly can refer to it), we are in
    // effect forced to behave as though we do have all of their dependencies.
    // This is because the resulting shared assembly that we will depend on
    // DOES have those dependencies, but we won't be able to validly share that
    // assembly unless we match all of ITS dependencies, too.
    //
    // If you're confused by the above, I'm not surprised.
    // Basically, the conclusion is that even though this assembly
    // may not actually depend on the all the recursively
    // referenced assemblies, we still cannot share it unless we can
    // match the binding of all of those dependencies anyway.
    //

    PEFileBinding *pDeps;
    DWORD cDeps;

    TIMELINE_START(LOADER, ("Compute assembly closure %S", 
                                      pFile->GetLeafFileName()));

    hr = pAssembly->ComputeBindingDependenciesClosure(&pDeps, &cDeps, FALSE);

    TIMELINE_END(LOADER, ("compute assembly closure %S", 
                                    pFile->GetLeafFileName()));

    if (FAILED(hr))
    {
#ifdef PROFILING_SUPPORTED
        if (CORProfilerTrackAssemblyLoads())
            g_profControlBlock.pProfInterface->AssemblyLoadFinished((ThreadID) GetThread(),
                                                                    (AssemblyID) pAssembly, hr);
#endif // PROFILING_SUPPORTED
        delete pAssembly;

        LOG((LF_CODESHARING,
             LL_INFO10,
             "Failed assembly \"%S\": error 0x%x computing binding dependencies.\n",
             pFile->GetFileName(), hr));

        return hr;
    }

    LOG((LF_CODESHARING,
         LL_INFO100,
         "Computed %d dependencies.\n", cDeps));

    pAssembly->SetSharingProperties(pDeps, cDeps);

    LOG((LF_CODESHARING,
         LL_INFO100,
         "Successfully created shared assembly \"%S\".\n", pFile->GetFileName()));

    if (ppAssembly != NULL)
        *ppAssembly = pAssembly;

    return S_OK;
}

HRESULT BaseDomain::SetAssemblyManifestModule(Assembly *pAssembly, Module *pModule, OBJECTREF *pThrowable)
{
    HRESULT hr;

    pAssembly->m_pManifest = pModule;

    // Adds the module as a system module if we're the system domain
    // Otherwise it's a non-system module
    hr = pAssembly->AddModule(pModule, mdFileNil, TRUE,
                              pThrowable);

#ifdef PROFILING_SUPPORTED
    // Signal the profiler that the assembly is loaded.  We must wait till this point so that
    // the manifest pointer is not null and the friendly name of the assembly is accessible.
    // If are sharing mscorlib, don't track loads into system domain as they really don't count.
    if (CORProfilerTrackAssemblyLoads())
        g_profControlBlock.pProfInterface->AssemblyLoadFinished((ThreadID) GetThread(), (AssemblyID) pAssembly, hr);
#endif // PROFILING_SUPPORTED

    return hr;
}

//
// LoadingAssemblyRecords are used to keep track of what assemblies are
// currently being loaded in the current domain.  
//
// This is used to handle recursive loading loops.  These can occur in three
// different places:
//
// * When creating a shared assembly, we need to load all dependent assemblies
//   as shared
// * When testing to see if we can use a zapped assembly, we need to compute
//   and test all the dependencies of the zapped assembly.
//
// Since there may be loops in assembly dependencies, we need to detect
// and deal with cases of circular recursion.
//

BOOL BaseDomain::PostLoadingAssembly(const BYTE *pBase, Assembly *pAssembly)
{
    EnterLoadingAssemblyListLock();
    _ASSERTE(FindLoadingAssembly(pBase) == NULL);

    LoadingAssemblyRecord *pRecord = new (nothrow) LoadingAssemblyRecord();
    if (pRecord) {
        pRecord->pBase = pBase;
        pRecord->pAssembly = pAssembly;
        pRecord->pNext = m_pLoadingAssemblies;

        m_pLoadingAssemblies = pRecord;
        LeaveLoadingAssemblyListLock();
        return TRUE;
    }
    LeaveLoadingAssemblyListLock();
    return FALSE;
}

Assembly *BaseDomain::FindLoadingAssembly(const BYTE *pBase)
{
    EnterLoadingAssemblyListLock();
    LoadingAssemblyRecord *pRecord = m_pLoadingAssemblies;

    while (pRecord != NULL)
    {
        if (pRecord->pBase == pBase)
        {
            Assembly* pRet=pRecord->pAssembly;
            LeaveLoadingAssemblyListLock();
            return pRet;
        }

        pRecord = pRecord->pNext;
    }
    LeaveLoadingAssemblyListLock();
    return NULL;
}

void BaseDomain::RemoveLoadingAssembly(const BYTE *pBase)
{
    EnterLoadingAssemblyListLock();
    LoadingAssemblyRecord **ppRecord = &m_pLoadingAssemblies;
    LoadingAssemblyRecord *pRecord;

    while ((pRecord = *ppRecord) != NULL)
    {
        if (pRecord->pBase == pBase)
        {
            *ppRecord = pRecord->pNext;
            delete pRecord;
            LeaveLoadingAssemblyListLock();
            return;
        }

        ppRecord = &pRecord->pNext;
    }
    
    _ASSERTE(!"Didn't find loading assembly record");
    LeaveLoadingAssemblyListLock();
}

HRESULT AppDomain::SetupSharedStatics()
{
    // don't do any work in init stage. If not init only do work in non-shared case if are default domain
    if (g_fEEInit)
        return S_OK;

    // Because we are allocating/referencing objects, need to be in cooperative mode
    BEGIN_ENSURE_COOPERATIVE_GC();

    static DomainLocalClass *pSharedLocalClass = NULL;

    MethodTable *pMT = g_Mscorlib.GetClass(CLASS__SHARED_STATICS);
    FieldDesc *pFD = g_Mscorlib.GetField(FIELD__SHARED_STATICS__SHARED_STATICS);

    if (pSharedLocalClass == NULL) {
        // Note that there is no race here since the default domain is always set up first
        _ASSERTE(this == SystemDomain::System()->DefaultDomain());
        
        OBJECTHANDLE hSharedStaticsHandle = CreateGlobalHandle(NULL);
        OBJECTREF pSharedStaticsInstance = AllocateObject(pMT);
        StoreObjectInHandle(hSharedStaticsHandle, pSharedStaticsInstance);

        DomainLocalBlock *pLocalBlock = GetDomainLocalBlock();
        pSharedLocalClass = pLocalBlock->FetchClass(pMT);

        pFD->SetStaticOBJECTREF(ObjectFromHandle(hSharedStaticsHandle));

        pMT->SetClassInited();
 
    } else {
        DomainLocalBlock *pLocalBlock = GetDomainLocalBlock();
        pLocalBlock->PopulateClass(pMT, pSharedLocalClass);
        pLocalBlock->SetClassInitialized(pMT->GetSharedClassIndex());
    }


    END_ENSURE_COOPERATIVE_GC();

    return S_OK;
}

OBJECTREF AppDomain::GetUnloadWorker()
{    
    SystemDomain::Enter(); // Take the lock so we don't leak a handle and only create one worker
    static OBJECTHANDLE hUnloadWorkerHandle = CreateHandle(NULL);

    // Because we are allocating/referencing objects, need to be in cooperative mode
    BEGIN_ENSURE_COOPERATIVE_GC();

    if (ObjectFromHandle(hUnloadWorkerHandle) == NULL) {
        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__UNLOAD_WORKER);;
        OBJECTREF pUnloadWorker = AllocateObject(pMT);
        StoreObjectInHandle(hUnloadWorkerHandle, pUnloadWorker);
#ifdef APPDOMAIN_STATE
        _ASSERTE_ALL_BUILDS(this == SystemDomain::System()->DefaultDomain());
        pUnloadWorker->SetAppDomain();
#endif
    }
    END_ENSURE_COOPERATIVE_GC();

    SystemDomain::Leave();

    _ASSERTE(ObjectFromHandle(hUnloadWorkerHandle) != NULL);

    return ObjectFromHandle(hUnloadWorkerHandle);
}

/*private*/
// A lock must be taken before using this routine.
// @TODO: CTS, We should look at a reader writer implementation that allows
// multiple readers but a single writer.
Module* BaseDomain::FindModule(BYTE *pBase)
{
    Assembly* assem = NULL;
    Module* result = NULL;
    _ASSERTE(SystemDomain::System());

    result = SystemDomain::System()->FindModule(pBase);

    if (result == NULL)
    {
        AssemblyIterator i = IterateAssemblies();
        while (i.Next())
        {
            result = i.GetAssembly()->FindAssembly(pBase);

            if (result != NULL)
                break;
        }
    }

    return result;
}

/*private*/
// A lock must be taken before using this routine.
// @TODO: CTS, We should look at a reader writer implementation that allows
// multiple readers but a single writer.
Module* BaseDomain::FindModule__Fixed(BYTE *pBase)
{
    Assembly* assem = NULL;
    Module* result = NULL;
    _ASSERTE(SystemDomain::System());

    result = SystemDomain::System()->FindModule(pBase);

    if (result == NULL)
    {
        AssemblyIterator i = IterateAssemblies();
        while (i.Next())
        {
            result = i.GetAssembly()->FindModule(pBase);

            if (result != NULL)
                break;
        }
    }

    return result;
}

/*private*/
// A lock must be taken before using this routine.
// @TODO: CTS, We should look at a reader writer implementation that allows
// multiple readers but a single writer.
Assembly* BaseDomain::FindAssembly(BYTE *pBase)
{
    Assembly* assem = NULL;
    _ASSERTE(SystemDomain::System());

    // All Domains have the system assemblies as part of their domain.
    assem = SystemDomain::System()->FindAssembly(pBase);
    if(assem == NULL) {
        AssemblyIterator i = IterateAssemblies();

        while (i.Next())
        {
            PEFile *pManifestFile = i.GetAssembly()->GetManifestFile();
            if (pManifestFile && pManifestFile->GetBase() == pBase)
            {
                assem = i.GetAssembly();
                break;
            }
        }
    }
    return assem;
}

// NOTE!  This will not check the internal modules of the assembly
// for private types.
TypeHandle BaseDomain::FindAssemblyQualifiedTypeHandle(LPCUTF8 szAssemblyQualifiedName,
                                                       BOOL fPublicTypeOnly,
                                                       Assembly *pCallingAssembly,
                                                       BOOL *pfNameIsAsmQualified,
                                                       OBJECTREF *pThrowable)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(this == SystemDomain::GetCurrentDomain());

    CQuickArray<CHAR> strBuff;

    // We don't want to modify the caller's string so we need to make copy.
    int NameLength = (int)strlen(szAssemblyQualifiedName);
    strBuff.ReSize(NameLength + 1);
    memcpy(strBuff.Ptr(), szAssemblyQualifiedName, NameLength);
    strBuff[NameLength] = 0;

    char* szClassName = strBuff.Ptr();
    char* szAssembly = NULL;

    if (*szClassName == '\0')
        COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

    HRESULT hr;
    LPUTF8 szNameSpaceSep;
    if(FAILED(hr = AssemblyNative::FindAssemblyName(szClassName, &szAssembly, &szNameSpaceSep))) 
        COMPlusThrowHR(hr);
        
    char noNameSpace = '\0';
    NameHandle typeName;
    if (szNameSpaceSep) {
        *szNameSpaceSep = '\0';
        typeName.SetName(szClassName, szNameSpaceSep+1);
    }
    else
        typeName.SetName(&noNameSpace, szClassName);

        
    TypeHandle typeHnd;

    if(szAssembly && *szAssembly) {
        AssemblySpec spec;
        hr = spec.Init(szAssembly);

        // The name is assembly qualified.
        if (pfNameIsAsmQualified)
            *pfNameIsAsmQualified = TRUE;

        if (SUCCEEDED(hr)) {
            Assembly* pAssembly = NULL;
            hr = spec.LoadAssembly(&pAssembly, pThrowable);
            if(SUCCEEDED(hr))
            {
                typeHnd = pAssembly->FindNestedTypeHandle(&typeName, pThrowable);

                // If we are only looking for public types then we need to do a visibility check.
                if (!typeHnd.IsNull() && fPublicTypeOnly) {
                    EEClass *pClass = typeHnd.GetClassOrTypeParam();
                    while(IsTdNestedPublic(pClass->GetProtection()))
                        pClass = pClass->GetEnclosingClass();

                    if (!IsTdPublic(pClass->GetProtection()))
                        typeHnd = TypeHandle();
                }
            }
        }

        // If we failed to load the type, then post a type load exception.
        if (typeHnd.IsNull()) {
            #define MAKE_TRANSLATIONFAILED pwzAssemblyName=L"" 
            MAKE_WIDEPTR_FROMUTF8_FORPRINT(pwzAssemblyName, szAssembly);
            if (szNameSpaceSep)
                *szNameSpaceSep = NAMESPACE_SEPARATOR_CHAR;
            PostTypeLoadException(NULL, szClassName, pwzAssemblyName,
                                  NULL, IDS_CLASSLOAD_GENERIC, pThrowable);
            #undef MAKE_TRANSLATIONFAILED
        }
    }
    else 
    {
        // The name is not assembly qualified.
        if (pfNameIsAsmQualified)
            pfNameIsAsmQualified = FALSE;

        // No assembly name was specified so start by looking in the calling
        // assembly if one was specified. It is important to note that no 
        // visibility check is required for types loaded from the calling
        // assembly.
        if (pCallingAssembly)
            typeHnd = pCallingAssembly->FindNestedTypeHandle(&typeName, pThrowable);

        // If we failed to find the type in the calling assembly, then look in the
        // system assembly.
        if (typeHnd.IsNull())
        {
            // Attempt to load the type from the system assembly.
            typeHnd = SystemDomain::SystemAssembly()->FindNestedTypeHandle(&typeName, pThrowable);

            // If we are only looking for public types, then we need to do a visibility check.
            if (!typeHnd.IsNull() && fPublicTypeOnly) {
                EEClass *pClass = typeHnd.GetClassOrTypeParam();
                while(IsTdNestedPublic(pClass->GetProtection()))
                    pClass = pClass->GetEnclosingClass();

                if (!IsTdPublic(pClass->GetProtection()))
                    typeHnd = TypeHandle();
            }
        }

        // We failed to load the type so post a type load exception.
        if (typeHnd.IsNull()) {
            if (pCallingAssembly) {
                // A calling assembly was specified so assume the type should
                // have been in the calling assembly.
                pCallingAssembly->PostTypeLoadException(&typeName, IDS_CLASSLOAD_GENERIC, pThrowable);
            }
            else {
                // There is no calling assembly so assume the type should have
                // been in the system assembly.
                SystemDomain::SystemAssembly()->PostTypeLoadException(&typeName, IDS_CLASSLOAD_GENERIC, pThrowable);
            }
        }
    }

    return typeHnd;
}

void AppDomain::SetFriendlyName(LPCWSTR pwzFriendlyName, BOOL fDebuggerCares)
{
    if (pwzFriendlyName)
    {
        LPWSTR szNew = new (nothrow) wchar_t[wcslen(pwzFriendlyName) + 1];
        if (szNew == 0)
            return;
        wcscpy(szNew, pwzFriendlyName);
        if (m_pwzFriendlyName)
            delete[] m_pwzFriendlyName;
        m_pwzFriendlyName = szNew;
    }

#ifdef DEBUGGING_SUPPORTED
    _ASSERTE(NULL != g_pDebugInterface);

    // update the name in the IPC publishing block
    if (SUCCEEDED(g_pDebugInterface->UpdateAppDomainEntryInIPC(this)))
    {
        // inform the attached debugger that the name of this appdomain has changed.
        if (IsDebuggerAttached() && fDebuggerCares)
            g_pDebugInterface->NameChangeEvent(this, NULL);
    }

#endif // DEBUGGING_SUPPORTED
}

void AppDomain::ResetFriendlyName(BOOL fDebuggerCares)
{
    if (m_pwzFriendlyName)
    {
        delete m_pwzFriendlyName;
        m_pwzFriendlyName = NULL;

        GetFriendlyName (fDebuggerCares);
    }
}


LPCWSTR AppDomain::GetFriendlyName(BOOL fDebuggerCares)
{
#if _DEBUG
    // Handle NULL this pointer - this happens sometimes when printing log messages
    // but in general shouldn't occur in real code
    if (this == NULL)
        return L"<Null>";
#endif

    if (m_pwzFriendlyName)
        return m_pwzFriendlyName;

    // If there is an assembly, try to get the name from it.
    // If no assembly, but if it's the DefaultDomain, then give it a name
    BOOL set = FALSE;

    if (m_Assemblies.GetCount() > 0)
    {
        LPWSTR pName = NULL;
        DWORD dwName;
        Assembly *pAssembly = (Assembly*) m_Assemblies.Get(0);

        HRESULT hr = pAssembly->GetCodeBase(&pName, &dwName);
        if(SUCCEEDED(hr) && pName)
        {
            LPWSTR sep = wcsrchr(pName, L'/');
            if (sep)
                sep++;
            else
                sep = pName;
            SetFriendlyName(sep, fDebuggerCares);
            set = TRUE;
        }
    }

    if (!set)
    {
        if (m_pRootFile != NULL)
        {
            LPCWSTR pName = m_pRootFile->GetLeafFileName();
            LPCWSTR sep = wcsrchr(pName, L'.');
            
            CQuickBytes buffer;
            if (sep != NULL)
            {
                LPWSTR pNewName = (LPWSTR) _alloca((sep - pName + 1) * sizeof(WCHAR));
                wcsncpy(pNewName, pName, sep - pName);
                pNewName[sep - pName] = 0;
                pName = pNewName;
            }
                
            SetFriendlyName(pName, fDebuggerCares);
            set = TRUE;
        }
    }

    if (!set)
    {
        if (this == SystemDomain::System()->DefaultDomain()) {
            SetFriendlyName(DEFAULT_DOMAIN_FRIENDLY_NAME, fDebuggerCares);
        }

        // This is for the profiler - if they call GetFriendlyName on an AppdomainCreateStarted
        // event, then we want to give them a temporary name they can use.
        else if (GetId() == 0)
            return (NULL);
        else
        {
            // 32-bit signed int can be a max of 11 decimal digits
            WCHAR buffer[CCH_OTHER_DOMAIN_FRIENDLY_NAME_PREFIX + 11 + 1 ];  
            wcscpy(buffer, OTHER_DOMAIN_FRIENDLY_NAME_PREFIX);
            _itow(GetId(), buffer + CCH_OTHER_DOMAIN_FRIENDLY_NAME_PREFIX, 10);
            SetFriendlyName(buffer, fDebuggerCares);
        }
    }

    return m_pwzFriendlyName;
}

HRESULT AppDomain::BindAssemblySpec(AssemblySpec *pSpec,
                                    PEFile **ppFile,
                                    IAssembly** ppIAssembly,
                                    Assembly **ppDynamicAssembly,
                                    OBJECTREF *pExtraEvidence,
                                    OBJECTREF *pThrowable)
{
    _ASSERTE(pSpec->GetAppDomain() == this);
    _ASSERTE(ppFile);
    _ASSERTE(ppIAssembly);

    // First, check our cache of bound specs.
    HRESULT hr = LookupAssemblySpec(pSpec, ppFile, ppIAssembly, pThrowable);
    if (hr != S_FALSE) {
        
        // @TODO: no way to check redirected, failed assembly loads
        // Luckily, we've saved off the security hr from the first try,
        // unless that try a more trusted caller asked for this...
        // Also, if a less trusted caller got a security hr, but a
        // more trusted caller then tries, and gets the cached hr,
        // that's incorrect...
        if (*ppIAssembly) // bind had succeeded
            hr = pSpec->DemandFileIOPermission(NULL, *ppIAssembly, pThrowable);

        return hr;
    }

    return pSpec->LowLevelLoadManifestFile(ppFile, 
                                           ppIAssembly, 
                                           ppDynamicAssembly, 
                                           pExtraEvidence,
                                           pThrowable);
}

HRESULT AppDomain::PredictAssemblySpecBinding(AssemblySpec *pSpec, GUID *pmvid, BYTE *pbHash, DWORD *pcbHash)
{
    _ASSERTE(pSpec->GetAppDomain() == this);

    return pSpec->PredictBinding(pmvid, pbHash, pcbHash);
}

BOOL AppDomain::StoreBindAssemblySpecResult(AssemblySpec *pSpec,
                                            PEFile *pFile,
                                            IAssembly* pIAssembly,
                                            BOOL clone)
{
    _ASSERTE(pSpec->GetAppDomain() == this);

    //
    // Currently, caller must have the app domain lock
    //

    // Quick check for duplicate
    if (m_pBindingCache != NULL && m_pBindingCache->Contains(pSpec))
        return FALSE;

    PEFile *pFileCopy;
    if (FAILED(PEFile::Clone(pFile, &pFileCopy)))
        return FALSE;

    {
        APPDOMAIN_CACHE_LOCK(this); 

        if (m_pBindingCache == NULL) {
            m_pBindingCache = new (nothrow) AssemblySpecBindingCache(m_pDomainCacheCrst);
            if (!m_pBindingCache)
                return FALSE;
        }
        else
        {
            if (m_pBindingCache->Contains(pSpec)) {
                delete pFileCopy;
                return FALSE;
            }
        }
    
        m_pBindingCache->Store(pSpec, pFileCopy,  pIAssembly, clone);
    }

    return TRUE;
}

BOOL AppDomain::StoreBindAssemblySpecError(AssemblySpec *pSpec,
                                           HRESULT hr,
                                           OBJECTREF *pThrowable,
                                           BOOL clone)
{
    _ASSERTE(pSpec->GetAppDomain() == this);

    //
    // Currently, caller must have the app domain lock
    //

    // Quick check for duplicate
    if (m_pBindingCache != NULL && m_pBindingCache->Contains(pSpec))
        return FALSE;

    {
        APPDOMAIN_CACHE_LOCK(this); 

    if (m_pBindingCache == NULL) {
        m_pBindingCache = new (nothrow) AssemblySpecBindingCache(m_pDomainCacheCrst);
        if (!m_pBindingCache)
            return FALSE;
    }
    else
    {
        if (m_pBindingCache->Contains(pSpec)) {
            return FALSE;
        }
    }

    m_pBindingCache->Store(pSpec, hr, pThrowable, clone);
    }

    return TRUE;
}

ULONG AppDomain::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
}

ULONG AppDomain::Release()
{
    _ASSERTE(m_cRef > 0);
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef) {
        delete this;
    }
    return (cRef);
}

// Can return NULL for E_OUTOFMEMORY
AssemblySink* AppDomain::GetAssemblySink()
{

    AssemblySink* ret = (AssemblySink*) InterlockedExchangePointer((PVOID*)&m_pAsyncPool,
                                                                   NULL);
    if(ret == NULL)
        ret = new (nothrow) AssemblySink(this);
    else
        ret->AddRef();

    return ret;
}

void AppDomain::RaiseUnloadDomainEvent_Wrapper(AppDomain* pDomain)
{
    pDomain->RaiseUnloadDomainEvent();
}

void AppDomain::RaiseUnloadDomainEvent()
{

    Thread *pThread = GetThread();
    if (this != pThread->GetDomain())
    {
    BEGIN_ENSURE_COOPERATIVE_GC();
        pThread->DoADCallBack(GetDefaultContext(), AppDomain::RaiseUnloadDomainEvent_Wrapper, this);
        END_ENSURE_COOPERATIVE_GC();
        return;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();
    COMPLUS_TRY {
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_UNLOAD);

            OBJECTREF ref;
            if ((ref = GetRawExposedObject()) != NULL) {
                INT64 args[1] = {
                    ObjToInt64(ref)
                };
            pMD->Call(args, METHOD__APP_DOMAIN__ON_UNLOAD);
        }
    } COMPLUS_CATCH {
#if _DEBUG
        HRESULT hr = SecurityHelper::MapToHR(GETTHROWABLE());
#endif //_DEBUG
        // Swallow any exceptions
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();
}

void AppDomain::RaiseLoadingAssembly_Wrapper(AppDomain::RaiseLoadingAssembly_Args *args)
{
    args->pDomain->RaiseLoadingAssemblyEvent(args->pAssembly);
}

void AppDomain::RaiseLoadingAssemblyEvent(Assembly *pAssembly)
{
#ifdef _IA64_
    //
    // @TODO_IA64: this starts mucking about with the system
    // assembly, which we don't have yet...
    //
    return;
#endif


    Thread *pThread = GetThread();
    if (this != pThread->GetDomain())
    {
        RaiseLoadingAssembly_Args args = { this, pAssembly };
        BEGIN_ENSURE_COOPERATIVE_GC();
        pThread->DoADCallBack(GetDefaultContext(), AppDomain::RaiseLoadingAssembly_Wrapper, &args);
        END_ENSURE_COOPERATIVE_GC();
        return;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();
    COMPLUS_TRY {

        APPDOMAINREF/*OBJECTREF*/ AppDomainRef;
        if ((AppDomainRef = (APPDOMAINREF) GetRawExposedObject()) != NULL) {
            if (AppDomainRef->m_pAssemblyEventHandler != NULL)
            {
                INT64 args[2];
                MethodDesc *pMD;
                GCPROTECT_BEGIN(AppDomainRef);
                pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_ASSEMBLY_LOAD);

                args[1] = ObjToInt64(pAssembly->GetExposedObject());
                args[0] = ObjToInt64(AppDomainRef);
                GCPROTECT_END();
                pMD->Call(args, METHOD__APP_DOMAIN__ON_ASSEMBLY_LOAD);
            }
        }
    } COMPLUS_CATCH {
#if _DEBUG
        HRESULT hr = SecurityHelper::MapToHR(GETTHROWABLE());
#endif //_DEBUG
        // Swallow any exceptions
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();
}

BOOL 
AppDomain::OnUnhandledException(OBJECTREF *pThrowable, BOOL isTerminating) {
    CANNOTTHROWCOMPLUSEXCEPTION();

    if (CanThreadEnter(GetThread()))
        return RaiseUnhandledExceptionEvent(pThrowable, isTerminating);
    else
       return FALSE;
}

extern BOOL g_fEEStarted;

void AppDomain::RaiseExitProcessEvent()
{
    if (!g_fEEStarted)
        return;

    // Only finalizer thread during shutdown can call this function.
    _ASSERTE ((g_fEEShutDown&ShutDown_Finalize1) && GetThread() == g_pGCHeap->GetFinalizerThread());

    _ASSERTE (GetThread()->PreemptiveGCDisabled());

    _ASSERTE (GetThread()->GetDomain() == SystemDomain::System()->DefaultDomain());

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        MethodDesc *OnExitProcessEvent = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_EXIT_PROCESS);
        _ASSERTE(OnExitProcessEvent);

        OnExitProcessEvent->Call(NULL, METHOD__APP_DOMAIN__ON_EXIT_PROCESS);
    } COMPLUS_CATCH {
#if _DEBUG
        HRESULT hr = SecurityHelper::MapToHR(GETTHROWABLE());
#endif //_DEBUG
        // Swallow any exceptions
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();
}

void AppDomain::RaiseUnhandledExceptionEvent_Wrapper(AppDomain::RaiseUnhandled_Args *args)
{
    *(args->pResult) = args->pDomain->RaiseUnhandledExceptionEvent(args->pThrowable, args->isTerminating);
}

BOOL 
AppDomain::RaiseUnhandledExceptionEvent(OBJECTREF *pThrowable, BOOL isTerminating)
{

    BOOL result = FALSE;
    APPDOMAINREF AppDomainRef;

    _ASSERTE(pThrowable != NULL && IsProtectedByGCFrame(pThrowable));

    Thread *pThread = GetThread();
    if (this != pThread->GetDomain())
    {
        RaiseUnhandled_Args args = {this, pThrowable, isTerminating, &result};
        // call through DoCallBack with a domain transition
        BEGIN_ENSURE_COOPERATIVE_GC();
        pThread->DoADCallBack(this->GetDefaultContext(), AppDomain::RaiseUnhandledExceptionEvent_Wrapper, &args);
        END_ENSURE_COOPERATIVE_GC();
        return result;
    }

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
    
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_UNHANDLED_EXCEPTION);

        if ((AppDomainRef = (APPDOMAINREF) GetRawExposedObject()) != NULL) {
            if (AppDomainRef->m_pUnhandledExceptionEventHandler != NULL) {
                result = TRUE;
                INT64 args[3];
                args[1] = (INT64) isTerminating;
                args[2] = ObjToInt64(*pThrowable);
                args[0] = ObjToInt64(AppDomainRef);
                pMD->Call(args, METHOD__APP_DOMAIN__ON_UNHANDLED_EXCEPTION);
            }
        }
    } COMPLUS_CATCH {
#if _DEBUG
        HRESULT hr = SecurityHelper::MapToHR(GETTHROWABLE());
#endif //_DEBUG
        // Swallow any errors.
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    return result;
}

// Create a domain passed on a string name
AppDomain* AppDomain::CreateDomainContext(WCHAR* fileName)
{
    THROWSCOMPLUSEXCEPTION();

    if(fileName == NULL) return NULL;

    AppDomain* pDomain = NULL;
    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__VAL_CREATE_DOMAIN);
    STRINGREF pFilePath = NULL;
    GCPROTECT_BEGIN(pFilePath);
    pFilePath = COMString::NewString(fileName);
    
    INT64 args[1] = {
        ObjToInt64(pFilePath),
    };
    APPDOMAINREF pDom = (APPDOMAINREF) ObjectToOBJECTREF((Object*) pMD->Call(args, METHOD__APP_DOMAIN__VAL_CREATE_DOMAIN));
    if(pDom != NULL) {
        Context* pContext = ComCallWrapper::GetExecutionContext(pDom, NULL);
        if(pContext)
            pDomain = pContext->GetDomain();
    }
    GCPROTECT_END();

    return pDomain;
}

// You must be in the correct context before calling this
// routine. Therefore, it is only good for initializing the
// default domain.
HRESULT AppDomain::InitializeDomainContext(DWORD optimization,
                                           LPCWSTR pwszPath,
                                           LPCWSTR pwszConfig)
{
    HRESULT hr = S_OK;
    BEGIN_ENSURE_COOPERATIVE_GC();
    COMPLUS_TRY {
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__SETUP_DOMAIN);

        struct _gc {
            STRINGREF pFilePath;
            STRINGREF pConfig;
            OBJECTREF ref;
        } gc;
        ZeroMemory(&gc, sizeof(gc));
               
        GCPROTECT_BEGIN(gc);
        gc.pFilePath = COMString::NewString(pwszPath);
        gc.pConfig = COMString::NewString(pwszConfig);
        if ((gc.ref = GetExposedObject()) != NULL) {
            INT64 args[4] = {
                ObjToInt64(gc.ref),
                ObjToInt64(gc.pConfig),
                ObjToInt64(gc.pFilePath),
                optimization,
            };
            pMD->Call(args, METHOD__APP_DOMAIN__SETUP_DOMAIN);
        }

        GCPROTECT_END();
    } COMPLUS_CATCH {
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
    } COMPLUS_END_CATCH;

    END_ENSURE_COOPERATIVE_GC();
    return hr;
}
// The fusion context should only be null when appdomain is being setup
// and there should be no reason to protect the creation.
HRESULT AppDomain::CreateFusionContext(IApplicationContext** ppFusionContext)
{
    if(!m_pFusionContext) {
        IApplicationContext* pFusionContext = NULL;
        HRESULT hr = FusionBind::CreateFusionContext(NULL, &pFusionContext);
        if(FAILED(hr)) return hr;
        m_pFusionContext = pFusionContext;
    }
    *ppFusionContext = m_pFusionContext;
    return S_OK;
}
// This method resets the binding redirect in the appdomains cache
// and resets the property in fusion's application context. This method
// is in-herently unsafe.
void AppDomain::ResetBindingRedirect()
{
    _ASSERTE(GetAppDomain() == this);
    
    BEGIN_ENSURE_COOPERATIVE_GC();
    
    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__RESET_BINDING_REDIRECTS);
    
    OBJECTREF ref;
    if ((ref = GetExposedObject()) != NULL) {
        INT64 args[1] = {
            ObjToInt64(ref),
        };
        pMD->Call(args, METHOD__APP_DOMAIN__RESET_BINDING_REDIRECTS);
    }

    IApplicationContext* pFusionContext = GetFusionContext();
    if(pFusionContext) {
       pFusionContext->Set(ACTAG_DISALLOW_APP_BINDING_REDIRECTS,
                           NULL,
                           0,
                           0);
   }
     
    END_ENSURE_COOPERATIVE_GC();
}

void AppDomain::SetupExecutableFusionContext(WCHAR *exePath)
{
    _ASSERTE(GetAppDomain() == this);

    BEGIN_ENSURE_COOPERATIVE_GC();

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__SET_DOMAIN_CONTEXT);

    STRINGREF pFilePath = NULL;
    GCPROTECT_BEGIN(pFilePath);
    pFilePath = COMString::NewString(exePath);

    OBJECTREF ref;
    if ((ref = GetExposedObject()) != NULL) {
        INT64 args[2] = {
            ObjToInt64(ref),
            ObjToInt64(pFilePath),
        };
        pMD->Call(args, METHOD__APP_DOMAIN__SET_DOMAIN_CONTEXT);
    }

    GCPROTECT_END();

    END_ENSURE_COOPERATIVE_GC();
}

BOOL AppDomain::SetContextProperty(IApplicationContext* pFusionContext,
                                   LPCWSTR pProperty, OBJECTREF* obj)

{
#ifdef FUSION_SUPPORTED

    THROWSCOMPLUSEXCEPTION();

    if(obj && ((*obj) != NULL)) {
        MethodTable* pMT = (*obj)->GetMethodTable();
        if(!g_Mscorlib.IsClass(pMT, CLASS__STRING))
            COMPlusThrow(kInvalidCastException, IDS_EE_CANNOTCASTTO, TEXT(g_StringClassName));

        DWORD lgth = (ObjectToSTRINGREF(*(StringObject**)obj))->GetStringLength();
        CQuickBytes qb;
        LPWSTR appBase = (LPWSTR) qb.Alloc((lgth+1)*sizeof(WCHAR));
        memcpy(appBase, (ObjectToSTRINGREF(*(StringObject**)obj))->GetBuffer(), lgth*sizeof(WCHAR));
        if(appBase[lgth-1] == '/')
            lgth--;
        appBase[lgth] = L'\0';

        LOG((LF_LOADER, 
             LL_INFO10, 
             "\nSet: %S: *%S*.\n", 
             pProperty, appBase));

        pFusionContext->Set(pProperty,
                            appBase,
                            (lgth+1) * sizeof(WCHAR),
                            0);
    }

    return TRUE;
#else // !FUSION_SUPPORTED
    return FALSE;
#endif // !FUSION_SUPPORTED
}

void AppDomain::ReleaseFusionInterfaces()
{
    WriteZapLogs();

    BaseDomain::ReleaseFusionInterfaces();

    if (m_pBindingCache) {
        delete m_pBindingCache;
        m_pBindingCache = NULL;
    }
}

HRESULT BaseDomain::SetShadowCopy()
{
    if (this == SystemDomain::System())
        return E_FAIL;

    m_fShadowCopy = TRUE;
    return S_OK;
}

BOOL BaseDomain::IsShadowCopyOn()
{
    return m_fShadowCopy;
}

HRESULT AppDomain::GetDynamicDir(LPWSTR* pDynamicDir)
{
    CHECKGC();
    HRESULT hr = S_OK;
    if (m_pwDynamicDir == NULL) {
        EnterLock();
        if(m_pwDynamicDir == NULL) {
            IApplicationContext* pFusionContext = GetFusionContext();
            _ASSERTE(pFusionContext);
            if(SUCCEEDED(hr)) {
                DWORD dwSize = 0;
                hr = pFusionContext->GetDynamicDirectory(NULL, &dwSize);
                
                if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                    m_pwDynamicDir = (LPWSTR) m_pLowFrequencyHeap->AllocMem(dwSize * sizeof(WCHAR));
                    if (m_pwDynamicDir)
                        hr = pFusionContext->GetDynamicDirectory(m_pwDynamicDir, &dwSize);
                    else
                        hr = E_OUTOFMEMORY;
                }
            }
        }
        LeaveLock();
        if(FAILED(hr)) return hr;
    }
    
    *pDynamicDir = m_pwDynamicDir;

    return hr;
}

#ifdef DEBUGGING_SUPPORTED
void AppDomain::SetDebuggerAttached(DWORD dwStatus)
{
    // first, reset the debugger bits
    m_dwFlags &= ~DEBUGGER_STATUS_BITS_MASK;

    // then set the bits to the desired value
    m_dwFlags |= dwStatus;

    LOG((LF_CORDB, LL_EVERYTHING, "AD::SDA AD:%#08x status:%#x flags:%#x %ls\n", 
        this, dwStatus, m_dwFlags, GetFriendlyName(FALSE)));
}

DWORD AppDomain::GetDebuggerAttached(void)
{
    LOG((LF_CORDB, LL_EVERYTHING, "AD::GD this;0x%x val:0x%x\n", this,
        m_dwFlags & DEBUGGER_STATUS_BITS_MASK));

    return m_dwFlags & DEBUGGER_STATUS_BITS_MASK;
}

BOOL AppDomain::IsDebuggerAttached(void)
{
    LOG((LF_CORDB, LL_EVERYTHING, "AD::IDA this;0x%x flags:0x%x\n", 
        this, m_dwFlags));

    // Of course, we can't have a debugger attached to this AD if there isn't a debugger attached to the whole
    // process...
    if (CORDebuggerAttached())
        return ((m_dwFlags & DEBUGGER_ATTACHED) == DEBUGGER_ATTACHED) ? TRUE : FALSE;
    else
        return FALSE;
}

BOOL AppDomain::NotifyDebuggerAttach(int flags, BOOL attaching)
{
    BOOL result = FALSE;

    if (!attaching && !IsDebuggerAttached())
        return FALSE;

    AssemblyIterator i;

    // Iterate the system assemblies and inform the debugger they're being loaded.
    LOG((LF_CORDB, LL_INFO100, "AD::NDA: Interating system assemblies\n"));
    i = SystemDomain::System()->IterateAssemblies();
    while (i.Next())
    {
        LOG((LF_CORDB, LL_INFO100, "AD::NDA: Iterated system assembly AD:%#08x %s\n", 
             i.GetAssembly(), i.GetAssembly()->GetName()));
        result = i.GetAssembly()->NotifyDebuggerAttach(this, flags,
                                                       attaching) || result;
    }

    // Now attach to our assemblies
    LOG((LF_CORDB, LL_INFO100, "AD::NDA: Iterating assemblies\n"));
    i = IterateAssemblies();
    while (i.Next())
    {
        LOG((LF_CORDB, LL_INFO100, "AD::NDA: Iterated  assembly AD:%#08x %s\n", 
             i.GetAssembly(), i.GetAssembly()->GetName()));
        if (!i.GetAssembly()->IsSystem())
        result = i.GetAssembly()->NotifyDebuggerAttach(this, flags,
                                                       attaching) || result;
    }

    // Look at any shared assembly file dependencies that we have, and see if there are
    // existing loaded shared assemblies for them.  This is to handle the case where the EE
    // should have sent an assembly load for this domain but hasn't yet.

    {
        PtrHashMap::PtrIterator i = m_sharedDependenciesMap.begin();
        while (!i.end())
        {
            PEFileBinding *pDep = (PEFileBinding *)i.GetValue();

            if (pDep->pPEFile != NULL)
            {
                // The shared domain lookup function needs to access the current app domain.
                // If we're in the helper thread, this won't be set up.  So do it manually.

                if (GetThread() == NULL)
                    TlsSetValue(GetAppDomainTLSIndex(), (VOID*)this);
                else
                    _ASSERTE(GetAppDomain() == this);

                BYTE *pBase = pDep->pPEFile->GetBase();
                Assembly *pDepAssembly;
                if (SharedDomain::GetDomain()->FindShareableAssembly(pBase, &pDepAssembly) == S_OK)
                {
                    if (!ContainsAssembly(pDepAssembly))
                    {
                        LOG((LF_CORDB, LL_INFO100, "AD::NDA: Iterated shared assembly dependency AD:%#08x %s\n", 
                             pDepAssembly, pDepAssembly->GetName()));
                        
                        result = pDepAssembly->NotifyDebuggerAttach(this, flags,
                                                                    attaching) || result;
                    }
                }

                // Reset app domain if necessary
                if (GetThread() == NULL)
                    TlsSetValue(GetAppDomainTLSIndex(), NULL);
            }

            ++i;
        }
    }

    return result;
}

void AppDomain::NotifyDebuggerDetach()
{
    if (!IsDebuggerAttached())
        return;

    LOG((LF_CORDB, LL_INFO10, "AD::NDD domain [%d] %#08x %ls\n",
         GetId(), this, GetFriendlyName()));

    LOG((LF_CORDB, LL_INFO100, "AD::NDD: Interating non-shared assemblies\n"));
    AssemblyIterator i = IterateAssemblies();

    // Detach from our assemblies
    while (i.Next())
    {
        LOG((LF_CORDB, LL_INFO100, "AD::NDD: Iterated non-shared assembly AD:%#08x %s\n", 
             i.GetAssembly(), i.GetAssembly()->GetName()));
        if (!i.GetAssembly()->IsSystem())
        i.GetAssembly()->NotifyDebuggerDetach(this);
    }

    // And now from the system assemblies
    LOG((LF_CORDB, LL_INFO100, "AD::NDD: Interating system assemblies\n"));
    i = SystemDomain::System()->IterateAssemblies();
    while (i.Next())
    {
        LOG((LF_CORDB, LL_INFO100, "AD::NDD: Iterated system assembly AD:%#08x %s\n", 
             i.GetAssembly(), i.GetAssembly()->GetName()));
        i.GetAssembly()->NotifyDebuggerDetach(this);
}

    // Note that we may have sent attach events for some other assemblies above. (Namely shared 
    // assemblies which we depend on but which haven't been explicitly loaded into our app domain.)
    // This is OK since the OOP debugger logic remembers these & will handle them for us.
}
#endif // DEBUGGING_SUPPORTED

void AppDomain::SetSystemAssemblyLoadEventSent(BOOL fFlag)
{
    if (fFlag == TRUE)
        m_dwFlags |= LOAD_SYSTEM_ASSEMBLY_EVENT_SENT;
    else
        m_dwFlags &= ~LOAD_SYSTEM_ASSEMBLY_EVENT_SENT;
}

BOOL AppDomain::WasSystemAssemblyLoadEventSent(void)
{
    return ((m_dwFlags & LOAD_SYSTEM_ASSEMBLY_EVENT_SENT) == 0) ? FALSE : TRUE;
}

BOOL AppDomain::IsDomainBeingCreated(void)
{
    return ((m_dwFlags & APP_DOMAIN_BEING_CREATED) ? TRUE : FALSE);
}

void AppDomain::SetDomainBeingCreated(BOOL flag)
{
    if (flag == TRUE)
        m_dwFlags |= APP_DOMAIN_BEING_CREATED;
    else
        m_dwFlags &= ~APP_DOMAIN_BEING_CREATED;
}

void AppDomain::InitializeComObject()
{
    THROWSCOMPLUSEXCEPTION();
    if(m_pComObjectMT == NULL) {
        BEGIN_ENSURE_PREEMPTIVE_GC();
        EnterLock();
        END_ENSURE_PREEMPTIVE_GC();

        if(m_pComObjectMT == NULL) {
            HRESULT hr = S_OK;
            MethodTable *pComClass = SystemDomain::System()->BaseComObject();
            // ComObject is dependent on Variant
            COMVariant::EnsureVariantInitialized();

            m_pComObjectMT = pComClass;
        }
        LeaveLock();
    }
}

ComCallWrapperCache *AppDomain::GetComCallWrapperCache()
{
    if (! m_pComCallWrapperCache) {
        EnterLock();
        if (! m_pComCallWrapperCache)
            m_pComCallWrapperCache = ComCallWrapperCache::Create(this);
        LeaveLock();
    }
    _ASSERTE(m_pComCallWrapperCache);
    return m_pComCallWrapperCache;
}

ComPlusWrapperCache *AppDomain::GetComPlusWrapperCache()
{
    if (! m_pComPlusWrapperCache) {

        // Initialize the global RCW cleanup list here as well. This is so that it 
        // it guaranteed to exist if any RCW's are created, but it is not created
        // unconditionally.
        if (!g_pRCWCleanupList) {
            SystemDomain::Enter();
            if (!g_pRCWCleanupList)
            {
                ComPlusWrapperCleanupList *pList = new (nothrow) ComPlusWrapperCleanupList();
                if (pList != NULL && pList->Init())
                    g_pRCWCleanupList = pList;
            }
            SystemDomain::Leave();
        }
        // @todo: need error path here
        _ASSERTE(g_pRCWCleanupList);

        EnterLock();
        if (! m_pComPlusWrapperCache)
            m_pComPlusWrapperCache = new (nothrow) ComPlusWrapperCache(this);
        LeaveLock();
    }
    _ASSERTE(m_pComPlusWrapperCache);
    return m_pComPlusWrapperCache;
}

void AppDomain::ReleaseComPlusWrapper(LPVOID pCtxCookie)
{
    if (m_pComPlusWrapperCache)
        m_pComPlusWrapperCache->ReleaseWrappers(pCtxCookie);
}

BOOL AppDomain::CanThreadEnter(Thread *pThread)
{
    if (pThread == GCHeap::GetFinalizerThread() || 
        pThread == SystemDomain::System()->GetUnloadingThread())
    {
        return (int) m_Stage < STAGE_CLOSED;   
    }
    else
        return (int) m_Stage < STAGE_EXITED;
}

void AppDomain::Exit(BOOL fRunFinalizers)
{
    THROWSCOMPLUSEXCEPTION();

    LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomain::Exiting domain [%d] %#08x %ls\n",
         GetId(), this, GetFriendlyName()));

    m_Stage = STAGE_EXITING;  // Note that we're trying to exit

    // Raise the event indicating the domain is being unloaded.
    RaiseUnloadDomainEvent();

    //
    // Set up blocks so no threads can enter.
    //

    // Set the flag on our CCW cache so stubs won't enter
    if (m_pComCallWrapperCache)
        m_pComCallWrapperCache->SetDomainIsUnloading();


    // Release our ID so remoting and thread pool won't enter
    SystemDomain::ReleaseAppDomainId(m_dwId);


    AssemblyIterator i = IterateAssemblies();
    while (i.Next())
    {
        Assembly *pAssembly = i.GetAssembly();
        if (! pAssembly->IsShared())
            // The only action Unload takes is to cause our CCWs to
            // get stomped with unload thunks
            pAssembly->GetLoader()->Unload();
    }

    m_Stage = STAGE_EXITED; // All entries into the domain should be blocked now

    LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomain::Domain [%d] %#08x %ls is exited.\n",
         GetId(), this, GetFriendlyName()));

    // Cause existing threads to abort out of this domain.  This should ensure all
    // normal threads are outside the domain, and we've already ensured that no new threads
    // can enter.

    COMPLUS_TRY
    {
        UnwindThreads();
    }
    COMPLUS_CATCH
    {
        OBJECTREF pReThrowable = NULL;
        GCPROTECT_BEGIN(pReThrowable);
        pReThrowable=GETTHROWABLE();

        __try
        {
            AssemblySecurityDescriptor *pSecDesc = m_pSecContext->m_pAssemblies;
            while (pSecDesc)
            {
                // If the assembly has a security grant set we need to serialize it in
                // the shared security descriptor so we can guarantee that any future
                // version of the assembly in another appdomain context will get exactly
                // the same grant set. Do this while we can still enter appdomain
                // context to perform the serialization.
                if (pSecDesc->GetSharedSecDesc())
                    pSecDesc->GetSharedSecDesc()->MarshalGrantSet(this);
                pSecDesc = pSecDesc->GetNextDescInAppDomain();
            }
        }
        __except(
            // want to grab the exception before it's handled so we can figure out who's causing it
#ifdef _DEBUG
            DbgAssertDialog(__FILE__, __LINE__, "Unexpected exception occured during AD unload, likely in MarshalGrantSet"),
#endif
            FreeBuildDebugBreak(),
            EXCEPTION_EXECUTE_HANDLER)
        {
            // If we can't ensure the assembly in question will never be used again, we need to terminate the process. The issue is that 
            // the jitted code for the assembly contains burned in assumptions about security policy at the time the assembly was first 
            // created, so we can't ever allow the set of permissions granted to that assembly to change or an inconsistency would result. 
            // The marshal operation is the one that records the grant set in a form we can reconstitute later.
             FATAL_EE_ERROR();
        }

        GCPROTECT_END();

        COMPlusThrow(pReThrowable);
    }
    COMPLUS_END_CATCH


    // Throw away any domain specific data held by threads in the system as
    // compressed security stacks. Walking the thread store is going to be
    // difficult seeing as we will potentially execute managed code on each
    // iteration. The cleanup routine tells us whether it's OK to continue or
    // whether we should restart the scan from the beginning.
    // We need to do this before stopping thread entry into the appdomain (since
    // we might have to marshal compressed stacks from this app domain), but
    // we don't have to check again after threads are refused admittance. That's
    // because any thread that enters this domain after this point does one of
    // two things: Recaches an object in this context from the serialized
    // compressed stack (which doesn't need any additional cleanup) OR tries to
    // create a new thread with a new compressed stack object. The
    // synchronization for the latter case is in SetInheritedSecurityStack
    // (basically we just throw an AppDomainUnloaded exception in that case).
    CompressedStack::AllHandleAppDomainUnload( this, m_dwId );

    //
    // Spin running finalizers until we flush them all.  We need to make multiple passes
    // in case the finalizers create more finalizable objects.  This is important to clear
    // the finalizable objects as roots, as well as to actually execute the finalizers. This
    // will only finalize instances instances of types that aren't potentially agile becuase we can't 
    // risk finalizing agile objects. So we will be left with instances of potentially agile types 
    // in handles or statics.
    //
    // @todo: Need to ensure this will terminate in a reasonable amount of time.  Eventually
    // we should probably start passing FALSE for fRunFinalizers. Also I'm not sure we
    // guarantee that FinalizerThreadWait will ever terminate in general.
    //

    m_Stage = STAGE_FINALIZING; // All non-shared finalizers have run; no more non-shared code should run in the domain

    // We have a tricky problem here where we want to flush all finalizers but
    // also need to determine whether we need to serialize any security
    // permission grant sets (which runs managed code and could create more
    // finalizable objects). The grant set logic must be performed after any
    // user code could run, so we must finalize and serialize in a loop until no
    // more serializations are necessary.
    bool fWorkToDo;
    __try
    {
        do {
            // Flush finalizers first.
            g_pGCHeap->UnloadAppDomain(this, fRunFinalizers);
            while (g_pGCHeap->GetUnloadingAppDomain() != NULL)
                g_pGCHeap->FinalizerThreadWait();

            fWorkToDo = false;
            AssemblySecurityDescriptor *pSecDesc = m_pSecContext->m_pAssemblies;
            while (pSecDesc)
            {
                // If the assembly has a security grant set we need to serialize it in
                // the shared security descriptor so we can guarantee that any future
                // version of the assembly in another appdomain context will get exactly
                // the same grant set. Do this while we can still enter appdomain
                // context to perform the serialization.
                if (pSecDesc->GetSharedSecDesc() && pSecDesc->GetSharedSecDesc()->MarshalGrantSet(this))
                    fWorkToDo = true;
                pSecDesc = pSecDesc->GetNextDescInAppDomain();
            }
        } while (fWorkToDo);
    }
    __except(
        // want to grab the exception before it's handled so we can figure out who's causing it
#ifdef _DEBUG
        DbgAssertDialog(__FILE__, __LINE__, "Unexpected exception occured during AD unload, likely in MarshalGrantSet"),
#endif
        FreeBuildDebugBreak(),
        EXCEPTION_EXECUTE_HANDLER)
    {
        // If we can't ensure the assembly in question will never be used again, we need to terminate the process. The issue is that 
        // the jitted code for the assembly contains burned in assumptions about security policy at the time the assembly was first 
        // created, so we can't ever allow the set of permissions granted to that assembly to change or an inconsistency would result. 
        // The marshal operation is the one that records the grant set in a form we can reconstitute later.
         FATAL_EE_ERROR();
    }

    m_Stage = STAGE_FINALIZED; // All finalizers have run except for FinalizableAndAgile objects

    LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomain::Domain [%d] %#08x %ls is finalized.\n",
         GetId(), this, GetFriendlyName()));

    // Globally stop aggressive backpatching.  This must happen before we do a GC,
    // since the GC is our synchronization mechanism to prevent races in the
    // backpatcher.
    EEClass::DisableBackpatching();

    AddRef();           // Hold a reference so CloseDomain won't delete us yet
    CloseDomain();      // Remove ourself from the list of app domains

    //
    // It should be impossible to run non-mscorlib code in this domain now.
    // Nuke all of our roots except the handles. We do this to allow as many
    // finalizers as possible to run correctly. If we delete the handles, they
    // can't run.
    //

    ClearGCRoots();

    ClearGCHandles();

    LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomain::Domain [%d] %#08x %ls is cleared.\n",
         GetId(), this, GetFriendlyName()));

    m_Stage = STAGE_CLEARED; // No objects in the domain should be reachable at this point 

    // do a GC to clear out all the objects that have been released.
    g_pGCHeap->GarbageCollect();
    // won't be any finalizable objects as we eagerly finalized them, but do need to clean 
    // up syncblocks etc in DoExtraWorkForFinalier before we start killing things
    g_pGCHeap->FinalizerThreadWait();

#if CHECK_APP_DOMAIN_LEAKS 
    if (g_pConfig->AppDomainLeaks())
        // at this point shouldn't have any non-agile objects in the heap because we finalized all the non-agile ones.
        SyncBlockCache::GetSyncBlockCache()->CheckForUnloadedInstances(GetIndex());
#endif

    // There should now be no objects from this domain in the heap except any in mscorlib that were 
    // rooted by a finalizer. They will be cleanup up on the next GC.
    m_Stage = STAGE_COLLECTED; 

    LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomain::Domain [%d] %#08x %ls is collected.\n",
         GetId(), this, GetFriendlyName()));

    // Get the list of all classes we need to unlink from the backpatching list. It is
    // important that this call be after the domain cannot load any more classes.
    StartUnlinkClasses();

    // Note: it is important that this be after an EE suspension (like the above GC.)
    // This, together with the fact that we globally stopped backpatching, guarantees that
    // no threads are traversing the dangerous parts of the backpatching lists now.
    EndUnlinkClasses();

    // Backpatching can now resume.
    EEClass::EnableBackpatching();

    // Free the per-appdomain portion of each assembly security descriptor.
    AssemblySecurityDescriptor *pSecDesc = m_pSecContext->m_pAssemblies;
    while (pSecDesc)
    {
        AssemblySecurityDescriptor *pDelete = pSecDesc;
        pSecDesc = pSecDesc->GetNextDescInAppDomain();
        delete pDelete;
    }

    m_Stage = AppDomain::STAGE_CLOSED;
    SystemDomain::SetUnloadDomainClosed();

    // Release the ref we took before closing the domain
    Release();
    
    // in debug mode, do one more GC to make sure didn't miss anything 
#ifdef _DEBUG
    g_pGCHeap->FinalizerThreadWait();
    g_pGCHeap->GarbageCollect();
#endif
}

void AppDomain::StartUnlinkClasses()
{
    //
    // Accumulate a list of all classes which need to be unlinked.  It is very important
    // that this call happens after it is possible to do any more class loading in the domain.
    //

    m_UnlinkClasses = new EEHashTableOfEEClass;
    m_UnlinkClasses->Init(100, NULL, NULL);

    AssemblyIterator i = IterateAssemblies();
    while (i.Next()) {
        Assembly *pAssembly = i.GetAssembly();
            pAssembly->GetLoader()->UnlinkClasses(this);
    }
}

void AppDomain::UnlinkClass(EEClass *pClass)
{
    // Don't worry about non-restored classes.
    if (!pClass->IsRestored())
        return;

    EEClass *pParent = pClass->GetParentClass();
    // Don't worry about cases where parent & child are both doomed.
    if (pParent && pParent->GetDomain() != this)
    {
        void  *datum;

        if (!m_UnlinkClasses->GetValue(pParent, &datum))
            m_UnlinkClasses->InsertKeyAsValue(pParent);
    }
}

void AppDomain::EndUnlinkClasses()
{
    //
    // Unlink all the classes that we accumulated earlier.  It is very important that there
    // is an EE sync between the Start and End calls - this guarantees that there are no threads
    // lingering in the class lists which will trip over the entries we are about to delete.
    //

    EEHashTableIteration    iter;

    m_UnlinkClasses->IterateStart(&iter);

    while (m_UnlinkClasses->IterateNext(&iter))
    {
        EEClass  *pParent = m_UnlinkClasses->IterateGetKey(&iter);

        pParent->UnlinkChildrenInDomain(this);
    }

    delete m_UnlinkClasses;
    m_UnlinkClasses = NULL;
}

void AppDomain::Unload(BOOL fForceUnload, Thread *pRequestingThread)
{
    THROWSCOMPLUSEXCEPTION();

    Thread *pThread = GetThread();

    _ASSERTE(pThread->PreemptiveGCDisabled());

    if (! fForceUnload && !g_pConfig->AppDomainUnload())
        return;

#if (defined(_DEBUG) || defined(BREAK_ON_UNLOAD) || defined(AD_LOG_MEMORY) || defined(AD_SNAPSHOT))
    static int unloadCount = 0;
#endif

#ifdef BREAK_ON_UNLOAD
    static int breakOnUnload = g_pConfig->GetConfigDWORD(L"ADBreakOnUnload", 0);

    ++unloadCount;
    if (breakOnUnload)
    {
        if (breakOnUnload == unloadCount)
#ifdef _DEBUG
            _ASSERTE(!"Unloading AD");
#else
            FreeBuildDebugBreak();
#endif
    }
#endif

#ifdef AD_LOG_MEMORY
    static int logMemory = g_pConfig->GetConfigDWORD(L"ADLogMemory", 0);
    typedef void (__cdecl *LogItFcn) ( int );
    static LogItFcn pLogIt = NULL;

    if (logMemory && ! pLogIt)
    {
        HMODULE hMod = LoadLibraryA("mpdh.dll");
        if (hMod)
        {
            pThread->EnablePreemptiveGC();
            pLogIt = (LogItFcn)GetProcAddress(hMod, "logIt");
            if (pLogIt)
            {
                pLogIt(9999);
                pLogIt(9999);
            }
            pThread->DisablePreemptiveGC();
        }
    }
#endif

    if (this == SystemDomain::System()->DefaultDomain())
        COMPlusThrow(kCannotUnloadAppDomainException, IDS_EE_ADUNLOAD_DEFAULT);

    _ASSERTE(CanUnload());

    if (pThread == GCHeap::GetFinalizerThread() || pRequestingThread == GCHeap::GetFinalizerThread())
        COMPlusThrow(kCannotUnloadAppDomainException, IDS_EE_ADUNLOAD_IN_FINALIZER);

    // the lock on the UnloadWorker in the default domain will prevent more than one unload at a time.
    _ASSERTE(! SystemDomain::AppDomainBeingUnloaded());

    // should not be running in this AD because unload spawned thread in default domain
    _ASSERTE(! GetThread()->IsRunningIn(this, NULL));

#ifdef APPDOMAIN_STATE
    _ASSERTE_ALL_BUILDS(GetThread()->GetDomain() == SystemDomain::System()->DefaultDomain());
#endif

    LOG((LF_APPDOMAIN | LF_CORDB, LL_INFO10, "AppDomain::Unloading domain [%d] %#08x %ls\n", GetId(), this, GetFriendlyName()));

    APPDOMAIN_UNLOAD_LOCK(this);
    SystemDomain::System()->SetUnloadRequestingThread(pRequestingThread);
    SystemDomain::System()->SetUnloadingThread(GetThread());


#ifdef _DEBUG
    static int dumpSB = g_pConfig->GetConfigDWORD(L"ADDumpSB", 0);
    if (dumpSB > 1)
    {
        LogSpewAlways("Starting unload %3.3d\n", unloadCount);
        DumpSyncBlockCache();
    }
#endif

    // Do the actual unloading
    Exit(TRUE);

#ifdef AD_LOG_MEMORY
    if (pLogIt)
    {
        pThread->EnablePreemptiveGC();
        pLogIt(unloadCount);
        pThread->DisablePreemptiveGC();
    }
#endif

#ifdef AD_SNAPSHOT
    static int takeSnapShot = g_pConfig->GetConfigDWORD(L"ADTakeSnapShot", 0);
    if (takeSnapShot)
    {
        char buffer[1024];
        sprintf(buffer, "vadump -p %d -o > vadump.%d", GetCurrentProcessId(), unloadCount);
        system(buffer);
        sprintf(buffer, "umdh -p:%d -d -i:1 -f:umdh.%d", GetCurrentProcessId(), unloadCount);
        system(buffer);
        int takeDHSnapShot = g_pConfig->GetConfigDWORD(L"ADTakeDHSnapShot", 0);
        if (takeDHSnapShot)
        {
            sprintf(buffer, "dh -p %d -s -g -h -b -f dh.%d", GetCurrentProcessId(), unloadCount);
            system(buffer);
        }
    }

#endif

#ifdef _DEBUG
    static int dbgAllocReport = g_pConfig->GetConfigDWORD(L"ADDbgAllocReport", 0);
    if (dbgAllocReport)
    {
        DbgAllocReport(NULL, FALSE, FALSE);
        ShutdownLogging();
        char buffer[1024];
        sprintf(buffer, "DbgAlloc.%d", unloadCount);
        _ASSERTE(MoveFileExA("COMPLUS.LOG", buffer, MOVEFILE_REPLACE_EXISTING));
        // this will open a new file
        InitLogging();
    }

    if (dumpSB > 0)
    {
        // do extra finalizer wait to remove any leftover sb entries
        g_pGCHeap->FinalizerThreadWait();
        g_pGCHeap->GarbageCollect();
        g_pGCHeap->FinalizerThreadWait();
        LogSpewAlways("Done unload %3.3d\n", unloadCount);
        DumpSyncBlockCache();
        ShutdownLogging();
        char buffer[1024];
        sprintf(buffer, "DumpSB.%d", unloadCount);
        _ASSERTE(MoveFileExA("COMPLUS.LOG", buffer, MOVEFILE_REPLACE_EXISTING));
        // this will open a new file
        InitLogging();
    }
#endif
}

void AppDomain::ExceptionUnwind(Frame *pFrame)
{
    LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::ExceptionUnwind for %8.8x\n", pFrame));
#if _DEBUG_ADUNLOAD
    printf("%x AppDomain::ExceptionUnwind for %8.8p\n", GetThread()->GetThreadId(), pFrame);
#endif
    Thread *pThread = GetThread();
    _ASSERTE(pThread);

    // if the frame was pushed in managed code, then the cleanup in the managed code finally will
    // already have popped returned from the context, so don't need to do anything. However, if we
    // are still the current frame on an ExceptionUnwind, then we need to clean ourselves off. And if
    // the frame was pushed outside of EnterContext as part of a failed attempt to enter the context
    // then the return context will be null, so don't need to do anything with this frame.
    Context *pReturnContext = pFrame->GetReturnContext();
    if (pReturnContext && pThread->GetContext() != pReturnContext)
    {
        pThread->ReturnToContext(pFrame, FALSE);
    }

    if (! pThread->ShouldChangeAbortToUnload(pFrame))
    {
        LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::ExceptionUnwind: not first transition or abort\n"));
        return;
    }

    LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::ExceptionUnwind: changing to unload\n"));

    BEGIN_ENSURE_COOPERATIVE_GC();
    OBJECTREF throwable = NULL;
    CreateExceptionObjectWithResource(kAppDomainUnloadedException, L"Remoting_AppDomainUnloaded_ThreadUnwound", &throwable);

    // reset the exception to an AppDomainUnloadedException
    if (throwable != NULL)
        GetThread()->SetThrowable(throwable);
    END_ENSURE_COOPERATIVE_GC();
}

void AppDomain::StopEEAndUnwindThreads(int retryCount)
{
    THROWSCOMPLUSEXCEPTION();

    // For now piggyback on the GC's suspend EE mechanism
    GCHeap::SuspendEE(GCHeap::SUSPEND_FOR_APPDOMAIN_SHUTDOWN);

#ifdef _DEBUG
    // @todo: what to do with any threads that didn't stop?
    _ASSERTE(g_pThreadStore->DbgBackgroundThreadCount() > 0);
#endif

    int totalADCount = 0;
    Thread *pThread = NULL;

    RuntimeExceptionKind reKind = kLastException;
    UINT resId = 0;
    WCHAR wszThreadId[10];

    while ((pThread = ThreadStore::GetThreadList(pThread)) != NULL)
    {
        // we already checked that we're not running in the unload domain
        if (pThread == GetThread())
            continue;

#ifdef _DEBUG
        void PrintStackTraceWithADToLog(Thread *pThread);
        if (LoggingOn(LF_APPDOMAIN, LL_INFO100)) {
            LOG((LF_APPDOMAIN, LL_INFO100, "\nStackTrace for %x\n", pThread->GetThreadId()));
            PrintStackTraceWithADToLog(pThread);
        }
#endif
        int count = 0;
        Frame *pFrame = pThread->GetFirstTransitionInto(this, &count);
        if (! pFrame) {
            _ASSERTE(count == 0);
            continue;
        }
        totalADCount += count;

        // don't setup the exception info for the unloading thread unless it's the last one in
        if (retryCount > 1000 && reKind == kLastException &&
            (pThread != SystemDomain::System()->GetUnloadRequestingThread() || m_dwThreadEnterCount == 1))
        {
#ifdef AD_BREAK_ON_CANNOT_UNLOAD
            static int breakOnCannotUnload = g_pConfig->GetConfigDWORD(L"ADBreakOnCannotUnload", 0);
            if (breakOnCannotUnload)
                _ASSERTE(!"Cannot unload AD");
#endif
            reKind = kCannotUnloadAppDomainException;
            resId = IDS_EE_ADUNLOAD_CANT_UNWIND_THREAD;
            Wszwsprintf(wszThreadId, L"%x", pThread->GetThreadId());
            LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::UnwindThreads cannot stop thread %x with %d transitions\n", pThread->GetThreadId(), count));
            // don't break out of this early or the assert totalADCount == (int)m_dwThreadEnterCount below will fire
            // it's better to chew a little extra time here and make sure our counts are consistent
        }

        // only abort the thread requesting the unload if it's the last one in, that way it will get
        // notification that the unload failed for some other thread not being aborted. And don't abort
        // the finalizer thread - let it finish it's work as it's allowed to be in there. If it won't finish, 
        // then we will eventually get a CannotUnloadException on it.
        if (pThread != GCHeap::GetFinalizerThread() &&
           (pThread != SystemDomain::System()->GetUnloadRequestingThread() || m_dwThreadEnterCount == 1))
        {
            LOG((LF_APPDOMAIN, LL_INFO100, "AppDomain::UnwindThreads stopping %x with %d transitions\n", pThread->GetThreadId(), count));
#if _DEBUG_ADUNLOAD
            printf("AppDomain::UnwindThreads %x stopping %x with first frame %8.8p\n", GetThread()->GetThreadId(), pThread->GetThreadId(), pFrame);
#endif
            if (retryCount == -1 || m_dwThreadEnterCount == 1)
            {
                // minor hack - don't keep aborting a non-requesting thread, give it time to get out. ASP has a problem they need to 
                // fix with respect to this.
                pThread->SetUnloadBoundaryFrame(pFrame);
                if (!pThread->IsAbortRequested())
                    pThread->SetAbortRequest();
            }
        }
    }

#ifdef _DEBUG
    _ASSERTE(totalADCount == (int)m_dwThreadEnterCount);
#endif
    if (totalADCount != (int)m_dwThreadEnterCount)
        FreeBuildDebugBreak();
    
    // if our count did get messed up, set it to whatever count we actually found in the domain to avoid looping
    // or other problems related to incorrect count. This is very much a bug if this happens - a thread should always
    // exit the domain gracefully.
    m_dwThreadEnterCount = totalADCount;

    // CommonTripThread will handle the abort for any threads that we've marked
    GCHeap::RestartEE(FALSE, TRUE);
    if (reKind != kLastException)
    {
        SystemDomain::RestoreAppDomainId(m_dwId, this);
        COMPlusThrow(reKind, resId, wszThreadId);
    }
}

void AppDomain::UnwindThreads()
{
    // @todo: need real synchronization here!!!

    int retryCount = -1;
    // now wait for all the threads running in our AD to get out
    while (m_dwThreadEnterCount > 0) {
#ifdef _DEBUG
        if (LoggingOn(LF_APPDOMAIN, LL_INFO100))
            DumpADThreadTrack();
#endif
        StopEEAndUnwindThreads(retryCount);
#ifdef STRESS_HEAP
        // GCStress takes a long time to unwind, due to expensive creation of
        // a threadabort exception.
        if(g_pConfig->GetGCStressLevel() == 0)            
#endif
            ++retryCount;
        LOG((LF_APPDOMAIN, LL_INFO10, "AppDomain::UnwindThreads iteration %d waiting on thread count %d\n", retryCount, m_dwThreadEnterCount));
#if _DEBUG_ADUNLOAD
        printf("AppDomain::UnwindThreads iteration %d waiting on thread count %d\n", retryCount, m_dwThreadEnterCount);
#endif
#ifdef _DEBUG
        GetThread()->UserSleep(20);
#else
        GetThread()->UserSleep(10);
#endif
    }
}

void AppDomain::ClearGCHandles()
{
    // this will prevent any finalizers from trying to switch into the AD. The handles to
    // the exposed objects are garbage, so can't touch them.
    Context::CleanupDefaultContext(this);
    m_pDefaultContext = NULL;

    // Remove our handle table as a source of GC roots
    SystemDomain::System()->Enter();
    BEGIN_ENSURE_COOPERATIVE_GC();
    Ref_RemoveHandleTable(m_hHandleTable);
    END_ENSURE_COOPERATIVE_GC();
    SystemDomain::System()->Leave();
}

void AppDomain::ClearGCRoots()
{
    Thread *pCurThread = GetThread();
    BOOL toggleGC = pCurThread->PreemptiveGCDisabled();

    // Need to take this lock prior to suspending the EE because ReleaseDomainStores needs it. All
    // access to thread_m_pDLSHash is done with the LockDLSHash, so don't have to worry about cooperative
    // mode threads
    if (toggleGC)
        pCurThread->EnablePreemptiveGC();
    ThreadStore::LockDLSHash();
    pCurThread->DisablePreemptiveGC();

    Thread *pThread = NULL;
    GCHeap::SuspendEE(GCHeap::SUSPEND_FOR_APPDOMAIN_SHUTDOWN);

    // Tell the JIT managers to delete any entries in their structures. All the cooperative mode threads are stopped at
    // this point, so only need to synchronize the preemptive mode threads.
    ExecutionManager::Unload(this);

    // Release the DLS for this domain for each thread. Also, remove the TLS for this
    // domain for each thread.
    int iSize = (g_pThreadStore->m_ThreadCount) * sizeof(LocalDataStore*);
    CQuickBytes qb;
    LocalDataStore** pStores = (LocalDataStore **) qb.Alloc(iSize);
    int numStores = 0;
    ReleaseDomainStores(pStores, &numStores);

    // Clear out the exceptions objects held by a thread.
    while ((pThread = ThreadStore::GetAllThreadList(pThread, 0, 0)) != NULL)
    {
        // @TODO: A pre-allocated AppDomainUnloaded exception might be better.
        if (   pThread->m_LastThrownObjectHandle != NULL
            && HndGetHandleTable(pThread->m_LastThrownObjectHandle) == m_hHandleTable) 
        {
            DestroyHandle(pThread->m_LastThrownObjectHandle);
            pThread->m_LastThrownObjectHandle = NULL;
        }

        for (ExInfo* pExInfo = &pThread->m_handlerInfo;
            pExInfo != NULL;
            pExInfo = pExInfo->m_pPrevNestedInfo)
        {
            if (   pExInfo->m_pThrowable 
                && HndGetHandleTable(pExInfo->m_pThrowable) == m_hHandleTable)
            {
                DestroyHandle(pExInfo->m_pThrowable);
                pExInfo->m_pThrowable = NULL;
            }
        }
        // go through the thread local statics and clear out any whose methoddesc
    }

    // @TODO: Anything else to clean out?
    GCHeap::RestartEE(FALSE, TRUE);

    // Now remove these LocalDataStores from the managed LDS manager. This must be done outside the
    // suspend of the EE because RemoveDLSFromList calls managed code.
    int i = numStores;
    while (--i >= 0) {
        if (pStores[i]) {
            Thread::RemoveDLSFromList(pStores[i]);
            delete pStores[i];
        }
    }

    ThreadStore::UnlockDLSHash();
    if (!toggleGC)
        pCurThread->EnablePreemptiveGC();
}

// (1) Remove the DLS for this domain from each thread
// (2) Also, remove the TLS (Thread local static) stores for this
// domain from each thread
void AppDomain::ReleaseDomainStores(LocalDataStore **pStores, int *numStores)
{
    // Don't bother cleaning this up if we're detaching
    if (g_fProcessDetach)
        return;

    Thread *pThread = NULL;
    int id = GetId();
    int i = 0;

    Thread *pCurThread = GetThread();

    while ((pThread = ThreadStore::GetAllThreadList(pThread, 0, 0)) != NULL)
    {
        // Get a pointer to the Domain Local Store
        pStores[i++] = pThread->RemoveDomainLocalStore(id);

        // Delete the thread local static store
        pThread->DeleteThreadStaticData(this);
    }

    *numStores = i;
}

#ifdef _DEBUG

void AppDomain::TrackADThreadEnter(Thread *pThread, Frame *pFrame)
{
    _ASSERTE(pThread);
    _ASSERTE(pFrame != (Frame*)(size_t)0xcdcdcdcd);

    while (FastInterlockCompareExchange((void **)&m_TrackSpinLock, (LPVOID)1, (LPVOID)0) != (LPVOID)0)
        ;
    if (m_pThreadTrackInfoList == NULL)
        m_pThreadTrackInfoList = new (nothrow) ThreadTrackInfoList;
    if (m_pThreadTrackInfoList) {

        ThreadTrackInfoList *pTrackList = m_pThreadTrackInfoList;

        ThreadTrackInfo *pTrack = NULL;
        for (int i=0; i < pTrackList->Count(); i++) {
            if ((*(pTrackList->Get(i)))->pThread == pThread) {
                pTrack = *(pTrackList->Get(i));
                break;
            }
        }
        if (! pTrack) {
            pTrack = new (nothrow) ThreadTrackInfo;
            if (pTrack)
                pTrack->pThread = pThread;
            ThreadTrackInfo **pSlot = pTrackList->Append();
            *pSlot = pTrack;
        }

        ++m_dwThreadEnterCount;
        Frame **pSlot = pTrack->frameStack.Insert(0);
        *pSlot = pFrame;

        int totThreads = 0;
        for (i=0; i < pTrackList->Count(); i++)
            totThreads += (*(pTrackList->Get(i)))->frameStack.Count();
        _ASSERTE(totThreads == (int)m_dwThreadEnterCount);
    }

    InterlockedExchange((LONG*)&m_TrackSpinLock, 0);
}


void AppDomain::TrackADThreadExit(Thread *pThread, Frame *pFrame)
{
    while (FastInterlockCompareExchange((void **)&m_TrackSpinLock, (LPVOID)1, (LPVOID)0) != (LPVOID)0)
        ;
    ThreadTrackInfoList *pTrackList= m_pThreadTrackInfoList;
    _ASSERTE(pTrackList);
    ThreadTrackInfo *pTrack = NULL;
    for (int i=0; i < pTrackList->Count(); i++)
    {
        if ((*(pTrackList->Get(i)))->pThread == pThread)
        {
            pTrack = *(pTrackList->Get(i));
            break;
        }
    }
    _ASSERTE(pTrack);
    _ASSERTE(*(pTrack->frameStack.Get(0)) == pFrame);
    pTrack->frameStack.Delete(0);
    --m_dwThreadEnterCount;

    int totThreads = 0;
    for (i=0; i < pTrackList->Count(); i++)
        totThreads += (*(pTrackList->Get(i)))->frameStack.Count();
    _ASSERTE(totThreads == (int)m_dwThreadEnterCount);

    InterlockedExchange((LONG*)&m_TrackSpinLock, 0);
}

void AppDomain::DumpADThreadTrack()
{
    while (FastInterlockCompareExchange((void **)&m_TrackSpinLock, (LPVOID)1, (LPVOID)0) != (LPVOID)0)
        ;
    ThreadTrackInfoList *pTrackList= m_pThreadTrackInfoList;
    if (!pTrackList)
        goto end;

    {
    LOG((LF_APPDOMAIN, LL_INFO10000, "\nThread dump of %d threads for %S\n", m_dwThreadEnterCount, GetFriendlyName()));
    int totThreads = 0;
    for (int i=0; i < pTrackList->Count(); i++)
    {
        ThreadTrackInfo *pTrack = *(pTrackList->Get(i));
        LOG((LF_APPDOMAIN, LL_INFO100, "  ADEnterCount for %x is %d\n", pTrack->pThread->GetThreadId(), pTrack->frameStack.Count()));
        totThreads += pTrack->frameStack.Count();
        for (int j=0; j < pTrack->frameStack.Count(); j++)
            LOG((LF_APPDOMAIN, LL_INFO100, "      frame %8.8x\n", *(pTrack->frameStack.Get(j))));
    }
    _ASSERTE(totThreads == (int)m_dwThreadEnterCount);
    }
end:
    InterlockedExchange((LONG*)&m_TrackSpinLock, 0);
}
#endif

void BaseDomain::ReleaseFusionInterfaces()
{
    AssemblyIterator i = IterateAssemblies();

    while (i.Next()) {
        Assembly * assem = i.GetAssembly();
        if (assem->Parent() == this) {
            assem->ReleaseFusionInterfaces();
        }
    }

    // Release the fusion context after all the assemblies have been released.
    ClearFusionContext();
}

OBJECTREF AppDomain::GetAppDomainProxy()
{
    THROWSCOMPLUSEXCEPTION();

    COMClass::EnsureReflectionInitialized();

    OBJECTREF orProxy = CRemotingServices::CreateProxyForDomain(this);

    _ASSERTE(orProxy->GetMethodTable()->IsThunking());

    return orProxy;
}


void *SharedDomain::operator new(size_t size, void *pInPlace)
{
    return pInPlace;
}

void SharedDomain::operator delete(void *pMem)
{
    // Do nothing - new() was in-place
}


HRESULT SharedDomain::Attach()
{
    // Create the global SharedDomain and initialize it.
    m_pSharedDomain = new (&g_pSharedDomainMemory) SharedDomain();
    if (m_pSharedDomain == NULL)
        return COR_E_OUTOFMEMORY;

    LOG((LF_CLASSLOADER,
         LL_INFO10,
         "Created shared domain at %x\n",
         m_pSharedDomain));

    // We need to initialize the memory pools etc. for the system domain.
    HRESULT hr = m_pSharedDomain->Init(); // Setup the memory heaps
    if(FAILED(hr)) return hr;

    return S_OK;

}

void SharedDomain::Detach()
{
    if (m_pSharedDomain)
    {
        m_pSharedDomain->Terminate();
        delete m_pSharedDomain;
        m_pSharedDomain = NULL;
    }
}

SharedDomain *SharedDomain::GetDomain()
{
    return m_pSharedDomain;
}

HRESULT SharedDomain::Init()
{
    HRESULT hr = BaseDomain::Init();
    if (FAILED(hr))
        return hr;

    LockOwner lock = {m_pDomainCrst, IsOwnerOfCrst};
    // 1 below indicates index into g_rgprimes[1] == 17
    m_assemblyMap.Init(1, CanLoadAssembly, TRUE, &lock);

    // Allocate enough space for just mscoree initially
    m_pDLSRecords = (DLSRecord *) GetHighFrequencyHeap()->AllocMem(sizeof(DLSRecord));
    if (!m_pDLSRecords)
        return E_OUTOFMEMORY;

    m_cDLSRecords = 0;
    m_aDLSRecords = 1;

    return S_OK;
}

void SharedDomain::Terminate()
{
    // make sure we delete the StringLiteralMap before unloading
    // the asemblies since the string literal map entries can 
    // point to metadata string literals.
    if (m_pStringLiteralMap != NULL)
    {
        delete m_pStringLiteralMap;
        m_pStringLiteralMap = NULL;
    }

    PtrHashMap::PtrIterator i = m_assemblyMap.begin();

    while (!i.end())
    {
        Assembly *pAssembly = (Assembly*) i.GetValue();
        delete pAssembly;
        ++i;
    }

    BaseDomain::Terminate();
}

BOOL SharedDomain::CanLoadAssembly(UPTR u1, UPTR u2)
{
    //
    // We're kind of abusing the compare routine.
    // Rather than matching the given pointer,
    // we test to see if we can load in the current
    // app domain.
    //

    Assembly *pAssembly = (Assembly *) u2;

    bool result;

    if (GetThread() == NULL)
    {
        // Special case for running this in the debug helper thread.  In such a case 
        // we can rely on the cache for our results so don't worry about error or loading
        result = pAssembly->CanShare(GetAppDomain(), NULL, TRUE) == S_OK;
    }
    else
    {

    BEGIN_ENSURE_COOPERATIVE_GC();
    
    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
    
    result = pAssembly->CanShare(GetAppDomain(), &throwable, FALSE) == S_OK;

    GCPROTECT_END();

    END_ENSURE_COOPERATIVE_GC();
    }

    return result;
}

HRESULT SharedDomain::FindShareableAssembly(BYTE *pBase, Assembly **ppAssembly)
{
    Assembly *match = (Assembly *) m_assemblyMap.LookupValue((UPTR) pBase, NULL);
    if (match != (Assembly *) INVALIDENTRY)
    {
        *ppAssembly = match;
        return S_OK;
    }
    else
    {
        *ppAssembly = NULL;
        return S_FALSE;
    }
}


HRESULT SharedDomain::AddShareableAssembly(Assembly **ppAssembly, AssemblySecurityDescriptor **ppSecDesc)
{
    HRESULT hr;

    EnterLock();

    UPTR base = (UPTR) (*ppAssembly)->GetManifestFile()->GetBase();

    // See if we are racing to add the same assembly
    Assembly *match = (Assembly *) m_assemblyMap.LookupValue(base, NULL);
    if (match == (Assembly *) INVALIDENTRY)
    {
        m_assemblyMap.InsertValue(base, *ppAssembly);
        hr = S_OK;
    }
    else
    {
        Assembly *pOldAssembly = *ppAssembly;
        *ppAssembly = match;

        // Perform the old assembly delete before the security cleanup below
        // since this action triggers the deletion of the associated
        // SharedSecurityDescriptor which in turn blows away the SSD back
        // pointer in each ASD referenced (which would blow away the work done
        // by the ASD->Init call below).
        delete pOldAssembly;

        // When switching assemblies we have some security cleanup to
        // perform. We've already associated the
        // AssemblySecurityDescriptor for this appdomain with this
        // particular assembly instance, so we need to relink the ASD
        // with the new assembly (doing this without first unlinking
        // the ASD from the old list causes a list corruption, but
        // we're about to blow away the SharedSecurityDescriptor and
        // the entire list anyway, and avoiding the unlink stops us
        // falling over some debug code that could fire if policy had
        // already been resolved for the assembly we're about to
        // delete).
        // Better unlink the ASD from the list of ASDs for this AD though, else
        // we'll add ourselves twice and corrupt the list (which is very much
        // still alive).
        (*ppSecDesc)->RemoveFromAppDomainList();
        *ppSecDesc = (*ppSecDesc)->Init(match);

        hr = S_FALSE;
    }

    (*ppAssembly)->IncrementShareCount();

    LeaveLock();

    LOG((LF_CODESHARING,
         LL_INFO100,
         "Successfully added shareable assembly \"%S\".\n",
         (*ppAssembly)->GetManifestFile()->GetFileName()));

    return hr;
}

void SharedDomain::ReleaseFusionInterfaces()
{
    BaseDomain::ReleaseFusionInterfaces();

    PtrHashMap::PtrIterator i = m_assemblyMap.begin();

    while (!i.end())
    {
        Assembly *pAssembly = (Assembly*) i.GetValue();
        pAssembly->ReleaseFusionInterfaces();
        ++i;
    }
}// ReleaseFusionInterfaces

DomainLocalClass *DomainLocalBlock::AllocateClass(MethodTable *pClass)
{
    THROWSCOMPLUSEXCEPTION();

    DomainLocalClass *pLocalClass = (DomainLocalClass *)
        m_pDomain->GetHighFrequencyHeap()->AllocMem(sizeof(DomainLocalClass)
                                                    + pClass->GetStaticSize());

    if (pLocalClass == NULL)
        COMPlusThrowOM();

    LOG((LF_CODESHARING,
         LL_INFO1000,
         "Allocated domain local class for domain 0x%x of size %d for class %s.\n",
         m_pDomain, pClass->GetStaticSize(), pClass->GetClass()->m_szDebugClassName));

    pClass->InstantiateStaticHandles((OBJECTREF **) pLocalClass->GetStaticSpace(), FALSE);

    return pLocalClass;
}

void DomainLocalBlock::EnsureIndex(SIZE_T index)
{
    THROWSCOMPLUSEXCEPTION();

    enum
    {
        LOCAL_BLOCK_SIZE_INCREMENT = 1024
    };

    if (m_pSlots != NULL && m_cSlots > index)
        return;

    APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(m_pDomain);

    if (m_pSlots != NULL && m_cSlots > index)
        return;

    SIZE_T oldSize = m_cSlots;
    SIZE_T newSize = index;

    if (newSize - oldSize < LOCAL_BLOCK_SIZE_INCREMENT)
        newSize = oldSize + LOCAL_BLOCK_SIZE_INCREMENT;

    void *pBlock = m_pDomain->GetHighFrequencyHeap()->AllocMem(sizeof(SIZE_T) * newSize);
    if (pBlock == NULL)
        COMPlusThrowOM();

    LOG((LF_CODESHARING,
         LL_INFO100,
         "Allocated Domain local block for domain 0x%x of size %d.\n",
         m_pDomain, newSize));

    if (m_pSlots)
        // copy the old values in
        memcpy(pBlock, m_pSlots, oldSize * sizeof(SIZE_T));

    m_pSlots = (SIZE_T*)pBlock;
    m_cSlots = newSize;
}

HRESULT DomainLocalBlock::SafeEnsureIndex(SIZE_T index) 
{
    HRESULT hr = E_FAIL;
    COMPLUS_TRY
    {
        EnsureIndex(index);
        hr = S_OK;
    }
    COMPLUS_CATCH
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        hr = SecurityHelper::MapToHR(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    }
    COMPLUS_END_CATCH
    return hr;
}

void DomainLocalBlock::EnsureMaxIndex()
{
    EnsureIndex(SharedDomain::GetDomain()->GetMaxSharedClassIndex());
}


DomainLocalClass *DomainLocalBlock::PopulateClass(MethodTable *pMT)
{
    THROWSCOMPLUSEXCEPTION();

    SIZE_T ID = pMT->GetSharedClassIndex();
    DomainLocalClass *pLocalClass = GetClass(ID);

    if (pLocalClass == NULL)
    {
        APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(m_pDomain);

        pLocalClass = GetClass(ID);
        if (pLocalClass == NULL)
        {
            pLocalClass = AllocateClass(pMT);
            SetClass(ID, pLocalClass);
        }
    }

    return pLocalClass;
}

void DomainLocalBlock::PopulateClass(MethodTable *pMT, DomainLocalClass *pData)
{
    THROWSCOMPLUSEXCEPTION();

    SIZE_T ID = pMT->GetSharedClassIndex();

    APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(m_pDomain);

    _ASSERTE(GetClass(ID) == NULL);

    SetClass(ID, pData);
}

DomainLocalClass *DomainLocalBlock::FetchClass(MethodTable *pClass)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF Throwable;
    DomainLocalClass *pLocalClass;

    if (!pClass->CheckRunClassInit(&Throwable, &pLocalClass, m_pDomain))
        COMPlusThrow(Throwable);

    return pLocalClass;
}

SIZE_T SharedDomain::AllocateSharedClassIndices(SIZE_T typeCount)
{
    // Allocate some "anonymous" DLS entries.  Note that these can never be
    // accessed via FindIndexClass.

    EnterCacheLock();

    DWORD result = m_nextClassIndex;
    m_nextClassIndex += typeCount;

    LeaveCacheLock();

    return result;
}


SIZE_T SharedDomain::AllocateSharedClassIndices(Module *pModule, SIZE_T typeCount)
{
    _ASSERTE(pModule != NULL);

    if (typeCount == 0)
        return 0;

    EnterCacheLock();

    
    DWORD result = m_nextClassIndex;
    m_nextClassIndex += typeCount;
    DWORD total = m_nextClassIndex;
    
    if (m_cDLSRecords == m_aDLSRecords) {
        m_aDLSRecords <<= 1;
        if (m_aDLSRecords < 20)
            m_aDLSRecords = 20;
        
        DLSRecord *pNewRecords = (DLSRecord *)
            GetHighFrequencyHeap()->AllocMem(sizeof(DLSRecord) * m_aDLSRecords);
        if (pNewRecords) {
            memcpy(pNewRecords, m_pDLSRecords, sizeof(DLSRecord) * m_cDLSRecords);
            
            // Leak the old DLS record list, since another thread may be scanning it.
            // (Besides, it's allocated in the loader heap.)
            m_pDLSRecords = pNewRecords;
        }
        else {
            LeaveCacheLock();
            return 0; //@TODO: do we really want to return 0 for an error?
        }
    }

    DLSRecord *pNewRecord = m_pDLSRecords + m_cDLSRecords;
    pNewRecord->pModule = pModule;
    pNewRecord->DLSBase = result;
    
    m_cDLSRecords++;
    
    pModule->SetBaseClassIndex(result);

    LeaveCacheLock();

    //
    // Whenever indicies get added to a shared assembly,
    // we need to scan all domains using that assembly, and make sure that
    // they have a big enough DLS allocated.
    // @todo: make this faster - if we have a lot of domains then we're screwed
    //

    Assembly *pAssembly = pModule->GetAssembly();
    BOOL fSystemAssembly = pAssembly->IsSystem();
    AppDomainIterator ai;

    while (ai.Next())
    {
        AppDomain *pDomain = ai.GetDomain();

        if (fSystemAssembly) {
            pDomain->GetDomainLocalBlock()->EnsureIndex(total);
            continue;
        }

        AssemblyIterator i = pDomain->IterateAssemblies();
        while (i.Next())
        {
            if (i.GetAssembly() == pAssembly)
            {
                pDomain->GetDomainLocalBlock()->EnsureIndex(total);
                break;
            }
        }
    }

    return result;
}

void DomainLocalBlock::SetClassInitialized(SIZE_T ID)
{
    _ASSERTE(m_cSlots > ID);
    _ASSERTE(!IsClassInitialized(ID));
    _ASSERTE(!IsClassInitError(ID));

    // We may grow the size of m_pSlots and replace it with an enlarged one.
    // We need to take the same lock as in EnsureIndex to ensure that this update
    // is sync-ed with enlargement.
    APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(m_pDomain);

    m_pSlots[ID] |= INITIALIZED_FLAG;
}

void DomainLocalBlock::SetClassInitError(SIZE_T ID)
{
    _ASSERTE(m_cSlots > ID);
    _ASSERTE(!IsClassInitialized(ID));
    
    // We may grow the size of m_pSlots and replace it with an enlarged one.
    // We need to take the same lock as in EnsureIndex to ensure that this update
    // is sync-ed with enlargement.
    APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(m_pDomain);

    m_pSlots[ID] |= ERROR_FLAG;
}

void DomainLocalBlock::SetSlot(SIZE_T index, void *value) 
{ 
    _ASSERTE(m_cSlots > index); 

    // We may grow the size of m_pSlots and replace it with an enlarged one.
    // We need to take the same lock as in EnsureIndex to ensure that this update
    // is sync-ed with enlargement.
    APPDOMAIN_DOMAIN_LOCAL_BLOCK_LOCK(m_pDomain);

    m_pSlots[index] = (SIZE_T) value; 
}

MethodTable *SharedDomain::FindIndexClass(SIZE_T index)
{
    //
    // Binary search for the DLS record 
    //

    DLSRecord *pStart = m_pDLSRecords;
    DLSRecord *pEnd = pStart + m_cDLSRecords - 1;

    while (pStart < pEnd)
    {
        DLSRecord *pMid = pStart + ((pEnd - pStart)>>1);

        if (index < pMid->DLSBase)
            pEnd = pMid;
        else if (index >= (pMid+1)->DLSBase)
            pStart = pMid+1;
        else
        {
            pStart = pMid;
            break;
        }
    }

    _ASSERTE(index >= pStart->DLSBase 
             && (pStart == (m_pDLSRecords + m_cDLSRecords - 1)
                 || index < (pStart+1)->DLSBase)
             && index < m_nextClassIndex);
    
    // Find the module in the current app domain
    
    Module *pModule = pStart->pModule;

    _ASSERTE(pModule != NULL);
    _ASSERTE(pModule->GetBaseClassIndex() == pStart->DLSBase);

    // Load the desired type based on its rid

    DWORD rid = (DWORD)(index - pStart->DLSBase + 1);
    TypeHandle th = pModule->LookupTypeDef(TokenFromRid(rid, mdtTypeDef));

    _ASSERTE(!th.IsNull());

    return th.AsMethodTable();
}

//*****************************************************************************
//*****************************************************************************
//*****************************************************************************

HRESULT InterfaceVTableMapMgr::Init(BYTE * initReservedMem, DWORD initReservedMemSize)
{
    m_pInterfaceVTableMapMgrCrst = NULL;
    m_pFirstMap                  = NULL;
    m_pInterfaceVTableMapHeap    = NULL;
    m_nextInterfaceId            = 0;
    m_dwHighestId                = 0;
    m_dwFlag = 0;

    if ((m_pInterfaceVTableMapMgrCrst = ::new Crst("InterfaceVTableMapMgr", CrstInterfaceVTableMap)) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if ((m_pInterfaceVTableMapHeap = ::new LoaderHeap(INTERFACE_VTABLE_MAP_MGR_RESERVE_SIZE, INTERFACE_VTABLE_MAP_MGR_COMMIT_SIZE, 
                                                      initReservedMem, initReservedMemSize, 
                                                      &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize),
                                                      &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize))
                                                      ) == NULL)
    {
        return E_OUTOFMEMORY;
    }
    WS_PERF_ADD_HEAP(INTERFACE_VTABLEMAP_HEAP, m_pInterfaceVTableMapHeap);

#if 1
    m_pGlobalTableForComWrappers = SystemDomain::GetAddressOfGlobalInterfaceVTableMap();
#else
    if (!(m_pGlobalTableForComWrappers = (LPVOID*)VirtualAlloc(NULL, kNumPagesAllocedForGlobalTable*OS_PAGE_SIZE, MEM_RESERVE, PAGE_READWRITE)))
    {
        return E_OUTOFMEMORY;
    }
#endif

    return S_OK;
}


VOID InterfaceVTableMapMgr::Terminate()
{
    ::delete m_pInterfaceVTableMapMgrCrst;

#ifdef _DEBUG

    UINT    totalslots = 0;
    UINT    usedslots  = 0;

    for (MapHeader *pMap = m_pFirstMap; pMap != NULL; pMap = pMap->m_pNext)
    {
        totalslots += pMap->m_numSlots;
        for (DWORD i = 0; i < pMap->m_numSlots; i++)
        {
            if (pMap->m_slotTab[i] != NULL)
            {
                usedslots++;
            }
        }
    }

    if (totalslots != 0)
    {
        LOG((LF_CLASSLOADER, LL_INFO10, "----------------------------------------------------------\n"));
        LOG((LF_CLASSLOADER, LL_INFO10, " %lu interfaces loaded.\n", (ULONG)m_nextInterfaceId));
        LOG((LF_CLASSLOADER, LL_INFO10, " %lu slots filled.\n", (ULONG)usedslots));
        LOG((LF_CLASSLOADER, LL_INFO10, " %lu slots allocated.\n", (ULONG)totalslots));
        LOG((LF_CLASSLOADER, LL_INFO10, " %lu%% fill factor.\n", (ULONG) (100.0*( ((double)usedslots)/((double)totalslots) ))));
        LOG((LF_CLASSLOADER, LL_INFO10, "----------------------------------------------------------\n"));
    }
#endif

    ::delete m_pInterfaceVTableMapHeap;


#if 1
#else
    BOOL success;
    success = VirtualFree(m_pGlobalTableForComWrappers, kNumPagesAllocedForGlobalTable*OS_PAGE_SIZE, MEM_DECOMMIT);
    _ASSERTE(success);
    success = VirtualFree(m_pGlobalTableForComWrappers, 0, MEM_RELEASE);
    _ASSERTE(success);
#endif

}

void InterfaceVTableMapMgr::SetShared()
{
    _ASSERTE(m_nextInterfaceId == 0);

    m_dwFlag = SHARED_MAP;
}


UINT32 InterfaceVTableMapMgr::AllocInterfaceId()
{
#if 1
    // @todo: Have everyone call this directly since going through
    // the InterfaceVTableMapMgr is inefficient and misleading.
    return SystemDomain::AllocateGlobalInterfaceId();
#else
    UINT32 res;



    m_pInterfaceVTableMapMgrCrst->Enter();

    if(m_dwFlag & SHARED_MAP) {
        res = m_nextInterfaceId;
        m_nextInterfaceId += 4;
    }
    else {
        do {
            res = m_nextInterfaceId++;
        } while ((res & 0x3) == 0);
    }
    res = GrowInterfaceArray(res);

    m_pInterfaceVTableMapMgrCrst->Leave();

    return res;
#endif
}

UINT32 InterfaceVTableMapMgr::EnsureInterfaceId(UINT res)
{
#if 1
#else
    m_pInterfaceVTableMapMgrCrst->Enter();

    UINT32 result = 0;
    while(result != -1 && res >= m_dwHighestId) {
        result = GrowInterfaceArray(res);
    }

    m_pInterfaceVTableMapMgrCrst->Leave();
#endif
    return res;
}

UINT32 InterfaceVTableMapMgr::GrowInterfaceArray(UINT res)
{
#if 1
#else
    if (res >= m_dwHighestId)
    {
        if (res * sizeof(LPVOID) >= kNumPagesAllocedForGlobalTable*OS_PAGE_SIZE)
        {
            m_nextInterfaceId--;
            m_pInterfaceVTableMapMgrCrst->Leave();
            return (UINT32)(-1);
        }

        // Cross into new page boundary. Commit the next page.
        if (!VirtualAlloc( m_dwHighestId * sizeof(LPVOID) + (LPBYTE)m_pGlobalTableForComWrappers,
                           OS_PAGE_SIZE,
                           MEM_COMMIT,
                           PAGE_READWRITE ))
        {
            return (UINT32)(-1);
        }
#ifdef _DEBUG
        FillMemory( m_dwHighestId * sizeof(LPVOID) + (LPBYTE)m_pGlobalTableForComWrappers, OS_PAGE_SIZE, 0xcc );
#endif
        m_dwHighestId += OS_PAGE_SIZE / sizeof(LPVOID);
    }
#endif
    return res;
}

// Find minimum id in a vector of ids
static  UINT32 MinIntfId(DWORD intfIdCnt, UINT32 intfIdVec[])
{
    UINT32 minIntfId = 0xffffffff;

    for (DWORD i = 0; i < intfIdCnt; i++)
        if (minIntfId > intfIdVec[i])
            minIntfId = intfIdVec[i];

    return  minIntfId;
}

// Find maximum id in a vector of ids
static  UINT32 MaxIntfId(DWORD intfIdCnt, UINT32 intfIdVec[])
{
    UINT32 maxIntfId = 0;

    for (DWORD i = 0; i < intfIdCnt; i++)
        if (maxIntfId < intfIdVec[i])
            maxIntfId = intfIdVec[i];

    return  maxIntfId;
}

// Check whether the set of interfaces described by intfIdCnt, intfIdVec fits in slotVec,
// that is, whether slotVec[id] == NULL's for every id in intfIdVec.
static  BOOL  IntfVecFits(LPVOID slotVec[], DWORD intfIdCnt, UINT32 intfIdVec[])
{
    for (DWORD i = 0; i < intfIdCnt; i++)
        if (slotVec[ intfIdVec[i] ] != NULL)
            return  false;

    return  true;
}

// Find a NULL slot in slotVec. Return slotCnt if none found.
static  DWORD  FindFreeSlot(DWORD start, DWORD slotCnt, LPVOID slotVec[])
{
    for (DWORD i = start; i < slotCnt; i++)
        if (slotVec[i] == NULL)
            break;

    return  i;
}

// Find an index i such that slotVec[i+id] == NULL for all id in intfIdVec.
// If successful, return i in result and return true. Return false if unsucessful.
static  BOOL  FindFreeSlots(DWORD start, DWORD slotCnt, LPVOID slotVec[], DWORD intfIdCnt, UINT32 intfIdVec[], INT32 *result)
{
    _ASSERTE(slotCnt > 0);

    UINT32 minId = MinIntfId(intfIdCnt, intfIdVec);
    UINT32 maxId = MaxIntfId(intfIdCnt, intfIdVec);

    // brute force search of all possible positions from start
    for (int i = start - minId; i + maxId < slotCnt; i++)
    {
        // test this position - quick tests first, if these succeed, the full test
        if (slotVec[i + minId] == NULL &&
            slotVec[i + maxId] == NULL &&
            IntfVecFits(&slotVec[i], intfIdCnt, intfIdVec))
        {
            *result = i;
            return  true;
        }
    }

    return  false;
}


LPVOID *InterfaceVTableMapMgr::GetInterfaceVTableMap(const InterfaceInfo_t *pInterfaceInfo, const MethodTable *pMethodTableStart, DWORD numInterfaces)
{

    DWORD i;
    INT32 slot = 0;
    UINT32 intfIdVecBuf[32];
    UINT32 *intfIdVec;

    // protect ourselves against the pathological case
    if (numInterfaces <= 0)
        return NULL;

    // normally, the local buffer in the stack frame is big enough
    // if not, allocate a bigger one
    intfIdVec = intfIdVecBuf;
    if (sizeof(intfIdVecBuf)/sizeof(intfIdVecBuf[0]) < numInterfaces)
        intfIdVec = (UINT32 *)_alloca(numInterfaces*sizeof(*intfIdVec));

    // construct the vector of interface ids we need table slots for
    LOG((LF_CLASSLOADER, LL_INFO100, "Getting an interface map for following interface IDS\n"));
    for (i = 0; i < numInterfaces; i++)
    {
        intfIdVec[i] = pInterfaceInfo[i].m_pMethodTable->GetClass()->GetInterfaceId();
        LOG((LF_CLASSLOADER, LL_INFO100, "     IID 0x%x (interface %s)\n", intfIdVec[i], pInterfaceInfo[i].m_pMethodTable->GetClass()->m_szDebugClassName));
    }

    m_pInterfaceVTableMapMgrCrst->Enter();

    // check all the allocated maps for a slot we can use
    for (MapHeader *pMap = m_pFirstMap; pMap; pMap = pMap->m_pNext)
    {
        // update the first free slot of the map
        pMap->m_firstFreeSlot = FindFreeSlot(pMap->m_firstFreeSlot, pMap->m_numSlots, pMap->m_slotTab);

        // try to find a position that has NULL entries where we need them.
        if (FindFreeSlots(pMap->m_firstFreeSlot, pMap->m_numSlots, pMap->m_slotTab, numInterfaces, intfIdVec, &slot))
            break;
    }

    if (pMap == NULL)
    {
        // Need to allocate a new map.
        // We want it to be big enough for this class and a couple others like it,
        // and also it should have a certain minimum size to minimize external fragmentation.

        UINT32 minId = MinIntfId(numInterfaces, intfIdVec);
        UINT32 maxId = MaxIntfId(numInterfaces, intfIdVec);

        int numSlots = (maxId - minId + 1)*10;      // want to do at least 10 classes like this one

        if (numSlots < 1000)                         // allocate at least 1000 slots
            numSlots = 1000;

        pMap = (MapHeader *)(m_pInterfaceVTableMapHeap->AllocMem(sizeof(MapHeader) + numSlots*sizeof(pMap->m_slotTab[0])));
        if (pMap) {
            FillMemory(pMap->m_slotTab, numSlots*sizeof(pMap->m_slotTab[0]), 0);

            pMap->m_pNext         = m_pFirstMap;
            pMap->m_numSlots      = numSlots;
            pMap->m_firstFreeSlot = 0;

            m_pFirstMap = pMap;

            // we already know that FindFreeSlots succeeds in this case, and what it returns.
            slot = - (int)minId;

            // check that that's indeed the case.
            _ASSERTE(FindFreeSlots(0, pMap->m_numSlots, pMap->m_slotTab, numInterfaces, intfIdVec, &slot) &&
                     slot == - (int)minId);
        }
    }

    LPVOID  *result = NULL;

    if (pMap)
    {
        result = &pMap->m_slotTab[slot];

        for (i = 0; i < numInterfaces; i++)
        {
            UINT32 id = pInterfaceInfo[i].m_pMethodTable->GetClass()->GetInterfaceId();

            _ASSERTE(&result[id] >= &pMap->m_slotTab[0]
                     && &result[id] < &pMap->m_slotTab[pMap->m_numSlots]);
            result[id] = (LPVOID)( ( (LPVOID*) (((MethodTable*)pMethodTableStart)->GetDispatchVtableForInterface(pInterfaceInfo[i].m_pMethodTable)) ) );
        }
    }

    m_pInterfaceVTableMapMgrCrst->Leave();

    return  result;
}

Assembly* AppDomain::RaiseTypeResolveEvent(LPCSTR szName, OBJECTREF *pThrowable)
{
    Assembly* pAssembly = NULL;
    _ASSERTE(strcmp(szName, g_AppDomainClassName));

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        MethodDesc *OnTypeResolveEvent = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_TYPE_RESOLVE);
        struct _gc {
            OBJECTREF AppDomainRef;
            STRINGREF str;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        GCPROTECT_BEGIN(gc);
        if ((gc.AppDomainRef = GetRawExposedObject()) != NULL) {
            gc.str = COMString::NewString(szName);
            INT64 args[2] = {
                ObjToInt64(gc.AppDomainRef),
                ObjToInt64(gc.str)
            };
            ASSEMBLYREF ResultingAssemblyRef = (ASSEMBLYREF) Int64ToObj(OnTypeResolveEvent->Call(args, METHOD__APP_DOMAIN__ON_TYPE_RESOLVE));
            if (ResultingAssemblyRef != NULL)
                pAssembly = ResultingAssemblyRef->GetAssembly();
        }
            GCPROTECT_END();
    }
    COMPLUS_CATCH {
        if (pThrowable) *pThrowable = GETTHROWABLE();
    } COMPLUS_END_CATCH
            
    END_ENSURE_COOPERATIVE_GC();

    return pAssembly;
}

Assembly* AppDomain::RaiseResourceResolveEvent(LPCSTR szName, OBJECTREF *pThrowable)
{
    Assembly* pAssembly = NULL;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        MethodDesc *OnResourceResolveEvent = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_RESOURCE_RESOLVE);
        struct _gc {
            OBJECTREF AppDomainRef;
            STRINGREF str;
        } gc;
        ZeroMemory(&gc, sizeof(gc));
            
        GCPROTECT_BEGIN(gc);
        if ((gc.AppDomainRef = GetRawExposedObject()) != NULL) {
            gc.str = COMString::NewString(szName);
            INT64 args[2] = {
                ObjToInt64(gc.AppDomainRef),
                ObjToInt64(gc.str)
            };
            ASSEMBLYREF ResultingAssemblyRef = (ASSEMBLYREF) Int64ToObj(OnResourceResolveEvent->Call(args, METHOD__APP_DOMAIN__ON_RESOURCE_RESOLVE));
            if (ResultingAssemblyRef != NULL)
                pAssembly = ResultingAssemblyRef->GetAssembly();
        }
        GCPROTECT_END();
    }
    COMPLUS_CATCH {
        if (pThrowable) *pThrowable = GETTHROWABLE();
    } COMPLUS_END_CATCH
            
    END_ENSURE_COOPERATIVE_GC();

    return pAssembly;
}

Assembly* AppDomain::RaiseAssemblyResolveEvent(LPCWSTR wszName, OBJECTREF *pThrowable)
{
    Assembly* pAssembly = NULL;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        MethodDesc *OnAssemblyResolveEvent = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__ON_ASSEMBLY_RESOLVE);

        struct _gc {
            OBJECTREF AppDomainRef;
            STRINGREF str;
        } gc;
        ZeroMemory(&gc, sizeof(gc));
            
        GCPROTECT_BEGIN(gc);
        if ((gc.AppDomainRef = GetRawExposedObject()) != NULL) {
            gc.str = COMString::NewString(wszName);
            INT64 args[2] = {
                ObjToInt64(gc.AppDomainRef),
                ObjToInt64(gc.str)
            };
            ASSEMBLYREF ResultingAssemblyRef = (ASSEMBLYREF) Int64ToObj(OnAssemblyResolveEvent->Call(args, 
                                                                                                     METHOD__APP_DOMAIN__ON_ASSEMBLY_RESOLVE));
            if (ResultingAssemblyRef != NULL)
                pAssembly = ResultingAssemblyRef->GetAssembly();
        }
        GCPROTECT_END();
    }
    COMPLUS_CATCH {
        if (pThrowable) *pThrowable = GETTHROWABLE();
    } COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    return pAssembly;
}





MethodTable *        TheSByteClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pSByteClass = NULL;
    if (!g_pSByteClass)
    {
        g_pSByteClass = g_Mscorlib.FetchClass(CLASS__SBYTE);
    }
    return g_pSByteClass;
}


MethodTable *        TheInt16Class()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pInt16Class = NULL;
    if (!g_pInt16Class)
    {
        g_pInt16Class = g_Mscorlib.FetchClass(CLASS__INT16);
    }
    return g_pInt16Class;
}


MethodTable *        TheInt32Class()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pInt32Class = NULL;
    if (!g_pInt32Class)
    {
        g_pInt32Class = g_Mscorlib.FetchClass(CLASS__INT32);
    }
    return g_pInt32Class;
}


MethodTable *        TheByteClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pByteClass = NULL;
    if (!g_pByteClass)
    {
        g_pByteClass = g_Mscorlib.FetchClass(CLASS__BYTE);
    }
    return g_pByteClass;
}

MethodTable *        TheUInt16Class()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pUInt16Class = NULL;
    if (!g_pUInt16Class)
    {
        g_pUInt16Class = g_Mscorlib.FetchClass(CLASS__UINT16);
    }
    return g_pUInt16Class;
}


MethodTable *        TheUInt32Class()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pUInt32Class = NULL;
    if (!g_pUInt32Class)
    {
        g_pUInt32Class = g_Mscorlib.FetchClass(CLASS__UINT32);
    }
    return g_pUInt32Class;
}

MethodTable *        TheBooleanClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pBooleanClass = NULL;
    if (!g_pBooleanClass)
    {
        g_pBooleanClass = g_Mscorlib.FetchClass(CLASS__BOOLEAN);
    }
    return g_pBooleanClass;
}


MethodTable *        TheSingleClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pSingleClass = NULL;
    if (!g_pSingleClass)
    {
        g_pSingleClass = g_Mscorlib.FetchClass(CLASS__SINGLE);
    }
    return g_pSingleClass;
}

MethodTable *        TheDoubleClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pDoubleClass = NULL;
    if (!g_pDoubleClass)
    {
        g_pDoubleClass = g_Mscorlib.FetchClass(CLASS__DOUBLE);
    }
    return g_pDoubleClass;
}

MethodTable *        TheIntPtrClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pIntPtrClass = NULL;
    if (!g_pIntPtrClass)
    {
        g_pIntPtrClass = g_Mscorlib.FetchClass(CLASS__INTPTR);
    }
    return g_pIntPtrClass;
}


MethodTable *        TheUIntPtrClass()
{
    THROWSCOMPLUSEXCEPTION();
    static MethodTable *g_pUIntPtrClass = NULL;
    if (!g_pUIntPtrClass)
    {
        g_pUIntPtrClass = g_Mscorlib.FetchClass(CLASS__UINTPTR);
    }
    return g_pUIntPtrClass;
}


Module* AppDomain::LoadModuleIfSharedDependency(LPCBYTE pAssemblyBase,LPCBYTE pModuleBase)
{
    EnterLoadLock();
        if (m_sharedDependenciesMap.LookupValue((UPTR)pAssemblyBase, 
                                            NULL) == (LPVOID) INVALIDENTRY)
        {
            LeaveLoadLock();
            return NULL;
        }

        Assembly *pAssembly=NULL;

        if(SharedDomain::GetDomain()->FindShareableAssembly((LPBYTE)pAssemblyBase, &pAssembly)!=S_OK)
        {
            LeaveLoadLock();
            return NULL;
        }
    LeaveLoadLock();

    PEFile* pefile=NULL;
    if (FAILED(PEFile::Clone(pAssembly->GetManifestFile(),&pefile)))
        return NULL;
    Assembly* pLoadedAssembly; 
    if (FAILED(LoadAssembly(pefile,pAssembly->GetFusionAssembly(),NULL,&pLoadedAssembly,NULL,FALSE,NULL)))
        return NULL;
    _ASSERTE(pLoadedAssembly==pAssembly);

    EnterLoadLock();
    Module* pRet=pAssembly->FindModule(LPBYTE(pModuleBase)); 
    LeaveLoadLock();
    return pRet;
};


// This should only be called for the default domain.
HRESULT AppDomain::SetDefaultActivationContext(Frame* pFrame)
{
    // which can force a load to happen. 
    HRESULT hr = S_OK;
    
    HANDLE hActCtx = NULL;
    HANDLE hBaseCtx = NULL;
    DWORD nCount = 0;

    if(m_pFusionContext != NULL) {

        ACTIVATION_CONTEXT_BASIC_INFORMATION  sBasic;
        ACTIVATION_CONTEXT_BASIC_INFORMATION* pBasic = &sBasic;
        ZeroMemory(pBasic, sizeof(sBasic));
        nCount = sizeof(sBasic);
        
        // first get the process activation context by getting the
        // basic information for the NULL context.
        if(!WszQueryActCtxW(0, hActCtx, NULL, 
                            ActivationContextBasicInformation,
                            pBasic, nCount,
                            &nCount)) 
        {
            if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) 
            {
                pBasic = (ACTIVATION_CONTEXT_BASIC_INFORMATION*) alloca(nCount);
                if(!WszQueryActCtxW(0, hActCtx, NULL, 
                                    ActivationContextBasicInformation,
                                    pBasic, nCount,
                                    &nCount)) 
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
                
            
            // If we fail because the entry point is not there then
            // return.
            if(hr == HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND) ||      // win2k
               hr == HRESULT_FROM_WIN32(ERROR_ENVVAR_NOT_FOUND) ||    // winNT
               hr == HRESULT_FROM_WIN32(ERROR_CALL_NOT_IMPLEMENTED )) // win98
                return S_OK;
        }
        

        if(SUCCEEDED(hr) && pBasic->hActCtx) {
            IApplicationContext* context = GetFusionContext();
            if(context) {
                hr = context->Set(ACTAG_SXS_ACTIVATION_CONTEXT,
                                  pBasic->hActCtx,
                                  sizeof(HANDLE),
                                  0);
                
                if(SUCCEEDED(hr)) {
                    ULONG_PTR cookie;
                    hr = context->SxsActivateContext(&cookie);
                    if(SUCCEEDED(hr)) {
                        pFrame->SetWin32Context(cookie);
                    }
                }
            }
            else
                WszReleaseActCtx(pBasic->hActCtx);
        }



    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomainhelper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _APPDOMAIN_HELPER_H_
#define _APPDOMAIN_HELPER_H_

// Marshal a single object into a serialized blob.
//
//

// @TODO: Sort out CRT vs. Win32 heap story.  This macro shouldn't be necessary.
#include "CorPermE.h"

class AppDomainHelper {

    friend class MarshalCache;

    // A pair of helper to move serialization info between managed byte-array and
    // unmanaged blob.
    static void AppDomainHelper::CopyEncodingToByteArray(IN PBYTE   pbData, 
                                                         IN DWORD   cbData, 
                                                         OUT OBJECTREF* pArray);

    static void AppDomainHelper::CopyByteArrayToEncoding(IN U1ARRAYREF* pArray,
                                                         OUT PBYTE*   ppbData,
                                                         OUT DWORD*   pcbData);

public:
    // Marshal a single object into a serialized blob.
    static void AppDomainHelper::MarshalObject(IN AppDomain *pDomain,
                                               IN OBJECTREF  *orObject,
                                               OUT U1ARRAYREF *porBlob);

    // Marshal one object into a seraialized blob.
    static void AppDomainHelper::MarshalObject(IN AppDomain *pDomain,
                                               IN OBJECTREF  *orObject,
                                               OUT BYTE    **ppbBlob,
                                               OUT DWORD    *pcbBlob);

    // Marshal two objects into serialized blobs.
    static void AppDomainHelper::MarshalObjects(IN AppDomain *pDomain,
                                                IN OBJECTREF  *orObject1,
                                                IN OBJECTREF  *orObject2,
                                                OUT BYTE    **ppbBlob1,
                                                OUT DWORD    *pcbBlob1,
                                                OUT BYTE    **ppbBlob2,
                                                OUT DWORD    *pcbBlob2);

    // Unmarshal a single object from a serialized blob.
    static void AppDomainHelper::UnmarshalObject(IN AppDomain   *pDomain,
                                                 IN U1ARRAYREF  *porBlob,
                                                 OUT OBJECTREF  *porObject);

    // Unmarshal a single object from a serialized blob.
    static void AppDomainHelper::UnmarshalObject(IN AppDomain   *pDomain,
                                                 IN BYTE        *pbBlob,
                                                 IN DWORD        cbBlob,
                                                 OUT OBJECTREF  *porObject);

    // Unmarshal two objects from serialized blobs.
    static void AppDomainHelper::UnmarshalObjects(IN AppDomain   *pDomain,
                                                  IN BYTE        *pbBlob1,
                                                  IN DWORD        cbBlob1,
                                                  IN BYTE        *pbBlob2,
                                                  IN DWORD        cbBlob2,
                                                  OUT OBJECTREF  *porObject1,
                                                  OUT OBJECTREF  *porObject2);

    // Copy an object from the given appdomain into the current appdomain.
    static OBJECTREF AppDomainHelper::CrossContextCopyFrom(IN AppDomain *pAppDomain,
                                                           IN OBJECTREF *orObject);
    // Copy an object to the given appdomain from the current appdomain.
    static OBJECTREF AppDomainHelper::CrossContextCopyTo(IN AppDomain *pAppDomain,
                                                         IN OBJECTREF  *orObject);
    // Copy an object from the given appdomain into the current appdomain.
    static OBJECTREF AppDomainHelper::CrossContextCopyFrom(IN DWORD dwDomainId,
                                                           IN OBJECTREF *orObject);
    // Copy an object to the given appdomain from the current appdomain.
    static OBJECTREF AppDomainHelper::CrossContextCopyTo(IN DWORD dwDomainId,
                                                         IN OBJECTREF  *orObject);

};

// Cache the bits needed to serialize/deserialize managed objects that will be
// passed across appdomain boundaries during a stackwalk. The serialization is
// performed lazily the first time it's needed and remains valid throughout the
// stackwalk. The last deserialized object is cached and tagged with its
// appdomain context. It's valid as long as we're walking frames within the same
// appdomain.
//
class MarshalCache
{
public:
    MarshalCache()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~MarshalCache()
    {
        if (m_pbObj1)
            FreeM(m_pbObj1);
        if (m_pbObj2)
            FreeM(m_pbObj2);
    }

    // Set the original value of the first cached object.
    void SetObject(OBJECTREF orObject)
    {
        m_pOriginalDomain = GetAppDomain();
        m_sGC.m_orInput1 = orObject;
    }

    // Set the original values of both cached objects.
    void SetObjects(OBJECTREF orObject1, OBJECTREF orObject2)
    {
        m_pOriginalDomain = GetAppDomain();
        m_sGC.m_orInput1 = orObject1;
        m_sGC.m_orInput2 = orObject2;
    }

    // Get a copy of the first object suitable for use in the given appdomain.
    OBJECTREF GetObject(AppDomain *pDomain)
    {
        THROWSCOMPLUSEXCEPTION();

        // No transition -- just return original object.
        if (pDomain == m_pOriginalDomain) {
            if (m_fObjectUpdated)
                UpdateObjectFinish();
            return m_sGC.m_orInput1;
        }

        // We've already deserialized the object into the correct context.
        if (pDomain == m_pCachedDomain)
            return m_sGC.m_orOutput1;

        // If we've updated the object in a different appdomain from the one we
        // originally started in, the cached object will be more up to date than
        // the original. Resync the objects.
        if (m_fObjectUpdated)
            UpdateObjectFinish();

        // Check whether we've serialized the original input object yet.
        if (m_pbObj1 == NULL)
            AppDomainHelper::MarshalObject(m_pOriginalDomain,
                                          &m_sGC.m_orInput1,
                                          &m_pbObj1,
                                          &m_cbObj1);

        // Deserialize into the correct context.
        AppDomainHelper::UnmarshalObject(pDomain,
                                        m_pbObj1,
                                        m_cbObj1,
                                        &m_sGC.m_orOutput1);
        m_pCachedDomain = pDomain;

        return m_sGC.m_orOutput1;
    }

    // As above, but retrieve both objects.
    OBJECTREF GetObjects(AppDomain *pDomain, OBJECTREF *porObject2)
    {
        THROWSCOMPLUSEXCEPTION();

        // No transition -- just return original objects.
        if (pDomain == m_pOriginalDomain) {
            if (m_fObjectUpdated)
                UpdateObjectFinish();
            *porObject2 = m_sGC.m_orInput2;
            return m_sGC.m_orInput1;
        }

        // We've already deserialized the objects into the correct context.
        if (pDomain == m_pCachedDomain) {
            *porObject2 = m_sGC.m_orOutput2;
            return m_sGC.m_orOutput1;
        }

        // If we've updated the object in a different appdomain from the one we
        // originally started in, the cached object will be more up to date than
        // the original. Resync the objects.
        if (m_fObjectUpdated)
            UpdateObjectFinish();

        // Check whether we've serialized the original input objects yet.
        if (m_pbObj1 == NULL)
            AppDomainHelper::MarshalObjects(m_pOriginalDomain,
                                           &m_sGC.m_orInput1,
                                           &m_sGC.m_orInput2,
                                           &m_pbObj1,
                                           &m_cbObj1,
                                           &m_pbObj2,
                                           &m_cbObj2);

        // Deserialize into the correct context.
        AppDomainHelper::UnmarshalObjects(pDomain,
                                          m_pbObj1,
                                          m_cbObj1,
                                          m_pbObj2,
                                          m_cbObj2,
                                          &m_sGC.m_orOutput1,
                                          &m_sGC.m_orOutput2);
        m_pCachedDomain = pDomain;

        *porObject2 = m_sGC.m_orOutput2;
        return m_sGC.m_orOutput1;
    }

    // Change the first object (updating the cacheing information
    // appropriately).
    void UpdateObject(AppDomain *pDomain, OBJECTREF orObject)
    {
        // The cached serialized blob is now useless.
        if (m_pbObj1)
            FreeM(m_pbObj1);
        m_pbObj1 = NULL;
        m_cbObj1 = 0;

        // The object we have now is valid in it's own appdomain, so place that
        // in the object cache.
        m_pCachedDomain = pDomain;
        m_sGC.m_orOutput1 = orObject;

        // If the object is updated in the original context, just use the new
        // value as is. In this case we have the data to re-marshal the updated
        // object as normal, so we can consider the cache fully updated and exit
        // now.
        if (pDomain == m_pOriginalDomain) {
            m_sGC.m_orInput1 = orObject;
            m_fObjectUpdated = false;
            return;
        }

        // We want to avoid re-marshaling the updated value as long as possible
        // (it might be updated again before we need its value in a different
        // context). So set a flag to indicate that the object must be
        // re-marshaled when the value is queried in a new context.
        m_fObjectUpdated = true;
    }

    // This structure is public only so that it can be GC protected. Do not
    // access the fields directly, they change in an unpredictable fashion due
    // to the lazy cacheing algorithm.
    struct _gc {
        OBJECTREF   m_orInput1;
        OBJECTREF   m_orInput2;
        OBJECTREF   m_orOutput1;
        OBJECTREF   m_orOutput2;
    }           m_sGC;

private:

    // Called after one or more calls to UpdateObject to marshal the updated
    // object back into its original context (it's assumed we're called in this
    // context).
    void UpdateObjectFinish()
    {
        _ASSERTE(m_fObjectUpdated && m_pbObj1 == NULL);
        AppDomainHelper::MarshalObject(m_pCachedDomain,
                                      &m_sGC.m_orOutput1,
                                      &m_pbObj1,
                                      &m_cbObj1);
        AppDomainHelper::UnmarshalObject(m_pOriginalDomain,
                                        m_pbObj1,
                                        m_cbObj1,
                                        &m_sGC.m_orInput1);
        m_fObjectUpdated = false;
    }

    BYTE       *m_pbObj1;
    DWORD       m_cbObj1;
    BYTE       *m_pbObj2;
    DWORD       m_cbObj2;
    AppDomain  *m_pCachedDomain;
    AppDomain  *m_pOriginalDomain;
    bool        m_fObjectUpdated;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomainnative.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AppDomainNative.hpp
**
** Purpose: Implements native methods for AppDomains
**
** Date:  May 20, 2000
**
===========================================================*/
#ifndef _APPDOMAINNATIVE_H
#define _APPDOMAINNATIVE_H

class AppDomainNative
{
    struct CreateBasicDomainArgs
    {
    };

    struct SetupDomainSecurityArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(void*, parentSecurityDescriptor);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, creatorsEvidence);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, providedEvidence);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, strFriendlyName);
    };

    struct UpdateContextPropertyArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, value);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, key);
        DECLARE_ECALL_PTR_ARG(LPVOID, fusionContext);
    };

    struct UpdateLoaderOptimizationArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
        DECLARE_ECALL_I4_ARG(DWORD, optimization); 
    };

    
    struct ExecuteAssemblyArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(PTRARRAYREF, stringArgs);
        DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, assemblyName);
    };

    struct UnloadArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(THREADBASEREF, requestingThread);
        DECLARE_ECALL_OBJECTREF_ARG(INT32, dwId);
    };

    struct IsDomainIdValidArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(INT32, dwId);
    };

    struct ForcePolicyResolutionArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
    };

    struct GetIdArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
    };

    struct GetIdForUnloadArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refDomain);
    };

    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
    };

    struct StringInternArgs {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF, refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, pString);
    };

    struct ForceToSharedDomainArgs {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, pObject);
    };

    struct GetGrantSetArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF,  refThis);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*,       ppDenied);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*,       ppGranted);
    };

    struct TypeArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(APPDOMAINREF,  refThis);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTCLASSBASEREF,  type);
    };

public:
    static AppDomain *ValidateArg(APPDOMAINREF pThis);

    static LPVOID __stdcall CreateBasicDomain(CreateBasicDomainArgs *args);
    static void   __stdcall SetupDomainSecurity(SetupDomainSecurityArgs *args);
    static LPVOID __stdcall GetFusionContext(NoArgs *args);
    static LPVOID __stdcall GetSecurityDescriptor(NoArgs *args);
    static void   __stdcall UpdateContextProperty(UpdateContextPropertyArgs* args);
    static void   __stdcall UpdateLoaderOptimization(UpdateLoaderOptimizationArgs* args);
    static LPVOID __stdcall CreateDynamicAssembly(CreateDynamicAssemblyArgs *args);
    static LPVOID __stdcall GetFriendlyName(NoArgs *args);
    static LPVOID __stdcall GetAssemblies(NoArgs *args); 
    static LPVOID __stdcall GetOrInternString(StringInternArgs *args);
    static LPVOID __stdcall IsStringInterned(StringInternArgs *args);
    static INT32  __stdcall ExecuteAssembly(ExecuteAssemblyArgs *args);
    static void   __stdcall Unload(UnloadArgs *args);
    static void   __stdcall ForcePolicyResolution(ForcePolicyResolutionArgs *args);
    static void   __stdcall AddAppBase(NoArgs *args);
    static LPVOID __stdcall GetDynamicDir(NoArgs *args);
    static LPVOID __stdcall GetDefaultDomain(LPVOID noarg);
    static INT32  __stdcall GetId(GetIdArgs *args);
    static INT32  __stdcall GetIdForUnload(GetIdForUnloadArgs *args);
    static INT32  __stdcall IsDomainIdValid(IsDomainIdValidArgs *args);
    static LPVOID __stdcall GetUnloadWorker(NoArgs *args);
    static INT32  __stdcall IsUnloadingForcedFinalize(NoArgs *args);
    static INT32  __stdcall IsFinalizingForUnload(NoArgs *args);
    static void   __stdcall ForceResolve(NoArgs *args);
    static void   __stdcall ForceToSharedDomain(ForceToSharedDomainArgs *args);
    static INT32  __stdcall IsTypeUnloading(TypeArgs *args);
    static void   __stdcall GetGrantSet(GetGrantSetArgs *args);    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomainnative.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
#include "AppDomain.hpp"
#include "AppDomainNative.hpp"
#include "Remoting.h"
#include "COMString.h"
#include "Security.h"
#include "eeconfig.h"
#include "comsystem.h"
#include "AppDomainHelper.h"

//************************************************************************
inline AppDomain *AppDomainNative::ValidateArg(APPDOMAINREF pThis)
{
    THROWSCOMPLUSEXCEPTION();
    if (pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Should not get here with a Transparent proxy for the this pointer -
    // should have always called through onto the real object
    _ASSERTE(! CRemotingServices::IsTransparentProxy(OBJECTREFToObject(pThis)));

    AppDomain* pDomain = (AppDomain*)pThis->GetDomain();

    if(!pDomain)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // should not get here with an invalid appdomain. Once unload it, we won't let anyone else
    // in and any threads that are already in will be unwound.
    _ASSERTE(SystemDomain::GetAppDomainAtIndex(pDomain->GetIndex()) != NULL);
    return pDomain;
}

//************************************************************************
LPVOID __stdcall AppDomainNative::CreateBasicDomain(CreateBasicDomainArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    CHECKGC();
    // Create the domain adding the appropriate arguments

    LPVOID rv = NULL;
    AppDomain *pDomain = NULL;

    // @TODO: Have we taken a lock before calling this?
    HRESULT hr = SystemDomain::NewDomain(&pDomain);
    if (FAILED(hr)) 
        COMPlusThrowHR(hr);

#ifdef DEBUGGING_SUPPORTED    
    // Notify the debugger here, before the thread transitions into the 
    // AD to finish the setup.  If we don't, stepping won't work right (RAID 67173)
    SystemDomain::PublishAppDomainAndInformDebugger(pDomain);
#endif // DEBUGGING_SUPPORTED

    *((OBJECTREF *)&rv) = pDomain->GetAppDomainProxy();
    return rv;
}

void __stdcall AppDomainNative::SetupDomainSecurity(SetupDomainSecurityArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    CHECKGC();
    // Load the class from this module (fail if it is in a different one).
    AppDomain* pDomain = ValidateArg(args->refThis);
    
    // Set up Security
    ApplicationSecurityDescriptor *pCreatorSecDesc = (ApplicationSecurityDescriptor*)args->parentSecurityDescriptor;
    
    // If the AppDomain that created this one is a default appdomain and
    // no evidence is provided, then this new AppDomain is also a default appdomain.
    // If there is no provided evidence but the creator is not a default appdomain,
    // then this new appdomain just gets the same evidence as the creator.
    // If evidence is provided, the new appdomain is not a default appdomain and
    // we simply use the provided evidence.
    
    BOOL resolveRequired = FALSE;
    OBJECTREF orEvidence = NULL;
    GCPROTECT_BEGIN(orEvidence);
    if (args->providedEvidence == NULL) {
        if (pCreatorSecDesc->GetProperties(CORSEC_DEFAULT_APPDOMAIN) != 0)
            pDomain->GetSecurityDescriptor()->SetDefaultAppDomainProperty();
        orEvidence = args->creatorsEvidence;
    }
    else {
        if (Security::IsExecutionPermissionCheckEnabled())
            resolveRequired = TRUE;
        orEvidence = args->providedEvidence;
    }
    
    pDomain->GetSecurityDescriptor()->SetEvidence( orEvidence );
    GCPROTECT_END();

    // If the user created this domain, need to know this so the debugger doesn't
    // go and reset the friendly name that was provided.
    pDomain->SetIsUserCreatedDomain();
    
    WCHAR* pFriendlyName = NULL;
    Thread *pThread = GetThread();

    void* checkPointMarker = pThread->m_MarshalAlloc.GetCheckpoint();
    if (args->strFriendlyName != NULL) {
        WCHAR* pString = NULL;
        int    iString;
        RefInterpretGetStringValuesDangerousForGC(args->strFriendlyName, &pString, &iString);
        pFriendlyName = (WCHAR*) pThread->m_MarshalAlloc.Alloc((++iString) * sizeof(WCHAR));

        // Check for a valid string allocation
        if (pFriendlyName == (WCHAR*)-1)
           pFriendlyName = NULL;
        else
           memcpy(pFriendlyName, pString, iString*sizeof(WCHAR));
    }
    
    if (resolveRequired)
        pDomain->GetSecurityDescriptor()->Resolve();

    // once domain is loaded it is publically available so if you have anything 
    // that a list interrogator might need access to if it gets a hold of the
    // appdomain, then do it above the LoadDomain.
    HRESULT hr = SystemDomain::LoadDomain(pDomain, pFriendlyName);

#ifdef PROFILING_SUPPORTED
    // Need the first assembly loaded in to get any data on an app domain.
    if (CORProfilerTrackAppDomainLoads())
        g_profControlBlock.pProfInterface->AppDomainCreationFinished((ThreadID) GetThread(), (AppDomainID) pDomain, hr);
#endif // PROFILING_SUPPORTED

    // We held on to a reference until we were added to the list (see CreateBasicDomain)
    // Once in the list we can safely release this reference.
    pDomain->Release();

    pThread->m_MarshalAlloc.Collapse(checkPointMarker);
    
    if (FAILED(hr)) {
        pDomain->Release();
        if (hr == E_FAIL)
            hr = MSEE_E_CANNOTCREATEAPPDOMAIN;
        COMPlusThrowHR(hr);
    }

#ifdef _DEBUG
    LOG((LF_APPDOMAIN, LL_INFO100, "AppDomainNative::CreateDomain domain [%d] %8.8x %S\n", pDomain->GetIndex(), pDomain, pDomain->GetFriendlyName()));
#endif
}

LPVOID __stdcall AppDomainNative::GetFusionContext(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    CHECKGC();
    LPVOID rv = NULL;
    HRESULT hr;

    AppDomain* pApp = ValidateArg(args->refThis);

    IApplicationContext* pContext;
    if(SUCCEEDED(hr = pApp->CreateFusionContext(&pContext)))
        rv = pContext;
    else
        COMPlusThrowHR(hr);

    return rv;
}

LPVOID __stdcall AppDomainNative::GetSecurityDescriptor(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    CHECKGC();
    return ValidateArg(args->refThis)->GetSecurityDescriptor();
}


void __stdcall AppDomainNative::UpdateLoaderOptimization(UpdateLoaderOptimizationArgs* args)
{
    THROWSCOMPLUSEXCEPTION();
    CHECKGC();

    ValidateArg(args->refThis)->SetSharePolicy((BaseDomain::SharePolicy) args->optimization);
}


void __stdcall AppDomainNative::UpdateContextProperty(UpdateContextPropertyArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    if(args->key != NULL) {
        IApplicationContext* pContext = (IApplicationContext*) args->fusionContext;
        CQuickBytes qb;

        DWORD lgth = args->key->GetStringLength();
        LPWSTR key = (LPWSTR) qb.Alloc((lgth+1)*sizeof(WCHAR));
        memcpy(key, args->key->GetBuffer(), lgth*sizeof(WCHAR));
        key[lgth] = L'\0';
        
        AppDomain::SetContextProperty(pContext, key, (OBJECTREF*) &(args->value));
    }
}

INT32 __stdcall AppDomainNative::ExecuteAssembly(ExecuteAssemblyArgs *args)
{
    CHECKGC();
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pDomain = ValidateArg(args->refThis);

    if (!args->assemblyName)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Generic");

    Assembly* pAssembly = (Assembly*) args->assemblyName->GetAssembly();

    if((BaseDomain*) pDomain == SystemDomain::System()) 
        COMPlusThrow(kUnauthorizedAccessException, L"UnauthorizedAccess_SystemDomain");

    if (!pDomain->m_pRootFile)
        pDomain->m_pRootFile = pAssembly->GetSecurityModule()->GetPEFile();

    ///
    BOOL bCreatedConsole=FALSE;
    if (pAssembly->GetManifestFile()->GetNTHeader()->OptionalHeader.Subsystem==IMAGE_SUBSYSTEM_WINDOWS_CUI)
    {
        bCreatedConsole=AllocConsole();
        LPWSTR wszCodebase;
        DWORD  dwCodebase;
        if (SUCCEEDED(pAssembly->GetCodeBase(&wszCodebase,&dwCodebase)))
            SetConsoleTitle(wszCodebase);
    }


    HRESULT hr = pAssembly->ExecuteMainMethod(&args->stringArgs);
    if(FAILED(hr)) 
        COMPlusThrowHR(hr);

    if(bCreatedConsole)
        FreeConsole();
    return GetLatchedExitCode ();
}


LPVOID __stdcall AppDomainNative::CreateDynamicAssembly(CreateDynamicAssemblyArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly*       pAssem;
    ASSEMBLYREF*    rv;

    AppDomain* pAppDomain = ValidateArg(args->refThis);

    if((BaseDomain*) pAppDomain == SystemDomain::System()) 
        COMPlusThrow(kUnauthorizedAccessException, L"UnauthorizedAccess_SystemDomain");

    HRESULT hr = pAppDomain->CreateDynamicAssembly(args, &pAssem);
    if (FAILED(hr))
        COMPlusThrowHR(hr);

    pAppDomain->AddAssembly(pAssem);
    *((ASSEMBLYREF*) &rv) = (ASSEMBLYREF) pAssem->GetExposedObject();

    return rv;
}



LPVOID __stdcall AppDomainNative::GetFriendlyName(NoArgs *args)
{
    LPVOID rv;
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pApp = ValidateArg(args->refThis);

    STRINGREF str = NULL;
    LPCWSTR wstr = pApp->GetFriendlyName();
    if (wstr)
        str = COMString::NewString(wstr);   

    *((STRINGREF*) &rv) = str;
    return rv;
}


LPVOID __stdcall AppDomainNative::GetAssemblies(NoArgs *args)
{
    CHECKGC();
    LPVOID rv;
    size_t numSystemAssemblies;
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pAssemblyClass = g_Mscorlib.GetClass(CLASS__ASSEMBLY);

    AppDomain* pApp = ValidateArg(args->refThis);
    _ASSERTE(SystemDomain::System()->GetSharePolicy() == BaseDomain::SHARE_POLICY_ALWAYS);

    BOOL fNotSystemDomain = ( (AppDomain*) SystemDomain::System() != pApp );
    PTRARRAYREF AsmArray = NULL;
    GCPROTECT_BEGIN(AsmArray);

    if (fNotSystemDomain) {
        SystemDomain::System()->EnterLoadLock();
        numSystemAssemblies = SystemDomain::System()->m_Assemblies.GetCount();
    }
    else
        numSystemAssemblies = 0;

    pApp->EnterLoadLock();

    AsmArray = (PTRARRAYREF) AllocateObjectArray((DWORD) (numSystemAssemblies +
                                                 pApp->m_Assemblies.GetCount()),
                                                 pAssemblyClass);
    if (!AsmArray) {
        pApp->LeaveLoadLock();
        if (fNotSystemDomain)
            SystemDomain::System()->LeaveLoadLock();
        COMPlusThrowOM();
    }

    if (fNotSystemDomain) {
        AppDomain::AssemblyIterator systemIterator = SystemDomain::System()->IterateAssemblies();
        while (systemIterator.Next()) {
            // Do not change this code.  This is done this way to
            //  prevent a GC hole in the SetObjectReference() call.  The compiler
            //  is free to pick the order of evaluation.
            OBJECTREF o = (OBJECTREF) systemIterator.GetAssembly()->GetExposedObject();
            AsmArray->SetAt(systemIterator.GetIndex(), o);
        }
    }

    AppDomain::AssemblyIterator i = pApp->IterateAssemblies();
    while (i.Next()) {
        // Do not change this code.  This is done this way to
        //  prevent a GC hole in the SetObjectReference() call.  The compiler
        //  is free to pick the order of evaluation.
        OBJECTREF o = (OBJECTREF) i.GetAssembly()->GetExposedObject();
        AsmArray->SetAt(numSystemAssemblies++, o);
    }

    pApp->LeaveLoadLock();
    if (fNotSystemDomain)
        SystemDomain::System()->LeaveLoadLock();

    *((PTRARRAYREF*) &rv) = AsmArray;
    GCPROTECT_END();

    return rv;
}

void __stdcall AppDomainNative::Unload(UnloadArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    AppDomain *pApp = SystemDomain::System()->GetAppDomainAtId(args->dwId);

    _ASSERTE(pApp); // The call to GetIdForUnload should ensure we have a valid domain
    
    Thread *pRequestingThread = NULL;
    if (args->requestingThread != NULL)
        pRequestingThread = args->requestingThread->GetInternal();

    pApp->Unload(FALSE, pRequestingThread);
}

INT32 __stdcall AppDomainNative::IsDomainIdValid(IsDomainIdValidArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    // NOTE: This assumes that appDomain IDs are not recycled post unload
    // thus relying on GetAppDomainAtId to return NULL if the appDomain
    // got unloaded or the id is bogus.
    return (SystemDomain::System()->GetAppDomainAtId(args->dwId) != NULL);
}

LPVOID AppDomainNative::GetDefaultDomain(LPVOID noargs)
{
    THROWSCOMPLUSEXCEPTION();
    LPVOID rv;
    if (GetThread()->GetDomain() == SystemDomain::System()->DefaultDomain())
        *((APPDOMAINREF *)&rv) = (APPDOMAINREF) SystemDomain::System()->DefaultDomain()->GetExposedObject();
    else
        *((APPDOMAINREF *)&rv) = (APPDOMAINREF) SystemDomain::System()->DefaultDomain()->GetAppDomainProxy();
    return rv;
}

INT32 __stdcall AppDomainNative::GetId(GetIdArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    AppDomain* pApp = ValidateArg(args->refThis);
    // can only be accessed from within current domain
    _ASSERTE(GetThread()->GetDomain() == pApp);

    return pApp->GetId();
}

INT32 __stdcall AppDomainNative::GetIdForUnload(GetIdForUnloadArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain *pDomain = NULL;

    if (args->refDomain == NULL)
       COMPlusThrow(kArgumentNullException, L"ArgumentNull_Obj");

    if (! args->refDomain->GetMethodTable()->IsTransparentProxyType()) {
        pDomain = (AppDomain*)(args->refDomain->GetDomain());

        if (!pDomain)
            COMPlusThrow(kNullReferenceException, L"NullReference");
    } 
    else {
        // so this is an proxy type, now get it's underlying appdomain which will be null if non-local
        Context *pContext = CRemotingServices::GetServerContextForProxy((OBJECTREF)args->refDomain);
        if (pContext)
            pDomain = pContext->GetDomain();
        else
            COMPlusThrow(kCannotUnloadAppDomainException, IDS_EE_ADUNLOAD_NOT_LOCAL);
    }

    _ASSERTE(pDomain);

    if (! pDomain->IsOpen() || pDomain->GetId() == 0)
        COMPlusThrow(kAppDomainUnloadedException);

    return pDomain->GetId();
}

LPVOID __stdcall AppDomainNative::GetUnloadWorker(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(GetThread()->GetDomain() == SystemDomain::System()->DefaultDomain());
    return (OBJECTREFToObject(SystemDomain::System()->DefaultDomain()->GetUnloadWorker()));
}

void __stdcall AppDomainNative::ForcePolicyResolution(ForcePolicyResolutionArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    AppDomain* pApp = ValidateArg(args->refThis);

    // Force a security policy resolution on each assembly currently loaded into
    // the domain.
    AppDomain::AssemblyIterator i = pApp->IterateAssemblies();
    while (i.Next())
        i.GetAssembly()->GetSecurityDescriptor(pApp)->Resolve();
}


LPVOID __stdcall AppDomainNative::IsStringInterned(StringInternArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    AppDomain* pApp = ValidateArg(args->refThis);

    if (args->pString == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
    
    STRINGREF *stringVal = args->refThis->GetDomain()->IsStringInterned(&args->pString);

    if (stringVal == NULL)
        return NULL;

    RETURN(*stringVal, STRINGREF);

}

LPVOID __stdcall AppDomainNative::GetOrInternString(StringInternArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    AppDomain* pApp = ValidateArg(args->refThis);

    if (args->pString == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");

    STRINGREF *stringVal = args->refThis->GetDomain()->GetOrInternString(&args->pString);
    if (stringVal == NULL)
        return NULL;

    RETURN(*stringVal, STRINGREF);
}


LPVOID __stdcall AppDomainNative::GetDynamicDir(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    LPVOID rv = NULL;
    AppDomain *pDomain = ValidateArg(args->refThis);

    HRESULT hr;
    LPWSTR pDynamicDir;
    if (SUCCEEDED(hr = pDomain->GetDynamicDir(&pDynamicDir))) {
        STRINGREF str = COMString::NewString(pDynamicDir);
        *((STRINGREF*) &rv) = str;
    }
    // return NULL when the dyn dir wasn't set
    else if (hr != HRESULT_FROM_WIN32(ERROR_NOT_FOUND))
        COMPlusThrowHR(hr);

    return rv;
}

void __stdcall AppDomainNative::ForceResolve(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pAppDomain = ValidateArg(args->refThis);
  
    // We get the evidence so that even if security is off
    // we generate the evidence properly.
    Security::InitSecurity();
    pAppDomain->GetSecurityDescriptor()->GetEvidence();
}

void __stdcall AppDomainNative::GetGrantSet(GetGrantSetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pAppDomain = ValidateArg(args->refThis);    
    ApplicationSecurityDescriptor *pSecDesc = pAppDomain->GetSecurityDescriptor();
    pSecDesc->Resolve();
    OBJECTREF granted = pSecDesc->GetGrantedPermissionSet(args->ppDenied);
    *(args->ppGranted) = granted;
}


INT32 __stdcall AppDomainNative::IsTypeUnloading(TypeArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pApp = ValidateArg(args->refThis);
    MethodTable *pMT = args->type->GetMethodTable();

    return (!pMT->IsShared()) && (pMT->GetDomain() == pApp);
}
    
INT32 __stdcall AppDomainNative::IsUnloadingForcedFinalize(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pApp = ValidateArg(args->refThis);

    return pApp->IsFinalized();
}

INT32 __stdcall AppDomainNative::IsFinalizingForUnload(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain* pApp = ValidateArg(args->refThis);

    return pApp->IsFinalizing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\array.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// File: ARRAY.CPP
//
// File which contains a bunch of of array related things.
//
#include "common.h"

#include "clsload.hpp"
#include "method.hpp"
#include "class.h"
#include "object.h"
#include "field.h"
#include "util.hpp"
#include "excep.h"
#include "siginfo.hpp"
#include "threads.h"
#include "stublink.h"
#include "ecall.h"
#include "COMPlusWrapper.h"
#include "ComClass.h"
#include "ndirect.h"
#include "gcdesc.h"
#include "JITInterface.h"
#include "ComCallWrapper.h"
#include "EEConfig.h"
#include "log.h"
#include "nstruct.h"
#include "cgensys.h"
#include "compluscall.h"
#include "array.h"
#include "wsperf.h"
#include "ecall.h"
#include "icecap.h"

#define MAX_SIZE_FOR_VALUECLASS_IN_ARRAY 0xffff
#define MAX_PTRS_FOR_VALUECLASSS_IN_ARRAY 0xffff

// GetElement, SetElement, SetElementAddress, <init2>
#define ARRAYCLASS_GET "Get"
#define ARRAYCLASS_SET "Set"
#define ARRAYCLASS_ADDRESS "Address"
#define ARRAYCLASS_GETAT "GetAt"
#define ARRAYCLASS_SETAT "SetAt"
#define ARRAYCLASS_ADDRESSAT "AddressAt"
#define ARRAYCLASS_INIT COR_CTOR_METHOD_NAME    // ".ctor"

// The VTABLE for an array look like

//  System.Object Vtable
//  System.Array Vtable
//  Type[] Vtable 
//      Get(<rank specific)
//      Set(<rank specific)
//      Address(<rank specific)
//      .ctor(int)      // Possibly more


////////////////////////////////////////////////////////////////////////////
//
// System/Array class methods
//
////////////////////////////////////////////////////////////////////////////
FCIMPL1(INT32, Array_Rank, ArrayBase* array)
    VALIDATEOBJECTREF(array);

    if (array == NULL)
        FCThrow(kNullReferenceException);

    return array->GetRank();
FCIMPLEND

FCIMPL1(void, Array_Initialize, ArrayBase* array) 
    MethodTable* pArrayMT = array->GetMethodTable();
    ArrayClass* pArrayCls = (ArrayClass*) pArrayMT->GetClass();
    _ASSERTE(pArrayCls->IsArrayClass());

    // value class array, check to see if it has a constructor
    MethodDesc* ctor = pArrayCls->GetElementCtor();
    if (ctor == 0)
        return;     // Nothing to do

    HELPER_METHOD_FRAME_BEGIN_1(array);

    unsigned offset = ArrayBase::GetDataPtrOffset(pArrayMT);
    unsigned size = pArrayMT->GetComponentSize();
    unsigned cElements = array->GetNumComponents();

    INSTALL_COMPLUS_EXCEPTION_HANDLER();
#if defined(_X86_) && !defined(PLATFORM_CE)
    typedef void (__fastcall * CtorFtnType)(BYTE*);
    CtorFtnType ctorFtn = (CtorFtnType) ctor->GetAddrofCode();
    for (unsigned i =0; i < cElements; i++)
    {
#ifdef _DEBUG
		BYTE* thisPtr = (((BYTE*) array) + offset);
		__asm {
			mov ECX, thisPtr;
			call    [ctorFtn]
			nop 	           // Mark the fact that we can call managed code
		}
#else 
        (*ctorFtn)(((BYTE*) array) + offset);
#endif
        offset += size;
    }
#else // !_X86_ || PLATFORM_CE          
    //
    // This is quite a bit slower, but it is portable.  
    //
    const BYTE* ctorFtn = ctor->GetAddrofCode();
    MetaSig sig(ctor->GetSig(), ctor->GetModule());
    for (unsigned i =0; i < cElements; i++)
    {
        BYTE* arg = ((BYTE*) array) + offset;
        ctor->Call((BYTE*) &arg, &sig);
        offset += size;
    }
#endif // !_X86 || PLATFORM_CE
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
    HELPER_METHOD_FRAME_END();
FCIMPLEND



// Get inclusive upper bound
FCIMPL2(INT32, Array_UpperBound, ArrayBase* array, unsigned int dimension)
    VALIDATEOBJECTREF(array);

    ArrayClass *pArrayClass;
    DWORD       Rank;

    if (array == NULL)
        FCThrow(kNullReferenceException);

    // What is this an array of?
    pArrayClass = array->GetArrayClass();
    Rank = pArrayClass->GetRank();

    if (dimension >= Rank)
        FCThrowRes(kIndexOutOfRangeException, L"IndexOutOfRange_ArrayRankIndex");

    return array->GetBoundsPtr()[dimension] + array->GetLowerBoundsPtr()[dimension] - 1;
FCIMPLEND


FCIMPL2(INT32, Array_LowerBound, ArrayBase* array, unsigned int dimension)
    VALIDATEOBJECTREF(array);

    ArrayClass *pArrayClass;
    DWORD       Rank;

    if (array == NULL)
        FCThrow(kNullReferenceException);

    // What is this an array of?
    pArrayClass = array->GetArrayClass();

    Rank = pArrayClass->GetRank();

    if (dimension >= Rank)
        FCThrowRes(kIndexOutOfRangeException, L"IndexOutOfRange_ArrayRankIndex");

    return array->GetLowerBoundsPtr()[dimension];
FCIMPLEND


FCIMPL2(INT32, Array_GetLength, ArrayBase* array, unsigned int dimension)
    VALIDATEOBJECTREF(array);

    if (array==NULL)
        FCThrow(kNullReferenceException);
    unsigned int rank = array->GetRank();
    if (dimension >= rank)
        FCThrow(kIndexOutOfRangeException);
    return array->GetBoundsPtr()[dimension];
FCIMPLEND


FCIMPL1(INT32, Array_GetLengthNoRank, ArrayBase* array)
    VALIDATEOBJECTREF(array);

    if (array==NULL)
        FCThrow(kNullReferenceException);
    return array->GetNumComponents();
FCIMPLEND


/*****************************************************************************************/

static PCOR_SIGNATURE EmitSharedType(PCOR_SIGNATURE pSig, TypeHandle typeHnd) {

    CorElementType type = typeHnd.GetSigCorElementType();
    if (CorTypeInfo::IsObjRef(type)) {
        *pSig++ = ELEMENT_TYPE_VAR;
        *pSig++ = 0;        // variable 0
    }
    else if (CorTypeInfo::IsPrimitiveType(type))
        *pSig++ = type;                     // Primitives are easy
    else if (type == ELEMENT_TYPE_PTR) {
        *pSig++ = ELEMENT_TYPE_U;           // we share here too
    }
    else 
    {
        _ASSERTE(type == ELEMENT_TYPE_VALUETYPE);
        *pSig++ = ELEMENT_TYPE_VALUETYPE;
        pSig += CorSigCompressToken(typeHnd.GetClass()->GetCl(), pSig);
    }
    return(pSig);
}

//
// Generate a short sig (descr) for an array accessors
//
#define ARRAY_FUNC_GET     0
#define ARRAY_FUNC_SET     1
#define ARRAY_FUNC_CTOR    2
#define ARRAY_FUNC_ADDRESS 3

BOOL ClassLoader::GenerateArrayAccessorCallSig(
    TypeHandle elemTypeHnd, 
    DWORD   dwRank,
    DWORD   dwFuncType,    // Load, store, or <init>
    Module* pModule,
    PCCOR_SIGNATURE *ppSig,// Generated signature
    DWORD * pcSig          // Generated signature size
)
{
    PCOR_SIGNATURE pSig;
    PCOR_SIGNATURE pSigMemory;
    DWORD   dwCallSigSize;
    DWORD   i;

    _ASSERTE(dwRank >= 1 && dwRank < 0x3fff);

    dwCallSigSize = dwRank + 3;

    // If the rank is larger than 127 then the encoding for the number of arguments
    // will take 2 bytes.
    if (dwRank >= 0x7f)
        dwCallSigSize++;

    // One more for byref or for the value being set.
    if (dwFuncType == ARRAY_FUNC_SET || dwFuncType == ARRAY_FUNC_ADDRESS)
        dwCallSigSize++;    

    // Reserve 4 bytes for the token 
    if (dwFuncType != ARRAY_FUNC_CTOR && !CorTypeInfo::IsPrimitiveType(elemTypeHnd.GetSigCorElementType()))
        dwCallSigSize += 4;

    WS_PERF_SET_HEAP(HIGH_FREQ_HEAP);
    pSigMemory = (PCOR_SIGNATURE) GetHighFrequencyHeap()->AllocMem(dwCallSigSize);
    if (pSigMemory == NULL)
        return FALSE;

    WS_PERF_UPDATE_DETAIL("ArrayClass:GenArrayAccess", dwCallSigSize, pSigMemory);

#ifdef _DEBUG
    m_dwDebugArrayClassSize += dwCallSigSize;
#endif

    pSig = pSigMemory;
    BYTE callConv = IMAGE_CEE_CS_CALLCONV_DEFAULT + IMAGE_CEE_CS_CALLCONV_HASTHIS;
    if (dwFuncType == ARRAY_FUNC_ADDRESS)
        callConv |= CORINFO_CALLCONV_PARAMTYPE;     // Address routine needs special hidden arg

    *pSig++ = callConv;
    switch (dwFuncType)
    {
        case ARRAY_FUNC_GET:
            pSig += CorSigCompressData(dwRank, pSig);       // Argument count
            pSig = EmitSharedType(pSig, elemTypeHnd);
            break;
        case ARRAY_FUNC_CTOR:
            pSig += CorSigCompressData(dwRank, pSig);       // Argument count
            *pSig++ = (BYTE) ELEMENT_TYPE_VOID;             // Return type
            break;
        case ARRAY_FUNC_SET:
            pSig += CorSigCompressData(dwRank+1, pSig);     // Argument count
            *pSig++ = (BYTE) ELEMENT_TYPE_VOID;             // Return type
            break;
        case ARRAY_FUNC_ADDRESS:
            pSig += CorSigCompressData(dwRank, pSig);       // Argument count
            *pSig++ = (BYTE) ELEMENT_TYPE_BYREF;            // Return type
            pSig = EmitSharedType(pSig, elemTypeHnd);
            break;
    }
    for (i = 0; i < dwRank; i++)                
        *pSig++ = ELEMENT_TYPE_I4;
    
    if (dwFuncType == ARRAY_FUNC_SET)
        pSig = EmitSharedType(pSig, elemTypeHnd);

    // Make sure the sig came out exactly as large as we expected
    _ASSERTE(pSig <= pSigMemory + dwCallSigSize);

    *ppSig = pSigMemory;
    *pcSig = (DWORD)(pSig-pSigMemory);
    return TRUE;
}

//
// Allocate a new MethodDesc for a fake array method.
//
// Based on code in class.cpp.
//
// pszMethodName must a constant string which cannot go away, so we can point references at it.
//
ArrayECallMethodDesc *ArrayClass::AllocArrayMethodDesc(
    MethodDescChunk *pChunk,
    DWORD   dwIndex,                                                       
    LPCUTF8 pszMethodName,
    PCCOR_SIGNATURE pShortSig,
    DWORD   cShortSig,
	DWORD 	methodAttrs,
    DWORD   dwVtableSlot,
    CorInfoIntrinsics   intrinsicID)
{
    ArrayECallMethodDesc *pNewMD;

    pNewMD = (ArrayECallMethodDesc *) pChunk->GetMethodDescAt(dwIndex);

    memset(pNewMD, 0, sizeof(ArrayECallMethodDesc));

#ifdef _DEBUG
    pNewMD->m_pszDebugMethodName = (LPUTF8)pszMethodName;
    pNewMD->m_pDebugEEClass      = this;
    pNewMD->m_pszDebugClassName  = m_szDebugClassName;
    pNewMD->m_pDebugMethodTable  = GetMethodTable();
#endif

    pNewMD->SetChunkIndex(dwIndex, mcArray);
    pNewMD->SetMemberDef(0);

    emitStubCall(pNewMD, (BYTE*)(ThePreStub()->GetEntryPoint()));
    pNewMD->m_pszArrayClassMethodName = pszMethodName;
    pNewMD->SetClassification(mcArray);
    pNewMD->m_wAttrs = WORD(methodAttrs); assert(pNewMD->m_wAttrs == methodAttrs);

    pNewMD->m_pSig = pShortSig;
    pNewMD->m_cSig = cShortSig;
    pNewMD->SetAddrofCode(pNewMD->GetPreStubAddr());
    pNewMD->m_intrinsicID = BYTE(intrinsicID); // assert(pNewMD->m_intrinsicID == intrinsicID);

    pNewMD->m_wSlotNumber = (WORD) dwVtableSlot;
    GetVtable()[ dwVtableSlot ] = (SLOT) pNewMD->GetPreStubAddr();

    return pNewMD;
}


/*****************************************************************************************/
MethodTable* ClassLoader::CreateArrayMethodTable(TypeHandle elemTypeHnd, CorElementType arrayKind, unsigned Rank, OBJECTREF* pThrowable) 
{
    // At the moment we can't share nested SZARRAYs because they have different
    // numbers of constructors.  
    CorElementType elemType = elemTypeHnd.GetSigCorElementType();
    if (CorTypeInfo::IsObjRef(elemType) && elemType != ELEMENT_TYPE_SZARRAY &&
        elemTypeHnd.GetMethodTable() != g_pObjectClass) {
        return(FindArrayForElem(TypeHandle(g_pObjectClass), arrayKind, Rank, pThrowable).GetMethodTable());
    }

    Module*         pModule = elemTypeHnd.GetModule();

    BOOL            containsPointers = CorTypeInfo::IsObjRef(elemType);
    if (elemType == ELEMENT_TYPE_VALUETYPE && elemTypeHnd.AsMethodTable()->ContainsPointers())
        containsPointers = TRUE;

    // this is the base for every array type
    _ASSERTE(g_pArrayClass);        // Must have already loaded the System.Array class
    g_pArrayClass->CheckRestore();  //dario REVIEW: is this needed every array creation?

    DWORD numCtors = 2;         // ELEMENT_TYPE_ARRAY has two ctor functions, one with and one without lower bounds
    if (arrayKind == ELEMENT_TYPE_SZARRAY)
    {
        numCtors = 1;
        TypeHandle ptr = elemTypeHnd;
        while (ptr.IsTypeDesc() && ptr.AsTypeDesc()->GetNormCorElementType() == ELEMENT_TYPE_SZARRAY) {
            numCtors++;
            ptr = ptr.AsTypeDesc()->GetTypeParam();
        }
    }

    /****************************************************************************************/

    // Parent class is the top level array
    // The vtable will have all of top level class's methods, plus any methods we have for array classes
    WORD wNumVtableSlots = (WORD) (g_pArrayClass->GetClass()->GetNumVtableSlots() + numCtors + 
                                   3 +  // 3 for the GetAt, SetAt, AddressAt
                                   3    // 3 for the proper rank Get, Set, Address
                                  );    
    DWORD curSlot = g_pArrayClass->GetClass()->GetNumVtableSlots();

    // GC info
    DWORD cbMT = sizeof(MethodTable) - sizeof(SLOT) + (wNumVtableSlots * sizeof(SLOT));
    
    if (containsPointers)
    {
        cbMT += CGCDesc::ComputeSize( 1 );
        if (elemType == ELEMENT_TYPE_VALUETYPE)
        {
            int nSeries = CGCDesc::GetCGCDescFromMT(elemTypeHnd.AsMethodTable())->GetNumSeries();
            cbMT += (nSeries - 1)*sizeof (val_serie_item);
        }
    }

    // Inherit top level class's interface map
    DWORD dwMTOffsetForInterfacesMap = cbMT;
    cbMT += g_pArrayClass->GetNumInterfaces() * sizeof(InterfaceInfo_t);

    // Allocate ArrayClass, MethodTable, and class name in one alloc

    WS_PERF_SET_HEAP(HIGH_FREQ_HEAP);
    // ArrayClass already includes one void*
    BYTE* pMemory = (BYTE *) GetHighFrequencyHeap()->AllocMem(sizeof(ArrayClass) + cbMT);
    if (pMemory == NULL)
        return NULL;
    
    WS_PERF_UPDATE_DETAIL("ArrayClass:AllocArrayMethodDesc",  sizeof(ArrayECallMethodDesc) + METHOD_PREPAD, pMemory);

    // Zero the ArrayClass and the MethodTable
    memset(pMemory, 0, sizeof(ArrayClass) + cbMT);

    ArrayClass* pClass = (ArrayClass *) pMemory;

    // Head of MethodTable memory (starts after ArrayClass), this points at the GCDesc stuff in front
    // of a method table (if needed)
    BYTE* pMTHead = pMemory + sizeof(ArrayClass);
    if (containsPointers)
    {
        pMTHead += CGCDesc::ComputeSize(1);
        if (elemType == ELEMENT_TYPE_VALUETYPE)
        {
            int nSeries = CGCDesc::GetCGCDescFromMT(elemTypeHnd.AsMethodTable())->GetNumSeries();
            pMTHead += (nSeries - 1)*sizeof (val_serie_item);
        }
    }
    
    MethodTable* pMT = (MethodTable *) pMTHead;

    // Fill in pClass 
    pClass->SetExposedClassObject (0);
    pClass->SetNumVtableSlots (wNumVtableSlots);
    pClass->SetNumMethodSlots (wNumVtableSlots);
    pClass->SetLoader (this);
    pClass->SetAttrClass (tdPublic | tdSerializable | tdSealed);  // This class is public, serializable, sealed
    pClass->SetRank (Rank);
    pClass->SetElementTypeHandle (elemTypeHnd);
    pClass->SetElementType (elemType); 
    pClass->Setcl (mdTypeDefNil);
	DWORD flags = VMFLAG_ARRAY_CLASS | VMFLAG_INITED;
	if (elemTypeHnd.GetClass()->ContainsStackPtr())
		flags |= VMFLAG_CONTAINS_STACK_PTR;
    pClass->SetVMFlags (flags);
    pClass->SetMethodTable (pMT);
    pClass->SetParentClass (g_pArrayClass->GetClass());

#if CHECK_APP_DOMAIN_LEAKS
    // Non-covariant arrays of agile types are agile
    if (elemType != ELEMENT_TYPE_CLASS && elemTypeHnd.IsAppDomainAgile())
        pClass->SetVMFlags (pClass->GetVMFlags() | VMFLAG_APP_DOMAIN_AGILE);
    pClass->SetAppDomainAgilityDone();
#endif

#ifdef _DEBUG
    m_dwDebugArrayClassSize += (sizeof(ArrayClass) + cbMT);
#endif

    // Fill In the method table
    DWORD dwComponentSize = elemTypeHnd.GetSize();  

    //
    // NOTE: order is important here because assigning something to m_wFlags
    //       will overwrite m_ComponentSize due to the fact that they are
    //       part of the same union.  
    //
    pMT->m_wFlags           = (MethodTable::enum_flag_Array | MethodTable::enum_flag_ClassInited);
    pMT->m_ComponentSize    = (WORD) dwComponentSize; 
    pMT->m_pEEClass         = pClass;
    pMT->m_pModule          = pModule;
    pMT->m_NormType         = arrayKind;
    pMT->m_wDefaultCtorSlot = MethodTable::NO_SLOT;

    if (CorTypeInfo::IsObjRef(elemType)) 
        pMT->SetSharedMethodTable();

    // Set BaseSize to be size of non-data portion of the array
    pMT->m_BaseSize = ObjSizeOf(ArrayBase);
    if (pMT->HasSharedMethodTable())
        pMT->m_BaseSize += sizeof(TypeHandle);  // Add in the type handle that is also stored in this case
    if (arrayKind == ELEMENT_TYPE_ARRAY)
        pMT->m_BaseSize += Rank*sizeof(DWORD)*2;

    // Interface map can be the same as my parent
    pMT->m_pInterfaceVTableMap = g_pArrayClass->GetInterfaceVTableMap();
    pMT->m_pIMap = g_pArrayClass->m_pIMap;
    pMT->m_wNumInterface = g_pArrayClass->m_wNumInterface;

    // Copy top level class's vtable - note, vtable is contained within the MethodTable
    memcpy(pClass->GetVtable(), g_pArrayClass->GetVtable(), g_pArrayClass->GetClass()->GetNumVtableSlots()*sizeof(SLOT));

    // Count the number of method descs we need so we can allocate chunks.
    DWORD dwMethodDescs = numCtors 
                        + 3         // for rank specific Get, Set, Address
                        + 3;        // for GetAt, SetAt, AddressAt

    // allocate as many chunks as needed to hold the methods
    WS_PERF_SET_HEAP(HIGH_FREQ_HEAP);
    DWORD cChunks = MethodDescChunk::GetChunkCount(dwMethodDescs, mcArray);
    MethodDescChunk **pChunks = (MethodDescChunk**)_alloca(cChunks * sizeof(MethodDescChunk*));
    DWORD cMethodsLeft = dwMethodDescs;
    for (DWORD i = 0; i < cChunks; i++) {
        DWORD cMethods = min(cMethodsLeft, MethodDescChunk::GetMaxMethodDescs(mcArray));
        pChunks[i] = MethodDescChunk::CreateChunk(GetHighFrequencyHeap(), cMethods, mcArray, 0);
        if (pChunks[i] == NULL)
            return NULL;
        cMethodsLeft -= cMethods;
        pChunks[i]->SetMethodTable(pMT);
#ifdef _DEBUG
        m_dwDebugArrayClassSize += pChunks[i]->Sizeof();
#endif
    }
    _ASSERTE(cMethodsLeft == 0);

    MethodDescChunk *pMethodDescChunk = pChunks[0];
    DWORD dwMethodDescIndex = 0;
    DWORD dwCurrentChunk = 0;

#define MDC_INC_INDEX() do {                                                    \
        dwMethodDescIndex++;                                                    \
        if (dwMethodDescIndex == MethodDescChunk::GetMaxMethodDescs(mcArray)) { \
            dwMethodDescIndex = 0;                                              \
            pMethodDescChunk = pChunks[++dwCurrentChunk];                       \
        }                                                                       \
    } while (false)

    // Generate a new stand-alone, Rank Specific Get, Set and Address method.  
    PCCOR_SIGNATURE pSig;
    DWORD           cSig;
	WORD 			methodAttrs = mdPublic; 

    // Get
    if (!GenerateArrayAccessorCallSig(elemTypeHnd, Rank, ARRAY_FUNC_GET, pModule, &pSig, &cSig)) 
        return NULL;
    if (!(pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, ARRAYCLASS_GET, pSig, cSig, methodAttrs, curSlot++, CORINFO_INTRINSIC_Array_Get)))
        return NULL;
    MDC_INC_INDEX();

    // Set
    if (!GenerateArrayAccessorCallSig(elemTypeHnd, Rank, ARRAY_FUNC_SET, pModule, &pSig, &cSig)) 
        return NULL;
    if (!(pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, ARRAYCLASS_SET, pSig, cSig, methodAttrs, curSlot++, CORINFO_INTRINSIC_Array_Set)))
        return NULL;
    MDC_INC_INDEX();

    // Address
    if (!GenerateArrayAccessorCallSig(elemTypeHnd, Rank, ARRAY_FUNC_ADDRESS, pModule, &pSig, &cSig)) 
        return NULL;
    if (!(pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, ARRAYCLASS_ADDRESS, pSig, cSig, methodAttrs, curSlot++)))
        return NULL;
    MDC_INC_INDEX();


    // GetAt
    if (!GenerateArrayAccessorCallSig(elemTypeHnd, 1, ARRAY_FUNC_GET, pModule, &pSig, &cSig)) 
        return NULL;
    if (!(pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, ARRAYCLASS_GETAT, pSig, cSig, methodAttrs, curSlot++)))
        return NULL;
    MDC_INC_INDEX();

    // SetAt
    if (!GenerateArrayAccessorCallSig(elemTypeHnd, 1, ARRAY_FUNC_SET, pModule, &pSig, &cSig)) 
			return NULL;
		if (!(pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, ARRAYCLASS_SETAT, pSig, cSig, methodAttrs, curSlot++)))
        return NULL;
    MDC_INC_INDEX();

    // AddressAt
    if (!GenerateArrayAccessorCallSig(elemTypeHnd, 1, ARRAY_FUNC_ADDRESS, pModule, &pSig, &cSig)) 
        return NULL;
    if (!(pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, ARRAYCLASS_ADDRESSAT, pSig, cSig, methodAttrs, curSlot++)))
        return NULL;
    MDC_INC_INDEX();


	WORD ctorAttrs = mdPublic | mdRTSpecialName;

    // Set up Construtor  vtable entries
    if (arrayKind == ELEMENT_TYPE_SZARRAY)
    {
        // For SZARRAY arrays, set up multiple constructors.  We probably should not do this.  
        for (DWORD i = 0; i < numCtors; i++)
        {
            if (GenerateArrayAccessorCallSig(elemTypeHnd, i+1, ARRAY_FUNC_CTOR, pModule, &pSig, &cSig) == FALSE)
                return NULL;
            if (pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, COR_CTOR_METHOD_NAME, pSig, cSig, ctorAttrs, curSlot++) == NULL)
                return NULL;
            MDC_INC_INDEX();
        }
    }
    else
    {
        // ELEMENT_TYPE_ARRAY has two constructors, one without lower bounds and one with lower bounds
        if (GenerateArrayAccessorCallSig(elemTypeHnd, Rank, ARRAY_FUNC_CTOR, pModule, &pSig, &cSig) == FALSE)
            return NULL;
        if (pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, COR_CTOR_METHOD_NAME,  pSig, cSig, ctorAttrs, curSlot++) == NULL)
            return NULL;
        MDC_INC_INDEX();

        if (GenerateArrayAccessorCallSig(elemTypeHnd, Rank * 2, ARRAY_FUNC_CTOR, pModule, &pSig, &cSig) == FALSE)
            return NULL;
        if (pClass->AllocArrayMethodDesc(pMethodDescChunk, dwMethodDescIndex, COR_CTOR_METHOD_NAME,  pSig, cSig, ctorAttrs, curSlot++) == NULL)
            return NULL;
        MDC_INC_INDEX();
    }
    _ASSERTE(wNumVtableSlots == curSlot);

#undef MDC_INC_INDEX

    // Set up GC information 
    if (elemType == ELEMENT_TYPE_VALUETYPE || elemType == ELEMENT_TYPE_VOID)
    {
        // The only way for dwComponentSize to be large is to be part of a value class. If this changes
        // then the check will need to be moved outside valueclass check.
        if(dwComponentSize > MAX_SIZE_FOR_VALUECLASS_IN_ARRAY) {
            CQuickBytes qb;
            LPSTR elemName = (LPSTR) qb.Alloc(MAX_CLASSNAME_LENGTH * sizeof(CHAR));
            unsigned ret = elemTypeHnd.GetName(elemName, MAX_CLASSNAME_LENGTH);
            _ASSERTE(ret < MAX_CLASSNAME_LENGTH);

            elemTypeHnd.GetAssembly()->PostTypeLoadException(elemName, IDS_CLASSLOAD_VALUECLASSTOOLARGE, pThrowable);
            return NULL;
        }

        // If it's an array of value classes, there is a different format for the GCDesc if it contains pointers
        if (elemTypeHnd.AsMethodTable()->ContainsPointers())
        {
            CGCDescSeries  *pSeries;

            // There must be only one series for value classes
            CGCDescSeries  *pByValueSeries = CGCDesc::GetCGCDescFromMT(elemTypeHnd.AsMethodTable())->GetHighestSeries();

            pMT->SetContainsPointers();

            // negative series has a special meaning, indicating a different form of GCDesc
            int nSeries = CGCDesc::GetCGCDescFromMT(elemTypeHnd.AsMethodTable())->GetNumSeries();
            CGCDesc::GetCGCDescFromMT(pMT)->Init( pMT, -nSeries );

            pSeries = CGCDesc::GetCGCDescFromMT(pMT)->GetHighestSeries();

            // sort by offset
            CGCDescSeries** sortedSeries = (CGCDescSeries**) _alloca(sizeof(CGCDescSeries*)*nSeries);
            for (int index = 0; index < nSeries; index++)
                sortedSeries[index] = &pByValueSeries[-index];

            // section sort
            for (int i = 0; i < nSeries; i++) {
                for (int j = i+1; j < nSeries; j++)
                    if (sortedSeries[j]->GetSeriesOffset() < sortedSeries[i]->GetSeriesOffset())
                    {
                        CGCDescSeries* temp = sortedSeries[i];
                        sortedSeries[i] = sortedSeries[j];
                        sortedSeries[j] = temp;
                    }
            }

            // Offset of the first pointer in the array
            // This equals the offset of the first pointer if this were an array of entirely pointers, plus the offset of the
            // first pointer in the value class
            pSeries->SetSeriesOffset(ArrayBase::GetDataPtrOffset(pMT)
                + (sortedSeries[0]->GetSeriesOffset()) - sizeof (Object) );
            for (index = 0; index < nSeries; index ++)
            {
                DWORD dwNumPtrsInBytes = sortedSeries[index]->GetSeriesSize()
                    + elemTypeHnd.AsMethodTable()->GetBaseSize();
                int currentOffset;
                DWORD skip;
                currentOffset = sortedSeries[index]->GetSeriesOffset()+dwNumPtrsInBytes;
                if (index != nSeries-1)
                {
                    skip = sortedSeries[index+1]->GetSeriesOffset()-currentOffset;
                }
                else if (index == 0)
                {
                    skip = elemTypeHnd.AsClass()->GetAlignedNumInstanceFieldBytes() - dwNumPtrsInBytes;
                }
                else
                {
                    skip = sortedSeries[0]->GetSeriesOffset() + elemTypeHnd.AsMethodTable()->GetBaseSize()
                         - ObjSizeOf(Object) - currentOffset;
                }
                unsigned short NumPtrs = (unsigned short) (dwNumPtrsInBytes / sizeof(void*));
                if(skip > MAX_SIZE_FOR_VALUECLASS_IN_ARRAY || dwNumPtrsInBytes > MAX_PTRS_FOR_VALUECLASSS_IN_ARRAY) {
                    CQuickBytes qb;
                    LPSTR elemName = (LPSTR) qb.Alloc(MAX_CLASSNAME_LENGTH * sizeof(CHAR));
                    unsigned ret = elemTypeHnd.GetName(elemName, MAX_CLASSNAME_LENGTH);
                    _ASSERTE(ret < MAX_CLASSNAME_LENGTH);

                    elemTypeHnd.GetAssembly()->PostTypeLoadException(elemName,
                                                                     IDS_CLASSLOAD_VALUECLASSTOOLARGE,
                                                                     pThrowable);
                    return NULL;
                }
        
                val_serie_item *val_item = &(pSeries->val_serie[-index]);

                val_item->set_val_serie_item (NumPtrs, (unsigned short)skip);
            }
        }

        unsigned __int8 ctorSig[] = { IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, 0, ELEMENT_TYPE_VOID };

        MethodTable *pMT = elemTypeHnd.AsMethodTable();
        if (pMT->HasDefaultConstructor())
            pClass->SetElementCtor (pMT->GetDefaultConstructor());
        else
            pClass->SetElementCtor (NULL);
    }
    else if (CorTypeInfo::IsObjRef(elemType))
    {
        CGCDescSeries  *pSeries;

        pMT->SetContainsPointers();

        // This array is all GC Pointers
        CGCDesc::GetCGCDescFromMT(pMT)->Init( pMT, 1 );

        pSeries = CGCDesc::GetCGCDescFromMT(pMT)->GetHighestSeries();

        pSeries->SetSeriesOffset(ArrayBase::GetDataPtrOffset(pMT));
        // For arrays, the size is the negative of the BaseSize (the GC always adds the total 
        // size of the object, so what you end up with is the size of the data portion of the array)
        pSeries->SetSeriesSize((DWORD)-(int)(pMT->m_BaseSize));
    }
 
    // If we get here we are assuming that there was no truncation. If this is not the case then
    // an array whose base type is not a value class was created and was larger then 0xffff (a word)
    _ASSERTE(dwComponentSize == pMT->m_ComponentSize);

    // Add to linked list of ArrayClasses for this loader
    pClass->SetNext (m_pHeadArrayClass);
    m_pHeadArrayClass   = pClass;

    return(pMT);
}

//========================================================================
// Generates the platform-independent arrayop stub.
//========================================================================
BOOL GenerateArrayOpScript(ArrayECallMethodDesc *pMD, ArrayOpScript *paos)
{
    THROWSCOMPLUSEXCEPTION();
    MethodTable *pMT = pMD->GetMethodTable();
    ArrayClass *pcls = (ArrayClass*)(pMT->GetClass());

#ifdef _DEBUG
    FillMemory(paos, sizeof(ArrayOpScript) + sizeof(ArrayOpIndexSpec) * pcls->GetRank(), 0xcc);
#endif

    paos->m_rank            = (BYTE)(pcls->GetRank());
    paos->m_fHasLowerBounds = (pMT->GetNormCorElementType() == ELEMENT_TYPE_ARRAY);
    paos->m_flags           = 0;
    paos->m_gcDesc          = 0;
    paos->m_ofsoffirst      = ArrayBase::GetDataPtrOffset(pMT);

    if (strcmp(pMD->m_pszArrayClassMethodName, ARRAYCLASS_GET) == 0)
        paos->m_op = ArrayOpScript::LOAD;
    else if (strcmp(pMD->m_pszArrayClassMethodName, ARRAYCLASS_SET) == 0)
        paos->m_op = ArrayOpScript::STORE;
    else if (strcmp(pMD->m_pszArrayClassMethodName, ARRAYCLASS_ADDRESS) == 0)
        paos->m_op = ArrayOpScript::LOADADDR;
    else
    {
		/**
        paos->m_flags |= ArrayOpScript::FLATACCESSOR;
        if (strcmp(pMD->m_pszArrayClassMethodName, ARRAYCLASS_GETAT) == 0)
            paos->m_op = ArrayOpScript::LOAD;
        else if (strcmp(pMD->m_pszArrayClassMethodName, ARRAYCLASS_SETAT) == 0)
            paos->m_op = ArrayOpScript::STORE;
        else if (strcmp(pMD->m_pszArrayClassMethodName, ARRAYCLASS_ADDRESSAT) == 0)
            paos->m_op = ArrayOpScript::LOADADDR;
        else {
            _ASSERTE(!"Bad Array function!");
            return FALSE;
        }
		**/
		return FALSE;
    }

    PCCOR_SIGNATURE sig = pMD->m_pSig;
    MetaSig msig(sig, pcls->GetModule());
    _ASSERTE(!msig.IsVarArg());     // No array signature is varargs, code below does not expect it. 

    paos->m_signed = FALSE;
    switch (pcls->GetElementType())
    {
        // These are all different because of sign extension
        default:
            _ASSERTE(!"Unsupported Array Type");
            return FALSE;

        case ELEMENT_TYPE_I1:
            paos->m_elemsize = 1;
            paos->m_signed = TRUE;
            break;

        case ELEMENT_TYPE_BOOLEAN:
        case ELEMENT_TYPE_U1:
            paos->m_elemsize = 1;
            break;

        case ELEMENT_TYPE_I2:
            paos->m_elemsize = 2;
            paos->m_signed = TRUE;
            break;

        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_U2:
            paos->m_elemsize = 2;
            break;

        case ELEMENT_TYPE_I:
        case ELEMENT_TYPE_I4:
            paos->m_elemsize = 4;
            paos->m_signed = TRUE;
            break;

        case ELEMENT_TYPE_PTR:
        case ELEMENT_TYPE_U:
        case ELEMENT_TYPE_U4:
            paos->m_elemsize = 4;
            break;

        case ELEMENT_TYPE_I8:
            paos->m_elemsize = 8;
            paos->m_signed = TRUE;
            break;

        case ELEMENT_TYPE_U8:
            paos->m_elemsize = 8;
            break;

        case ELEMENT_TYPE_R4:
            paos->m_elemsize = 4;
            paos->m_flags |= paos->ISFPUTYPE;
            break;

        case ELEMENT_TYPE_R8:
            paos->m_elemsize = 8;
            paos->m_flags |= paos->ISFPUTYPE;
            break;

        case ELEMENT_TYPE_SZARRAY:
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_OBJECT:
            paos->m_elemsize = sizeof(LPVOID);
            paos->m_flags |= paos->NEEDSWRITEBARRIER;
            if (paos->m_op != ArrayOpScript::LOAD)
                paos->m_flags |= paos->NEEDSTYPECHECK;

            if (paos->m_op == ArrayOpScript::LOADADDR)
                _ASSERTE(*sig & CORINFO_CALLCONV_PARAMTYPE);
            break;

        case ELEMENT_TYPE_VALUETYPE:
            paos->m_elemsize = pMT->m_ComponentSize;
            if (pMT->ContainsPointers()) {
                paos->m_gcDesc = CGCDesc::GetCGCDescFromMT(pMT);
                paos->m_flags |= paos->NEEDSWRITEBARRIER;
            }
            break;
    }

	paos->m_cbretpop = msig.CbStackPop(FALSE);

    ArgIterator argit(NULL, &msig, FALSE); 
    if (msig.HasRetBuffArg())
    {
        paos->m_flags |= ArrayOpScript::HASRETVALBUFFER;
        UINT regstructofs;
        int ofs = argit.GetRetBuffArgOffset(&regstructofs);
        if (regstructofs != -1)
        {
            paos->m_fRetBufInReg = TRUE;
            paos->m_fRetBufLoc = regstructofs;
        }
        else
        {
            paos->m_fRetBufInReg = FALSE;
            paos->m_fRetBufLoc = ofs;
        }
    }
    else
    {
        // If no retbuf, these values are ignored; but set them to
        // constant values so they don't create unnecessary hash misses.
        paos->m_fRetBufInReg = 0;
        paos->m_fRetBufLoc = 0;  
    }
    
    for (UINT idx = 0; idx < paos->m_rank; idx++)
    {
        ArrayOpIndexSpec *pai = (ArrayOpIndexSpec*)(paos->GetArrayOpIndexSpecs() + idx);
        //        int    GetNextOffset(BYTE *pType, UINT32 *pStructSize, UINT *pRegStructOfs = NULL);
        
        BYTE ptyp; UINT32 structsize;
        UINT regstructofs;
        int ofs = argit.GetNextOffset(&ptyp, &structsize, &regstructofs);
        if (regstructofs != -1)
        {
            pai->m_freg = TRUE;
            pai->m_idxloc = regstructofs;
        }
        else
        {
            pai->m_freg = FALSE;
            pai->m_idxloc = ofs;
        }
        pai->m_lboundofs = paos->m_fHasLowerBounds ? (ArrayBase::GetLowerBoundsOffset(pMT) + idx*sizeof(DWORD)) : 0;
        pai->m_lengthofs = ArrayBase::GetBoundsOffset(pMT) + idx*sizeof(DWORD);
    }


    if (*sig & CORINFO_CALLCONV_PARAMTYPE) {
        _ASSERTE(paos->m_op == ArrayOpScript::LOADADDR);
        paos->m_typeParamOffs = argit.GetParamTypeArgOffset(&paos->m_typeParamReg);
    }
    
    if (paos->m_op == paos->STORE)
    {
        BYTE ptyp; UINT32 structsize;
        UINT regstructofs;
        int ofs = argit.GetNextOffset(&ptyp, &structsize, &regstructofs);
        if (regstructofs != -1)
        {
            paos->m_fValInReg = TRUE;
            paos->m_fValLoc = regstructofs;
        }
        else
        {
            paos->m_fValInReg = FALSE;
            paos->m_fValLoc = ofs;
        }
    }
    
    return TRUE;
}

Stub *GenerateArrayOpStub(CPUSTUBLINKER *psl, ArrayECallMethodDesc* pMD)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pMT = pMD->GetMethodTable();
    ArrayClass *pcls = (ArrayClass*)(pMT->GetClass());

#ifndef _X86_
    return NULL;
#else

    if (pcls->GetRank() == 0)
    {
        // this method belongs to the genarray class.
        psl->EmitRankExceptionThrowStub(MetaSig::SizeOfActualFixedArgStack(pMT->GetModule(), pMD->m_pSig, FALSE));
        return psl->Link();

    }
    else
    {
        ArrayOpScript *paos = (ArrayOpScript*)_alloca(sizeof(ArrayOpScript) + sizeof(ArrayOpIndexSpec) * pcls->GetRank());

        if (!GenerateArrayOpScript(pMD, paos)) {
			// TODO: this is only here as a hack.  GenerateArrayOptScript should not fail - vancem
			psl->EmitRankExceptionThrowStub(MetaSig::SizeOfActualFixedArgStack(pMT->GetModule(), pMD->m_pSig, FALSE));
			return psl->Link();
		}

        Stub *pArrayOpStub;
        ArrayStubCache::MLStubCompilationMode mode;
        pArrayOpStub = ECall::m_pArrayStubCache->Canonicalize((const BYTE *)paos, &mode);
        if (!pArrayOpStub || mode != MLStubCache::STANDALONE) {
            COMPlusThrowOM();
        }

        return pArrayOpStub;
    }

#endif
}

ArrayStubCache::MLStubCompilationMode ArrayStubCache::CompileMLStub(const BYTE *pRawMLStub,
                                                    StubLinker *psl,
                                                    void *callerContext)
{
    MLStubCompilationMode ret = INTERPRETED;
    COMPLUS_TRY
    {

        ((CPUSTUBLINKER*)psl)->EmitArrayOpStub((ArrayOpScript*)pRawMLStub);
        ret = STANDALONE;
    }
    COMPLUS_CATCH
    {
        // In case of an error, we'll just leave the mode as "INTERPRETED."
        // and let the caller of Canonicalize() treat that as an error.
    } COMPLUS_END_CATCH
    return ret;

}

UINT ArrayStubCache::Length(const BYTE *pRawMLStub)
{
    return ((ArrayOpScript*)pRawMLStub)->Length();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\array.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _ARRAY_H_
#define _ARRAY_H_

#define MAX_RANK 32        // If you make this bigger, you need to make MAX_CLASSNAME_LENGTH bigger too.  
                           // if you have an 32 dim array with at least 2 elements in each dim that 
                           // takes up 4Gig!!!  Thus this is a reasonable maximum.   
// (Note: at the time of the above comment, the rank was 32, and
// MAX_CLASSNAME_LENGTH was 256.  I'm now changing MAX_CLASSNAME_LENGTH
// to 1024, but not changing MAX_RANK.)

class MethodTable;


// System/Array class methods
FCDECL1(INT32, Array_Rank, ArrayBase* pArray);
FCDECL2(INT32, Array_LowerBound, ArrayBase* pArray, unsigned int dimension);
FCDECL2(INT32, Array_UpperBound, ArrayBase* pArray, unsigned int dimension);
//void __stdcall Array_Get(struct ArrayGetArgs *pArgs);
//void __stdcall Array_Set(struct ArraySetArgs *pArgs);
FCDECL1(INT32, Array_GetLengthNoRank, ArrayBase* pArray);
FCDECL2(INT32, Array_GetLength, ArrayBase* pArray, unsigned int dimension);
FCDECL1(void, Array_Initialize, ArrayBase* pArray);

//======================================================================
// The following structures double as hash keys for the MLStubCache.
// Thus, it's imperative that there be no
// unused "pad" fields that contain unstable values.
#pragma pack(push)
#pragma pack(1)



// Specifies one index spec. This is used mostly to get the argument
// location done early when we still have a signature to work with.
struct ArrayOpIndexSpec
{
    BYTE    m_freg;           //incoming index on stack or in register?
    UINT32  m_idxloc;         //if (m_fref) offset in ArgumentReg else base-frame offset into stack.
    UINT32  m_lboundofs;      //offset within array of lowerbound
    UINT32  m_lengthofs;      //offset within array of lengths
};


struct ArrayOpScript
{
    enum
    {
        LOAD     = 0,
        STORE    = 1,
        LOADADDR = 2,
    };


    // FLAGS
    enum
    {
        ISFPUTYPE            = 0x01,
        NEEDSWRITEBARRIER    = 0x02,
        HASRETVALBUFFER      = 0x04,
        NEEDSTYPECHECK       = 0x10,
        FLATACCESSOR         = 0x20,        // Only one index (GetAt, SetAt, AddressAt)
    };

    BYTE    m_rank;            // # of ArrayOpIndexSpec's
    BYTE    m_fHasLowerBounds; // if FALSE, all lowerbounds are 0
    BYTE    m_op;              // STORE/LOAD/LOADADDR

    BYTE    m_flags;

    UINT32  m_elemsize;        // size in bytes of element.
    BYTE    m_signed;          // whether to sign-extend or zero-extend (for short types)

    BYTE    m_fRetBufInReg;    // if HASRETVALBUFFER, indicates whether the retbuf ptr is in a register
    UINT16  m_fRetBufLoc;      // if HASRETVALBUFFER, stack offset or argreg offset of retbuf ptr

    BYTE    m_fValInReg;       // for STORES, indicates whether the value is in a register.
    UINT16  m_fValLoc;         // for STORES, stack offset or argreg offset of value

    UINT16  m_cbretpop;        // how much to pop
    UINT    m_ofsoffirst;      // offset of first element
    CGCDesc*m_gcDesc;          // layout of GC stuff (0 if not needed)

    INT     m_typeParamReg;     // for hidden type Param (LOADADDR only), -1 if not in register
                                // Otherwise indicates which register holds type param
    INT     m_typeParamOffs;    // If type Param not in register this is its offset.

    // Array of ArrayOpIndexSpec's follow (one for each dimension).

    const ArrayOpIndexSpec *GetArrayOpIndexSpecs() const
    {
        return (const ArrayOpIndexSpec *)(1+ this);
    }

    UINT Length() const
    {
        return sizeof(*this) + m_rank * sizeof(ArrayOpIndexSpec);
    }

};


#pragma pack(pop)
//======================================================================



Stub *GenerateArrayOpStub(CPUSTUBLINKER *psl, ArrayECallMethodDesc* pMD);


#endif// _ARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\appdomainhelper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

#include "common.h"
#include "AppDomainHelper.h"

// @TODO: Fix the EE so it's using just one heap.  Security uses these MallocM/FreeM macros that
// map to LocalAlloc, and don't play nice with others.

#include "CorPermE.h"

void AppDomainHelper::CopyEncodingToByteArray(IN PBYTE   pbData,
                                              IN DWORD   cbData,
                                              OUT OBJECTREF* pArray)
{
    THROWSCOMPLUSEXCEPTION();
    U1ARRAYREF pObj;
    _ASSERTE(pArray);

    if(cbData) {
        pObj = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1,cbData);
        if(pObj == NULL) COMPlusThrowOM();

        memcpyNoGCRefs(pObj->m_Array, pbData, cbData);
        *pArray = (OBJECTREF) pObj;
    } else
        *pArray = NULL;
}


void AppDomainHelper::CopyByteArrayToEncoding(IN U1ARRAYREF* pArray,
                                              OUT PBYTE*   ppbData,
                                              OUT DWORD*   pcbData)
{
    THROWSCOMPLUSEXCEPTION();
    HRESULT hr = S_OK;
    _ASSERTE(pArray);
    _ASSERTE(ppbData);
    _ASSERTE(pcbData);

    if (*pArray == NULL) {
        *ppbData = NULL;
        *pcbData = 0;
        return;
    }

    DWORD size = (DWORD) (*pArray)->GetNumComponents();
    if(size) {
        *ppbData = (PBYTE) MallocM(size);
        if(*ppbData == NULL) COMPlusThrowOM();
        *pcbData = size;

        CopyMemory(*ppbData, (*pArray)->GetDirectPointerToNonObjectElements(), size);
    }
}


// Marshal a single object into a serialized blob.
void AppDomainHelper::MarshalObject(IN AppDomain *pDomain,
                                    IN OBJECTREF *orObject, // Object must be GC protected
                                    OUT U1ARRAYREF *porBlob)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(orObject);

    Thread *pThread = GetThread();
    AppDomain *pCurrDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__MARSHAL_OBJECT);

    if (pCurrDomain != pDomain)
        pThread->EnterContext(pDomain->GetDefaultContext(), &frame, TRUE);

    INT64 args[] = {
        ObjToInt64(*orObject)
    };

    *porBlob = (U1ARRAYREF)Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__MARSHAL_OBJECT));

    if (pCurrDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);
}

// Marshal a single object into a serialized blob.
void AppDomainHelper::MarshalObject(IN AppDomain *pDomain,
                                    IN OBJECTREF *orObject, // Object must be GC protected
                                    OUT BYTE    **ppbBlob,
                                    OUT DWORD    *pcbBlob)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(orObject);

    Thread *pThread = GetThread();
    AppDomain *pCurrDomain = pThread->GetDomain();
    ContextTransitionFrame frame;
    U1ARRAYREF orBlob = NULL;

    GCPROTECT_BEGIN(orBlob);

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__MARSHAL_OBJECT);

    if (pCurrDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    INT64 args[] = {
        ObjToInt64(*orObject)
    };

    orBlob = (U1ARRAYREF)Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__MARSHAL_OBJECT));

    if (pCurrDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    CopyByteArrayToEncoding(&orBlob,
                            ppbBlob,
                            pcbBlob);
    GCPROTECT_END();
}

// Marshal two objects into serialized blobs.
void AppDomainHelper::MarshalObjects(IN AppDomain *pDomain,
                                    IN OBJECTREF  *orObject1,
                                    IN OBJECTREF  *orObject2,
                                    OUT BYTE    **ppbBlob1,
                                    OUT DWORD    *pcbBlob1,
                                    OUT BYTE    **ppbBlob2,
                                    OUT DWORD    *pcbBlob2)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(orObject1);
    _ASSERTE(orObject2);

    Thread *pThread = GetThread();
    AppDomain *pCurrDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    struct _gc {
        U1ARRAYREF  orBlob1;
        U1ARRAYREF  orBlob2;
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    GCPROTECT_BEGIN(gc);

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__MARSHAL_OBJECTS);

    if (pCurrDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    INT64 args[] = {
        (INT64)&gc.orBlob2,
        ObjToInt64(*orObject2),
        ObjToInt64(*orObject1),
    };

    gc.orBlob1 = (U1ARRAYREF)Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__MARSHAL_OBJECTS));

    if (pCurrDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);

    CopyByteArrayToEncoding(&gc.orBlob1,
                            ppbBlob1,
                            pcbBlob1);

    CopyByteArrayToEncoding(&gc.orBlob2,
                            ppbBlob2,
                            pcbBlob2);
    GCPROTECT_END();
}

// Unmarshal a single object from a serialized blob.
void AppDomainHelper::UnmarshalObject(IN AppDomain  *pDomain,
                                     IN U1ARRAYREF  *porBlob,
                                     OUT OBJECTREF  *porObject)
{
    THROWSCOMPLUSEXCEPTION();

    Thread *pThread = GetThread();
    AppDomain *pCurrDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__UNMARSHAL_OBJECT);

    if (pCurrDomain != pDomain)
        pThread->EnterContext(pDomain->GetDefaultContext(), &frame, TRUE);

    INT64 args[] = {
        ObjToInt64(*porBlob)
    };

    *porObject = Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__UNMARSHAL_OBJECT));

    if (pCurrDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);
}

// Unmarshal a single object from a serialized blob.
void AppDomainHelper::UnmarshalObject(IN AppDomain   *pDomain,
                                     IN BYTE        *pbBlob,
                                     IN DWORD        cbBlob,
                                     OUT OBJECTREF  *porObject)
{
    THROWSCOMPLUSEXCEPTION();

    Thread *pThread = GetThread();
    AppDomain *pCurrDomain = pThread->GetDomain();
    ContextTransitionFrame frame;
    OBJECTREF orBlob = NULL;

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__UNMARSHAL_OBJECT);

    if (pCurrDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    GCPROTECT_BEGIN(orBlob);

    AppDomainHelper::CopyEncodingToByteArray(pbBlob,
                                            cbBlob,
                                            &orBlob);

    INT64 args[] = {
        ObjToInt64(orBlob)
    };

    *porObject = Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__UNMARSHAL_OBJECT));

    GCPROTECT_END();

    if (pCurrDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);
}

// Unmarshal two objects from serialized blobs.
void AppDomainHelper::UnmarshalObjects(IN AppDomain   *pDomain,
                                      IN BYTE        *pbBlob1,
                                      IN DWORD        cbBlob1,
                                      IN BYTE        *pbBlob2,
                                      IN DWORD        cbBlob2,
                                      OUT OBJECTREF  *porObject1,
                                      OUT OBJECTREF  *porObject2)
{
    THROWSCOMPLUSEXCEPTION();

    Thread *pThread = GetThread();
    AppDomain *pCurrDomain = pThread->GetDomain();
    ContextTransitionFrame frame;

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__UNMARSHAL_OBJECTS);

    struct _gc {
        OBJECTREF  orBlob1;
        OBJECTREF  orBlob2;
        OBJECTREF  orObject2;
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    if (pCurrDomain != pDomain)
        pThread->EnterContextRestricted(pDomain->GetDefaultContext(), &frame, TRUE);

    GCPROTECT_BEGIN(gc);

    AppDomainHelper::CopyEncodingToByteArray(pbBlob1,
                                            cbBlob1,
                                            &gc.orBlob1);

    AppDomainHelper::CopyEncodingToByteArray(pbBlob2,
                                            cbBlob2,
                                            &gc.orBlob2);

    INT64 args[] = {
        (INT64)&gc.orObject2,
        ObjToInt64(gc.orBlob2),
        ObjToInt64(gc.orBlob1)
    };

    *porObject1 = Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__UNMARSHAL_OBJECTS));
    *porObject2 = gc.orObject2;

    GCPROTECT_END();

    if (pCurrDomain != pDomain)
        pThread->ReturnToContext(&frame, TRUE);
}

// Copy an object from the given appdomain into the current appdomain.
OBJECTREF AppDomainHelper::CrossContextCopyFrom(IN DWORD dwDomainId,
                                                IN OBJECTREF *orObject) // Object must be GC protected
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain *pDomain = SystemDomain::System()->GetAppDomainAtId(dwDomainId);
    if (! pDomain)
        COMPlusThrow(kAppDomainUnloadedException);
    return CrossContextCopyFrom(pDomain, orObject);
}

// Copy an object from the given appdomain into the current appdomain.
OBJECTREF AppDomainHelper::CrossContextCopyTo(IN DWORD dwDomainId,
                                                IN OBJECTREF *orObject) // Object must be GC protected
{
    THROWSCOMPLUSEXCEPTION();

    AppDomain *pDomain = SystemDomain::System()->GetAppDomainAtId(dwDomainId);
    if (! pDomain)
        COMPlusThrow(kAppDomainUnloadedException);
    return CrossContextCopyTo(pDomain, orObject);
}

// Copy an object from the given appdomain into the current appdomain.
OBJECTREF AppDomainHelper::CrossContextCopyFrom(IN AppDomain *pDomain,
                                                IN OBJECTREF *orObject) // Object must be GC protected
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pDomain != NULL);
    _ASSERTE(pDomain != GetAppDomain());
    _ASSERTE(orObject);

    U1ARRAYREF  orBlob = NULL;
    OBJECTREF pResult = NULL;

    GCPROTECT_BEGIN(orBlob);
    AppDomainHelper::MarshalObject(pDomain, orObject, &orBlob);
    AppDomainHelper::UnmarshalObject(GetAppDomain(), &orBlob, &pResult);
    GCPROTECT_END();

    return pResult;
}

// Copy an object to the given appdomain from the current appdomain.
OBJECTREF AppDomainHelper::CrossContextCopyTo(IN AppDomain *pDomain,
                                              IN OBJECTREF *orObject)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(pDomain != NULL);
    _ASSERTE(pDomain != GetAppDomain());
    _ASSERTE(orObject);

    U1ARRAYREF  orBlob = NULL;
    OBJECTREF pResult = NULL;

    GCPROTECT_BEGIN(orBlob);
    AppDomainHelper::MarshalObject(GetAppDomain(), orObject, &orBlob);
    AppDomainHelper::UnmarshalObject(pDomain, &orBlob, &pResult);
    GCPROTECT_END();

    return pResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assembly.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: Assembly.cpp
**
** Purpose: Implements assembly (loader domain) architecture
**
** Date:  Dec 1, 1998
**
===========================================================*/

#include "common.h"

#include <stdlib.h>

#include "Assembly.hpp"
#include "AppDomain.hpp"
#include "security.h"
#include "COMClass.h"
#include "COMString.h"
#include "COMReflectionCommon.h"
#include "AssemblySink.h"
#include "PerfCounters.h"
#include "AssemblyName.hpp"
#include "fusion.h"
#include "EEProfInterfaces.h"
#include "ReflectClassWriter.h" 
#include "COMDynamic.h"

#include "urlmon.h"
#include "ReflectWrap.h"
#include "COMMember.h"

#include "eeconfig.h"
#include "StrongName.h"
#include "corcompile.h"
#include "corzap.h"
#include "CeeFileGenWriter.h"
#include "AssemblyNative.hpp"
#include "Timeline.h"
#include "nlog.h"
#include "sha.h"
#include "AppDomainNative.hpp"
#include "Remoting.h"
#include "safegetfilesize.h"
#include "customattribute.h"
#include "winnls.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


// Define these macro's to do strict validation for jit lock and class init entry leaks. 
// This defines determine if the asserts that verify for these leaks are defined or not. 
// These asserts can sometimes go off even if no entries have been leaked so this defines
// should be used with caution.
//
// If we are inside a .cctor when the application shut's down then the class init lock's
// head will be set and this will cause the assert to go off.
//
// If we are jitting a method when the application shut's down then the jit lock's head
// will be set causing the assert to go off.

//#define STRICT_JITLOCK_ENTRY_LEAK_DETECTION
//#define STRICT_CLSINITLOCK_ENTRY_LEAK_DETECTION

BOOL VerifyAllGlobalFunctions(Module *pModule);
BOOL VerifyAllMethodsForClass(Module *pModule, mdTypeDef cl, ClassLoader *pClassLoader);

Assembly::Assembly() :
    m_pDomain(NULL),
    m_pClassLoader(NULL),
    m_pDynamicCode(NULL),
    m_pManifest(NULL),
    m_pManifestFile(NULL),
    m_pManifestImport(NULL),
    m_pManifestAssemblyImport(NULL),
    m_pEntryPoint(NULL),
    m_tEntryModule(mdFileNil),
    m_kManifest(mdTokenNil),
    m_pwsFullName(NULL),
    m_psName(NULL),
    m_dwFlags(0),
    m_pZapAssembly(NULL),
    m_pZapPath(NULL),
    m_pwCodeBase(NULL),
    m_isDynamic(false),
    m_pOnDiskManifest(NULL),
    m_dwCodeBase(0),
    m_Context(NULL),
    m_pbPublicKey(NULL),
    m_cbPublicKey(0),
    m_pbRefedPublicKeyToken(NULL),
    m_cbRefedPublicKeyToken(0),
    m_pSharedSecurityDesc(NULL),
    m_ulHashAlgId(0),
    m_FreeFlag(0),
    m_pSecurityManager(NULL),
    m_pAllowedFiles(NULL),
    m_fIsShared(FALSE),
    m_pSharingProperties(NULL),
    m_debuggerFlags(DACF_NONE),
    m_pITypeLib(NULL),
    m_pbHashValue(NULL),
    m_fTerminated(FALSE),
    m_fAllowUntrustedCaller(FALSE),
    m_fCheckedForAllowUntrustedCaller(FALSE),
    m_pFusionAssembly(NULL),
    m_pFusionAssemblyName(NULL),
    m_dwDynamicAssemblyAccess(ASSEMBLY_ACCESS_RUN)
{
}

Assembly::~Assembly() 
{
    ReflectionModule *pAssemModule = NULL;
    Terminate();

    if (m_psName && (m_FreeFlag & FREE_NAME))
        delete[] m_psName;
    if (m_pbPublicKey && (m_FreeFlag & FREE_PUBLIC_KEY))
        delete[] m_pbPublicKey;
    if (m_pbStrongNameKeyPair && (m_FreeFlag & FREE_KEY_PAIR))
        delete[] m_pbStrongNameKeyPair;
    if (m_pwStrongNameKeyContainer && (m_FreeFlag & FREE_KEY_CONTAINER))
        delete[] m_pwStrongNameKeyContainer;
    if (m_Context) {
        if (m_Context->szLocale && (m_FreeFlag & FREE_LOCALE))
            delete[] m_Context->szLocale;

        delete m_Context;
    }

    if (m_pwsFullName)
        delete[] m_pwsFullName;

    if (m_pbHashValue)
        delete[] m_pbHashValue;

    if (m_pbRefedPublicKeyToken)
        StrongNameFreeBuffer(m_pbRefedPublicKeyToken);

    if(m_pSecurityManager) {
        m_pSecurityManager->Release();
        m_pSecurityManager = NULL;
    }

    if (m_pAllowedFiles)
    {
        delete(m_pAllowedFiles);
    }

    if (m_pSharingProperties)
    {
        // @todo jenh: put this back in when we get the counts correct
        // _ASSERTE(m_pSharingProperties->shareCount == 0);

        PEFileBinding *p = m_pSharingProperties->pDependencies;
        PEFileBinding *pEnd = p + m_pSharingProperties->cDependencies;
        while (p < pEnd)
        {
            if (p->pPEFile != NULL)
                delete p->pPEFile;
            p++;
        }
        
        delete m_pSharingProperties->pDependencies;
        delete m_pSharingProperties;
    }

    if (IsDynamic())
    {
        if (m_pOnDiskManifest)
        {
            // free the on disk manifest if it is not freed yet. Normally it is freed when we finish saving.
            // However, we can encouter error case such that user is aborting
            //
            if (m_pOnDiskManifest && m_fEmbeddedManifest == false)
                m_pOnDiskManifest->Destruct();
            m_pOnDiskManifest = NULL;
        }
    }

    if (m_pManifestFile && (m_FreeFlag & FREE_PEFILE))
        delete m_pManifestFile;

    ReleaseFusionInterfaces();

#if ZAP_RECORD_LOAD_ORDER
    if (m_pClassLoader)
        m_pClassLoader->CloseLoadOrderLogFiles();
#endif
}


HRESULT Assembly::Init(BOOL isDynamic)
{
    if (GetDomain() == SharedDomain::GetDomain())
    {
        SetShared();
        m_ExposedObjectIndex = SharedDomain::GetDomain()->AllocateSharedClassIndices(1);
        // Expand the current appdomain's DLS to cover at least the index we
        // just allocated, since security might try to access this slot before
        // we add any shared class indices.
        HRESULT hr;
        IfFailRet(GetAppDomain()->GetDomainLocalBlock()->SafeEnsureIndex(m_ExposedObjectIndex));
    }
    else
        m_ExposedObject = GetDomain()->CreateHandle(NULL);

    m_pClassLoader = new (nothrow) ClassLoader();
    if(!m_pClassLoader) return E_OUTOFMEMORY;
    
    m_pClassLoader->SetAssembly(this);
    m_isDynamic = isDynamic;
    if(!m_pClassLoader->Init()) {
        _ASSERTE(!"Unable to initialize the class loader");
        return E_OUTOFMEMORY;
    }

    m_pSharedSecurityDesc = SharedSecDescHelper::Allocate(this);
    if (!m_pSharedSecurityDesc) return E_OUTOFMEMORY;

    m_pAllowedFiles = new (nothrow) EEUtf8StringHashTable();
    if (!m_pAllowedFiles)
        return E_OUTOFMEMORY;

    COUNTER_ONLY(GetPrivatePerfCounters().m_Loading.cAssemblies++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Loading.cAssemblies++);

    return S_OK;
}

void Assembly::Terminate( BOOL signalProfiler )
{
    if (this->m_fTerminated)
        return;

#ifdef PROFILING_SUPPORTED
    // Signal profile if present.
    if (signalProfiler && CORProfilerTrackAssemblyLoads())
        g_profControlBlock.pProfInterface->AssemblyUnloadStarted((ThreadID) GetThread(), (AssemblyID) this);
#endif // PROFILING_SUPPORTED
    
    delete m_pSharedSecurityDesc;
    m_pSharedSecurityDesc = NULL;

    if(m_pClassLoader != NULL)
    {
        delete m_pClassLoader;
        m_pClassLoader = NULL;
    }

    // Release the dynamic code module
    if(m_pDynamicCode) 
    {
       m_pDynamicCode->Release();
       m_pDynamicCode = NULL;
    }

    if (m_pManifestImport)
    {
        m_pManifestImport->Release();
        m_pManifestImport=NULL;
    }

    if (m_pManifestAssemblyImport)
    {
        m_pManifestAssemblyImport->Release();
        m_pManifestAssemblyImport=NULL;
    }

    if (m_pZapPath)
    {
        delete [] (void*) m_pZapPath;
        m_pZapPath = NULL;
    }
        
    if(m_pwCodeBase) 
    {
        delete m_pwCodeBase;
        m_pwCodeBase = NULL;
        m_dwCodeBase = 0;
    }

    COUNTER_ONLY(GetPrivatePerfCounters().m_Loading.cAssemblies--);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Loading.cAssemblies--);

    if(g_fProcessDetach == FALSE) {
        __try {
            if (m_pITypeLib && m_pITypeLib != (ITypeLib*)-1) {
                m_pITypeLib->Release();
                m_pITypeLib = NULL;
            }
        }
        __except (COMPLUS_EXCEPTION_EXECUTE_HANDLER) 
        { }
    }
    
#ifdef PROFILING_SUPPORTED
    // Always signal the profiler.
    if (signalProfiler && CORProfilerTrackAssemblyLoads())
        g_profControlBlock.pProfInterface->AssemblyUnloadFinished((ThreadID) GetThread(), (AssemblyID) this, S_OK);
#endif // PROFILING_SUPPORTED

    this->m_fTerminated = TRUE;
    return;  // makes the compiler happy when PROFILING_SUPPORTED isn't defined
}  

void Assembly::ReleaseFusionInterfaces()
{
    if(SystemDomain::BeforeFusionShutdown()) {

        if (m_pZapAssembly) {
            m_pZapAssembly->Release();
            m_pZapAssembly = NULL;
        }

        if (m_pFusionAssembly) {
            m_pFusionAssembly->Release();
            m_pFusionAssembly = NULL;
        }
           
        if(m_pFusionAssemblyName) {
            m_pFusionAssemblyName->Release();
            m_pFusionAssemblyName = NULL;
        }
    }

}// ReleaseFusionInterfaces


void Assembly::AllocateExposedObjectHandle(AppDomain *pDomain)
{
    _ASSERTE(pDomain);

    DomainLocalBlock *pLocalBlock = pDomain->GetDomainLocalBlock();
        
    if (pLocalBlock->GetSlot(m_ExposedObjectIndex) == NULL)
        pLocalBlock->SetSlot(m_ExposedObjectIndex, pDomain->CreateHandle(NULL));
}


OBJECTREF Assembly::GetRawExposedObject(AppDomain *pDomain)
{
    OBJECTHANDLE hObject;
    
    //
    // Figure out which handle to use.
    //

    if (IsShared())
    {
        if (pDomain == NULL)
            pDomain = GetAppDomain();

        DomainLocalBlock *pLocalBlock = pDomain->GetDomainLocalBlock();
        
        hObject = (OBJECTHANDLE) pLocalBlock->GetSlot(m_ExposedObjectIndex);
        if (hObject == NULL)
            return NULL;
    }
    else
        hObject = m_ExposedObject;

    //
    // Now get the object from the handle.
    //

    return ObjectFromHandle(hObject);
}

OBJECTREF Assembly::GetExposedObject(AppDomain *pDomain)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTHANDLE hObject;
    
    //
    // Figure out which handle to use.
    //

    if (IsShared())
    {
        if (pDomain == NULL)
            pDomain = GetAppDomain();

        DomainLocalBlock *pLocalBlock = pDomain->GetDomainLocalBlock();
        
        //
        // Create the handle if necessary.  There should be no race
        // possible here, because we force create the handle before
        // we publish the assembly to other threads.  This is really
        // only here for the case when we need the handle earlier than
        // that (e.g. security)
        //

        hObject = (OBJECTHANDLE) pLocalBlock->GetSlot(m_ExposedObjectIndex);
        if (hObject == NULL)
        {
            hObject = pDomain->CreateHandle(NULL);
            pLocalBlock->SetSlot(m_ExposedObjectIndex, hObject);
        }
    }
    else
        hObject = m_ExposedObject;

    //
    // Now get the object from the handle.
    //

    OBJECTREF ref = ObjectFromHandle(hObject);
    if (ref == NULL)
    {
        MethodTable *pMT;
        if (IsDynamic())
            pMT = g_Mscorlib.GetClass(CLASS__ASSEMBLY_BUILDER);
        else
            pMT = g_Mscorlib.GetClass(CLASS__ASSEMBLY);

        // Create the assembly object
        ASSEMBLYREF obj = (ASSEMBLYREF) AllocateObject(pMT);

        if(obj == NULL)
            COMPlusThrowOM();

        obj->SetAssembly(this);

        StoreFirstObjectInHandle(hObject, (OBJECTREF) obj);

        return (OBJECTREF) obj;
    }

    return ref;
}

ListLock*  Assembly::GetClassInitLock()
{
    return m_pDomain->GetClassInitLock();
}

ListLock* Assembly::GetJitLock()
{
    // Use the same lock as class inits, so we can detect cycles between the two.
    return m_pDomain->GetClassInitLock();
}
    
LoaderHeap* Assembly::GetLowFrequencyHeap()
{
    return m_pDomain->GetLowFrequencyHeap();
}

LoaderHeap* Assembly::GetHighFrequencyHeap()
{
    return m_pDomain->GetHighFrequencyHeap();
}

LoaderHeap* Assembly::GetStubHeap()
{
    return m_pDomain->GetStubHeap();
}

BaseDomain* Assembly::GetDomain()
{
    _ASSERTE(m_pDomain);
    return static_cast<BaseDomain*>(m_pDomain);
}

TypeHandle Assembly::LoadTypeHandle(NameHandle* pName, OBJECTREF *pThrowable,
                                    BOOL dontLoadInMemoryType /*=TRUE*/)
{
    return m_pClassLoader->LoadTypeHandle(pName, pThrowable, dontLoadInMemoryType);
}

HRESULT Assembly::SetParent(BaseDomain* pParent)
{
    m_pDomain = pParent;
    return S_OK;
}

HRESULT Assembly::AddManifestMetadata(PEFile* pFile)
{
    _ASSERTE(pFile);
    
    m_pManifestImport = pFile->GetMDImport();
    m_pManifestImport->AddRef();
    
    if (FAILED(m_pManifestImport->GetAssemblyFromScope(&m_kManifest)))
        return COR_E_ASSEMBLYEXPECTED;

    m_Context = new (nothrow) AssemblyMetaDataInternal;
    TESTANDRETURNMEMORY(m_Context);

    ZeroMemory(m_Context, sizeof(AssemblyMetaDataInternal));
        
    if (m_psName && (m_FreeFlag & FREE_NAME)) {
        delete[] m_psName;
        m_FreeFlag ^= FREE_NAME;
    }
    m_pManifestImport->GetAssemblyProps(m_kManifest,
                                        (const void**) &m_pbPublicKey,
                                        &m_cbPublicKey,
                                        &m_ulHashAlgId,
                                        &m_psName,
                                        m_Context,
                                        &m_dwFlags);

    m_pManifestFile = pFile;
    return S_OK;
}

HRESULT Assembly::AddManifest(PEFile* pFile,
                              IAssembly* pIAssembly,
                              BOOL fProfile)
{
    HRESULT hr;

    //
    // Make sure we don't do this more than once.
    //
    if (m_pManifestImport)
        return S_OK;

#ifdef PROFILING_SUPPORTED
    // Signal profile if present.
    if (CORProfilerTrackAssemblyLoads() && fProfile)
        g_profControlBlock.pProfInterface->AssemblyLoadStarted((ThreadID) GetThread(), (AssemblyID) this);
#endif // PROFILING_SUPPORTED

    if (FAILED(hr = AddManifestMetadata(pFile)))
        return hr;

    LOG((LF_CLASSLOADER, 
         LL_INFO10, 
         "Added manifest: \"%s\".\n", 
         m_psName));

    // We have the manifest in this scope so save it off
    if(m_pManifest)
        return COR_E_BADIMAGEFORMAT; 

    if(pIAssembly == NULL && SystemDomain::GetStrongAssemblyStatus()) {
        if(!m_cbPublicKey) 
            return COR_E_TYPELOAD;
    }

    if(pIAssembly) {
        hr = SetFusionAssembly(pIAssembly);
        if(FAILED(hr)) return hr;
    }

    hr = CacheManifestExportedTypes();
    if(FAILED(hr)) return hr;
    hr = CacheManifestFiles();
    if(FAILED(hr)) return hr;
   
    // If the module containing the manifest has a token in the File Reference table
    // then that file will contain the real entry point for the assembly. When we
    // go to execute it will be necessary to get that module and find the entry
    // token stored the that modules header. If this module contains code as well
    // as the manifest then it may also contain the token pointing to the entry 
    // location. This case is handled by Assembly::AddModule().
    // InMemory modules do not have a header so we ignore them.
    IMAGE_COR20_HEADER *    Header = pFile->GetCORHeader();
    if ((!m_pEntryPoint) && TypeFromToken(Header->EntryPointToken) == mdtFile) 
        m_tEntryModule = Header->EntryPointToken;

    return hr;
}


// Returns;
// S_OK : if it was able to load the module
// S_FALSE : if the file reference is to a resource file and cannot be loaded
// S_FALSE but module set: module already set in file rid map
// otherwise it returns errors.
HRESULT Assembly::FindInternalModule(mdFile kFile,
                                     mdToken  mdTokenNotToLoad,
                                     Module** ppModule,
                                     OBJECTREF* pThrowable)
{
    HRESULT hr = S_OK;

    Module* pModule = m_pManifest->LookupFile(kFile);
    if(!pModule) {
        if (mdTokenNotToLoad != tdAllTypes)
            hr = LoadInternalModule(kFile, m_pManifestImport, 
                                    &pModule, pThrowable);
        else
            return E_FAIL;
    }

    if(SUCCEEDED(hr) && ppModule)
        *ppModule = pModule;

    return hr;
}

// Returns;
// S_OK : if it was able to load the module
// S_FALSE : if the file reference is to a resource file and cannot be loaded
// S_FALSE but module set: module already set in file rid map
// otherwise it returns errors.
HRESULT Assembly::LoadInternalModule(mdFile kFile, IMDInternalImport *pImport,
                                     Module** ppModule, OBJECTREF* pThrowable)
{
    HRESULT hr = S_OK;
    LPCSTR psModuleName = NULL;
    const BYTE* pHash;
    DWORD dwFlags = 0;
    ULONG dwHashLength = 0;

    pImport->GetFileProps(kFile,
                          &psModuleName,
                          (const void**) &pHash,
                          &dwHashLength,
                          &dwFlags);

    if(IsFfContainsMetaData(dwFlags)) {
        WCHAR pPath[MAX_PATH];
        hr = LoadInternalModule(psModuleName,
                                kFile,
                                m_ulHashAlgId,
                                pHash,
                                dwHashLength,
                                dwFlags,
                                pPath,
                                MAX_PATH,
                                ppModule,
                                pThrowable);
    }
    else
        hr = S_FALSE;

    return hr;

}

HRESULT Assembly::CopyCodeBase(LPCWSTR pCodeBase)
{
    if(pCodeBase) {
        DWORD lgth = (DWORD)(wcslen(pCodeBase) + 1);
        LPWSTR pwCodeBase = new (nothrow) WCHAR[lgth];
        if(!pwCodeBase) return E_OUTOFMEMORY;
        
        memcpy(pwCodeBase, pCodeBase, lgth*sizeof(WCHAR));
        m_dwCodeBase = lgth-1;
        
        if (FastInterlockCompareExchange((void**) &m_pwCodeBase,
                                         pwCodeBase,
                                         NULL))
            delete[] pwCodeBase;
    }
    return S_OK;
}


HRESULT Assembly::FindCodeBase(WCHAR* pCodeBase, DWORD* pdwCodeBase, BOOL fCopiedName)
{
    Module *pModule = m_pManifest;

    HRESULT hr = S_OK;
    if(pModule == NULL) 
        pModule = GetLoader()->m_pHeadModule;
    
    if(m_pManifestFile)
        return FindAssemblyCodeBase(pCodeBase, pdwCodeBase, (fCopiedName && GetDomain()->IsShadowCopyOn()));
    else if (pModule && pModule->IsPEFile())
        return pModule->GetPEFile()->FindCodeBase(pCodeBase, pdwCodeBase);
    else {
        if (*pdwCodeBase > 0)
            *pCodeBase = 0;
        else 
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

        *pdwCodeBase = 1;
    }

    return hr;
}

HRESULT Assembly::GetCodeBase(LPWSTR *pwCodeBase, DWORD* pdwCodeBase)
{
    // If the assembly does not have a code base then build one
    if(m_pwCodeBase == NULL) {
        WCHAR* pCodeBase = NULL;
        DWORD  dwCodeBase = 0;

        HRESULT hr = FindCodeBase(pCodeBase, &dwCodeBase, FALSE);
        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            pCodeBase = (WCHAR*) _alloca(dwCodeBase*sizeof(WCHAR));
            hr = FindCodeBase(pCodeBase, &dwCodeBase, FALSE);
        }
        if(FAILED(hr)) return hr;
        
        hr = CopyCodeBase(pCodeBase);
        if(FAILED(hr)) return hr;
    }
    
    if(pwCodeBase)
        *pwCodeBase = m_pwCodeBase;
    if(pdwCodeBase)
        *pdwCodeBase = m_dwCodeBase;
    
    return S_OK;
}

HRESULT Assembly::FindAssemblyCodeBase(WCHAR* pCodeBase, 
                                       DWORD* pdwCodeBase, 
                                       BOOL fCopiedName)
{
    HRESULT hr = S_OK;
    if(m_pFusionAssembly) {
        if(!fCopiedName) {
            IAssemblyName *pNameDef;
            DWORD dwSize = *pdwCodeBase;
            hr = m_pFusionAssembly->GetAssemblyNameDef(&pNameDef);
            if (SUCCEEDED(hr)) {
                hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pCodeBase, &dwSize);
                pNameDef->Release();
                
                // If we end up with no codebase then use the file name instead. 
                if((SUCCEEDED(hr) || HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) && dwSize == 0)
                    fCopiedName  = true;
                else
                    *pdwCodeBase = dwSize;
                
#ifdef _DEBUG
                if(SUCCEEDED(hr)) 
                    LOG((LF_CLASSLOADER, LL_INFO10, "Found Fusion CodeBase: \"%ws\".\n", pCodeBase));
#endif
                
            }
        }
        
        if(fCopiedName)
            return PEFile::FindCodeBase(m_pManifestFile->GetFileName(), pCodeBase, pdwCodeBase);

        return hr;
    }
    else 
        return m_pManifestFile->FindCodeBase(pCodeBase, pdwCodeBase);
}

HRESULT Assembly::SetFusionAssembly(IAssembly *pFusionAssembly)
{
    HRESULT hr;

    TIMELINE_AUTO(LOADER, "SetFusionAssembly");

    _ASSERTE(pFusionAssembly != NULL);

    if (m_pFusionAssembly) {
        m_pFusionAssemblyName->Release();
        m_pFusionAssembly->Release();
    }

    pFusionAssembly->AddRef();

    m_pFusionAssembly = pFusionAssembly;

    IfFailRet(pFusionAssembly->GetAssemblyNameDef(&m_pFusionAssemblyName));

    return hr;
}

AssemblySecurityDescriptor *Assembly::GetSecurityDescriptor(AppDomain *pDomain)
{
    AssemblySecurityDescriptor *pSecDesc;

    if (pDomain == NULL)
        pDomain = GetAppDomain();

    pSecDesc = m_pSharedSecurityDesc->FindSecDesc(pDomain);

    // If we didn't find a security descriptor for this appdomain context we
    // need to create one now.
    if (pSecDesc == NULL) {

        pSecDesc = AssemSecDescHelper::Allocate(pDomain);
        if (pSecDesc == NULL)
            return NULL;

        AssemblySecurityDescriptor* pNewSecDesc = pSecDesc->Init(this);

        if (pSecDesc == pNewSecDesc)
            pNewSecDesc->AddDescriptorToDomainList();

        pSecDesc = pNewSecDesc;
    }

    return pSecDesc;
}


HRESULT Assembly::LoadInternalModule(LPCSTR    pName,
                                     mdFile    kFile,
                                     DWORD     dwHashAlgorithm,
                                     const     BYTE*   pbHash,
                                     DWORD     cbHash,
                                     DWORD     flags,
                                     WCHAR*    pPath,
                                     DWORD     dwPath,
                                     Module    **ppModule,
                                     OBJECTREF *pThrowable)
{
#ifdef FUSION_SUPPORTED
    if(!pName || !*pName) return E_POINTER;
    _ASSERTE(m_pManifest);  // We need to have a manifest before we can load a module

    HRESULT hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    if (!kFile)
        goto ErrExit;

    #define MAKE_TRANSLATIONFAILED  return COR_E_BADIMAGEFORMAT
    MAKE_WIDEPTR_FROMUTF8(pwName, pName);
    #undef MAKE_TRANSLATIONFAILED

    if (!FusionBind::VerifyBindingStringW(pwName))
        goto raiseEvent;

    if(GetFusionAssembly())
        hr = GetFileFromFusion(pwName,
                               pPath,
                               dwPath);

    if(FAILED(hr) && HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME) != hr) {

        if (!(m_pManifest->GetFileName() && *(m_pManifest->GetFileName())))
            goto raiseEvent;

        wcscpy(pPath, m_pManifest->GetFileName());

        LOG((LF_CLASSLOADER, 
             LL_INFO10, 
             "Retrieving internal module for: \"%S\".\n", 
             pPath));

        // Save this point
        WCHAR* tail = wcsrchr(pPath, '\\');
        // Add the directory divider
        _ASSERTE(*tail == '\\');
        tail++;
        
        if ((DWORD) ((tail - pPath) + wcslen(pwName)) >= dwPath)
            goto ErrExit;

        // Add the name of the module
        wcscpy(tail, pwName);
    }

    if ((! (m_pManifestFile->IsDisplayAsm() || m_pManifestFile->IsWebPermAsm()) ) &&
        FAILED(hr = AssemblySpec::DemandFileIOPermission(pPath,
                                                         TRUE,
                                                         AssemblySpec::FILE_READ,
                                                         pThrowable)))
            return hr;

    hr = VerifyInternalModuleHash(pPath,
                                  dwHashAlgorithm,
                                  pbHash,
                                  cbHash,
                                  pThrowable);

    PEFile *pFile = NULL;
    if (SUCCEEDED(hr))
        // Modules may come from fusion but we don't care
        hr = SystemDomain::LoadFile(pPath, 
                                    this, 
                                    kFile,
                                    FALSE, 
                                    NULL, 
                                    NULL,  // code base is determined by the assembly not the module
                                    NULL,
                                    &pFile, 
                                    IsFfContainsNoMetaData(flags));

    if(hr == S_OK) {
        hr = LoadFoundInternalModule(pFile,
                                     kFile,
                                     IsFfContainsNoMetaData(flags),
                                     ppModule,
                                     pThrowable);
    }
    else if (!ModuleFound(hr)) {
    raiseEvent:

        // Module not found
        Module* pModule = RaiseModuleResolveEvent(pName, pThrowable);

        if (pModule &&
            (pModule == m_pManifest->LookupFile(kFile))) {
            hr = S_OK;
            if(ppModule) *ppModule = pModule;
        }
    }

 ErrExit:
    if (FAILED(hr))
        PostFileLoadException(pName, FALSE, NULL, hr, pThrowable);

    return hr;
#else // !FUSION_SUPPORTED
    return E_NOTIMPL;
#endif // !FUSION_SUPPORTED
}

HRESULT Assembly::VerifyInternalModuleHash(WCHAR*      pPath,
                                           DWORD       dwHashAlgorithm,
                                           const BYTE* pbHash,
                                           DWORD       cbHash,
                                           OBJECTREF*  pThrowable)
{
    HRESULT hr = S_OK;
    if ( !m_pManifestFile->HashesVerified() &&
         (m_cbPublicKey ||
          m_pManifest->GetSecurityDescriptor()->IsSigned()) ) {

        if (!pbHash)
            return CRYPT_E_HASH_VALUE;

        // The hash was originally done on the entire file, as a data file.
        // When we normally load this file at runtime, we may not load the
        // entire file, and it's not loaded as a data file, anyway.  So,
        // unfortunately, we must reload, or fail the hash verification.
        PBYTE pbBuffer;
        DWORD dwResultLen;
        
        hr = ReadFileIntoMemory(pPath, &pbBuffer, &dwResultLen);
        if (FAILED(hr))
            return hr;
        hr = VerifyHash(pbBuffer,
                        dwResultLen,
                        dwHashAlgorithm,
                        pbHash,
                        cbHash);
        delete[] pbBuffer;
    }

    return hr;
}

HRESULT Assembly::LoadFoundInternalModule(PEFile    *pFile,
                                          mdFile    kFile,
                                          BOOL      fResource,
                                          Module    **ppModule,
                                          OBJECTREF *pThrowable)
{
    if (!pFile)
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    BaseDomain* pDomain = GetDomain();
    _ASSERTE(pDomain);

    HRESULT hr = S_OK;
    Module *pModule = NULL;
    pDomain->EnterLoadLock();
    EE_TRY_FOR_FINALLY {
    // Check if this module has already been added
    Module* pRidModule = m_pManifest->LookupFile(kFile);
    if (pRidModule) {
        delete pFile;
        if(ppModule) *ppModule = pRidModule;
        return S_FALSE; // returning in the FINALLY is expensive, but this is an error path.
    }
    
    pModule = pDomain->FindModule(pFile->GetBase());
            
    // Make sure it is not us.
    if (pModule) {
        if (pModule->GetAssembly() != this)
            pModule = NULL;
        else
            delete pFile;
    }

    if (!pModule) {
        if (fResource)
            hr = Module::CreateResource(pFile, &pModule);
        else  {

            PEFile *pZapFile = GetZapFile(pFile);

            if (pZapFile == NULL
                && (m_pZapAssembly != NULL || m_pZapPath != NULL) // OK if we don't have an assembly zap for a valid reason
                && g_pConfig->RequireZaps()) {

                _ASSERTE(!"Couldn't get zap file for module");
                hr = COR_E_FILENOTFOUND;
                delete pFile;
            }
            else
                hr = Module::Create(pFile, pZapFile, &pModule,
                                    CORDebuggerEnCMode(GetDebuggerInfoBits()));
        }
    }

    if(SUCCEEDED(hr)) {
        if (fResource) {
            DWORD dwModuleIndex;
            // If InsertModule fails, it has already been added.
            hr = m_pClassLoader->InsertModule(pModule, kFile, &dwModuleIndex);
            if (hr == S_OK)
                pModule->SetContainer(this, dwModuleIndex, kFile, true, pThrowable);
        }
        else
            hr = AddModule(pModule, kFile, FALSE, pThrowable);
    }
    
    }
    EE_FINALLY {
        pDomain->LeaveLoadLock();
    } EE_END_FINALLY;
    
    if(SUCCEEDED(hr)) {
        hr = S_OK;
        if(ppModule) *ppModule = pModule;
    }

    return hr;
}

#define ConvertAssemblyRefToContext(pContext, pI)                                             \
    pContext.usMajorVersion = pI.usMajorVersion;                                              \
    pContext.usMinorVersion = pI.usMinorVersion;                                              \
    pContext.usBuildNumber = pI.usBuildNumber;                                                \
    pContext.usRevisionNumber = pI.usRevisionNumber;                                          \
    if(pI.szLocale) {                                                                         \
        MAKE_WIDEPTR_FROMUTF8(pLocale, pI.szLocale);                                          \
        pContext.szLocale = pLocale;                                                          \
        pContext.cbLocale = wcslen(pLocale) + 1;                                              \
    } else {                                                                                  \
        pContext.szLocale = NULL;                                                             \
        pContext.cbLocale = 0;                                                                \
    }


// Returns S_OK
//         
HRESULT Assembly::FindExternalAssembly(Module* pTokenModule,
                                       mdAssemblyRef kAssemblyRef,
                                       IMDInternalImport *pImport, 
                                       mdToken mdTokenNotToLoad,
                                       Assembly** ppAssembly,
                                       OBJECTREF* pThrowable)
{
    HRESULT hr = S_OK;
    Assembly* pFoundAssembly = pTokenModule->LookupAssemblyRef(kAssemblyRef);
    if(!pFoundAssembly) {
        // Get the referencing assembly. This is used 
        // as a hint to find the location of the other assembly
        Assembly* pAssembly = pTokenModule->GetAssembly();

        // we do not care about individual tokens since this is out of scope.
        // When mdTokenNotToLoad is set to a single typedef it stops recursive
        // loads and this can not happen with external references.
        if (mdTokenNotToLoad != tdAllTypes) {

            hr = LoadExternalAssembly(kAssemblyRef,
                                      pImport,
                                      pAssembly,
                                      &pFoundAssembly,
                                      pThrowable);
            if(SUCCEEDED(hr)) {
                if(!pTokenModule->StoreAssemblyRef(kAssemblyRef, pFoundAssembly))
                    hr = E_OUTOFMEMORY;
            }
        }
        else
            return E_FAIL;
    }     

    if(SUCCEEDED(hr) && ppAssembly)
        *ppAssembly = pFoundAssembly;

    return hr;
}

// Returns S_OK
//         
HRESULT Assembly::LoadExternalAssembly(mdAssemblyRef      kAssemblyRef, 
                                       IMDInternalImport* pImport, 
                                       Assembly*          pAssembly,
                                       Assembly**         ppAssembly,
                                       OBJECTREF*         pThrowable)
{
    AssemblySpec spec;
    HRESULT hr;

    if (FAILED(hr = spec.InitializeSpec(kAssemblyRef, pImport, pAssembly)))
        return hr;

    //Strong assemblies should not be able to reference simple assemblies.
    if (pAssembly->m_cbPublicKey &&
        (!spec.IsStronglyNamed())) {
        #define MAKE_TRANSLATIONFAILED szName=""
        MAKE_UTF8PTR_FROMWIDE(szName,
                              spec.GetName() ? L"" : spec.GetCodeBase()->m_pszCodeBase);
        #undef MAKE_TRANSLATIONFAILED

        LOG((LF_CLASSLOADER, LL_ERROR, "Could not load assembly '%s' because it was not strongly-named\n", spec.GetName() ? spec.GetName() : szName));
        
        PostFileLoadException(spec.GetName() ? spec.GetName() : szName, 
                              FALSE,NULL, FUSION_E_PRIVATE_ASM_DISALLOWED, pThrowable);
        return FUSION_E_PRIVATE_ASM_DISALLOWED;
    }

    return spec.LoadAssembly(ppAssembly, pThrowable);
}


/* static */
HRESULT Assembly::VerifyHash(PBYTE pbBuffer,
                             DWORD dwBufferLen,
                             ALG_ID iHashAlg,
                             const BYTE* pbGivenValue,
                             DWORD cbGivenValue)
{
    PBYTE pbCurrentValue = NULL;
    DWORD cbCurrentValue;

    // If hash is not provided, then don't verify it!
    if (cbGivenValue == 0)
        return NOERROR;

    HRESULT hr = GetHash(pbBuffer,
                         dwBufferLen,
                         iHashAlg,
                         &pbCurrentValue,
                         &cbCurrentValue);
    if (FAILED(hr))
        return hr;

    if (cbCurrentValue != cbGivenValue)
        hr = COR_E_MODULE_HASH_CHECK_FAILED;
    else {
        if (memcmp(pbCurrentValue, pbGivenValue, cbCurrentValue))
            hr = COR_E_MODULE_HASH_CHECK_FAILED;
        else
            hr = S_OK;
    }

    delete[] pbCurrentValue;
    return hr;
}

/* static */
// You should delete[] pbCurrentValue when you're through with it, if GetHash
// returns S_OK
HRESULT Assembly::GetHash(WCHAR*    strFullFileName,
                          ALG_ID    iHashAlg,
                          BYTE**    pbCurrentValue, // should be NULL
                          DWORD*    cbCurrentValue)
{
    HRESULT     hr;
    PBYTE       pbBuffer = 0;
    DWORD       dwBufLen = 0;;

    IfFailGo(ReadFileIntoMemory(strFullFileName, &pbBuffer, &dwBufLen));
    hr = GetHash(pbBuffer, dwBufLen, iHashAlg, pbCurrentValue, cbCurrentValue);
ErrExit:
    if (pbBuffer)
        delete[] pbBuffer;
    return S_OK;
}

/* static */
// You should delete[] ppbBuffer when you're through with it, if ReadFileIntoMemory
// returns S_OK
HRESULT Assembly::ReadFileIntoMemory(LPCWSTR    strFullFileName,
                                     BYTE**     ppbBuffer,
                                     DWORD*     pdwBufLen)
{
    // The hash needs to be done on the entire file, as a data file.
    HANDLE hFile = WszCreateFile(strFullFileName,
                                 GENERIC_READ,
                                 FILE_SHARE_READ,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                 NULL);
    if (hFile == INVALID_HANDLE_VALUE)
        return HRESULT_FROM_WIN32(GetLastError());

    DWORD dwFileLen = SafeGetFileSize(hFile, 0);
    if (dwFileLen == 0xffffffff)
    {
        CloseHandle(hFile);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    _ASSERTE(ppbBuffer);
    *ppbBuffer = new (nothrow) BYTE[dwFileLen];
    if (*ppbBuffer == NULL)
    {
        CloseHandle(hFile);
        return E_OUTOFMEMORY;
    }
      
    if ((SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) ||
        (!ReadFile(hFile, *ppbBuffer, dwFileLen, pdwBufLen, NULL))) {
        CloseHandle(hFile);
        delete[] *ppbBuffer;
        *ppbBuffer = 0;
        return HRESULT_FROM_WIN32(GetLastError());
    }
    _ASSERTE(dwFileLen == *pdwBufLen);
    CloseHandle(hFile);
    return S_OK;
}   // Assembly::ReadFileIntoMemory

/* static */
// You should delete[] pbCurrentValue when you're through with it, if GetHash
// returns S_OK
HRESULT Assembly::GetHash(PBYTE pbBuffer,
                          DWORD dwBufferLen,
                          ALG_ID iHashAlg,
                          BYTE** pbCurrentValue,  // should be NULL
                          DWORD *cbCurrentValue)
{
    HRESULT    hr;
    HCRYPTPROV hProv = 0;
    HCRYPTHASH hHash = 0;
    DWORD      dwCount = sizeof(DWORD);

    if (*pbCurrentValue)
        return E_POINTER;

#ifdef _X86_
    // If the hash algorithm is SHA1, we can use a simple SHA1 hasher we have
    // statically linked into the runtime and avoid loading the entire CryptoAPI
    // infrastructure.
    if (iHashAlg == CALG_SHA1) {
        A_SHA_CTX ctx;

        *cbCurrentValue = A_SHA_DIGEST_LEN;
        *pbCurrentValue = new (nothrow) BYTE[*cbCurrentValue];
        if (!(*pbCurrentValue))
            return E_OUTOFMEMORY;

        A_SHAInit(&ctx);
        A_SHAUpdate(&ctx, pbBuffer, dwBufferLen);
        A_SHAFinal(&ctx, *pbCurrentValue);

        return S_OK;
    }
#endif

    // No need to late bind this stuff, all these crypto API entry points happen
    // to live in ADVAPI32.

    if ((!WszCryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) ||
        (!CryptCreateHash(hProv, iHashAlg, 0, 0, &hHash)) ||
        (!CryptHashData(hHash, pbBuffer, dwBufferLen, 0)) ||
        (!CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE *) cbCurrentValue, 
                            &dwCount, 0))) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    // @todo:  It may be faster to map the file into memory than read it into
    // memory in one shot.  Investigate.
    *pbCurrentValue = new (nothrow) BYTE[*cbCurrentValue];
    if (!(*pbCurrentValue)) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if(!CryptGetHashParam(hHash, HP_HASHVAL, *pbCurrentValue, cbCurrentValue, 0)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        delete[] *pbCurrentValue;
        *pbCurrentValue = 0;
        goto exit;
    }

    hr = S_OK;

 exit:
    if (hHash)
        CryptDestroyHash(hHash);
    if (hProv)
        CryptReleaseContext(hProv, 0);

    return hr;
}

HRESULT Assembly::FindModuleByExportedType(mdExportedType mdType, 
                                           mdToken tokenNotToLoad,
                                           mdTypeDef mdNested, 
                                           Module** ppModule,
                                           mdTypeDef* pCL, 
                                           OBJECTREF *pThrowable)
{
    HRESULT hr;
    mdToken mdLinkRef;
    mdToken mdBinding;
    LPCSTR pszNameSpace;
    LPCSTR pszName;

    m_pManifestImport->GetExportedTypeProps(mdType,
                                            &pszNameSpace,
                                            &pszName,
                                            &mdLinkRef, //impl
                                            &mdBinding, // Hint
                                            NULL); // dwflags

    switch(TypeFromToken(mdLinkRef)) {
    case mdtAssemblyRef:
        Assembly *pFoundAssembly;
        hr = FindExternalAssembly(m_pManifest,
                                  mdLinkRef,
                                  m_pManifestImport,
                                  tokenNotToLoad,
                                  &pFoundAssembly,
                                  pThrowable);
        if (SUCCEEDED(hr)) {
            *pCL = mdTypeDefNil;  // We don't trust the mdBinding token
            *ppModule = pFoundAssembly->m_pManifest;
        }
        break;

    case mdtFile:

        if (mdLinkRef == mdFileNil) {
            *ppModule = m_pManifest;  // type is in same file as manifest
            hr = S_OK;
        }
        else
            hr = FindInternalModule(mdLinkRef,
                                    tokenNotToLoad,
                                    ppModule,
                                    pThrowable);

        // We may not want to trust this TypeDef token, since it
        // was saved in a scope other than the one it was defined in
        if(SUCCEEDED(hr)) {
            if (mdNested == mdTypeDefNil)
                *pCL = mdBinding;
            else
                *pCL = mdNested;
        }
        break;

    case mdtExportedType:
        // Only override the nested type token if it hasn't been set yet.
        if (mdNested != mdTypeDefNil)
            mdBinding = mdNested;
        return FindModuleByExportedType(mdLinkRef, tokenNotToLoad, mdBinding,
                                        ppModule, pCL, pThrowable);

    default:
        hr = COR_E_BADIMAGEFORMAT;
        BAD_FORMAT_ASSERT(!"Invalid token type");
    }

    return hr;
}

// Returns CLDB_S_NULL if nil-scoped token
HRESULT Assembly::FindAssemblyByTypeRef(NameHandle* pName,
                                        Assembly** ppAssembly,
                                        OBJECTREF *pThrowable)
{
    HRESULT hr = E_FAIL;
    _ASSERTE(pName);
    _ASSERTE(pName->GetTypeModule());
    _ASSERTE(pName->GetTypeToken());
    _ASSERTE(ppAssembly);

    IMDInternalImport *pImport = pName->GetTypeModule()->GetMDImport();
    mdTypeRef tkType = pName->GetTypeToken();
    _ASSERTE(TypeFromToken(tkType) == mdtTypeRef);

    // If nested, get top level encloser's impl
    do {
        tkType = pImport->GetResolutionScopeOfTypeRef(tkType);
        if (IsNilToken(tkType)) {
            *ppAssembly = this;
            return CLDB_S_NULL;  // nil-scope TR okay if there's an ExportedType
        }
    } while (TypeFromToken(tkType) == mdtTypeRef);

    switch (TypeFromToken(tkType)) {
    case mdtModule:
        *ppAssembly = pName->GetTypeModule()->GetAssembly();
        return S_OK;

    case mdtModuleRef:
        Module *pModule;
        if (SUCCEEDED(hr = FindModuleByModuleRef(pImport,
                                                 tkType,
                                                 pName->GetTokenNotToLoad(),
                                                 &pModule,
                                                 pThrowable)))
            *ppAssembly = pModule->GetAssembly();
        break;
        
    case mdtAssemblyRef:
        return FindExternalAssembly(pName->GetTypeModule(),
                                  tkType, 
                                  pImport, 
                                  pName->GetTokenNotToLoad(),
                                  ppAssembly, 
                                  pThrowable);

    default:
        // null token okay if there's an ExportedType
        if (IsNilToken(tkType)) {
            *ppAssembly = this;
            return CLDB_S_NULL;
        }

        _ASSERTE(!"Invalid token type");
    }

    return hr;
}

HRESULT Assembly::FindModuleByModuleRef(IMDInternalImport *pImport,
                                        mdModuleRef tkMR,
                                        mdToken tokenNotToLoad,
                                        Module** ppModule,
                                        OBJECTREF *pThrowable)
{
    // get the ModuleRef, match it by name to a File
    LPCSTR pszModuleName;
    HashDatum datum;
    Module *pFoundModule;
    HRESULT hr = COR_E_DLLNOTFOUND;

    if(pImport->IsValidToken(tkMR))
    {
        pImport->GetModuleRefProps(tkMR, &pszModuleName);

        if (m_pAllowedFiles->GetValue(pszModuleName, &datum)) {
            if (datum) { // internal module
                hr = FindInternalModule((mdFile)(size_t)datum,
                                        tokenNotToLoad,
                                        &pFoundModule,
                                        pThrowable);
                if (SUCCEEDED(hr) && pFoundModule)
                    *ppModule = pFoundModule;
            }
            else { // manifest file
                *ppModule = m_pManifest;
                hr = S_OK;
            }
        }
        else
            hr = COR_E_UNAUTHORIZEDACCESS;
    }
    return hr;
}

// Determines if the module contains an assembly.
/* static */
HRESULT Assembly::CheckFileForAssembly(PEFile* pFile)
{
    mdAssembly kManifest;
    HRESULT hr;
    
    IMDInternalImport *pMDImport = pFile->GetMDImport(&hr);
    if (!pMDImport)
        return hr;

    if(pFile->GetMDImport()->GetAssemblyFromScope(&kManifest) == S_OK) 
        return S_OK;

    return COR_E_ASSEMBLYEXPECTED;
}

BOOL Assembly::IsAssembly()
{
    return (mdTokenNil != m_kManifest);
}

HRESULT Assembly::CacheManifestExportedTypes()
{
    _ASSERTE(IsAssembly());
    _ASSERTE(m_pManifestImport);

    HRESULT hr;
    HENUMInternal phEnum;
    mdToken mdExportedType;
    mdToken mdImpl;
    LPCSTR pszName;
    LPCSTR pszNameSpace;
        
    hr = m_pManifestImport->EnumInit(mdtExportedType,
                                     mdTokenNil,
                                     &phEnum);

    if (SUCCEEDED(hr)) {
        m_pClassLoader->LockAvailableClasses();

        for(int i = 0; m_pManifestImport->EnumNext(&phEnum, &mdExportedType); i++) {
            if(TypeFromToken(mdExportedType) == mdtExportedType) {
                m_pManifestImport->GetExportedTypeProps(mdExportedType,
                                                        &pszNameSpace,
                                                        &pszName,
                                                        &mdImpl,
                                                        NULL,   // type def
                                                        NULL); // flags
                IfFailGo(m_pClassLoader->AddExportedTypeHaveLock(pszNameSpace, pszName, mdExportedType, m_pManifestImport, mdImpl));
            }
        }
        
    ErrExit:
        m_pClassLoader->UnlockAvailableClasses();
        m_pManifestImport->EnumClose(&phEnum);
    }

    return hr;
}                      
                      

HRESULT Assembly::CacheManifestFiles()
{
    HENUMInternal phEnum;
    mdToken tkFile;
    LPCSTR pszFileName;
    int i;

    HRESULT hr = m_pManifestImport->EnumInit(mdtFile,
                                             mdTokenNil,
                                             &phEnum);

    if (SUCCEEDED(hr)) {
        DWORD dwCount = m_pManifestImport->EnumGetCount(&phEnum);
        if (!m_pAllowedFiles->Init(dwCount ? dwCount+1 : 1, NULL))
            IfFailGo(E_OUTOFMEMORY);
    
        for(i = 0; m_pManifestImport->EnumNext(&phEnum, &tkFile); i++) {

            if(TypeFromToken(tkFile) == mdtFile) {
                m_pManifestImport->GetFileProps(tkFile,
                                                &pszFileName,
                                                NULL,  // hash
                                                NULL,  // hash len
                                                NULL); // flags

                // Add each internal module
                if (!m_pAllowedFiles->InsertValue(pszFileName, (HashDatum)(size_t)tkFile, FALSE))
                    IfFailGo(E_OUTOFMEMORY);
            }
        }

        // Add the manifest file
        if (m_pManifestImport->IsValidToken(m_pManifestImport->GetModuleFromScope())) {
            m_pManifestImport->GetScopeProps(&pszFileName, NULL);
            if (!m_pAllowedFiles->InsertValue(pszFileName, NULL, FALSE))
                hr = E_OUTOFMEMORY;
        }
        else
            hr = COR_E_BADIMAGEFORMAT;


    ErrExit:
        m_pManifestImport->EnumClose(&phEnum);

    }

    return hr;
}                      

HRESULT Assembly::GetModuleFromFilename(LPCWSTR wszModuleFilename,
                                        Module **ppModule)
{
    _ASSERTE(wszModuleFilename && ppModule);

    // Sensible default value
    *ppModule = NULL;

    // Let's split up the module name in case the caller provided a full
    // path, which makes no sense in the case of a manifest
    // The file name could be fully qualified, so need to chop it apart.
    {
        WCHAR *wszName = (WCHAR *)_alloca(MAX_PATH * sizeof(WCHAR));
        WCHAR wszExt[MAX_PATH];
        SplitPath(wszModuleFilename, NULL, NULL, wszName, wszExt);

        // Concat the extension
        wcscat(wszName, wszExt);

        // Replace the pointer provided with our own
        wszModuleFilename = wszName;
    }

    // First, check the manifest's file, since the manifest does not enumerate
    // itself
    {
        PEFile *pManFile = GetManifestFile();
        if (!pManFile)
            return (COR_E_NOTSUPPORTED); // Fails for dynamic modules

        // The file name could be fully qualified, so need to chop it apart.
        WCHAR wszName[MAX_PATH];
        WCHAR wszExt[MAX_PATH];
        SplitPath(pManFile->GetFileName(), NULL, NULL, wszName, wszExt);

        // Concat the extension
        wcscat(wszName, wszExt);

        // Compare the two names
        if (_wcsicmp(wszName, wszModuleFilename) == 0)
        {
            // So the manifest is also the module, so set it
            *ppModule = GetManifestModule();
            _ASSERTE(*ppModule);

            return (S_OK);
        }
    }

    // Next, have a look in the cache of files associated with the manifest
    {
        // This stuff is all done with UTF8 strings, so we need to
        // convert the wide string passed in.
        #define MAKE_TRANSLATIONFAILED return E_INVALIDARG;
        MAKE_UTF8PTR_FROMWIDE(szModuleFilename, wszModuleFilename);
        #undef MAKE_TRANSLATIONFAILED
        _ASSERTE(szModuleFilename);

        mdToken tkFile;
#ifdef _DEBUG
        tkFile = mdFileNil;
#endif //_DEBUG

        // Do a lookup in the hash
        BOOL fRes = m_pAllowedFiles->GetValue(szModuleFilename, (HashDatum *) &tkFile);

        // If we successfully found a match
        if (fRes)
        {
#ifdef _DEBUG
            _ASSERTE(tkFile != mdFileNil);
#endif //_DEBUG

            OBJECTREF objThrow = NULL;
            GCPROTECT_BEGIN(objThrow);

            // Try to get the Module for this filename
            HRESULT hr = FindInternalModule(tkFile, mdTokenNil, ppModule, &objThrow);

            // If an exception was thrown, convert it to an hr
            if (FAILED(hr) && objThrow != NULL)
                hr = SecurityHelper::MapToHR(objThrow);

            GCPROTECT_END();

            // Found it, so quit the search
            _ASSERTE(*ppModule);
            return (S_OK);
        }
    }

    return (E_FAIL);
}


//@TODO: if module is not signed it needs to acquire the 
//permissions from the assembly.
HRESULT Assembly::AddModule(Module* module, mdFile kFile, BOOL fNeedSecurity, OBJECTREF *pThrowable)
{
    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(m_pClassLoader);
    _ASSERTE(module);


    COMPLUS_TRY
    {
        // @TODO: rip out the index
        DWORD index;
        // If InsertModule returns S_FALSE, it has already been added.
        hr = m_pClassLoader->InsertModule(module, kFile, &index);
        if (hr != S_OK) {
            if (hr == S_FALSE)
                return S_OK;
            return hr;
        }

#ifdef PROFILING_SUPPORTED
        // Signal profile if present, but only in legacy mode
        if (CORProfilerTrackAssemblyLoads() && m_pManifest == NULL)
            g_profControlBlock.pProfInterface->AssemblyLoadStarted((ThreadID) GetThread(), (AssemblyID) this);
#endif PROFILING_SUPPORTED
        
    
         // @TODO: RM, remove security stuff once implicit assemblies are no longer
        // supported (and move the code into something like CacheManifest).
        AssemblySecurityDescriptor *pSec = GetSecurityDescriptor();
        _ASSERTE(pSec);

        if(fNeedSecurity)
            pSec->SetSecurity(module->IsSystem() ? true : false);

        if( module->IsPEFile() ) {
            // Check to see if the entry token stored in the header is a token for a MethodDef.
            // If it is then this is the entry point that is called. We don't want to do this if
            // the module is InMemory because it will not have a header.
            IMAGE_COR20_HEADER *pHeader = module->GetCORHeader();
            if (m_pEntryPoint == NULL && TypeFromToken(pHeader->EntryPointToken) == mdtMethodDef) 
                m_pEntryPoint = module;
        }

        TIMELINE_START(LOADER, ("EarlyResolve"));

        // If explicit permission requests were made we should
        // resolve policy now in case we can't grant the minimal
        // required permissions.
        if (fNeedSecurity &&
            Security::IsSecurityOn() &&
            (!module->IsSystem()) &&
            (m_dwDynamicAssemblyAccess != ASSEMBLY_ACCESS_SAVE)) {
            IfFailRet(Security::EarlyResolve(this, pSec, pThrowable));
        }

        TIMELINE_END(LOADER, ("EarlyResolve"));

        // Set up the module side caching of meta data, stubs, etc.
        hr = module->SetContainer(this, index, kFile, false, pThrowable);
        if(FAILED(hr)) return hr;

    #ifdef PROFILING_SUPPORTED
        // Signal the profiler that the assembly is loaded.  This is done only in legacy mode,
        // since it is signalled in LoadManifest method in non-legacy mode.  This is ok, since
        // legacy mode only has one module per assembly and this will thus only be called once.
        if (CORProfilerTrackAssemblyLoads() && m_pManifest == NULL)
            g_profControlBlock.pProfInterface->AssemblyLoadFinished((ThreadID) GetThread(), (AssemblyID) this, hr);
    #endif // PROFILING_SUPPORTED
    
    #ifdef DEBUGGING_SUPPORTED
        // Modules take the DebuggerAssemblyControlFlags down from its
        // parent Assembly initially.
        module->SetDebuggerInfoBits(GetDebuggerInfoBits());

        LOG((LF_CORDB, LL_INFO10, "Module %S: bits=0x%x\n",
             module->GetFileName(),
             module->GetDebuggerInfoBits()));
    #endif // DEBUGGING_SUPPORTED

    #ifdef _DEBUG
        // Force the CodeBase to be found in debug mode.
        LPWSTR pName;
        DWORD  dwLength;
        hr = GetCodeBase(&pName, &dwLength);
    #endif

    } 
    COMPLUS_CATCH 
    {
        OBJECTREF Throwable = NULL;
        GCPROTECT_BEGIN( Throwable );
        Throwable = GETTHROWABLE();
        hr = SecurityHelper::MapToHR(Throwable);
        if (pThrowable != NULL) 
            *pThrowable = Throwable;
        GCPROTECT_END();
    } 
    COMPLUS_END_CATCH

    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

HRESULT Assembly::InitializeSecurityManager()
{
#ifdef PLATFORM_CE
    return E_NOTIMPL;
#else // !PLATFORM_CE
    HRESULT hr = S_OK;
    if(m_pSecurityManager == NULL) {

        hr = CoInternetCreateSecurityManager(NULL,
                                             &m_pSecurityManager,
                                             0);
    }
    return hr;
#endif // !PLATFORM_CE
}

    
// Returns security information for the assembly based on the codebase
HRESULT Assembly::GetSecurityIdentity(LPWSTR *ppCodebase, DWORD *pdwZone, BYTE *pbUniqueID, DWORD *pcbUniqueID)
{
    HRESULT hr = S_OK;

#ifndef PLATFORM_CE
    DWORD dwCodebase = 0;
    
    BEGIN_ENSURE_PREEMPTIVE_GC();
    
    hr = GetCodeBase(ppCodebase, &dwCodebase);
    if(SUCCEEDED(hr) && dwCodebase) {
        *pdwZone = Security::QuickGetZone( *ppCodebase );

        if (*pdwZone == -1)
        {
            DWORD flags = 0;

            hr = InitializeSecurityManager();
            IfFailGoto(hr, exit);

            // We have a class name, return a class factory for it
            hr = m_pSecurityManager->MapUrlToZone(*ppCodebase,
                                                  pdwZone,
                                                  flags);
            IfFailGoto(hr, exit);
        
            hr = m_pSecurityManager->GetSecurityId(*ppCodebase,
                                                   pbUniqueID,
                                                   pcbUniqueID,
                                                   0);
            IfFailGoto(hr, exit);
        }
        else
        {
            pbUniqueID = 0;
        }
    }

exit:

    END_ENSURE_PREEMPTIVE_GC();

#endif // !PLATFORM_CE
    return hr;
}

Module* Assembly::FindAssembly(BYTE *pBase)
{
    
    if(m_pManifest && m_pManifest->GetILBase() == pBase)
        return m_pManifest;
    else
        return NULL;
}
       
Module* Assembly::FindModule(BYTE *pBase)
{
    _ASSERTE(m_pClassLoader);
    
    if(m_pManifest && m_pManifest->GetILBase() == pBase)
        return m_pManifest;

    
    Module* pModule = m_pClassLoader->m_pHeadModule;
    while (pModule)
    {
        if (pModule->GetILBase() == pBase)
            break;
        pModule = pModule->GetNextModule();
    }
    return pModule;
}


TypeHandle Assembly::LookupTypeHandle(NameHandle* pName, 
                                      OBJECTREF* pThrowable)
{
    return m_pClassLoader->LookupTypeHandle(pName, pThrowable);
}


TypeHandle Assembly::GetInternalType(NameHandle* typeName, BOOL bThrowOnError,
                                     OBJECTREF *pThrowable)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle typeHnd;       
    HENUMInternal phEnum;
    HRESULT hr;
    //_ASSERTE(pThrowableAvailable(pThrowable));

    // load a file that hasn't been loaded, then check if the type's there
    if (FAILED(hr = m_pManifestImport->EnumInit(mdtFile,
                                                mdTokenNil,
                                                &phEnum))) {
        if (bThrowOnError) {
            DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
            COMPlusThrowHR(hr);
        }
        return typeHnd;
    }

    bool FileSkipped = false;
    mdToken mdFile;
    while (m_pManifestImport->EnumNext(&phEnum, &mdFile)) {
        if (m_pManifest->LookupFile(mdFile))
            FileSkipped = true;
        else{
            if (FAILED(LoadInternalModule(mdFile,
                                          m_pManifestImport,
                                          NULL, // ppModule
                                          pThrowable))) {
                m_pManifestImport->EnumClose(&phEnum);
                //if (pThrowableAvailable(pThrowable) && bThrowOnError) {
                //DEBUG_SAFE_TO_THROW_IN_THIS_BLOCK;
                    COMPlusThrow(*pThrowable);
                    //}
                return typeHnd;
            }

            typeHnd = FindNestedTypeHandle(typeName, pThrowable);
            if (! (typeHnd.IsNull() && (*pThrowable == NULL)) )
                goto exit;
            
            FileSkipped = false;
        }
    }

    // check the available type table again, just in case it
    // was another thread that had added the skipped file
    if (FileSkipped)
        typeHnd = FindNestedTypeHandle(typeName, pThrowable);

 exit:
    m_pManifestImport->EnumClose(&phEnum);
    return typeHnd;
}


TypeHandle Assembly::FindNestedTypeHandle(NameHandle* typeName,
                                          OBJECTREF *pThrowable)
{
    //_ASSERTE(pThrowableAvailable(pThrowable));

    // Reset pThrowable to NULL before we do the look up.
    *pThrowable = NULL;

    TypeHandle typeHnd = LookupTypeHandle(typeName, pThrowable);

    if ((*pThrowable == NULL) && typeHnd.IsNull()) {
        char *plus;
        LPCSTR szCurrent = typeName->GetName();
        NameHandle nestedTypeName(*typeName);
        nestedTypeName.SetTypeToken(m_pManifest, mdtBaseType);

        // Find top-level type, then nested type beneath it, then nested type
        // beneath that...
        while ((plus = (char*) FindNestedSeparator(szCurrent)) != NULL) {
            *plus = '\0';

            typeHnd = LookupTypeHandle(&nestedTypeName, pThrowable);
            *plus = NESTED_SEPARATOR_CHAR;

            if (typeHnd.IsNull())
                return typeHnd;

            szCurrent = plus+1;
            nestedTypeName.SetName(NULL, szCurrent);
        }

        // Now find the nested type we really want
        if (szCurrent != typeName->GetName())
            typeHnd = LookupTypeHandle(&nestedTypeName, pThrowable);
    }

    return typeHnd;
}


// foo+bar means nested type "bar" with enclosing type "foo"
// foo\+bar means non-nested type with name "foo+bar"
// Returns pointer to first '+' that separates an enclosing and nested type.
/* static */
LPCSTR Assembly::FindNestedSeparator(LPCSTR szClassName)
{
    char *plus;
    char *slash;
    BOOL fEvenSlashCount;

    // If name begins with '+', encloser can't have "" name, so not nested
    if ( (plus = strchr(szClassName, NESTED_SEPARATOR_CHAR)) != NULL &&
         (plus != szClassName) ) {

        // ignore +'s with odd # of preceding backslashes
        while ((slash = plus) != NULL) {
            fEvenSlashCount = TRUE;

            while ( (--slash >= szClassName) &&
                    (*slash == BACKSLASH_CHAR) )
                fEvenSlashCount = !fEvenSlashCount;

            if (fEvenSlashCount) // '+' without matching backslash
                return plus;

            plus = strchr(plus+1, NESTED_SEPARATOR_CHAR);
        }
    }

    return NULL;
}

HRESULT Assembly::ExecuteMainMethod(PTRARRAYREF *stringArgs)
{
    HRESULT     hr;
    if (FAILED(hr = GetEntryPoint(&m_pEntryPoint)))
        return hr;
    return GetLoader()->ExecuteMainMethod(m_pEntryPoint, stringArgs);
}

HRESULT Assembly::GetEntryPoint(Module **ppModule)
{
    HRESULT     hr = S_OK;

    _ASSERTE(ppModule);

    if(!m_pEntryPoint) {
        if ((TypeFromToken(m_tEntryModule) == mdtFile) &&
            (m_tEntryModule != mdFileNil))
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            OBJECTREF throwable = NULL;
            GCPROTECT_BEGIN (throwable);
            
            Thread* pThread=GetThread();
            pThread->SetRedirectingEntryPoint();

            if (FAILED(hr = FindInternalModule(m_tEntryModule, 
                                               tdNoTypes,
                                               &m_pEntryPoint, 
                                               &throwable)))
            {
                if (throwable != NULL)
                    DefaultCatchHandler(&throwable); // @TODO: Maybe change to 1st pass.
                else
                    GetManifestModule()->DisplayFileLoadError(hr);
            }

            pThread->ResetRedirectingEntryPoint();

            GCPROTECT_END ();
            END_ENSURE_COOPERATIVE_GC();

            if (FAILED(hr))
                return hr;
        }

        if(m_pEntryPoint == NULL) 
            return E_FAIL;
    }
    *ppModule = m_pEntryPoint;
    return hr;
}

/* static */
BOOL Assembly::ModuleFound(HRESULT hr)
{
    switch (hr) {
    case HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_INVALID_NAME):
    case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME):
    case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
    case HRESULT_FROM_WIN32(ERROR_NOT_READY):
    case HRESULT_FROM_WIN32(ERROR_WRONG_TARGET_NAME):
        return FALSE;
    default:
        return TRUE;
    }
}

static int AddVersion(LPSTR dir,
                      USHORT ver)
{
    char v1[33];
    _ltoa(ver, v1, 10);
    int lgth = (int)strlen(v1);
    strncpy(dir, v1, lgth+1);
    return lgth;
}

HRESULT Assembly::GetFileFromFusion(LPWSTR      pwModuleName,
                                    WCHAR*      szPath,
                                    DWORD       dwPath)
{
#ifdef FUSION_SUPPORTED

    if(pwModuleName == NULL || *pwModuleName == L'\0') 
        return HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME);
       
    AppDomain* pAppDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pAppDomain);
    if(!m_pManifestFile)
        return COR_E_FILENOTFOUND;
    
    _ASSERTE(GetFusionAssembly());

    IAssemblyModuleImport* pImport = NULL;
    HRESULT hr = GetFusionAssembly()->GetModuleByName(pwModuleName, &pImport);
    if(FAILED(hr)) 
        goto exit;

    if(pImport->IsAvailable())
        hr = pImport->GetModulePath(szPath,
                                    &dwPath);
    else {
        _ASSERTE(pAppDomain && "All assemblies must be associated with a domain");
        
        IApplicationContext *pFusionContext = pAppDomain->GetFusionContext();
        _ASSERTE(pFusionContext);
        
        AssemblySink* pSink = NULL;
        pSink = pAppDomain->GetAssemblySink();
        if(!pSink) {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        IAssemblyModuleImport* pResult = NULL;
        hr = FusionBind::RemoteLoadModule(pFusionContext, 
                                          pImport, 
                                          pSink,
                                          &pResult);
        pSink->Release();
        if(FAILED(hr)) 
            goto exit;
        
        _ASSERTE(pResult);
        hr = pResult->GetModulePath(szPath,
                                    &dwPath);
        pResult->Release();
    }

 exit:
    if(pImport) 
        pImport->Release();

    return hr;
#else // !FUSION_SUPPORTED
    return E_NOTIMPL;
#endif // !FUSION_SUPPORTED
}

Module* Assembly::RaiseModuleResolveEvent(LPCSTR szName, OBJECTREF *pThrowable)
{
    Module* pModule = NULL;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY {
        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__ASSEMBLY__ON_MODULE_RESOLVE);

        struct _gc {
            OBJECTREF AssemblyRef;
            STRINGREF str;
        } gc;
        ZeroMemory(&gc, sizeof(gc));
            
        GCPROTECT_BEGIN(gc);
        if ((gc.AssemblyRef = GetRawExposedObject()) != NULL) {
            gc.str = COMString::NewString(szName);
            INT64 args[2] = {
                ObjToInt64(gc.AssemblyRef),
                ObjToInt64(gc.str)
            };
            REFLECTMODULEBASEREF ResultingModuleRef = 
                (REFLECTMODULEBASEREF) Int64ToObj(pMD->Call(args, METHOD__ASSEMBLY__ON_MODULE_RESOLVE));
            if (ResultingModuleRef != NULL)
                pModule = (Module*) ResultingModuleRef->GetData();
        }
        GCPROTECT_END();
    }
    COMPLUS_CATCH {
        if (pThrowable) *pThrowable = GETTHROWABLE();
    } COMPLUS_END_CATCH
          
    END_ENSURE_COOPERATIVE_GC();

    return pModule;
}

/*
  // The enum for dwLocation from managed code:
    public enum ResourceLocation
    {
        Embedded = 1,
        ContainedInAnotherAssembly = 2,
        ContainedInManifestFile = 4
    }
*/
HRESULT Assembly::GetResource(LPCSTR szName, HANDLE *hFile, DWORD *cbResource,
                              PBYTE *pbInMemoryResource, Assembly** pAssemblyRef,
                              LPCSTR *szFileName, DWORD *dwLocation, 
                              StackCrawlMark *pStackMark, BOOL fSkipSecurityCheck,
                              BOOL fSkipRaiseResolveEvent)
{
    mdToken            mdLinkRef;
    DWORD              dwResourceFlags;
    DWORD              dwOffset;
    mdManifestResource mdResource;
    HRESULT            hr;
    Assembly*          pAssembly = NULL;

    _ASSERTE(m_pManifestImport || "This assert normally means that mscorlib didn't build properly. Try doing a clean build in the BCL directory and verify the build log to ensure that it built cleanly.");
    if (!m_pManifestImport)
        return E_FAIL;

    if (SUCCEEDED(hr = m_pManifestImport->FindManifestResourceByName(szName,
                                                                     &mdResource)))
        pAssembly = this;
    else {
        if(fSkipRaiseResolveEvent)
            return hr;

        AppDomain* pDomain = SystemDomain::GetCurrentDomain();
        _ASSERTE(pDomain);

        if (((BaseDomain*)pDomain) == SystemDomain::System())
            return E_FAIL;

        OBJECTREF Throwable = NULL;
        GCPROTECT_BEGIN(Throwable);
        pAssembly = pDomain->RaiseResourceResolveEvent(szName, &Throwable);
        if (!pAssembly) {
            if (Throwable != NULL)
                hr = SecurityHelper::MapToHR(Throwable);
        }
        GCPROTECT_END();
        if (!pAssembly)
            return hr;
      
        if (FAILED(hr = pAssembly->m_pManifestImport->FindManifestResourceByName(szName,
                                                                                 &mdResource)))
            return hr;
        if (dwLocation) {
            if (pAssemblyRef)
                *pAssemblyRef = pAssembly;
            
            *dwLocation = *dwLocation | 2; // ResourceLocation.containedInAnotherAssembly
        }
    }

    pAssembly->m_pManifestImport->GetManifestResourceProps(mdResource,
                                                           NULL, //&szName,
                                                           &mdLinkRef,
                                                           &dwOffset,
                                                           &dwResourceFlags);

    switch(TypeFromToken(mdLinkRef)) {
    case mdtAssemblyRef:
        Assembly *pFoundAssembly;
        if (FAILED(hr = pAssembly->FindExternalAssembly(m_pManifest,
                                                        mdLinkRef,
                                                        m_pManifestImport,
                                                        tdNoTypes,
                                                        &pFoundAssembly,
                                                        NULL)))
            return hr;

        if (dwLocation) {
            if (pAssemblyRef)
                *pAssemblyRef = pFoundAssembly;

            *dwLocation = *dwLocation | 2; // ResourceLocation.containedInAnotherAssembly
        }

        return pFoundAssembly->GetResource(szName,
                                           hFile,
                                           cbResource,
                                           pbInMemoryResource,
                                           pAssemblyRef,
                                           szFileName,
                                           dwLocation,
                                           pStackMark,
                                           fSkipSecurityCheck);

    case mdtFile:
        if (mdLinkRef == mdFileNil) {
            // The resource is embedded in the manifest file

            if (!IsMrPublic(dwResourceFlags) && pStackMark && !fSkipSecurityCheck) {
                Assembly *pCallersAssembly = SystemDomain::GetCallersAssembly(pStackMark);
                if (! ((!pCallersAssembly) || // full trust for interop
                       (pCallersAssembly == pAssembly) ||
                       (AssemblyNative::HaveReflectionPermission(FALSE))) )
                return CLDB_E_RECORD_NOTFOUND;
            }

            if (dwLocation) {
                *dwLocation = *dwLocation | 5; // ResourceLocation.embedded |
                                               // ResourceLocation.containedInManifestFile
                return S_OK;
            }

            return GetEmbeddedResource(pAssembly->m_pManifest, dwOffset, hFile,
                                       cbResource, pbInMemoryResource);
        }

        // The resource is either linked or embedded in a non-manifest-containing file
        return pAssembly->GetResourceFromFile(mdLinkRef, szName, hFile, cbResource,
                                              pbInMemoryResource, szFileName,
                                              dwLocation, IsMrPublic(dwResourceFlags), 
                                              pStackMark, fSkipSecurityCheck);

    default:
        BAD_FORMAT_ASSERT(!"Invalid token saved in ManifestResource");
        return COR_E_BADIMAGEFORMAT;
    }
}


/* static */
HRESULT Assembly::GetEmbeddedResource(Module *pModule, DWORD dwOffset, HANDLE *hFile,
                                      DWORD *cbResource, PBYTE *pbInMemoryResource)
{
    DWORD *dwSize;
    
    PEFile *pFile = pModule->GetPEFile();
    // @TODO: can't get resources from dynamic modules?
    if (!pFile)
        return COR_E_NOTSUPPORTED;
    
    IMAGE_COR20_HEADER *Header = pFile->GetCORHeader();

    if (dwOffset > Header->Resources.Size - sizeof(DWORD))
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

    HANDLE hTempFile;
    LPCWSTR wszPath = pFile->GetFileName();
    if (hFile && wszPath && *wszPath) {
        //@BUG 54905: remove when NLS's OpenDataFile() is updated
        hTempFile = VMWszCreateFile(wszPath,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                    NULL);
        if (hTempFile == INVALID_HANDLE_VALUE)
            return HRESULT_FROM_WIN32(GetLastError());
    }
    else {
        if (hFile)
        *hFile = INVALID_HANDLE_VALUE;

        // base + RVA to resource blob + offset to this resource
         dwSize = (DWORD*) (pFile->GetBase() + Header->Resources.VirtualAddress + dwOffset);
        if ((*dwSize) > Header->Resources.Size - dwOffset - sizeof(DWORD))
            return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);

        *pbInMemoryResource = (PBYTE) dwSize + sizeof(DWORD);
        *cbResource = *dwSize;
        return S_OK;
    }


    //@BUG 54905: remove when NLS's OpenDataFile() is updated
    
    // The manifest file is mapped as an exe, with an RVA for the VA.
    // dwOffset is from the RVA saved in Manifest.VA
    DWORD dwResourceOffset;
    DWORD dwFileLen = SafeGetFileSize(hTempFile, 0);
    if (dwFileLen == 0xFFFFFFFF) {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        CloseHandle(hTempFile);
        return hr;
    }
    if (0 == (dwResourceOffset = Cor_RtlImageRvaToOffset(pFile->GetNTHeader(),
                                                         Header->Resources.VirtualAddress,
                                                         dwFileLen))) {
        CloseHandle(hTempFile);
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    }

    if (SetFilePointer(hTempFile,
                       dwResourceOffset + dwOffset,
                       NULL,
                       FILE_BEGIN) == 0xFFFFFFFF) {
        CloseHandle(hTempFile);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    BYTE pbResourceSize[sizeof(DWORD)];
    DWORD lgth;
    
    if (!ReadFile(hTempFile, pbResourceSize, sizeof(DWORD), &lgth, NULL)) {
        CloseHandle(hTempFile);
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    dwSize = (DWORD*) pbResourceSize;
    if ((*(UNALIGNED DWORD*)dwSize) > Header->Resources.Size - dwOffset - sizeof(DWORD)) {
        CloseHandle(hTempFile);
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    }

    *cbResource = *dwSize;
    *hFile = hTempFile;
    return S_OK;
}


HRESULT Assembly::GetResourceFromFile(mdFile mdResFile, LPCSTR szResName, HANDLE *hFile,
                                      DWORD *cbResource, PBYTE *pbInMemoryResource,
                                      LPCSTR *szFileName, DWORD *dwLocation,
                                      BOOL fIsPublic, StackCrawlMark *pStackMark,
                                      BOOL fSkipSecurityCheck)
{
    const char *szName;
    DWORD      cbHash;
    PBYTE      pbHash;
    HRESULT    hr;
    DWORD      dwFlags;
    Module     *pModule = NULL;
    DWORD      dwOffset = 0;

    m_pManifestImport->GetFileProps(mdResFile,
                                    &szName,
                                    (const void **) &pbHash,
                                    &cbHash,
                                    &dwFlags);

    if (IsFfContainsMetaData(dwFlags)) {
        // The resource is embedded in a non-manifest-containing file.
        mdManifestResource mdResource;
        mdToken mdLinkRef;
        DWORD dwResourceFlags;

        if (FAILED(hr = FindInternalModule(mdResFile,
                                           tdNoTypes,
                                           &pModule,
                                           NULL)))
            return hr;

        if (FAILED(hr = pModule->GetMDImport()->FindManifestResourceByName(szResName,
                                                                           &mdResource)))
            return hr;

        pModule->GetMDImport()->GetManifestResourceProps(mdResource,
                                                         NULL, //&szName,
                                                         &mdLinkRef,
                                                         &dwOffset,
                                                         &dwResourceFlags);
        _ASSERTE(mdLinkRef == mdFileNil);
        if (mdLinkRef != mdFileNil) {
            BAD_FORMAT_ASSERT(!"Can't get LinkRef");
            return COR_E_BADIMAGEFORMAT;
        }
        fIsPublic = IsMrPublic(dwResourceFlags);
    }

    if (!fIsPublic && pStackMark && !fSkipSecurityCheck) {
        Assembly *pCallersAssembly = SystemDomain::GetCallersAssembly(pStackMark);
        if (! ((!pCallersAssembly) || // full trust for interop
               (pCallersAssembly == this) ||
               (AssemblyNative::HaveReflectionPermission(FALSE))) )
            return CLDB_E_RECORD_NOTFOUND;
    }

    if (IsFfContainsMetaData(dwFlags)) {
        if (dwLocation) {
            *dwLocation = *dwLocation | 1; // ResourceLocation.embedded
            *szFileName = szName;
            return S_OK;
        }

        return GetEmbeddedResource(pModule, dwOffset, hFile, cbResource,
                                   pbInMemoryResource);
    }

    // The resource is linked (it's in its own file)
    if (szFileName) {
        *szFileName = szName;
        return S_OK;        
    }

    if (hFile == NULL) {
        hr = FindInternalModule(mdResFile, 
                                tdNoTypes,
                                &pModule, 
                                NULL);
        if(hr == S_FALSE) { // resource file not yet loaded
            WCHAR pPath[MAX_PATH];
            hr = LoadInternalModule(szName,
                                    mdResFile,
                                    m_ulHashAlgId,
                                    pbHash,
                                    cbHash,
                                    dwFlags,
                                    pPath,
                                    MAX_PATH,
                                    &pModule,
                                    NULL);
        }

        if (FAILED(hr))
            return hr;
    
        *pbInMemoryResource = pModule->GetPEFile()->GetBase();
        *cbResource = pModule->GetPEFile()->GetUnmappedFileLength();
        return S_OK;
    }
    else {
      //@BUG 54905: remove when NLS's OpenDataFile() is updated
        LPCWSTR pFileName = m_pManifest->GetFileName();
        WCHAR wszPath[MAX_PATH];
        DWORD lgth = (DWORD)wcslen(pFileName);

        if (lgth) {
            wcscpy(wszPath, pFileName);
            
            wchar_t* tail = wszPath+lgth; // go to one past the last character
            
            while(--tail != wszPath && *tail != L'\\');
            // Add the directory divider
            if(*tail == L'\\') tail++;
            if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szName, -1, tail, MAX_PATH - (tail - wszPath)))
                return HRESULT_FROM_WIN32(GetLastError());
        }
        else
            if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szName, -1, wszPath, MAX_PATH))
                return HRESULT_FROM_WIN32(GetLastError());
        
        HANDLE hTempFile = VMWszCreateFile(wszPath,
                                           GENERIC_READ,
                                           FILE_SHARE_READ,
                                           NULL,
                                           OPEN_EXISTING,
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                           NULL);
        if (hTempFile == INVALID_HANDLE_VALUE)
            return HRESULT_FROM_WIN32(GetLastError());
        
        DWORD dwFileLen = SafeGetFileSize(hTempFile, 0);
        if (dwFileLen == 0xFFFFFFFF) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
        
        if (!m_pManifestFile->HashesVerified() &&
            (m_cbPublicKey ||
             m_pManifest->GetSecurityDescriptor()->IsSigned())) {
    
            if (!pbHash)
                return CRYPT_E_HASH_VALUE;

            PBYTE pbResourceBlob = new (nothrow) byte[dwFileLen];
            if (!pbResourceBlob) {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            DWORD dwBytesRead;
            if (!ReadFile(hTempFile, pbResourceBlob, dwFileLen, &dwBytesRead, NULL)) {
                delete[] pbResourceBlob;
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto exit;
            }

            if (FAILED(hr = VerifyHash(pbResourceBlob,
                                       dwBytesRead,
                                       m_ulHashAlgId,
                                       pbHash,
                                       cbHash))) {
          delete[] pbResourceBlob;
                goto exit;
            }

            delete[] pbResourceBlob;
            
            if (SetFilePointer(hTempFile, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto exit;
            }
        }

        *cbResource = dwFileLen;
        *hFile = hTempFile;
        return S_OK;;
        
    exit:
        CloseHandle(hTempFile);
        return hr;
    }
}


/* static */
DWORD Assembly::GetZapString(CORCOMPILE_VERSION_INFO *pZapVersionInfo, 
                             LPWSTR buffer)
{
    //  
    // String format: 
    // "ZAP" + optional zap set (up to 3 chars) + "-" +
    // OS: 
    //      W - Win 9x
    //      N - Win NT
    //      version xxx.yyy
    // Processor: 
    //      8 - X86
    //      I - IA64
    //      A - Alpha
    // Build type: (Note that this is intended to capture the 
    //              layout of preloaded data structures)
    //      C - Checked
    //      F - Free
    // Code flags - letters are missing or present (& in order):
    //      D - debugging symbols
    //      O - optimized debug
    //      P - profiling
    //      S - shareable
    // Version:
    //      release -Major.Minor
    //      
    //  e.g. "ZAP-N5.0-8CD-2000.18"
    //

    //
    // ZAP
    // 
    
    LPWSTR p = buffer;
    wcscpy(buffer, L"ZAP");
    p += wcslen(p);

    //
    // Include the zap set specified by config, if any.
    //

    LPCWSTR pZapSet = g_pConfig->ZapSet();
    _ASSERTE(wcslen(pZapSet) <= 3); // enforced by eeconfig
    wcscpy(p, pZapSet);
    p += wcslen(p);

    *p++ = '-';

    //
    // OS
    //

    switch (pZapVersionInfo->wOSPlatformID)
    {
    case VER_PLATFORM_WIN32_WINDOWS:
        *p++ = 'W';
        break;
    case VER_PLATFORM_WIN32_NT:
        *p++ = 'N';
        break;
    default:
        _ASSERTE(!"Unknown OS type");
    }
    _ASSERTE(pZapVersionInfo->wOSMajorVersion < 999);
    _ASSERTE(pZapVersionInfo->wOSMinorVersion < 999);
    swprintf(p, L"%d.%d-", pZapVersionInfo->wOSMajorVersion, pZapVersionInfo->wOSMinorVersion);
    p += wcslen(p);

    // 
    // Processor, platform
    // 

    switch (pZapVersionInfo->wMachine)
    {
    case IMAGE_FILE_MACHINE_ALPHA:
        *p++ = 'A';
        break;
    case IMAGE_FILE_MACHINE_I386:
        *p++ = '8';
        break;
    case IMAGE_FILE_MACHINE_IA64:
        *p++ = 'I';
        break;
    default:
        _ASSERTE(!"Unknown machine type");
    }

    //
    // Build
    // 

    if (pZapVersionInfo->wBuild == CORCOMPILE_BUILD_CHECKED)
        *p++ = 'C';
    else if (pZapVersionInfo->wBuild == CORCOMPILE_BUILD_FREE)
        *p++ = 'F';
    else
    {
        _ASSERTE(!"Unknown build type");
    }

    //
    // Codegen flags
    //

    if (pZapVersionInfo->wCodegenFlags & CORCOMPILE_CODEGEN_DEBUGGING)
        *p++ = 'D';
    if (pZapVersionInfo->wCodegenFlags & CORCOMPILE_CODEGEN_OPT_DEBUGGING)
        *p++ = 'O';
    if (pZapVersionInfo->wCodegenFlags & CORCOMPILE_CODEGEN_PROFILING)
        *p++ = 'P';
    if (pZapVersionInfo->wCodegenFlags & CORCOMPILE_CODEGEN_SHAREABLE)
        *p++ = 'S';

    *p = 0;

    return (DWORD)(p - buffer);
}

void Assembly::GetCurrentZapString(LPWSTR buffer, BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile)

{
    CORCOMPILE_VERSION_INFO ZapVersionInfo; 

    GetCurrentVersionInfo(&ZapVersionInfo, fForceDebug, fForceDebugOpt, fForceProfile);

    GetZapString(&ZapVersionInfo, buffer);
}

void Assembly::GetCurrentVersionInfo(CORCOMPILE_VERSION_INFO *pZapVersionInfo,
                                     BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile)
{
    ZeroMemory(pZapVersionInfo, sizeof(CORCOMPILE_VERSION_INFO));

    OSVERSIONINFOW osInfo;
    osInfo.dwOSVersionInfoSize = sizeof(osInfo);
    if (!WszGetVersionEx(&osInfo))
        _ASSERTE(!"GetVersionEx failed");
    
    _ASSERTE(osInfo.dwMajorVersion < 999);
    _ASSERTE(osInfo.dwMinorVersion < 999);
    pZapVersionInfo->wOSPlatformID = (WORD) osInfo.dwPlatformId;
    pZapVersionInfo->wOSMajorVersion = (WORD) osInfo.dwMajorVersion;
    pZapVersionInfo->wOSMinorVersion = (WORD) osInfo.dwMinorVersion;
    
#if defined(_X86_)
    pZapVersionInfo->wMachine = IMAGE_FILE_MACHINE_I386;
#elif defined(_ALPHA_)
    pZapVersionInfo->wMachine = IMAGE_FILE_MACHINE_ALPHA;
#elif defined(_IA64_)
    pZapVersionInfo->wMachine = IMAGE_FILE_MACHINE_IA64;
#else
#error "port me"
#endif

    pZapVersionInfo->wVersionMajor = COR_BUILD_MAJOR;
    pZapVersionInfo->wVersionMinor = COR_BUILD_MINOR;
    pZapVersionInfo->wVersionBuildNumber = COR_OFFICIAL_BUILD_NUMBER;
    pZapVersionInfo->wVersionPrivateBuildNumber = COR_PRIVATE_BUILD_NUMBER;

#if _DEBUG
    pZapVersionInfo->wBuild = CORCOMPILE_BUILD_CHECKED;
#else
    pZapVersionInfo->wBuild = CORCOMPILE_BUILD_FREE;
#endif

#ifdef DEBUGGING_SUPPORTED
    if (fForceDebug || fForceDebugOpt || CORDebuggerTrackJITInfo(GetDebuggerInfoBits()))
    {
        pZapVersionInfo->wCodegenFlags |= CORCOMPILE_CODEGEN_DEBUGGING;
        if (fForceDebugOpt || CORDebuggerAllowJITOpts(GetDebuggerInfoBits()))
            pZapVersionInfo->wCodegenFlags |= CORCOMPILE_CODEGEN_OPT_DEBUGGING;
    }
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
    if (fForceProfile || CORProfilerTrackEnterLeave() || CORProfilerTrackTransitions())
    {
        pZapVersionInfo->wCodegenFlags |= CORCOMPILE_CODEGEN_PROFILING;
        
        // Note that we have hardwired profiling to also imply optimized debugging
        // info.  This cuts down on one permutation of prejit files.
        pZapVersionInfo->wCodegenFlags |= CORCOMPILE_CODEGEN_DEBUGGING;
        pZapVersionInfo->wCodegenFlags |= CORCOMPILE_CODEGEN_OPT_DEBUGGING;
    }
#endif // PROFILING_SUPPORTED

    if (IsShared())
        pZapVersionInfo->wCodegenFlags |= CORCOMPILE_CODEGEN_SHAREABLE;
}

HRESULT Assembly::LoadZapAssembly()
{
    HRESULT hr;

    //
    // There is a problem with (profiling + inproc debugging) which
    // requires a different codegen pattern then normal profiling.  In
    // normal profiling, the enter callback normally happens
    // immediately on function entry.  However, if inproc debugging is
    // enabled, the callback is delayed until after the prolog.  This
    // is because there are conflicting requirements - in the normal
    // profiling situation, you want accurate timing so the enter
    // callback needs to be immediate; however, in the inproc
    // debugging case you need to have the stack frame set up during
    // the enter callback so you can examine and manipulate locals.
    //
    // Thus the solution for now is that we simply won't use zaps when
    // inproc debugging & profiling are enabled.  It doesn't seem
    // worthwhile to add a new zap codegen flavor for this scenario.
    //
    if (CORProfilerTrackEnterLeave() && CORProfilerInprocEnabled())
        return S_FALSE;

    TIMELINE_AUTO(ZAP, "LocateZapAssembly");

    _ASSERTE(m_pZapAssembly == NULL && m_pZapPath == NULL);

    _ASSERTE(g_pConfig->UseZaps());
    _ASSERTE(!SystemDomain::GetCurrentDomain()->IsCompilationDomain());

    hr = LocateZapAssemblyInFusion(&m_pZapAssembly, FALSE, FALSE, FALSE);
    IfFailRet(hr);
    if (hr == S_OK)
    {
        LOG((LF_ZAP, LL_INFO100, "ZAP: Found zap assembly in fusion.\n")); 
    }

    return hr;
}

HRESULT Assembly::LocateZapAssemblyInFusion(IAssembly **ppZapAssembly,
                                            BOOL fForceDebug,
                                            BOOL fForceDebugOpt, 
                                            BOOL fForceProfile)
{
    HRESULT hr;

    TIMELINE_AUTO(ZAP, "LocateZapInFusion");

    _ASSERTE(ppZapAssembly);
    IAssembly *pZapAssembly = NULL;

    AppDomain *pAppDomain = SystemDomain::GetCurrentDomain();

    IApplicationContext *pFusionContext = NULL;
    if (IsSystem())
    {
        //
        // System domain stuff is handled specially - we make a custom
        // application context pointing to where the DLL is.
        // 

        pFusionContext = SystemDomain::System()->GetFusionContext();
        _ASSERTE(pFusionContext);
    }
    else
    {
        AppDomain *pAppDomain = SystemDomain::GetCurrentDomain();
        pFusionContext = pAppDomain->GetFusionContext();
        _ASSERTE(pFusionContext);
    }

    //
    // Iterate through multiple matches to find one which checks out.
    // Note that there may potentially be multiple valid possibilities - we'll
    // just take the first one.
    //
    // (There will only be multiple valid possibilities in the case where 
    // one zap file has a subset of the bindings of another one, for instance
    // if a zap file has only a limited amount of the code precompiled.  I don't
    // anticipate that this will be common at all in practice.)
    //

    IAssemblyName *pZapName = NULL;
    if (GetFusionAssembly())
    {
        //
        // Get the assembly name from the assembly.
        //
        IAssemblyName *pAssemblyName;
        IfFailRet(GetFusionAssembly()->GetAssemblyNameDef(&pAssemblyName));

        hr = pAssemblyName->Clone(&pZapName);
        pAssemblyName->Release();
        IfFailRet(hr);
    }
    else
    {
        //
        // Some assemblies haven't been bound by fusion.  (For example,
        // mscorlib & shell applications.)  For these assemblies, construct
        // a name directly from the assembly metadata.
        //

        AssemblySpec spec;
        IfFailRet(GetAssemblySpec(&spec));
        IfFailRet(spec.CreateFusionName(&pZapName));
    }

    WCHAR buffer[CORCOMPILE_MAX_ZAP_STRING_SIZE];
    GetCurrentZapString(buffer, fForceDebug, fForceDebugOpt, fForceProfile);
    DWORD bufferLength = (DWORD)wcslen(buffer);

    //
    // Set the CUSTOM attribute to NULL.  This will return 
    // us all installed zap assemblies.
    //

    IAssemblyEnum *pEnum;
    pZapName->SetProperty(ASM_NAME_CUSTOM, NULL, 0);

#ifdef LOGGING
    CQuickWSTR displayName;
    DWORD count = (DWORD)displayName.Size();
    if (FAILED(pZapName->GetDisplayName(displayName.Ptr(), &count, 
                                        ASM_DISPLAYF_VERSION
                                        | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                                        | ASM_DISPLAYF_CULTURE
                                        | ASM_DISPLAYF_PROCESSORARCHITECTURE
                                        | ASM_DISPLAYF_LANGUAGEID)))
    {
        displayName.ReSize(count+1);
        if (FAILED(pZapName->GetDisplayName(displayName.Ptr(), &count, 
                                            ASM_DISPLAYF_VERSION
                                            | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                                            | ASM_DISPLAYF_CULTURE
                                            | ASM_DISPLAYF_PROCESSORARCHITECTURE
                                            | ASM_DISPLAYF_LANGUAGEID)))
        
            wcscpy(displayName.Ptr(), L"<name too long>");
    }

    LOG((LF_ZAP, LL_INFO100, "ZAP: Looking for assembly %S, zap string=%S in fusion.\n",
         displayName.Ptr(), buffer));
#endif

    // NOTE: need to also iterate over the ASM_ENUM_DOWNLOAD_STRONG cache
    // when the per-user cache is hooked up.
    hr = CreateAssemblyEnum(&pEnum, NULL, pZapName, ASM_CACHE_ZAP, 0);
    pZapName->Release();

    if (SUCCEEDED(hr))
    {
        IApplicationContext *pMatchContext = NULL;
        IAssemblyName *pMatchName;
        while (pZapAssembly == NULL
               && pEnum->GetNextAssembly(&pMatchContext, &pMatchName, 0) == S_OK)
        {
            //
            // Only consider assemblies which have the same zap 
            // string (minus the unique ID postfix)
            //

            WCHAR zapString[CORCOMPILE_MAX_ZAP_STRING_SIZE];
            DWORD zapStringSize = sizeof(zapString);
            if (SUCCEEDED(pMatchName->GetProperty(ASM_NAME_CUSTOM, 
                                                  zapString, &zapStringSize))
                && wcslen(zapString) >= bufferLength
                && (zapString[bufferLength] == '-'
                    || wcslen(zapString) == bufferLength)
                && wcsncmp(zapString, buffer, bufferLength) == 0)
            {
                AssemblySink *pAssemblySink = pAppDomain->GetAssemblySink();
                if (!pAssemblySink)
                    hr = E_OUTOFMEMORY;
                else {
                    hr = pMatchName->BindToObject(IID_IAssembly,
                                                  pAssemblySink,
                                                  pMatchContext == NULL 
                                                  ? pFusionContext : pMatchContext, 
                                                  L"", NULL, NULL, 0, 
                                                  (void**) &pZapAssembly);
                    
                    pAssemblySink->Release();
                }

                if (SUCCEEDED(hr))
                {
                    WCHAR path[MAX_PATH];
                    DWORD cPath = MAX_PATH;
                    hr = pZapAssembly->GetManifestModulePath(path, &cPath);
                    path[cPath] = 0;

                    BOOL doSkip = TRUE, doDelete = FALSE;

                    //
                    // We want to be sure we do not disturb access times of zap files
                    // we open but don't use.  This is so these old files will be scavenged
                    // properly by fusion.
                    //

                    FILETIME accessTime;
                    if (SUCCEEDED(hr)) 
                    {
                        HANDLE hFile;

                        // 
                        // Get the access time so we can restore it later if necessary.
                        //
                        
                        hFile = WszCreateFile(path, GENERIC_READ, 
                                              FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                                              OPEN_EXISTING, 0, NULL);
                        if (hFile != INVALID_HANDLE_VALUE)
                        {
                            if (!GetFileTime(hFile, NULL, &accessTime, NULL))
                                hr = HRESULT_FROM_WIN32(GetLastError());
                            CloseHandle(hFile);
                        }
                    }
                    

                    if (SUCCEEDED(hr))
                    {
                        HCORMODULE hModule;
                        if (SUCCEEDED(CorMap::OpenFile(path, CorLoadOSMap, &hModule)))
                        {
                            PEFile *pZapManifest;
                            if (SUCCEEDED(PEFile::Create(hModule, &pZapManifest)))
                            {
                                if (!CheckZapVersion(pZapManifest))
                                    doDelete = TRUE;
                                else if (CheckZapConfiguration(pZapManifest,
                                                               fForceDebug, fForceDebugOpt,
                                                               fForceProfile))
                                    doSkip = FALSE;

                                delete pZapManifest;
                            }
                            else
                                doDelete = TRUE;
                        }
                        else
                            doDelete = TRUE;
                    }

                    if (doSkip && !doDelete)
                    {
                        HANDLE hFile = WszCreateFile(path, GENERIC_WRITE, 
                                                     FILE_SHARE_READ|FILE_SHARE_WRITE, NULL,
                                                     OPEN_EXISTING, 0, NULL);
                        if (hFile != INVALID_HANDLE_VALUE)
                        {
                            //
                            // Reset access time of file
                            //
                            
                            SetFileTime(hFile, NULL, &accessTime, NULL);
                            CloseHandle(hFile);
                        }
                    }

                    if (doSkip)
                    {
                        pZapAssembly->Release();
                        pZapAssembly = NULL;
                    }
                    
                    if (doDelete)
                        DeleteZapAssemblyInFusion(pMatchName);
                }
            }

            if (pMatchContext)
                pMatchContext->Release();
            pMatchName->Release();
        }

        pEnum->Release();
    }

    if (pZapAssembly)
    {
        *ppZapAssembly = pZapAssembly;
        hr = S_OK;
    }
    else
        hr = S_FALSE;

    return hr;
}

HRESULT Assembly::DeleteZapAssemblyInFusion(IAssemblyName *pZapName)
{
    HRESULT hr;

    TIMELINE_AUTO(ZAP, "DeleteZapAssemblyInFusion");

    //
    // Get the string name to pass to UninstallAssembly
    //

    CQuickWSTR buffer;

    DWORD cDisplayName = (DWORD)buffer.Size();
    hr = pZapName->GetDisplayName( buffer.Ptr(), &cDisplayName, 
                                   ASM_DISPLAYF_VERSION 
                                   | ASM_DISPLAYF_CULTURE 
                                   | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                                   | ASM_DISPLAYF_CUSTOM
                                   | ASM_DISPLAYF_PROCESSORARCHITECTURE
                                | ASM_DISPLAYF_LANGUAGEID );

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        buffer.ReSize(cDisplayName);


        IfFailRet(pZapName->GetDisplayName( buffer.Ptr(), &cDisplayName, 
                                   ASM_DISPLAYF_VERSION 
                                   | ASM_DISPLAYF_CULTURE 
                                   | ASM_DISPLAYF_PUBLIC_KEY_TOKEN
                                   | ASM_DISPLAYF_CUSTOM
                                   | ASM_DISPLAYF_PROCESSORARCHITECTURE
                                            | ASM_DISPLAYF_LANGUAGEID ));
    }

    //
    // Create a temporary cache object & call Uninstall
    //

    IAssemblyCache *pCache;
    IfFailRet(CreateAssemblyCache(&pCache, 0));

    hr = pCache->UninstallAssembly(0, buffer.Ptr(), NULL, NULL);

    pCache->Release();

    if (SUCCEEDED(hr))
    {
        LOG((LF_ZAP, LL_INFO100, 
             "ZAP: found obsolete zap %S in cache; deleted it.\n", 
             buffer.Ptr()));
    }

    return hr;
}

//
// Checks to make sure the zap isn't out of date with repect to 
// the runtime
//

BOOL Assembly::CheckZapVersion(PEFile *pZapManifest)
{
    TIMELINE_AUTO(ZAP, "CheckZapVersion");

    LOG((LF_ZAP, LL_INFO1000, "ZAP: Checking runtime version for %S.\n",
         pZapManifest->GetFileName()));

    if (g_pConfig->VersionZapsByTimestamp())
    {
        //
        // In a developer tree, we will automatically fail any zap files which 
        // are older than the current version of the runtime.  This is so that 
        // we don't load bad zap files after recompiling the runtime.
        //
        // @todo: this isn't 100% correct - obviously we only care about only 1 of 
        // mscorwks & mscorsvr, and mscoree may have been in a completely different
        // directory.  However, this should be good enough.
        //

        static BOOL checked = FALSE;
        static FILETIME modTime = { 0 };
        static LPCWSTR libs[] = 
        { 
            L"mscoree.dll",
            L"mscorwks.dll",
            L"mscorsvr.dll",
            L"mscorjit.dll",
            L"mscorpe.dll",
            NULL
        };

        if (!checked)
        {
            //
            // Find the latest modified system dll, and use its timestamp to
            // check against.
            //

            checked = TRUE;

            // 12 is the length of the longest pLibName
            WCHAR path[MAX_PATH+13];
            DWORD length = NumItems(path);

            HRESULT hr = GetInternalSystemDirectory(path, &length);
            _ASSERTE(SUCCEEDED(hr));

            WCHAR *pathEnd = path+length-1;
            // Make sure "length" means what we think it does.
            _ASSERTE(pathEnd[-1] != 0 && pathEnd[0] == 0);

            LPCWSTR *pLibName = libs;
            while (*pLibName)
            {
                wcscpy(pathEnd, *pLibName);

                FILETIME libTime;
                WIN32_FIND_DATA data;
                HANDLE find = WszFindFirstFile(path, &data);
                if (find == INVALID_HANDLE_VALUE)
                {
                    libTime.dwLowDateTime = 0;
                    libTime.dwHighDateTime = 0;
                }
                else 
                {
                    libTime = data.ftLastWriteTime;
                    FindClose(find);
                }

                if (CompareFileTime(&libTime, &modTime) > 0)
                {
                    LOG((LF_ZAP, LL_INFO10000, 
                         "ZAP: dll %S was last modified system dll.\n", 
                         *pLibName));

                    modTime = libTime;
                }

                pLibName++;
            }
        }

        //
        // Get the mod time of the zap manifest
        //

        WIN32_FIND_DATA data;
        FILETIME zapTime;
        HANDLE find = WszFindFirstFile(pZapManifest->GetFileName(), &data);
        if (find == INVALID_HANDLE_VALUE)
        {
            zapTime.dwLowDateTime = 0;
            zapTime.dwHighDateTime = 0;
        }
        else 
        {
            zapTime = data.ftLastWriteTime;
            FindClose(find);
        }

        if (CompareFileTime(&zapTime, &modTime) < 0)
        {
            LOG((LF_ZAP, LL_WARNING, "ZAP: zap manifest %S is older than runtime dll - ignoring...\n", pZapManifest->GetFileName()));

            return FALSE;
        }
    }

    //
    // Get the zap version header
    // 
    CORCOMPILE_VERSION_INFO *pVersionInfo = NULL;
    CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
      (pZapManifest->RVAToPointer(pZapManifest->GetCORHeader()->ManagedNativeHeader.VirtualAddress));
    if (pZapHeader)
        pVersionInfo = (CORCOMPILE_VERSION_INFO *)
            (pZapManifest->RVAToPointer(pZapHeader->VersionInfo.VirtualAddress));
    if (!pVersionInfo)
    {
        LOG((LF_ZAP, LL_WARNING, "ZAP: zap manifest %S has an invalid header - ignoring...\n", pZapManifest->GetFileName()));
        
        return FALSE;
    }

    //
    // Check that the EE minor version numbers are the same.
    //

    if (pVersionInfo->wVersionMajor != COR_BUILD_MAJOR
        || pVersionInfo->wVersionMinor != COR_BUILD_MINOR 
        || pVersionInfo->wVersionBuildNumber != COR_OFFICIAL_BUILD_NUMBER
        || pVersionInfo->wVersionPrivateBuildNumber != COR_PRIVATE_BUILD_NUMBER)
    {
        LOG((LF_ZAP, LL_INFO1000, "ZAP: Version numbers don't match EE.\n")); 
        return FALSE;
    }

    //
    // Check the processor specific ID
    //

    if (pVersionInfo->dwSpecificProcessor != GetSpecificCpuType())
    {
        LOG((LF_ZAP, LL_INFO1000, "ZAP: Specific CPU numbers don't match this machine.\n")); 
        return FALSE;
    }

    //
    // The zap is up to date.
    //

    LOG((LF_ZAP, LL_INFO1000, "ZAP: Zap file is up to date.\n")); 
    return TRUE;
}

//
// Checks to see if the zap is appropriate for this configuration
//

BOOL Assembly::CheckZapConfiguration(PEFile *pZapManifest, 
                                     BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile)
{
    HRESULT hr;

    TIMELINE_AUTO(ZAP, "CheckZapConfiguration");

    LOG((LF_ZAP, LL_INFO1000, "ZAP: Checking zap version for %S.\n",
         pZapManifest->GetFileName()));

    //
    // Get the zap version header
    // 

    CORCOMPILE_VERSION_INFO *pVersionInfo = NULL;
    CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
      pZapManifest->RVAToPointer(pZapManifest->GetCORHeader()->ManagedNativeHeader.VirtualAddress);
    if (pZapHeader)
        pVersionInfo = (CORCOMPILE_VERSION_INFO *)
            pZapManifest->RVAToPointer(pZapHeader->VersionInfo.VirtualAddress);

    if (!pVersionInfo)
    {
        LOG((LF_ZAP, LL_INFO1000, "ZAP: invalid zap file header.\n")); 
        return FALSE;
    }

#ifdef _DEBUG
    //
    // The zap string info should always match since we've
    // had a successful lookup - we'll double check
    // in a debug build.
    //
    WCHAR testZapString[CORCOMPILE_MAX_ZAP_STRING_SIZE];
    GetZapString(pVersionInfo, testZapString);

    WCHAR currentZapString[CORCOMPILE_MAX_ZAP_STRING_SIZE];
    GetCurrentZapString(currentZapString, fForceDebug, fForceDebugOpt, fForceProfile);

    _ASSERTE(wcscmp(testZapString, currentZapString) == 0);
#endif

    //
    //
    // Keep track of when this assembly had skip verification permission
    //

    BOOL fHadSkipVerification = (pVersionInfo->mvid != STRUCT_CONTAINS_HASH);
    BOOL fHasSkipVerification = FALSE;

    // Make sure this zap corresponds to our file
    //

    GUID mvid;

    // @TODO: Eventually this should truly be of variable size
    DWORD cbHash = MAX_SNHASH_SIZE;
    CQuickBytes qbHash;
    if (FAILED(qbHash.ReSize(cbHash)))
        return FALSE;

    //
    // If the MVID was stored, then we need to check 
    //

    if (pVersionInfo->mvid != STRUCT_CONTAINS_HASH)
    {
        GetManifestImport()->GetScopeProps(NULL, &mvid);

        // If the binary had full trust when we NGEN'd it, compare MVIDs now
        if (pVersionInfo->mvid != mvid)
            return FALSE;

        if (IsSystem() || Security::IsSecurityOff())
            fHasSkipVerification = TRUE;
        else
        {
            BEGIN_ENSURE_COOPERATIVE_GC();
            fHasSkipVerification = GetSecurityDescriptor()->QuickCanSkipVerification();
            END_ENSURE_COOPERATIVE_GC();
        }
    }

    //
    // Get strong name hash for bound file if MVID check is not enough to guarantee security
    //

    if (!(fHadSkipVerification && fHasSkipVerification))
    {
        if (FAILED(GetManifestFile()->GetSNSigOrHash((BYTE *) qbHash.Ptr(), &cbHash)))
            return FALSE;
        _ASSERTE(cbHash <= qbHash.Size());

        if (cbHash != pVersionInfo->wcbSNHash ||
            memcmp(qbHash.Ptr(), &pVersionInfo->rgbSNHash[0], pVersionInfo->wcbSNHash) != 0)
        {
            LOG((LF_ZAP, LL_INFO1000, "ZAP: HASH of zap doesn't match manifest.\n"));
            return FALSE;
        }
    }

    //
    // Check that the grant set (and associated denied set) at prejit time are
    // the same as policy would grant us now (otherwise any linktime checks we
    // did during the prejitting might be invalid).
    //
    if (!CheckZapSecurity(pZapManifest))
    {
        LOG((LF_ZAP, LL_INFO1000, "ZAP: persisted grant set no longer valid.\n")); 
        return FALSE;
    }

    //
    // Check all the dependencies listed in the zap header
    //

    TIMELINE_START(LOADER, ("check zap dependencies"));

    AppDomain *pAppDomain = SystemDomain::GetCurrentDomain();

    CORCOMPILE_DEPENDENCY *pDependencies = (CORCOMPILE_DEPENDENCY *)
      pZapManifest->RVAToPointer(pVersionInfo->Dependencies.VirtualAddress);
        
    CORCOMPILE_DEPENDENCY *pDependenciesEnd = (CORCOMPILE_DEPENDENCY *)
      pZapManifest->RVAToPointer(pVersionInfo->Dependencies.VirtualAddress
                                 + pVersionInfo->Dependencies.Size);
        
    while (pDependencies &&
           (pDependencies < pDependenciesEnd))
    {
        //
        // Load the manifest file for the given name assembly spec.
        // 
            
        AssemblySpec name;
        name.InitializeSpec(pDependencies->dwAssemblyRef, pZapManifest->GetMDImport(), this);

        //
        // Keep track of when each dependency had skip verification permission
        //

        fHadSkipVerification = (pDependencies->mvid != STRUCT_CONTAINS_HASH);
        fHasSkipVerification = FALSE;
  
        // 
        // First, try lightweight prediction
        //

        cbHash = qbHash.Size();
        hr = pAppDomain->PredictAssemblySpecBinding(&name, &mvid, (BYTE *) qbHash.Ptr(), &cbHash);
        _ASSERTE(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER));

        // If we find it through prebind, then it's in the GAC and is fully trusted and thus has
        // skip verification permission.
        if (hr == S_OK)
        {
            fHasSkipVerification = TRUE;

            // If the binary had full trust when we NGEN'd it, compare MVIDs now
            if (fHadSkipVerification)
            {
                // Fail if the MVIDs don't match
                if (pDependencies->mvid != mvid)
                    return FALSE;
            }
        }

        // If the prebind above fails OR
        // If the prebind succeeds but we didn't get a hash value (it wasn't signed
        // or delay signed) and we need it because the assembly wasn't fully trusted
        // when the dependant was ngen'd
        // THEN we need to do a full bind so we can get the hash value of the manifest module
        if (hr != S_OK ||
            (cbHash == 0 && !(fHadSkipVerification && fHasSkipVerification)))
        {
            PEFile *pNameFile;
            Assembly *pDynamicAssembly = NULL;
            IAssembly* pIAssembly = NULL;
            
            hr = pAppDomain->BindAssemblySpec(&name, &pNameFile, &pIAssembly, &pDynamicAssembly, NULL, NULL);
            if (FAILED(hr))
            {
                LOG((LF_ZAP, LL_INFO1000, "ZAP: Failed dependency name load %S.\n", 
                     L"<Unknown>"));

                TIMELINE_END(LOADER, ("check zap dependencies"));

                return FALSE;
            }
            
            //
            // This is the case where the runtime is hosted and the host is trying to control
            // all assemblies that are loaded and providing extra evidence etc.  In this case,
            // ngen is not supported.
            //

            if (pDynamicAssembly) 
                return FALSE;

            //
            // If we save the MVID at ngen time, then it was fully trusted
            // (i.e. had skip verification permission), and so if we're to match using MVID
            // then we also need to make sure it is still fully trusted.
            //

            if (fHadSkipVerification)
            {
                // Check to see if this assembly has already been loaded into this appdomain,
                // and if so just ask it if it has skip verification permission
                Assembly *pAsm = pAppDomain->FindAssembly(pNameFile->GetBase());
                if (pAsm != NULL)
                {
                    // Check their MVIDs first, because that's cheaper than checking if the
                    // assembly has skip verification permission
                    pAsm->GetManifestImport()->GetScopeProps(NULL, &mvid);

                    // If the MVIDs don't match, there's no point trying to match their hashes
                    // since by definition their data is different and so their hashes will also be.
                    if (pDependencies->mvid != mvid)
                        return FALSE;

                    // Check for skip verification permission
                    if (pAsm->IsSystem() || Security::IsSecurityOff())
                        fHasSkipVerification = TRUE;
                    else
                    {
                        BEGIN_ENSURE_COOPERATIVE_GC();
                        fHasSkipVerification = pAsm->GetSecurityDescriptor()->QuickCanSkipVerification();
                        END_ENSURE_COOPERATIVE_GC();
                    }
                }

                // The assembly is not loaded into the AppDomain, so we have to use a hack
                // to figure out if the assembly would have skip verification permission.
                else
                {
                    // Check their MVIDs first, because that's cheaper than checking if the
                    // assembly has skip verification permission
                    IMDInternalImport *pIMDI = pNameFile->GetMDImport(&hr);
                    if (pIMDI == NULL || FAILED(hr))
                        return FALSE;

                    pIMDI->GetScopeProps(NULL, &mvid);

                    // If the MVIDs don't match, there's no point trying to match their hashes
                    // since by definition their data is different and so their hashes will also be.
                    if (pDependencies->mvid != mvid)
                        return FALSE;

                    // Call the hack
                    fHasSkipVerification = Security::CanLoadUnverifiableAssembly(pNameFile, NULL, TRUE, NULL);
                }
            }

            if (!fHasSkipVerification)
            {
                //
                // Retrieve the strong name hash
                //

                cbHash = qbHash.Size();
                if (FAILED(pNameFile->GetSNSigOrHash((BYTE *) qbHash.Ptr(), &cbHash)))
                    return FALSE;
            }

            // 
            // Store the binding in case we hit it later.
            // 

            pAppDomain->StoreBindAssemblySpecResult(&name, pNameFile, pIAssembly, TRUE);

            // The table takes ownership of these two things, so we can get rid of our copies
            delete pNameFile;
            if(pIAssembly)
                pIAssembly->Release();
        }

        if (!(fHadSkipVerification && fHasSkipVerification))
        {
            if (cbHash != pDependencies->wcbSNHash ||
                memcmp(qbHash.Ptr(), &pDependencies->rgbSNHash[0], pDependencies->wcbSNHash) != 0)
            {
    #ifdef LOGGING
                {
                    WORD i;
                    LOG((LF_ZAP, LL_INFO1000, "ZAP: HASH of zap dependency doesn't match binding.\n"));

                    LOG((LF_ZAP, LL_INFO1000, "Dependency:\t"));
                    for (i = 0; i < pDependencies->wcbSNHash; i++)
                        LOG((LF_ZAP, LL_INFO1000, "%2x", (DWORD) pDependencies->rgbSNHash[i]));
                    LOG((LF_ZAP, LL_INFO1000, "\n"));

                    LOG((LF_ZAP, LL_INFO1000, "Binding:   \t"));
                    for (i = 0; i < cbHash; i++)
                        LOG((LF_ZAP, LL_INFO1000, "%2x", (DWORD) ((BYTE *)qbHash.Ptr())[i]));
                    LOG((LF_ZAP, LL_INFO1000, "\n"));
                }
    #endif

                TIMELINE_END(LOADER, ("check zap dependencies"));

                return FALSE;
            }
        }
            
        pDependencies++;
    }

    TIMELINE_END(LOADER, ("check zap dependencies"));

    //
    // Looks OK!
    //
    
    LOG((LF_ZAP, LL_INFO100, 
         "ZAP: Version check succeeded for %S.\n", 
         pZapManifest->GetFileName()));
    
    return TRUE;
}

BOOL Assembly::CheckZapSecurity(PEFile *pZapManifest)
{
    BOOL fPass = FALSE;
    mdAssembly tkAssembly;

    if (!Security::IsSecurityOn())
        return TRUE;

    TIMELINE_START(ZAP, ("CheckZapSecurity"));

    if (FAILED(pZapManifest->GetMDImport()->GetAssemblyFromScope(&tkAssembly)))
        return FALSE;

    HENUMInternal i;
    if (pZapManifest->GetMDImport()->EnumPermissionSetsInit(tkAssembly, 
                                                            dclPrejitGrant, &i) != S_OK)
    {
        // No grant set stored - this is OK only if security is off.
        return FALSE;
    }

    //
    // System libraries are a special case, the security info's always OK.
    //

    if (IsSystem())
        return TRUE;

    BEGIN_ENSURE_COOPERATIVE_GC();

    AssemblySecurityDescriptor *pSecDesc = GetSecurityDescriptor();

    COMPLUS_TRY
    {

        struct _gc {
            OBJECTREF   demands;
            OBJECTREF   granted;
            OBJECTREF   denied;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        GCPROTECT_BEGIN(gc);

        //
        // Grab the persisted grant (and possibly denied) sets from the zapped
        // assembly. We encode these as standard permission sets hung off the
        // assembly token, with special action codes to distinguish them from
        // permission requests.
        //

        SecurityHelper::GetDeclaredPermissions(pZapManifest->GetMDImport(),
                                            tkAssembly,
                                            dclPrejitGrant,
                                            &gc.demands);

        {
            // Check explicitly for empty set, so we can avoid resolving policy

            MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__IS_EMPTY);

            INT64 args[] = {
                ObjToInt64(gc.demands),
            };

            fPass = (BOOL) pMD->Call(args, METHOD__PERMISSION_SET__IS_EMPTY);
        }

        if (!fPass)
        {
        pSecDesc->Resolve();
        gc.granted = pSecDesc->GetGrantedPermissionSet(&gc.denied);

        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__PERMISSION_SET__IS_SUBSET_OF);
        INT64 args[] = {
            ObjToInt64(gc.demands),
            ObjToInt64(gc.granted),
        };
        fPass = (BOOL) pMD->Call(args, METHOD__PERMISSION_SET__IS_SUBSET_OF);
        }

        GCPROTECT_END();
    }
    COMPLUS_CATCH
    {
        OBJECTREF pThrowable = GETTHROWABLE();
        Security::CheckExceptionForSecuritySafety( pThrowable, FALSE );
        HRESULT hr = SecurityHelper::MapToHR(pThrowable);
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();

    TIMELINE_END(ZAP, ("check zap security"));

    return fPass;
}

PEFile *Assembly::GetZapFile(PEFile *pFile)
{
    HRESULT hr;
    PEFile *pZapFile = NULL;

    if (m_pZapAssembly)
    {
        if (pFile->GetBase() == m_pManifestFile->GetBase())
        {
            //
            // Use the zap assembly's manifest module for our manifest module
            //

            WCHAR wszPath[MAX_PATH];
            DWORD dwSize = MAX_PATH;

            hr = m_pZapAssembly->GetManifestModulePath(wszPath,
                                                       &dwSize);
            if (SUCCEEDED(hr))
            {
                _ASSERTE(dwSize < MAX_PATH);
            
                hr = PEFile::Create(wszPath, NULL, mdFileNil, TRUE, m_pZapAssembly, NULL, NULL, &pZapFile);
            }
        }
        else
        {
            IAssemblyModuleImport *pZapModule;

            TIMELINE_START(LOADER, ("Zap GetModuleByName"));

            hr = m_pZapAssembly->GetModuleByName(pFile->GetLeafFileName(), &pZapModule);

            TIMELINE_END(LOADER, ("Zap GetModuleByName"));

            if (SUCCEEDED(hr))
            {
                //
                // Currently, we should never be remote loading zap files.
                // So ignore the import if it is not available (although it should
                // always be in expected scenarios.)
                //
                if (pZapModule->IsAvailable())
                {
                    WCHAR wszPath[MAX_PATH];
                    DWORD dwSize = MAX_PATH;

                    hr = pZapModule->GetModulePath(wszPath, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        _ASSERTE(dwSize < MAX_PATH);

                        PEFile::Create(wszPath, NULL, mdFileNil, TRUE, NULL, NULL, NULL, &pZapFile);
                    }
                }

                pZapModule->Release();
            }
        }
    }
    else if (m_pZapPath)
    {
        if (wcslen(m_pZapPath) + wcslen(pFile->GetLeafFileName()) + 2 <= MAX_PATH) {
            WCHAR buffer[MAX_PATH];
            
            wcscpy(buffer, m_pZapPath);
            wcscat(buffer, L"\\");
            wcscat(buffer, pFile->GetLeafFileName());

            PEFile::Create(buffer, NULL, mdFileNil, TRUE, NULL, NULL, NULL, &pZapFile);
        }
    }
    else
        return NULL;

    if (pZapFile == NULL)
    {
        LOG((LF_ZAP, LL_INFO10, 
             "ZAP: *** No zap file available for %S.\n", 
             pFile->GetFileName()));
    }
    else
    {
        LOG((LF_ZAP, LL_INFO10, 
             "ZAP: *** Using zap file %S for %S.\n", 
             pZapFile->GetFileName(), pFile->GetFileName()));
    }

    return pZapFile;
}

NLogAssembly *Assembly::CreateAssemblyLog()
{
    if (IsDynamic() || GetManifestFile() == NULL)
        return NULL;

    //
    // Compute configuration parameters
    //

    CORCOMPILE_VERSION_INFO versionInfo;
    GetCurrentVersionInfo(&versionInfo, FALSE, FALSE, FALSE);

    CorZapSharing sharing;
    if (versionInfo.wCodegenFlags & CORCOMPILE_CODEGEN_SHAREABLE)
        sharing = CORZAP_SHARING_MULTIPLE;
    else
        sharing = CORZAP_SHARING_SINGLE;

    CorZapDebugging debugging;
    if (versionInfo.wCodegenFlags & CORCOMPILE_CODEGEN_DEBUGGING)
        if (versionInfo.wCodegenFlags & CORCOMPILE_CODEGEN_OPT_DEBUGGING)
            debugging = CORZAP_DEBUGGING_OPTIMIZED;
        else
            debugging = CORZAP_DEBUGGING_FULL;
    else
        debugging = CORZAP_DEBUGGING_NONE;
              
    CorZapProfiling profiling;
    if (versionInfo.wCodegenFlags & CORCOMPILE_CODEGEN_PROFILING)
        profiling = CORZAP_PROFILING_ENABLED;
    else
        profiling = CORZAP_PROFILING_DISABLED;

    //
    // Compute assembly name
    //

    IAssemblyName *pName = GetFusionAssemblyName();
    if (pName)
        pName->AddRef();
    else {
        //
        // Executables typically won't have fusion info
        //

        AssemblySpec spec;
        GetAssemblySpec(&spec);
        if(FAILED( spec.CreateFusionName(&pName) ) ) {
            pName->Release();
            return NULL;
       }

        LPWSTR pCodebase;
        DWORD cCodebase;
        if (FAILED(GetCodeBase(&pCodebase, &cCodebase))) {
            pName->Release();
            return NULL;
        }

        pName->SetProperty(ASM_NAME_CODEBASE_URL, pCodebase, (cCodebase+1)*sizeof(WCHAR));

    }

    //
    // Collect MVID
    //
    
    GUID mvid;
    GetManifestImport()->GetScopeProps(NULL, &mvid);

    //
    // Create log assembly
    //

    // @TODO: Does this need to be converted to use strong name hash?

    NLogAssembly *pAssembly 
      = new (nothrow) NLogAssembly(pName, sharing, debugging, profiling, &mvid);

    pName->Release();
    if (!pAssembly)
        return NULL;

    //
    // Collect modules
    //

    Module *m = GetLoader()->m_pHeadModule;
    while (m) {
        NLogModule *pModule = m->CreateModuleLog();

        if (pModule)
            pAssembly->AppendModule(pModule);

        m = m->GetNextModule();
    }

    return pAssembly;
}

//***********************************************************
// Add a typedef to the runtime TypeDef table of this assembly
//***********************************************************
void Assembly::AddType(
    Module          *pModule,
    mdTypeDef       cl)
{
    if (pModule->GetAssembly() != this)
    {
        // you cannot add a typedef outside of the assembly to the typedef table
        _ASSERTE(!"Bad usage!");
    }
    m_pClassLoader->AddAvailableClassDontHaveLock(pModule, pModule->GetClassLoaderIndex(), cl);
}



//***********************************************************
//
// get the IMetaDataAssemblyEmit for the on disk manifest.
// Note that the pointer returned is AddRefed. It is the caller's
// responsibility to release the reference.
//
//***********************************************************
IMetaDataAssemblyEmit *Assembly::GetOnDiskMDAssemblyEmitter()
{
    IMetaDataAssemblyEmit *pAssemEmitter = NULL;
    IMetaDataEmit   *pEmitter;
    HRESULT         hr;
    RefClassWriter  *pRCW;   

    _ASSERTE(m_pOnDiskManifest);

    pRCW = m_pOnDiskManifest->GetClassWriter(); 
    _ASSERTE(pRCW);

    // If the RefClassWriter has a on disk emitter, then use it rather than the in-memory emitter.
    pEmitter = pRCW->GetOnDiskEmitter();
        
    if (pEmitter == NULL)
        pEmitter = m_pOnDiskManifest->GetEmitter();

    _ASSERTE(pEmitter);

    IfFailGo( pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &pAssemEmitter) );
    if (pAssemEmitter == NULL)
    {
        // the manifest is not writable
        _ASSERTE(!"Bad usage!");
    }
ErrExit:
    return pAssemEmitter;
}


//***********************************************************
//
// prepare saving manifest to disk.
// We will create a CorModule to store the on disk manifest.
// This CorModule will be destroyed/released when we are done emitting.
//
//***********************************************************
void Assembly::PrepareSavingManifest(ReflectionModule *pAssemblyModule)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr = NOERROR;
    CorModule       *pWrite;
    IMetaDataAssemblyEmit *pAssemEmitter = NULL;
    LPWSTR          wszName = NULL;
    ASSEMBLYMETADATA assemData;
    int             len;
    CQuickBytes     qb;

    if (pAssemblyModule)
    {
        // embedded assembly
        m_pOnDiskManifest = pAssemblyModule;
        m_fEmbeddedManifest = true;
    }
    else
    {
        m_fEmbeddedManifest = false;

        pWrite = allocateReflectionModule();  
        if (!pWrite) 
            IfFailGo(E_OUTOFMEMORY);
    
        // intiailize the dynamic module
        hr = pWrite->Initialize(CORMODULE_NEW, IID_ICeeGen, IID_IMetaDataEmit);
        if (FAILED(hr)) 
            IfFailGo(E_OUTOFMEMORY);

        m_pOnDiskManifest = pWrite->GetReflectionModule();

        // make the On-Disk manifest module remember which assembly it belongs to.
        m_pOnDiskManifest->SetAssembly(this);   
        
        pWrite->Release();
    }

    pAssemEmitter = GetOnDiskMDAssemblyEmitter();

    // convert the manifest name to unicode
    _ASSERTE(m_psName);

    len = (int)strlen(m_psName);
    // Don't allocate asm name on stack since names may be very long.
    wszName = (LPWSTR) qb.Alloc((len + 1) * sizeof(WCHAR));
    len = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_psName, len+1, wszName, len+1);  
    if (len==0)
        IfFailGo(HRESULT_FROM_WIN32(GetLastError()));
    memset(&assemData, 0, sizeof(ASSEMBLYMETADATA));

    // propagating version information 
    assemData.usMajorVersion = m_Context->usMajorVersion;
    assemData.usMinorVersion = m_Context->usMinorVersion;
    assemData.usBuildNumber = m_Context->usBuildNumber;
    assemData.usRevisionNumber = m_Context->usRevisionNumber;
    if (m_Context->szLocale)
    {
        assemData.cbLocale = (ULONG)(strlen(m_Context->szLocale) + 1);
        #define MAKE_TRANSLATIONFAILED IfFailGo(E_INVALIDARG) 
        MAKE_WIDEPTR_FROMUTF8(wzLocale, m_Context->szLocale);
        #undef MAKE_TRANSLATIONFAILED
        assemData.szLocale = wzLocale;
    }

    //@todo: add Title, Description, Alias as CA

    // @todo: propagate all of the information
    // @todo: introduce a helper in metadata to take the ansi version of string.
    hr = pAssemEmitter->DefineAssembly(
        m_pbPublicKey,          // [IN] Public key of the assembly.
        m_cbPublicKey,          // [IN] Count of bytes in the public key.
        m_ulHashAlgId,          // [IN] Hash Algorithm.
        wszName,                // [IN] Name of the assembly.
        &assemData,             // [IN] Assembly MetaData.
        m_dwFlags,              // [IN] Flags.
        &m_tkOnDiskManifest); // [OUT] Returned Assembly token.

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (FAILED(hr))
    {
        _ASSERTE(!"Failed in prepare to save manifest!");
        FATAL_EE_ERROR();
    }
}   // Assembly::PrepareSavingManifest


//***********************************************************
//
// add a file name to the file list of this assembly. On disk only.
//
//***********************************************************
mdFile Assembly::AddFileList(LPWSTR wszFileName)
{
    THROWSCOMPLUSEXCEPTION();

    IMetaDataAssemblyEmit *pAssemEmitter = GetOnDiskMDAssemblyEmitter();
    HRESULT         hr = NOERROR;
    mdFile          fl;

    // Define File.
    IfFailGo( pAssemEmitter->DefineFile(   
        wszFileName,                // [IN] Name of the file.
        0,                          // [IN] Hash Blob.
        0,                          // [IN] Count of bytes in the Hash Blob.
        0,                          // [IN] Flags.
        &fl) );                     // [OUT] Returned File token.

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (FAILED(hr))
        COMPlusThrowHR(hr);

    return fl;
}   // Assembly::AddFileList


//***********************************************************
//
// Set the hash value on a file table entry.
//
//***********************************************************
void Assembly::SetHashValue(mdFile tkFile, LPWSTR wszFullFileName)
{
    THROWSCOMPLUSEXCEPTION();

    IMetaDataAssemblyEmit *pAssemEmitter = GetOnDiskMDAssemblyEmitter();
    HRESULT         hr = NOERROR;
    BYTE            *pbHashValue = 0;
    DWORD           cbHashValue = 0;

    // Get the hash value.
    IfFailGo(GetHash(wszFullFileName, m_ulHashAlgId, &pbHashValue, &cbHashValue));

    // Set the hash blob.
    IfFailGo( pAssemEmitter->SetFileProps(
        tkFile,                 // [IN] File Token.
        pbHashValue,            // [IN] Hash Blob.
        cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        -1));                   // [IN] Flags.

    ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (pbHashValue)
        delete[] pbHashValue;

    if (FAILED(hr))
        COMPlusThrowHR(hr);
}   // Assembly::SetHashValue


//***********************************************************
// Add an assembly to the assemblyref list. pAssemEmitter specifies where 
// the AssemblyRef is emitted to.
//***********************************************************
mdAssemblyRef Assembly::AddAssemblyRef(Assembly *refedAssembly, IMetaDataAssemblyEmit *pAssemEmitter)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr = NOERROR;
    mdAssemblyRef   ar = 0;
    BYTE           *pbPublicKeyToken = NULL;
    DWORD           cbPublicKeyToken = 0;

    if (pAssemEmitter) // We release at the end of this function
        pAssemEmitter->AddRef();
    else
        pAssemEmitter = GetOnDiskMDAssemblyEmitter();

    wchar_t wszLocale[MAX_PATH];

    _ASSERTE(refedAssembly->m_psName);
    int len = (int)strlen(refedAssembly->m_psName); 
    // Don't allocate asm name on stack since names may be very long.
    CQuickBytes qb;
    wchar_t *wszName = (LPWSTR) qb.Alloc((len + 1) * sizeof(WCHAR));
    if (wszName == NULL)
        IfFailGo(E_OUTOFMEMORY);
    len = WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, refedAssembly->m_psName, len+1, wszName, len+1);  
    if (len == 0)
    {
        IfFailGo( HRESULT_FROM_WIN32(GetLastError()) );
    }

    ASSEMBLYMETADATA AMD;
    if (refedAssembly->m_Context) {
        AMD.usMajorVersion = refedAssembly->m_Context->usMajorVersion;
        AMD.usMinorVersion = refedAssembly->m_Context->usMinorVersion;
        AMD.usBuildNumber = refedAssembly->m_Context->usBuildNumber;
        AMD.usRevisionNumber = refedAssembly->m_Context->usRevisionNumber;

        if (refedAssembly->m_Context->szLocale) {
            AMD.cbLocale = (ULONG)strlen(refedAssembly->m_Context->szLocale) + 1;
            Wsz_mbstowcs((unsigned short *)wszLocale, refedAssembly->m_Context->szLocale, MAX_PATH);
            AMD.szLocale = (unsigned short *) wszLocale;
        }
        else {
            AMD.cbLocale = 1;
            wszLocale[0] = L'\0';
            AMD.szLocale = (unsigned short *) wszLocale;
        }
            
        AMD.rProcessor = NULL;
        AMD.ulProcessor = 0;
        AMD.rOS = NULL;
        AMD.ulOS = 0;
    }
    else
        ZeroMemory(&AMD, (sizeof(ASSEMBLYMETADATA)));


    pbPublicKeyToken = refedAssembly->m_pbPublicKey;
    cbPublicKeyToken = refedAssembly->m_cbPublicKey;

    if (cbPublicKeyToken) {
        if (refedAssembly->m_cbRefedPublicKeyToken == 0)
        {
            // Compress public into a token (truncated hashed version).
            // Need to switch into GC pre-emptive mode for this call since
            // it might perform a load library (don't need to bother for
            // further StrongName calls since all library loading will be finished).
            Thread *pThread = GetThread();
            pThread->EnablePreemptiveGC();
            if (!StrongNameTokenFromPublicKey(refedAssembly->m_pbPublicKey,
                                              refedAssembly->m_cbPublicKey,
                                              &pbPublicKeyToken,
                                              &cbPublicKeyToken)) {
                hr = StrongNameErrorInfo();
                pThread->DisablePreemptiveGC();
                goto ErrExit;
            }

            // Cache the public key token for the referenced assembly so that we
            // won't recalculate if we reference to this assembly again.
            refedAssembly->m_pbRefedPublicKeyToken = pbPublicKeyToken;
            refedAssembly->m_cbRefedPublicKeyToken = cbPublicKeyToken;
            pThread->DisablePreemptiveGC();
        }
        else
        {
            // We have calculated the public key token for this referenced
            // assembly before. Just use it.
            pbPublicKeyToken = refedAssembly->m_pbRefedPublicKeyToken;
            cbPublicKeyToken = refedAssembly->m_cbRefedPublicKeyToken;
        }
    }

    IfFailGo( pAssemEmitter->DefineAssemblyRef(pbPublicKeyToken,
                                               cbPublicKeyToken,
                                               (const unsigned short *) wszName,
                                               &AMD,
                                               NULL,
                                               0,
                                               refedAssembly->m_dwFlags & ~afPublicKey,
                                               &ar) );
    
ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (FAILED(hr)) {
        _ASSERTE(!"Failed in DefineAssemblyRef to save to disk!");
        FATAL_EE_ERROR();
    }
    return ar;
}   // Assembly::AddAssemblyRef


//***********************************************************
// Initialize an AssemblySpec from the Assembly data.
//***********************************************************
HRESULT Assembly::GetAssemblySpec(AssemblySpec *pSpec)
{
    HRESULT     hr;
    
    BYTE *pbPublicKeyToken = NULL;
    DWORD cbPublicKeyToken = 0;

    if (m_cbPublicKey) {
        // Compress public key into a token (truncated hashed version).
        // Need to switch into GC pre-emptive mode for this call since
        // it might perform a load library (don't need to bother for
        // further StrongName calls since all library loading will be finished).
        Thread *pThread = GetThread();
        BOOLEAN bGCWasDisabled = pThread && pThread->PreemptiveGCDisabled();
        if (bGCWasDisabled)
            pThread->EnablePreemptiveGC();
        if (!StrongNameTokenFromPublicKey(m_pbPublicKey,
                                          m_cbPublicKey,
                                          &pbPublicKeyToken,
                                          &cbPublicKeyToken)) {
            if (bGCWasDisabled)
                pThread->DisablePreemptiveGC();
            IfFailGo(StrongNameErrorInfo());
        }
        if (bGCWasDisabled)
            pThread->DisablePreemptiveGC();
    }

    IfFailGo(pSpec->Init(m_psName, 
                         m_Context, 
                         pbPublicKeyToken, cbPublicKeyToken, 
                         m_dwFlags & ~afPublicKey));

    pSpec->CloneFields(pSpec->PUBLIC_KEY_OR_TOKEN_OWNED);
        
ErrExit:

    if (pbPublicKeyToken)
        StrongNameFreeBuffer(pbPublicKeyToken);

    return hr;        
} // HRESULT Assembly::GetAssemblySpec()


//***********************************************************
// add a Type name to COMType table. On disk only.
//***********************************************************
mdExportedType Assembly::AddExportedType(LPWSTR wszExportedType, mdToken tkImpl, mdToken tkTypeDef, CorTypeAttr flags)
{
    THROWSCOMPLUSEXCEPTION();

    IMetaDataAssemblyEmit *pAssemEmitter = GetOnDiskMDAssemblyEmitter();
    HRESULT         hr = NOERROR;
    mdExportedType       ct;
    mdTypeDef       tkType = tkTypeDef;

    if (RidFromToken(tkTypeDef) == 0)
        tkType = mdTypeDefNil;

    // @todo: meichint there are more detail information needed to be filled.
    IfFailGo( pAssemEmitter->DefineExportedType(   
        wszExportedType,            // [IN] Name of the COMType.
        tkImpl,                     // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
        tkType,                     // [IN] TypeDef token within the file.
        flags,                      // [IN] Flags.
        &ct) );                     // [OUT] Returned ExportedType token.

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (FAILED(hr))
    {
        FATAL_EE_ERROR();
    }
    return ct;
}   // Assembly::AddExportedType



//***********************************************************
// add an entry to ManifestResource table for a stand alone managed resource. On disk only.
//***********************************************************
void Assembly::AddStandAloneResource(LPWSTR wszName, LPWSTR wszDescription, LPWSTR wszMimeType, LPWSTR wszFileName, LPWSTR wszFullFileName, int iAttribute)
{
    THROWSCOMPLUSEXCEPTION();

    IMetaDataAssemblyEmit *pAssemEmitter = GetOnDiskMDAssemblyEmitter();
    HRESULT         hr = NOERROR;
    mdFile          tkFile;
    mdManifestResource mr;
    BYTE            *pbHashValue = 0;
    DWORD           cbHashValue = 0;

    // Get the hash value;
    if (m_ulHashAlgId)
        IfFailGo(GetHash(wszFullFileName, m_ulHashAlgId, &pbHashValue, &cbHashValue));

    IfFailGo( pAssemEmitter->DefineFile(
        wszFileName,            // [IN] Name of the file.
        pbHashValue,            // [IN] Hash Blob.
        cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        ffContainsNoMetaData,   // [IN] Flags.
        &tkFile) );             // [OUT] Returned File token.


    IfFailGo( pAssemEmitter->DefineManifestResource(     
        wszName,                // [IN] Name of the resource.
        tkFile,                 // [IN] mdFile or mdAssemblyRef that provides the resource.
        0,                      // [IN] Offset to the beginning of the resource within the file.
        iAttribute,             // [IN] Flags.
        &mr) );                 // [OUT] Returned ManifestResource token.

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (pbHashValue)
        delete[] pbHashValue;

    if (FAILED(hr))
    {
        COMPlusThrowHR(hr);
    }
}   // Assembly::AddStandAloneResource


//***********************************************************
// Save security permission requests.
//***********************************************************
void Assembly::SavePermissionRequests(U1ARRAYREF orRequired,
                                      U1ARRAYREF orOptional,
                                      U1ARRAYREF orRefused)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT              hr = S_OK;
    IMetaDataEmitHelper *pEmitHelper = NULL;
    IMetaDataAssemblyEmit *pAssemEmitter = GetOnDiskMDAssemblyEmitter();

    _ASSERTE( pAssemEmitter );
    IfFailGo( pAssemEmitter->QueryInterface(IID_IMetaDataEmitHelper, (void**)&pEmitHelper) );

    if (orRequired != NULL)
        IfFailGo(pEmitHelper->AddDeclarativeSecurityHelper(m_tkOnDiskManifest,
                                                           dclRequestMinimum,
                                                           orRequired->GetDataPtr(),
                                                           orRequired->GetNumComponents(),
                                                           NULL));

    if (orOptional != NULL)
        IfFailGo(pEmitHelper->AddDeclarativeSecurityHelper(m_tkOnDiskManifest,
                                                           dclRequestOptional,
                                                           orOptional->GetDataPtr(),
                                                           orOptional->GetNumComponents(),
                                                           NULL));

    if (orRefused != NULL)
        IfFailGo(pEmitHelper->AddDeclarativeSecurityHelper(m_tkOnDiskManifest,
                                                           dclRequestRefuse,
                                                           orRefused->GetDataPtr(),
                                                           orRefused->GetNumComponents(),
                                                           NULL));

 ErrExit:
    if (pEmitHelper)
        pEmitHelper->Release();
    if (pAssemEmitter)
        pAssemEmitter->Release();
    if (FAILED(hr))
        FATAL_EE_ERROR();
}


//***********************************************************
// Allocate space for a strong name signature in the manifest
//***********************************************************
HRESULT Assembly::AllocateStrongNameSignature(ICeeFileGen  *pCeeFileGen,
                                              HCEEFILE      ceeFile)
{
    HRESULT     hr;
    HCEESECTION TData;
    DWORD       dwDataOffset;
    DWORD       dwDataLength;
    DWORD       dwDataRVA;
    VOID       *pvBuffer;
    DWORD       dwLength;
    static LONG lCount = 0;

    // Calling strong name routines for the first time can cause a load library,
    // potentially leaving us with a deadlock if we're in cooperative GC mode.
    // Switch to pre-emptive mode and touch a harmless strong name routine to
    // get any load library calls out of the way without having to switch modes
    // continuously through this routine (and the two support routines that
    // follow).
    Thread *pThread = GetThread();
    if (pThread->PreemptiveGCDisabled()) {
        pThread->EnablePreemptiveGC();
        StrongNameErrorInfo();
        pThread->DisablePreemptiveGC();
    }

    // If we're going to do a full signing we have a key pair either
    // in a key container or provided directly in a byte array. In the
    // latter case we have to create a temporary key container and
    // install the key into it.
    if (m_eStrongNameLevel == SN_FULL_KEYPAIR_IN_ARRAY) {

        // Create a unique name for the temporary container.
        dwLength = (DWORD)((wcslen(L"__MSCOREE__12345678_12345678__") + 1) * sizeof(WCHAR));
        m_pwStrongNameKeyContainer = new (nothrow) WCHAR[dwLength];
        if (m_pwStrongNameKeyContainer == NULL)
            return E_OUTOFMEMORY;
        swprintf(m_pwStrongNameKeyContainer,
                 L"__MSCOREE__%08X_%08X__",
                 ::GetCurrentProcessId(),
                 InterlockedIncrement(&lCount));

        // Delete any stale container with the same name.
        StrongNameKeyDelete(m_pwStrongNameKeyContainer);

        // Import the key pair into the container.
        if (!StrongNameKeyInstall(m_pwStrongNameKeyContainer,
                                  m_pbStrongNameKeyPair,
                                  m_cbStrongNameKeyPair)) {
            delete[] m_pwStrongNameKeyContainer;
            return StrongNameErrorInfo();
        }
    }

    // Determine size of signature blob.
    if (!StrongNameSignatureSize(m_pbPublicKey, m_cbPublicKey, &dwDataLength)) {
        hr = StrongNameErrorInfo();
        CleanupStrongNameSignature();
        return hr;
    }

    // Allocate space for the signature in the text section and update the COM+
    // header to point to the space.
    IfFailRet(pCeeFileGen->GetIlSection(ceeFile, &TData));
    IfFailRet(pCeeFileGen->GetSectionDataLen(TData, &dwDataOffset));
    IfFailRet(pCeeFileGen->GetSectionBlock(TData, dwDataLength, 4, &pvBuffer));
    IfFailRet(pCeeFileGen->GetMethodRVA(ceeFile, dwDataOffset, &dwDataRVA));
    IfFailRet(pCeeFileGen->SetStrongNameEntry(ceeFile, dwDataLength, dwDataRVA));

    return S_OK;
}


//***********************************************************
// Strong name sign a manifest already persisted to disk
//***********************************************************
HRESULT Assembly::SignWithStrongName(LPWSTR wszFileName)
{
    HRESULT hr = S_OK;

    if ((m_eStrongNameLevel == SN_FULL_KEYPAIR_IN_ARRAY) ||
        (m_eStrongNameLevel == SN_FULL_KEYPAIR_IN_CONTAINER))
    {
        if (!StrongNameSignatureGeneration(wszFileName, m_pwStrongNameKeyContainer, NULL, 0, NULL, NULL))
            hr = StrongNameErrorInfo();
    }

    CleanupStrongNameSignature();

    return hr;
}


//***********************************************************
// Cleanup resources allocated by AllocateStrongNameSignature
// in the case where SignWithStrongName was never called
//***********************************************************
void Assembly::CleanupStrongNameSignature()
{
    if (m_eStrongNameLevel == SN_FULL_KEYPAIR_IN_ARRAY) {
        StrongNameKeyDelete(m_pwStrongNameKeyContainer);
        delete[] m_pwStrongNameKeyContainer;
    }
}


//***********************************************************
// save the manifest to disk!
//***********************************************************
void Assembly::SaveManifestToDisk(LPWSTR wszFileName, int entrypoint, int fileKind)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT         hr = NOERROR;
    HCEEFILE        ceeFile = NULL;
    ICeeFileGen     *pCeeFileGen = NULL;
    RefClassWriter  *pRCW;   
    IMetaDataEmit   *pEmitter;

    _ASSERTE( m_fEmbeddedManifest == false );

    pRCW = m_pOnDiskManifest->GetClassWriter(); 
    _ASSERTE(pRCW);

    IfFailGo( pRCW->EnsureCeeFileGenCreated() );

    pCeeFileGen = pRCW->GetCeeFileGen();
    ceeFile = pRCW->GetHCEEFILE();
    _ASSERTE(ceeFile && pCeeFileGen);

    //Emit the MetaData 
    pEmitter = m_pOnDiskManifest->GetClassWriter()->GetEmitter();
    IfFailGo( pCeeFileGen->EmitMetaDataEx(ceeFile, pEmitter) );

    // Allocate space for a strong name signature if a public key was supplied
    // (this doesn't strong name the assembly, but it makes it possible to do so
    // as a post processing step).
    if (m_cbPublicKey)
        IfFailGo(AllocateStrongNameSignature(pCeeFileGen, ceeFile));

    IfFailGo( pCeeFileGen->SetOutputFileName(ceeFile, wszFileName) );

    // the entryPoint for an assembly is a tkFile token if exist.
    if (RidFromToken(entrypoint) != mdTokenNil)
        IfFailGo( pCeeFileGen->SetEntryPoint(ceeFile, entrypoint) );
    if (fileKind == Dll) 
    {
        pCeeFileGen->SetDllSwitch(ceeFile, true);
    } 
    else 
    {
        // should have a valid entry point for applications
        if (fileKind == WindowApplication)
        {
            IfFailGo( pCeeFileGen->SetSubsystem(ceeFile, IMAGE_SUBSYSTEM_WINDOWS_GUI, CEE_IMAGE_SUBSYSTEM_MAJOR_VERSION, CEE_IMAGE_SUBSYSTEM_MINOR_VERSION) );
        }
        else
        {
            _ASSERTE(fileKind == ConsoleApplication);
            IfFailGo( pCeeFileGen->SetSubsystem(ceeFile, IMAGE_SUBSYSTEM_WINDOWS_CUI, CEE_IMAGE_SUBSYSTEM_MAJOR_VERSION, CEE_IMAGE_SUBSYSTEM_MINOR_VERSION) );
        }

    }

    //Generate the CeeFile
    IfFailGo(pCeeFileGen->GenerateCeeFile(ceeFile) );

    // Strong name sign the resulting assembly if required.
    if (m_cbPublicKey)
        IfFailGo(SignWithStrongName(wszFileName));

    // now release the m_pOnDiskManifest
ErrExit:
    pRCW->DestroyCeeFileGen();

    m_pOnDiskManifest->Destruct();
    m_pOnDiskManifest = NULL;

    if (FAILED(hr)) 
    {
        CleanupStrongNameSignature();
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
        {
            SCODE       scode = HRESULT_CODE(hr);
            WCHAR       wzErrorInfo[MAX_PATH];
            WszFormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                0, 
                hr,
                0,
                wzErrorInfo,
                MAX_PATH,
                0);
            if (IsWin32IOError(scode))
            {
                COMPlusThrowHR(COR_E_IO, wzErrorInfo);
            }
            else
            {
                COMPlusThrowHR(hr, wzErrorInfo);
            }
        }
        if (hr == CEE_E_CVTRES_NOT_FOUND)
            COMPlusThrow(kIOException, L"Argument_cvtres_NotFound");
        COMPlusThrowHR(hr);
    }
}   // Assembly::SaveManifestToDisk

//***********************************************************
// Adding a module with file name wszFileName into the file list
//***********************************************************
void Assembly::AddFileToInMemoryFileList(LPWSTR wszFileName, Module *pModule)
{
    THROWSCOMPLUSEXCEPTION();

    IMetaDataAssemblyEmit   *pAssemEmitter = NULL;
    IMetaDataEmit           *pEmitter;
    mdFile                  tkFile;
    LPCSTR                  szFileName;
    HRESULT                 hr;

    pEmitter = m_pManifest->GetEmitter();
    _ASSERTE(pEmitter);

    IfFailGo( pEmitter->QueryInterface(IID_IMetaDataAssemblyEmit, (void**) &pAssemEmitter) );
    if (pAssemEmitter == NULL)
    {
        // the manifest is not writable
        goto ErrExit;
    }

    // Define an entry in the in-memory file list for this module
    IfFailGo( pAssemEmitter->DefineFile(        
        wszFileName,                // [IN] Name of the file.
        NULL,                       // [IN] Hash Blob.
        0,                          // [IN] Count of bytes in the Hash Blob.
        ffContainsMetaData,         // [IN] Flags.
        &tkFile) );                 // [OUT] Returned File token.

    m_pManifest->GetMDImport()->GetFileProps(tkFile, &szFileName, NULL, NULL, NULL);
    
    // insert the value into manifest's look up table.
    if (!m_pAllowedFiles->InsertValue(szFileName, (HashDatum)(size_t)tkFile, FALSE))
        IfFailGo(E_OUTOFMEMORY);

    // Now make file token associate with the loaded module
    if (!m_pManifest->StoreFile(tkFile, pModule))
        IfFailGo(E_OUTOFMEMORY);

ErrExit:
    if (pAssemEmitter)
        pAssemEmitter->Release();

    if (FAILED(hr))
    {
        _ASSERTE(!"Failed in saving manifest to disk!");
        if (hr == E_OUTOFMEMORY)
            COMPlusThrowOM();
        else
            FATAL_EE_ERROR();
    }

}   // AddFileToInMemoryFileList

//***********************************************************
// Define an assembly ref. The referenced assembly is a writable version.
// It is passed in pAsmRefEmit. pAsmEmit is the manifest to be updated to
// contained the assemblyRef.
//***********************************************************
HRESULT Assembly::DefineAssemblyRef(IMetaDataAssemblyEmit* pAsmEmit,
                                    IMetaDataEmit* pAsmRefEmit,
                                    mdAssemblyRef* mdAssemblyRef)
{
    PBYTE pbMetaData;
    DWORD cbMetaData;

    HRESULT hr = pAsmRefEmit->GetSaveSize(cssAccurate, &cbMetaData);
    if (!cbMetaData)
        return hr;

    pbMetaData = new (nothrow) BYTE[cbMetaData];
    if (!pbMetaData)
        return E_OUTOFMEMORY;

    IStream *pStream;
    if (FAILED(hr = CInMemoryStream::CreateStreamOnMemory(pbMetaData, cbMetaData, &pStream))) {
        delete[] pbMetaData;
        return hr;
    }
        
    hr = pAsmRefEmit->SaveToStream(pStream, 0);
    pStream->Release();

    if (SUCCEEDED(hr))
        hr = DefineAssemblyRef(pAsmEmit, pbMetaData, cbMetaData, mdAssemblyRef);

    delete[] pbMetaData;
    return hr;
}


//***********************************************************
// Define an assembly ref. The referenced assembly is a readonly version.
// It is passed in pbMetaData and cbMetaData. pAsmEmit is the manifest to be updated to
// contained the assemblyRef.
//***********************************************************
HRESULT Assembly::DefineAssemblyRef(IMetaDataAssemblyEmit* pAsmEmit,
                                    PBYTE pbMetaData,
                                    DWORD cbMetaData,
                                    mdAssemblyRef* mdAssemblyRef)
{
    PBYTE pbHashValue = NULL;
    DWORD cbHashValue = 0;
    LPWSTR wszLocale[MAX_PATH];
    PBYTE pbPublicKeyToken = NULL;
    DWORD cbPublicKeyToken = 0;

    HRESULT hr = GetHash(pbMetaData,
                         cbMetaData,
                         m_ulHashAlgId,
                         &pbHashValue,
                         &cbHashValue);
    if (FAILED(hr))
        return hr;

    _ASSERTE(m_psName);
    // Don't allocate asm name on stack since names may be very long.
    int len = (int)strlen(m_psName); 
    CQuickBytes qb;
    wchar_t *wszName = (LPWSTR) qb.Alloc((len + 1) * sizeof(WCHAR));
    if (wszName == NULL)
        return E_OUTOFMEMORY;
    if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_psName, len+1, wszName, len+1))
        return HRESULT_FROM_WIN32(GetLastError());;

    ASSEMBLYMETADATA AMD;
    if (m_Context) {
        AMD.usMajorVersion = m_Context->usMajorVersion;
        AMD.usMinorVersion = m_Context->usMinorVersion;
        AMD.usBuildNumber = m_Context->usBuildNumber;
        AMD.usRevisionNumber = m_Context->usRevisionNumber;

        if (m_Context->szLocale) {
            AMD.cbLocale = (ULONG)(strlen(m_Context->szLocale) + 1);
            Wsz_mbstowcs((unsigned short *)wszLocale, m_Context->szLocale, MAX_PATH);
            AMD.szLocale = (unsigned short *) wszLocale;
        }
        else {
            AMD.cbLocale = 1;
            wszLocale[0] = L'\0';
            AMD.szLocale = (unsigned short *) wszLocale;
        }

        AMD.rProcessor = NULL;
        AMD.ulProcessor = 0;
        AMD.rOS = NULL;
        AMD.ulOS = 0;
    }
    else
        ZeroMemory(&AMD, sizeof(ASSEMBLYMETADATA));

    pbPublicKeyToken = m_pbPublicKey;
    cbPublicKeyToken = m_cbPublicKey;

    if (cbPublicKeyToken) {
        // Compress public key into a token (truncated hashed version).
        // Need to switch into GC pre-emptive mode for this call since
        // it might perform a load library (don't need to bother for
        // further StrongName calls since all library loading will be finished).
        Thread *pThread = GetThread();
        BOOLEAN bGCWasDisabled = pThread->PreemptiveGCDisabled();
        if (bGCWasDisabled)
            pThread->EnablePreemptiveGC();
        if (!StrongNameTokenFromPublicKey(m_pbPublicKey,
                                          m_cbPublicKey,
                                          &pbPublicKeyToken,
                                          &cbPublicKeyToken)) {
            delete [] pbHashValue;
            if (bGCWasDisabled)
                pThread->DisablePreemptiveGC();
            return StrongNameErrorInfo();
        }
        if (bGCWasDisabled)
            pThread->DisablePreemptiveGC();
    }

    hr = pAsmEmit->DefineAssemblyRef(pbPublicKeyToken,
                                     cbPublicKeyToken,
                                     (const unsigned short *)wszName,
                                     &AMD,
                                     pbHashValue,
                                     cbHashValue,
                                     m_dwFlags & ~afPublicKey,
                                     mdAssemblyRef);

    if (pbPublicKeyToken != m_pbPublicKey)
        StrongNameFreeBuffer(pbPublicKeyToken);

    delete[] pbHashValue;
    return hr;
}

HRESULT Assembly::VerifyModule(Module* pModule)
{
    // Get a count of all the classdefs and enumerate them.
    HENUMInternal   hEnum;
    mdTypeDef td;

    HRESULT hr = pModule->GetMDImport()->EnumTypeDefInit(&hEnum);
    if(SUCCEEDED(hr))
    {
        // First verify all global functions - if there are any
        if (!VerifyAllGlobalFunctions(pModule))
            hr = E_FAIL;
        
        while (pModule->GetMDImport()->EnumTypeDefNext(&hEnum, &td))
        {
            if (!VerifyAllMethodsForClass(pModule, td, pModule->GetClassLoader()))
            {
                pModule->GetMDImport()->EnumTypeDefClose(&hEnum);
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

HRESULT Assembly::VerifyAssembly()
{
     HRESULT hr1;
     HRESULT hr = S_OK;
    _ASSERTE(IsAssembly());
    _ASSERTE(m_pManifestImport);

    // Verify the module containing the manifest. There is no
    // FileRefence so will no show up in the list.
    hr1 = VerifyModule(m_pManifest);

    if (FAILED(hr1))
        hr = hr1;

    HENUMInternal phEnum;
    hr1 = m_pManifestImport->EnumInit(mdtFile,
                                     mdTokenNil,
                                     &phEnum);
    if (FAILED(hr1)) {
        hr = hr1;
    }
    else {
        mdToken mdFile;
        
        for(int i = 0; m_pManifestImport->EnumNext(&phEnum, &mdFile); i++) {
            Module* pModule;
            hr1 = FindInternalModule(mdFile, 
                                     tdNoTypes,
                                     &pModule, 
                                     NULL);
            if (FAILED(hr1)) {
                hr = hr1;
            }
            else if(hr == S_FALSE) {
                // do nothing for resource files
            }
            else {
                hr1 = VerifyModule(pModule);
                if(FAILED(hr1)) hr = hr1;
            }
        }
    }

    return hr;
}

// Return the full name of the assembly
HRESULT Assembly::GetFullName(LPCWSTR *pwsFullName)
{
    HRESULT hr = S_OK;
#ifdef FUSION_SUPPORTED

    _ASSERTE(pwsFullName);

    if(m_pwsFullName == NULL) {

        BOOL fReleaseIAN = FALSE;
        IAssemblyName* pFusionAssemblyName = GetFusionAssemblyName();

        // GetFusionAssemblyName() could return NULL for byte[] assemblies.
        if(!pFusionAssemblyName) {
            // Don't allocate asm name on stack since names may be very long.
            int len = (int)strlen(m_psName); 
            CQuickBytes qb;
            wchar_t *wszName = (LPWSTR) qb.Alloc((len + 1) * sizeof(WCHAR));
            if (wszName == NULL)
                return E_OUTOFMEMORY;
            if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, m_psName, len+1, wszName, len+1))
                return HRESULT_FROM_WIN32(GetLastError());

            if (FAILED(hr = Assembly::SetFusionAssemblyName(wszName,
                                                            m_dwFlags,
                                                            m_Context,
                                                            m_pbPublicKey,
                                                            m_cbPublicKey,
                                                            &pFusionAssemblyName)))
                return hr;

            fReleaseIAN = TRUE;
        }

        LPWSTR wsFullName = NULL;
        DWORD cb = 0;
        pFusionAssemblyName->GetDisplayName(NULL, &cb, 0);
        if(cb) {
            wsFullName = new (nothrow) WCHAR[cb];
            if (!wsFullName) {
                if (fReleaseIAN)
                    pFusionAssemblyName->Release();
                return E_OUTOFMEMORY;
            }

            if (FAILED(hr = pFusionAssemblyName->GetDisplayName(wsFullName, &cb, 0)))
                // if we fail then just null out the name
                wsFullName[0] = L'\0';
        }

        if (fReleaseIAN)
            pFusionAssemblyName->Release();

        if (FastInterlockCompareExchange((void**) &m_pwsFullName,
                                         wsFullName,
                                         NULL))
            delete[] wsFullName;
    }

    *pwsFullName = m_pwsFullName;
#endif  // FUSION_SUPPORTED

    return hr;
}

/* static */
HRESULT Assembly::SetFusionAssemblyName(LPCWSTR pSimpleName,
                                        DWORD dwFlags,
                                        AssemblyMetaDataInternal *pContext,
                                        PBYTE  pbPublicKeyOrToken,
                                        DWORD  cbPublicKeyOrToken,
                                        IAssemblyName **ppFusionAssemblyName)
{
    IAssemblyName* pFusionAssemblyName = NULL;
    HRESULT hr;

    if (SUCCEEDED(hr = CreateAssemblyNameObject(&pFusionAssemblyName, pSimpleName, 0, NULL))) {
        DWORD cb = 0;

        if ((pContext->usMajorVersion != (USHORT) -1) &&
            FAILED(hr = pFusionAssemblyName->SetProperty(ASM_NAME_MAJOR_VERSION, &pContext->usMajorVersion, sizeof(USHORT))))
            goto exit;
            
        if ((pContext->usMinorVersion != (USHORT) -1) &&
            FAILED(hr = pFusionAssemblyName->SetProperty(ASM_NAME_MINOR_VERSION, &pContext->usMinorVersion, sizeof(USHORT))))
            goto exit;

        if ((pContext->usBuildNumber != (USHORT) -1) &&
            FAILED(hr = pFusionAssemblyName->SetProperty(ASM_NAME_BUILD_NUMBER, &pContext->usBuildNumber, sizeof(USHORT))))
            goto exit;

        if ((pContext->usRevisionNumber != (USHORT) -1) &&
            FAILED(hr = pFusionAssemblyName->SetProperty(ASM_NAME_REVISION_NUMBER, &pContext->usRevisionNumber, sizeof(USHORT))))
            goto exit;


        if (pContext->szLocale) {
            #define MAKE_TRANSLATIONFAILED {hr=E_INVALIDARG; goto exit;}
            MAKE_WIDEPTR_FROMUTF8(pwLocale,pContext->szLocale);
            #undef MAKE_TRANSLATIONFAILED
            
            if (FAILED(hr = pFusionAssemblyName->SetProperty(ASM_NAME_CULTURE, pwLocale, (DWORD)(sizeof(WCHAR) * (wcslen(pwLocale)+1)))))
                goto exit;
        }

        if (pbPublicKeyOrToken) {
            if (cbPublicKeyOrToken && IsAfPublicKey(dwFlags))
                hr = pFusionAssemblyName->SetProperty(ASM_NAME_PUBLIC_KEY, pbPublicKeyOrToken, cbPublicKeyOrToken);
            else if (cbPublicKeyOrToken && IsAfPublicKeyToken(dwFlags))
                hr = pFusionAssemblyName->SetProperty(ASM_NAME_PUBLIC_KEY_TOKEN, pbPublicKeyOrToken, cbPublicKeyOrToken);
            else
                hr = pFusionAssemblyName->SetProperty(ASM_NAME_NULL_PUBLIC_KEY, NULL, 0);

            if (FAILED(hr))
                goto exit;
        }

        // See if the assembly[ref] is retargetable (ie, for a generic assembly).
        if (IsAfRetargetable(dwFlags)) {
            BOOL bTrue = TRUE;
            hr = pFusionAssemblyName->SetProperty(ASM_NAME_RETARGET, &bTrue, sizeof(bTrue));

            if (FAILED(hr))
                goto exit;
        }

        *ppFusionAssemblyName = pFusionAssemblyName;
        return S_OK;

    exit:
        pFusionAssemblyName->Release();
    }

    return hr;
}

IMetaDataAssemblyImport* Assembly::GetManifestAssemblyImport()
{
    if (!m_pManifestAssemblyImport) {
        // Make sure internal MD is in RW format.
        if (SUCCEEDED(Module::ConvertMDInternalToReadWrite(&m_pManifestImport))) {
            IMetaDataAssemblyImport *pIMDAImport = NULL;
            GetMetaDataPublicInterfaceFromInternal((void*)m_pManifestImport, 
                                                   IID_IMetaDataAssemblyImport, 
                                                   (void **)&pIMDAImport);
            
            if (FastInterlockCompareExchange((void **)&m_pManifestAssemblyImport, pIMDAImport, NULL))
                pIMDAImport->Release();
        }
    }

    return m_pManifestAssemblyImport;
}

// Return the friendly name of the assembly.  In legacy mode, the friendly
// name is the filename of the module containing the manifest.
HRESULT Assembly::GetName(LPCUTF8 *pszName)
{

    // This should only occur in the legacy case, in which case the name is set
    // to the filename of the module that contains the manifest
    if (!m_psName) {
        // Since there's only one module per assembly in legacy mode, this is ok.
        if (m_pClassLoader == NULL || m_pClassLoader->m_pHeadModule == NULL)
            return (E_FAIL);

        DWORD dwLength;
        m_pClassLoader->m_pHeadModule->GetFileName(NULL, 0, &dwLength);

        if (dwLength == 0) {
            // Make sure string is unique by incorporating this pointer value into string.
            HRESULT hr;
            WCHAR   wszTemplate[30];
            IfFailRet(LoadStringRC(IDS_EE_NAME_UNKNOWN_UNQ,
                                   wszTemplate,
                                   sizeof(wszTemplate)/sizeof(wszTemplate[0]),
                                   FALSE));
            
            wchar_t wszUniq[20];
            wprintf(wszUniq, L"%#8x", this);
            LPWSTR wszMessage = NULL;
            LPCWSTR wszArgs[3] = {wszUniq, NULL, NULL};
            DWORD res = WszFormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY|FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                         wszTemplate,
                                         0,
                                         0,
                                         (LPWSTR) &wszMessage,
                                         0,
                                         (va_list*) wszArgs);
            m_psName = new (nothrow) char[30];
            if (! (m_psName && res) ) {
                LocalFree(wszMessage);
                return E_OUTOFMEMORY;
            }

            dwLength = Wsz_wcstombs((LPSTR) m_psName, wszMessage, 30);
            LocalFree(wszMessage);
        }
        else {
            m_psName = new (nothrow) char[++dwLength];
            if (!m_psName)
                return E_OUTOFMEMORY;
        m_pClassLoader->m_pHeadModule->GetFileName((LPUTF8) m_psName, 
                                                       dwLength, &dwLength);
        }

        _ASSERTE(dwLength);
        m_FreeFlag |= FREE_NAME;
    }

    *pszName = m_psName;

    return S_OK;
}

struct LoadAssemblyHelper_Args {
    LPCWSTR wszAssembly;
    Assembly **ppAssembly;
    HRESULT hr;
};

static void LoadAssemblyHelper(LoadAssemblyHelper_Args *args)
{

    AppDomain *pDomain = GetThread()->GetDomain();
    args->hr = pDomain->LoadAssemblyHelper(args->wszAssembly,
                                           NULL,
                                           args->ppAssembly,
                                           NULL);
}

HRESULT STDMETHODCALLTYPE
GetAssembliesByName(LPCWSTR  szAppBase,
                    LPCWSTR  szPrivateBin,
                    LPCWSTR  szAssemblyName,
                    IUnknown *ppIUnk[],
                    ULONG    cMax,
                    ULONG    *pcAssemblies)
{
    HRESULT hr = S_OK;

    if (g_fEEInit) {
        // Cannot call this during EE startup
        return MSEE_E_ASSEMBLYLOADINPROGRESS;
    }

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    if (!(szAssemblyName && ppIUnk && pcAssemblies))
        IfFailGo(E_POINTER);

    Thread* pThread = GetThread();
    if (!pThread)
        IfFailGo(E_UNEXPECTED);

    if (SetupThread() == NULL)
        IfFailGo(E_OUTOFMEMORY);
    
    AppDomain *pDomain;
        
    if(szAppBase || szPrivateBin) {

        BOOL fGCEnabled = !pThread->PreemptiveGCDisabled();

        if (fGCEnabled)
            pThread->DisablePreemptiveGC();

        COMPLUS_TRY {
            MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__APP_DOMAIN__CREATE_DOMAINEX);
            struct _gc {
                STRINGREF pFriendlyName;
                STRINGREF pAppBase;
                STRINGREF pPrivateBin;
            } gc;
            ZeroMemory(&gc, sizeof(gc));
            
            GCPROTECT_BEGIN(gc);
            gc.pFriendlyName = COMString::NewString(L"GetAssembliesByName");
            if(szAppBase) 
                gc.pAppBase = COMString::NewString(szAppBase);
            if(szPrivateBin) 
                gc.pPrivateBin = COMString::NewString(szPrivateBin);
            
            INT64 args[5] = {
                0,
                ObjToInt64(gc.pPrivateBin),
                ObjToInt64(gc.pAppBase),
                NULL,
                ObjToInt64(gc.pFriendlyName)
            };
            APPDOMAINREF pDom = (APPDOMAINREF) Int64ToObj(pMD->Call(args, METHOD__APP_DOMAIN__CREATE_DOMAINEX));
            if (pDom == NULL)
                hr = E_FAIL;
            else {
                Context *pContext = CRemotingServices::GetServerContextForProxy((OBJECTREF) pDom);
                _ASSERTE(pContext);
                pDomain = pContext->GetDomain();
            }

            GCPROTECT_END();
        }
        COMPLUS_CATCH {
            hr = SecurityHelper::MapToHR(GETTHROWABLE());
        } COMPLUS_END_CATCH;
          
    
        if (fGCEnabled)
            pThread->EnablePreemptiveGC();
    }
    else
        pDomain = SystemDomain::System()->DefaultDomain();

    Assembly *pFoundAssembly;
    if (SUCCEEDED(hr)) {

        if (pDomain == pThread->GetDomain())
            hr = pDomain->LoadAssemblyHelper(szAssemblyName,
                                             NULL,
                                             &pFoundAssembly,
                                             NULL);
        else {
            LoadAssemblyHelper_Args args;
            args.wszAssembly = szAssemblyName;
            args.ppAssembly = &pFoundAssembly;
            COMPLUS_TRY {
                pThread->DoADCallBack(pDomain->GetDefaultContext(), LoadAssemblyHelper, &args);
                hr = args.hr;
            }
            COMPLUS_CATCH {
                hr = SecurityHelper::MapToHR(GETTHROWABLE());
            } COMPLUS_END_CATCH;
        }

        if (SUCCEEDED(hr)) {
            if (cMax < 1)
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            else {
                ppIUnk[0] = (IUnknown *)pFoundAssembly->GetManifestAssemblyImport();
                ppIUnk[0]->AddRef();
            }
            *pcAssemblies = 1;
        }
    }

 ErrExit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}// Used by the IMetadata API's to access an assemblies metadata. 

BOOL VerifyAllMethodsForClass(Module *pModule, mdTypeDef cl, ClassLoader *pClassLoader)
{
    BOOL retval = TRUE;
    int  j;
    OBJECTREF pThrowable;
    EEClass *pClass;
     
    // In the case of COR_GLOBAL_PARENT_TOKEN (i.e. global functions), it is guaranteed
    // that the module has a method table or our caller will have skipped this step.
    NameHandle name(pModule, cl);
    pClass = (cl == COR_GLOBAL_PARENT_TOKEN
              ? pModule->GetMethodTable()->GetClass()
              : (pClassLoader->LoadTypeHandle(&name)).GetClass());

    if (pClass == NULL)
        return FALSE;

    g_fVerifierOff = false;

    // Verify all methods in class - excluding inherited methods
    if (pClass->GetParentClass() == NULL)
        j = 0;
    else
        j = pClass->GetParentClass()->GetNumVtableSlots();

    while (j < pClass->GetNumMethodSlots())
    {
        MethodDesc *pMD = pClass->GetUnknownMethodDescForSlot(j);   
        if (pMD == NULL)
        {
            j++;
            continue;
        }

        if (pMD->IsIL() && !pMD->IsAbstract() && !pMD->IsUnboxingStub())
        {

            COMPLUS_TRY
            {
                COR_ILMETHOD_DECODER ILHeader(pMD->GetILHeader(), pMD->GetMDImport()); 
                if (FAILED(pMD->Verify(&ILHeader, TRUE, TRUE)))
                {
                    // Get and display class/method info!
                    retval = FALSE;
                }
            }
            COMPLUS_CATCH
            {
                // Get and display class/method info!
                pThrowable = GETTHROWABLE();
                _ASSERTE(pThrowable);
                GCPROTECT_BEGIN(pThrowable);

                CQuickWSTRNoDtor message;

                COMPLUS_TRY 
                {
                    // Defined and set to null
                    LPCUTF8 pszClassname = NULL;
                    LPCUTF8 pszNamespace = NULL;
                    LPCUTF8 pszMethodname = NULL;

                    GetExceptionMessage(pThrowable, &message);
                    
                    // Display class and Method info
                    if (cl != COR_GLOBAL_PARENT_TOKEN)
                    {
                        pMD->GetMDImport()->GetNameOfTypeDef(cl, &pszClassname, &pszNamespace);
                        if (*pszNamespace)
                        {
                            PrintToStdOutA(pszNamespace);
                            PrintToStdOutA("\\");
                        }
                        if (pszClassname)
                        {
                            PrintToStdOutA(pszClassname);
                            PrintToStdOutA("::");
                        }
                    }
                    else
                    {
                        PrintToStdOutA("Global Function :");
                    }

                    pszMethodname = pMD->GetMDImport()->GetNameOfMethodDef(pMD->GetMemberDef());    

                    PrintToStdOutA(pszMethodname);
                    PrintToStdOutA("() - ");
                    if (message.Size() > 0)
                        PrintToStdOutW(message.Ptr());
                    PrintToStdOutA("\n\n");
                }
                COMPLUS_CATCH 
                {
                    _ASSERTE(!"We threw an exception during verification.  Investigation needed");
                }
                COMPLUS_END_CATCH

                message.Destroy();
    
                FlushLogging();     // Flush any logging output
                GCPROTECT_END();

                retval = FALSE;
            } COMPLUS_END_CATCH
        }

        j++;
    }
    return retval;
}

// Helper function to verify the global functions
BOOL VerifyAllGlobalFunctions(Module *pModule)
{
    // Is there anything worth verifying?
    if (pModule->GetMethodTable())
    {
        if (!VerifyAllMethodsForClass(pModule, COR_GLOBAL_PARENT_TOKEN,
                                      pModule->GetClassLoader()))
        {
            return FALSE;
        }
    }
    return TRUE;
}

#ifdef DEBUGGING_SUPPORTED
BOOL Assembly::NotifyDebuggerAttach(AppDomain *pDomain, int flags, BOOL attaching)
{
    BOOL result = FALSE;

    if (!attaching && !pDomain->IsDebuggerAttached())
        return FALSE;

    if (flags & ATTACH_ASSEMBLY_LOAD)
    {
        g_pDebugInterface->LoadAssembly(pDomain, this, FALSE, attaching);
        result = TRUE;
    }

    ClassLoader* pLoader = GetLoader();
    if (pLoader)
    {
        for (Module *pModule = pLoader->m_pHeadModule;
             pModule;
             pModule = pModule->GetNextModule())
        {
            result = pModule->NotifyDebuggerAttach(pDomain, flags, attaching) || result;
        }
    }


    return result;
}

void Assembly::NotifyDebuggerDetach(AppDomain *pDomain)
{

    if (!pDomain->IsDebuggerAttached())
        return;

    ClassLoader* pLoader = GetLoader();
    if (pLoader)
    {
        for (Module *pModule = pLoader->m_pHeadModule;
             pModule;
             pModule = pModule->GetNextModule())
        {
            pModule->NotifyDebuggerDetach(pDomain);
        }
    }

    g_pDebugInterface->UnloadAssembly(pDomain, this);

}
#endif // DEBUGGING_SUPPORTED

static BOOL CompareBases(UPTR u1, UPTR u2)
{
    BYTE *b1 = (BYTE *) (u1 << 1);
    BYTE *b2 = (BYTE *) u2;

    return b1 == b2;
}

HRESULT Assembly::ComputeBindingDependenciesClosure(PEFileBinding **ppDeps,
                                                    DWORD *pcDeps, 
                                                    BOOL suppressLoads)
{
    HRESULT hr = S_OK;

    AppDomain *pAppDomain = SystemDomain::GetCurrentDomain();

    AssemblySpecHash specHash;
    PtrHashMap manifestHash;
    manifestHash.Init(CompareBases, FALSE, NULL);

    DWORD depsEnd = 0;
    DWORD depsMax = 10;
    PEFileBinding *deps = (PEFileBinding *) 
      _alloca(depsMax * sizeof(PEFileBinding));

    DWORD peFileVisited = 0;
    DWORD peFileEnd = 0;
    DWORD peFileMax = 10;
    PEFile **peFiles = (PEFile **)
        _alloca(peFileMax * sizeof(PEFile *));

    peFiles[peFileEnd++] = this->GetManifestFile();

    
    BEGIN_ENSURE_COOPERATIVE_GC();
    while (peFileVisited < peFileEnd)
    {
        PEFile *pCurrentPEFile = peFiles[peFileVisited++];

        LOG((LF_CODESHARING, 
             LL_INFO100, 
             "Considering dependencies of pefile \"%S\".\n",
             pCurrentPEFile->GetFileName())); 

        IMDInternalImport *pImport = pCurrentPEFile->GetMDImport();
        HENUMInternal e;

        //
        // Enumerate all assembly refs in the manifest
        //

        pImport->EnumInit(mdtAssemblyRef, mdTokenNil, &e);

        mdAssemblyRef ar;
        while (pImport->EnumNext(&e, &ar))
        {
            AssemblySpec spec;
            spec.InitializeSpec(ar, pImport, NULL);

            // 
            // We never care about mscorlib as a dependency, since it
            // cannot be versioned.
            //

            if (spec.IsMscorlib())
                continue;

            if (IsSystem())
            {
                // 
                // Major hack: Right now the VC compiler puts a reference to 
                // MS.VisualC in the custom marshalers assembly, which is only used
                // for custom attributes.  Since we don't care about such references,
                // and references to assemblies outside the system domain will break us,
                // I'm putting in this hack to ignore any assembly refs from system 
                // assemblies when computing this closure.
                //
                // @todo: the real fix here is to get VC to add a compiler option to 
                // suppress these custom attributes.
                //

                // These asserts should help us figure out if we're abusing this hack.
                _ASSERTE(_stricmp(spec.GetName(), "Microsoft.VisualC") == 0);
                _ASSERTE(_wcsicmp(GetManifestFile()->GetLeafFileName(), L"custommarshalers.dll") == 0);

                continue;
            }

            if (!specHash.Store(&spec))
            {
                //
                // If we haven't seen this ref yet, add it to the list.
                //

                LOG((LF_CODESHARING, 
                     LL_INFO1000, 
                     "Testing dependency \"%s\" (hash %x).\n",
                     spec.GetName(), spec.Hash())); 

                PEFile *pDepFile = NULL;
                IAssembly* pIAssembly = NULL;
                OBJECTREF throwable = NULL;
                GCPROTECT_BEGIN(throwable);
                if (suppressLoads)
                {
                    //
                    // Try to find the spec in our cache; if it's not there, just skip it. 
                    // (Note that there can't be any transitive dependencies if it hasn't ever
                    // been loaded.)
                    //

                    hr = pAppDomain->LookupAssemblySpec(&spec, &pDepFile, NULL, &throwable);
                    if (hr == S_FALSE)
                    {
                        Assembly *pAssembly = pAppDomain->FindCachedAssembly(&spec);
                        if (pAssembly)
                            PEFile::Clone(pAssembly->GetManifestFile(), &pDepFile);
                        else 
                            continue;
                    }
                }
                else
                {
                    Assembly *pDynamicAssembly = NULL;
                    hr = pAppDomain->BindAssemblySpec(&spec, &pDepFile, &pIAssembly,&pDynamicAssembly, NULL, &throwable);

                    if (pDynamicAssembly)
                        continue;

                    //
                    // Store the binding in the cache, as we will probably
                    // try it again later.  Keep ownership of pDepFile,
                    // though.
                    //
                    
                    if (FAILED(hr))
                    {
                        pAppDomain->StoreBindAssemblySpecError(&spec, hr, &throwable);
                    }
                    else
                    {
                        pAppDomain->StoreBindAssemblySpecResult(&spec, pDepFile, pIAssembly);
                        pIAssembly->Release();
                    }
                }

                if (depsEnd == depsMax)
                {
                    //
                    // We need a bigger array...
                    //

                    depsMax *= 2;
                    PEFileBinding *newDeps = (PEFileBinding *) 
                        _alloca(depsMax * sizeof(PEFileBinding));
                    memcpy(newDeps, deps, depsEnd * sizeof(PEFileBinding));
                    deps = newDeps;
                }

                PEFileBinding *d = &deps[depsEnd++];
                
                d->pImport = pImport;
                d->assemblyRef = ar;
                d->pPEFile = pDepFile;

                GCPROTECT_END();

                //
                // See if we've examined this binding's manifest yet.  (Note
                // that we can have different specs which bind to the same
                // manifest.)
                //

                if (pDepFile != NULL)
                {
                    BYTE *base = pDepFile->GetBase();
                
                    if (manifestHash.LookupValue((UPTR)base, base) == (BYTE*) INVALIDENTRY)
                    {
                        manifestHash.InsertValue((UPTR)base, base);
                    
                        if (peFileEnd == peFileMax)
                        {
                            //
                            // We need a bigger array...
                            //

                            peFileMax *= 2;
                            PEFile **newPeFiles = (PEFile **) 
                              _alloca(peFileMax * sizeof(PEFile **));
                            memcpy(newPeFiles, peFiles, 
                                   peFileEnd * sizeof(PEFile **));
                            peFiles = newPeFiles;
                        }
                    
                        peFiles[peFileEnd++] = pDepFile;
                    }
                }
            }
            else
            {
                LOG((LF_CODESHARING, 
                     LL_INFO10000, 
                     "Already tested spec \"%s\" (hash %d).\n",
                     spec.GetName(), spec.Hash())); 
            }
        }
        pImport->EnumClose(&e);
    }
    END_ENSURE_COOPERATIVE_GC();

    //
    // Copy dependencies into an array we can return.
    //

    *pcDeps = depsEnd;
    *ppDeps = new (nothrow) PEFileBinding [ depsEnd ];
    if (!*ppDeps)
        return E_OUTOFMEMORY;

    memcpy(*ppDeps, deps, depsEnd * sizeof(PEFileBinding));
    return S_OK;
}

HRESULT Assembly::SetSharingProperties(PEFileBinding *pDependencies, DWORD cDependencies)
{
    _ASSERTE(m_pSharingProperties == NULL);

    PEFileSharingProperties *p = new (nothrow) PEFileSharingProperties;
    if (p == NULL)
        return E_OUTOFMEMORY;

    p->pDependencies = pDependencies;
    p->cDependencies = cDependencies;
    p->shareCount = 0;

    m_pSharingProperties = p;

    return S_OK;
}

HRESULT Assembly::GetSharingProperties(PEFileBinding **ppDependencies, DWORD *pcDependencies)
{
    if (m_pSharingProperties == NULL)
    {
        *ppDependencies = NULL;
        *pcDependencies = 0;
        return S_FALSE;
    }
    else
    {

        *ppDependencies = m_pSharingProperties->pDependencies;
        *pcDependencies = m_pSharingProperties->cDependencies;
        return S_OK;
    }
}

void Assembly::IncrementShareCount()
{
    FastInterlockIncrement((long*)&m_pSharingProperties->shareCount);
}

void Assembly::DecrementShareCount()
{
    FastInterlockDecrement((long*)&m_pSharingProperties->shareCount);
}

HRESULT Assembly::CanLoadInDomain(AppDomain *pAppDomain)
{
    HRESULT hr;

    // Only make sense for shared assemblies
    _ASSERTE(IsShared());

    // If we're already loaded, then of course we can load.
    if (pAppDomain->FindAssembly(this->GetManifestFile()->GetBase()) != NULL)
        return S_OK;

    // First, try to bind the assembly's spec in the given app domain.  This 
    // will discover the case where the assembly can never even be bound in the
    // domain.

    PEFile *pFile;
    IAssembly *pIAssembly;
    Assembly *pDynamicAssembly;

    AssemblySpec spec(pAppDomain);
    GetAssemblySpec(&spec);

    // @todo: Note that we may need to throw any exception on the floor here.  This is because
    // we may be running in the debug helper thread, which can't deal with these things

    hr = pAppDomain->BindAssemblySpec(&spec, &pFile, &pIAssembly, &pDynamicAssembly, NULL, NULL);

    if (FAILED(hr))
    {
        // If we failed, the assembly cannot be shared in the domain.
        // Cache the error so we don't contradict this in the future.


        pAppDomain->StoreBindAssemblySpecError(&spec, hr, NULL);
        hr = S_FALSE;
    }
    else
    {
        // See if the assembly metadata bound to the expected assembly.

        pAppDomain->StoreBindAssemblySpecResult(&spec, pFile, pIAssembly);

        if (GetManifestFile()->GetBase() != pFile->GetBase())
            hr = S_FALSE;
        else
            hr = CanShare(pAppDomain, NULL, FALSE);

        delete pFile;
        if (pIAssembly)
            pIAssembly->Release();
    }

    return hr;
}

HRESULT Assembly::CanShare(AppDomain *pAppDomain, OBJECTREF *pThrowable, BOOL suppressLoads)
{
    HRESULT hr = S_OK;

    LOG((LF_CODESHARING, 
         LL_INFO100, 
         "Checking if we can share: \"%s\" in domain 0x%x.\n", 
         m_psName, pAppDomain));

    //
    // If we weren't able to compute sharing properties, err on the side of caution
    // & just fail.
    //

    if (m_pSharingProperties == NULL)
        return E_FAIL;

    //
    // Note that this routine has the side effect of loading a bunch of assemblies
    // into the domain.  However, because we visit the dependencies in sorted order, 
    // we at least can be sure that we won't load any assemblies which aren't part
    // of the dependencies of the assembly.  
    //
    // Also, since we will be sharing a different version of the assembly anyway, it 
    // won't matter because we will soon be loading all dependencies anyway. 
    //
    
    PEFileBinding *deps = m_pSharingProperties->pDependencies;
    PEFileBinding *depsEnd = deps + m_pSharingProperties->cDependencies;

    while (deps < depsEnd)
    {
        AssemblySpec spec;

        spec.InitializeSpec(deps->assemblyRef, deps->pImport, NULL);

        BOOL fail = FALSE;
        PEFile *pFile;
        Assembly *pDynamicAssembly = NULL;
        IAssembly* pIAssembly = NULL;

        if (suppressLoads)
        {
            //
            // Try to find the spec in our cache
            //

            if (pAppDomain->LookupAssemblySpec(&spec, &pFile, &pIAssembly, pThrowable) != S_OK
                || (pThrowable != NULL && *pThrowable != NULL))
                hr = E_FAIL;
        }
        else
        {
            hr = pAppDomain->BindAssemblySpec(&spec, &pFile, &pIAssembly, &pDynamicAssembly, NULL, pThrowable);
        }

        if ((FAILED(hr) != 0) // did we just fail
            != 
            (deps->pPEFile == NULL)) // did the cached binding fail
        {
            // Our error status doesn't match the error status of the dependency

            LOG((LF_CODESHARING, 
                 LL_INFO100, 
                 "%s %x binding dependent spec \"%S\": .\n", 
                 FAILED(hr) ? "Unexpected error" : "Didn't get expected error",
                 hr, spec.GetName()));

            fail = TRUE;
        } 

        if (pDynamicAssembly)
            fail = TRUE;

        if (!fail)
        {
            if (FAILED(hr))
            {
                // Expected error - match OK.  Make sure we store the error so it will
                // never succeed (which could lead to a binding mismatch between sharing 
                // domains)

                if (!suppressLoads)
                    pAppDomain->StoreBindAssemblySpecError(&spec, hr, pThrowable);
            }
            else
            {
                BYTE *pBoundBase = pFile->GetBase();
                LPCWSTR pBoundName = pFile->GetFileName();

                //
                // Even if these files don't match up with the shared assembly
                // we are testing for, it is likely that they will be used by whatever 
                // version of this assembly we end up using.  Therefore, we will
                // prime our cache with the bindings so the files don't get unloaded
                // & reloaded
                //

                if (!suppressLoads)
                    pAppDomain->StoreBindAssemblySpecResult(&spec, pFile, pIAssembly);

                delete pFile;
                if(pIAssembly)
                    pIAssembly->Release();

                if (pBoundBase != deps->pPEFile->GetBase())
                {
                    LOG((LF_CODESHARING,
                         LL_INFO100, 
                         "We can't share it, \"%S\" binds to \"%S\" in the current domain: .\n", 
                         spec.GetName(), pBoundName));

                    fail = TRUE;
                }
            }
        }

        if (fail)
        {
            hr = S_FALSE;
            break;
        }
        else
        {
            hr = S_OK;
        }

        deps++;
    }

    LOG((LF_CODESHARING, LL_INFO100, "We can %sshare it.\n", hr == S_OK ? "" : "not ")); 

    return hr;
}

// @todo Find a better place for these
#define DE_CUSTOM_VALUE_NAMESPACE        "System.Diagnostics"
#define DE_DEBUGGABLE_ATTRIBUTE_NAME     "DebuggableAttribute"

// @todo .INI file is a temporary hack for Beta 1
#define DE_INI_FILE_SECTION_NAME          L".NET Framework Debugging Control"
#define DE_INI_FILE_KEY_TRACK_INFO        L"GenerateTrackingInfo"
#define DE_INI_FILE_KEY_ALLOW_JIT_OPTS    L"AllowOptimize"

DWORD Assembly::ComputeDebuggingConfig()
{
#ifdef DEBUGGING_SUPPORTED
    bool fTrackJITInfo = false;
    bool fAllowJITOpts = true;
    bool fEnC = false;
    DWORD dacfFlags = DACF_NONE;
    bool fOverride = false;
    bool fHasBits;

    if ((fHasBits = GetDebuggingOverrides(&fTrackJITInfo, &fAllowJITOpts, &fOverride, &fEnC)) == false)
        fHasBits = GetDebuggingCustomAttributes(&fTrackJITInfo, &fAllowJITOpts, &fEnC);

    if (fHasBits)
    {
        if (fTrackJITInfo)
            dacfFlags |= DACF_TRACK_JIT_INFO;
        
        if (fAllowJITOpts)
            dacfFlags |= DACF_ALLOW_JIT_OPTS;

        if (fOverride)
            dacfFlags |= DACF_USER_OVERRIDE;

        if (fEnC)
            dacfFlags |= DACF_ENC_ENABLED;
    }
        
    return dacfFlags;
#else // !DEBUGGING_SUPPORTED
    return 0;
#endif // !DEBUGGING_SUPPORTED
}
        
void Assembly::SetupDebuggingConfig(void)
{
#ifdef DEBUGGING_SUPPORTED
    DWORD dacfFlags = ComputeDebuggingConfig();

    // If this process was launched by a debugger, then prevent optimized code from being produced
    if (CORLaunchedByDebugger())
    {
        dacfFlags &= ~DACF_ALLOW_JIT_OPTS;
        dacfFlags |= DACF_ENC_ENABLED;
    }

    SetDebuggerInfoBits((DebuggerAssemblyControlFlags)dacfFlags);

    LOG((LF_CORDB, LL_INFO10, "Assembly %S: bits=0x%x\n", GetManifestFile()->GetFileName(), GetDebuggerInfoBits()));
#endif // DEBUGGING_SUPPORTED
}

// The format for the (temporary) .INI file is:

// [.NET Framework Debugging Control]
// GenerateTrackingInfo=<n> where n is 0 or 1
// AllowOptimize=<n> where n is 0 or 1

// Where neither x nor y equal INVALID_INI_INT:
#define INVALID_INI_INT (0xFFFF)

bool Assembly::GetDebuggingOverrides(bool *pfTrackJITInfo, bool *pfAllowJITOpts, bool *pfOverride, bool *pfEnC)
{
#ifdef DEBUGGING_SUPPORTED
    _ASSERTE(pfTrackJITInfo);
    _ASSERTE(pfAllowJITOpts);
    _ASSERTE(pfEnC);

    bool fHasBits = false;
    WCHAR *pFileName = NULL;
    HRESULT hr = S_OK;
    UINT cbExtOrValue = 4;
    WCHAR *pTail = NULL;
    size_t len = 0;
    WCHAR *lpFileName = NULL;

    const WCHAR *wszFileName = GetManifestFile()->GetFileName();

    if (wszFileName == NULL)
        return false;

    // lpFileName is a copy of the original, and will be edited.
    CQuickBytes qb;
    len = wcslen(wszFileName);
    qb.Alloc((len + 1) * sizeof(WCHAR));
    lpFileName = (WCHAR*) qb.Ptr();
    wcscpy(lpFileName, wszFileName);

    pFileName = wcsrchr(lpFileName, L'\\');
    if (pFileName == NULL)
        pFileName = lpFileName;

    if (*pFileName == L'\\')
        pFileName++; //move the pointer past the last '\'

    _ASSERTE(wcslen(L".INI") == cbExtOrValue);

    if (pFileName == NULL || (pTail=wcsrchr(pFileName, L'.')) == NULL || (wcslen(pTail)<cbExtOrValue))
        return false;

    wcscpy(pTail, L".INI");

    // Win2K has a problem if multiple processes call GetPrivateProfile* on the same
    // non-existent .INI file simultaneously.  The OS livelocks in the kernel (i.e.
    // outside of user space) and remains there at full CPU for several minutes.  Then
    // it breaks out.  Here is our work-around, while we pursue a fix in a future
    // version of the OS.
    WIN32_FIND_DATA data;
    HANDLE h = WszFindFirstFile(lpFileName, &data);

    if (h == INVALID_HANDLE_VALUE)
        return false;

    FindClose(h);

    // Having modified the filename, we use the full path
    // to actually get the file.
    if ((cbExtOrValue=WszGetPrivateProfileInt(DE_INI_FILE_SECTION_NAME,
                                              DE_INI_FILE_KEY_TRACK_INFO,
                                              INVALID_INI_INT,
                                              lpFileName)) != INVALID_INI_INT)
    {
        if (cbExtOrValue != 0)
        {
            (*pfTrackJITInfo) = true;
        }
        else
        {
            (*pfTrackJITInfo) = false;
        }

        *pfOverride = true;
        fHasBits = true;
    }

    if ((cbExtOrValue=WszGetPrivateProfileInt(DE_INI_FILE_SECTION_NAME,
                                              DE_INI_FILE_KEY_ALLOW_JIT_OPTS,
                                              INVALID_INI_INT,
                                              lpFileName)) != INVALID_INI_INT)
    {
        // Note: for V1, EnC mode is tied to whether or not optimizations are enabled.
        if (cbExtOrValue != 0)
        {
            (*pfAllowJITOpts) = true;
            (*pfEnC) = false;
        }
        else
        {
            (*pfAllowJITOpts) = false;
            (*pfEnC) = true;
        }

        *pfOverride = true;
        fHasBits = true;
    }

    return fHasBits;

#else  // !DEBUGGING_SUPPORTED
    return false;
#endif // !DEBUGGING_SUPPORTED
}


// For right now, we only check to see if the DebuggableAttribute is present - later may add fields/properties to the
// attributes.
bool Assembly::GetDebuggingCustomAttributes(bool *pfTrackJITInfo, bool *pfAllowJITOpts, bool *pfEnC)
{
    _ASSERTE(pfTrackJITInfo);
    _ASSERTE(pfAllowJITOpts);
    _ASSERTE(pfEnC);

    bool fHasBits = false;

    ULONG size;
    BYTE *blob;
    mdModule mdMod;
    mdMod = GetManifestImport()->GetModuleFromScope();
    mdAssembly asTK = TokenFromRid(mdtAssembly, 1);
        
    HRESULT hr = S_OK;    
    hr = GetManifestImport()->GetCustomAttributeByName(asTK,
                                                       DE_CUSTOM_VALUE_NAMESPACE
                                                       NAMESPACE_SEPARATOR_STR
                                                       DE_DEBUGGABLE_ATTRIBUTE_NAME,
                                                       (const void**)&blob,
                                                       &size);

    // If there is no custom value, then there is no entrypoint defined.
    if (!(FAILED(hr) || hr == S_FALSE))
    {
        // We're expecting a 6 byte blob:
        //
        // 1, 0, enable tracking, disable opts, 0, 0
        if (size == 6)
        {
            _ASSERTE((blob[0] == 1) && (blob[1] == 0));
            
            (*pfTrackJITInfo) = (blob[2] != 0);
            (*pfAllowJITOpts) = (blob[3] == 0);

            // Note: for V1, EnC mode is tied to whether or not optimizations are enabled.
            (*pfEnC) = (blob[3] != 0);
            
            // We only say that we have bits if we're told to track.
            fHasBits = *pfTrackJITInfo;

            LOG((LF_CORDB, LL_INFO10, "Assembly %S: has %s=%d,%d\n",
                 GetManifestFile()->GetFileName(),
                 DE_DEBUGGABLE_ATTRIBUTE_NAME,
                 blob[2], blob[3]));
        }
    }

    return fHasBits;
}

BOOL Assembly::AllowUntrustedCaller()
{
    if (!m_fCheckedForAllowUntrustedCaller)
    {
        CheckAllowUntrustedCaller();
        m_fCheckedForAllowUntrustedCaller = TRUE;
    }

    return m_fAllowUntrustedCaller;
}

void Assembly::CheckAllowUntrustedCaller()
{
    SharedSecurityDescriptor* pSecDesc = this->GetSharedSecurityDescriptor();

    if (pSecDesc->IsSystem() || !this->IsStrongNamed())
    {
        m_fAllowUntrustedCaller = TRUE;
        return;
    }

    Module* pModule;
    mdToken token;
    TypeHandle attributeClass;

    pModule = this->GetSecurityModule();

    IMDInternalImport *mdImport = this->GetManifestImport();
    if (mdImport)
        mdImport->GetAssemblyFromScope(&token);
    else
        return;

    BEGIN_ENSURE_COOPERATIVE_GC();

    COMPLUS_TRY
    {
        MethodTable* pMethodTable = g_Mscorlib.GetClass( CLASS__ALLOW_PARTIALLY_TRUSTED_CALLER );
        _ASSERTE( pMethodTable != NULL && "System.Security.AllowPartiallyTrustedCallersAttribute must be defined in mscorlib" );
        attributeClass = TypeHandle( pMethodTable );

        m_fAllowUntrustedCaller = COMCustomAttribute::IsDefined( pModule,
                                                                 token,
                                                                 attributeClass,
                                                                 FALSE );
    }
    COMPLUS_CATCH
    {
        m_fAllowUntrustedCaller = FALSE;
    }
    COMPLUS_END_CATCH

    END_ENSURE_COOPERATIVE_GC();
}

//
// Manage an ITypeLib pointer for this Assembly.
//
ITypeLib* Assembly::GetTypeLib()
{
    // Get the value we are going to return.
    ITypeLib *pResult = m_pITypeLib;
    // If there is a value, AddRef() it.
    if (pResult && pResult != (ITypeLib*)-1)
        pResult->AddRef();
    return pResult;
} // ITypeLib* Assembly::GetTypeLib()

void Assembly::SetTypeLib(ITypeLib *pNew)
{
    ITypeLib *pOld;
    pOld = (ITypeLib*)InterlockedExchangePointer((PVOID*)&m_pITypeLib, (PVOID)pNew);
    // TypeLibs are refcounted pointers.
    if (pNew != pOld)
    {
        if (pNew && pNew != (ITypeLib*)-1)
            pNew->AddRef();
        if (pOld && pOld != (ITypeLib*)-1)
            pOld->Release();
    }   
} // void Assembly::SetTypeLib()

// -- eof --
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblyname.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblyName.hpp
**
** Purpose: Implements AssemblyName (loader domain) architecture
**
** Date:  August 10, 1999
**
===========================================================*/
#ifndef _AssemblyName_H
#define _AssemblyName_H

class AssemblyName
{
    friend class BaseDomain;

 public:
    static HRESULT ConvertToAssemblyMetaData(StackingAllocator* alloc,
                                             ASSEMBLYNAMEREF* pName,
                                             AssemblyMetaDataInternal* pMetaData);
};

class AssemblyNameNative
{
    struct GetFileInformationArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   filename);
    };

    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
    };

    public:
    static LPVOID __stdcall GetFileInformation(GetFileInformationArgs* args);
    static LPVOID __stdcall ToString(NoArgs* args);
    static LPVOID __stdcall GetPublicKeyToken(NoArgs* args);
    static LPVOID __stdcall EscapeCodeBase(GetFileInformationArgs *args);
};

#endif  // _AssemblyName_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblyname.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblyName.cpp
**
** Purpose: Implements AssemblyName (loader domain) architecture
**
** Date:  August 10, 1999
**
===========================================================*/

#include "common.h"

#include <stdlib.h>
#include <shlwapi.h>

#include "AssemblyName.hpp"
#include "COMString.h"
#include "permset.h"
#include "field.h"
#include "fusion.h"
#include "StrongName.h"
#include "eeconfig.h"

// This uses thread storage to allocate space. Please use Checkpoint and release it.
HRESULT AssemblyName::ConvertToAssemblyMetaData(StackingAllocator* alloc, ASSEMBLYNAMEREF* pName, AssemblyMetaDataInternal* pMetaData)
{
    THROWSCOMPLUSEXCEPTION();
    HRESULT hr = S_OK;;

    if (!pMetaData)
        return E_INVALIDARG;

    ZeroMemory(pMetaData, sizeof(AssemblyMetaDataInternal));

    VERSIONREF version = (VERSIONREF) (*pName)->GetVersion();
    if(version == NULL) {
        pMetaData->usMajorVersion = (USHORT) -1;
        pMetaData->usMinorVersion = (USHORT) -1;
        pMetaData->usBuildNumber = (USHORT) -1;         
        pMetaData->usRevisionNumber = (USHORT) -1;
    }
    else {
        pMetaData->usMajorVersion = version->GetMajor();
        pMetaData->usMinorVersion = version->GetMinor();
        pMetaData->usBuildNumber = version->GetBuild();
        pMetaData->usRevisionNumber = version->GetRevision();
    }

    MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__CULTURE_INFO__GET_NAME);
        
    struct _gc {
        OBJECTREF   cultureinfo;
        STRINGREF   pString;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    pMetaData->szLocale = 0;

    GCPROTECT_BEGIN(gc);
    gc.cultureinfo = (*pName)->GetCultureInfo();
    if (gc.cultureinfo != NULL) {
        INT64 args[] = {
            ObjToInt64(gc.cultureinfo)
        };
        INT64 ret = pMD->Call(args, METHOD__CULTURE_INFO__GET_NAME);
        gc.pString = ObjectToSTRINGREF(*(StringObject**)(&ret));
        if (gc.pString != NULL) {
            DWORD lgth = WszWideCharToMultiByte(CP_UTF8, 0, gc.pString->GetBuffer(), -1, NULL, 0, NULL, NULL);
            LPSTR lpLocale = (LPSTR) alloc->Alloc(lgth + 1);
            WszWideCharToMultiByte(CP_UTF8, 0, gc.pString->GetBuffer(), -1, 
                                   lpLocale, lgth+1, NULL, NULL);
            lpLocale[lgth] = '\0';
            pMetaData->szLocale = lpLocale;
        }
    }

    GCPROTECT_END();
    if(FAILED(hr)) return hr;

    return hr;
}

static WCHAR prefix[] = L"file://";

LPVOID __stdcall AssemblyNameNative::GetFileInformation(GetFileInformationArgs *args)
{
    LPVOID rv = NULL; 
    WCHAR *FileChars;
    int fLength;

    THROWSCOMPLUSEXCEPTION();

    if (args->filename == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_FileName");

    //Get string data.
    RefInterpretGetStringValuesDangerousForGC((STRINGREF)args->filename, &FileChars, &fLength);

    if (!fLength)
        COMPlusThrow(kArgumentException, L"Argument_EmptyFileName");

    CQuickBytes qb;  
    DWORD dwFileLength = (DWORD) fLength;
    LPWSTR wszFileChars = (LPWSTR) qb.Alloc((++dwFileLength) * sizeof(WCHAR));
    memcpy(wszFileChars, FileChars, dwFileLength*sizeof(WCHAR));

    UINT last = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS);
    HCORMODULE hModule;
    HRESULT hr = CorMap::OpenFile(wszFileChars, CorLoadOSMap, &hModule);
    SetErrorMode(last);

    PEFile *pFile = NULL;
    if (SUCCEEDED(hr))
        hr = PEFile::Create(hModule, &pFile, FALSE);

	if (FAILED(hr)) {
        OBJECTREF Throwable = NULL;
        GCPROTECT_BEGIN(Throwable);

        MAKE_UTF8PTR_FROMWIDE(szName, wszFileChars);
        PostFileLoadException(szName, TRUE, NULL, hr, &Throwable);
        COMPlusThrow(Throwable);

        GCPROTECT_END();
    }

    if (! (pFile->GetMDImport())) {
        delete pFile;
        COMPlusThrowHR(COR_E_BADIMAGEFORMAT);
    }

    ASSEMBLYNAMEREF name = NULL;
    GCPROTECT_BEGIN(name);
    {
        Assembly assembly;

        hr = assembly.AddManifestMetadata(pFile);
        if (SUCCEEDED(hr)) {
            assembly.m_FreeFlag |= Assembly::FREE_PEFILE;
            hr = assembly.GetManifestFile()->ReadHeaders();
        }

        if (FAILED(hr))
            COMPlusThrowHR(hr);

        assembly.m_FreeFlag |= Assembly::FREE_PEFILE;

        CQuickBytes qb2;
        DWORD dwCodeBase = 0;
        pFile->FindCodeBase(NULL, &dwCodeBase);
        LPWSTR wszCodeBase = (LPWSTR)qb2.Alloc((++dwCodeBase) * sizeof(WCHAR));

        hr = pFile->FindCodeBase(wszCodeBase, &dwCodeBase);
        if (SUCCEEDED(hr))
            assembly.m_pwCodeBase = wszCodeBase;
        else
            COMPlusThrowHR(hr);

        assembly.m_ExposedObject = SystemDomain::System()->GetCurrentDomain()->CreateHandle(NULL);

        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__ASSEMBLY__GET_NAME);

        INT64 args[1] = {
            ObjToInt64(assembly.GetExposedObject())
        };

        name = (ASSEMBLYNAMEREF) Int64ToObj(pMD->Call(args, METHOD__ASSEMBLY__GET_NAME));
        name->UnsetAssembly();

        // Don't let ~Assembly delete this.
        assembly.m_pwCodeBase = NULL;
        DestroyHandle(assembly.m_ExposedObject);

    } GCPROTECT_END();  // The ~Assembly() will toggle the GC mode that can cause a GC
    
    *((OBJECTREF*) &rv) = name;
    return rv;
}

LPVOID __stdcall AssemblyNameNative::ToString(NoArgs* args)
{
    LPVOID rv = NULL; 
#ifdef FUSION_SUPPORTED

    THROWSCOMPLUSEXCEPTION();
    if (args->refThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    HRESULT hr;
    ASSEMBLYNAMEREF pThis = (ASSEMBLYNAMEREF) args->refThis;
    GCPROTECT_BEGIN(pThis);

    DWORD dwFlags = pThis->GetFlags();

    AssemblyMetaDataInternal sContext;
    Thread *pThread = GetThread();

    void* checkPointMarker = pThread->m_MarshalAlloc.GetCheckpoint();

    hr = AssemblyName::ConvertToAssemblyMetaData(&(pThread->m_MarshalAlloc), 
                                                 (ASSEMBLYNAMEREF*) &pThis,
                                                 &sContext);
    if (SUCCEEDED(hr)) {

        WCHAR* pSimpleName = NULL;

        if (pThis->GetSimpleName() != NULL) {
            WCHAR* pString;
            int    iString;
            RefInterpretGetStringValuesDangerousForGC((STRINGREF) pThis->GetSimpleName(), &pString, &iString);
            pSimpleName = (WCHAR*) pThread->m_MarshalAlloc.Alloc((++iString) * sizeof(WCHAR));
            memcpy(pSimpleName, pString, iString*sizeof(WCHAR));
        }

        PBYTE  pbPublicKeyOrToken = NULL;
        DWORD  cbPublicKeyOrToken = 0;
        if (IsAfPublicKey(pThis->GetFlags()) && pThis->GetPublicKey() != NULL) {
            PBYTE  pArray = NULL;
            pArray = pThis->GetPublicKey()->GetDataPtr();
            cbPublicKeyOrToken = pThis->GetPublicKey()->GetNumComponents();
            pbPublicKeyOrToken = (PBYTE) pThread->m_MarshalAlloc.Alloc(cbPublicKeyOrToken);
            memcpy(pbPublicKeyOrToken, pArray, cbPublicKeyOrToken);
        }
        else if (IsAfPublicKeyToken(pThis->GetFlags()) && pThis->GetPublicKeyToken() != NULL) {
            PBYTE  pArray = NULL;
            pArray = pThis->GetPublicKeyToken()->GetDataPtr();
            cbPublicKeyOrToken = pThis->GetPublicKeyToken()->GetNumComponents();
            pbPublicKeyOrToken = (PBYTE) pThread->m_MarshalAlloc.Alloc(cbPublicKeyOrToken);
            memcpy(pbPublicKeyOrToken, pArray, cbPublicKeyOrToken);
        }

        IAssemblyName* pFusionAssemblyName = NULL;
        if (SUCCEEDED(hr = Assembly::SetFusionAssemblyName(pSimpleName,
                                                           dwFlags,
                                                           &sContext,
                                                           pbPublicKeyOrToken,
                                                           cbPublicKeyOrToken,
                                                           &pFusionAssemblyName))) {
            CQuickBytes qb;
            DWORD cb = 0;
            LPWSTR wszDisplayName = NULL;

            pFusionAssemblyName->GetDisplayName(NULL, &cb, 0);
            if(cb) {
                wszDisplayName = (LPWSTR) qb.Alloc(cb * sizeof(WCHAR));
                hr = pFusionAssemblyName->GetDisplayName(wszDisplayName, &cb, 0);
            }
            pFusionAssemblyName->Release();

            if (SUCCEEDED(hr) && cb) {
                    OBJECTREF pObj = (OBJECTREF) COMString::NewString(wszDisplayName);
                    *((OBJECTREF*)(&rv)) = pObj;
                }
            }
    }

    pThread->m_MarshalAlloc.Collapse(checkPointMarker);

    GCPROTECT_END();

    if (FAILED(hr))
        COMPlusThrowHR(hr);

#endif // FUSION_SUPPORTED
    return rv;
}

LPVOID __stdcall AssemblyNameNative::GetPublicKeyToken(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();
    if (args->refThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    LPVOID rv = NULL;
    ASSEMBLYNAMEREF orThis = (ASSEMBLYNAMEREF)args->refThis;
    U1ARRAYREF orPublicKey = orThis->GetPublicKey();

    if ((orPublicKey != NULL) && (orPublicKey->GetNumComponents() > 0)) {
        DWORD   cbKey = orPublicKey->GetNumComponents();
        CQuickBytes qb;
        BYTE   *pbKey = (BYTE*) qb.Alloc(cbKey);
        DWORD   cbToken;
        BYTE   *pbToken;

        memcpy(pbKey, orPublicKey->GetDataPtr(), cbKey);

        Thread *pThread = GetThread();
        pThread->EnablePreemptiveGC();
        BOOL fResult = StrongNameTokenFromPublicKey(pbKey, cbKey, &pbToken, &cbToken);
        pThread->DisablePreemptiveGC();

        if (!fResult)
            COMPlusThrowHR(StrongNameErrorInfo());

        OBJECTREF orOutputArray = NULL;
        SecurityHelper::CopyEncodingToByteArray(pbToken, cbToken, &orOutputArray);

        StrongNameFreeBuffer(pbToken);

        *((OBJECTREF*)(&rv)) = orOutputArray;
    }

    return rv;
}


LPVOID __stdcall AssemblyNameNative::EscapeCodeBase(GetFileInformationArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    LPVOID rv = NULL;
    LPWSTR pCodeBase = NULL;
    DWORD  dwCodeBase = 0;
    CQuickBytes qb;

    if (args->filename != NULL) {
        WCHAR* pString;
        int    iString;
        RefInterpretGetStringValuesDangerousForGC(args->filename, &pString, &iString);
        dwCodeBase = (DWORD) iString;
        pCodeBase = (LPWSTR) qb.Alloc((++dwCodeBase) * sizeof(WCHAR));
        memcpy(pCodeBase, pString, dwCodeBase*sizeof(WCHAR));
    }

    if(pCodeBase) {
        CQuickBytes qb2;
        DWORD dwEscaped = 1;
        UrlEscape(pCodeBase, (LPWSTR) qb2.Ptr(), &dwEscaped, 0);

        LPWSTR result = (LPWSTR)qb2.Alloc((++dwEscaped) * sizeof(WCHAR));
        HRESULT hr = UrlEscape(pCodeBase, result, &dwEscaped, 0);

        if (SUCCEEDED(hr))
            *((OBJECTREF*)(&rv)) = (OBJECTREF) COMString::NewString(result);
        else
            COMPlusThrowHR(hr);
    }

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblynative.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblyNative.hpp
**
** Purpose: Implements AssemblyNative (loader domain) architecture
**
** Date:  Oct 26, 1998
**
===========================================================*/
#ifndef _ASSEMBLYNATIVE_H
#define _ASSEMBLYNATIVE_H


class AssemblyNative
{
    friend class COMClass;
    friend class Assembly;
    friend class BaseDomain;

    struct LoadFullAssemblyArgs
    {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYREF, locationHint);
        DECLARE_ECALL_I4_ARG(BOOL, fThrowOnFileNotFound);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, security);
        DECLARE_ECALL_I4_ARG(BOOL, fIsStringized); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, codeBase);
        DECLARE_ECALL_OBJECTREF_ARG(ASSEMBLYNAMEREF, assemblyName);
    };

    struct LoadAssemblyImageArgs
    {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, security);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  SymByteArray);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  PEByteArray);
    };

    struct LoadAssemblyFileArgs
    {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF, security);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF, path);
    };

    struct LoadModuleImageArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   security);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  SymByteArray);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  PEByteArray);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   moduleName);
    };

    struct GetNameArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };

    struct GetResourceInfoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF*,  pFileName);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF*,  pAssemblyRef);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };

    struct GetResourceArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(bool,               skipSecurityCheck);
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *, stackMark);
        DECLARE_ECALL_I4_ARG(UINT64 *,   length);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };

    struct GetType1Arg
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };
    struct GetType2Arg
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };
    struct GetType3Arg
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bIgnoreCase);
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };
    struct GetTypeInternalArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(DWORD, bPublicOnly);
        DECLARE_ECALL_I4_ARG(DWORD, bIgnoreCase);
        DECLARE_ECALL_I4_ARG(DWORD, bThrowOnError); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   name);
    };

    struct NoArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
    };

    struct _ParseNameArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   typeName);
    };

    struct EmptyArgs
    {
    };

    struct GetCodebaseArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(INT32, fCopiedName); 
    };

    struct GetModulesArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(INT32, fGetResourceModules); 
        DECLARE_ECALL_I4_ARG(INT32, fLoadIfNotFound); 
    };

    struct GetModuleArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFileName);
    };

    struct PrepareSavingManifestArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(REFLECTMODULEBASEREF, module);
    };

    struct AddFileListArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFileName);
    };

    struct SetHashValueArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFullFileName);
        DECLARE_ECALL_I4_ARG(INT32, tkFile);
    };

    struct AddExportedTypeArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(INT32, flags); 
        DECLARE_ECALL_I4_ARG(INT32, tkTypeDef); 
        DECLARE_ECALL_I4_ARG(INT32, ar); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strCOMTypeName);
    };
    struct AddStandAloneResourceArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(INT32, iAttribute); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFullFileName);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFileName);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strName);
    };
    struct SavePermissionRequestsArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  refused);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  optional);
        DECLARE_ECALL_OBJECTREF_ARG(U1ARRAYREF,  required);
    };
    struct SaveManifestToDiskArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_I4_ARG(INT32, fileKind); 
        DECLARE_ECALL_I4_ARG(INT32, entrypoint); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strManifestFileName);
    };
    struct AddFileToInMemoryFileListArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refThis);
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,   refModule);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strModuleFileName);
    };
    struct CreateQualifiedNameArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strTypeName);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strAssemblyName);
    };

    struct GetGrantSetArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,  refThis);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*,       ppDenied);
        DECLARE_ECALL_PTR_ARG(OBJECTREF*,       ppGranted);
    };

    struct GetExecutingAssemblyArgs
    {
        DECLARE_ECALL_PTR_ARG(StackCrawlMark *,       stackMark);
    };

    struct GetVersionArgs
    {
        DECLARE_ECALL_OBJECTREF_ARG(OBJECTREF,  refThis);
        DECLARE_ECALL_PTR_ARG(INT32 *, pRevisionNumber);
        DECLARE_ECALL_PTR_ARG(INT32 *, pBuildNumber );
        DECLARE_ECALL_PTR_ARG(INT32 *, pMinorVersion);
        DECLARE_ECALL_PTR_ARG(INT32 *, pMajorVersion );
    };

    struct DefineVersionInfoResourceArgs
    {
        DECLARE_ECALL_I4_ARG(BOOL,  fIsDll); 
        DECLARE_ECALL_I4_ARG(INT32, lcid); 
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFileVersion);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strProductVersion);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strProduct);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strCompany);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strTrademark);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strCopyright);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strDescription);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strIconFilename);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strTitle);
        DECLARE_ECALL_OBJECTREF_ARG(STRINGREF,   strFilename);
    };

protected:

    static BOOL HaveReflectionPermission(BOOL ThrowOnFalse);
    
public:
    static Assembly *ValidateThisRef(ASSEMBLYREF pThis);

    static LPVOID __stdcall Load(LoadFullAssemblyArgs *args);
    static LPVOID __stdcall LoadFile(LoadAssemblyFileArgs *args);
    static LPVOID __stdcall LoadImage(LoadAssemblyImageArgs *args);
    static LPVOID __stdcall LoadModuleImage(LoadModuleImageArgs *args);
    static LPVOID __stdcall GetLocation(NoArgs *args);
    static LPVOID __stdcall GetTypeInternal(GetTypeInternalArgs *args);
    static LPVOID __stdcall GetType1Args(GetType1Arg *args);
    static LPVOID __stdcall GetType2Args(GetType2Arg *args);
    static LPVOID __stdcall GetType3Args(GetType3Arg *args);
    static LPVOID GetTypeInner(Assembly *pAssem,
                               STRINGREF *refClassName, 
                               BOOL bThrowOnError, 
                               BOOL bIgnoreCase, 
                               BOOL bVerifyAccess,
                               BOOL bPublicOnly);
    static BYTE*  __stdcall GetResource(GetResourceArgs *args);
    static INT32  __stdcall GetManifestResourceInfo(GetResourceInfoArgs *args);
    static LPVOID __stdcall GetExecutingAssembly(GetExecutingAssemblyArgs *args);
    static LPVOID __stdcall GetEntryAssembly(EmptyArgs *args);
    static INT32 __stdcall GetVersion(GetVersionArgs *args);
    static LPVOID __stdcall GetPublicKey(NoArgs *args);
    static LPVOID __stdcall GetSimpleName(NoArgs *args);
    static LPVOID __stdcall GetLocale(NoArgs *args);
    static LPVOID __stdcall GetCodeBase(GetCodebaseArgs *args);
    static INT32 __stdcall GetHashAlgorithm(NoArgs *args);
    static INT32 __stdcall GetFlags(NoArgs *args);
    static LPVOID __stdcall GetModules(GetModulesArgs *args);
    static LPVOID __stdcall GetModule(GetModuleArgs *args);
    static LPVOID __stdcall GetExportedTypes(NoArgs *args);
    static LPVOID __stdcall GetResourceNames(NoArgs *args);
    static LPVOID __stdcall GetReferencedAssemblies(NoArgs *args);
    static LPVOID __stdcall GetEntryPoint(NoArgs *args);
    static void __stdcall PrepareSavingManifest(PrepareSavingManifestArgs *args);
    static mdFile __stdcall AddFileList(AddFileListArgs *args);
    static void __stdcall SetHashValue(SetHashValueArgs *args);
    static mdExportedType __stdcall AddExportedType(AddExportedTypeArgs *args);    
    static void __stdcall AddStandAloneResource(AddStandAloneResourceArgs *args);    
    static void __stdcall SavePermissionRequests(SavePermissionRequestsArgs *args);
    static void __stdcall SaveManifestToDisk(SaveManifestToDiskArgs *args);
    static void __stdcall AddFileToInMemoryFileList(AddFileToInMemoryFileListArgs *args);
    static LPVOID __stdcall GetStringizedName(NoArgs *args);
    static LPVOID __stdcall CreateQualifiedName(CreateQualifiedNameArgs *args);
    static void __stdcall ForceResolve(NoArgs *args);
    static void __stdcall GetGrantSet(GetGrantSetArgs *args);
    static LPVOID __stdcall GetOnDiskAssemblyModule(NoArgs *args);
    static LPVOID __stdcall GetInMemoryAssemblyModule(NoArgs *args);
    static LPVOID __stdcall DefineVersionInfoResource(DefineVersionInfoResourceArgs *args);
    static LPVOID __stdcall GetExportedTypeLibGuid(NoArgs *args);
    static INT32 __stdcall GlobalAssemblyCache(NoArgs *args);
    static LPVOID __stdcall GetImageRuntimeVersion(NoArgs *args);

    // Parse the type name to find the assembly Name,
    static HRESULT FindAssemblyName(LPUTF8 szFullClassName,
                                    LPUTF8* pszAssemblyName,
                                    LPUTF8* pszNameSpaceSep);
    static LPVOID __stdcall ParseTypeName(_ParseNameArgs* args);


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblynativeresource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// ResFile.H
// This handles Win32Resources
//

#pragma once

class CFile;

class Win32Res {
public:
    Win32Res();
    ~Win32Res();

    HRESULT SetInfo(LPCWSTR szFile, 
                    LPCWSTR szTitle, 
                    LPCWSTR szIconName, 
                    LPCWSTR szDescription,
                    LPCWSTR szCopyright, 
                    LPCWSTR szTrademark, 
                    LPCWSTR szCompany, 
                    LPCWSTR szProduct, 
                    LPCWSTR szProductVersion,
                    LPCWSTR szFileVersion, 
                    int lcid, 
                    BOOL fDLL);
    HRESULT MakeResFile(const void **pData, DWORD  *pcbData);

private:
#define PadKeyLen(cb) ((((cb) + 5) & ~3) - 2)
#define PadValLen(cb) ((cb + 3) & ~3)
#define KEYSIZE(sz) (PadKeyLen(sizeof(sz)*sizeof(WCHAR))/sizeof(WCHAR))
#define KEYBYTES(sz) (KEYSIZE(sz)*sizeof(WCHAR))
#define HDRSIZE (3 * sizeof(WORD))

    static WORD             SizeofVerString(LPCWSTR lpszKey, LPCWSTR lpszValue);
    HRESULT                 WriteVerString(LPCWSTR lpszKey, LPCWSTR lpszValue);
    HRESULT                 WriteVerResource();
    HRESULT                 WriteIconResource();

    HRESULT                 Write(void *pData, size_t len);
    LPCWSTR     m_szFile;
    LPCWSTR     m_Icon;
	enum {
		v_Description, 
		v_Title, 
		v_Copyright, 
		v_Trademark, 
		v_Product, 
		v_ProductVersion, 
		v_Company, 
		v_FileVersion, 
		NUM_VALUES
		};
    LPCWSTR     m_Values[NUM_VALUES];
	ULONG		m_Version[4];
    int         m_lcid;
    BOOL        m_fDll;
    PBYTE       m_pData;
    PBYTE       m_pCur;
    PBYTE       m_pEnd;


    // RES file structs (borrowed from MSDN)
#pragma pack( push)
#pragma pack(1)
    struct RESOURCEHEADER {
        DWORD DataSize;
        DWORD HeaderSize;
        WORD  Magic1;
        WORD  Type;
        WORD  Magic2;
        WORD  Name;
        DWORD DataVersion;
        WORD  MemoryFlags;
        WORD  LanguageId;
        DWORD Version;
        DWORD Characteristics;
    };

    struct ICONDIRENTRY {
        BYTE  bWidth;
        BYTE  bHeight;
        BYTE  bColorCount;
        BYTE  bReserved;
        WORD  wPlanes;
        WORD  wBitCount;
        DWORD dwBytesInRes;
        DWORD dwImageOffset;
    };

    struct ICONRESDIR {
        BYTE  Width;        // = ICONDIRENTRY.bWidth;
        BYTE  Height;       // = ICONDIRENTRY.bHeight;
        BYTE  ColorCount;   // = ICONDIRENTRY.bColorCount;
        BYTE  reserved;     // = ICONDIRENTRY.bReserved;
        WORD  Planes;       // = ICONDIRENTRY.wPlanes;
        WORD  BitCount;     // = ICONDIRENTRY.wBitCount;
        DWORD BytesInRes;   // = ICONDIRENTRY.dwBytesInRes;
        WORD  IconId;       // = RESOURCEHEADER.Name
    };
    struct EXEVERRESOURCE {
        WORD cbRootBlock;                                     // size of whole resource
        WORD cbRootValue;                                     // size of VS_FIXEDFILEINFO structure
        WORD fRootText;                                       // root is text?
        WCHAR szRootKey[KEYSIZE("VS_VERSION_INFO")];          // Holds "VS_VERSION_INFO"
        VS_FIXEDFILEINFO vsFixed;                             // fixed information.
        WORD cbVarBlock;                                      //   size of VarFileInfo block
        WORD cbVarValue;                                      //   always 0
        WORD fVarText;                                        //   VarFileInfo is text?
        WCHAR szVarKey[KEYSIZE("VarFileInfo")];               //   Holds "VarFileInfo"
        WORD cbTransBlock;                                    //     size of Translation block
        WORD cbTransValue;                                    //     size of Translation value
        WORD fTransText;                                      //     Translation is text?
        WCHAR szTransKey[KEYSIZE("Translation")];             //     Holds "Translation"
        WORD langid;                                          //     language id
        WORD codepage;                                        //     codepage id
        WORD cbStringBlock;                                   //   size of StringFileInfo block
        WORD cbStringValue;                                   //   always 0
        WORD fStringText;                                     //   StringFileInfo is text?
        WCHAR szStringKey[KEYSIZE("StringFileInfo")];         //   Holds "StringFileInfo"
        WORD cbLangCpBlock;                                   //     size of language/codepage block
        WORD cbLangCpValue;                                   //     always 0
        WORD fLangCpText;                                     //     LangCp is text?
        WCHAR szLangCpKey[KEYSIZE("12345678")];               //     Holds hex version of language/codepage
        // followed by strings
    };
#pragma pack( pop)
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblynativeresource.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
////////////////////////////////////////////////////////////////////////////////
// ResFile.CPP

#include "common.h"

//#include "stdafx.h"
#include "AssemblyNativeResource.h"
#include <limits.h>
#include <ddeml.h>

extern "C" _CRTIMP int    __cdecl swscanf(const wchar_t *, const wchar_t *, ...);

#ifndef MAKEINTRESOURCE
 #define MAKEINTRESOURCE MAKEINTRESOURCEW
#endif

Win32Res::Win32Res()
{
    m_szFile = NULL;
    m_Icon = NULL;
    for (int i = 0; i < NUM_VALUES; i++)
        m_Values[i] = NULL;
    for (i = 0; i < NUM_VALUES; i++)
        m_Values[i] = NULL;
    m_fDll = false;
    m_pData = NULL;
    m_pCur = NULL;
    m_pEnd = NULL;
}

Win32Res::~Win32Res()
{
    m_szFile = NULL;
    m_Icon = NULL;
    for (int i = 0; i < NUM_VALUES; i++)
        m_Values[i] = NULL;
    for (i = 0; i < NUM_VALUES; i++)
        m_Values[i] = NULL;
    m_fDll = false;
    if (m_pData)
        delete [] m_pData;
    m_pData = NULL;
    m_pCur = NULL;

    m_pEnd = NULL;
}

//*****************************************************************************
// Initializes the structures with version information.
//*****************************************************************************
HRESULT Win32Res::SetInfo(
	LPCWSTR 	szFile, 
	LPCWSTR 	szTitle, 
	LPCWSTR 	szIconName, 
	LPCWSTR 	szDescription,
    LPCWSTR 	szCopyright, 
	LPCWSTR 	szTrademark, 
	LPCWSTR 	szCompany, 
	LPCWSTR 	szProduct, 
	LPCWSTR 	szProductVersion,
    LPCWSTR 	szFileVersion, 
    int         lcid,
	BOOL 		fDLL)
{
    _ASSERTE(szFile != NULL);

    m_szFile = szFile;
    if (szIconName && szIconName[0] != 0)
        m_Icon = szIconName;    // a non-mepty string

#define NonNull(sz) (sz == NULL || *sz == L'\0' ? L" " : sz)
    m_Values[v_Description] 	= NonNull(szDescription);
    m_Values[v_Title] 			= NonNull(szTitle);
    m_Values[v_Copyright] 		= NonNull(szCopyright);
    m_Values[v_Trademark] 		= NonNull(szTrademark);
    m_Values[v_Product] 		= NonNull(szProduct);
    m_Values[v_ProductVersion] 	= NonNull(szProductVersion);
    m_Values[v_Company] 		= NonNull(szCompany);
	m_Values[v_FileVersion] 	= NonNull(szFileVersion);
#undef NonNull

    m_fDll = fDLL;
    m_lcid = lcid;
    return S_OK;
}

HRESULT Win32Res::MakeResFile(const void **pData, DWORD  *pcbData)
{
    static RESOURCEHEADER magic = { 0x00000000, 0x00000020, 0xFFFF, 0x0000, 0xFFFF, 0x0000,
                        0x00000000, 0x0000, 0x0000, 0x00000000, 0x00000000 };
    _ASSERTE(pData != NULL && pcbData != NULL);

    HRESULT hr;

    *pData = NULL;
    *pcbData = 0;
    if ((m_pData = new (nothrow) BYTE[(sizeof(RESOURCEHEADER) * 3 + sizeof(EXEVERRESOURCE))]) == NULL)
        return E_OUTOFMEMORY;
    m_pCur = m_pData;
    m_pEnd = m_pData + sizeof(RESOURCEHEADER) * 3 + sizeof(EXEVERRESOURCE);

    // inject the magic empty entry
    if (FAILED(hr = Write( &magic, sizeof(magic)))) {
        return hr;
    }

    if (FAILED(hr = WriteVerResource()))
        return hr;

    if (m_Icon && FAILED(hr = WriteIconResource()))
        return hr;

    *pData = m_pData;
    *pcbData = (DWORD)(m_pCur - m_pData);
    return S_OK;
}


/*
 * WriteIconResource
 *   Writes the Icon resource into the RES file.
 *
 * RETURNS: TRUE on succes, FALSE on failure (errors reported to user)
 */
HRESULT Win32Res::WriteIconResource()
{
    HANDLE hIconFile = INVALID_HANDLE_VALUE;
    WORD wTemp, wCount, resID = 2;  // Skip 1 for the version ID
    DWORD dwRead = 0, dwWritten = 0;
    HRESULT hr;
    ICONRESDIR *grp = NULL;
    PBYTE icoBuffer = NULL;
    RESOURCEHEADER grpHeader = { 0x00000000, 0x00000020, 0xFFFF, (WORD)RT_GROUP_ICON, 0xFFFF, 0x7F00, // 0x7F00 == IDI_APPLICATION
                0x00000000, 0x1030, 0x0000, 0x00000000, 0x00000000 };

    // Read the icon
    hIconFile = WszCreateFile( m_Icon, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
        FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hIconFile == INVALID_HANDLE_VALUE) {
        hr = GetLastError();
        goto FAILED;
    }

    // Read the magic reserved WORD
    if (ReadFile( hIconFile, &wTemp, sizeof(WORD), &dwRead, NULL) == FALSE) {
        hr = GetLastError();
        goto FAILED;
    } else if (wTemp != 0 || dwRead != sizeof(WORD))
        goto BAD_FORMAT;


    // Verify the Type WORD
    if (ReadFile( hIconFile, &wCount, sizeof(WORD), &dwRead, NULL) == FALSE) {
        hr = GetLastError();
        goto FAILED;
    } else if (wCount != 1 || dwRead != sizeof(WORD))
        goto BAD_FORMAT;

    // Read the Count WORD
    if (ReadFile( hIconFile, &wCount, sizeof(WORD), &dwRead, NULL) == FALSE) {
        hr = GetLastError();
        goto FAILED;
    } else if (wCount == 0 || dwRead != sizeof(WORD))
        goto BAD_FORMAT;


    if ((grp = new (nothrow) ICONRESDIR[wCount]) == NULL) {
        hr = E_OUTOFMEMORY;
        goto CLEANUP;
    }
    grpHeader.DataSize = 3 * sizeof(WORD) + wCount * sizeof(ICONRESDIR);

    // For each Icon
    for (WORD i = 0; i < wCount; i++) {
        ICONDIRENTRY ico;
        DWORD        icoPos, newPos;
        RESOURCEHEADER icoHeader = { 0x00000000, 0x00000020, 0xFFFF, (WORD)RT_ICON, 0xFFFF, 0x0000,
                    0x00000000, 0x1010, 0x0000, 0x00000000, 0x00000000 };
        icoHeader.Name = resID++;

        // Read the Icon header
        if (ReadFile( hIconFile, &ico, sizeof(ICONDIRENTRY), &dwRead, NULL) == FALSE) {
            hr = GetLastError();
            goto FAILED;
        } else if (dwRead != sizeof(ICONDIRENTRY))
            goto BAD_FORMAT;

        _ASSERTE(sizeof(ICONRESDIR) + sizeof(WORD) == sizeof(ICONDIRENTRY));
        memcpy(grp + i, &ico, sizeof(ICONRESDIR));
        grp[i].IconId = icoHeader.Name;
        icoHeader.DataSize = ico.dwBytesInRes;
        if ((icoBuffer = new (nothrow) BYTE[icoHeader.DataSize]) == NULL) {
            hr = E_OUTOFMEMORY;
            goto CLEANUP;
        }

        // Write the header to the RES file
        if (FAILED(hr = Write( &icoHeader, sizeof(RESOURCEHEADER))))
            goto CLEANUP;

        // Position to read the Icon data
        icoPos = SetFilePointer( hIconFile, 0, NULL, FILE_CURRENT);
        if (icoPos == INVALID_SET_FILE_POINTER) {
            hr = GetLastError();
            goto FAILED;
        }
        newPos = SetFilePointer( hIconFile, ico.dwImageOffset, NULL, FILE_BEGIN);
        if (newPos == INVALID_SET_FILE_POINTER) {
            hr = GetLastError();
            goto FAILED;
        }

        // Actually read the data
        if (ReadFile( hIconFile, icoBuffer, icoHeader.DataSize, &dwRead, NULL) == FALSE) {
            hr = GetLastError();
            goto FAILED;
        } else if (dwRead != icoHeader.DataSize)
            goto BAD_FORMAT;

        // Because Icon files don't seem to record the actual Planes and BitCount in 
        // the ICONDIRENTRY, get the info from the BITMAPINFOHEADER at the beginning
        // of the data here:
        grp[i].Planes = ((BITMAPINFOHEADER*)icoBuffer)->biPlanes;
        grp[i].BitCount = ((BITMAPINFOHEADER*)icoBuffer)->biBitCount;

        // Now write the data to the RES file
        if (FAILED(hr = Write( icoBuffer, icoHeader.DataSize)))
            goto CLEANUP;
        
        delete [] icoBuffer;
        icoBuffer = NULL;

        // Reposition to read the next Icon header
        newPos = SetFilePointer( hIconFile, icoPos, NULL, FILE_BEGIN);
        if (newPos != icoPos) {
            hr = GetLastError();
            goto FAILED;
        }
    }

    // inject the icon group
    if (FAILED(hr = Write( &grpHeader, sizeof(RESOURCEHEADER))))
        goto CLEANUP;


    // Write the header to the RES file
    wTemp = 0; // the reserved WORD
    if (FAILED(hr = Write( &wTemp, sizeof(WORD))))
        goto CLEANUP;

    wTemp = RES_ICON; // the GROUP type
    if (FAILED(hr = Write( &wTemp, sizeof(WORD))))
        goto CLEANUP;

    if (FAILED(hr = Write( &wCount, sizeof(WORD))))
        goto CLEANUP;

    // now write the entries
    hr = Write( grp, sizeof(ICONRESDIR) * wCount);
    goto CLEANUP;

BAD_FORMAT:
    hr = ERROR_INVALID_DATA;

FAILED:
    hr = HRESULT_FROM_WIN32(hr);

CLEANUP:
    if (hIconFile != INVALID_HANDLE_VALUE)
        CloseHandle(hIconFile);

    if (grp != NULL)
        delete [] grp;
    if (icoBuffer != NULL)
        delete [] icoBuffer;

    return hr;
}

/*
 * WriteVerResource
 *   Writes the version resource into the RES file.
 *
 * RETURNS: TRUE on succes, FALSE on failure (errors reported to user)
 */
HRESULT Win32Res::WriteVerResource()
{
    WCHAR szLangCp[9];           // language/codepage string.
    EXEVERRESOURCE VerResource;
    WORD  cbStringBlocks;
    HRESULT hr;
    int i;
    bool bUseFileVer = false;
	WCHAR		rcFile[_MAX_PATH];		        // Name of file without path
	WCHAR		rcFileExtension[_MAX_PATH];		// file extension
	WCHAR		rcFileName[_MAX_PATH];		    // Name of file with extension but without path
    DWORD       cbTmp;

    THROWSCOMPLUSEXCEPTION();

	SplitPath(m_szFile, 0, 0, rcFile, rcFileExtension);

    wcscpy(rcFileName, rcFile);
    wcscat(rcFileName, rcFileExtension);

    static EXEVERRESOURCE VerResourceTemplate = {
        sizeof(EXEVERRESOURCE), sizeof(VS_FIXEDFILEINFO), 0, L"VS_VERSION_INFO",
        {
            VS_FFI_SIGNATURE,           // Signature
            VS_FFI_STRUCVERSION,        // structure version
            0, 0,                       // file version number
            0, 0,                       // product version number
            VS_FFI_FILEFLAGSMASK,       // file flags mask
            0,                          // file flags
            VOS__WINDOWS32,
            VFT_APP,                    // file type
            0,                          // subtype
            0, 0                        // file date/time
        },
        sizeof(WORD) * 2 + 2 * HDRSIZE + KEYBYTES("VarFileInfo") + KEYBYTES("Translation"),
        0,
        1,
        L"VarFileInfo",
        sizeof(WORD) * 2 + HDRSIZE + KEYBYTES("Translation"),
        sizeof(WORD) * 2,
        0,
        L"Translation",
        0,
        0,
        2 * HDRSIZE + KEYBYTES("StringFileInfo") + KEYBYTES("12345678"),
        0,
        1,
        L"StringFileInfo",
        HDRSIZE + KEYBYTES("12345678"),
        0,
        1,
        L"12345678"
    };
    static const WCHAR szComments[] = L"Comments";
    static const WCHAR szCompanyName[] = L"CompanyName";
    static const WCHAR szFileDescription[] = L"FileDescription";
    static const WCHAR szCopyright[] = L"LegalCopyright";
    static const WCHAR szTrademark[] = L"LegalTrademarks";
    static const WCHAR szProdName[] = L"ProductName";
    static const WCHAR szFileVerResName[] = L"FileVersion";
    static const WCHAR szProdVerResName[] = L"ProductVersion";
    static const WCHAR szInternalNameResName[] = L"InternalName";
    static const WCHAR szOriginalNameResName[] = L"OriginalFilename";
    
    // If there's no product version, use the file version
    if (m_Values[v_ProductVersion][0] == 0) {
        m_Values[v_ProductVersion] = m_Values[v_FileVersion];
        bUseFileVer = true;
    }

    // Keep the two following arrays in the same order
#define MAX_KEY     10
    static const LPCWSTR szKeys [MAX_KEY] = {
        szComments,
        szCompanyName,
        szFileDescription,
        szFileVerResName,
        szInternalNameResName,
        szCopyright,
        szTrademark,
        szOriginalNameResName,
        szProdName,
        szProdVerResName,
    };
    LPCWSTR szValues [MAX_KEY] = {  // values for keys
        m_Values[v_Description],	//compiler->assemblyDescription == NULL ? L"" : compiler->assemblyDescription,
        m_Values[v_Company],        // Company Name
        m_Values[v_Title],          // FileDescription  //compiler->assemblyTitle == NULL ? L"" : compiler->assemblyTitle,
        m_Values[v_FileVersion],   	// FileVersion
        rcFile,                   	// InternalName
        m_Values[v_Copyright],      // Copyright
        m_Values[v_Trademark],      // Trademark
        rcFileName,           	    // OriginalName
        m_Values[v_Product],        // Product Name     //compiler->assemblyTitle == NULL ? L"" : compiler->assemblyTitle,
        m_Values[v_ProductVersion]	// Product Version
    };

    memcpy(&VerResource, &VerResourceTemplate, sizeof(VerResource));

    if (m_fDll)
        VerResource.vsFixed.dwFileType = VFT_DLL;
    else
        VerResource.vsFixed.dwFileType = VFT_APP;

	// Extract the numeric version from the string.
	m_Version[0] = m_Version[1] = m_Version[2] = m_Version[3] = 0;
	swscanf(m_Values[v_FileVersion], L"%hu.%hu.%hu.%hu", m_Version, m_Version + 1, m_Version + 2, m_Version + 3);

    // Fill in the FIXEDFILEINFO
    VerResource.vsFixed.dwFileVersionMS =
        ((DWORD)m_Version[0] << 16) + m_Version[1];

    VerResource.vsFixed.dwFileVersionLS =
        ((DWORD)m_Version[2] << 16) + m_Version[3];

    if (bUseFileVer) {
        VerResource.vsFixed.dwProductVersionLS = VerResource.vsFixed.dwFileVersionLS;
        VerResource.vsFixed.dwProductVersionMS = VerResource.vsFixed.dwFileVersionMS;
    } else {
        WORD v[4];
        v[0] = v[1] = v[2] = v[3] = 0;
        // Try to get the version numbers, but don't waste time or give any errors
        // just default to zeros
        swscanf(m_Values[v_ProductVersion], L"%hu.%hu.%hu.%hu", v, v + 1, v + 2, v + 3);

        VerResource.vsFixed.dwProductVersionMS =
            ((DWORD)v[0] << 16) + v[1];

        VerResource.vsFixed.dwProductVersionLS =
            ((DWORD)v[2] << 16) + v[3];
    }

    // There is no documentation on what units to use for the date!  So we use zero.
    // The Windows resource compiler does too.
    VerResource.vsFixed.dwFileDateMS = VerResource.vsFixed.dwFileDateLS = 0;

    // Fill in codepage/language -- we'll assume the IDE language/codepage
    // is the right one.
    if (m_lcid != -1)
        VerResource.langid = m_lcid;
    else 
        VerResource.langid = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL); 
    VerResource.codepage = CP_WINUNICODE;   // Unicode codepage.

    swprintf(szLangCp, L"%04x%04x", VerResource.langid, VerResource.codepage);
    wcscpy(VerResource.szLangCpKey, szLangCp);

    // Determine the size of all the string blocks.
    cbStringBlocks = 0;
    for (i = 0; i < MAX_KEY; i++) {
        cbTmp = SizeofVerString( szKeys[i], szValues[i]);
        if ((cbStringBlocks + cbTmp) > USHRT_MAX)
            COMPlusThrow(kArgumentException, L"Argument_VerStringTooLong");
        cbStringBlocks += (WORD) cbTmp;
    }

    if ((cbStringBlocks + VerResource.cbLangCpBlock) > USHRT_MAX)
        COMPlusThrow(kArgumentException, L"Argument_VerStringTooLong");
    VerResource.cbLangCpBlock += cbStringBlocks;

    if ((cbStringBlocks + VerResource.cbStringBlock) > USHRT_MAX)
        COMPlusThrow(kArgumentException, L"Argument_VerStringTooLong");
    VerResource.cbStringBlock += cbStringBlocks;

    if ((cbStringBlocks + VerResource.cbRootBlock) > USHRT_MAX)
        COMPlusThrow(kArgumentException, L"Argument_VerStringTooLong");
    VerResource.cbRootBlock += cbStringBlocks;

    // Call this VS_VERSION_INFO
    RESOURCEHEADER verHeader = { 0x00000000, 0x0000003C, 0xFFFF, (WORD)RT_VERSION, 0xFFFF, 0x0001,
                                 0x00000000, 0x0030, 0x0000, 0x00000000, 0x00000000 };
    verHeader.DataSize = VerResource.cbRootBlock;

    // Write the header
    if (FAILED(hr = Write( &verHeader, sizeof(RESOURCEHEADER))))
        return hr;

    // Write the version resource
    if (FAILED(hr = Write( &VerResource, sizeof(VerResource))))
        return hr;

    // Write each string block.
    for (i = 0; i < MAX_KEY; i++) {
        if (FAILED(hr = WriteVerString( szKeys[i], szValues[i])))
            return hr;
    }
#undef MAX_KEY

    return S_OK;
}

/*
 * SizeofVerString
 *    Determines the size of a version string to the given stream.
 * RETURNS: size of block in bytes.
 */
WORD Win32Res::SizeofVerString(LPCWSTR lpszKey, LPCWSTR lpszValue)
{
    THROWSCOMPLUSEXCEPTION();

    size_t cbKey, cbValue;

    cbKey = (wcslen(lpszKey) + 1) * 2;  // Make room for the NULL
    cbValue = (wcslen(lpszValue) + 1) * 2;
    if (cbValue == 2)
        cbValue = 4;   // Empty strings need a space and NULL terminator (for Win9x)
    if (cbKey + cbValue >= 0xFFF0)
        COMPlusThrow(kArgumentException, L"Argument_VerStringTooLong");
    return (WORD)(PadKeyLen(cbKey) +   // key, 0 padded to DWORD boundary
                  PadValLen(cbValue) + // value, 0 padded to dword boundary
                  HDRSIZE);             // block header.
}

/*----------------------------------------------------------------------------
 * WriteVerString
 *    Writes a version string to the given file.
 */
HRESULT Win32Res::WriteVerString( LPCWSTR lpszKey, LPCWSTR lpszValue)
{
    size_t cbKey, cbValue, cbBlock;
    bool bNeedsSpace = false;
    BYTE * pbBlock;
    HRESULT hr;

    cbKey = (wcslen(lpszKey) + 1) * 2;     // includes terminating NUL
    cbValue = wcslen(lpszValue);
    if (cbValue > 0)
        cbValue++; // make room for NULL
    else {
        bNeedsSpace = true;
        cbValue = 2; // Make room for space and NULL (for Win9x)
    }
    cbBlock = SizeofVerString(lpszKey, lpszValue);
    if ((pbBlock = new (nothrow) BYTE[(DWORD)cbBlock + HDRSIZE]) == NULL)
        return E_OUTOFMEMORY;
    ZeroMemory(pbBlock, (DWORD)cbBlock + HDRSIZE);

    _ASSERTE(cbValue < USHRT_MAX && cbKey < USHRT_MAX && cbBlock < USHRT_MAX);

    // Copy header, key and value to block.
    *(WORD *)pbBlock = (WORD)cbBlock;
    *(WORD *)(pbBlock + sizeof(WORD)) = (WORD)cbValue;
    *(WORD *)(pbBlock + 2 * sizeof(WORD)) = 1;   // 1 = text value
    wcscpy((WCHAR*)(pbBlock + HDRSIZE), lpszKey);
    if (bNeedsSpace)
        *((WCHAR*)(pbBlock + (HDRSIZE + PadKeyLen(cbKey)))) = L' ';
    else
        wcscpy((WCHAR*)(pbBlock + (HDRSIZE + PadKeyLen(cbKey))), lpszValue);

    // Write block
    hr = Write( pbBlock, cbBlock);

    // Cleanup and return
    delete [] pbBlock;
    return hr;
}

HRESULT Win32Res::Write(void *pData, size_t len)
{
    if (m_pCur + len > m_pEnd) {
        // Grow
        size_t newSize = (m_pEnd - m_pData);

        // double the size unless we need more than that
        if (len > newSize)
            newSize += len;
        else
            newSize *= 2;

        LPBYTE pNew = new (nothrow) BYTE[newSize];
        if (pNew == NULL)
            return E_OUTOFMEMORY;
        memcpy(pNew, m_pData, m_pCur - m_pData);
        delete [] m_pData;
        // Relocate the pointers
        m_pCur = pNew + (m_pCur - m_pData);
        m_pData = pNew;
        m_pEnd = pNew + newSize;
    }

    // Copy it in
    memcpy(m_pCur, pData, len);
    m_pCur += len;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assembly.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  Assembly.hpp
**
** Purpose: Implements assembly (loader domain) architecture
**
** Date:  Oct 26, 1998
**
===========================================================*/
#ifndef _ASSEMBLY_H
#define _ASSEMBLY_H

#include "clsload.hpp"
#include "fusion.h"
#include "eehash.h"
#include "ListLock.h"
#include <wincrypt.h>
#include "ICeeFileGen.h"
#include "FusionBind.h"
#include "CordbPriv.h"
#include "AssemblySpec.hpp"
#include <member-offset-info.h>


#ifdef _DEBUG
#define                                                                                         \
CHECKGC()                                                                                       \
{                                                                                               \
    Thread* __tdTemp = GetThread();                                                             \
    ASSERT(__tdTemp != NULL && "The EE does not know about the current thread");                \
    ASSERT(__tdTemp->PreemptiveGCDisabled() == TRUE && "GC must be disabled for this routine"); \
}
#else
#define CHECKGC()
#endif


class BaseDomain;
class AppDomain;
class SystemDomain;
class ClassLoader;
class ComDynamicWrite;
class AssemblySink;
class AssemblyNative;
class AssemblySpec;
class COMHash;
class SharedSecurityDescriptor;
class NLogAssembly;


// Bits in m_dwDynamicAssemblyAccess (see System.Reflection.Emit.AssemblyBuilderAccess.cs)
#define ASSEMBLY_ACCESS_RUN     0x01
#define ASSEMBLY_ACCESS_SAVE    0x02

struct AssemblyBinding
{
    IMDInternalImport  *pImport;
    mdToken             assemblyRef;
    Assembly           *pAssembly;
};

struct PEFileBinding
{
    IMDInternalImport   *pImport;
    mdToken             assemblyRef;
    PEFile              *pPEFile;
};

struct PEFileSharingProperties
{
    PEFileBinding       *pDependencies;
    DWORD                cDependencies;
    DWORD                shareCount;
};


//--------------------------------------------------------------------------------------
//     Layout
//     ------
//          Domain
//            |
//            |
//            -------------------- ......
//                |          |
//            Assembly    Assembly
//                 |
//              Classoader
//                 |
//                 ---------------........
//                    |       |
//                 Module   Module
//
// Notes:
// ------
// Assemblies manage a manifest and contain a single class loader. References will be resolved
// as follows (this is not currently implemented since manifests are not yet enabled)
// 1) Internal references within modules should be defined as typedefs and will not be impacted
//    by the assembly unless they are marked as a 'Setting' and require configuration information.
// 2) When an external reference is required it will be found in the manifest. There is a hash
//    table for the manifest that originally contains all the logical names found in the manifest
//    and a token to find meta data for the name. When the reference is resolved the EEClass 
//    reference replaces the token. 
// 3) The token will be to a resource ref. The resource ref will have a token for a module reference
//    or an assembly reference. 
// 3a) For module references the module will be loaded into the assembly (if has not already been
//     added) and the EEClass will be obtained from there.
// 3b) For the assembly references a quick check is done to determine if the assembly is already 
//     loaded and if not the fusion name will be passed to fusion to point us to a loadable assembly.
//     Once loaded the EEClass can be obtained from the assembly.
//
// Currently, manifests are not supported so the look up routine for unfound classes searches through
// all the assemblies in the domain. This is very temporary.
//
//
// Dynamic Modules.
// ---------------
// There is one dynamic module per assembly (this may be loosened later). The assembly does not
// affect the object reference returned for a dynamically created class. It will affect the 
// visibility if the class is named and a GetClass("foo") call is used to generate a new instance
// of the class. There is an TODO to allow the developer to dynamically push an entry to the manifest
// to allow GetClass() calls to succeed.
//
// A side note. All dynamic classes will acquire the security of the assembly.
//

class Assembly
{
    friend BaseDomain;
    friend SystemDomain;
    friend ClassLoader;
    friend AssemblyNative;
    friend AssemblySpec;
    friend COMHash;
    friend PEFile;
    friend NDirect;
    friend class AssemblyNameNative;
    friend struct MEMBER_OFFSET_INFO(Assembly);
public:

    //****************************************************************************************
    //
    // Intialization/shutdown routines for every instance of an assembly
    HRESULT Init(BOOL isDynamic);
    void Terminate( BOOL signalProfiler = TRUE );
    void ReleaseFusionInterfaces();
    HRESULT SetFusionAssembly(IAssembly *pFusionAssembly);

    BOOL IsSystem() { return m_pManifestFile != NULL && m_pManifestFile->IsSystem(); }

    //****************************************************************************************
    //
    // Add a module to the assembly.
    HRESULT AddModule(Module* module, mdFile kFile, 
                      BOOL fNeedSecurity,
                      OBJECTREF *pThrowable = NULL);

    //****************************************************************************************
    //
    // Returns the class loader associated with the assembly.
    ClassLoader* GetLoader()
    {
        return m_pClassLoader;
    }

    //****************************************************************************************
    //
    // Find a class in the loader. If the class is not known to the loader it will make a 
    // call to the assembly to locate the class. @TODO: CTS, move the hash table out of the
    // loader and into the assembly. The hash table should only contain exported classes
    TypeHandle LookupTypeHandle(NameHandle* pName,
                                OBJECTREF* pThrowable = NULL);

    TypeHandle LookupTypeHandle(LPCUTF8 pszClassName,
                                OBJECTREF* pThrowable = NULL)
    {
        NameHandle typeName(pszClassName);
        return LookupTypeHandle(&typeName, pThrowable);
    }


    TypeHandle GetInternalType(NameHandle* typeName, BOOL bThrowOnError, OBJECTREF *pThrowable);

    static LPCSTR FindNestedSeparator(LPCSTR szClassName);
    TypeHandle FindNestedTypeHandle(NameHandle* typeName,
                                    OBJECTREF *pThrowable);

    //****************************************************************************************
    //
    // Find the module identified by the base address
    Module* FindModule(BYTE *baseAddress);
    Module* FindAssembly(BYTE *baseAddress);   // just checks the image containing the manifest

    //****************************************************************************************
    //
    // Get the domain the assembly lives in.
    BaseDomain* Parent()
    {
        return m_pDomain;
    }
    
    // Sets the assemblies domain.
    HRESULT SetParent(BaseDomain* pParent);
    
    // Returns the parent domain if it is not the system area. Returns NULL if it is the 
    // system domain
    BaseDomain* GetDomain();

    //****************************************************************************************
    //
    HRESULT AddManifest(PEFile* pFile, 
                        IAssembly* pIAssembly,
                        BOOL fProfile = TRUE);
    HRESULT AddManifestMetadata(PEFile* pFile);
    HRESULT FindInternalModule(mdFile     kFile,
                               mdToken    mdTokenNotToLoad,
                               Module**   ppModule,
                               OBJECTREF* pThrowable);
    HRESULT LoadInternalModule(mdFile               kFile,
                               IMDInternalImport*   pAssemblyImport,
                               Module**             ppModule,
                               OBJECTREF*           pThrowable);

    HRESULT LoadInternalModule(LPCUTF8      pName,
                               mdFile       kFile,
                               DWORD        dwHashAlgorithm,
                               const BYTE*  pbHash,
                               DWORD        cbHash,
                               DWORD        flags,
                               WCHAR*       pPath,
                               DWORD        dwPath,
                               Module**     ppModule,
                               OBJECTREF*   pThrowable);

    HRESULT LoadFoundInternalModule(PEFile    *pFile,
                                    mdFile    kFile,
                                    BOOL      fResource,
                                    Module    **ppModule,
                                    OBJECTREF *pThrowable);

    HRESULT FindExternalAssembly(Module*            pTokenModule,
                                 mdAssemblyRef      kAssemblyRef,
                                 IMDInternalImport* pImport,
                                 mdToken            mdTokenNotToLoad,
                                 Assembly**         ppAssembly,
                                 OBJECTREF*         pThrowable);

    HRESULT LoadExternalAssembly(mdAssemblyRef      kAssemblyRef,
                                 IMDInternalImport* pImport,
                                 Assembly*          pAssembly,
                                 Assembly**         ppAssembly,
                                 OBJECTREF*         pThrowable);
    
    HRESULT VerifyInternalModuleHash(WCHAR*      pPath,
                                     DWORD       dwHashAlgorithm,
                                     const BYTE* pbHash,
                                     DWORD       cbHash,
                                     OBJECTREF*  pThrowable);
    static HRESULT VerifyHash(PBYTE       pbBuffer,
                              DWORD       dwBufferLen,
                              ALG_ID      iHashAlg,
                              const BYTE* pbHashValue, 
                              DWORD       cbHashValue);
    static HRESULT GetHash(WCHAR* strFullFileName,
                           ALG_ID iHashAlg,
                           BYTE** pbCurrentValue,  // should be NULL
                           DWORD *cbCurrentValue);

    static HRESULT ReadFileIntoMemory(LPCWSTR   strFullFileName,
                                      BYTE**    ppbBuffer,
                                      DWORD*    pdwBufLen);

    static HRESULT GetHash(PBYTE pbBuffer,
                           DWORD dwBufferLen,
                           ALG_ID iHashAlg,
                           BYTE** pbCurrentValue,  // should be NULL
                           DWORD *cbCurrentValue);

    BOOL IsAssembly();

    BOOL AllowUntrustedCaller();
    void CheckAllowUntrustedCaller();

    BOOL IsStrongNamed()
    {
        return m_cbPublicKey;
    }
    void GetPublicKey(const BYTE **ppPK, DWORD *pcbPK)
    {
        *ppPK = m_pbPublicKey;
        *pcbPK = m_cbPublicKey;
    }

    // Level of strong name support (dynamic assemblies only).
    enum StrongNameLevel {
        SN_NONE = 0,
        SN_PUBLIC_KEY = 1,
        SN_FULL_KEYPAIR_IN_ARRAY = 2,
        SN_FULL_KEYPAIR_IN_CONTAINER = 3
    };

    StrongNameLevel GetStrongNameLevel()
    {
        return m_eStrongNameLevel;
    }

    void SetStrongNameLevel(StrongNameLevel eLevel)
    {
        m_eStrongNameLevel = eLevel;
    }

    LoaderHeap* GetLowFrequencyHeap();
    LoaderHeap* GetHighFrequencyHeap();
    LoaderHeap* GetStubHeap();

    Module* GetSecurityModule() // obsolete
    {
        return m_pManifest;
    }

    Module* GetManifestModule()
    {
        return m_pManifest;
    }

    ReflectionModule* GetOnDiskManifestModule()
    {
        return m_pOnDiskManifest;
    }

    PEFile* GetManifestFile()
    {
        return m_pManifestFile;
    }

    IMDInternalImport* GetManifestImport()
    {
        return m_pManifestImport;
    }

    IMetaDataAssemblyImport* GetManifestAssemblyImport();

    mdAssembly GetManifestToken()
    {
        return m_kManifest;
    }

    // Return the friendly name of the assembly.  In legacy mode, the friendly
    // name is the filename of the module containing the manifest.
    HRESULT GetName(LPCUTF8 *pszName);
    // Note that this version may return NULL in legacy mode.
    LPCUTF8 GetName() { return m_psName; }

    // Returns the long form of the name including, the version, public key, etc.
    HRESULT GetFullName(LPCWSTR *pwszFullName);
    static HRESULT SetFusionAssemblyName(LPCWSTR pSimpleName,
                                         DWORD dwFlags,
                                         AssemblyMetaDataInternal *pContext,
                                         PBYTE  pbPublicKey,
                                         DWORD  cbPublicKey,
                                         IAssemblyName **ppFusionAssemblyName);

    // Initialize an AssemblySpec from an Assembly.
    HRESULT GetAssemblySpec(AssemblySpec *pSpec);
    
    //****************************************************************************************
    //
    // Return and set the dynamic module. Currently, only one dynamic module can be set.
    CorModule* GetDynamicModule()
    {
        return m_pDynamicCode;
    }

    //****************************************************************************************
    //
    // Verification routines should not be used at runtime. They are to be used to statically
    // for static analysis of assemblies by verification tools.
    static HRESULT VerifyModule(Module* pModule);
    HRESULT VerifyAssembly();
    
    //****************************************************************************************
    //
    // Uses the given token to load a module or another assembly. Returns the module in
    // which the implementation resides.
    HRESULT FindModuleByExportedType(mdExportedType mdType,
                                mdToken tokenNotToLoad,
                                mdTypeDef mdNested,
                                Module** ppModule,
                                mdTypeDef *pCL,
                                OBJECTREF *pThrowable=NULL);
    HRESULT FindAssemblyByTypeRef(NameHandle* pName, 
                                  Assembly** ppAssembly,
                                  OBJECTREF *pThrowable);
    HRESULT FindModuleByModuleRef(IMDInternalImport *pImport,
                                  mdModuleRef tkMR,
                                  mdToken tokenNotToLoad,
                                  Module** ppModule,
                                  OBJECTREF *pThrowable);

    //****************************************************************************************
    //
    TypeHandle LoadTypeHandle(NameHandle* pName, OBJECTREF *pThrowable=NULL,
                              BOOL dontLoadInMemoryType=TRUE);

    //****************************************************************************************
    //
    HRESULT ExecuteMainMethod(PTRARRAYREF *stringArgs = NULL);
    // Returns the entrypoint module.
    HRESULT GetEntryPoint(Module **ppModule);

    //****************************************************************************************

    static DWORD GetZapString(CORCOMPILE_VERSION_INFO *pZapVersionInfo, 
                              LPWSTR buffer);
    void GetCurrentZapString(LPWSTR buffer, BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile);
    void GetCurrentVersionInfo(CORCOMPILE_VERSION_INFO *pZapVersionInfo, 
                               BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile);
    HRESULT LoadZapAssembly();
    HRESULT LocateZapAssemblyInFusion(IAssembly **ppZapAssembly, 
                                      BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile);
    HRESULT DeleteZapAssemblyInFusion(IAssemblyName *pZapAssembly);
    BOOL CheckZapVersion(PEFile *pZapManifest);
    BOOL CheckZapConfiguration(PEFile *pZapManifest, 
                               BOOL fForceDebug, BOOL fForceDebugOpt, BOOL fForceProfile);
    BOOL CheckZapSecurity(PEFile *pZapManifest);
    PEFile *GetZapFile(PEFile *pFile);

    NLogAssembly *CreateAssemblyLog();

    Assembly();
    ~Assembly();

    HRESULT GetResource(LPCSTR szName, HANDLE *hFile, DWORD *cbResource,
                        PBYTE *pbInMemoryResource, Assembly **pAssemblyRef,
                        LPCSTR *szFileName, DWORD *dwLocation, 
                        StackCrawlMark *pStackMark = NULL, BOOL fSkipSecurityCheck = FALSE,
                        BOOL fSkipRaiseResolveEvent = FALSE);

    //****************************************************************************************
#ifdef DEBUGGING_SUPPORTED
    BOOL NotifyDebuggerAttach(AppDomain *pDomain, int flags, BOOL attaching);
    void NotifyDebuggerDetach(AppDomain *pDomain = NULL);
#endif // DEBUGGING_SUPPORTED

    void AllocateExposedObjectHandle(AppDomain *pDomain);
    OBJECTREF GetRawExposedObject(AppDomain *pDomain = NULL);
    OBJECTREF GetExposedObject(AppDomain *pDomain = NULL);

    //****************************************************************************************
    // If the module contains a manifest then it will return S_OK
    static HRESULT CheckFileForAssembly(PEFile* pFile);
    
    FORCEINLINE BOOL IsDynamic() { return m_isDynamic; }
    FORCEINLINE BOOL HasRunAccess() { return m_dwDynamicAssemblyAccess & ASSEMBLY_ACCESS_RUN; }

    void AddType(Module* pModule,
                 mdTypeDef cl);

    void PrepareSavingManifest(ReflectionModule *pAssemblyModule);
    mdFile AddFileList(LPWSTR wszFileName);
    void SetHashValue(mdFile tkFile, LPWSTR wszFullFileName);
    mdAssemblyRef AddAssemblyRef(Assembly *refedAssembly, IMetaDataAssemblyEmit *pAssemEmitter = NULL);
    mdExportedType AddExportedType(LPWSTR wszExportedType, mdToken tkImpl, mdToken tkTypeDef, CorTypeAttr flags);    
    void AddStandAloneResource(LPWSTR wszName, LPWSTR wszDescription, LPWSTR wszMimeType, LPWSTR wszFileName , LPWSTR wszFullFileName, int iAttribute);    
    void SaveManifestToDisk(LPWSTR wszFileName, int entrypoint, int fileKind);
    void AddFileToInMemoryFileList(LPWSTR wszFileName, Module *pModule);
    void SavePermissionRequests(U1ARRAYREF orRequired, U1ARRAYREF orOptional, U1ARRAYREF orRefused);
    IMetaDataAssemblyEmit *GetOnDiskMDAssemblyEmitter();

    HRESULT DefineAssemblyRef(IMetaDataAssemblyEmit* pAsmEmit, //[IN] for referencing assembly
                              IMetaDataEmit* pAsmRefEmit,      //[IN] for this assembly (referenced assembly) - We should already be done emitting metadata for this assembly
                              mdAssemblyRef* mdAssemblyRef);   //[OUT] return assemblyref emitted in referencing assembly

    HRESULT DefineAssemblyRef(IMetaDataAssemblyEmit* pAsmEmit, //[IN] for referencing assembly
                              PBYTE pbMetaData,                //[IN] blob of the referenced assembly's metadata
                              DWORD cbMetaData,                //[IN] size of metadata blob
                              mdAssemblyRef* mdAssemblyRef);   //[OUT] return assemblyref emitted in referencing assembly
    
    //****************************************************************************************
    // Get the assemblies code base. If one was not explicitly set then one will be built from
    // the file name of the assembly. DONOT delete the returned values.
    // 
    HRESULT GetCodeBase(LPWSTR *pwCodeBase, DWORD* pdwCodeBase);

    HRESULT FindCodeBase(WCHAR* pCodeBase, DWORD* pdwCodeBase, BOOL fCopiedName);

    //****************************************************************************************

    AssemblySecurityDescriptor *GetSecurityDescriptor(AppDomain *pDomain = NULL);
    SharedSecurityDescriptor *GetSharedSecurityDescriptor() { return m_pSharedSecurityDesc; }

    HRESULT ComputeBindingDependenciesClosure(PEFileBinding **ppDeps,
                                              DWORD *pcDeps,
                                              BOOL ignoreFailures);
    // pDependencies should be allocated with new []
    HRESULT SetSharingProperties(PEFileBinding *pDependencies, DWORD cDependencies);
    HRESULT GetSharingProperties(PEFileBinding **pDependencies, DWORD *pcDependencies);
    HRESULT CanShare(AppDomain *pAppDomain, OBJECTREF *pThrowable = NULL, BOOL supressLoads = FALSE);
    void SetShared() { m_fIsShared = TRUE; }
    BOOL IsShared() { return m_fIsShared; }
    void IncrementShareCount();
    void DecrementShareCount();

    // Can this shared assembly be loaded into a specific domain
    HRESULT CanLoadInDomain(AppDomain *pDomain);

    HRESULT AllocateStrongNameSignature(ICeeFileGen  *pCeeFileGen,
                                        HCEEFILE      ceeFile);
    HRESULT SignWithStrongName(LPWSTR wszFileName);
    void CleanupStrongNameSignature();

    // Returns security information for the assembly based on the codebase
    HRESULT GetSecurityIdentity(LPWSTR *ppCodebase, DWORD *pdwZone, BYTE *pbUniqueID, DWORD *pcbUniqueID);

    // This allows someone to get a Module* given a file name of a module they
    // believe to be a part of the assembly.  If there is no match, E_FAIL is
    // returned.  If an exception is thrown, it is converted to an HRESULT and
    // returned.  If everything goes well, S_OK is returned.
    HRESULT GetModuleFromFilename(LPCWSTR wszModuleFilename,
                                  Module **ppModule);

    //
    // Get/set the DebuggerAssemblyControlFlags.
    //
    DebuggerAssemblyControlFlags GetDebuggerInfoBits(void)
    {
        return m_debuggerFlags;
    }

    void SetDebuggerInfoBits(DebuggerAssemblyControlFlags newBits)
    {
        m_debuggerFlags = newBits;
    }

    IAssembly* GetFusionAssembly()
    {
        return m_pFusionAssembly;
    }

    IAssemblyName* GetFusionAssemblyName()
    {
        return m_pFusionAssemblyName;
    }

    void SetupDebuggingConfig(void);
    DWORD ComputeDebuggingConfig(void);
    bool GetDebuggingOverrides(bool *pfTrackJITInfo, 
                               bool *pfAllowJITOpts,
                               bool *pfUserOverride,
                               bool *pfEnC);
    bool GetDebuggingCustomAttributes(bool *pfTrackJITInfo, 
                                      bool *pfAllowJITOpts,
                                      bool *pfEnC);

    AssemblyMetaDataInternal *m_Context;

    // Get any cached ITypeLib* for the assembly. 
    ITypeLib *GetTypeLib(); 
    // Cache the ITypeLib*, if one is not already cached.   
    void SetTypeLib(ITypeLib *pITLB);   

    //****************************************************************************************
    // Get the class init lock. The method is limited to friends because inappropriate use
    // will cause deadlocks in the system
    ListLock* GetClassInitLock();
    ListLock* GetJitLock();
    
    void PostTypeLoadException(LPCUTF8 pFullName, UINT resIDWhy,
                               OBJECTREF *pThrowable)
    {
        PostTypeLoadException(NULL, pFullName, NULL,
                              resIDWhy, pThrowable);
    }

    void PostTypeLoadException(LPCUTF8 pNameSpace, LPCUTF8 pTypeName,
                               UINT resIDWhy, OBJECTREF *pThrowable)
    {
        PostTypeLoadException(pNameSpace, pTypeName, NULL,
                              resIDWhy, pThrowable);
        
    }

    void PostTypeLoadException(NameHandle *pName, UINT resIDWhy, OBJECTREF *pThrowable)
    {
        LPCUTF8 pNameSpace; 
        LPCUTF8 pTypeName;
        char fullName[MAX_CLASSNAME_LENGTH + 1];

        if (pName->IsConstructed()) {
            pName->GetFullName(fullName, MAX_CLASSNAME_LENGTH);
            pNameSpace = 0;
            pTypeName = fullName;
        }
        else if (pName->GetName()) {
            pNameSpace = pName->GetNameSpace();
            pTypeName = pName->GetName();
        }
        else
            return PostTypeLoadException(pName->GetTypeModule()->GetMDImport(),
                                         pName->GetTypeToken(),
                                         resIDWhy,
                                         pThrowable);

        PostTypeLoadException(pNameSpace, pTypeName, NULL, resIDWhy, pThrowable);
    }

    void PostTypeLoadException(IMDInternalImport *pInternalImport, 
                               mdToken token,
                               UINT resIDWhy, 
                               OBJECTREF *pThrowable)
    {
        LPCUTF8     szClassName = "<unknown>";
        LPCUTF8     szNameSpace = NULL;

        switch (TypeFromToken(token)) {
        case mdtTypeRef:
            pInternalImport->GetNameOfTypeRef(token, &szNameSpace, &szClassName);
            break;
        case mdtTypeDef:
            pInternalImport->GetNameOfTypeDef(token, &szClassName, &szNameSpace);
        // Leave default as "<unknown>"
        }

        PostTypeLoadException(szNameSpace, szClassName, NULL,
                              resIDWhy, pThrowable);
    }

    void PostTypeLoadException(IMDInternalImport *pInternalImport, 
                               mdToken token,
                               LPCUTF8 fieldOrMethodName,
                               UINT resIDWhy, 
                               OBJECTREF *pThrowable)
    {
        LPCUTF8     szClassName = "<unknown>";
        LPCUTF8     szNameSpace = NULL;

        switch (TypeFromToken(token)) {
        case mdtTypeRef:
            pInternalImport->GetNameOfTypeRef(token, &szNameSpace, &szClassName);
            break;
        case mdtTypeDef:
            pInternalImport->GetNameOfTypeDef(token, &szClassName, &szNameSpace);
        // Leave default as "<unknown>"
        }

        LPCWSTR wszFullName = NULL;
        GetFullName(&wszFullName); // ignore return hr

        ::PostTypeLoadException(szNameSpace, szClassName, wszFullName,
                              fieldOrMethodName, resIDWhy, pThrowable);
    }

    void PostTypeLoadException(LPCUTF8 pNameSpace, LPCUTF8 pTypeName, LPCUTF8 pMethodName,
                               UINT resIDWhy, OBJECTREF *pThrowable)
    {
        LPCWSTR wszFullName = NULL;
        GetFullName(&wszFullName); // ignore return hr
        
        ::PostTypeLoadException(pNameSpace, pTypeName, wszFullName,
                                pMethodName, resIDWhy, pThrowable);
    }

    //****************************************************************************************
    //
    static BOOL ModuleFound(HRESULT hr);

protected:

    enum {
        FREE_NAME = 1,
        FREE_PUBLIC_KEY = 2,
        FREE_KEY_PAIR = 4,
        FREE_KEY_CONTAINER = 8,
        FREE_LOCALE = 16,
        FREE_PEFILE = 32,
    };

    // Keep track of the vars that need to be freed.
    short int m_FreeFlag;
    ULONG m_ulHashAlgId;    // Hash algorithm used in the Assembly
    PBYTE m_pbHashValue;    // The hash value of the file that contains the manifest.
    // NOTE: This hash value must have been computed using the alg specified
    //by m_ulHashAlgId, not by one specified by another assembly's AssemblyRef
    ULONG m_cbHashValue;    // Length, in bytes, of m_pbHashValue

    LPWSTR m_pwCodeBase;     // Cached code base for the assembly
 
    // Hash of files in manifest by name to File token
    EEUtf8StringHashTable *m_pAllowedFiles;
   
    union
    {
        OBJECTHANDLE    m_ExposedObject;        // non-shared
        SIZE_T          m_ExposedObjectIndex;   // shared
    };   

private:

    //****************************************************************************************
    HRESULT GetFileFromFusion(LPWSTR      pwFileName,
                              WCHAR*      szPath,
                              DWORD       dwPath);

    
    HRESULT CopyCodeBase(LPCWSTR pCodeBase);

    HRESULT FindAssemblyCodeBase(WCHAR* pCodeBase, DWORD* dwCodeBase, BOOL fCopiedName);

    // Pulls in URLMON's security manager. It is used to translate a codebase
    // into a zone and site
    HRESULT InitializeSecurityManager();

    // Used to initialize static method descriptors to the managed Assembly Class
    HRESULT InitializeAssemblyMethod(MethodDesc** pMethod, LPCUTF8 pName, LPHARDCODEDMETASIG sig);

    HRESULT CacheManifestExportedTypes();
    HRESULT CacheManifestFiles();

    Module* RaiseModuleResolveEvent(LPCSTR szName, OBJECTREF *pThrowable);

    HRESULT GetResourceFromFile(mdFile mdFile, LPCSTR szResName, HANDLE *hFile,
                                DWORD *cbResource, PBYTE *pbInMemoryResource,
                                LPCSTR *szFileName, DWORD *dwLocation,
                                BOOL fIsPublic, StackCrawlMark *pStackMark, 
                                BOOL fSkipSecurityCheck);
    static HRESULT GetEmbeddedResource(Module *pModule, DWORD dwOffset, HANDLE *hFile,
                                       DWORD *cbResource, PBYTE *pbInMemoryResource);

    BaseDomain*           m_pDomain;        // Parent Domain

    ClassLoader*          m_pClassLoader;   // Single Loader
    CorModule*            m_pDynamicCode;   // Dynamic writer

    mdFile                m_tEntryModule;    // File token indicating the file that has the entry point
    Module*               m_pEntryPoint;     // Module containing the entry point in the COM plus HEasder

    Module*               m_pManifest;
    PEFile*               m_pManifestFile;
    mdAssembly            m_kManifest;
    IMDInternalImport*    m_pManifestImport;
    IMetaDataAssemblyImport*      m_pManifestAssemblyImport;
    ReflectionModule*     m_pOnDiskManifest;  // This is the module containing the on disk manifest.
    mdAssembly            m_tkOnDiskManifest;
    BOOL                  m_fEmbeddedManifest;  

    IAssembly*            m_pFusionAssembly;     // Assembly object to assembly in fusion cache
    IAssemblyName*        m_pFusionAssemblyName; // name of assembly in cache

    DWORD                 m_dwCodeBase;     //  size of code base 
    LPWSTR                m_pwsFullName;    // Long version of the name (on the heap do not delete)

    DWORD                 m_dwFlags;

    // Set the appropriate m_FreeFlag bit if you malloc these.
    LPCUTF8               m_psName;          // Name of assembly

    PBYTE                 m_pbPublicKey;
    DWORD                 m_cbPublicKey;
    PBYTE                 m_pbStrongNameKeyPair;
    DWORD                 m_cbStrongNameKeyPair;
    LPWSTR                m_pwStrongNameKeyContainer;

    StrongNameLevel       m_eStrongNameLevel;

    BOOL                  m_isDynamic;
    DWORD                 m_dwDynamicAssemblyAccess;
        
    IAssembly*            m_pZapAssembly;        // Fusion assembly containing zaps
    LPCWSTR               m_pZapPath;            // Alternative non-fusion location for zaps

    // If a TypeLib is ever required for this module, cache the pointer here.
    ITypeLib              *m_pITypeLib;
    
    IInternetSecurityManager    *m_pSecurityManager;

    SharedSecurityDescriptor* m_pSharedSecurityDesc;    // Security descriptor (permission requests, signature etc)

    BOOL                        m_fIsShared;
    PEFileSharingProperties    *m_pSharingProperties;

    DebuggerAssemblyControlFlags m_debuggerFlags;

    // The following two fields are used in Reflection Emit. It caches the StrongNameTokenFromPublicKey's result value
    // for AssemblyRefs representing this Assembly.
    PBYTE                 m_pbRefedPublicKeyToken;
    DWORD                 m_cbRefedPublicKeyToken;

    BOOL                  m_fTerminated;
    BOOL                  m_fAllowUntrustedCaller;
    BOOL                  m_fCheckedForAllowUntrustedCaller;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblynative.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblyNative.cpp
**
** Purpose: Implements AssemblyNative (loader domain) architecture
**
** Date:  Dec 1, 1998
**
===========================================================*/

#include "common.h"

#include <shlwapi.h>
#include <stdlib.h>
#include "AssemblyNative.hpp"
#include "field.h"
#include "COMString.h"
#include "AssemblyName.hpp"
#include "EEConfig.h"
#include "Security.h"
#include "permset.h"
#include "COMReflectionCommon.h"
#include "COMClass.h"
#include "COMMember.h"
#include "StrongName.h"
#include "AssemblyNativeResource.h"
#include "InteropUtil.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


inline Assembly *AssemblyNative::ValidateThisRef(ASSEMBLYREF pThis)
{

    THROWSCOMPLUSEXCEPTION();
    if (pThis == NULL)
        COMPlusThrow(kNullReferenceException, L"NullReference_This");

    // Note: pThis->GetAssembly() may be NULL when Object.ToString() calls
    // Assembly.ToString()
    return pThis->GetAssembly();
}    

LPVOID __stdcall AssemblyNative::Load(LoadFullAssemblyArgs *args)
{
    CHECKGC();
    THROWSCOMPLUSEXCEPTION();

    if (args->assemblyName == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_AssemblyName");
    
    if( (args->assemblyName->GetSimpleName() == NULL) &&
        (args->codeBase == NULL ) )
        COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

    LPVOID rv = NULL;
    WCHAR* pCodeBase = NULL;
    DWORD  dwCodeBase = 0;
    Assembly *pAssembly = NULL;
    PBYTE  pStrongName = NULL;
    DWORD  dwStrongName = 0;
    PBYTE  pHashForControl=NULL;
    DWORD  dwHashForControl = 0;

    IAssembly *pRefIAssembly = NULL;
    DWORD dwFlags = 0;

    AssemblyMetaDataInternal sContext;
    LPSTR psSimpleName = NULL;
    HRESULT hr = S_OK;
    CQuickBytes qb;
    CQuickBytes qb2;
    CQuickBytes qb3;

    Thread *pThread = GetThread();
    void* checkPointMarker = pThread->m_MarshalAlloc.GetCheckpoint();

    if (!args->fIsStringized) {
        dwFlags = args->assemblyName->GetFlags();

        hr = AssemblyName::ConvertToAssemblyMetaData(&(pThread->m_MarshalAlloc), 
                                                     &args->assemblyName,
                                                     &sContext);
        if (FAILED(hr)) {
            pThread->m_MarshalAlloc.Collapse(checkPointMarker);
            COMPlusThrowHR(hr);
        }

        PBYTE  pArray = NULL;
        if (args->assemblyName->GetPublicKeyToken() != NULL) {
            dwFlags = !afPublicKey;
            pArray = args->assemblyName->GetPublicKeyToken()->GetDataPtr();
            dwStrongName = args->assemblyName->GetPublicKeyToken()->GetNumComponents();
            pStrongName = (PBYTE) pThread->m_MarshalAlloc.Alloc(dwStrongName);
            memcpy(pStrongName, pArray, dwStrongName);
        }
        else if (args->assemblyName->GetPublicKey() != NULL) {
            pArray = args->assemblyName->GetPublicKey()->GetDataPtr();
            dwStrongName = args->assemblyName->GetPublicKey()->GetNumComponents();
            pStrongName = (PBYTE) pThread->m_MarshalAlloc.Alloc(dwStrongName);
            memcpy(pStrongName, pArray, dwStrongName);
        }
    }

    if (args->codeBase != NULL) {
        WCHAR* pString;
        int    iString;
        RefInterpretGetStringValuesDangerousForGC(args->codeBase, &pString, &iString);
        dwCodeBase = (DWORD) iString;
        pCodeBase = (LPWSTR) qb2.Alloc((++dwCodeBase) * sizeof(WCHAR));
        memcpy(pCodeBase, pString, dwCodeBase*sizeof(WCHAR));
    }

    if (args->assemblyName->GetHashForControl() != NULL) {
        PBYTE  pArray = NULL;
        pArray = args->assemblyName->GetHashForControl()->GetDataPtr();
        dwHashForControl = args->assemblyName->GetHashForControl()->GetNumComponents();
        pHashForControl = (PBYTE) pThread->m_MarshalAlloc.Alloc(dwHashForControl);
        memcpy(pHashForControl, pArray, dwHashForControl);
    }

    AssemblySpec spec;
    OBJECTREF Throwable = NULL;  
    GCPROTECT_BEGIN(Throwable);

    if (args->assemblyName->GetSimpleName() != NULL) {
        STRINGREF sRef = (STRINGREF) args->assemblyName->GetSimpleName();
        DWORD strLen;
        if((strLen = sRef->GetStringLength()) == 0)
            COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

        psSimpleName = (LPUTF8) qb3.Alloc(++strLen);

        if (!COMString::TryConvertStringDataToUTF8(sRef, psSimpleName, strLen))
            psSimpleName = GetClassStringVars(sRef, &qb, &strLen);

        // Only need to get referencing IAssembly for Load(), not LoadFrom()
        Assembly *pRefAssembly;
        if (args->locationHint == NULL) {
            pRefAssembly = SystemDomain::GetCallersAssembly(args->stackMark);

            // Cross-appdomain callers aren't allowed as the parent
            if (pRefAssembly &&
                (pRefAssembly->GetDomain() != pThread->GetDomain()))
                pRefAssembly = NULL;
        }
        else
            pRefAssembly = args->locationHint->GetAssembly();

        // Shared assemblies should not be used for the parent in the
        // late-bound case.
        if (pRefAssembly && (!pRefAssembly->IsShared()))
            pRefIAssembly = pRefAssembly->GetFusionAssembly();
        
        if (args->fIsStringized)
            hr = spec.Init(psSimpleName); 
        else
            hr = spec.Init(psSimpleName, &sContext, 
                           pStrongName, dwStrongName, 
                           dwFlags);

        spec.GetCodeBase()->SetParentAssembly(pRefIAssembly);
    }
    else {
        hr = spec.Init((LPCSTR) NULL);
        spec.SetCodeBase(pCodeBase, dwCodeBase);
    }

    if (SUCCEEDED(hr)) {

        if (pHashForControl)
            spec.SetHashForControl(pHashForControl, dwHashForControl, args->assemblyName->GetHashAlgorithmForControl());

        hr = spec.LoadAssembly(&pAssembly, &Throwable,
                               &args->security);

        // If the user specified both a simple name and a codebase, and the module
        // wasn't found by simple name, try again, this time also using the codebase
        if ((!Assembly::ModuleFound(hr)) && psSimpleName && pCodeBase) {
            AssemblySpec spec2;
            spec2.SetCodeBase(pCodeBase, dwCodeBase);
            Throwable = NULL;
            hr = spec2.LoadAssembly(&pAssembly, &Throwable,
                                   &args->security);

            if (SUCCEEDED(hr) && pAssembly->GetFusionAssemblyName()) {
                IAssemblyName* pReqName = NULL;
                BOOL bNameIsGood=TRUE;
                #define MAKE_TRANSLATIONFAILED {bNameIsGood=FALSE ;hr=E_INVALIDARG;}
                MAKE_WIDEPTR_FROMUTF8(wszAssembly, psSimpleName);
                #undef MAKE_TRANSLATIONFAILED

                if (bNameIsGood)
                {
                    if (args->fIsStringized)
                        hr = CreateAssemblyNameObject(&pReqName, wszAssembly, CANOF_PARSE_DISPLAY_NAME, NULL);
                    else
                        hr = Assembly::SetFusionAssemblyName(wszAssembly,
                                                                dwFlags,
                                                                &sContext,
                                                                pStrongName,
                                                                dwStrongName,
                                                                &pReqName);
                }

                if (SUCCEEDED(hr)) {
                    hr = pAssembly->GetFusionAssemblyName()->IsEqual(pReqName, ASM_CMPF_DEFAULT);
                    if(hr == S_FALSE) {
                        hr = FUSION_E_REF_DEF_MISMATCH;
                        PostFileLoadException(psSimpleName, FALSE, NULL, hr, &Throwable);
                    }
                }
                if (pReqName)
                    pReqName->Release();
            }
        }
    }

    // Throw special exception for display name if file not found, for clarity
    if ((Throwable != NULL) &&
        ( (hr != COR_E_FILENOTFOUND) || ( args->fThrowOnFileNotFound) )) {
        pThread->m_MarshalAlloc.Collapse(checkPointMarker);
        COMPlusThrow(Throwable);
    }
    GCPROTECT_END();

    if (SUCCEEDED(hr))
        *((ASSEMBLYREF*) &rv) = (ASSEMBLYREF) pAssembly->GetExposedObject();
    else if (args->fThrowOnFileNotFound) {
        pThread->m_MarshalAlloc.Collapse(checkPointMarker);

        if ((hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) && psSimpleName) {
                #define MAKE_TRANSLATIONFAILED  pSimpleName=L""
                MAKE_WIDEPTR_FROMUTF8_FORPRINT(pSimpleName, psSimpleName);
                #undef MAKE_TRANSLATIONFAILED
                COMPlusThrow(kFileNotFoundException, IDS_EE_DISPLAYNAME_NOT_FOUND,
                             pSimpleName);
        }
        COMPlusThrowHR(hr);
    }
    
    pThread->m_MarshalAlloc.Collapse(checkPointMarker);

    return rv;
}


LPVOID __stdcall AssemblyNative::LoadImage(LoadAssemblyImageArgs *args)
{
    HRESULT hr = S_OK;
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    if (args->PEByteArray == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Array");

    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);

    PBYTE pbImage;
    DWORD cbImage;
    SecurityHelper::CopyByteArrayToEncoding(&args->PEByteArray, &pbImage, &cbImage);

    // Get caller's assembly so we can extract their codebase and propagate it
    // into the new assembly (which obviously doesn't have one of its own).
    LPCWSTR pCallersFileName = NULL;
    Assembly *pCallersAssembly = SystemDomain::GetCallersAssembly(args->stackMark);
    if (pCallersAssembly) { // can be null if caller is interop
        PEFile *pCallersFile = pCallersAssembly->GetSecurityModule()->GetPEFile();
        pCallersFileName = pCallersFile->GetFileName();

        // The caller itself may have been loaded via byte array.
        if (pCallersFileName[0] == L'\0')
            pCallersFileName = pCallersFile->GetLoadersFileName();
    }

    // Check for the presence and validity of a strong name.
    BEGIN_ENSURE_PREEMPTIVE_GC();
    if (!StrongNameSignatureVerificationFromImage(pbImage, cbImage, SN_INFLAG_INSTALL|SN_INFLAG_ALL_ACCESS, NULL))
        hr = StrongNameErrorInfo();
    END_ENSURE_PREEMPTIVE_GC();
    if (FAILED(hr) && hr != CORSEC_E_MISSING_STRONGNAME)
        COMPlusThrowHR(hr);

    PEFile *pFile;
    hr = PEFile::Create(pbImage, cbImage, 
                        NULL, 
                        pCallersFileName, 
                        &args->security, 
                        &pFile, 
                        FALSE);
    if (FAILED(hr))
        COMPlusThrowHR(hr);

    Module* pModule = NULL;
    Assembly *pAssembly;

    hr = pDomain->LoadAssembly(pFile, 
                               NULL, 
                               &pModule, 
                               &pAssembly, 
                               NULL,
                               &args->security,
                               FALSE,
                               NULL);

    if(FAILED(hr)) {
        FreeM(pbImage);
        COMPlusThrowHR(hr);
    }

    LOG((LF_CLASSLOADER, 
         LL_INFO100, 
         "\tLoaded in-memory module\n"));

    if (pAssembly)
    {
#ifdef DEBUGGING_SUPPORTED
        // If we were given symbols and we need to track JIT info for
        // the debugger, load them now.
        PBYTE pbSyms = NULL;
        DWORD cbSyms = 0;

        if ((args->SymByteArray != NULL) &&
            CORDebuggerTrackJITInfo(pModule->GetDebuggerInfoBits()))
        {
            SecurityHelper::CopyByteArrayToEncoding(&args->SymByteArray,
                                                    &pbSyms, &cbSyms);

            hr = pModule->SetSymbolBytes(pbSyms, cbSyms);

            if (FAILED(hr))
                COMPlusThrowHR(HRESULT_FROM_WIN32(hr));

            FreeM(pbSyms);
        }
#endif // DEBUGGING_SUPPORTED
        *((ASSEMBLYREF*) &rv) = (ASSEMBLYREF) pAssembly->GetExposedObject();
    }

    FreeM(pbImage);
    return rv;
}

LPVOID __stdcall AssemblyNative::LoadFile(LoadAssemblyFileArgs *args)
{
    HRESULT hr = S_OK;
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    if (args->path == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Path");
    
    CQuickBytes qb;
    LPWSTR pwzPath;
    DWORD  dwPath;
    WCHAR* pString;
    int    iString;
    
    RefInterpretGetStringValuesDangerousForGC(args->path, &pString, &iString);
    dwPath = (DWORD) iString + 1;
    pwzPath = (LPWSTR) qb.Alloc(dwPath * sizeof(WCHAR));
    memcpy(pwzPath, pString, dwPath * sizeof(WCHAR));

    PEFile *pFile;
    hr = PEFile::Create(pwzPath,
                        NULL, 
                        mdFileNil,
                        FALSE,
                        NULL,
                        NULL,
                        &args->security, 
                        &pFile);
    if (FAILED(hr))
        COMPlusThrowHR(hr);

    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);

    Assembly *pAssembly;
    hr = pDomain->LoadAssembly(pFile, 
                               NULL, 
                               NULL, 
                               &pAssembly, 
                               &args->security, 
                               FALSE,
                               NULL);
    if(FAILED(hr))
        COMPlusThrowHR(hr);

    LOG((LF_CLASSLOADER, 
         LL_INFO100, 
         "\tLoaded assembly from a file\n"));

    if (pAssembly)
        *((ASSEMBLYREF*) &rv) = (ASSEMBLYREF) pAssembly->GetExposedObject();

    return rv;
}

LPVOID __stdcall AssemblyNative::LoadModuleImage(LoadModuleImageArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->IsShared())
        COMPlusThrow(kNotSupportedException, L"NotSupported_SharedAssembly");

    if (args->moduleName == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_FileName");
    
    if (args->PEByteArray == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_Array");

    LPSTR psModuleName = NULL;
    WCHAR* pModuleName = NULL;
    WCHAR* pString;
    int    iString;
    CQuickBytes qb;

    RefInterpretGetStringValuesDangerousForGC((STRINGREF) args->moduleName, &pString, &iString);
    if(iString == 0)
        COMPlusThrow(kArgumentException, L"Argument_EmptyFileName");
    
    pModuleName = (LPWSTR) qb.Alloc((++iString) * sizeof(WCHAR));
    memcpy(pModuleName, pString, iString*sizeof(WCHAR));
    
    #define MAKE_TRANSLATIONFAILED COMPlusThrow(kArgumentException, L"Argument_EmptyFileName");
    MAKE_UTF8PTR_FROMWIDE(pName, pModuleName);
    #undef MAKE_TRANSLATIONFAILED

    psModuleName = pName;

    HashDatum datum;
    mdFile kFile = NULL;
    if (pAssembly->m_pAllowedFiles->GetValue(psModuleName, &datum))
        kFile = (mdFile)(size_t)datum;

    // If the name doesn't match one of the File def names, don't load this module.
    // If this name matches the manifest file (datum was NULL), don't load either.
    if (!kFile)
        COMPlusThrow(kArgumentException, L"Arg_InvalidFileName");

    PBYTE pbImage;
    DWORD cbImage;
    SecurityHelper::CopyByteArrayToEncoding(&args->PEByteArray, &pbImage, &cbImage);

    HRESULT hr;
    const BYTE* pbHash;
    DWORD cbHash;
    DWORD dwFlags;
    pAssembly->GetManifestImport()->GetFileProps(kFile,
                                                 NULL, //name
                                                 (const void**) &pbHash,
                                                 &cbHash,
                                                 &dwFlags);

    if ( pAssembly->m_cbPublicKey ||
         pAssembly->m_pManifest->GetSecurityDescriptor()->IsSigned() ) {

        if (!pbHash)
            hr = CRYPT_E_HASH_VALUE;
        else
            hr = Assembly::VerifyHash(pbImage,
                                      cbImage,
                                      pAssembly->m_ulHashAlgId,
                                      pbHash,
                                      cbHash);

        if (FAILED(hr)) {
            FreeM(pbImage);
            COMPlusThrowHR(hr);
        }
    }

    BOOL fResource = IsFfContainsNoMetaData(dwFlags);
    PEFile *pFile;
    hr = PEFile::Create(pbImage, cbImage, 
                        NULL, 
                        NULL, 
                        &args->security, 
                        &pFile, 
                        fResource);

    FreeM(pbImage);
    if (FAILED(hr))
        COMPlusThrowHR(hr);

    Module* pModule = NULL;
    OBJECTREF Throwable = NULL;  
    GCPROTECT_BEGIN(Throwable);
    hr = pAssembly->LoadFoundInternalModule(pFile,
                                            kFile,
                                            fResource,
                                            &pModule,
                                            &Throwable);
    if(hr != S_OK) {
        if (Throwable != NULL)
            COMPlusThrow(Throwable);

        if (hr == S_FALSE)
            COMPlusThrow(kArgumentException, L"Argument_ModuleAlreadyLoaded");

        COMPlusThrowHR(hr);
    }
    GCPROTECT_END();

    LOG((LF_CLASSLOADER, 
         LL_INFO100, 
         "\tLoaded in-memory module\n"));

    if (pModule) {
#ifdef DEBUGGING_SUPPORTED
        if (!fResource) {
            // If we were given symbols and we need to track JIT info for
            // the debugger, load them now.
            PBYTE pbSyms = NULL;
            DWORD cbSyms = 0;
            
            if ((args->SymByteArray != NULL) &&
                CORDebuggerTrackJITInfo(pModule->GetDebuggerInfoBits())) {
                SecurityHelper::CopyByteArrayToEncoding(&args->SymByteArray,
                                                        &pbSyms, &cbSyms);
                
                hr = pModule->SetSymbolBytes(pbSyms, cbSyms);
                FreeM(pbSyms);
                
                if (FAILED(hr))
                    COMPlusThrowHR(hr);
            }
        }

#endif // DEBUGGING_SUPPORTED
        *((REFLECTMODULEBASEREF*) &rv) = (REFLECTMODULEBASEREF) pModule->GetExposedModuleObject();
    }

    return rv;
}


LPVOID __stdcall AssemblyNative::GetLocation(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->GetManifestFile() &&
        pAssembly->GetManifestFile()->GetFileName()) {

        OBJECTREF pObj = (OBJECTREF) COMString::NewString(pAssembly->GetManifestFile()->GetFileName());        
        *((OBJECTREF*)(&rv)) = pObj;
    }

    return rv;
}

extern EEClass *GetCallersClass(StackCrawlMark *stackMark, void *returnIP);
extern Assembly *GetCallersAssembly(StackCrawlMark *stackMark, void *returnIP);

LPVOID __stdcall AssemblyNative::GetType1Args(GetType1Arg *args)
{
    THROWSCOMPLUSEXCEPTION();

    // Load the class from this module (fail if it is in a different one).
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    return GetTypeInner(pAssembly, &args->name, FALSE, FALSE, TRUE, FALSE);
}

LPVOID __stdcall AssemblyNative::GetType2Args(GetType2Arg *args)
{
    THROWSCOMPLUSEXCEPTION();

    // Load the class from this module (fail if it is in a different one).
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    return GetTypeInner(pAssembly, &args->name, args->bThrowOnError, FALSE, TRUE, FALSE);
}

LPVOID __stdcall AssemblyNative::GetType3Args(GetType3Arg *args)
{
    THROWSCOMPLUSEXCEPTION();

    // Load the class from this module (fail if it is in a different one).
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    return GetTypeInner(pAssembly, &args->name, args->bThrowOnError, args->bIgnoreCase, TRUE, FALSE);
}

LPVOID __stdcall AssemblyNative::GetTypeInternal(GetTypeInternalArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    // Load the class from this module (fail if it is in a different one).
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    return GetTypeInner(pAssembly, &args->name, args->bThrowOnError, args->bIgnoreCase, FALSE, args->bPublicOnly);
}

LPVOID AssemblyNative::GetTypeInner(Assembly *pAssembly,
                                    STRINGREF *refClassName, 
                                    BOOL bThrowOnError, 
                                    BOOL bIgnoreCase, 
                                    BOOL bVerifyAccess,
                                    BOOL bPublicOnly)
{
    THROWSCOMPLUSEXCEPTION();

    STRINGREF       sRef = *refClassName;
    if (!sRef)
        COMPlusThrowArgumentNull(L"typeName",L"ArgumentNull_String");

    LPVOID          rv = NULL;
    EEClass*        pClass = NULL;
    DWORD           strLen = sRef->GetStringLength() + 1;
    CQuickBytes     qb;
    LPUTF8          szClassName = (LPUTF8) qb.Alloc(strLen);
    CQuickBytes     bytes;
    DWORD           cClassName;

    // Get the class name in UTF8
    if (!COMString::TryConvertStringDataToUTF8(sRef, szClassName, strLen))
        szClassName = GetClassStringVars(sRef, &bytes, &cClassName);
    
    // Find the return address. This can be used to find caller's assembly
    Frame *pFrame = GetThread()->GetFrame();
    _ASSERTE(pFrame->IsFramedMethodFrame());

    void *returnIP;
    EEClass *pCallersClass = NULL;
    Assembly *pCallersAssembly = NULL;
    returnIP = pFrame->GetReturnAddress();

    if(pAssembly) {
        TypeHandle typeHnd;
        BOOL fVisible = TRUE;
        OBJECTREF Throwable = NULL;

        // Look for namespace separator
        LPUTF8 szNameSpaceSep = NULL;
        LPUTF8 szWalker = szClassName;
        DWORD nameLen = 0;
        for (; *szWalker; szWalker++, nameLen++) {
            if (*szWalker == NAMESPACE_SEPARATOR_CHAR)
                szNameSpaceSep = szWalker;
        }

        if (nameLen >= MAX_CLASSNAME_LENGTH)
            COMPlusThrow(kArgumentException, L"Argument_TypeNameTooLong");

        GCPROTECT_BEGIN(Throwable);

        if (NormalizeArrayTypeName(szClassName, nameLen)) {

            if (!*szClassName)
              COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

            NameHandle typeName;
            char noNameSpace = '\0';
            if (szNameSpaceSep) {

                *szNameSpaceSep = '\0';
                typeName.SetName(szClassName, szNameSpaceSep + 1);
            }
            else
                typeName.SetName(&noNameSpace, szClassName);

            if(bIgnoreCase)
                typeName.SetCaseInsensitive();
            else
                typeName.SetCaseSensitive();

            if (bVerifyAccess) {
                pCallersClass = GetCallersClass(NULL, returnIP);
                pCallersAssembly = (pCallersClass) ? pCallersClass->GetAssembly() : NULL;
            }

            // Returning NULL only means that the type is not in this assembly.
            typeHnd = pAssembly->FindNestedTypeHandle(&typeName, &Throwable);

            if (typeHnd.IsNull() && Throwable == NULL) 
                typeHnd = pAssembly->GetInternalType(&typeName, bThrowOnError, &Throwable);

            if (!typeHnd.IsNull() && bVerifyAccess) {
                // verify visibility
                BOOL bIsPublic = TRUE;

                EEClass *pClass = typeHnd.GetClassOrTypeParam();
                _ASSERTE(pClass);
                
                if (bPublicOnly && !(IsTdPublic(pClass->GetProtection()) || IsTdNestedPublic(pClass->GetProtection())))
                    // the user is asking for a public class but the class we have is not public, discard
                    fVisible = FALSE;
                else {
                    // if the class is a top level public there is no check to perform
                    if (!IsTdPublic(pClass->GetProtection())) {
                        if (!pCallersAssembly) {
                            pCallersClass = GetCallersClass(NULL, returnIP);
                            pCallersAssembly = (pCallersClass) ? pCallersClass->GetAssembly() : NULL;
                        }

                        if (pCallersAssembly && // full trust for interop
                            !ClassLoader::CanAccess(pCallersClass,
                                                    pCallersAssembly,
                                                    pClass,
                                                    pClass->GetAssembly(),
                                                    pClass->GetAttrClass())) {
                            // This is not legal if the user doesn't have reflection permission
                            if (!AssemblyNative::HaveReflectionPermission(bThrowOnError))
                                fVisible = FALSE;
                        }
                    }
                }
            }

            if((!typeHnd.IsNull()) && fVisible)
                // There one case were this may return null, if typeHnd
                //  represents the Transparent proxy.
                rv = OBJECTREFToObject(typeHnd.CreateClassObj());
        }

        if ((rv == NULL) && bThrowOnError) {

            if (Throwable == NULL) {
                if (szNameSpaceSep)
                    *szNameSpaceSep = NAMESPACE_SEPARATOR_CHAR;

                pAssembly->PostTypeLoadException(szClassName, IDS_CLASSLOAD_GENERIC, &Throwable);
            }

            COMPlusThrow(Throwable);
        }
        
        GCPROTECT_END();
    }
    
    return rv;
}


BOOL AssemblyNative::HaveReflectionPermission(BOOL ThrowOnFalse)
{
    THROWSCOMPLUSEXCEPTION();

    BOOL haveReflectionPermission = TRUE;
    COMPLUS_TRY {
        COMMember::g_pInvokeUtil->CheckSecurity();
    }
    COMPLUS_CATCH {
        if (ThrowOnFalse)
            COMPlusRareRethrow();

        haveReflectionPermission = FALSE;
    } COMPLUS_END_CATCH

    return haveReflectionPermission;
}
 

INT32 __stdcall AssemblyNative::GetVersion(GetVersionArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->m_Context) {
        *args->pRevisionNumber = pAssembly->m_Context->usRevisionNumber;
        *args->pBuildNumber = pAssembly->m_Context->usBuildNumber;
        *args->pMinorVersion = pAssembly->m_Context->usMinorVersion;
        *args->pMajorVersion = pAssembly->m_Context->usMajorVersion;
        return 1;        
    }
    else
        return 0;
}


LPVOID __stdcall AssemblyNative::GetPublicKey(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    OBJECTREF pObj = NULL;
    GCPROTECT_BEGIN(pObj);

    SecurityHelper::CopyEncodingToByteArray(pAssembly->m_pbPublicKey,
                                            pAssembly->m_cbPublicKey,
                                            &pObj);
        
    *((OBJECTREF*)(&rv)) = pObj;
    GCPROTECT_END();

    return rv;
}

LPVOID __stdcall AssemblyNative::GetSimpleName(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->m_psName)
        *((OBJECTREF*)(&rv)) = (OBJECTREF) COMString::NewString(pAssembly->m_psName);

    return rv;
}

/*
LPVOID __stdcall AssemblyNative::GetProcessors(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->m_Context &&
        pAssembly->m_Context->ulProcessor) {

        MethodTable *pMT = g_Mscorlib.GetClass(CLASS__PROCESSOR_ID);

        BASEARRAYREF pArray = NULL;
        GCPROTECT_BEGIN(pArray);

        TypeHandle arrayType = g_Mscorlib.GetType(TYPE__PROCESSOR_ID_ARRAY).AsArray();

        pArray = (BASEARRAYREF) AllocateArrayEx(arrayType,
                                                &pAssembly->m_Context->ulProcessor,
                                                1,
                                                FALSE);
        if(pArray == NULL) COMPlusThrowOM();
        
        BYTE* ptr = (BYTE*) pArray->GetDataPtr();
        DWORD size = pArray->GetComponentSize();

        for(ULONG i = 0; i < pAssembly->m_Context->ulProcessor; i++) {
            memcpyNoGCRefs(ptr, &(pAssembly->m_Context->rProcessor[i]), size);
            ptr += size;
        }

        *((OBJECTREF*)(&rv)) = (OBJECTREF) pArray;
        GCPROTECT_END();
    }

    return rv;
}
*/

/*
LPVOID __stdcall AssemblyNative::GetOSInformation(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->m_Context &&
        pAssembly->m_Context->ulOS) {
        
        MethodTable *pOSMT = g_Mscorlib.GetClass(CLASS__OPERATING_SYSTEM);
        MethodTable *pVersionMT = g_Mscorlib.GetClass(CLASS__VERSION);

        MethodDesc *pOSConstructor = g_Mscorlib.GetMethod(METHOD__OPERATING_SYSTEM__CTOR);
        MethodDesc *pVersionConstructor = g_Mscorlib.GetMethod(METHOD__VERSION__CTOR2);
            
        struct _gc {
            OBJECTREF pObj;
            PTRARRAYREF pArray;
            OBJECTREF pVersion;
        } gc;
        ZeroMemory(&gc, sizeof(gc));

        GCPROTECT_BEGIN(gc);
        
        gc.pArray = (PTRARRAYREF) AllocateObjectArray(pAssembly->m_Context->ulOS, pOSMT);
        if(gc.pArray == NULL) COMPlusThrowOM();
        
        for(ULONG i = 0; i < pAssembly->m_Context->ulOS; i++) {

            gc.pVersion = AllocateObject(pVersionMT);

            INT64 VersionArgs[3] =
            {
                ObjToInt64(gc.pVersion),
                (INT64) pAssembly->m_Context->rOS[i].dwOSMinorVersion,
                (INT64) pAssembly->m_Context->rOS[i].dwOSMajorVersion,      
            };
            pVersionConstructor->Call(VersionArgs, METHOD__VERSION__CTOR2);

            gc.pObj = AllocateObject(pOSMT);

            INT64 args[4] = 
            {
                ObjToInt64(gc.pObj),
                ObjToInt64(gc.pVersion),
                (INT64) pAssembly->m_Context->rOS[i].dwOSPlatformId
            };
            pOSConstructor->Call(args, METHOD__OPERATING_SYSTEM__CTOR);

            gc.pArray->SetAt(i, gc.pObj);
        }
        
        *((PTRARRAYREF*)(&rv)) = gc.pArray;
        GCPROTECT_END();
    }

    return rv;
}
*/


LPVOID __stdcall AssemblyNative::GetLocale(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (pAssembly->m_Context &&
        pAssembly->m_Context->szLocale &&
        *pAssembly->m_Context->szLocale)
        *((OBJECTREF*)(&rv)) = (OBJECTREF)COMString::NewString(pAssembly->m_Context->szLocale);

    return rv;
}

LPVOID __stdcall AssemblyNative::GetCodeBase(GetCodebaseArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    LPVOID rv = NULL;
    HRESULT hr;
    LPWSTR  pCodeBase = NULL;
    DWORD   dwCodeBase = 0;
    CQuickBytes qb;


    if(args->fCopiedName && pAssembly->GetDomain()->IsShadowCopyOn()) {
        hr = pAssembly->FindCodeBase(pCodeBase, &dwCodeBase, TRUE);

        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
            pCodeBase = (LPWSTR) qb.Alloc(dwCodeBase * sizeof(WCHAR));
            hr = pAssembly->FindCodeBase(pCodeBase, &dwCodeBase, TRUE);
        }
    }
    else
        hr = pAssembly->GetCodeBase(&pCodeBase, &dwCodeBase);

    if(SUCCEEDED(hr)) {
        if (pCodeBase)
            *((OBJECTREF*)(&rv)) = (OBJECTREF) COMString::NewString(pCodeBase);
    }
    else
        COMPlusThrowHR(hr);

    return rv;
}


INT32 __stdcall AssemblyNative::GetHashAlgorithm(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    return pAssembly->m_ulHashAlgId;
}

/*
LPVOID __stdcall AssemblyNative::GetAssemblyHash(NoArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (! (pAssembly->m_ulHashAlgId && pAssembly->GetManifestFile()) )
        return NULL;

    if (!pAssembly->m_pbHashValue) {
        IMAGE_COR20_HEADER *Header = pAssembly->GetManifestFile()->GetCORHeader();

        HRESULT hr = Assembly::GetHash(pAssembly->GetManifestFile()->GetBase() +
                                       Header->MetaData.VirtualAddress,
                                       Header->MetaData.Size,
                                       pAssembly->m_ulHashAlgId,
                                       &pAssembly->m_pbHashValue,
                                       &pAssembly->m_cbHashValue);
        
        if (FAILED(hr))
            COMPlusThrowHR(hr);
    }

    OBJECTREF pObj = NULL;
    GCPROTECT_BEGIN(pObj);

    SecurityHelper::CopyEncodingToByteArray(pAssembly->m_pbHashValue,
                                            pAssembly->m_cbHashValue,
                                            &pObj);

    *((OBJECTREF*)(&rv)) = pObj;
    GCPROTECT_END();

    return rv;
}
*/


INT32 __stdcall AssemblyNative::GetFlags(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    return pAssembly->m_dwFlags;
}


BYTE* __stdcall AssemblyNative::GetResource(GetResourceArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args->length != NULL);

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (args->name == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
        
    // Get the name in UTF8
    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    szName = GetClassStringVars(args->name, &bytes, &cName);

    if (!cName)
        COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

    DWORD  cbResource;
    PBYTE pbInMemoryResource = NULL;

    if (SUCCEEDED(pAssembly->GetResource(szName, NULL, &cbResource,
                                         &pbInMemoryResource, NULL, NULL,
                                         NULL, args->stackMark, args->skipSecurityCheck))) {
        _ASSERTE(pbInMemoryResource);
        *(args->length) = cbResource;
    }

    return pbInMemoryResource;
}


INT32 __stdcall AssemblyNative::GetManifestResourceInfo(GetResourceInfoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (args->name == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_String");
        
    // Get the name in UTF8
    CQuickBytes bytes;
    LPSTR szName;
    DWORD cName;

    szName = GetClassStringVars(args->name, &bytes, &cName);
    if (!cName)
        COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

    *(args->pFileName) = NULL;
    *(args->pAssemblyRef) = NULL;
    LPCSTR pFileName = NULL;
    DWORD dwLocation = 0;
    Assembly *pReferencedAssembly = NULL;

    if (FAILED(pAssembly->GetResource(szName, NULL, NULL, NULL,
                                      &pReferencedAssembly, &pFileName,
                                      &dwLocation, args->stackMark)))
        return -1;
    else {
        if (pFileName) {
            *((STRINGREF*) (&(*(args->pFileName)))) = COMString::NewString(pFileName);
        }
        if (pReferencedAssembly) {
            *((OBJECTREF*) (&(*(args->pAssemblyRef)))) = pReferencedAssembly->GetExposedObject();
        }

        return (INT32) dwLocation;
    }
}


LPVOID __stdcall AssemblyNative::GetModules(GetModulesArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pModuleClass = g_Mscorlib.GetClass(CLASS__MODULE);
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    HENUMInternal phEnum;

    HRESULT hr;
    if (FAILED(hr = pAssembly->GetManifestImport()->EnumInit(mdtFile,
                                                             mdTokenNil,
                                                             &phEnum)))
        COMPlusThrowHR(hr);

    DWORD dwElements = pAssembly->GetManifestImport()->EnumGetCount(&phEnum) + 1;

    struct _gc {
        PTRARRAYREF ModArray;
        PTRARRAYREF nArray;
        OBJECTREF Throwable;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
        
    GCPROTECT_BEGIN(gc);
    gc.ModArray = (PTRARRAYREF) AllocateObjectArray(dwElements,pModuleClass);
    if (!gc.ModArray)
        COMPlusThrowOM();
    
    int iCount = 0;

    mdFile  mdFile;
    OBJECTREF o = pAssembly->GetSecurityModule()->GetExposedModuleObject();
    gc.ModArray->SetAt(0, o);

    for(int i = 1;
        pAssembly->GetManifestImport()->EnumNext(&phEnum, &mdFile);
        i++) {
            
        Module  *pModule = pAssembly->GetSecurityModule()->LookupFile(mdFile);

        if (pModule) {
            if (pModule->IsResource() &&
                (!args->fGetResourceModules))
                pModule = NULL;
        }
        else if (args->fLoadIfNotFound) {
            // Module isn't loaded yet

            LPCSTR szModuleName;
            const BYTE* pHash;
            DWORD dwFlags;
            ULONG dwHashLength;
            pAssembly->GetManifestImport()->GetFileProps(mdFile,
                                                         &szModuleName,
                                                         (const void**) &pHash,
                                                         &dwHashLength,
                                                         &dwFlags);

            if (IsFfContainsMetaData(dwFlags) ||
                args->fGetResourceModules) {
                WCHAR pPath[MAX_PATH];
                hr = pAssembly->LoadInternalModule(szModuleName,
                                                   mdFile,
                                                   pAssembly->m_ulHashAlgId,
                                                   pHash,
                                                   dwHashLength,
                                                   dwFlags,
                                                   pPath,
                                                   MAX_PATH,
                                                   &pModule, 
                                                   &gc.Throwable);
                if(FAILED(hr)) {
                    pAssembly->GetManifestImport()->EnumClose(&phEnum);
                    
                    if (gc.Throwable != NULL)
                        COMPlusThrow(gc.Throwable);
                    COMPlusThrowHR(hr);
                }
            }
        }

        if(pModule) {
            OBJECTREF o = (OBJECTREF) pModule->GetExposedModuleObject();
            gc.ModArray->SetAt(i, o);
        }
        else
            iCount++;
    }
    
    pAssembly->GetManifestImport()->EnumClose(&phEnum);        
    
    if(iCount) {
        gc.nArray = (PTRARRAYREF) AllocateObjectArray(dwElements - iCount, pModuleClass);
        DWORD index = 0;
        for(DWORD ii = 0; ii < dwElements; ii++) {
            if(gc.ModArray->GetAt(ii) != NULL) {
                _ASSERTE(index < dwElements - iCount);
                gc.nArray->SetAt(index, gc.ModArray->GetAt(ii));
                index++;
            }
        }
        
        *((PTRARRAYREF*) &rv) = gc.nArray;
    }
    else {
        *((PTRARRAYREF*) &rv) = gc.ModArray;
    }
    
    GCPROTECT_END();

    return rv;
}


LPVOID __stdcall AssemblyNative::GetModule(GetModuleArgs *args)
{
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    if (args->strFileName == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_FileName");
    if(*(args->strFileName->GetBuffer()) == L'\0')
        COMPlusThrow(kArgumentException, L"Argument_EmptyFileName");
    
    Module *pModule;
    #define MAKE_TRANSLATIONFAILED COMPlusThrow(kArgumentException, L"Argument_EmptyFileName");
    MAKE_UTF8PTR_FROMWIDE(szModuleName, args->strFileName->GetBuffer());
    #undef MAKE_TRANSLATIONFAILED

    HashDatum datum;
    if (pAssembly->m_pAllowedFiles->GetValue(szModuleName, &datum)) {
        if (datum) { // internal module
            pModule = pAssembly->GetSecurityModule()->LookupFile((mdFile)(size_t)datum);// @todo WIN64 - Pointer truncation

            if (!pModule) {
                const BYTE* pHash;
                DWORD dwFlags = 0;
                ULONG dwHashLength = 0;
                HRESULT hr;
                pAssembly->GetManifestImport()->GetFileProps((mdFile)(size_t)datum, // @todo WIN64 - Pointer truncation
                                                             NULL, //&szModuleName,
                                                             (const void**) &pHash,
                                                             &dwHashLength,
                                                             &dwFlags);
                
                OBJECTREF Throwable = NULL;
                GCPROTECT_BEGIN(Throwable);
                WCHAR pPath[MAX_PATH];
                hr = pAssembly->LoadInternalModule(szModuleName,
                                                   (mdFile)(size_t)datum, // @todo WIN64 - Pointer truncation
                                                   pAssembly->m_ulHashAlgId,
                                                   pHash,
                                                   dwHashLength,
                                                   dwFlags,
                                                   pPath,
                                                   MAX_PATH,
                                                   &pModule,
                                                   &Throwable);

                if (Throwable != NULL)
                    COMPlusThrow(Throwable);
                GCPROTECT_END();

                if (FAILED(hr))
                    COMPlusThrowHR(hr);
            }
        }
        else // manifest module
            pModule = pAssembly->GetSecurityModule();
            
        *((OBJECTREF*) &rv) = pModule->GetExposedModuleObject();
    }

    return rv;
}


LPVOID __stdcall AssemblyNative::GetExportedTypes(NoArgs *args)
{
    LPVOID rv = NULL;   
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pTypeClass = g_Mscorlib.GetClass(CLASS__TYPE);
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    _ASSERTE(pAssembly->GetManifestImport());

    HENUMInternal phCTEnum;
    HENUMInternal phTDEnum;
    DWORD dwElements;

    if (pAssembly->GetManifestImport()->EnumInit(mdtExportedType,
                                                 mdTokenNil,
                                                 &phCTEnum) == S_OK)
        dwElements = pAssembly->GetManifestImport()->EnumGetCount(&phCTEnum);
    else
        dwElements = 0;

    if (pAssembly->GetSecurityModule()->GetMDImport()->EnumTypeDefInit(&phTDEnum) == S_OK)
        dwElements += pAssembly->GetSecurityModule()->GetMDImport()->EnumGetCount(&phTDEnum);

    mdExportedType mdCT;
    mdTypeDef mdTD;
    LPCSTR pszNameSpace;
    LPCSTR pszClassName;
    DWORD dwFlags;
    int iCount = 0;
    
    struct _gc {
        PTRARRAYREF TypeArray;
        PTRARRAYREF nArray;
        OBJECTREF Throwable;  
    } gc;
    ZeroMemory(&gc, sizeof(gc));

    GCPROTECT_BEGIN(gc);

    COMPLUS_TRY {
        gc.TypeArray = (PTRARRAYREF) AllocateObjectArray(dwElements, pTypeClass);
        if (gc.TypeArray == NULL)
            COMPlusThrowOM();
        
        while(pAssembly->GetSecurityModule()->GetMDImport()->EnumNext(&phTDEnum, &mdTD)) {
            mdTypeDef mdEncloser;
            TypeHandle typeHnd;
            
            pAssembly->GetSecurityModule()->GetMDImport()->GetNameOfTypeDef(mdTD,
                                                                            &pszClassName,
                                                                            &pszNameSpace);
            pAssembly->GetSecurityModule()->GetMDImport()->GetTypeDefProps(mdTD,
                                                                           &dwFlags,
                                                                           NULL);
            mdEncloser = mdTD;
            
            // nested type
            while (SUCCEEDED(pAssembly->GetSecurityModule()->GetMDImport()->GetNestedClassProps(mdEncloser, &mdEncloser)) &&
                   IsTdNestedPublic(dwFlags)) {
                pAssembly->GetSecurityModule()->GetMDImport()->GetTypeDefProps(mdEncloser,
                                                                               &dwFlags,
                                                                               NULL);
            }
            
            if (IsTdPublic(dwFlags)) {
                NameHandle typeName(pAssembly->GetSecurityModule(), mdTD);
                typeName.SetName(pszNameSpace, pszClassName);
                typeHnd = pAssembly->LoadTypeHandle(&typeName, &gc.Throwable);
                if (!typeHnd.IsNull()) {
                    OBJECTREF o = typeHnd.CreateClassObj();
                    gc.TypeArray->SetAt(iCount, o);
                    iCount++;
                }
                else if (gc.Throwable != NULL)
                    COMPlusThrow(gc.Throwable);
            }
        }
                
        // Now get the ExportedTypes that don't have TD's in the manifest file
        while(pAssembly->GetManifestImport()->EnumNext(&phCTEnum, &mdCT)) {
            mdToken mdImpl;
            TypeHandle typeHnd;
            pAssembly->GetManifestImport()->GetExportedTypeProps(mdCT,
                                                                 &pszNameSpace,
                                                                 &pszClassName,
                                                                 &mdImpl,
                                                                 NULL, //binding
                                                                 &dwFlags);
            
            // nested type
            while ((TypeFromToken(mdImpl) == mdtExportedType) &&
                   (mdImpl != mdExportedTypeNil) &&
                   IsTdNestedPublic(dwFlags)) {
                
                pAssembly->GetManifestImport()->GetExportedTypeProps(mdImpl,
                                                                     NULL, //namespace
                                                                     NULL, //name
                                                                     &mdImpl,
                                                                     NULL, //binding
                                                                     &dwFlags);
            }
            
            if ((TypeFromToken(mdImpl) == mdtFile) &&
                (mdImpl != mdFileNil) &&
                IsTdPublic(dwFlags)) {
                
                NameHandle typeName(pszNameSpace, pszClassName);
                typeName.SetTypeToken(pAssembly->GetSecurityModule(), mdCT);
                typeHnd = pAssembly->LookupTypeHandle(&typeName, &gc.Throwable);
                    
                if (typeHnd.IsNull() || (gc.Throwable != NULL)) {
                    if (gc.Throwable == NULL) {
                        pAssembly->PostTypeLoadException(pszNameSpace, pszClassName, IDS_CLASSLOAD_GENERIC, &gc.Throwable);
                    }

                    COMPlusThrow(gc.Throwable);                    
                }
                else {
                    OBJECTREF o = typeHnd.CreateClassObj();
                    gc.TypeArray->SetAt(iCount, o);
                    iCount++;
                }
            }
        }

        gc.nArray = (PTRARRAYREF) AllocateObjectArray(iCount, pTypeClass);
        for(int i = 0; i < iCount; i++)
            gc.nArray->SetAt(i, gc.TypeArray->GetAt(i));
        
        *((PTRARRAYREF*) &rv) = gc.nArray;
    }
    COMPLUS_FINALLY {

        pAssembly->GetManifestImport()->EnumClose(&phCTEnum);
        pAssembly->GetSecurityModule()->GetMDImport()->EnumTypeDefClose(&phTDEnum);
    } COMPLUS_END_FINALLY

    GCPROTECT_END();
    
    return rv;
}

LPVOID __stdcall AssemblyNative::GetResourceNames(NoArgs *args)
{
    LPVOID rv = NULL;   
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    _ASSERTE(pAssembly->GetManifestImport());

    HENUMInternal phEnum;
    DWORD dwCount;

    if (pAssembly->GetManifestImport()->EnumInit(mdtManifestResource,
                                                 mdTokenNil,
                                                 &phEnum) == S_OK)
        dwCount = pAssembly->GetManifestImport()->EnumGetCount(&phEnum);
    else
        dwCount = 0;

    PTRARRAYREF ItemArray = (PTRARRAYREF) AllocateObjectArray(dwCount, g_pStringClass);
        
    if (ItemArray == NULL)
        COMPlusThrowOM();

    mdManifestResource mdResource;

    GCPROTECT_BEGIN(ItemArray);
    for(DWORD i = 0;  i < dwCount; i++) {
        pAssembly->GetManifestImport()->EnumNext(&phEnum, &mdResource);
        LPCSTR pszName = NULL;
        
        pAssembly->GetManifestImport()->GetManifestResourceProps(mdResource,
                                                                 &pszName, // name
                                                                 NULL, // linkref
                                                                 NULL, // offset
                                                                 NULL); //flags
           
        OBJECTREF o = (OBJECTREF) COMString::NewString(pszName);
        ItemArray->SetAt(i, o);
    }
     
    *((PTRARRAYREF*) &rv) = ItemArray;
    GCPROTECT_END();
    
    pAssembly->GetManifestImport()->EnumClose(&phEnum);

    return rv;
}


LPVOID __stdcall AssemblyNative::GetReferencedAssemblies(NoArgs *args)
{
    LPVOID rv = NULL;   
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    _ASSERTE(pAssembly->GetManifestImport());

    MethodTable* pClass = g_Mscorlib.GetClass(CLASS__ASSEMBLY_NAME);
    MethodTable* pVersion = g_Mscorlib.GetClass(CLASS__VERSION);
    MethodTable* pCI = g_Mscorlib.GetClass(CLASS__CULTURE_INFO);

    HENUMInternal phEnum;
    DWORD dwCount;

    if (pAssembly->GetManifestImport()->EnumInit(mdtAssemblyRef,
                                                 mdTokenNil,
                                                 &phEnum) == S_OK)
        dwCount = pAssembly->GetManifestImport()->EnumGetCount(&phEnum);
    else
        dwCount = 0;
    
    mdAssemblyRef mdAssemblyRef;

    struct _gc {
        PTRARRAYREF ItemArray;
        OBJECTREF pObj;
        OBJECTREF CultureInfo;
        STRINGREF Locale;
        OBJECTREF Version;
        U1ARRAYREF PublicKeyOrToken;
        STRINGREF Name;
    } gc;
    ZeroMemory(&gc, sizeof(gc));
    
    GCPROTECT_BEGIN(gc);
 
    COMPLUS_TRY {
        
        gc.ItemArray = (PTRARRAYREF) AllocateObjectArray(dwCount, pClass);        
        if (gc.ItemArray == NULL)
            COMPlusThrowOM();
        
        for(DWORD i = 0; i < dwCount; i++) {
            
            pAssembly->GetManifestImport()->EnumNext(&phEnum, &mdAssemblyRef);
            
            LPCSTR pszName;
            const void *pbPublicKeyOrToken;
            DWORD cbPublicKeyOrToken;
            DWORD dwAssemblyRefFlags;
            AssemblyMetaDataInternal context;
            const void *pbHashValue;
            DWORD cbHashValue;
            
            ZeroMemory(&context, sizeof(context));
            pAssembly->GetManifestImport()->GetAssemblyRefProps(mdAssemblyRef,        // [IN] The AssemblyRef for which to get the properties.        
                                                                &pbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
                                                                &cbPublicKeyOrToken,  // [OUT] Count of bytes in the public key or token.
                                                                &pszName,             // [OUT] Buffer to fill with name.                              
                                                                &context,             // [OUT] Assembly MetaData.                                     
                                                                &pbHashValue,         // [OUT] Hash blob.                                             
                                                                &cbHashValue,         // [OUT] Count of bytes in the hash blob.                       
                                                                &dwAssemblyRefFlags); // [OUT] Flags.                                             
            
            MethodDesc *pCtor = g_Mscorlib.GetMethod(METHOD__VERSION__CTOR);
            
            // version
            gc.Version = AllocateObject(pVersion);
            
            INT64 VersionArgs[5] =
            {
                ObjToInt64(gc.Version),
                (INT64) context.usRevisionNumber,
                (INT64) context.usBuildNumber,
                (INT64) context.usMinorVersion,
                (INT64) context.usMajorVersion,      
            };
            pCtor->Call(VersionArgs, METHOD__VERSION__CTOR);
            
            // cultureinfo
            if (context.szLocale) {
                
                MethodDesc *pCtor = g_Mscorlib.GetMethod(METHOD__CULTURE_INFO__STR_CTOR);
                
                gc.CultureInfo = AllocateObject(pCI);
                
                gc.Locale = COMString::NewString(context.szLocale);
                
                INT64 args[2] = 
                {
                    ObjToInt64(gc.CultureInfo),
                    ObjToInt64(gc.Locale)
                };
                
                pCtor->Call(args, METHOD__CULTURE_INFO__STR_CTOR);
            }
            
            // public key or token byte array
            SecurityHelper::CopyEncodingToByteArray((BYTE*) pbPublicKeyOrToken,
                                                    cbPublicKeyOrToken,
                                                    (OBJECTREF*) &gc.PublicKeyOrToken);
            
            // simple name
            if(pszName)
                gc.Name = COMString::NewString(pszName);
            
            pCtor = g_Mscorlib.GetMethod(METHOD__ASSEMBLY_NAME__CTOR);
            
            gc.pObj = AllocateObject(pClass);
            INT64 MethodArgs[] = { ObjToInt64(gc.pObj),
                                   (INT64) dwAssemblyRefFlags,
                                   ObjToInt64(gc.CultureInfo),
                                   ObjToInt64(gc.Version),
                                   (INT64) pAssembly->m_ulHashAlgId,
                                   (INT64) NULL, // codebase
                                   ObjToInt64(gc.PublicKeyOrToken),
                                   ObjToInt64(gc.Name)                 
            };
            
            pCtor->Call(MethodArgs, METHOD__ASSEMBLY_NAME__CTOR);
            
            gc.ItemArray->SetAt(i, gc.pObj);
    }
     
    *((PTRARRAYREF*) &rv) = gc.ItemArray;
    }
    COMPLUS_CATCH {
        pAssembly->GetManifestImport()->EnumClose(&phEnum);
        OBJECTREF Throwable = GETTHROWABLE();
        COMPlusThrow(Throwable);
    } COMPLUS_END_CATCH

    GCPROTECT_END();
    pAssembly->GetManifestImport()->EnumClose(&phEnum);

    return rv;
}


LPVOID __stdcall AssemblyNative::GetEntryPoint(NoArgs *args)
{
    mdToken     ptkParent;
    MethodDesc* pMeth;
    Module*     pModule = 0;
    HRESULT     hr;

    LPVOID      rv = NULL; 

    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    hr = pAssembly->GetEntryPoint(&pModule);
    if (FAILED(hr)) {

        if (hr == E_FAIL) // no entrypoint
            return NULL;

        COMPlusThrowHR(hr);
    }

    _ASSERTE(pModule);
    IMAGE_COR20_HEADER* Header = pModule->GetCORHeader();

    hr = pModule->GetMDImport()->GetParentToken(Header->EntryPointToken,&ptkParent);
    if (FAILED(hr)) {

        _ASSERTE(!"Unable to find ParentToken");
        return rv;
    }

    OBJECTREF o;
    if (ptkParent != COR_GLOBAL_PARENT_TOKEN) {
        EEClass* InitialClass;
        OBJECTREF Throwable = NULL;
        GCPROTECT_BEGIN(Throwable);

        NameHandle name;
        name.SetTypeToken(pModule, ptkParent);
        InitialClass = pAssembly->GetLoader()->LoadTypeHandle(&name, &Throwable).GetClass();
        if (!InitialClass)
            COMPlusThrow(Throwable);

        GCPROTECT_END();
        pMeth = InitialClass->FindMethod((mdMethodDef)Header->EntryPointToken);  
        o = COMMember::g_pInvokeUtil->GetMethodInfo(pMeth);
    }   
    else { 
        pMeth = pModule->FindFunction((mdToken)Header->EntryPointToken);
        o = COMMember::g_pInvokeUtil->GetGlobalMethodInfo(pMeth,pModule);
    }

    *((OBJECTREF*) &rv) = o;
    return rv;
}


// prepare saving manifest to disk
void __stdcall AssemblyNative::PrepareSavingManifest(PrepareSavingManifestArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    REFLECTMODULEBASEREF pReflect;

    ReflectionModule    *pModule = NULL;

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    pReflect = (REFLECTMODULEBASEREF) args->module;
    if (pReflect != NULL)
    {
        pModule = (ReflectionModule*) pReflect->GetData();
        _ASSERTE(pModule);
    }

    pAssembly->PrepareSavingManifest(pModule);
}


// add a file name to the file list of this assembly. On disk only.
mdFile __stdcall AssemblyNative::AddFileList(AddFileListArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    return pAssembly->AddFileList(args->strFileName->GetBuffer());
}


// set the hash value on a file.
void __stdcall AssemblyNative::SetHashValue(SetHashValueArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    _ASSERTE(args->strFullFileName != NULL);

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    return pAssembly->SetHashValue(args->tkFile, args->strFullFileName->GetBuffer());
}


// add a Type name to COMType table. On disk only.
mdExportedType __stdcall AssemblyNative::AddExportedType(AddExportedTypeArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    return pAssembly->AddExportedType(args->strCOMTypeName->GetBuffer(), args->ar, args->tkTypeDef, (CorTypeAttr)args->flags);
}


// add a Stand alone resource to ManifestResource table
void __stdcall AssemblyNative::AddStandAloneResource(AddStandAloneResourceArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    pAssembly->AddStandAloneResource(
        args->strName->GetBuffer(), 
        NULL,
        NULL,
        args->strFileName->GetBuffer(),
        args->strFullFileName->GetBuffer(),
        args->iAttribute); 
}


// Save security permission requests.
void __stdcall AssemblyNative::SavePermissionRequests(SavePermissionRequestsArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    pAssembly->SavePermissionRequests(args->required, args->optional, args->refused);
}


// save the manifest to disk!
void __stdcall AssemblyNative::SaveManifestToDisk(SaveManifestToDiskArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    // Make a copy of the file name, GC could move strManifestFileName
    CQuickBytes qb;
    LPWSTR      pwszFileName = (LPWSTR) qb.Alloc(
            (args->strManifestFileName->GetStringLength() + 1) * sizeof(WCHAR));

    memcpyNoGCRefs(pwszFileName, args->strManifestFileName->GetBuffer(),
            (args->strManifestFileName->GetStringLength() + 1) * sizeof(WCHAR));

    pAssembly->SaveManifestToDisk(pwszFileName, args->entrypoint, args->fileKind);
}


// Add a file entry into the in memory file list of this manifest
void __stdcall AssemblyNative::AddFileToInMemoryFileList(AddFileToInMemoryFileListArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    REFLECTMODULEBASEREF    pReflect;
    Module                  *pModule;
    pReflect = (REFLECTMODULEBASEREF) args->refModule;
    _ASSERTE(pReflect);

    pModule = (Module*) pReflect->GetData();
    _ASSERTE(pModule);
    
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    pAssembly->AddFileToInMemoryFileList(args->strModuleFileName->GetBuffer(), pModule);
}


LPVOID __stdcall AssemblyNative::GetStringizedName(NoArgs *args)
{
    LPVOID rv = NULL;
#ifdef FUSION_SUPPORTED

    THROWSCOMPLUSEXCEPTION();
    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    // If called by Object.ToString(), pAssembly may be NULL.
    if (!pAssembly)
        return NULL;

    LPCWSTR wsFullName;
    HRESULT hr;
    if (FAILED(hr = pAssembly->GetFullName(&wsFullName)))
        COMPlusThrowHR(hr);
    
    OBJECTREF pObj = (OBJECTREF) COMString::NewString(wsFullName);
    *((OBJECTREF*)(&rv)) = pObj;

#endif // FUSION_SUPPORTED
    return rv;
}


LPVOID __stdcall AssemblyNative::GetExecutingAssembly(GetExecutingAssemblyArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    LPVOID rv = NULL;
    Assembly *pAssembly = SystemDomain::GetCallersAssembly(args->stackMark);

    if(pAssembly)
        *((ASSEMBLYREF*) &rv) = (ASSEMBLYREF) pAssembly->GetExposedObject();
    return rv;
}


LPVOID __stdcall AssemblyNative::GetEntryAssembly(EmptyArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    LPVOID rv = NULL;
    BaseDomain *pDomain = SystemDomain::GetCurrentDomain();
    if (!(pDomain == SystemDomain::System())) {
        PEFile *pFile = ((AppDomain*) pDomain)->m_pRootFile;
        if(pFile) {

            Module *pModule = pDomain->FindModule(pFile->GetBase());
            _ASSERTE(pModule);
            *((ASSEMBLYREF*) &rv) = (ASSEMBLYREF) pModule->GetAssembly()->GetExposedObject();
        }
    }
    return rv;
}


LPVOID __stdcall AssemblyNative::CreateQualifiedName(CreateQualifiedNameArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    LPVOID rv = NULL;

    LPWSTR pTypeName = NULL;
    DWORD  dwTypeName = 0;
    LPWSTR pAssemblyName = NULL;
    DWORD  dwAssemblyName = 0;
    OBJECTREF pObj = NULL;
    CQuickBytes qb;
    
    if(args->strTypeName != NULL) {
        pTypeName = args->strTypeName->GetBuffer();
        dwTypeName = args->strTypeName->GetStringLength();
    }

    if(args->strAssemblyName != NULL) {
        pAssemblyName = args->strAssemblyName->GetBuffer();
        dwAssemblyName = args->strAssemblyName->GetStringLength();
    }

    DWORD length = dwTypeName + dwAssemblyName + ASSEMBLY_SEPARATOR_LEN + 1;
    LPWSTR result = (LPWSTR) qb.Alloc(length * sizeof(WCHAR));
    if(result == NULL) COMPlusThrowOM();

    if(ns::MakeAssemblyQualifiedName(result,
                                     length,
                                     pTypeName,
                                     dwTypeName,
                                     pAssemblyName,
                                     dwAssemblyName)) {
        pObj = (OBJECTREF) COMString::NewString(result);
        *((OBJECTREF*)(&rv)) = pObj;
    }

    return rv;
}


void __stdcall AssemblyNative::ForceResolve(NoArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    // We get the evidence so that even if security is off
    // we generate the evidence properly.
    Security::InitSecurity();
    pAssembly->GetSecurityDescriptor()->GetEvidence();
        
    pAssembly->GetSecurityDescriptor()->Resolve();
}


void __stdcall AssemblyNative::GetGrantSet(GetGrantSetArgs* args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);    
    AssemblySecurityDescriptor *pSecDesc = pAssembly->GetSecurityDescriptor();

    pSecDesc->Resolve();
    OBJECTREF granted = pSecDesc->GetGrantedPermissionSet(args->ppDenied);
    *(args->ppGranted) = granted;
}


// return the on disk assembly module for reflection emit. This only works for dynamic assembly.
LPVOID __stdcall AssemblyNative::GetOnDiskAssemblyModule(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly        *pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis); 
    ReflectionModule *mod;
    LPVOID          rv; 

    mod = pAssembly->GetOnDiskManifestModule();
    _ASSERTE(mod);

    // Assign the return value  
    *((OBJECTREF*) &rv) = (OBJECTREF) mod->GetExposedModuleBuilderObject();     
    return rv;
}


// return the in memory assembly module for reflection emit. This only works for dynamic assembly.
LPVOID __stdcall AssemblyNative::GetInMemoryAssemblyModule(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    Assembly         *pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);     
    Module *mod; 
    LPVOID          rv; 

    mod = pAssembly->GetSecurityModule();
    _ASSERTE(mod);

    // get the corresponding managed ModuleBuilder class
    *((OBJECTREF*) &rv) = (OBJECTREF) mod->GetExposedModuleBuilderObject();     
    return rv;  
} // LPVOID __stdcall AssemblyNative::GetInMemoryAssemblyModule()


// Create a stand-alone resource file for version resource.
LPVOID __stdcall AssemblyNative::DefineVersionInfoResource(DefineVersionInfoResourceArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT     hr;                     // A result.
    LPVOID      rv;                     // Return value.
    Win32Res    res;                    // Resource helper object.
    const void  *pvData=0;              // Pointer to the resource.
    ULONG       cbData;                 // Size of the resource data.
    ULONG       cbWritten;
    WCHAR       szFile[MAX_PATH+1];     // File name for resource file.
    WCHAR       szPath[MAX_PATH+1];     // Path name for resource file.
    HANDLE      hFile;                  // Handle to the temp file.
    OBJECTREF   pObj = NULL;

    // Create the resource string.
    res.SetInfo(
        args->strFilename->GetBufferNullable(), 
        args->strTitle->GetBufferNullable(), 
        args->strIconFilename->GetBufferNullable(), 
        args->strDescription->GetBufferNullable(), 
        args->strCopyright->GetBufferNullable(), 
        args->strTrademark->GetBufferNullable(),
        args->strCompany->GetBufferNullable(), 
        args->strProduct->GetBufferNullable(), 
        args->strProductVersion->GetBufferNullable(), 
        args->strFileVersion->GetBufferNullable(), 
        args->lcid,
        args->fIsDll);

    if (FAILED(hr = res.MakeResFile(&pvData, &cbData)))
        COMPlusThrowHR(hr);

    // Persist to a file.
    if (!WszGetTempPath(MAX_PATH, szPath))
        COMPlusThrowHR(HRESULT_FROM_WIN32(GetLastError()));
    if (!WszGetTempFileName(szPath, L"RES", 0, szFile))
        COMPlusThrowHR(HRESULT_FROM_WIN32(GetLastError()));

    if ((hFile=WszCreateFile(szFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL)) == INVALID_HANDLE_VALUE)
        COMPlusThrowHR(HRESULT_FROM_WIN32(GetLastError()));
    
    if (!WriteFile(hFile, pvData, cbData, &cbWritten, NULL))
        COMPlusThrowHR(HRESULT_FROM_WIN32(GetLastError()));
    
    if (!CloseHandle(hFile))
        COMPlusThrowHR(HRESULT_FROM_WIN32(GetLastError()));

    
    // Return name as a string.
    pObj = (OBJECTREF) COMString::NewString(szFile);        
    *((OBJECTREF*)(&rv)) = pObj;
    
    return rv;  
} // LPVOID __stdcall AssemblyNative::DefineVersionInfoResource()


// Get the GUID that will be used for an exported typelib.
LPVOID __stdcall AssemblyNative::GetExportedTypeLibGuid(NoArgs *args)
{
    HRESULT hr = S_OK;
    LPVOID rv = NULL;
    THROWSCOMPLUSEXCEPTION();

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    U1ARRAYREF pObj=NULL;
    GCPROTECT_BEGIN(pObj);
    
    pObj = (U1ARRAYREF)AllocatePrimitiveArray(ELEMENT_TYPE_U1, sizeof(GUID));  
    if(pObj == NULL) COMPlusThrowOM();
        
    GUID guid;
    IfFailThrow(GetTypeLibGuidForAssembly(pAssembly, &guid));

    memcpyNoGCRefs(pObj->m_Array, &guid, sizeof(GUID));
    
    *((OBJECTREF*)(&rv)) = pObj;
    GCPROTECT_END();

    return rv;
} // LPVOID __stdcall AssemblyNative::GetExportedTypeLibGuid()

INT32 __stdcall AssemblyNative::GlobalAssemblyCache(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();
    BOOL cache = FALSE;

    Assembly* pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);
    if(pAssembly->GetFusionAssembly()) {
        DWORD location;
        if(SUCCEEDED(pAssembly->GetFusionAssembly()->GetAssemblyLocation(&location)))
            if((location & ASMLOC_LOCATION_MASK) == ASMLOC_GAC)
                cache = TRUE;

    }
    return (INT32) cache;
}

LPVOID __stdcall AssemblyNative::GetImageRuntimeVersion(NoArgs *args)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr = S_OK;
    Assembly* pAssembly = NULL;
    PEFile* pPEFile = NULL;
    LPVOID pMetaData = NULL;
    LPCSTR pVersion = NULL;
    STRINGREF VersionString = NULL;
    LPVOID rv = NULL;

    // Retrieve the Assembly * from the managed assembly.
    pAssembly = ValidateThisRef((ASSEMBLYREF) args->refThis);

    // Retrieve the PEFile from the assembly.
    pPEFile = pAssembly->GetManifestFile();
    _ASSERTE(pPEFile);

    // Retrieve the metadata pointer from the PEFile.
    IfFailThrow(pPEFile->GetMetadataPtr(&pMetaData));
    
    // We can now extract the version of the runtime the assembly was built against
    // from the metadata header.
    IfFailThrow(GetImageRuntimeVersionString(pMetaData, &pVersion));

    // Allocate a managed string that contains the version and return it.
    VersionString = COMString::NewString(pVersion);
    *((STRINGREF*) &rv) = VersionString;
    return rv;
}

LPVOID __stdcall AssemblyNative::ParseTypeName(_ParseNameArgs *args)
{
    LPVOID rv = NULL;   
    THROWSCOMPLUSEXCEPTION();
    
    if(args == NULL || args->typeName == NULL)
        COMPlusThrow(kArgumentNullException, L"ArgumentNull_AssemblyName");

    DWORD           strLen = args->typeName->GetStringLength() + 1;
    LPUTF8          szFulltypeName = (LPUTF8)_alloca(strLen);
    CQuickBytes     bytes;
    DWORD           ctypeName;
    LPUTF8          szAssemblyName = NULL;
    PTRARRAYREF        ItemArray = NULL;

    // Get the class name in UTF8
    if (!COMString::TryConvertStringDataToUTF8(args->typeName, szFulltypeName, strLen))
        szFulltypeName = GetClassStringVars(args->typeName, &bytes, &ctypeName);

    GCPROTECT_BEGIN(ItemArray);
    ItemArray = (PTRARRAYREF) AllocateObjectArray(2, g_pStringClass);
    if (ItemArray == NULL) COMPlusThrowOM();

    LPUTF8          szNameSpaceSep;
    if(SUCCEEDED(FindAssemblyName(szFulltypeName,
                                  &szAssemblyName,
                                  &szNameSpaceSep))) {
        OBJECTREF o = (OBJECTREF) COMString::NewString(szFulltypeName);
        ItemArray->SetAt(1, o);
        if(szAssemblyName != NULL) {
            o = (OBJECTREF) COMString::NewString(szAssemblyName);
            ItemArray->SetAt(0, o);
        }
        *((PTRARRAYREF*) &rv) = ItemArray;
    }
    GCPROTECT_END();
    
    return rv;
}


HRESULT AssemblyNative::FindAssemblyName(LPUTF8 szFullTypeName,
                                         LPUTF8* pszAssemblyName,
                                         LPUTF8* pszNameSpaceSep)
{

    _ASSERTE(szFullTypeName);
    _ASSERTE(pszAssemblyName);
    _ASSERTE(pszNameSpaceSep);

    THROWSCOMPLUSEXCEPTION();

    BOOL errorInArrayDefinition = FALSE;
    char* assembly = szFullTypeName;
    *pszAssemblyName = NULL;
    *pszNameSpaceSep = NULL;

    // make sure every parameterized specification is skipped (i.e. int[*,*,*]) 
    BOOL normalize = FALSE;
    for (; *assembly; assembly++) {

        // break if a ',' - that is ASSEMBLY_SEPARATOR_CHAR - is encountered
        if (*assembly == ASSEMBLY_SEPARATOR_CHAR) {

            // "\," means that the comma is part of the original type name
            BOOL evenSlashes = TRUE;
            for (char *ptr=assembly;
                 (ptr != szFullTypeName) && (*(ptr-1) == BACKSLASH_CHAR);
                 ptr--)
                evenSlashes = !evenSlashes;

            // Even # of slashes means there is no slash for this comma
            if (evenSlashes) {

                *assembly = '\0'; // so we have the name of the class with no noise (assembly name) in szFullTypeName

                if (assembly - szFullTypeName >= MAX_CLASSNAME_LENGTH)
                    COMPlusThrow(kArgumentException, L"Argument_TypeNameTooLong");

                while (COMCharacter::nativeIsWhiteSpace(*(++assembly))); // assembly now points to the assembly name
                break;
            }
        }
        else if (*assembly == '[') {
            // "\[" means that the bracket is part of the original type name
            BOOL evenSlashes = TRUE;
            for (char *ptr=assembly;
                 (ptr != szFullTypeName) && (*(ptr-1) == BACKSLASH_CHAR);
                 ptr--)
                evenSlashes = !evenSlashes;

            // Even # of slashes means there is no slash for this bracket
            if (evenSlashes) {

                // array may contain ',' inside so skip to the closing array bracket
                for (;*assembly && *assembly != ']'; assembly++) {
                    if (*assembly == '*' || *assembly == '?')
                        normalize = TRUE;
                }
                if (!*assembly) { // array is malformed (no closing bracket)
                    errorInArrayDefinition = TRUE;
                    break;
                }
            }
        } 
        else if (*assembly == NAMESPACE_SEPARATOR_CHAR)
            *pszNameSpaceSep = assembly;
    }
    if (normalize) {
        // this function will change szFullTypeName, notice that it can only shrink it
        if (!NormalizeArrayTypeName(szFullTypeName, (*assembly) ? assembly - szFullTypeName - 1 : assembly - szFullTypeName))
            errorInArrayDefinition = TRUE;
    }

    if (!*szFullTypeName)
      COMPlusThrow(kArgumentException, L"Format_StringZeroLength");

    // No assembly info with the type name - check full length
    if ((!*assembly) &&
        (assembly - szFullTypeName >= MAX_CLASSNAME_LENGTH))
        COMPlusThrow(kArgumentException, L"Argument_TypeNameTooLong");

    if (errorInArrayDefinition) 
        COMPlusThrow(kArgumentException, L"Argument_InvalidArrayName");

    *pszAssemblyName = assembly;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblysink.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblySink.hpp
**
** Purpose: Asynchronous call back for loading classes
**
** Date:  June 23, 1999
**
===========================================================*/
#ifndef _ASSEMBLYSINK_H
#define _ASSEMBLYSINK_H


class BaseDomain;

class AssemblySink : public FusionSink
{
public:
    
    AssemblySink(AppDomain* pDomain) :
        m_Domain(pDomain->GetId())
    {}

    ULONG STDMETHODCALLTYPE Release(void);
    
    STDMETHODIMP OnProgress(DWORD dwNotification,
                            HRESULT hrNotification,
                            LPCWSTR szNotification,
                            DWORD dwProgress,
                            DWORD dwProgressMax,
                            IUnknown* punk)
    {
        return FusionSink::OnProgress(dwNotification,
                                      hrNotification,
                                      szNotification,
                                      dwProgress,
                                      dwProgressMax,
                                      punk);
    }


    virtual HRESULT Wait();
private:
    DWORD m_Domain; // Which domain (index) do I belong to
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblysink.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblySink.cpp
**
** Purpose: Implements AssemblySink, event objects that block 
**          the current thread waiting for an asynchronous load
**          of an assembly to succeed. 
**
** Date:  June 16, 1999
**
===========================================================*/

#include "common.h"

#include <stdlib.h>
#include "AssemblySink.h"

ULONG AssemblySink::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef) {
        Reset();
        AssemblySink* ret = this;
        // If we have a domain we keep a pool of one around. If we get an entry
        // back from the pool then we were not added to the pool and need to be deleted.
        // If we do not have a pool then we need to delete it.
        
        
        AppDomain* pDomain = NULL;

        Thread *pCurThread = GetThread();
        if(pCurThread == NULL) 
            pCurThread = SetupThread();

        BOOL toggleGC = !pCurThread->PreemptiveGCDisabled();
        if (toggleGC) 
            pCurThread->DisablePreemptiveGC();    
        
        if(m_Domain) {
            pDomain = SystemDomain::GetAppDomainAtId(m_Domain);
            if(pDomain) {
                ret = (AssemblySink*) FastInterlockCompareExchange((void**) &(pDomain->m_pAsyncPool),
                                                                   this,
                                                                   NULL);
            }
        }

        if (toggleGC)
            pCurThread->EnablePreemptiveGC();

        if(ret != NULL) 
            delete this;
    }
    return (cRef);
}

HRESULT AssemblySink::Wait()
{
    HRESULT hr = S_OK;
    DWORD   dwReturn = 0;

    Thread* pThread = GetThread();
    BOOL fWasGCDisabled = pThread->PreemptiveGCDisabled();
    if (fWasGCDisabled)
        pThread->EnablePreemptiveGC();

    // @TODO - LBS
    // I have kept a previous semantic to loop until WAIT_OBJECT_0.  We should
    // consider changing the loop to only continue while the dwReturn is WAIT_TIMEOUT.
    
    // Looping until we get a signal from fusion - which we are gaurenteed <sp> to get.
    // We do a WaitForMultipleObjects (STA and MTA) and pump messages in the STA case
    // in the call so we shouldn't freeze the system.
    do 
    {
        EE_TRY_FOR_FINALLY {
            dwReturn = pThread->DoAppropriateAptStateWait(1, &m_hEvent, FALSE, 100, TRUE);
        } EE_FINALLY {
            // If we get an exception then we will just release this sink. It may be the
            // case that the appdomain was terminated. Other exceptions will cause the
            // sink to be scavenged but this is ok. A new one will be generated for the
            // next bind.
            if(__GotException)
                m_Domain = 0;
        } EE_END_FINALLY;

    } while (dwReturn != WAIT_OBJECT_0);
    
    if (fWasGCDisabled)
        pThread->DisablePreemptiveGC();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblyspec.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header: AssemblySpec.cpp
**
** Purpose: Implements Assembly binding class
**
** Date:  May 5, 2000
**
===========================================================*/

#include "common.h"

#include <stdlib.h>

#include "AssemblySpec.hpp"
#include "Security.h"
#include "eeconfig.h"
#include "StrongName.h"
#include "AssemblySink.h"
#include "AssemblyFileHash.h"
#include "permset.h"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


HRESULT AssemblySpec::InitializeSpec(mdToken kAssemblyRef, IMDInternalImport *pImport, Assembly* pAssembly)
{
    HRESULT hr = S_OK;

    ULONG dwHashAlgorithm = 0;

    m_fParsed = TRUE;
    DWORD rid = RidFromToken(kAssemblyRef);
    if((rid == 0)||(rid > pImport->GetCountWithTokenKind(mdtAssemblyRef))) {
        BAD_FORMAT_ASSERT(!"AssemblyRef Token Out of Range");
        return COR_E_BADIMAGEFORMAT;
    }
    // Hash algorithm used to find this hash is saved in Assembly def
    pImport->GetAssemblyRefProps(kAssemblyRef,                          // [IN] The AssemblyRef for which to get the properties.        
                                 (const void**) &m_pbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.                        
                                 &m_cbPublicKeyOrToken,                 // [OUT] Count of bytes in the public key or token.                 
                                 &m_pAssemblyName,                      // [OUT] Buffer to fill with name.                              
                                 &m_context,                            // [OUT] Assembly MetaData.                                     
                                 NULL,        // [OUT] Hash blob.                                             
                                 NULL,                        // [OUT] Count of bytes in the hash blob.                       
                                 &m_dwFlags);                           // [OUT] Flags.          

    if ((!m_pAssemblyName) ||
        (*m_pAssemblyName == 0)) {
        BAD_FORMAT_ASSERT(!"NULL AssemblyRef Name");
        return COR_E_BADIMAGEFORMAT;
    }

    if((!m_pbPublicKeyOrToken) && (m_cbPublicKeyOrToken != 0)) {
        BAD_FORMAT_ASSERT(!"NULL Public Key or Token of AssemblyRef");
        return COR_E_BADIMAGEFORMAT;
    }


    // Let's get the CodeBase from the caller and use it as a hint
    if(pAssembly && (!pAssembly->IsShared()))
        m_CodeInfo.SetParentAssembly(pAssembly->GetFusionAssembly());

#if _DEBUG
    {
        // Test fusion conversion
        IAssemblyName *pFusionName;
        _ASSERTE(CreateFusionName(&pFusionName, TRUE) == S_OK);
        AssemblySpec testFusion;
        _ASSERTE(testFusion.InitializeSpec(pFusionName) == S_OK);
        pFusionName->Release();
    }
#endif

    return hr;
}

HRESULT AssemblySpec::InitializeSpec(IAssemblyName *pName, PEFile *pFile)
{
    _ASSERTE(pFile != NULL || pName != NULL);

    HRESULT hr = S_OK;
   
    //
    // Fill out info from name, if we have it.
    //

    if (pName != NULL)
    {
        hr = Init(pName);
    }
    else
    {
        #define MAKE_TRANSLATIONFAILED return E_INVALIDARG; 
        MAKE_UTF8PTR_FROMWIDE(pName, pFile->GetFileName());
        #undef MAKE_TRANSLATIONFAILED

        m_pAssemblyName = new char [strlen(pName) + 1];
        if (m_pAssemblyName == NULL)
            return E_OUTOFMEMORY;
        strcpy((char*)m_pAssemblyName, pName);
        m_ownedFlags |= NAME_OWNED;           
    }

    return hr;
}

HRESULT AssemblySpec::LowLevelLoadManifestFile(PEFile** ppFile,
                                               IAssembly** ppIAssembly,
                                               Assembly **ppDynamicAssembly,
                                               OBJECTREF* pExtraEvidence,
                                               OBJECTREF* pThrowable)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

#ifdef FUSION_SUPPORTED

    if( (!(m_pAssemblyName || m_CodeInfo.m_pszCodeBase)) ||
        (m_pAssemblyName && !(*m_pAssemblyName)) ||
        (m_CodeInfo.m_pszCodeBase && !(*m_CodeInfo.m_pszCodeBase)) ) {
        PostFileLoadException("", FALSE, NULL, COR_E_FILENOTFOUND, pThrowable);
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    //
    // Check to see if this fits our rather loose idea of a reference to mscorlib.
    // If so, don't use fusion to bind it - do it ourselves.
    //

    HRESULT hr = S_OK;
    if (IsMscorlib()) {
        _ASSERTE(wcslen(SystemDomain::System()->BaseLibrary()) > 0);
        hr = PEFile::Create(SystemDomain::System()->BaseLibrary(), 
                            NULL, 
                            mdFileNil, 
                            TRUE, 
                            NULL, 
                            NULL, // Code base is the same as the name
                            NULL, // Extra Evidence
                            ppFile);
        _ASSERTE((*ppFile)->IsSystem());
        if (ppDynamicAssembly) *ppDynamicAssembly = NULL;
        return hr;
    }

    Assembly *pAssembly = NULL;

    CQuickString FusionLog;
    FusionLog.String()[0] = L'\0';

    BEGIN_ENSURE_PREEMPTIVE_GC();

    PEFile *pFile = NULL;
    IAssemblyName* pFusionAssemblyName = NULL;     // Assembly object to assembly in fusion cache
    hr = CreateFusionName(&pFusionAssemblyName);
    if (FAILED(hr))
        goto exit;

    hr = pFusionAssemblyName->SetProperty(ASM_NAME_NULL_CUSTOM, NULL, 0); //do not look in ZAP
    if (FAILED(hr))
        goto exit;

    hr = GetAssemblyFromFusion(GetAppDomain(),
                               pFusionAssemblyName,
                               &m_CodeInfo,
                               ppIAssembly,
                               &pFile,
                               &FusionLog,
                               pExtraEvidence,
                               pThrowable);
    if(FAILED(hr)) {

        if (m_pAssemblyName &&
            ( (hr == FUSION_E_REF_DEF_MISMATCH) || (!Assembly::ModuleFound(hr)) )) {
            DWORD cb = 0;
            pFusionAssemblyName->GetDisplayName(NULL, &cb, 0);
            if(cb) {
                CQuickBytes qb;
                LPWSTR pwsFullName = (LPWSTR) qb.Alloc(cb*sizeof(WCHAR));
            
                if (SUCCEEDED(pFusionAssemblyName->GetDisplayName(pwsFullName, &cb, 0))) {
                    if ((pAssembly = GetAppDomain()->RaiseAssemblyResolveEvent(pwsFullName, pThrowable)) != NULL) {
                        pFile = pAssembly->GetManifestFile();
                        hr = S_FALSE;
                    }
                }
            }
        }

 #ifdef _DEBUG
        if(FAILED(hr)) {
            if (m_pAssemblyName)
                LOG((LF_CLASSLOADER, LL_ERROR, "Fusion could not load from full name, %s\n", m_pAssemblyName));
            else if (m_CodeInfo.m_pszCodeBase)
                LOG((LF_CLASSLOADER, LL_ERROR, "Fusion could not load from codebase, %s\n",m_CodeInfo.m_pszCodeBase));
            else
                LOG((LF_CLASSLOADER, LL_ERROR, "Fusion could not load unknown assembly.\n"));
        }
#endif //_DEBUG

    }

 exit:
    if (SUCCEEDED(hr)) {
        if (ppFile) *ppFile = pFile;
        if (ppDynamicAssembly) *ppDynamicAssembly = pAssembly;
    }

    if(pFusionAssemblyName)
        pFusionAssemblyName->Release();

    END_ENSURE_PREEMPTIVE_GC();

    if (FAILED(hr)) {
        if (m_pAssemblyName)
            PostFileLoadException(m_pAssemblyName, FALSE, FusionLog.String(), hr, pThrowable);
        else {
            #define MAKE_TRANSLATIONFAILED szName=""
            MAKE_UTF8PTR_FROMWIDE(szName, m_CodeInfo.m_pszCodeBase);
            #undef MAKE_TRANSLATIONFAILED
            PostFileLoadException(szName, TRUE, FusionLog.String(), hr, pThrowable);
        }
    }
#else // !FUSION_SUPPORTED
    HRESULT hr = E_NOTIMPL;
#endif // !FUSION_SUPPORTED
    return hr;
}


/*static*/
HRESULT AssemblySpec::DemandFileIOPermission(Assembly *pAssembly,
                                             IAssembly *pIAssembly,
                                             OBJECTREF* pThrowable)
{
    _ASSERTE(pAssembly || pIAssembly);

    // should have already checked permission if the codebase is set
    if (!m_CodeInfo.m_pszCodeBase) { 

        BOOL fCodeBaseAsm = FALSE;
        BOOL fWebPermAsm = FALSE;
        PEFile *pFile = NULL;
        HRESULT hr;

        if (pAssembly) {
            pFile = pAssembly->GetManifestFile();
            if (pFile) {
                fCodeBaseAsm = (!pFile->IsDisplayAsm());
                fWebPermAsm = pFile->IsWebPermAsm();
            }
        }
        else {
            DWORD eLocation;
            hr = pIAssembly->GetAssemblyLocation(&eLocation);
            if (FAILED(hr)) {
                if (hr == E_NOTIMPL) // process exe
                    return S_OK;
                else
                    return hr;
            }
            fCodeBaseAsm = (eLocation & ASMLOC_CODEBASE_HINT);
            fWebPermAsm = ((eLocation & ASMLOC_LOCATION_MASK) == ASMLOC_DOWNLOAD_CACHE);
        }

        if (fCodeBaseAsm) {
            DWORD dwDemand;
            LPWSTR pCheckLoc = NULL;
            BOOL fHavePath = TRUE;
            
            if (!pAssembly) {
                IAssemblyName *pNameDef;
                hr = pIAssembly->GetAssemblyNameDef(&pNameDef);
                if (SUCCEEDED(hr)) {
                    DWORD dwCodeBase = 0;
                    hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pCheckLoc, &dwCodeBase);
                    if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                        pCheckLoc = (WCHAR*) _alloca(dwCodeBase*sizeof(WCHAR));
                        hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pCheckLoc, &dwCodeBase);
                    }
                    pNameDef->Release();
                }

                if (FAILED(hr))
                    return hr;

                fHavePath = FALSE;
            }

            if (fWebPermAsm) {
                if (pAssembly)
                    IfFailRet(pAssembly->GetCodeBase(&pCheckLoc, NULL));
                dwDemand = FILE_WEBPERM;
                fHavePath = FALSE;
            }
            else {
                if (pAssembly)
                    pCheckLoc = (LPWSTR) pFile->GetFileName();
                dwDemand = FILE_READANDPATHDISC;
            }

            return DemandFileIOPermission(pCheckLoc,
                                          fHavePath,
                                          dwDemand,
                                          pThrowable);
        }
    }

    return S_OK;
}


HRESULT AssemblySpec::DemandFileIOPermission(LPCWSTR wszCodeBase,
                                             BOOL fHavePath,
                                             DWORD dwDemandFlag,
                                             OBJECTREF* pThrowable)
{
    _ASSERTE(wszCodeBase);

    HRESULT hr = S_OK;
    BEGIN_ENSURE_COOPERATIVE_GC();
        
    COMPLUS_TRY {
        Security::InitSecurity();

        MethodDesc *pMD = g_Mscorlib.GetMethod(METHOD__ASSEMBLY__DEMAND_PERMISSION);
        if (pMD == NULL) {
            _ASSERTE(!"Could not find Assembly.DemandPermission()");
            hr = E_FAIL;
        }
        else {
            STRINGREF codeBase = NULL;
            GCPROTECT_BEGIN(codeBase);
            
            codeBase = COMString::NewString(wszCodeBase);
            INT64 args[3] = {
                (INT64) dwDemandFlag,
                (INT64) fHavePath,
                ObjToInt64(codeBase)
            };
            pMD->Call(args, METHOD__ASSEMBLY__DEMAND_PERMISSION);
            GCPROTECT_END();
        }
    }
    COMPLUS_CATCH {
        OBJECTREF Throwable = GETTHROWABLE();
        hr = SecurityHelper::MapToHR(Throwable);
        if ((pThrowable != NULL) && (*pThrowable == NULL))
            *pThrowable = Throwable;

        LOG((LF_LOADER, 
             LL_INFO10, 
             "Failed security demand, %d, for path '%S'\n", 
             dwDemandFlag, wszCodeBase));

    } COMPLUS_END_CATCH
          
    END_ENSURE_COOPERATIVE_GC();
    
    return hr;
}

HRESULT AssemblySpec::GetAssemblyFromFusion(AppDomain* pAppDomain,
                                            IAssemblyName* pFusionAssemblyName,
                                            CodeBaseInfo* pCodeBase,
                                            IAssembly** ppFusionAssembly,
                                            PEFile** ppFile,
                                            CQuickString* pFusionLog,
                                            OBJECTREF* pExtraEvidence,
                                            OBJECTREF* pThrowable)
{
#ifdef FUSION_SUPPORTED
    _ASSERTE(ppFile);
    HRESULT hr = S_OK;
    IAssembly *pFusionAssembly = NULL;

    COMPLUS_TRY {
        DWORD dwSize = MAX_PATH;
        WCHAR szPath[MAX_PATH];
        WCHAR *pPath = &(szPath[0]);
        AssemblySink* pSink;
        DWORD eLocation = 0;
        DWORD dwDemand = FILE_PATHDISCOVERY;
        LPWSTR pwsCodeBase = NULL;
        DWORD  dwCodeBase = 0;
        IAssemblyName *pNameDef = NULL;
        
        IApplicationContext *pFusionContext = pAppDomain->GetFusionContext();
        pSink = pAppDomain->GetAssemblySink();
        if(!pSink)
            return E_OUTOFMEMORY;
        
        pSink->pFusionLog = pFusionLog;
        pSink->m_fProbed = FALSE;
        pSink->m_fAborted = FALSE;
        pSink->m_fCheckCodeBase = !pCodeBase->m_pszCodeBase;

        hr = FusionBind::GetAssemblyFromFusion(pFusionContext,
                                               pSink,
                                               pFusionAssemblyName,
                                               pCodeBase,
                                               &pFusionAssembly);
        pSink->pFusionLog = NULL;
        if(SUCCEEDED(hr)) {
            _ASSERTE(pFusionAssembly);

            // Get the path to the module containing the manifest
            hr = pFusionAssembly->GetManifestModulePath(pPath,
                                                        &dwSize);
            if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                pPath = (WCHAR*) _alloca(dwSize*sizeof(WCHAR));
            hr = pFusionAssembly->GetManifestModulePath(pPath,
                                                        &dwSize);
            if(SUCCEEDED(hr)) {
                hr = pFusionAssembly->GetAssemblyNameDef(&pNameDef);
                if (SUCCEEDED(hr)) {
                    hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pwsCodeBase, &dwCodeBase);
                    if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                        pwsCodeBase = (WCHAR*) _alloca(dwCodeBase*sizeof(WCHAR));
                        hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pwsCodeBase, &dwCodeBase);
                    }
                    pNameDef->Release();
                }
            }
            if(hr == S_OK && dwSize)
                // Note that if this returns E_NOTIMPL, it's the process exe
                hr = pFusionAssembly->GetAssemblyLocation(&eLocation);
        }

        // Check if there was a redirect or it was cached, using a codebase
        if (pSink->m_fAborted ||
            ((!pSink->m_fProbed) && (eLocation & ASMLOC_CODEBASE_HINT) &&
             pSink->m_fCheckCodeBase)) {
            LPWSTR pCheckPath;
            bool fHavePath = FALSE;

            if (pSink->m_fAborted) {
                if (_wcsnicmp(pSink->m_wszCodeBase.String(), L"file", 4))
                    dwDemand = FILE_WEBPERM; // web permission demand only
                else
                    dwDemand = FILE_READANDPATHDISC; // path discovery and read demands

                pCheckPath = pSink->m_wszCodeBase.String();
            }
            else if ((eLocation & ASMLOC_LOCATION_MASK) == ASMLOC_DOWNLOAD_CACHE) {
                if (FAILED(hr)) // failed to retrieve codebase
                    return hr;

                pCheckPath = pwsCodeBase;
                dwDemand = FILE_WEBPERM;
            }
            else {
                pCheckPath = pPath;
                fHavePath = TRUE;
                dwDemand = FILE_READANDPATHDISC;
            }

            HRESULT permHR;
            if (FAILED(permHR = DemandFileIOPermission(pCheckPath,
                                                       fHavePath,
                                                       dwDemand,
                                                       pThrowable))) {
                if(pFusionAssembly)
                    pFusionAssembly->Release();
                pSink->Release();
                return permHR;
            }
        }

        // If we aborted to do a permission demand, re-do the bind.
        if (pSink->m_fAborted) {
            pCodeBase->m_pszCodeBase = pSink->m_wszCodeBase.String();
            pSink->m_fCheckCodeBase = FALSE;

            hr = FusionBind::GetAssemblyFromFusion(pFusionContext,
                                                   pSink,
                                                   pFusionAssemblyName,
                                                   pCodeBase,
                                                   &pFusionAssembly);

            pCodeBase->m_pszCodeBase = NULL;

            if(SUCCEEDED(hr)) {
                _ASSERTE(pFusionAssembly);

                // Get the path to the module containing the manifest
                hr = pFusionAssembly->GetManifestModulePath(pPath,
                                                            &dwSize);
                if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                    pPath = (WCHAR*) _alloca(dwSize*sizeof(WCHAR));
                hr = pFusionAssembly->GetManifestModulePath(pPath,
                                                            &dwSize);

                if(SUCCEEDED(hr)) {
                    hr = pFusionAssembly->GetAssemblyNameDef(&pNameDef);
                    if (SUCCEEDED(hr)) {
                        hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pwsCodeBase, &dwCodeBase);
                        if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                            pwsCodeBase = (WCHAR*) _alloca(dwCodeBase*sizeof(WCHAR));
                            hr = pNameDef->GetProperty(ASM_NAME_CODEBASE_URL, pwsCodeBase, &dwCodeBase);
                        }
                        pNameDef->Release();
                    }
                }
                
                if(hr == S_OK && dwSize)
                    // Note that if this returns E_NOTIMPL, it's the process exe
                    hr = pFusionAssembly->GetAssemblyLocation(&eLocation);
            }
        }

        pSink->Release();

        if (SUCCEEDED(hr)) {
            if ((eLocation & ASMLOC_CODEBASE_HINT) &&
                (!pCodeBase->m_pszCodeBase) &&
                ((eLocation & ASMLOC_LOCATION_MASK) != ASMLOC_GAC) &&
                ((eLocation & ASMLOC_LOCATION_MASK) != ASMLOC_DOWNLOAD_CACHE))  {
                hr = DemandFileIOPermission(pPath,
                                            TRUE,
                                            FILE_READANDPATHDISC,
                                            pThrowable);
                if (FAILED(hr)) {
                    if (pFusionAssembly)
                        pFusionAssembly->Release();
                    return hr;
                }
            }

            switch ((eLocation & ASMLOC_LOCATION_MASK)) {
            case ASMLOC_GAC:
            case ASMLOC_DOWNLOAD_CACHE:
            case ASMLOC_UNKNOWN:
                // Assemblies from the GAC or download cache have
                // already been verified by Fusion. Location Unknown
                // indicates a load from the dev path, which we'll
                // assume isn't a interesting case for verification.
                hr = S_OK;
                break;
            case ASMLOC_RUN_FROM_SOURCE:                
                // For now, just verify these every time, we need to
                // cache the fact that at least one verification has
                // been performed (if strong name policy permits
                // caching of verification results
                if (StrongNameSignatureVerification(pPath,
                                                    SN_INFLAG_INSTALL|SN_INFLAG_ALL_ACCESS|SN_INFLAG_RUNTIME,
                                                    NULL))
                    hr = S_OK;
                else {
                    hr = StrongNameErrorInfo();
                    if (hr == CORSEC_E_MISSING_STRONGNAME)
                        hr = S_OK;
                    else
                        hr = CORSEC_E_INVALID_STRONGNAME;
                }
                break;
            default:
                _ASSERTE(FALSE);
            }
            if (SUCCEEDED(hr)) {
                hr = SystemDomain::LoadFile(pPath, 
                                            NULL, 
                                            mdFileNil, 
                                            FALSE, 
                                            pFusionAssembly, 
                                            pwsCodeBase,
                                            pExtraEvidence,
                                            ppFile,
                                            FALSE);
                if (SUCCEEDED(hr)) {
                    if(ppFusionAssembly) {
                        pFusionAssembly->AddRef();
                        *ppFusionAssembly = pFusionAssembly;
                    }
                    if (! (eLocation & ASMLOC_CODEBASE_HINT) )
                        (*ppFile)->SetDisplayAsm();
                    else if (dwDemand == FILE_WEBPERM)
                        (*ppFile)->SetWebPermAsm();

                    if((eLocation & ASMLOC_LOCATION_MASK) == ASMLOC_GAC)
                        // Assemblies in the GAC have also had any internal module
                        // hashes verified at install time.
                        (*ppFile)->SetHashesVerified();
                }
            }
        }
        else if (hr == E_NOTIMPL) {
            // process exe
            _ASSERTE(pAppDomain == SystemDomain::System()->DefaultDomain());
            hr = PEFile::Clone(SystemDomain::System()->DefaultDomain()->m_pRootFile, ppFile);
            if(SUCCEEDED(hr) && ppFusionAssembly) {
                pFusionAssembly->AddRef();
                *ppFusionAssembly = pFusionAssembly;
            }
        }
    }
    COMPLUS_CATCH {
        BEGIN_ENSURE_COOPERATIVE_GC();
        if (pThrowable) 
        {
            *pThrowable = GETTHROWABLE();
            hr = SecurityHelper::MapToHR(*pThrowable);
        }
        else
            hr = SecurityHelper::MapToHR(GETTHROWABLE());
        END_ENSURE_COOPERATIVE_GC();
    } COMPLUS_END_CATCH
 
    if (pFusionAssembly)
        pFusionAssembly->Release();

    return hr;
#else // !FUSION_SUPPORTED
    return E_NOTIMPL;
#endif // !FUSION_SUPPORTED
}

HRESULT AssemblySpec::LoadAssembly(Assembly** ppAssembly,
                                   OBJECTREF* pThrowable, /*= NULL*/
                                   OBJECTREF* pExtraEvidence, /*= NULL*/
                                   BOOL fPolicyLoad) /*= FALSE*/
{
#ifdef FUSION_SUPPORTED
    IAssembly* pIAssembly = NULL;

    HRESULT hr;
    Assembly *pAssembly = GetAppDomain()->FindCachedAssembly(this);
    if(pAssembly) {
        if ((pExtraEvidence != NULL) && (*pExtraEvidence != NULL))
            IfFailGo(SECURITY_E_INCOMPATIBLE_EVIDENCE);
        
        IfFailRet(DemandFileIOPermission(pAssembly, NULL, pThrowable));

        *ppAssembly = pAssembly;
        return S_FALSE;
    }

    PEFile *pFile;
    IfFailGo(GetAppDomain()->BindAssemblySpec(this, 
                                              &pFile, 
                                              &pIAssembly, 
                                              &pAssembly, 
                                              pExtraEvidence,
                                              pThrowable));

    if (m_pHashForControl.Size() > 0)
    {
        if(pFile)
        {
            AssemblyFileHash fileHash;
            hr = fileHash.SetFileName(pFile->GetFileName());
            if(SUCCEEDED(hr)) {
                hr = fileHash.GenerateDigest();
                if(SUCCEEDED(hr)) {
                    hr = fileHash.CalculateHash(m_dwHashAlg);
                    if(SUCCEEDED(hr)) {
                        PBYTE pbHash = fileHash.GetHash();
                        DWORD cbHash = fileHash.GetHashSize();
                        
                        PBYTE pbPassedHash = (PBYTE) m_pHashForControl.Ptr();
                        DWORD cbPassedHash = m_pHashForControl.Size();

                        if (cbHash != m_pHashForControl.Size() || 
                            memcmp(m_pHashForControl.Ptr(), pbHash, cbHash))
                            hr=FUSION_E_REF_DEF_MISMATCH;
                    }
                }
            }
            if(FAILED(hr)) 
                hr = FUSION_E_REF_DEF_MISMATCH;
        }
        else
            hr=FUSION_E_REF_DEF_MISMATCH;

        IfFailGo(hr);
    }


    // Loaded by AssemblyResolve event handler
    if (hr == S_FALSE) {

        //If loaded by the AssemblyResolve event, check that
        // the public keys are the same as in the AR.
        // However, if the found assembly is a dynamically
        // created one, security has decided to allow it.
        if (m_cbPublicKeyOrToken &&
            pAssembly->m_pManifestFile) {
                
            if (!pAssembly->m_cbPublicKey)
                IfFailGo(FUSION_E_PRIVATE_ASM_DISALLOWED);

            // Ref has the full key
            if (m_dwFlags & afPublicKey) {
                if ((m_cbPublicKeyOrToken != pAssembly->m_cbPublicKey) ||
                    memcmp(m_pbPublicKeyOrToken, pAssembly->m_pbPublicKey, m_cbPublicKeyOrToken))
                    IfFailGo(FUSION_E_REF_DEF_MISMATCH);
            }
            
            // Ref has a token
            else if (pAssembly->m_cbRefedPublicKeyToken) {
                if ((m_cbPublicKeyOrToken != pAssembly->m_cbRefedPublicKeyToken) ||
                    memcmp(m_pbPublicKeyOrToken,
                           pAssembly->m_pbRefedPublicKeyToken,
                           m_cbPublicKeyOrToken))
                    IfFailGo(FUSION_E_REF_DEF_MISMATCH);
            }
            else {
                if (!StrongNameTokenFromPublicKey(pAssembly->m_pbPublicKey,
                                                  pAssembly->m_cbPublicKey,
                                                  &pAssembly->m_pbRefedPublicKeyToken,
                                                  &pAssembly->m_cbRefedPublicKeyToken))
                    IfFailGo(StrongNameErrorInfo());
                
                if ((m_cbPublicKeyOrToken != pAssembly->m_cbRefedPublicKeyToken) ||
                    memcmp(m_pbPublicKeyOrToken,
                           pAssembly->m_pbRefedPublicKeyToken,
                           m_cbPublicKeyOrToken))
                    IfFailGo(FUSION_E_REF_DEF_MISMATCH);
            }
        }
        
        *ppAssembly = pAssembly;
        return S_OK;
    }


    // Until we can create multiple Assembly objects for a single HMODULE
    // we can only store one IAssembly* per Assembly. It is very important
    // to maintain the IAssembly* for an image that is in the load-context.
    // An Assembly in the load-from-context can bind to an assembly in the
    // load-context but not visa-versa. Therefore, if we every get an IAssembly
    // from the load-from-context we must make sure that it will never be 
    // found using a load. If it did then we could end up with Assembly dependencies
    // that are wrong. For example, if I do a LoadFrom() on an assembly in the GAC
    // and it requires another Assembly that I have preloaded in the load-from-context
    // then that dependency gets burnt into the Jitted code. Later on a Load() is
    // done on the assembly in the GAC and we single instance it back to the one
    // we have gotten from the load-from-context because the HMODULES are the same.
    // Now the dependency is wrong because it would not have the preloaded assembly
    // if the order was reversed.
    
    //@TODO: uncomment me when sure that fusion puts Load()'s with a LF parent
    // in the Load context, not the LF context
    //    if (pIAssembly && m_CodeInfo.m_dwCodeBase) {
    if (pIAssembly) {
        IFusionLoadContext *pLoadContext;
        hr = pIAssembly->GetFusionLoadContext(&pLoadContext);
        _ASSERTE(SUCCEEDED(hr));
        if (SUCCEEDED(hr)) {
            if (pLoadContext->GetContextType() == LOADCTX_TYPE_LOADFROM) {

                mdAssembly mda;
                IMDInternalImport *pMDImport = pFile->GetMDImport(&hr);
                if (FAILED(hr))
                    goto exit;
                
                if (FAILED(pMDImport->GetAssemblyFromScope(&mda))) {
                    hr = COR_E_ASSEMBLYEXPECTED;
                    goto exit;
                }

                LPCUTF8 psName;
                PBYTE pbPublicKey;
                DWORD cbPublicKey;
                AssemblyMetaDataInternal context;
                DWORD dwFlags;
                pFile->GetMDImport()->GetAssemblyProps(mda,
                                                       (const void**) &pbPublicKey,
                                                       &cbPublicKey,
                                                       NULL, // hash alg
                                                       &psName,
                                                       &context,
                                                       &dwFlags);
                
                AssemblySpec spec;
                if (FAILED(hr = spec.Init(psName, 
                                          &context, 
                                          pbPublicKey,
                                          cbPublicKey, 
                                          dwFlags)))
                    goto exit;
                    
                IAssemblyName* pFoundAssemblyName;
                if (FAILED(hr = spec.CreateFusionName(&pFoundAssemblyName, FALSE)))
                    goto exit;
                
                AssemblySink* pFoundSink = GetAppDomain()->GetAssemblySink();
                if(!pFoundSink) {
                    pFoundAssemblyName->Release();
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }
                    
                IAssembly *pFoundIAssembly;
                BEGIN_ENSURE_PREEMPTIVE_GC();
                hr = FusionBind::GetAssemblyFromFusion(GetAppDomain()->GetFusionContext(),
                                                       pFoundSink,
                                                       pFoundAssemblyName,
                                                       &spec.m_CodeInfo,
                                                       &pFoundIAssembly);

                if(SUCCEEDED(hr)) {
                    DWORD dwFoundSize = MAX_PATH;
                    WCHAR wszFoundPath[MAX_PATH];
                    // Get the path to the module containing the manifest
                    if (SUCCEEDED(pFoundIAssembly->GetManifestModulePath(wszFoundPath,
                                                                         &dwFoundSize))) {
                        
                        // Keep the default context's IAssembly if the paths are the same
                        if (!_wcsicmp(wszFoundPath, pFile->GetFileName())) {
                            pIAssembly->Release();
                            pIAssembly = pFoundIAssembly;

                            // Make sure the new IAssembly isn't holding its own refcount on 
                            // the file (we've just verified we're holding the same file.)
                            // Otherwise we will leak the handle when we unload the assembly,
                            // assuming fusion decides to cache this IAssembly pointer 
                            // somewhere internally.
                            PEFile::ReleaseFusionMetadataImport(pFoundIAssembly);

                        }
                        else
                            pFoundIAssembly->Release();
                    }
                }

                pFoundAssemblyName->Release();
                pFoundSink->Release();
                END_ENSURE_PREEMPTIVE_GC();
                hr = S_OK;
            }
        exit:
            pLoadContext->Release();
        }
    }
    

    // Create the assembly and delay loading the main module.
    Module* pModule;
    hr = GetAppDomain()->LoadAssembly(pFile, 
                                      pIAssembly, 
                                      &pModule, 
                                      &pAssembly,
                                      pExtraEvidence,
                                      NULL,
                                      fPolicyLoad,
                                      pThrowable);

    BEGIN_ENSURE_PREEMPTIVE_GC();
    if(SUCCEEDED(hr)) {
        *ppAssembly = pAssembly;
        /*HRESULT hrLoose =*/ GetAppDomain()->AddAssemblyToCache(this, pAssembly);
    }
    
    if(pIAssembly)
        pIAssembly->Release();
    END_ENSURE_PREEMPTIVE_GC();

 ErrExit:
    if (FAILED(hr) && (pThrowable!=NULL)) { 
        BEGIN_ENSURE_COOPERATIVE_GC();
        if ((pThrowable != RETURN_ON_ERROR) && (*pThrowable == NULL)) {
            if (m_pAssemblyName)
                PostFileLoadException(m_pAssemblyName, FALSE, NULL, hr, pThrowable);
            else {
                #define MAKE_TRANSLATIONFAILED szName=""
                MAKE_UTF8PTR_FROMWIDE(szName, m_CodeInfo.m_pszCodeBase);
                #undef MAKE_TRANSLATIONFAILED
                PostFileLoadException(szName, TRUE, NULL, hr, pThrowable);
            }
        }
        END_ENSURE_COOPERATIVE_GC();
    }

    return hr;
#else // !FUSION_SUPPORTED
    _ASSERTE(!"AssemblySpec::LoadAssembly() is NYI without Fusion");
    return E_NOTIMPL;
#endif // !FUSION_SUPPORTED
}

/*static*/
HRESULT AssemblySpec::LoadAssembly(LPCSTR pSimpleName, 
                                   AssemblyMetaDataInternal* pContext,
                                   PBYTE pbPublicKeyOrToken,
                                   DWORD cbPublicKeyOrToken,
                                   DWORD dwFlags,
                                   Assembly** ppAssembly,
                                   OBJECTREF* pThrowable/*=NULL*/)
{
    HRESULT hr = S_OK;

    AssemblySpec spec;
    hr = spec.Init(pSimpleName, pContext,
                   pbPublicKeyOrToken, cbPublicKeyOrToken, dwFlags);
    
    if (SUCCEEDED(hr))
        hr = spec.LoadAssembly(ppAssembly, pThrowable);

    return hr;
}

/*static*/
HRESULT AssemblySpec::LoadAssembly(LPCWSTR pFilePath, 
                                   Assembly **ppAssembly,
                                   OBJECTREF *pThrowable/*=NULL*/)
{
    AssemblySpec spec;
    spec.SetCodeBase(pFilePath, (DWORD) wcslen(pFilePath)+1);
    return spec.LoadAssembly(ppAssembly, pThrowable);
}

#define ENGLISH_LOCALE                                                      \
          (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_NEUTRAL), SORT_DEFAULT))
BOOL AssemblySpec::IsMscorlib()
{
    if (m_pAssemblyName == NULL) {
        LPCWSTR file = FusionBind::GetCodeBase()->m_pszCodeBase;
        if(file) {
            if(_wcsnicmp(L"file:///", file, 8) == 0)
                file += 8;
            else if(_wcsnicmp(L"file://", file, 7) == 0)
                file += 7;
            int lgth = (int) wcslen(file);
            if(lgth) {
                lgth++;
                LPWSTR newFile = (LPWSTR) _alloca(lgth*sizeof(WCHAR));
                WCHAR* p = newFile;
                WCHAR* s = (WCHAR*) file;
                while(*s) {
                    if(*s == L'/') {
                        *p++ = L'\\';
                        s++;
                    }
                    else 
                        *p++ = *s++;
                }
                *p = L'\0';
                return SystemDomain::System()->IsBaseLibrary(newFile);
            }
        }
        return FALSE;
    }

    size_t iNameLen = strlen(m_pAssemblyName);
    return ( (iNameLen >= 8) &&
             (!_strnicmp(m_pAssemblyName, g_psBaseLibraryName, 8)) &&
             ( (iNameLen == 8) || (m_pAssemblyName[8] == ',') ||
               (iNameLen >=12 && CompareStringA(ENGLISH_LOCALE, NORM_IGNORECASE, &m_pAssemblyName[8], 4, ".dll", 4) == CSTR_EQUAL) ) );
}

STDAPI PreBindAssembly(IApplicationContext *pAppCtx, IAssemblyName *pName,
                       IAssembly *pAsmParent, IAssemblyName **ppNamePostPolicy,
                       LPVOID pvReserved);

HRESULT AssemblySpec::PredictBinding(GUID *pmvid, BYTE *pbHash, DWORD *pcbHash)
{
#ifdef FUSION_SUPPORTED
    HRESULT hr = S_OK;
    IAssemblyName* pAssemblyName = NULL;
    IAssemblyName *pBoundName = NULL;

    if(!(m_pAssemblyName || m_CodeInfo.m_pszCodeBase))
        return S_FALSE;

    //
    // Check to see if this fits our rather loose idea of a reference to mscorlib.
    // If so, don't use fusion to bind it - do it ourselves.
    //

    if (IsMscorlib())
    {
        Assembly *pAssembly = SystemDomain::SystemAssembly();
        if (pAssembly == NULL)
            return S_FALSE;

        pAssembly->GetManifestImport()->GetScopeProps(NULL, pmvid);
        return pAssembly->GetManifestFile()->GetSNSigOrHash(pbHash, pcbHash);
    }

    BEGIN_ENSURE_PREEMPTIVE_GC();

    hr = CreateFusionName(&pAssemblyName);
    if (FAILED(hr))
        goto exit;

    IApplicationContext *pContext;
    hr = GetAppDomain()->CreateFusionContext(&pContext);
    if (FAILED(hr))
        goto exit;

    hr = PreBindAssembly(pContext, 
                         pAssemblyName,
                         NULL,  // should be pAsmParent
                         &pBoundName,
                         NULL);

    if (hr == S_OK)
    {
        // Get the MVID
        DWORD cbmvid = sizeof(*pmvid);
        VERIFY(SUCCEEDED(pBoundName->GetProperty(ASM_NAME_MVID, pmvid, &cbmvid)));
        _ASSERTE(cbmvid == sizeof(*pmvid));

        // Try and get the strong name hash
        // Ignore return, since always S_OK
        VERIFY(SUCCEEDED(pBoundName->GetProperty(ASM_NAME_SIGNATURE_BLOB, pbHash, pcbHash)));
    }
    else if (hr == S_FALSE)
    {
        hr = E_FAIL;
    }

 exit:

    if(pAssemblyName)
        pAssemblyName->Release();
    if(pBoundName)
        pBoundName->Release();

    END_ENSURE_PREEMPTIVE_GC();

#else // !FUSION_SUPPORTED
    HRESULT hr = E_NOTIMPL;
#endif // !FUSION_SUPPORTED

    return hr;
}

AssemblySpecBindingCache::AssemblySpecBindingCache(Crst *pCrst)
  : m_pool(sizeof(AssemblyBinding), 20, 20)
{
    LockOwner lock = {pCrst, IsOwnerOfCrst};
    // 2 below refers to g_rgPrimes[2] == 23
    m_map.Init(2, CompareSpecs, TRUE, &lock);
}

AssemblySpecBindingCache::~AssemblySpecBindingCache()
{
    MemoryPool::Iterator i(&m_pool);
    BOOL fRelease = SystemDomain::BeforeFusionShutdown();
    
    while (i.Next())
    {
        AssemblyBinding *b = (AssemblyBinding *) i.GetElement();
        
        b->spec.~AssemblySpec();
        if(fRelease && (b->pIAssembly != NULL))
            b->pIAssembly->Release();
        if (b->file != NULL)
            delete b->file;
    }
}

BOOL AssemblySpecBindingCache::Contains(AssemblySpec *pSpec)
{
    DWORD key = pSpec->Hash();

    AssemblyBinding *entry = (AssemblyBinding *) m_map.LookupValue(key, pSpec);

    return (entry != (AssemblyBinding *) INVALIDENTRY);
}

//
// Returns S_OK (or the assembly load error) if the spec was already in the table
//

HRESULT AssemblySpecBindingCache::Lookup(AssemblySpec *pSpec, 
                                         PEFile **ppFile,
                                         IAssembly** ppIAssembly,
                                         OBJECTREF *pThrowable)
{
    DWORD key = pSpec->Hash();

    AssemblyBinding *entry = (AssemblyBinding *) m_map.LookupValue(key, pSpec);

    if (entry == (AssemblyBinding *) INVALIDENTRY)
        return S_FALSE;
    else
    {
        if (ppFile) 
        {
            if (entry->file == NULL)
                *ppFile = NULL;
            else
                PEFile::Clone(entry->file, ppFile);
        }
        if (ppIAssembly) 
        {
            *ppIAssembly = entry->pIAssembly;
            if (*ppIAssembly != NULL)
                (*ppIAssembly)->AddRef();
        }
        if (pThrowable) 
        {
            if (entry->hThrowable == NULL)
                *pThrowable = NULL;
            else
                *pThrowable = ObjectFromHandle(entry->hThrowable);
        }

        return entry->hr;
    }
}

void AssemblySpecBindingCache::Store(AssemblySpec *pSpec, PEFile *pFile, IAssembly* pIAssembly, BOOL clone)
{
    DWORD key = pSpec->Hash();

    _ASSERTE(!Contains(pSpec));

    AssemblyBinding *entry = new (m_pool.AllocateElement()) AssemblyBinding;
    if (entry) {

        entry->spec.Init(pSpec);
        if (clone)
            entry->spec.CloneFields(entry->spec.ALL_OWNED);

        entry->file = pFile;
        entry->pIAssembly = pIAssembly;
        if(pIAssembly)
            entry->pIAssembly->AddRef();

        entry->hThrowable = NULL;
        entry->hr = S_OK;

        m_map.InsertValue(key, entry);
    }
}

void AssemblySpecBindingCache::Store(AssemblySpec *pSpec, HRESULT hr, OBJECTREF *pThrowable, BOOL clone)
{
    DWORD key = pSpec->Hash();

    _ASSERTE(!Contains(pSpec));
    _ASSERTE(FAILED(hr));

    AssemblyBinding *entry = new (m_pool.AllocateElement()) AssemblyBinding;

    if (entry) {
        entry->spec.Init(pSpec);
        if (clone)
            entry->spec.CloneFields(entry->spec.ALL_OWNED);
        
        entry->file = NULL;
        entry->pIAssembly = NULL;
        entry->hThrowable = pSpec->GetAppDomain()->CreateHandle(*pThrowable);
        entry->hr = hr;
        
        m_map.InsertValue(key, entry);
    }
}

/*static*/
BOOL DomainAssemblyCache::CompareBindingSpec(UPTR spec1, UPTR spec2)
{
    AssemblySpec* pSpec1 = (AssemblySpec*) (spec1 << 1);
    AssemblyEntry* pEntry2 = (AssemblyEntry*) spec2;

    return pSpec1->Compare(&pEntry2->spec);
}


DomainAssemblyCache::AssemblyEntry* DomainAssemblyCache::LookupEntry(AssemblySpec* pSpec)
{

    DWORD hashValue = pSpec->Hash();

    LPVOID pResult = m_Table.LookupValue(hashValue, pSpec);
    if(pResult == (LPVOID) INVALIDENTRY)
        return NULL;
    else
        return (AssemblyEntry*) pResult;
        
}

HRESULT DomainAssemblyCache::InsertEntry(AssemblySpec* pSpec, LPVOID pData1, LPVOID pData2)
{
    HRESULT hr = S_FALSE;
    LPVOID ptr = LookupEntry(pSpec);
    if(ptr == NULL) {
        m_pDomain->EnterCacheLock();

        __try {
            ptr = LookupEntry(pSpec);
            if(ptr == NULL) {
                hr = E_OUTOFMEMORY;
                AssemblyEntry* pEntry = (AssemblyEntry*) m_pDomain->GetLowFrequencyHeap()->AllocMem(sizeof(AssemblyEntry));
                if(pEntry) {
                    new (&pEntry->spec) AssemblySpec ();
                    hr = pEntry->spec.Init(pSpec, FALSE);
                    if (SUCCEEDED(hr)) {
                        // the ref is kept alive as long as the appdomain is alive in the assemblyspec. The Init call
                        // adds an extra addref which we can't easily clean up later because we don't keep the
                        // assemblyspec in the cache.
                        IAssembly *pa = pEntry->spec.GetCodeBase()->GetParentAssembly();
                        
                        if (pa != NULL)
                            pa->Release();
                                            
                        hr = pEntry->spec.CloneFieldsToLoaderHeap(AssemblySpec::ALL_OWNED, m_pDomain->GetLowFrequencyHeap());
                        if (hr == S_OK) {
                            pEntry->pData[0] = pData1;
                            pEntry->pData[1] = pData2;
                            DWORD hashValue = pEntry->Hash();
                            m_Table.InsertValue(hashValue, pEntry);
                        }
                    }
                }
            }
        }
        __finally {
            m_pDomain->LeaveCacheLock();
        }
    }
#ifdef _DEBUG
    else {
        _ASSERTE(pData1 == ((AssemblyEntry*) ptr)->pData[0]);
        _ASSERTE(pData2 == ((AssemblyEntry*) ptr)->pData[1]);
    }
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\binarysearchilmaps.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _BINARYSEARCHILMAP_H
#define _BINARYSEARCHILMAP_H

#include "UtilCode.h"
#include "..\debug\inc\DbgIPCEvents.h"

class CBinarySearchILMap : public CBinarySearch<UnorderedILMap>
{
public:
    CBinarySearchILMap(UnorderedILMap *pBase, int iCount) : 
        CBinarySearch<UnorderedILMap>(pBase, iCount)
    {
    }

    CBinarySearchILMap(void) : 
        CBinarySearch<UnorderedILMap>(NULL, 0)
    {
    }
        
    virtual int Compare( const UnorderedILMap *pFirst,
                         const UnorderedILMap *pSecond)
    {
        if (pFirst->mdMethod < pSecond->mdMethod)
            return -1;
        else if (pFirst->mdMethod == pSecond->mdMethod)
            return 0;
        else
            return 1;
    }


    void SetVariables(UnorderedILMap *pBase, int iCount)
    {
        m_pBase = pBase;
        m_iCount = iCount;
    }
} ;

#endif //_BINARYSEARCHILMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\assemblyspec.hpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
**
** Header:  AssemblySpec.hpp
**
** Purpose: Implements classes used to bind to assemblies
**
** Date:  May 7, 2000
**
===========================================================*/
#ifndef _ASSEMBLYSPEC_H
#define _ASSEMBLYSPEC_H
#include "FusionBind.h"
#include "hash.h"
#include "memorypool.h"
#include "fusion.h"

class AppDomain;
class Assembly;
class AssemblyNameNative;
class AssemblySpec : public FusionBind
{
  private:

    friend class AppDomain;


    AppDomain       *m_pAppDomain;
    CQuickBytes      m_pHashForControl;  
    DWORD            m_dwHashAlg;

    HRESULT LowLevelLoadManifestFile(PEFile **ppFile,
                                     IAssembly** ppIAssembly,
                                     Assembly **ppDynamicAssembly,
                                     OBJECTREF *pExtraEvidence,
                                     OBJECTREF *pThrowable);
  public:

    AssemblySpec()
      : m_pAppDomain(::GetAppDomain()) {}

    AssemblySpec(AppDomain *pAppDomain)
      : m_pAppDomain(pAppDomain) {}

    HRESULT InitializeSpec(mdToken kAssemblyRef, 
                           IMDInternalImport *pImport, 
                           Assembly* pAssembly);
    HRESULT InitializeSpec(IAssemblyName *pName, PEFile *pFile = NULL);


    // Make sure this matches in the managed Assembly.DemandPermission()
    enum FilePermFlag {
        FILE_PATHDISCOVERY   = 0x0,
        FILE_READ            = 0x1,
        FILE_READANDPATHDISC = 0x2,
        FILE_WEBPERM         = 0x3
    };
    static HRESULT DemandFileIOPermission(LPCWSTR wszCodeBase,
                                          BOOL fHavePath,
                                          DWORD dwDemandFlag,
                                          OBJECTREF* pThrowable);
    HRESULT DemandFileIOPermission(Assembly *pAssembly,
                                   IAssembly *pIAssembly,
                                   OBJECTREF* pThrowable);

    HRESULT LoadAssembly(Assembly **ppAssembly,
                         OBJECTREF *pThrowable = NULL,
                         OBJECTREF *pExtraEvidence = NULL,
                         BOOL fPolicyLoad = FALSE);

    HRESULT LoadAssembly(IApplicationContext *pFusionContext, 
                         PEFile** ppModule,
                         IAssembly** ppFusionAssembly);
    //****************************************************************************************
    //
    // Creates and loads an assembly based on the name and context.
    static HRESULT LoadAssembly(LPCSTR pSimpleName, 
                                AssemblyMetaDataInternal* pContext,
                                PBYTE pbPublicKeyOrToken,
                                DWORD cbPublicKeyOrToken,
                                DWORD dwFlags,
                                Assembly** ppAssembly,
                                OBJECTREF* pThrowable=NULL);

    // Load an assembly based on an explicit path
    static HRESULT LoadAssembly(LPCWSTR pFilePath, 
                                Assembly **ppAssembly, OBJECTREF *pThrowable = NULL);

    HRESULT GetAssemblyFromFusion(AppDomain *pAppDomain,
                                  IAssemblyName* pFusionAssemblyName,
                                  CodeBaseInfo* pCodeBase,
                                  IAssembly** ppFusionAssembly,
                                  PEFile** ppFile,
                                  CQuickString* pFusionLog,
                                  OBJECTREF* pExtraEvidence,
                                  OBJECTREF* pThrowable);  // Returns an IP to the assembly in the fusion cache
    
    // Encapsulates the logic to identify a spec to mscorlib
    BOOL IsMscorlib();

    // Returns a prediction of the strong name hash of the binding, if possible
    HRESULT PredictBinding(GUID *pmvid, BYTE *pbHash, DWORD *pcbHash);

    AppDomain *GetAppDomain() 
    { return m_pAppDomain; }

    HRESULT SetHashForControl(PBYTE pHashForControl, DWORD dwHashForControl, DWORD dwHashAlg)
    {
        m_pHashForControl.Alloc(dwHashForControl);
        if(dwHashForControl)
            memcpy(m_pHashForControl, pHashForControl,dwHashForControl);
        m_dwHashAlg=dwHashAlg; 
        return S_OK;
    };
};


class AssemblySpecHash
{
    MemoryPool m_pool;
    PtrHashMap m_map;

  public:

    AssemblySpecHash()
      : m_pool(sizeof(AssemblySpec), 20, 20)
    {
    
        //2 below indicates index into g_rgprimes[2] == 23
        m_map.Init(2, CompareSpecs, FALSE, NULL);
    }

    ~AssemblySpecHash()
    {
        MemoryPool::Iterator i(&m_pool);

        while (i.Next())
            ((AssemblySpec*)i.GetElement())->~AssemblySpec();
    }

    //
    // Returns TRUE if the spec was already in the table
    //

    BOOL Store(AssemblySpec *pSpec)
    {
        DWORD key = pSpec->Hash();

        AssemblySpec *entry = (AssemblySpec *) m_map.LookupValue(key, pSpec);

        if (entry == (AssemblySpec*) INVALIDENTRY)
        {
            entry = new (m_pool.AllocateElement()) AssemblySpec;
            if (!entry)
                return FALSE; //@TODO: should we be returning false for outofmem?

            entry->Init(pSpec);

            m_map.InsertValue(key, entry);

            return FALSE;
        }
        else
            return TRUE;
    }

    DWORD Hash(AssemblySpec *pSpec)
    {
        return pSpec->Hash();
    }

    static BOOL CompareSpecs(UPTR u1, UPTR u2)
    {
        AssemblySpec *a1 = (AssemblySpec *) (u1 << 1);
        AssemblySpec *a2 = (AssemblySpec *) u2;

        return a1->Compare(a2) != 0;
    }
};


class AssemblySpecBindingCache
{
    struct AssemblyBinding
    {
        AssemblySpec    spec;
        IAssembly       *pIAssembly;
        PEFile          *file;
        OBJECTHANDLE    hThrowable;
        HRESULT         hr;
    };

    MemoryPool m_pool;
    PtrHashMap m_map;

  public:

    AssemblySpecBindingCache(Crst *pCrst);
    ~AssemblySpecBindingCache();

    BOOL Contains(AssemblySpec *pSpec);

    //
    // Returns TRUE if the spec was already in the table
    //

    HRESULT Lookup(AssemblySpec *pSpec, 
                   PEFile **ppFile,
                   IAssembly** ppIAssembly,
                   OBJECTREF *pThrowable);

    void Store(AssemblySpec *pSpec, PEFile *pFile, IAssembly* pIAssembly, BOOL clone);
    void Store(AssemblySpec *pSpec, HRESULT hr, OBJECTREF *pThrowable, BOOL clone);

    DWORD Hash(AssemblySpec *pSpec)
    {
        return pSpec->Hash();
    }

    static BOOL CompareSpecs(UPTR u1, UPTR u2)
    {
        AssemblySpec *a1 = (AssemblySpec *) (u1 << 1);
        AssemblySpec *a2 = (AssemblySpec *) u2;

        return a1->Compare(a2) != 0;
    }
};

class DomainAssemblyCache
{
    struct AssemblyEntry {
        AssemblySpec spec;
        LPVOID       pData[2];     // Can be an Assembly, PEFile, or an Unmanaged DLL
        
        DWORD Hash()
        {
            return spec.Hash();
        }
    };
        
    PtrHashMap  m_Table;
    BaseDomain*  m_pDomain;

public:

    static BOOL CompareBindingSpec(UPTR spec1, UPTR spec2);

    void InitializeTable(BaseDomain* pDomain, Crst *pCrst)
    {
        _ASSERTE(pDomain);
        m_pDomain = pDomain;

        LockOwner lock = {pCrst, IsOwnerOfCrst};
        // 1 below indicates index into g_rgprimes[1] == 17
        m_Table.Init(1, &CompareBindingSpec, true, &lock);
    }
    
    AssemblyEntry* LookupEntry(AssemblySpec* pSpec);

    LPVOID  LookupEntry(AssemblySpec* pSpec, UINT index)
    {
        _ASSERTE(index < 2);
        AssemblyEntry* ptr = LookupEntry(pSpec);
        if(ptr == NULL)
            return NULL;
        else
            return ptr->pData[index];
    }

    // Returns S_OK if successfully added.
    //         S_FALSE if an entry alread existed
    //         E_OUTOFMEMORY if domains allocator could not find the space
    HRESULT InsertEntry(AssemblySpec* pSpec, LPVOID pData1, LPVOID pData2 = NULL);

private:

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cachelinealloc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
// CCacheLineAllocator
//
//      This file dImplements the CCacheLineAllocator class.
//
// @comm
//
//  Notes:
//      The CacheLineAllocator maintains a pool of free CacheLines
//      
//      The CacheLine Allocator provides static member functions 
//      GetCacheLine and FreeCacheLine,
//---------------------------------------------------------------------------


#include "common.h"
#include <stddef.h>
#include "cachelineAlloc.h"

#include "threads.h"
#include "excep.h"

///////////////////////////////////////////////////////
//    CCacheLineAllocator::CCacheLineAllocator()
//
//////////////////////////////////////////////////////

CCacheLineAllocator::CCacheLineAllocator()
{
    m_freeList32.Init();
    m_freeList64.Init();
    m_registryList.Init();
}

///////////////////////////////////////////////////////
//           void CCacheLineAllocator::~CCacheLineAllocator()
//
//////////////////////////////////////////////////////

CCacheLineAllocator::~CCacheLineAllocator()
{
    LPCacheLine tempPtr = NULL;
    while((tempPtr = m_registryList.RemoveHead()) != NULL)
    {
        for (int i =0; i < CacheLine::numEntries; i++)
        {
            if(tempPtr->m_pAddr[i] != NULL)
            {
                if (!g_fProcessDetach)
                    VFree(tempPtr->m_pAddr[i]);
            }
        }
        delete tempPtr;
    }
}



///////////////////////////////////////////////////////
// static void *CCacheLineAllocator::VAlloc(ULONG cbSize)
//
//////////////////////////////////////////////////////
 

void *CCacheLineAllocator::VAlloc(ULONG cbSize)
{
    // helper to call virtual free to release memory

    int i =0;
    void* pv = VirtualAlloc (NULL, cbSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    _ASSERTE (pv != NULL);
    if (pv != NULL)
    {
        LPCacheLine tempPtr = m_registryList.GetHead();
        if (tempPtr == NULL)
        {
            goto LNew;
        }

        for (i =0; i < CacheLine::numEntries; i++)
        {
            if(tempPtr->m_pAddr[i] == NULL)
            {
                tempPtr->m_pAddr[i] = pv;
                return pv;
            }
        }

LNew:
        // initialize the bucket before returning
        tempPtr = new CacheLine();
        if (tempPtr != NULL)
        {
            tempPtr->Init64();
            tempPtr->m_pAddr[0] = pv;
            m_registryList.InsertHead(tempPtr);
        }
        else
        {
            // couldn't find space to register this page
            _ASSERTE(0);
            VirtualFree(pv, 0, MEM_RELEASE);
            FailFast(GetThread(), FatalOutOfMemory);
            return NULL;
        }
    }
    else
    {
        FailFast(GetThread(), FatalOutOfMemory);
    }
    return pv;
}

///////////////////////////////////////////////////////
//   void CCacheLineAllocator::VFree(void* pv)
//
//////////////////////////////////////////////////////
 

void CCacheLineAllocator::VFree(void* pv)
{
    // helper to call virtual free to release memory

    BOOL bRes = VirtualFree (pv, 0, MEM_RELEASE);
    _ASSERTE (bRes);
}

///////////////////////////////////////////////////////
//           void *CCacheLineAllocator::GetCacheLine()
//
//////////////////////////////////////////////////////
 
//WARNING: must have a lock when calling this function 
void *CCacheLineAllocator::GetCacheLine64()
{
        LPCacheLine tempPtr = m_freeList64.RemoveHead();
        if (tempPtr != NULL)
        {
            // initialize the bucket before returning
            tempPtr->Init64();
            return tempPtr;
        }
        
#define AllocSize 4096*16

        ////////////////////////////////'
        /// Virtual Allocation for some more cache lines
    
        BYTE* ptr = (BYTE*)VAlloc(AllocSize);
        
        if(!ptr)
            return NULL;

        
        tempPtr = (LPCacheLine)ptr;
        // Link all the buckets 
        tempPtr = tempPtr+1;
        LPCacheLine maxPtr = (LPCacheLine)(ptr + AllocSize);

        while(tempPtr < maxPtr)
        {
            m_freeList64.InsertHead(tempPtr);
            tempPtr++;
        }

        // return the first block
        tempPtr = (LPCacheLine)ptr;
        tempPtr->Init64();
        return tempPtr;
}


///////////////////////////////////////////////////////
//   void *CCacheLineAllocator::GetCacheLine32()
//
//////////////////////////////////////////////////////
 
//WARNING: must have a lock when calling this function 
void *CCacheLineAllocator::GetCacheLine32()
{
    LPCacheLine tempPtr = m_freeList32.RemoveHead();
    if (tempPtr != NULL)
    {
        // initialize the bucket before returning
        tempPtr->Init32();
        return tempPtr;
    }
    tempPtr = (LPCacheLine)GetCacheLine64();
    if (tempPtr != NULL)
    {
        m_freeList32.InsertHead(tempPtr);
        tempPtr = (LPCacheLine)((BYTE *)tempPtr+32);
    }
    return tempPtr;
}
///////////////////////////////////////////////////////
//    void CCacheLineAllocator::FreeCacheLine64(void * tempPtr)
//
//////////////////////////////////////////////////////
//WARNING: must have a lock when calling this function 
void CCacheLineAllocator::FreeCacheLine64(void * tempPtr)
{
    _ASSERTE(tempPtr != NULL);
    LPCacheLine pCLine = (LPCacheLine )tempPtr;
    m_freeList64.InsertHead(pCLine);
}


///////////////////////////////////////////////////////
//    void CCacheLineAllocator::FreeCacheLine32(void * tempPtr)
//
//////////////////////////////////////////////////////
//WARNING: must have a lock when calling this function 
void CCacheLineAllocator::FreeCacheLine32(void * tempPtr)
{
    _ASSERTE(tempPtr != NULL);
    LPCacheLine pCLine = (LPCacheLine )tempPtr;
    m_freeList32.InsertHead(pCLine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\binder.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef _BINDERMODULE_H_
#define _BINDERMODULE_H_

class Module;
class MethodTable;
class MethodDesc;
class FieldDesc;

//
// Use the Binder objects to avoid doing unnecessary name lookup 
// (esp. in the prejit case) 
//
// E.g. g_Mscorlib.GetClass(CLASS__APP_DOMAIN);
// 

// BinderClassIDs are of the form CLASS__XXX

enum BinderClassID
{
    CLASS__NIL = 0,

    CLASS__MSCORLIB_NIL = CLASS__NIL,

#define DEFINE_CLASS(i,n,s)         CLASS__ ## i,
#include "mscorlib.h"

    CLASS__MSCORLIB_COUNT,
};


// BinderMethdoIDs are of the form METHOD__XXX__YYY, 
// where X is the class and Y is the method

enum BinderMethodID
{
    METHOD__NIL = 0,

    METHOD__MSCORLIB_NIL = METHOD__NIL,

#define DEFINE_METHOD(c,i,s,g)      METHOD__ ## c ## __ ## i,
#include "mscorlib.h"

    METHOD__MSCORLIB_COUNT,
};

// BinderFieldIDs are of the form FIELD__XXX__YYY, 
// where X is the class and Y is the field

enum BinderFieldID
{
    FIELD__NIL = 0,

    // Mscorlib:
    FIELD__MSCORLIB_NIL = FIELD__NIL,
    
#define DEFINE_FIELD(c,i,s,g)               FIELD__ ## c ## __ ## i,
#ifdef _DEBUG
#define DEFINE_FIELD_U(c,i,s,g,uc,uf)       FIELD__ ## c ## __ ## i,
#endif
#include "mscorlib.h"

    FIELD__MSCORLIB_COUNT,
};

enum BinderTypeID
{
    TYPE__NIL = 0,

    // Mscorlib:
    TYPE__MSCORLIB_NIL = TYPE__NIL,

    TYPE__BYTE_ARRAY,
    TYPE__OBJECT_ARRAY,
    TYPE__VARIANT_ARRAY,
    TYPE__VOID_PTR,

    TYPE__MSCORLIB_COUNT,
};


class Binder
{
  public:

    //
    // Retrieve tokens from ID
    // 

    mdTypeDef GetTypeDef(BinderClassID id);
    mdMethodDef GetMethodDef(BinderMethodID id);
    mdFieldDef GetFieldDef(BinderFieldID id);

    //
    // Normal calls retrieve structures from ID
    // and make sure proper class initialization
    // has occurred.
    //

    MethodTable *GetClass(BinderClassID id);
    MethodDesc *GetMethod(BinderMethodID id);
    FieldDesc *GetField(BinderFieldID id);
    TypeHandle GetType(BinderTypeID id);

    //
    // Retrieve structures from ID, but 
    // don't run the .cctor
    //

    MethodTable *FetchClass(BinderClassID id);
    MethodDesc *FetchMethod(BinderMethodID id);
    FieldDesc *FetchField(BinderFieldID id);
    TypeHandle FetchType(BinderTypeID id);

    //
    // Retrieve structures from ID, but 
    // only if they have been loaded already.
    // This methods ensure that no gc will happen
    //
    MethodTable *GetExistingClass(BinderClassID id)
    {
        return RawGetClass(id);
    }

    MethodDesc *GetExistingMethod(BinderMethodID id)
    {
        return RawGetMethod(id);
    }

    FieldDesc *GetExistingField(BinderFieldID id)
    {
        return RawGetField(id);
    }

    TypeHandle GetExistingType(BinderTypeID id)
    {
        return RawGetType(id);
    }

    //
    // Info about stuff
    //
    
    LPCUTF8 GetClassName(BinderClassID id)
    { 
        _ASSERTE(id != CLASS__NIL);
        _ASSERTE(id <= m_cClassRIDs);
        return m_classDescriptions[id-1].name;
    }

    BinderClassID GetMethodClass(BinderMethodID id)
    { 
        _ASSERTE(id != METHOD__NIL);
        _ASSERTE(id <= m_cMethodRIDs);
        return m_methodDescriptions[id-1].classID;
    }

    LPCUTF8 GetMethodName(BinderMethodID id)
    { 
        _ASSERTE(id != METHOD__NIL);
        _ASSERTE(id <= m_cMethodRIDs);
        return m_methodDescriptions[id-1].name;
    }

    LPHARDCODEDMETASIG GetMethodSig(BinderMethodID id)
    { 
        _ASSERTE(id != METHOD__NIL);
        _ASSERTE(id <= m_cMethodRIDs);
        return m_methodDescriptions[id-1].sig;
    }

    PCCOR_SIGNATURE GetMethodBinarySig(BinderMethodID id)
    { 
        _ASSERTE(id != METHOD__NIL);
        _ASSERTE(id <= m_cMethodRIDs);
        return m_methodDescriptions[id-1].sig->GetBinarySig();
    }

    BinderClassID GetFieldClass(BinderFieldID id)
    { 
        _ASSERTE(id != FIELD__NIL);
        _ASSERTE(id <= m_cFieldRIDs);
        return m_fieldDescriptions[id-1].classID;
    }

    LPCUTF8 GetFieldName(BinderFieldID id)
    { 
        _ASSERTE(id != FIELD__NIL);
        _ASSERTE(id <= m_cFieldRIDs);
        return m_fieldDescriptions[id-1].name;
    }

    LPHARDCODEDMETASIG GetFieldSig(BinderFieldID id)
    { 
        _ASSERTE(id != FIELD__NIL);
        _ASSERTE(id <= m_cFieldRIDs);
        return m_fieldDescriptions[id-1].sig;
    }

    //
    // Identity test - doesn't do unnecessary
    // class loading or initialization.
    //

    BOOL IsClass(MethodTable *pMT, BinderClassID id);
    BOOL IsType(TypeHandle th, BinderTypeID id);

    //
    // Offsets - these could conceivably be implemented
    // more efficiently than accessing the Desc info.
    // @PERF: keep a separate table of fields we only 
    // access the offset of.
    // 

    DWORD GetFieldOffset(BinderFieldID id);

    //
    // Utilities for exceptions
    //
    
    BOOL IsException(MethodTable *pMT, RuntimeExceptionKind kind);
    MethodTable *GetException(RuntimeExceptionKind kind);
    MethodTable *FetchException(RuntimeExceptionKind kind);

    //
    // Utilities for signature element types
    //

    BOOL IsElementType(MethodTable *pMT, CorElementType type);
    MethodTable *GetElementType(CorElementType type);
    MethodTable *FetchElementType(CorElementType type);

    //
    // Store the binding arrays to a prejit image
    // so we don't have to do name lookup at runtime
    //

    void BindAll();

    HRESULT Save(DataImage *image);
    HRESULT Fixup(DataImage *image);

    //
    // These are called by initialization code:
    //

    static void StartupMscorlib(Module *pModule);

#ifdef SHOULD_WE_CLEANUP
    static void Shutdown();
#endif /* SHOULD_WE_CLEANUP */

#ifdef _DEBUG
    static void CheckMscorlib();
#endif

  private:

    struct ClassDescription
    {
        const char *name;
    };

    struct MethodDescription
    {
        BinderClassID classID;
        LPCUTF8 name;
        LPHARDCODEDMETASIG sig;
    };

    struct FieldDescription
    {
        BinderClassID classID;
        LPCUTF8 name;
        LPHARDCODEDMETASIG sig;
    };

    struct TypeDescription
    {
        BinderClassID   classID;
        CorElementType  type;
        int             rank;
        const char *name;
    };

    // NOTE: No constructors/destructors - we have global instances!

    void Init(Module *pModule, 
              ClassDescription *pClassDescriptions,
              DWORD cClassDescriptions,
              MethodDescription *pMethodDescriptions,
              DWORD cMethodDescriptions,
              FieldDescription *pFieldDescriptions,
              DWORD cFieldDescriptions,
              TypeDescription *pTypeDescriptions,
              DWORD cTypeDescriptions);
    void Restore(ClassDescription *pClassDescriptions,
                 MethodDescription *pMethodDescriptions,
                 FieldDescription *pFieldDescriptions,
                 TypeDescription *pTypeDescriptions);
    void Destroy();

    static void CheckInit(MethodTable *pMT);
    static void InitClass(MethodTable *pMT);
    
    MethodTable *RawGetClass(BinderClassID id);
    MethodDesc *RawGetMethod(BinderMethodID id);
public: // use by EnCSyncBlockInfo::ResolveField
    FieldDesc *RawGetField(BinderFieldID id);
private:    
    TypeHandle RawGetType(BinderTypeID id);

    MethodTable *LookupClass(BinderClassID id, BOOL fLoad = TRUE);
    MethodDesc *LookupMethod(BinderMethodID id);
    FieldDesc *LookupField(BinderFieldID id);
    TypeHandle LookupType(BinderTypeID id, BOOL fLoad = TRUE);

    ClassDescription *m_classDescriptions;
    MethodDescription *m_methodDescriptions;
    FieldDescription *m_fieldDescriptions;
    TypeDescription *m_typeDescriptions;

    Module *m_pModule;

    USHORT m_cClassRIDs;
    USHORT *m_pClassRIDs;

    USHORT m_cFieldRIDs;
    USHORT *m_pFieldRIDs;

    USHORT m_cMethodRIDs;
    USHORT *m_pMethodRIDs;

    USHORT m_cTypeHandles;
    TypeHandle *m_pTypeHandles;

    static ClassDescription MscorlibClassDescriptions[];
    static MethodDescription MscorlibMethodDescriptions[];
    static FieldDescription MscorlibFieldDescriptions[];
    static TypeDescription MscorlibTypeDescriptions[];

#ifdef _DEBUG
  
    struct FieldOffsetCheck
    {
        BinderFieldID fieldID;
        USHORT expectedOffset;
    };

    struct ClassSizeCheck
    {
        BinderClassID classID;
        USHORT expectedSize;
    };

    static FieldOffsetCheck MscorlibFieldOffsets[];
    static ClassSizeCheck MscorlibClassSizes[];

#endif

    // @perf: have separate arrays
    // to map directly to offsets rather than descs?
};

//
// Global bound modules:
// 

extern Binder g_Mscorlib;

#endif _BINDERMODULE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\binder.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"

#include "binder.h"

#include "field.h"
#include "excep.h"

#include "message.h"
#include "comnumber.h"

void Binder::Init(Module *pModule,
                  ClassDescription *pClassDescriptions,
                  DWORD cClassDescriptions,
                  MethodDescription *pMethodDescriptions,
                  DWORD cMethodDescriptions,
                  FieldDescription *pFieldDescriptions,
                  DWORD cFieldDescriptions,
                  TypeDescription *pTypeDescriptions,
                  DWORD cTypeDescriptions)
{
    m_pModule = pModule;
    pModule->m_pBinder = this;

    m_classDescriptions = pClassDescriptions;
    m_methodDescriptions = pMethodDescriptions;
    m_fieldDescriptions = pFieldDescriptions;
    m_typeDescriptions = pTypeDescriptions;

    //
    // Initialize Class RID array
    //

    _ASSERTE(cClassDescriptions < USHRT_MAX);
    m_cClassRIDs = (USHORT) cClassDescriptions;
    m_pClassRIDs = new USHORT [m_cClassRIDs];
    ZeroMemory(m_pClassRIDs, m_cClassRIDs * sizeof(*m_pClassRIDs));

    //
    // Initialize Method RID array
    //

    _ASSERTE(cMethodDescriptions < USHRT_MAX);
    m_cMethodRIDs = (USHORT) cMethodDescriptions;
    m_pMethodRIDs = new USHORT [m_cMethodRIDs];
    ZeroMemory(m_pMethodRIDs, m_cMethodRIDs * sizeof(*m_pMethodRIDs));

    
    //
    // Initialize Field RID array
    //

    _ASSERTE(cFieldDescriptions < USHRT_MAX);
    m_cFieldRIDs = (USHORT) cFieldDescriptions;
    m_pFieldRIDs = new USHORT [m_cFieldRIDs];
    ZeroMemory(m_pFieldRIDs, m_cFieldRIDs * sizeof(*m_pFieldRIDs));

    //
    // Initialize TypeHandle array
    //

    _ASSERTE(cTypeDescriptions < USHRT_MAX);
    m_cTypeHandles = (USHORT) cTypeDescriptions;
    m_pTypeHandles = new TypeHandle [m_cTypeHandles];
    ZeroMemory(m_pTypeHandles, m_cTypeHandles * sizeof(*m_pTypeHandles));
}

void Binder::Destroy()
{
    if (m_pClassRIDs != NULL
        && !m_pModule->IsPreloadedObject(m_pClassRIDs))
        delete [] m_pClassRIDs;

    if (m_pMethodRIDs != NULL
        && !m_pModule->IsPreloadedObject(m_pMethodRIDs))
        delete [] m_pMethodRIDs;

    if (m_pFieldRIDs != NULL
        && !m_pModule->IsPreloadedObject(m_pFieldRIDs))
        delete [] m_pFieldRIDs;

    if (m_pTypeHandles != NULL)
        delete [] m_pTypeHandles;
}

void Binder::BindAll()
{
    for (BinderClassID cID = (BinderClassID) 1; cID <= m_cClassRIDs; cID = (BinderClassID) (cID + 1))
    {
        if (GetClassName(cID) != NULL) // Allow for CorSigElement entries with no classes
            FetchClass(cID);
    }

    for (BinderMethodID mID = (BinderMethodID) 1; mID <= m_cMethodRIDs; mID = (BinderMethodID) (mID + 1))
        FetchMethod(mID);

    for (BinderFieldID fID = (BinderFieldID) 1; fID <= m_cFieldRIDs; fID = (BinderFieldID) (fID + 1))
        FetchField(fID);
}

HRESULT Binder::Save(DataImage *image)
{
    HRESULT hr;

    IfFailRet(image->StoreStructure(this, sizeof(Binder),
                                    DataImage::SECTION_BINDER,
                                    DataImage::DESCRIPTION_MODULE));

    IfFailRet(image->StoreStructure(m_pClassRIDs, m_cClassRIDs * sizeof(*m_pClassRIDs),
                                    DataImage::SECTION_BINDER,
                                    DataImage::DESCRIPTION_MODULE,
                                    mdTypeDefNil));

    IfFailRet(image->StoreStructure(m_pMethodRIDs, m_cMethodRIDs * sizeof(*m_pMethodRIDs),
                                    DataImage::SECTION_BINDER,
                                    DataImage::DESCRIPTION_MODULE,
                                    mdMethodDefNil));

    IfFailRet(image->StoreStructure(m_pFieldRIDs, m_cFieldRIDs * sizeof(*m_pFieldRIDs),
                                    DataImage::SECTION_BINDER,
                                    DataImage::DESCRIPTION_MODULE,
                                    mdFieldDefNil));

    return S_OK;
}

HRESULT Binder::Fixup(DataImage *image)
{
    image->FixupPointerField(&m_pModule);

    image->FixupPointerField(&m_pClassRIDs);
    image->FixupPointerField(&m_pFieldRIDs);
    image->FixupPointerField(&m_pMethodRIDs);

    image->ZERO_FIELD(m_pTypeHandles);
    
    image->ZERO_FIELD(m_classDescriptions);
    image->ZERO_FIELD(m_methodDescriptions);
    image->ZERO_FIELD(m_fieldDescriptions);
    image->ZERO_FIELD(m_typeDescriptions);

    return S_OK;
}

void Binder::Restore(ClassDescription *classDescriptions,
                     MethodDescription *methodDescriptions,
                     FieldDescription *fieldDescriptions,
                     TypeDescription *typeDescriptions)
{
    m_classDescriptions = classDescriptions;
    m_methodDescriptions = methodDescriptions;
    m_fieldDescriptions = fieldDescriptions;
    m_typeDescriptions = typeDescriptions;

    m_pTypeHandles = new TypeHandle [m_cTypeHandles];
    ZeroMemory(m_pTypeHandles, m_cTypeHandles * sizeof(*m_pTypeHandles));
}

mdTypeDef Binder::GetTypeDef(BinderClassID id) 
{
    _ASSERTE(id != CLASS__NIL);
    _ASSERTE(id <= m_cClassRIDs);
    if (m_pClassRIDs[id-1] == 0)
        LookupClass(id);
    return TokenFromRid(m_pClassRIDs[id-1], mdtTypeDef);
}

mdMethodDef Binder::GetMethodDef(BinderMethodID id)
{
    _ASSERTE(id != METHOD__NIL);
    _ASSERTE(id <= m_cMethodRIDs);
    if (m_pMethodRIDs[id-1] == 0)
        LookupMethod(id);
    return TokenFromRid(m_pMethodRIDs[id-1], mdtMethodDef);
}

mdFieldDef Binder::GetFieldDef(BinderFieldID id)
{
    _ASSERTE(id != FIELD__NIL);
    _ASSERTE(id <= m_cFieldRIDs);
    if (m_pFieldRIDs[id-1] == 0)
        LookupField(id);
    return TokenFromRid(m_pFieldRIDs[id-1], mdtFieldDef);
}

//
// Raw retrieve structures from ID.  Use these when 
// you don't care about class Restore or .cctors.
//

MethodTable *Binder::RawGetClass(BinderClassID id)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != CLASS__NIL);
    _ASSERTE(id <= m_cClassRIDs);
    TypeHandle th = m_pModule->LookupTypeDef(TokenFromRid(m_pClassRIDs[id-1], mdtTypeDef));
    _ASSERTE(!th.IsNull());
    _ASSERTE(th.IsUnsharedMT());
    return th.AsMethodTable();
}

MethodDesc *Binder::RawGetMethod(BinderMethodID id)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != METHOD__NIL);
    _ASSERTE(id <= m_cMethodRIDs);
    MethodDescription *d = m_methodDescriptions + id - 1;
    MethodTable *pMT = RawGetClass(d->classID);
    _ASSERTE(pMT != NULL);
    MethodDesc *pMD = pMT->GetMethodDescForSlot(m_pMethodRIDs[id-1]-1);
    _ASSERTE(pMD != NULL);
    return pMD;
}

FieldDesc *Binder::RawGetField(BinderFieldID id)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != FIELD__NIL);
    _ASSERTE(id <= m_cFieldRIDs);
    FieldDescription *f = m_fieldDescriptions + id - 1;
    MethodTable *pMT = RawGetClass(f->classID);
    _ASSERTE(pMT != NULL);

    // Can't do this because the class may not be restored yet.
    // _ASSERTE(m_pFieldRIDs[id-1]-1 < (pMT->GetClass()->GetNumStaticFields() 
    //                                  + pMT->GetClass()->GetNumIntroducedInstanceFields()));

    FieldDesc *pFD = pMT->GetClass()->GetFieldDescListRaw() + m_pFieldRIDs[id-1]-1;
    _ASSERTE(pFD != NULL);
    return pFD;
}

TypeHandle Binder::RawGetType(BinderTypeID id)
{
    CANNOTTHROWCOMPLUSEXCEPTION();
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != TYPE__NIL);
    _ASSERTE(id <= m_cTypeHandles);
    TypeHandle th = m_pTypeHandles[id-1];
    _ASSERTE(!th.IsNull());
    return th;
}

//
// Inline function to check a class for init & restore
//

inline void Binder::CheckInit(MethodTable *pMT)
{
    if (!pMT->IsClassInited())
        InitClass(pMT);
}



//
// Fetch retrieve structures from ID - doesn't
// trigger class init
//

MethodTable *Binder::FetchClass(BinderClassID id)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(id != CLASS__NIL);
    _ASSERTE(id <= m_cClassRIDs);

    MethodTable *pMT;

    if (m_pClassRIDs[id-1] == 0)
        pMT = LookupClass(id);
    else
    {
        pMT = RawGetClass(id);
        pMT->CheckRestore();
    }

    return pMT;
}

MethodDesc *Binder::FetchMethod(BinderMethodID id)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(id != METHOD__NIL);
    _ASSERTE(id <= m_cMethodRIDs);

    MethodDesc *pMD;

    if (m_pMethodRIDs[id-1] == 0)
        pMD = LookupMethod(id);
    else
    {
        pMD = RawGetMethod(id);
        pMD->GetMethodTable()->CheckRestore();
    }

    // Initialize the sig here where it's safe.  (Otherwise it would typically happen
    // during a MethodDesc::Call.)
    m_methodDescriptions[id-1].sig->GetBinarySig();

    return pMD;
}

FieldDesc *Binder::FetchField(BinderFieldID id)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(id != FIELD__NIL);
    _ASSERTE(id <= m_cFieldRIDs);

    FieldDesc *pFD;

    if (m_pFieldRIDs[id-1] == 0)
        pFD = LookupField(id);
    else
    {
        pFD = RawGetField(id);
        pFD->GetMethodTableOfEnclosingClass()->CheckRestore();
    }

    return pFD;
}

TypeHandle Binder::FetchType(BinderTypeID id)
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(id != TYPE__NIL);
    _ASSERTE(id <= m_cTypeHandles);

    TypeHandle th = m_pTypeHandles[id-1];
    if (th.IsNull())
        th = LookupType(id);

    return th;
}

//
// Normal retrieve structures from ID
//

MethodTable *Binder::GetClass(BinderClassID id)
{
    THROWSCOMPLUSEXCEPTION();

    MethodTable *pMT = FetchClass(id);

    CheckInit(pMT);

    return pMT;
}

MethodDesc *Binder::GetMethod(BinderMethodID id)
{
    THROWSCOMPLUSEXCEPTION();

    MethodDesc *pMD = FetchMethod(id);

    CheckInit(pMD->GetMethodTable());

    return pMD;
}

FieldDesc *Binder::GetField(BinderFieldID id)
{
    THROWSCOMPLUSEXCEPTION();

    FieldDesc *pFD = FetchField(id);

    CheckInit(pFD->GetMethodTableOfEnclosingClass());

    return pFD;
}

TypeHandle Binder::GetType(BinderTypeID id)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle th = FetchType(id);

    return th;
}

//
// Offsets - these could conceivably be implemented
// more efficiently than accessing the Desc info.
// @PERF: keep a separate table of fields we only 
// access the offset of.
// 

DWORD Binder::GetFieldOffset(BinderFieldID id)
{ 
    return GetField(id)->GetOffset(); 
}

BOOL Binder::IsClass(MethodTable *pMT, BinderClassID id)
{
    if (m_pClassRIDs[id-1] == 0)
        return LookupClass(id, FALSE) == pMT;
    else
        return RawGetClass(id) == pMT;
}

BOOL Binder::IsType(TypeHandle th, BinderTypeID id)
{
    if (RawGetType(id) == th)
        return TRUE;
    if (!m_pTypeHandles[id-1].IsNull())
        return FALSE;
    else
        return LookupType(id, FALSE) == th;
}

void Binder::InitClass(MethodTable *pMT)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    if (!pMT->CheckRunClassInit(&throwable))
        COMPlusThrow(throwable);

    GCPROTECT_END();
}

MethodTable *Binder::LookupClass(BinderClassID id, BOOL fLoad)
{
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != CLASS__NIL);
    _ASSERTE(id <= m_cClassRIDs);

    MethodTable *pMT;

    ClassDescription *d = m_classDescriptions + id - 1;

    NameHandle nh(d->name);

    if (!fLoad)
    {
        nh.SetTokenNotToLoad(tdAllTypes);
        pMT = m_pModule->GetClassLoader()->FindTypeHandle(&nh).AsMethodTable();
        if (pMT == NULL)
            return NULL;
    }
    else
    {
        THROWSCOMPLUSEXCEPTION();

        BEGIN_ENSURE_COOPERATIVE_GC();
        OBJECTREF pThrowable = NULL;
        GCPROTECT_BEGIN(pThrowable);

        pMT = m_pModule->GetClassLoader()->FindTypeHandle(&nh, &pThrowable).AsMethodTable();
        if (pMT == NULL)
        {
            _ASSERTE(!"EE expects class to exist");
            COMPlusThrow(pThrowable);
        }
        GCPROTECT_END();
        END_ENSURE_COOPERATIVE_GC();
    }

    _ASSERTE(pMT->GetModule() == m_pModule);

    mdTypeDef td = pMT->GetClass()->GetCl();

    _ASSERTE(!IsNilToken(td));

    _ASSERTE(RidFromToken(td) <= USHRT_MAX);
    m_pClassRIDs[id-1] = (USHORT) RidFromToken(td);

    m_pModule->StoreTypeDef(td, pMT);

    return pMT;
}

MethodDesc *Binder::LookupMethod(BinderMethodID id)
{
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != METHOD__NIL);
    _ASSERTE(id <= m_cMethodRIDs);

    THROWSCOMPLUSEXCEPTION();

    MethodDescription *d = m_methodDescriptions + id - 1;

    MethodTable *pMT = FetchClass(d->classID);

    MethodDesc *pMD = pMT->GetClass()->FindMethod(d->name, d->sig);

    // @todo: should this be a real check & throw?
    _ASSERTE(pMD != NULL || !"EE expects method to exist");

    _ASSERTE(pMD->GetSlot()+1 <= USHRT_MAX);
    m_pMethodRIDs[id-1] = (USHORT) pMD->GetSlot()+1;

    // Go ahead and fill in the rid map since we're here anyway
    m_pModule->StoreMethodDef(pMD->GetMemberDef(), pMD);

    return pMD;
}

FieldDesc *Binder::LookupField(BinderFieldID id)
{
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != FIELD__NIL);
    _ASSERTE(id <= m_cFieldRIDs);

    THROWSCOMPLUSEXCEPTION();

    FieldDescription *d = m_fieldDescriptions + id - 1;

    MethodTable *pMT = FetchClass(d->classID);

    FieldDesc *pFD;

    pFD = pMT->GetClass()->FindField(d->name, d->sig);

    // @todo: should this be a real check & throw?
    _ASSERTE(pFD != NULL || !"EE expects field to exist");
    _ASSERTE(pFD - pMT->GetClass()->GetFieldDescListRaw() >= 0);
    _ASSERTE(pFD - pMT->GetClass()->GetFieldDescListRaw() < (pMT->GetClass()->GetNumStaticFields() 
                                                             + pMT->GetClass()->GetNumIntroducedInstanceFields()));
    _ASSERTE(pFD - pMT->GetClass()->GetFieldDescListRaw() + 1 < USHRT_MAX);

    USHORT index = (USHORT)(pFD - pMT->GetClass()->GetFieldDescListRaw());

    m_pFieldRIDs[id-1] = index+1;

    // Go ahead and fill in the rid map since we're here anyway
    m_pModule->StoreFieldDef(pFD->GetMemberDef(), pFD);

    return pFD;
}

TypeHandle Binder::LookupType(BinderTypeID id, BOOL fLoad)
{
    _ASSERTE(m_pModule != NULL);
    _ASSERTE(id != TYPE__NIL);
    _ASSERTE(id <= m_cTypeHandles);

    THROWSCOMPLUSEXCEPTION();

    TypeHandle th;

    TypeDescription *d = m_typeDescriptions + id - 1;

    OBJECTREF pThrowable = NULL;
    GCPROTECT_BEGIN(pThrowable);

    NameHandle nh(d->type, TypeHandle(GetClass(d->classID)), d->rank);
    if (!fLoad)
        nh.SetTokenNotToLoad(tdAllTypes);
    th = m_pModule->GetClassLoader()->FindTypeHandle(&nh, &pThrowable);

    GCPROTECT_END();

    if (th.IsNull())
    {
        if (fLoad)
            COMPlusThrow(pThrowable);
        return TypeHandle();
    }

    m_pTypeHandles[id-1] = th;

    return th;
}

BOOL Binder::IsException(MethodTable *pMT, RuntimeExceptionKind kind)
{
    return IsClass(pMT, (BinderClassID) (kind + CLASS__MSCORLIB_COUNT));
}

MethodTable *Binder::GetException(RuntimeExceptionKind kind)
{
    // @todo: handle throw case gracefully???

    return GetClass((BinderClassID) (kind + CLASS__MSCORLIB_COUNT));
}

MethodTable *Binder::FetchException(RuntimeExceptionKind kind)
{
    return FetchClass((BinderClassID) (kind + CLASS__MSCORLIB_COUNT));
}


BOOL Binder::IsElementType(MethodTable *pMT, CorElementType type)
{
    BinderClassID id = (BinderClassID) (type + CLASS__MSCORLIB_COUNT + kLastException);

    _ASSERTE(GetClassName(id) != NULL);

    return IsClass(pMT, id);
}

MethodTable *Binder::GetElementType(CorElementType type)
{
    BinderClassID id = (BinderClassID) (type + CLASS__MSCORLIB_COUNT + kLastException);

    _ASSERTE(GetClassName(id) != NULL);

    return GetClass(id);
}

MethodTable *Binder::FetchElementType(CorElementType type)
{
    BinderClassID id = (BinderClassID) (type + CLASS__MSCORLIB_COUNT + kLastException);

    _ASSERTE(GetClassName(id) != NULL);

    return FetchClass(id);
}


///////////////////////////////////////////////////////////////////////////////////
// Mscorlib:
///////////////////////////////////////////////////////////////////////////////////

Binder::ClassDescription Binder::MscorlibClassDescriptions[] = 
{
#define DEFINE_CLASS(i,n,s)         g_ ## n ## NS "." # s,
#include "mscorlib.h"
    
    // Include all exception types here

#define EXCEPTION_BEGIN_DEFINE(ns, reKind, hr) ns "." # reKind,
#define EXCEPTION_ADD_HR(hr)
#define EXCEPTION_END_DEFINE()
#include "rexcep.h"
#undef EXCEPTION_BEGIN_DEFINE
#undef EXCEPTION_ADD_HR
#undef EXCEPTION_END_DEFINE

    // Now include all signature types

#define TYPEINFO(e,c,s,g,ie,ia,ip,if,im,ial)    c,
#include "cortypeinfo.h"
#undef TYPEINFO

};

Binder::MethodDescription Binder::MscorlibMethodDescriptions[] = 
{
#define DEFINE_METHOD(c,i,s,g)          { CLASS__ ## c , # s, & gsig_ ## g },
#include "mscorlib.h"
};

// @TODO: pull offsets out into separate array???

Binder::FieldDescription Binder::MscorlibFieldDescriptions[] =
{
#define DEFINE_FIELD(c,i,s,g)           { CLASS__ ## c , # s, & gsig_Fld_ ## g },
#ifdef _DEBUG
#define DEFINE_FIELD_U(c,i,s,g,uc,uf)   { CLASS__ ## c , # s, & gsig_Fld_ ## g },
#endif
#include "mscorlib.h"
};

Binder::TypeDescription Binder::MscorlibTypeDescriptions[] = 
{
    { CLASS__BYTE,          ELEMENT_TYPE_SZARRAY,       1 },
    { CLASS__OBJECT,        ELEMENT_TYPE_SZARRAY,       1 },
    { CLASS__VARIANT,       ELEMENT_TYPE_SZARRAY,       1 },
    { CLASS__VOID,          ELEMENT_TYPE_PTR,           0 },
};

#ifdef _DEBUG

Binder::FieldOffsetCheck Binder::MscorlibFieldOffsets[] =
{
#define DEFINE_FIELD_U(c,i,s,g,uc,uf)  { FIELD__ ## c ## __ ## i, offsetof(uc, uf) },   
#include "mscorlib.h"
    (BinderFieldID) 0
};

Binder::ClassSizeCheck Binder::MscorlibClassSizes[] =
{
#define DEFINE_CLASS_U(i,n,s,uc)  { CLASS__ ## i, sizeof(uc) },   
#include "mscorlib.h"
    (BinderClassID) 0
};

void Binder::CheckMscorlib()
{
    FieldOffsetCheck     *pOffsets = MscorlibFieldOffsets;

    while (pOffsets->fieldID != FIELD__NIL)
    {
        FieldDesc *pFD = g_Mscorlib.FetchField(pOffsets->fieldID);
        DWORD offset = pFD->GetOffset();

        if (!pFD->GetMethodTableOfEnclosingClass()->IsValueClass())
            offset += sizeof(ObjHeader);

        _ASSERTE(offset == pOffsets->expectedOffset
                 && "Managed class field offset does not match unmanaged class field offset");
        pOffsets++;
    }

    ClassSizeCheck     *pSizes = MscorlibClassSizes;

    while (pSizes->classID != CLASS__NIL)
    {
        MethodTable *pMT = g_Mscorlib.FetchClass(pSizes->classID);
        DWORD size = pMT->GetBaseSize() - sizeof(ObjHeader);

        _ASSERTE(size == pSizes->expectedSize
                 && "Managed object size does not match unmanaged object size");
        pSizes++;
    }
}


#endif 

Binder g_Mscorlib;

void Binder::StartupMscorlib(Module *pModule)
{
    _ASSERTE(CLASS__MSCORLIB_COUNT < USHRT_MAX);
    _ASSERTE(METHOD__MSCORLIB_COUNT < USHRT_MAX);
    _ASSERTE(FIELD__MSCORLIB_COUNT < USHRT_MAX);
    _ASSERTE(TYPE__MSCORLIB_COUNT < USHRT_MAX);

    if (pModule->m_pBinder != NULL)
    {
        _ASSERTE(pModule->GetZapBase() != 0);

        //
        // Copy restored binder into known global
        //

        g_Mscorlib = *pModule->m_pBinder;
        pModule->m_pBinder = &g_Mscorlib;

        g_Mscorlib.Restore(MscorlibClassDescriptions,
                           MscorlibMethodDescriptions,
                           MscorlibFieldDescriptions,
                           MscorlibTypeDescriptions);
    }
    else
    {
        g_Mscorlib.Init(pModule,
                        MscorlibClassDescriptions,
                        sizeof(MscorlibClassDescriptions)/sizeof(*MscorlibClassDescriptions),
                        MscorlibMethodDescriptions,
                        sizeof(MscorlibMethodDescriptions)/sizeof(*MscorlibMethodDescriptions),
                        MscorlibFieldDescriptions,
                        sizeof(MscorlibFieldDescriptions)/sizeof(*MscorlibFieldDescriptions),
                        MscorlibTypeDescriptions,
                        sizeof(MscorlibTypeDescriptions)/sizeof(*MscorlibTypeDescriptions));
    }
}

#ifdef SHOULD_WE_CLEANUP
void Binder::Shutdown()
{
    g_Mscorlib.Destroy();
}
#endif /* SHOULD_WE_CLEANUP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ceeload.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEELOAD.CPP
// 

// CEELOAD reads in the PE file format using LoadLibrary
// ===========================================================================

#include "common.h"

#include "ceeload.h"
#include "hash.h"
#include "vars.hpp"
#include "ReflectClassWriter.h"
#include "method.hpp"
#include "stublink.h"
#include "security.h"
#include "cgensys.h"
#include "excep.h"
#include "ComClass.h"
#include "DbgInterface.h"
#include "NDirect.h"
#include "wsperf.h"
#include "icecap.h"
#include "EEProfInterfaces.h"
#include "PerfCounters.h"
#include "CorMap.hpp"
#include "EncEE.h"
#include "jitinterface.h"
#include "reflectutil.h"
#include "nexport.h"
#include "eeconfig.h"
#include "PEVerifier.h"
#include "nexport.h"
#include "utsem.h"
#include "jumptargettable.h"
#include "stdio.h"
#include "zapmonitor.h"
#include "perflog.h"
#include "Timeline.h"
#include "nlog.h"
#include "compile.h"


class IJWNOADThunk
{

#pragma pack(push,1)
    struct STUBLAYOUT
    {
#ifdef _X86_
        BYTE           m_movEAX;   //MOV EAX,imm32
        IJWNOADThunk  *m_uet;      // pointer to start of this structure
        BYTE           m_jmp;      //JMP NEAR32 (0xe9)
        const BYTE *   m_execstub; // pointer to MakeCall
#else
        int nyi;
#endif
    } m_code2;
#pragma pack(pop)
protected:
    static void __cdecl MakeCall();
    static void SafeNoModule();
    static void NoModule();

    BYTE*   m_pModulebase;
    BYTE*   m_pAssemblybase;
    DWORD   m_dwIndex;
    mdToken m_Token;
    DWORD   m_StartAD;
    LPCVOID m_StartADRetAddr;
    LPCVOID LookupInCache(AppDomain* pDomain);
    void AddToCache(AppDomain* pDomain,LPCVOID pRetAddr);

public:
    DWORD GetCachedAD()
    {
        return m_StartAD;
    };

    void SetCachedDest(LPCVOID pAddr)
    {
        m_StartADRetAddr=pAddr;
    }

    static IJWNOADThunk* FromCode(LPCBYTE pCodeAddr)
    {
        IJWNOADThunk* p=NULL;
        return (IJWNOADThunk*)(pCodeAddr+(LPBYTE(&(p->m_code2))-LPBYTE(p)));
    };
    mdToken GetToken()
    {
        return m_Token;
    }
    IJWNOADThunk(BYTE* pModulebase,BYTE* pAssemblybase, DWORD dwIndex,mdToken Token)
    {
        m_pModulebase=pModulebase;
        m_pAssemblybase=pAssemblybase;
        m_dwIndex=dwIndex;
        m_Token=Token;
        m_StartADRetAddr=NULL;
        m_StartAD=GetAppDomain()->GetId();
#ifdef _X86_
        m_code2.m_movEAX=0xb8; //mov eax
        m_code2.m_uet=this;
        m_code2.m_jmp=0xe9; 
        m_code2.m_execstub=(BYTE*) (((BYTE*)(MakeCall)) - (4+((BYTE*)&m_code2.m_execstub)));

        _ASSERTE(IsStub((const BYTE*) &m_code2));
#else
        _ASSERTE(!"@todo ia64");
#endif
    };

    // Checks if the addr is this type of stub by comparing content.
    // This works becaue we have a unique call to MakeCall.
    static bool IsStub(const BYTE * pAddr)
    {
#ifdef _X86_    
        // Note, we have to be careful. We don't know that this is a stub yet,
        // and so we don't want to access memory off the end of a page and AV.
        // To be safe, start at the front and keep working through the stub.
        // A stub won't end until we hit some sort of branch instruction (call/jmp),
        // so if we only look 1 instruction ahead at a time, we'll be safe.
        const STUBLAYOUT * pStub = (const STUBLAYOUT*) pAddr;

        if (pStub->m_movEAX != 0xb8)
            return false;

        if (pStub->m_uet != FromCode(pAddr))
            return false;

        if (pStub->m_jmp != 0xe9)
            return false;

        const BYTE * pTarget = (BYTE*) (((BYTE*)(MakeCall)) - (4+((BYTE*)&pStub->m_execstub)));
        if (pStub->m_execstub != pTarget)
            return false;

        return true;
#else
        _ASSERTE(!"@todo ia64 - port IsStub()");
#endif
    }
    
    LPCBYTE GetCode()
    {
        return (LPCBYTE)&m_code2;
    }
};



// -------------------------------------------------------
// Stub managed for IJWNOADThunk
// -------------------------------------------------------
IJWNOADThunkStubManager *IJWNOADThunkStubManager::g_pManager = NULL;

BOOL IJWNOADThunkStubManager::Init()
{
    _ASSERTE(g_pManager == NULL); // only add once
    g_pManager = new IJWNOADThunkStubManager();
    if (g_pManager == NULL)
        return FALSE;

    StubManager::AddStubManager(g_pManager);
    return TRUE;
}
#ifdef SHOULD_WE_CLEANUP
static void IJWNOADThunkStubManager::Uninit()
{
    delete g_pManager;
    g_pManager = NULL;
}
#endif /* SHOULD_WE_CLEANUP */

IJWNOADThunkStubManager::IJWNOADThunkStubManager() : StubManager() {}
IJWNOADThunkStubManager::~IJWNOADThunkStubManager() {}

// Check if it's a stub by looking at the content
BOOL IJWNOADThunkStubManager::CheckIsStub(const BYTE *stubStartAddress)
{
    return IJWNOADThunk::IsStub(stubStartAddress);
}



// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED





#define FORMAT_MESSAGE_LENGTH       1024
#define ERROR_LENGTH                512

HRESULT STDMETHODCALLTYPE CreateICeeGen(REFIID riid, void **pCeeGen);

//
// A hashtable for u->m thunks not represented in the fixup tables.
//
class UMThunkHash : public CClosedHashBase {
    private:
        //----------------------------------------------------
        // Hash key for CClosedHashBase
        //----------------------------------------------------
        struct UTHKey {
            LPVOID          m_pTarget;
            PCCOR_SIGNATURE m_pSig;
            DWORD           m_cSig;
        };

        //----------------------------------------------------
        // Hash entry for CClosedHashBase
        //----------------------------------------------------
        struct UTHEntry {
            UTHKey           m_key;
            ELEMENTSTATUS    m_status;
            UMEntryThunk     m_UMEntryThunk;
            UMThunkMarshInfo m_UMThunkMarshInfo;
        };

    public:
        UMThunkHash(Module *pModule, AppDomain *pDomain) :
            CClosedHashBase(
#ifdef _DEBUG
                             3,
#else
                            17,    // CClosedHashTable will grow as necessary
#endif                      

                            sizeof(UTHEntry),
                            FALSE
                            ),
            m_crst("UMThunkHash", CrstUMThunkHash)

        {
            m_pModule = pModule;
            m_dwAppDomainId = pDomain->GetId();
        }

        ~UMThunkHash()
        {
            UTHEntry *phe = (UTHEntry*)GetFirst();
            while (phe) {
                phe->m_UMEntryThunk.~UMEntryThunk();
                phe->m_UMThunkMarshInfo.~UMThunkMarshInfo();
                phe = (UTHEntry*)GetNext((BYTE*)phe);
            }
        }   



    public:
        LPVOID GetUMThunk(LPVOID pTarget, PCCOR_SIGNATURE pSig, DWORD cSig)
        {
            m_crst.Enter();
        
            UTHKey key;
            key.m_pTarget = pTarget;
            key.m_pSig    = pSig;
            key.m_cSig  = cSig;

            bool bNew;
            UTHEntry *phe = (UTHEntry*)FindOrAdd((LPVOID)&key, /*modifies*/bNew);
            if (phe)
            {
                if (bNew)
                {
                    phe->m_UMThunkMarshInfo.LoadTimeInit(pSig, 
                                                         cSig, 
                                                         m_pModule, 
                                                         !(MetaSig::GetCallingConventionInfo(m_pModule, pSig) & IMAGE_CEE_CS_CALLCONV_HASTHIS),
                                                         nltAnsi,
                                                         (CorPinvokeMap)0
                                                        );
                    phe->m_UMEntryThunk.LoadTimeInit((const BYTE *)pTarget, NULL, &(phe->m_UMThunkMarshInfo), NULL, m_dwAppDomainId);
                }
            }

            m_crst.Leave();
            return phe ? (LPVOID)(phe->m_UMEntryThunk.GetCode()) : NULL;
        }


        // *** OVERRIDES FOR CClosedHashBase ***/

        //*****************************************************************************
        // Hash is called with a pointer to an element in the table.  You must override
        // this method and provide a hash algorithm for your element type.
        //*****************************************************************************
            virtual unsigned long Hash(             // The key value.
                void const  *pData)                 // Raw data to hash.
            {
                UTHKey *pKey = (UTHKey*)pData;
                return (ULONG)(size_t)(pKey->m_pTarget);
            }


        //*****************************************************************************
        // Compare is used in the typical memcmp way, 0 is eqaulity, -1/1 indicate
        // direction of miscompare.  In this system everything is always equal or not.
        //*****************************************************************************
        unsigned long Compare(          // 0, -1, or 1.
                              void const  *pData,               // Raw key data on lookup.
                              BYTE        *pElement)            // The element to compare data against.
        {
            UTHKey *pkey1 = (UTHKey*)pData;
            UTHKey *pkey2 = &( ((UTHEntry*)pElement)->m_key );
        
            if (pkey1->m_pTarget != pkey2->m_pTarget)
            {
                return 1;
            }
            if (MetaSig::CompareMethodSigs(pkey1->m_pSig, pkey1->m_cSig, m_pModule, pkey2->m_pSig, pkey2->m_cSig, m_pModule))
            {
                return 1;
            }
            return 0;
        }

        //*****************************************************************************
        // Return true if the element is free to be used.
        //*****************************************************************************
            virtual ELEMENTSTATUS Status(           // The status of the entry.
                BYTE        *pElement)            // The element to check.
            {
                return ((UTHEntry*)pElement)->m_status;
            }

        //*****************************************************************************
        // Sets the status of the given element.
        //*****************************************************************************
            virtual void SetStatus(
                BYTE        *pElement,              // The element to set status for.
                ELEMENTSTATUS eStatus)            // New status.
            {
                ((UTHEntry*)pElement)->m_status = eStatus;
            }

        //*****************************************************************************
        // Returns the internal key value for an element.
        //*****************************************************************************
            virtual void *GetKey(                   // The data to hash on.
                BYTE        *pElement)            // The element to return data ptr for.
            {
                return (BYTE*) &(((UTHEntry*)pElement)->m_key);
            }



        Module      *m_pModule;
        DWORD        m_dwAppDomainId;
        Crst         m_crst;
};


#pragma pack(push, 1)
struct MUThunk
{
    VASigCookie     *m_pCookie;
    PCCOR_SIGNATURE  m_pSig;
    LPVOID           m_pTarget;
#ifdef _X86_
    LPVOID           GetCode()
    {
        return &m_op1;
    }

    BYTE             m_op1;     //0x58  POP   eax       ;;pop return address

    BYTE             m_op2;     //0x68  PUSH  cookie
    UINT32           m_opcookie;//         

    BYTE             m_op3;     //0x50  PUSH  eax       ;;repush return address

    BYTE             m_op4;     //0xb8  MOV   eax,target
    UINT32           m_optarget;//
    BYTE             m_jmp;     //0xe9  JMP   PInvokeCalliStub
    UINT32           m_jmptarg;
#else // !_X86_
    LPVOID           GetCode()
    {
        _ASSERTE(!"@todo ia64");
        return NULL;
    }
#endif // _X86_
};
#pragma pack(pop)


//
// A hashtable for u->m thunks not represented in the fixup tables.
//
class MUThunkHash : public CClosedHashBase {
    private:
        //----------------------------------------------------
        // Hash key for CClosedHashBase
        //----------------------------------------------------
        struct UTHKey {
            LPVOID          m_pTarget;
            PCCOR_SIGNATURE m_pSig;
            DWORD           m_cSig;
        };

        //----------------------------------------------------
        // Hash entry for CClosedHashBase
        //----------------------------------------------------
        struct UTHEntry {
            UTHKey           m_key;
            ELEMENTSTATUS    m_status;
            MUThunk          m_MUThunk;
        };

    public:
        MUThunkHash(Module *pModule) :
            CClosedHashBase(
#ifdef _DEBUG
                             3,
#else
                            17,    // CClosedHashTable will grow as necessary
#endif                      

                            sizeof(UTHEntry),
                            FALSE
                            ),
            m_crst("MUThunkHash", CrstMUThunkHash)

        {
            m_pModule = pModule;
        }

        ~MUThunkHash()
        {
            UTHEntry *phe = (UTHEntry*)GetFirst();
            while (phe) {
                delete (BYTE*)phe->m_MUThunk.m_pSig;
                phe = (UTHEntry*)GetNext((BYTE*)phe);
            }
        }   



    public:
        LPVOID GetMUThunk(LPVOID pTarget, PCCOR_SIGNATURE pSig0, DWORD cSig)
        {
            // forward decl defined in ndirect.cpp
            LPVOID GetEntryPointForPInvokeCalliStub();

            PCCOR_SIGNATURE pSig; // A persistant copy of the sig
            pSig = (PCCOR_SIGNATURE)(new BYTE[cSig]);

            memcpyNoGCRefs((BYTE*)pSig, pSig0, cSig);
            ((BYTE*)pSig)[0] = IMAGE_CEE_CS_CALLCONV_STDCALL; 

            // Have to lookup cookie eagerly because once we've added a blank
            // entry to the hashtable, it's not easy to tolerate failure.
            VASigCookie *pCookie = m_pModule->GetVASigCookie(pSig);
            if (!pCookie)
            {
                delete (BYTE*)pSig;
                return NULL;
            }   

            m_crst.Enter();
        
            UTHKey key;
            key.m_pTarget = pTarget;
            key.m_pSig    = pSig;
            key.m_cSig    = cSig;

            bool bNew;
            UTHEntry *phe = (UTHEntry*)FindOrAdd((LPVOID)&key, /*modifies*/bNew);
            if (phe)
            {
                if (bNew)
                {
                    phe->m_MUThunk.m_pCookie = pCookie;
                    phe->m_MUThunk.m_pSig    = pSig;
                    phe->m_MUThunk.m_pTarget = pTarget;
#ifdef _X86_
                    phe->m_MUThunk.m_op1      = 0x58;       //POP EAX
                    phe->m_MUThunk.m_op2      = 0x68;       //PUSH
                    phe->m_MUThunk.m_opcookie = (UINT32)(size_t)pCookie;
                    phe->m_MUThunk.m_op3      = 0x50;       //POP EAX
                    phe->m_MUThunk.m_op4      = 0xb8;       //mov eax
                    phe->m_MUThunk.m_optarget = (UINT32)(size_t)pTarget;
                    phe->m_MUThunk.m_jmp      = 0xe9;       //jmp
                    phe->m_MUThunk.m_jmptarg  = (UINT32)((size_t)GetEntryPointForPInvokeCalliStub() - ((size_t)( 1 + &(phe->m_MUThunk.m_jmptarg))));
#else
                    _ASSERTE(!"Non-X86 NYI");
#endif

                }
                else
                {
                    delete (BYTE*)pSig;
                }
            }
            else
            {
                delete (BYTE*)pSig;
            }

            m_crst.Leave();
            return phe ? (LPVOID)(phe->m_MUThunk.GetCode()) : NULL;
        }


        // *** OVERRIDES FOR CClosedHashBase ***/

        //*****************************************************************************
        // Hash is called with a pointer to an element in the table.  You must override
        // this method and provide a hash algorithm for your element type.
        //*****************************************************************************
            virtual unsigned long Hash(             // The key value.
                void const  *pData)                 // Raw data to hash.
            {
                UTHKey *pKey = (UTHKey*)pData;
                return (ULONG)(size_t)(pKey->m_pTarget);
            }


        //*****************************************************************************
        // Compare is used in the typical memcmp way, 0 is eqaulity, -1/1 indicate
        // direction of miscompare.  In this system everything is always equal or not.
        //*****************************************************************************
        unsigned long Compare(          // 0, -1, or 1.
                              void const  *pData,               // Raw key data on lookup.
                              BYTE        *pElement)            // The element to compare data against.
        {
            UTHKey *pkey1 = (UTHKey*)pData;
            UTHKey *pkey2 = &( ((UTHEntry*)pElement)->m_key );
        
            if (pkey1->m_pTarget != pkey2->m_pTarget)
            {
                return 1;
            }
            if (MetaSig::CompareMethodSigs(pkey1->m_pSig, pkey1->m_cSig, m_pModule, pkey2->m_pSig, pkey2->m_cSig, m_pModule))
            {
                return 1;
            }
            return 0;
        }

        //*****************************************************************************
        // Return true if the element is free to be used.
        //*****************************************************************************
            virtual ELEMENTSTATUS Status(           // The status of the entry.
                BYTE        *pElement)            // The element to check.
            {
                return ((UTHEntry*)pElement)->m_status;
            }

        //*****************************************************************************
        // Sets the status of the given element.
        //*****************************************************************************
            virtual void SetStatus(
                BYTE        *pElement,              // The element to set status for.
                ELEMENTSTATUS eStatus)            // New status.
            {
                ((UTHEntry*)pElement)->m_status = eStatus;
            }

        //*****************************************************************************
        // Returns the internal key value for an element.
        //*****************************************************************************
            virtual void *GetKey(                   // The data to hash on.
                BYTE        *pElement)            // The element to return data ptr for.
            {
                return (BYTE*) &(((UTHEntry*)pElement)->m_key);
            }



        Module      *m_pModule;
        Crst         m_crst;
};





// ===========================================================================
// Module
// ===========================================================================

//
// RuntimeInit initializes only fields which are not persisted in preload files
//

HRESULT Module::RuntimeInit()
{
#ifdef PROFILING_SUPPORTED
    // If profiling, then send the pModule event so load time may be measured.
    if (CORProfilerTrackModuleLoads())
        g_profControlBlock.pProfInterface->ModuleLoadStarted((ThreadID) GetThread(), (ModuleID) this);
#endif // PROFILING_SUPPORTED

    m_pCrst = new (&m_CrstInstance) Crst("ModuleCrst", CrstModule);

    m_pLookupTableCrst = new (&m_LookupTableCrstInstance) Crst("ModuleLookupTableCrst", CrstModuleLookupTable);

#ifdef PROFILING_SUPPORTED
    // Profiler enabled, and re-jits requested?
    if (CORProfilerAllowRejit())
    {
        m_dwFlags |= SUPPORTS_UPDATEABLE_METHODS;
    }
    else
#endif // PROFILING_SUPPORTED
    {
        m_dwFlags &= ~SUPPORTS_UPDATEABLE_METHODS;
    }

#ifdef _DEBUG
    m_fForceVerify = FALSE;
#endif

#if ZAP_RECORD_LOAD_ORDER
    m_loadOrderFile = INVALID_HANDLE_VALUE;
#endif

    return S_OK;
}

//
// Init initializes all fields of a Module
//

HRESULT Module::Init(BYTE *ilBaseAddress)
{
    m_ilBase                    = ilBaseAddress;
    m_zapFile                   = NULL;

    // This is now NULL'd in the module's constructor so it can be set
    // before Init is called
    // m_file                      = NULL;

    m_pMDImport                 = NULL;
    m_pEmitter                  = NULL;
    m_pImporter                 = NULL;
    m_pDispenser                = NULL;

    m_pDllMain                  = NULL;
    m_dwFlags                   = 0;
    m_pVASigCookieBlock         = NULL;
    m_pAssembly                 = NULL;
    m_moduleRef                 = mdFileNil;
    m_dwModuleIndex             = 0;
    m_pCrst                     = NULL;
#ifdef COMPRESSION_SUPPORTED
    m_pInstructionDecodingTable = NULL;
#endif
    m_pMethodTable              = NULL;
    m_pISymUnmanagedReader      = NULL;
    m_pNextModule               = NULL;
    m_dwBaseClassIndex          = 0;
    m_pPreloadRangeStart        = NULL;
    m_pPreloadRangeEnd          = NULL;
    m_pThunkTable               = NULL;
    m_pADThunkTable             = NULL;
    m_pADThunkTableDLSIndexForSharedClasses=0;
    m_ExposedModuleObject       = NULL;
    m_pLookupTableHeap          = NULL;
    m_pLookupTableCrst          = NULL;
    m_pThunkHeap                = NULL;
    
    m_pIStreamSym               = NULL;
    
    // Set up tables
    ZeroMemory(&m_TypeDefToMethodTableMap, sizeof(LookupMap));
    m_dwTypeDefMapBlockSize = 0;
    ZeroMemory(&m_TypeRefToMethodTableMap, sizeof(LookupMap));
    m_dwTypeRefMapBlockSize = 0;
    ZeroMemory(&m_MethodDefToDescMap, sizeof(LookupMap));
    m_dwMethodDefMapBlockSize = 0;
    ZeroMemory(&m_FieldDefToDescMap, sizeof(LookupMap));
    m_dwFieldDefMapBlockSize = 0;
    ZeroMemory(&m_MemberRefToDescMap, sizeof(LookupMap));
    m_dwMemberRefMapBlockSize = 0;
    ZeroMemory(&m_FileReferencesMap, sizeof(LookupMap));
    m_dwFileReferencesMapBlockSize = 0;
    ZeroMemory(&m_AssemblyReferencesMap, sizeof(LookupMap));
    m_dwAssemblyReferencesMapBlockSize = 0;

    m_pBinder                   = NULL;

    m_pJumpTargetTable          = NULL;
    m_pFixupBlobs               = NULL;
    m_cFixupBlobs               = 0;

    m_alternateRVAStaticBase    = 0;

#if ZAP_RECORD_LOAD_ORDER
    m_loadOrderFile             = INVALID_HANDLE_VALUE;
#endif

    m_compiledMethodRecord      = NULL;
    m_loadedClassRecord         = NULL;
    
    // Remaining inits
    return RuntimeInit();
}

HRESULT Module::Init(PEFile *pFile, PEFile *pZapFile, BOOL preload)
{
    HRESULT             hr;

    m_file = pFile;

    if (preload)
        IfFailRet(Module::RuntimeInit());
    else
        IfFailRet(Module::Init(pFile->GetBase()));

    m_zapFile = pZapFile;

    IMDInternalImport *pImport = NULL;
        pImport = pFile->GetMDImport(&hr);

    if (pImport == NULL) 
    {
        if (FAILED(hr))
            return hr;
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    }

    pImport->AddRef();
    SetMDImport(pImport);

    LOG((LF_CLASSLOADER, LL_INFO10, "Loaded pModule: \"%ws\".\n", GetFileName()));

    if (!preload)
        IfFailRet(AllocateMaps());

#ifdef COMPRESSION_SUPPORTED

    if (pCORHeader->Flags & COMIMAGE_FLAGS_COMPRESSIONDATA)
    {

        IMAGE_COR20_COMPRESSION_HEADER* compData =  
          (IMAGE_COR20_COMPRESSION_HEADER*) (base() + pCORHeader->CompressionData.VirtualAddress);  

        if (compData->CompressionType == COR_COMPRESS_MACROS && compData->Version == 0)
        {   
            m_pInstructionDecodingTable = InstructionDecoder::CreateInstructionDecodingTable(
             base() + pCORHeader->CompressionData.VirtualAddress  + IMAGE_COR20_COMPRESSION_HEADER_SIZE,
             pCORHeader->CompressionData.Size - IMAGE_COR20_COMPRESSION_HEADER_SIZE);
            if (m_pInstructionDecodingTable == NULL)
                return COR_E_OUTOFMEMORY;
        }   
        else {  
            _ASSERTE(!"Compression not supported");
            return E_FAIL;
        }
    }

#endif

#if ZAP_RECORD_LOAD_ORDER
    if (g_pConfig->RecordLoadOrder())
        OpenLoadOrderLogFile();
#endif

    return S_OK;
}

HRESULT Module::CreateResource(PEFile *file, Module **ppModule)
{
    Module *pModule = new (nothrow) Module();
    if (pModule == NULL)
        return E_OUTOFMEMORY;

    pModule->m_file = file;

    HRESULT hr;
    IfFailRet(pModule->Init(file->GetBase()));

    pModule->SetPEFile();
    pModule->SetResource();
    *ppModule = pModule;
    return S_OK;
}

HRESULT Module::Create(PEFile *file, Module **ppModule, BOOL isEnC)
{
    HRESULT hr = S_OK;

    IfFailRet(VerifyFile(file, FALSE));

    //
    // Enable the zap monitor if appropriate
    //

#if ZAPMONITOR_ENABLED
    if (g_pConfig->MonitorZapStartup() || g_pConfig->MonitorZapExecution()) 
    {
        // Don't make a monitor for an IJW file
        if (file->GetCORHeader()->VTableFixups.VirtualAddress == 0)
        {
            ZapMonitor *monitor = new ZapMonitor(file, file->GetMDImport());
            monitor->Reset();
        }
    }
#endif

    Module *pModule;

#ifdef EnC_SUPPORTED
    if (isEnC && !file->IsSystem())
        pModule = new EditAndContinueModule();
    else
#endif // EnC_SUPPORTED
        pModule = new Module();
    
    if (pModule == NULL)
        hr = E_OUTOFMEMORY;

    IfFailGo(pModule->Init(file, NULL, false));

    pModule->SetPEFile();


#ifdef EnC_SUPPORTED
    if (isEnC && !file->IsSystem())
    {
        pModule->SetEditAndContinue();
    }
#endif // EnC_SUPPORTED

    *ppModule = pModule;

ErrExit:
#ifdef PROFILING_SUPPORTED
    // When profiling, let the profiler know we're done.
    if (CORProfilerTrackModuleLoads())
        g_profControlBlock.pProfInterface->ModuleLoadFinished((ThreadID) GetThread(), (ModuleID) pModule, hr);
#endif // PROFILILNG_SUPPORTED

    return hr;
}

void Module::Unload()
{
    // Unload the EEClass*'s filled out in the TypeDefToEEClass map
    LookupMap *pMap;
    DWORD       dwMinIndex = 0;
    MethodTable *pMT;

    // Go through each linked block
    for (pMap = &m_TypeDefToMethodTableMap; pMap != NULL && pMap->pTable; pMap = pMap->pNext)
    {
        DWORD i;
        DWORD dwIterCount = pMap->dwMaxIndex - dwMinIndex;
        void **pRealTableStart = &pMap->pTable[dwMinIndex];
        
        for (i = 0; i < dwIterCount; i++)
        {
            pMT = (MethodTable *) (pRealTableStart[i]);
            
            if (pMT != NULL)
            {
                pMT->GetClass()->Unload();
            }
        }
        
        dwMinIndex = pMap->dwMaxIndex;
    }
}

void Module::UnlinkClasses(AppDomain *pDomain)
{
    // Unlink the EEClass*'s filled out in the TypeDefToEEClass map
    LookupMap *pMap;
    DWORD       dwMinIndex = 0;
    MethodTable *pMT;

    // Go through each linked block
    for (pMap = &m_TypeDefToMethodTableMap; pMap != NULL && pMap->pTable; pMap = pMap->pNext)
    {
        DWORD i;
        DWORD dwIterCount = pMap->dwMaxIndex - dwMinIndex;
        void **pRealTableStart = &pMap->pTable[dwMinIndex];
        
        for (i = 0; i < dwIterCount; i++)
        {
            pMT = (MethodTable *) (pRealTableStart[i]);
            
            if (pMT != NULL)
                pDomain->UnlinkClass(pMT->GetClass());
        }
        
        dwMinIndex = pMap->dwMaxIndex;
    }
}

//
// Destructor for Module
//

void Module::Destruct()
{
#ifdef PROFILING_SUPPORTED
    if (CORProfilerTrackModuleLoads())
        g_profControlBlock.pProfInterface->ModuleUnloadStarted((ThreadID) GetThread(), (ModuleID) this);
#endif // PROFILING_SUPPORTED

    LOG((LF_EEMEM, INFO3, 
         "Deleting module %x\n"
         "m_pLookupTableHeap:    %10d bytes\n",
         this,
         (m_pLookupTableHeap ? m_pLookupTableHeap->GetSize() : -1)));

    // Free classes in the class table
    FreeClassTables();

    g_pDebugInterface->DestructModule(this);

    // when destructing a module - close the scope
    ReleaseMDInterfaces();

    ReleaseISymUnmanagedReader();

    if (m_pISymUnmanagedReaderLock)
    {
        DeleteCriticalSection(m_pISymUnmanagedReaderLock);
        delete m_pISymUnmanagedReaderLock;
        m_pISymUnmanagedReaderLock = NULL;
    }

   // Clean up sig cookies
    VASigCookieBlock    *pVASigCookieBlock = m_pVASigCookieBlock;
    while (pVASigCookieBlock)
    {
        VASigCookieBlock    *pNext = pVASigCookieBlock->m_Next;

        for (UINT i = 0; i < pVASigCookieBlock->m_numcookies; i++)
            pVASigCookieBlock->m_cookies[i].Destruct();

        delete pVASigCookieBlock;

        pVASigCookieBlock = pNext;
    }

    delete m_pCrst;

#ifdef COMPRESSION_SUPPORTED
    if (m_pInstructionDecodingTable)
        InstructionDecoder::DestroyInstructionDecodingTable(m_pInstructionDecodingTable);
#endif

    if (m_pLookupTableHeap)
        delete m_pLookupTableHeap;

    delete m_pLookupTableCrst;

    delete m_pUMThunkHash;
    delete m_pMUThunkHash;
    delete m_pThunkHeap;

   if (m_pThunkTable)
        delete [] m_pThunkTable;

#ifdef PROFILING_SUPPORTED
    if (CORProfilerTrackModuleLoads())
        g_profControlBlock.pProfInterface->ModuleUnloadFinished((ThreadID) GetThread(), 
                                                                (ModuleID) this, S_OK);
#endif // PROFILING_SUPPORTED

    if (m_file)
        delete m_file;

    if (m_pFixupBlobs)
        delete [] m_pFixupBlobs;
    
    if (m_compiledMethodRecord)
        delete m_compiledMethodRecord;

    if (m_loadedClassRecord)
        delete m_loadedClassRecord;

    //
    // Warning - deleting the zap file will cause the module to be unmapped
    //
    IStream *pStream = GetInMemorySymbolStream();
    if(pStream != NULL)
    {
        pStream->Release();
        SetInMemorySymbolStream(NULL);
    }

    if (IsPrecompile())
    {
        //
        // Remove our code from the code manager
        //

        CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
          (GetZapBase()+ GetZapCORHeader()->ManagedNativeHeader.VirtualAddress);
        CORCOMPILE_CODE_MANAGER_ENTRY *codeMgr = (CORCOMPILE_CODE_MANAGER_ENTRY *) 
          (GetZapBase() + pZapHeader->CodeManagerTable.VirtualAddress);

        ExecutionManager::DeleteRange((LPVOID) (codeMgr->Code.VirtualAddress + GetZapBase()));
    }

    if (IsPreload())
    {
        if (m_zapFile)
            delete m_zapFile;
    }
    else
    {
        if (m_pJumpTargetTable)
            delete [] m_pJumpTargetTable;
        if (m_zapFile)
            delete m_zapFile;

        delete this;
    }
}

HRESULT Module::VerifyFile(PEFile *file, BOOL fZap)
{
    HRESULT hr;
    IMAGE_COR20_HEADER *pCORHeader = file->GetCORHeader();

    // If the file is COM+ 1.0, which by definition has nothing the runtime can
    // use, or if the file requires a newer version of this engine than us,
    // it cannot be run by this engine.

    if (pCORHeader == NULL
        || pCORHeader->MajorRuntimeVersion == 1
        || pCORHeader->MajorRuntimeVersion > COR_VERSION_MAJOR)
    {
        return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    }

    //verify that COM+ specific parts of the PE file are valid
    IfFailRet(file->VerifyDirectory(&pCORHeader->MetaData,IMAGE_SCN_MEM_WRITE));
    IfFailRet(file->VerifyDirectory(&pCORHeader->CodeManagerTable,IMAGE_SCN_MEM_WRITE));
#ifdef COMPRESSION_SUPPORTED
    IfFailRet(file->VerifyDirectory(&pCORHeader->CompressionData,IMAGE_SCN_MEM_WRITE));
#endif
    IfFailRet(file->VerifyDirectory(&pCORHeader->VTableFixups,0));

    IfFailRet(file->VerifyDirectory(&pCORHeader->Resources,IMAGE_SCN_MEM_WRITE));

    // Don't do this.  If set, the VA is only guaranteed to be a
    // valid, loaded RVA if this file contains a standalone manifest.
    // Non-standalone manifest files will have the VA set, but the
    // manifest is not in an NTSection, so verifyDirectory() will fail.
    // IfFailRet(file->VerifyDirectory(m_pcorheader->Manifest,0));

    IfFailRet(file->VerifyFlags(pCORHeader->Flags, fZap));
    if (fZap)
    {
        CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
          (file->GetBase() + pCORHeader->ManagedNativeHeader.VirtualAddress);
        if (pCORHeader->ManagedNativeHeader.Size < sizeof(CORCOMPILE_HEADER))
            return HRESULT_FROM_WIN32(ERROR_BAD_FORMAT);
    
        IfFailRet(file->VerifyDirectory(&pZapHeader->EEInfoTable,0));
        IfFailRet(file->VerifyDirectory(&pZapHeader->HelperTable,0));
        IfFailRet(file->VerifyDirectory(&pZapHeader->DelayLoadInfo,0));
        IfFailRet(file->VerifyDirectory(&pZapHeader->VersionInfo,0));
        IfFailRet(file->VerifyDirectory(&pZapHeader->DebugMap,0));
        IfFailRet(file->VerifyDirectory(&pZapHeader->ModuleImage,0));
    }

    return S_OK;
}

HRESULT Module::SetContainer(Assembly *pAssembly, int moduleIndex, mdToken moduleRef,
                             BOOL fResource, OBJECTREF *pThrowable)
{
    HRESULT hr;

    m_pAssembly = pAssembly;
    m_moduleRef = moduleRef;
    m_dwModuleIndex = moduleIndex;

    if (m_pAssembly->IsShared())
    {
        //
        // Compute a base DLS index for classes
        // @perf: can we come up with something a bit denser?
        //
        SIZE_T typeCount = m_pMDImport ? m_pMDImport->GetCountWithTokenKind(mdtTypeDef)+1 : 0;

        SharedDomain::GetDomain()->AllocateSharedClassIndices(this, typeCount+1);
        m_ExposedModuleObjectIndex = m_dwBaseClassIndex + typeCount;
    }

    if (fResource)
        return S_OK;

    if (!IsPreload()) 
    { 
        hr = BuildClassForModule(pThrowable);
        if (FAILED(hr))
            return(hr);
    }    

    TIMELINE_START(LOADER, ("FixupVTables"));

    if (IsPEFile())
    {
        // Fixup vtables in the header that global functions sometimes use.
        FixupVTables(pThrowable);
    }

    TIMELINE_END(LOADER, ("FixupVTables"));

#ifdef DEBUGGING_SUPPORTED
    //
    // If we're debugging, let the debugger know that this module
    // is initialized and loaded now.
    //
    if (CORDebuggerAttached())
        NotifyDebuggerLoad();
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
    if (CORProfilerTrackModuleLoads())
    {
        // Ensure that the pdb gets copied, even if a debugger is not attached.
        GetISymUnmanagedReader();
        g_profControlBlock.pProfInterface->ModuleAttachedToAssembly((ThreadID) GetThread(),
                    (ModuleID) this, (AssemblyID) m_pAssembly);
    }
#endif // PROFILING_SUPPORTED

    if (IsPrecompile())
    {
        TIMELINE_START(LOADER, ("LoadTokenTables"));

        _ASSERTE(IsPEFile());
        if (!LoadTokenTables())
            return COR_E_TYPELOAD;

        TIMELINE_END(LOADER, ("LoadTokenTables"));
    }

    return S_OK;
}

//
// AllocateMap allocates the RID maps based on the size of the current
// metadata (if any)
//

HRESULT Module::AllocateMaps()
{
    enum
    {
        TYPEDEF_MAP_INITIAL_SIZE = 5,
        TYPEREF_MAP_INITIAL_SIZE = 5,
        MEMBERREF_MAP_INITIAL_SIZE = 10,
        MEMBERDEF_MAP_INITIAL_SIZE = 10,
        FILEREFERENCES_MAP_INITIAL_SIZE = 5,
        ASSEMBLYREFERENCES_MAP_INITIAL_SIZE = 5,

        TYPEDEF_MAP_BLOCK_SIZE = 50,
        TYPEREF_MAP_BLOCK_SIZE = 50,
        MEMBERREF_MAP_BLOCK_SIZE = 50,
        MEMBERDEF_MAP_BLOCK_SIZE = 50,
        FILEREFERENCES_MAP_BLOCK_SIZE = 50,
        ASSEMBLYREFERENCES_MAP_BLOCK_SIZE = 50,
        DEFAULT_RESERVE_SIZE = 4096,
    };
    
    DWORD           dwTableAllocElements;
    DWORD           dwReserveSize;
    void            **pTable = NULL;
    HRESULT         hr;

    if (m_pMDImport == NULL)
    {
        // For dynamic modules, it is essential that we at least have a TypeDefToMethodTable
        // map with an initial block.  Otherwise, all the iterators will abort on an
        // initial empty table and we will e.g. corrupt the backpatching chains during
        // an appdomain unload.
        m_TypeDefToMethodTableMap.dwMaxIndex = TYPEDEF_MAP_INITIAL_SIZE;

        // The above is essential.  The following ones are precautionary.
        m_TypeRefToMethodTableMap.dwMaxIndex = TYPEREF_MAP_INITIAL_SIZE;
        m_MethodDefToDescMap.dwMaxIndex = MEMBERDEF_MAP_INITIAL_SIZE;
        m_FieldDefToDescMap.dwMaxIndex = MEMBERDEF_MAP_INITIAL_SIZE;
        m_MemberRefToDescMap.dwMaxIndex = MEMBERREF_MAP_BLOCK_SIZE;
        m_FileReferencesMap.dwMaxIndex = FILEREFERENCES_MAP_INITIAL_SIZE;
        m_AssemblyReferencesMap.dwMaxIndex = ASSEMBLYREFERENCES_MAP_INITIAL_SIZE;
    }
    else
    {
        HENUMInternal   hTypeDefEnum;

        IfFailRet(m_pMDImport->EnumTypeDefInit(&hTypeDefEnum));
        m_TypeDefToMethodTableMap.dwMaxIndex = m_pMDImport->EnumTypeDefGetCount(&hTypeDefEnum);
        m_pMDImport->EnumTypeDefClose(&hTypeDefEnum);

        if (m_TypeDefToMethodTableMap.dwMaxIndex >= MAX_CLASSES_PER_MODULE)
            return COR_E_TYPELOAD;

        // Metadata count is inclusive
        m_TypeDefToMethodTableMap.dwMaxIndex++;

        // Get # TypeRefs
        m_TypeRefToMethodTableMap.dwMaxIndex = m_pMDImport->GetCountWithTokenKind(mdtTypeRef)+1;

        // Get # MethodDefs
        m_MethodDefToDescMap.dwMaxIndex = m_pMDImport->GetCountWithTokenKind(mdtMethodDef)+1;

        // Get # FieldDefs
        m_FieldDefToDescMap.dwMaxIndex = m_pMDImport->GetCountWithTokenKind(mdtFieldDef)+1;

        // Get # MemberRefs
        m_MemberRefToDescMap.dwMaxIndex = m_pMDImport->GetCountWithTokenKind(mdtMemberRef)+1;

        // Get the number of AssemblyReferences and FileReferences in the map
        m_FileReferencesMap.dwMaxIndex = m_pMDImport->GetCountWithTokenKind(mdtFile)+1;
        m_AssemblyReferencesMap.dwMaxIndex = m_pMDImport->GetCountWithTokenKind(mdtAssemblyRef)+1;
    }
    
    // Use one allocation to allocate all the tables
    dwTableAllocElements = m_TypeDefToMethodTableMap.dwMaxIndex + 
      (m_TypeRefToMethodTableMap.dwMaxIndex + m_MemberRefToDescMap.dwMaxIndex + 
       m_MethodDefToDescMap.dwMaxIndex + m_FieldDefToDescMap.dwMaxIndex) +
      m_AssemblyReferencesMap.dwMaxIndex + m_FileReferencesMap.dwMaxIndex;

    dwReserveSize = dwTableAllocElements * sizeof(void*);

    if (m_pLookupTableHeap == NULL)
    {
        // Round to system page size
        dwReserveSize = (dwReserveSize + g_SystemInfo.dwPageSize - 1) & (~(g_SystemInfo.dwPageSize-1));

        m_pLookupTableHeap = new (&m_LookupTableHeapInstance) 
          LoaderHeap(dwReserveSize, RIDMAP_COMMIT_SIZE);
        if (m_pLookupTableHeap == NULL)
            return E_OUTOFMEMORY;
        WS_PERF_ADD_HEAP(LOOKUP_TABLE_HEAP, m_pLookupTableHeap);
        
    }

    if (dwTableAllocElements > 0)
    {
        WS_PERF_SET_HEAP(LOOKUP_TABLE_HEAP);    
        pTable = (void **) m_pLookupTableHeap->AllocMem(dwTableAllocElements * sizeof(void*));
        WS_PERF_UPDATE_DETAIL("LookupTableHeap", dwTableAllocElements * sizeof(void*), pTable);
        if (pTable == NULL)
            return E_OUTOFMEMORY;
    }

    // Don't need to memset, since AllocMem() uses VirtualAlloc(), which guarantees the memory is zero
    // This way we don't automatically touch all those pages
    // memset(pTable, 0, dwTableAllocElements * sizeof(void*));

    m_dwTypeDefMapBlockSize = TYPEDEF_MAP_BLOCK_SIZE;
    m_TypeDefToMethodTableMap.pdwBlockSize = &m_dwTypeDefMapBlockSize;
    m_TypeDefToMethodTableMap.pNext  = NULL;
    m_TypeDefToMethodTableMap.pTable = pTable;

    m_dwTypeRefMapBlockSize = TYPEREF_MAP_BLOCK_SIZE;
    m_TypeRefToMethodTableMap.pdwBlockSize = &m_dwTypeRefMapBlockSize;
    m_TypeRefToMethodTableMap.pNext  = NULL;
    m_TypeRefToMethodTableMap.pTable = &pTable[m_TypeDefToMethodTableMap.dwMaxIndex];

    m_dwMethodDefMapBlockSize = MEMBERDEF_MAP_BLOCK_SIZE;
    m_MethodDefToDescMap.pdwBlockSize = &m_dwMethodDefMapBlockSize;
    m_MethodDefToDescMap.pNext  = NULL;
    m_MethodDefToDescMap.pTable = &m_TypeRefToMethodTableMap.pTable[m_TypeRefToMethodTableMap.dwMaxIndex];

    m_dwFieldDefMapBlockSize = MEMBERDEF_MAP_BLOCK_SIZE;
    m_FieldDefToDescMap.pdwBlockSize = &m_dwFieldDefMapBlockSize;
    m_FieldDefToDescMap.pNext  = NULL;
    m_FieldDefToDescMap.pTable = &m_MethodDefToDescMap.pTable[m_MethodDefToDescMap.dwMaxIndex];

    m_dwMemberRefMapBlockSize = MEMBERREF_MAP_BLOCK_SIZE;
    m_MemberRefToDescMap.pdwBlockSize = &m_dwMemberRefMapBlockSize;
    m_MemberRefToDescMap.pNext  = NULL;
    m_MemberRefToDescMap.pTable = &m_FieldDefToDescMap.pTable[m_FieldDefToDescMap.dwMaxIndex];
    
    m_dwFileReferencesMapBlockSize = FILEREFERENCES_MAP_BLOCK_SIZE;
    m_FileReferencesMap.pdwBlockSize = &m_dwFileReferencesMapBlockSize;
    m_FileReferencesMap.pNext  = NULL;
    m_FileReferencesMap.pTable = &m_MemberRefToDescMap.pTable[m_MemberRefToDescMap.dwMaxIndex];
    
    m_dwAssemblyReferencesMapBlockSize = ASSEMBLYREFERENCES_MAP_BLOCK_SIZE;
    m_AssemblyReferencesMap.pdwBlockSize = &m_dwAssemblyReferencesMapBlockSize;
    m_AssemblyReferencesMap.pNext  = NULL;
    m_AssemblyReferencesMap.pTable = &m_FileReferencesMap.pTable[m_FileReferencesMap.dwMaxIndex];

    return S_OK;
}

//
// FreeClassTables frees the classes in the module
//

void Module::FreeClassTables()
{
    if (m_dwFlags & CLASSES_FREED)
        return;

    m_dwFlags |= CLASSES_FREED;

#if _DEBUG
    DebugLogRidMapOccupancy();
#endif

    // Free the EEClass*'s filled out in the TypeDefToEEClass map
    LookupMap *pMap;
    DWORD       dwMinIndex = 0;
    MethodTable *pMT;

    // Go through each linked block
    for (pMap = &m_TypeDefToMethodTableMap; pMap != NULL && pMap->pTable; pMap = pMap->pNext)
    {
        DWORD i;
        DWORD dwIterCount = pMap->dwMaxIndex - dwMinIndex;
        void **pRealTableStart = &pMap->pTable[dwMinIndex];
        
        for (i = 0; i < dwIterCount; i++)
        {
            pMT = (MethodTable *) (pRealTableStart[i]);
            
            if (pMT != NULL)
            {
                pMT->GetClass()->destruct();
                pRealTableStart[i] = NULL;
            }
        }
    
        dwMinIndex = pMap->dwMaxIndex;
    }
}

void Module::SetMDImport(IMDInternalImport *pImport)
{
    _ASSERTE(m_pImporter == NULL);
    _ASSERTE(m_pEmitter == NULL);

    m_pMDImport = pImport;
}

void Module::SetEmit(IMetaDataEmit *pEmit)
{
    _ASSERTE(m_pMDImport == NULL);
    _ASSERTE(m_pImporter == NULL);
    _ASSERTE(m_pEmitter == NULL);

    m_pEmitter = pEmit;

    HRESULT hr = GetMetaDataInternalInterfaceFromPublic((void*) pEmit, IID_IMDInternalImport, 
                                                        (void **)&m_pMDImport);
    _ASSERTE(SUCCEEDED(hr) && m_pMDImport != NULL);
}

//
// ConvertMDInternalToReadWrite: 
// If a public metadata interface is needed, must convert to r/w format
//  first.  Note that the data is not made writeable, nor actually converted,
//  only the data structures pointing to the actual data change.  This is 
//  done because the public interfaces only understand the MDInternalRW
//  format (which understands both the optimized and un-optimized metadata).
//
HRESULT Module::ConvertMDInternalToReadWrite(IMDInternalImport **ppImport)
{ 
    HRESULT     hr=S_OK;                // A result.
    IMDInternalImport *pOld;            // Old (current RO) value of internal import.
    IMDInternalImport *pNew;            // New (RW) value of internal import.

    // Take a local copy of *ppImport.  This may be a pointer to an RO
    //  or to an RW MDInternalXX.
    pOld = *ppImport;

    // If an RO, convert to an RW, return S_OK.  If already RW, no conversion 
    //  needed, return S_FALSE.
    IfFailGo(ConvertMDInternalImport(pOld, &pNew));

    // If no conversion took place, don't change pointers.
    if (hr == S_FALSE)
    {
        hr = S_OK;
        goto ErrExit;
    }

    // Swap the pointers in a thread safe manner.  If the contents of *ppImport
    //  equals pOld then no other thread got here first, and the old contents are
    //  replaced with pNew.  The old contents are returned.
    if (FastInterlockCompareExchange((void**)ppImport, pNew, pOld) == pOld)
    {   // Swapped -- get the metadata to hang onto the old Internal import.
        VERIFY((*ppImport)->SetUserContextData(pOld) == S_OK);
    }
    else
    {   // Some other thread finished first.  Just free the results of this conversion.
        pNew->Release();
        _ASSERTE((*ppImport)->QueryInterface(IID_IMDInternalImportENC, (void**)&pOld) == S_OK);
        DEBUG_STMT(if (pOld) pOld->Release();)
    }

ErrExit:
    return hr;
} // HRESULT Module::ConvertMDInternalToReadWrite()



// Self-initializing accessor for m_pThunkHeap
LoaderHeap *Module::GetThunkHeap()
{
    if (!m_pThunkHeap)
    {
        LoaderHeap *pNewHeap = new LoaderHeap(4096, 4096, 
                                              &(GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize), 
                                              &(GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize),
                                              &ThunkHeapStubManager::g_pManager->m_rangeList);
        if (VipInterlockedCompareExchange((void*volatile*)&m_pThunkHeap, (VOID*)pNewHeap, (VOID*)0) != 0)
        {
            delete pNewHeap;
        }
    }

    _ASSERTE(m_pThunkHeap != NULL);
    return m_pThunkHeap;
}


IMetaDataImport *Module::GetImporter()
{
    if (m_pImporter == NULL && m_pMDImport != NULL)
    {
        if (SUCCEEDED(ConvertMDInternalToReadWrite(&m_pMDImport)))
        {
            IMetaDataImport *pIMDImport = NULL;
            GetMetaDataPublicInterfaceFromInternal((void*)m_pMDImport, 
                                                   IID_IMetaDataImport,
                                                   (void **)&pIMDImport);

            // Do a safe pointer assignment.   If another thread beat us, release
            // the interface and use the first one that gets in.
            if (FastInterlockCompareExchange((void **)&m_pImporter, pIMDImport, NULL))
                pIMDImport->Release();
        }
    }

    _ASSERTE((m_pImporter != NULL && m_pMDImport != NULL) ||
             (m_pImporter == NULL && m_pMDImport == NULL));

    return m_pImporter;
}

LPCWSTR Module::GetFileName()
{
    if (m_file == NULL)
        return L"";
    else
        return m_file->GetFileName();
}

// Note that the debugger relies on the file name being copied
// into buffer pointed to by name.
HRESULT Module::GetFileName(LPSTR name, DWORD max, DWORD *count)
{
    if (m_file != NULL)
        return m_file->GetFileName(name, max, count);

    *count = 0;
    return S_OK;
}

BOOL Module::IsSystem()
{
    Assembly *pAssembly = GetAssembly();
    if (pAssembly == NULL)
        return IsSystemFile();
    else
        return pAssembly->IsSystem();
}

IMetaDataEmit *Module::GetEmitter()
{
    if (m_pEmitter == NULL)
    {
        HRESULT hr;
        IMetaDataEmit *pEmit = NULL;
        hr = GetImporter()->QueryInterface(IID_IMetaDataEmit, (void **)&pEmit);
        _ASSERTE(pEmit && SUCCEEDED(hr));

        if (FastInterlockCompareExchange((void **)&m_pEmitter, pEmit, NULL))
            pEmit->Release();
    }

    return m_pEmitter;
}

IMetaDataDispenserEx *Module::GetDispenser()
{
    if (m_pDispenser == NULL)
    {
        // Get the Dispenser interface.
        HRESULT hr = MetaDataGetDispenser(CLSID_CorMetaDataDispenser, 
                                          IID_IMetaDataDispenserEx, (void **)&m_pDispenser);
    }
    _ASSERTE(m_pDispenser != NULL);
    return m_pDispenser;
}

void Module::ReleaseMDInterfaces(BOOL forENC)
{
    if (!forENC) 
    {
        if (m_pMDImport)
        {
            m_pMDImport->Release();
            m_pMDImport = NULL;
        }
        if (m_pDispenser)
        {
            m_pDispenser->Release();
            m_pDispenser = NULL;
        }
    }

    if (m_pEmitter)
    {
        m_pEmitter->Release();
        m_pEmitter = NULL;
    }

    if (m_pImporter)
    {
        m_pImporter->Release();
        m_pImporter = NULL;
    }
}

ClassLoader *Module::GetClassLoader()
{
    _ASSERTE(m_pAssembly != NULL);
    return m_pAssembly->GetLoader();
}

BaseDomain *Module::GetDomain()
{
    _ASSERTE(m_pAssembly != NULL);
    return m_pAssembly->GetDomain();
}

AssemblySecurityDescriptor *Module::GetSecurityDescriptor()
{
    _ASSERTE(m_pAssembly != NULL);
    return m_pAssembly->GetSecurityDescriptor();
}

BOOL Module::IsSystemClasses()
{
    return GetSecurityDescriptor()->IsSystemClasses();
}

BOOL Module::IsFullyTrusted()
{
    return GetSecurityDescriptor()->IsFullyTrusted();
}

//
// We'll use this struct and global to keep a list of all
// ISymUnmanagedReaders and ISymUnmanagedWriters (or any IUnknown) so
// we can relelease them at the end.
//
struct IUnknownList
{
    IUnknownList   *next;
    HelpForInterfaceCleanup *cleanup;
    IUnknown       *pUnk;
};

static IUnknownList *g_IUnknownList = NULL;

/*static*/ HRESULT Module::TrackIUnknownForDelete(
                                 IUnknown *pUnk,
                                 IUnknown ***pppUnk,
                                 HelpForInterfaceCleanup *pCleanHelp)
{
    IUnknownList *pNew = new IUnknownList;

    if (pNew == NULL)
        return E_OUTOFMEMORY;

    pNew->pUnk = pUnk; // Ref count is 1
    pNew->cleanup = pCleanHelp;
    pNew->next = g_IUnknownList;
    g_IUnknownList = pNew;

    // Return the address of where we're keeping the IUnknown*, if
    // needed.
    if (pppUnk)
        *pppUnk = &(pNew->pUnk);

    return S_OK;
}

/*static*/ void Module::ReleaseAllIUnknowns(void)
{
    IUnknownList **ppElement = &g_IUnknownList;

    while (*ppElement)
    {
        IUnknownList *pTmp = *ppElement;

        // Release the IUnknown
        if (pTmp->pUnk != NULL)
            pTmp->pUnk->Release();
            
        if (pTmp->cleanup != NULL)
            delete pTmp->cleanup;

        *ppElement = pTmp->next;
        delete pTmp;
    }
}

void Module::ReleaseIUnknown(IUnknown *pUnk)
{
    IUnknownList **ppElement = &g_IUnknownList;

    while (*ppElement)
    {
        IUnknownList *pTmp = *ppElement;

        // Release the IUnknown
        if (pTmp->pUnk == pUnk)
        {
            // This doesn't have to be thread safe because only add to front of list and
            // only delete on unload or shutdown and can only be happening on one thread
            pTmp->pUnk->Release();
            if (pTmp->cleanup != NULL)
                delete pTmp->cleanup;
            *ppElement = pTmp->next;
            delete pTmp;
            break;
        }
        ppElement = &pTmp->next;
    }
    _ASSERTE(ppElement);    // if have a reader, should have found it in list
}

void Module::ReleaseIUnknown(IUnknown **ppUnk)
{
    IUnknownList **ppElement = &g_IUnknownList;

    while (*ppElement)
    {
        IUnknownList *pTmp = *ppElement;

        // Release the IUnknown
        if (&(pTmp->pUnk) == ppUnk)
        {
            // This doesn't have to be thread safe because only add to front of list and
            // only delete on unload or shutdown and can only be happening on one thread
            if (pTmp->pUnk)
                pTmp->pUnk->Release();
            if (pTmp->cleanup != NULL)
                delete pTmp->cleanup;
            *ppElement = pTmp->next;
            delete pTmp;
            break;
        }
        ppElement = &pTmp->next;
    }
    _ASSERTE(ppElement);    // if have a reader, should have found it in list
}

void Module::ReleaseISymUnmanagedReader(void)
{
    // This doesn't have to take the m_pISymUnmanagedReaderLock since
    // a module is destroyed only by one thread.
    if (m_pISymUnmanagedReader == NULL)
        return;
    Module::ReleaseIUnknown(m_pISymUnmanagedReader);
    m_pISymUnmanagedReader = NULL;
}

/*static*/ void Module::ReleaseMemoryForTracking()
{
    IUnknownList **ppElement = &g_IUnknownList;

    while (*ppElement)
    {
        IUnknownList *pTmp = *ppElement;

        *ppElement = pTmp->next;

        if (pTmp->cleanup != NULL)
        {
            (*(pTmp->cleanup->pFunction))(pTmp->cleanup->pData);

            delete pTmp->cleanup;
        }
        
        delete pTmp;
    }
}// ReleaseMemoryForTracking


//
// Module::FusionCopyPDBs asks Fusion to copy PDBs for a given
// assembly if they need to be copied. This is for the case where a PE
// file is shadow copied to the Fusion cache. Fusion needs to be told
// to take the time to copy the PDB, too.
//
typedef HRESULT __stdcall COPYPDBS(IAssembly *pAsm);

void Module::FusionCopyPDBs(LPCWSTR moduleName)
{
    Assembly *pAssembly = GetAssembly();

    // Just return if we've already done this for this Module's
    // Assembly.
    if ((pAssembly->GetDebuggerInfoBits() & DACF_PDBS_COPIED) ||
        (pAssembly->GetFusionAssembly() == NULL))
    {
        LOG((LF_CORDB, LL_INFO10,
             "Don't need to copy PDB's for module %S\n",
             moduleName));
        
        return;
    }

    LOG((LF_CORDB, LL_INFO10,
         "Attempting to copy PDB's for module %S\n", moduleName));
        
    // This isn't a publicly exported Fusion API, so we have to look
    // it up in the Fusion DLL by name.
    HINSTANCE fusiondll = WszGetModuleHandle(L"Fusion.DLL");

    if (fusiondll != NULL)
    {
        COPYPDBS *pCopyPDBFunc;

        pCopyPDBFunc = (COPYPDBS*) GetProcAddress(fusiondll, "CopyPDBs");
        
        if (pCopyPDBFunc != NULL)
        {
            HRESULT hr = pCopyPDBFunc(pAssembly->GetFusionAssembly());
            // TODO Goes off with E_NO_IMPL -vancem 
            // _ASSERTE(SUCCEEDED(hr) || hr == E_INVALIDARG);

            LOG((LF_CORDB, LL_INFO10,
                 "Fusion.dll!CopyPDBs returned hr=0x%08x for module 0x%08x\n",
                 hr, this));
        }
        else
        {
            LOG((LF_CORDB, LL_INFO10,
                 "Fusion.dll!CopyPDBs could not be found!\n"));
        }
    }
    else
    {
        LOG((LF_CORDB, LL_INFO10, "Fusion.dll could not be found!\n"));
    }

    // Remember that we've copied the PDBs for this assembly.
    pAssembly->SetDebuggerInfoBits(
            (DebuggerAssemblyControlFlags)(pAssembly->GetDebuggerInfoBits() |
                                           DACF_PDBS_COPIED));
}

//
// This will return a symbol reader for this module, if possible.
//
#if defined(ENABLE_PERF_LOG) && defined(DEBUGGING_SUPPORTED)
extern BOOL g_fDbgPerfOn;
extern __int64 g_symbolReadersCreated;
#endif

// This function will free the metadata interface if we are not
// able to free the ISymUnmanagedReader
static void ReleaseImporterFromISymUnmanagedReader(void * pData)
{
    IMetaDataImport *md = (IMetaDataImport*)pData;

    // We need to release it twice
    md->Release();
    md->Release();
    
}// ReleaseImporterFromISymUnmanagedReader

ISymUnmanagedReader *Module::GetISymUnmanagedReader(void)
{
    // ReleaseAllIUnknowns() called during EEShutDown() will destroy
    // m_pISymUnmanagedReader. We cannot use it for stack-traces or anything
    if (g_fEEShutDown)
        return NULL;

    // If we haven't created the lock yet, do so lazily here
    if (m_pISymUnmanagedReaderLock == NULL)
    {
        // Allocate and initialize the critical section
        PCRITICAL_SECTION pCritSec = new CRITICAL_SECTION;
        _ASSERTE(pCritSec != NULL);

        if (pCritSec == NULL)
            return (NULL);

        InitializeCriticalSection(pCritSec);

        // Swap the pointers in a thread safe manner.
        if (InterlockedCompareExchangePointer((PVOID *)&m_pISymUnmanagedReaderLock, (PVOID)pCritSec, NULL) != NULL)
        {
            DeleteCriticalSection(pCritSec);
            delete pCritSec;
        }
    }

    // Take the lock for the m_pISymUnmanagedReader
    EnterCriticalSection(m_pISymUnmanagedReaderLock);

    HRESULT hr = S_OK;
    HelpForInterfaceCleanup* hlp = NULL; 
    ISymUnmanagedBinder *pBinder = NULL;
    UINT lastErrorMode = 0;

    // Name for the module
    LPCWSTR pName = NULL;

    // Check to see if this variable has already been set
    if (m_pISymUnmanagedReader != NULL)
        goto ErrExit;

    pName = GetFileName();

    if (pName[0] == L'\0')
    {
        hr = E_INVALIDARG;
        goto ErrExit;
    }

    // Call Fusion to ensure that any PDB's are shadow copied before
    // trying to get a synbol reader. This has to be done once per
    // Assembly.
    FusionCopyPDBs(pName);

    // Create a binder to find the reader.
    //
    // @perf: this is slow, creating and destroying the binder every
    // time. We should cache this somewhere, but I'm not 100% sure
    // where right now...
    IfFailGo(FakeCoCreateInstance(CLSID_CorSymBinder_SxS,
                                  IID_ISymUnmanagedBinder,
                                  (void**)&pBinder));

    LOG((LF_CORDB, LL_INFO10, "M::GISUR: Created binder\n"));

    // Note: we change the error mode here so we don't get any popups as the PDB symbol reader attempts to search the
    // hard disk for files.
    lastErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS);
    
    hr = pBinder->GetReaderForFile(GetImporter(),
                                       pName,
                                       NULL,
                                   &m_pISymUnmanagedReader);

    SetErrorMode(lastErrorMode);

    if (FAILED(hr))
        goto ErrExit;

    hlp = new HelpForInterfaceCleanup;
    hlp->pData = GetImporter();
    hlp->pFunction = ReleaseImporterFromISymUnmanagedReader;
    
    
    IfFailGo(Module::TrackIUnknownForDelete((IUnknown*)m_pISymUnmanagedReader,
                                            NULL,
                                            hlp));

    LOG((LF_CORDB, LL_INFO10, "M::GISUR: Loaded symbols for module %S\n",
         pName));

#if defined(ENABLE_PERF_LOG) && defined(DEBUGGING_SUPPORTED)
    if (g_fDbgPerfOn)
        g_symbolReadersCreated++;
#endif
    
ErrExit:
    if (pBinder != NULL)
        pBinder->Release();
    
    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO10, "M::GISUR: Failed to load symbols for module %S, hr=0x%08x\n", pName, hr));
        if (m_pISymUnmanagedReader)
            m_pISymUnmanagedReader->Release();
        m_pISymUnmanagedReader = (ISymUnmanagedReader*)0x01; // Failed to load.
    }

    // Leave the lock
    LeaveCriticalSection(m_pISymUnmanagedReaderLock);
    
    // Make checks that don't have to be done under lock
    if (m_pISymUnmanagedReader == (ISymUnmanagedReader *)0x01)
        return (NULL);
    else
        return (m_pISymUnmanagedReader);
}

HRESULT Module::UpdateISymUnmanagedReader(IStream *pStream)
{
    HRESULT hr = S_OK;
    ISymUnmanagedBinder *pBinder = NULL;
    HelpForInterfaceCleanup* hlp = NULL; 


    // If we don't already have a reader, create one.
    if (m_pISymUnmanagedReader == NULL)
    {
        IfFailGo(FakeCoCreateInstance(CLSID_CorSymBinder_SxS,
                                      IID_ISymUnmanagedBinder,
                                      (void**)&pBinder));

        LOG((LF_CORDB, LL_INFO10, "M::UISUR: Created binder\n"));

        IfFailGo(pBinder->GetReaderFromStream(GetImporter(),
                                              pStream,
                                              &m_pISymUnmanagedReader));

        hlp = new HelpForInterfaceCleanup;
        hlp->pData = GetImporter();
        hlp->pFunction = ReleaseImporterFromISymUnmanagedReader;

        IfFailGo(Module::TrackIUnknownForDelete(
                                      (IUnknown*)m_pISymUnmanagedReader,
                                      NULL,
                                      hlp));
    
        LOG((LF_CORDB, LL_INFO10,
             "M::UISUR: Loaded symbols for module 0x%08x\n", this));
    }
    else if (m_pISymUnmanagedReader != (ISymUnmanagedReader*)0x01)
    {
        // We already have a reader, so just replace the symbols. We
        // replace instead of update because we are doing this only
        // for dynamic modules and the syms are cumulative.
        hr = m_pISymUnmanagedReader->ReplaceSymbolStore(NULL, pStream);
    
        LOG((LF_CORDB, LL_INFO10,
             "M::UISUR: Updated symbols for module 0x%08x\n", this));
    }
    else
        hr = E_INVALIDARG;
        
ErrExit:
    if (pBinder)
        pBinder->Release();
    
    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO10,
             "M::GISUR: Failed to load symbols for module 0x%08x, hr=0x%08x\n",
             this, hr));

        if (m_pISymUnmanagedReader)
        {
            m_pISymUnmanagedReader->Release();
            m_pISymUnmanagedReader = NULL; // We'll try again next time...
        }
    }

    return hr;
}

// At this point, this is only called when we're creating an appdomain
// out of an array of bytes, so we'll keep the IStream that we create
// around in case the debugger attaches later (including detach & re-attach!)
HRESULT Module::SetSymbolBytes(BYTE *pbSyms, DWORD cbSyms)
{
    HRESULT hr = S_OK;
    HelpForInterfaceCleanup* hlp = NULL; 


    // Create a IStream from the memory for the syms.
    ISymUnmanagedBinder *pBinder = NULL;

    CGrowableStream *pStream = new CGrowableStream();
    if (pStream == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pStream->AddRef(); // The Module will keep a copy for it's own use.
    
#ifdef LOGGING        
    LPCWSTR pName;
    pName = GetFileName();
#endif
        
    ULONG cbWritten;
    hr = HRESULT_FROM_WIN32(pStream->Write((const void HUGEP *)pbSyms,
                   (ULONG)cbSyms,
                                           &cbWritten));
    if (FAILED(hr))
        return hr;
                   
    // Create a reader.
    IfFailGo(FakeCoCreateInstance(CLSID_CorSymBinder_SxS,
                                  IID_ISymUnmanagedBinder,
                                  (void**)&pBinder));

    LOG((LF_CORDB, LL_INFO10, "M::SSB: Created binder\n"));

    // The SymReader gets the other reference:
    IfFailGo(pBinder->GetReaderFromStream(GetImporter(),
                                          pStream,
                                          &m_pISymUnmanagedReader));
    hlp = new HelpForInterfaceCleanup;
    hlp->pData = GetImporter();
    hlp->pFunction = ReleaseImporterFromISymUnmanagedReader;
    
    IfFailGo(Module::TrackIUnknownForDelete(
                                     (IUnknown*)m_pISymUnmanagedReader,
                                     NULL,
                                     hlp));
    
    LOG((LF_CORDB, LL_INFO10,
         "M::SSB: Loaded symbols for module 0x%08x\n", this));

    LOG((LF_CORDB, LL_INFO10, "M::GISUR: Loaded symbols for module %S\n",
         pName));

    // Make sure to set the symbol stream on the module before
    // attempting to send UpdateModuleSyms messages up for it.
    SetInMemorySymbolStream(pStream);

#ifdef DEBUGGING_SUPPORTED
    // Tell the debugger that symbols have been loaded for this
    // module.  We iterate through all domains which contain this
    // module's assembly, and send a debugger notify for each one.
    // @perf: it would scale better if we directly knew which domains
    // the assembly was loaded in.
    if (CORDebuggerAttached())
    {
        AppDomainIterator i;
    
        while (i.Next())
        {
            AppDomain *pDomain = i.GetDomain();

            if (pDomain->IsDebuggerAttached() && (GetDomain() == SystemDomain::System() ||
                                                  pDomain->ContainsAssembly(m_pAssembly)))
                g_pDebugInterface->UpdateModuleSyms(this, pDomain, FALSE);
        }
    }
#endif // DEBUGGING_SUPPORTED
    
ErrExit:
    if (pBinder)
        pBinder->Release();
    
    if (FAILED(hr))
    {
        LOG((LF_CORDB, LL_INFO10,
             "M::GISUR: Failed to load symbols for module %S, hr=0x%08x\n",
             pName, hr));

        if (m_pISymUnmanagedReader != NULL)
        {
            m_pISymUnmanagedReader->Release();
            m_pISymUnmanagedReader = NULL; // We'll try again next time.
        }
    }

    return hr;
}

//---------------------------------------------------------------------------
// displays details about metadata error including module name, error 
// string corresponding to hr code, and a rich error posted by the
// metadata (if available).
//
//---------------------------------------------------------------------------
void Module::DisplayFileLoadError(HRESULT hrRpt)
{
    HRESULT     hr;
    CComPtr<IErrorInfo> pIErrInfo;                  // Error item 
    LPCWSTR     rcMod;                              // Module path
    WCHAR       rcErr[ERROR_LENGTH];                // Error string for hr
    CComBSTR    sDesc = NULL;                       // MetaData error message
    WCHAR       rcTemplate[ERROR_LENGTH];       

    LPWSTR      rcFormattedErr = new (throws) WCHAR[FORMAT_MESSAGE_LENGTH];

    // Retrieve metadata rich error
    if (GetErrorInfo(0, &pIErrInfo) == S_OK)
        pIErrInfo->GetDescription(&sDesc);
        
    // Get error message template
    hr = LoadStringRC(IDS_EE_METADATA_ERROR, rcTemplate, NumItems(rcTemplate), true);

    if (SUCCEEDED(hr)) {
        rcMod = GetFileName();

        // Print metadata rich error
        if (sDesc.Length())
        {
            _snwprintf(rcFormattedErr, FORMAT_MESSAGE_LENGTH, rcTemplate, rcMod, sDesc.m_str);
            SysFreeString(sDesc);
        }
        else if (HRESULT_FACILITY(hrRpt) == FACILITY_URT)
        {
            // If this is one of our errors, then grab the error from the rc file.
            hr = LoadStringRC(LOWORD(hrRpt), rcErr, NumItems(rcErr), true);
            if (hr == S_OK)
                // Retrieve error message string for inputted hr code
                _snwprintf(rcFormattedErr, FORMAT_MESSAGE_LENGTH, rcTemplate, rcMod, rcErr);
        } 
        else if (WszFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                  0, hrRpt, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                  rcErr, NumItems(rcErr), 0))
        {
            // Otherwise it isn't one of ours, so we need to see if the system can
            // find the text for it.
            hr = S_OK;
            
            // System messages contain a trailing \r\n, which we don't want normally.
            int iLen = lstrlenW(rcErr);
            if (iLen > 3 && rcErr[iLen - 2] == '\r' && rcErr[iLen - 1] == '\n')
                rcErr[iLen - 2] = '\0';
            _snwprintf(rcFormattedErr, FORMAT_MESSAGE_LENGTH, rcTemplate, rcMod, rcErr);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            if (SUCCEEDED(hr))
                hr = E_FAIL;
        }
    }

    // If we failed to find the message anywhere, then issue a hard coded message.
    if (FAILED(hr))
    {
        swprintf(rcErr, L"CLR Internal error: 0x%08x", hrRpt);
        DEBUG_STMT(DbgWriteEx(rcErr));
    }

    rcFormattedErr[FORMAT_MESSAGE_LENGTH-1] = L'\0';
    DisplayError(hrRpt, rcFormattedErr);       
    delete rcFormattedErr;
}
 

//==========================================================================
// If Module doesn't yet know the Exposed Module class that represents it via
// Reflection, acquire that class now.  Regardless, return it to the caller.
//==========================================================================
OBJECTREF Module::GetExposedModuleObject(AppDomain *pDomain)
{
    THROWSCOMPLUSEXCEPTION();

    //
    // Figure out which handle to use.
    //
    
    OBJECTHANDLE hObject;

    // @TODO cwb: The synchronization of classes is still being designed.  But
    // here's a place where we need to use that mechanism, once it's in place.

    if (GetAssembly()->IsShared())
    {
        if (pDomain == NULL)
            pDomain = GetAppDomain();

        DomainLocalBlock *pLocalBlock = pDomain->GetDomainLocalBlock();
        
        hObject = (OBJECTHANDLE) pLocalBlock->GetSlot(m_ExposedModuleObjectIndex);
        if (hObject == NULL)
        {
            hObject = pDomain->CreateHandle(NULL);
            pLocalBlock->SetSlot(m_ExposedModuleObjectIndex, hObject);
        }
    }
    else
    {
        hObject = m_ExposedModuleObject;
        if (hObject == NULL)
        {
            hObject = GetDomain()->CreateHandle(NULL);
            m_ExposedModuleObject = hObject;
        }
    }

    if (ObjectFromHandle(hObject) == NULL)
    {
        // Make sure that reflection has been initialized
        COMClass::EnsureReflectionInitialized();

        REFLECTMODULEBASEREF  refClass = NULL;
        HRESULT         hr = COMClass::CreateClassObjFromModule(this, &refClass);

        // either we got a refClass or we got an error code:
        _ASSERTE(SUCCEEDED(hr) == (refClass != NULL));

        if (FAILED(hr))
            COMPlusThrowHR(hr);

        // The following will only update the handle if it is currently NULL.
        // In other words, first setter wins.  We don't have to do any
        // cleanup if our guy loses, since GC will collect it.
        StoreFirstObjectInHandle(hObject, (OBJECTREF) refClass);

        // either way, we must have a non-NULL value now (since nobody will
        // reset it back to NULL underneath us)
        _ASSERTE(ObjectFromHandle(hObject) != NULL);

    }
    return ObjectFromHandle(hObject);
}

//==========================================================================
// If Module doesn't yet know the Exposed Module class that represents it via
// Reflection, acquire that class now.  Regardless, return it to the caller.
//==========================================================================
OBJECTREF Module::GetExposedModuleBuilderObject(AppDomain *pDomain)
{
    THROWSCOMPLUSEXCEPTION();

    //
    // Figure out which handle to use.
    //

    OBJECTHANDLE hObject;

    // @TODO cwb: The synchronization of classes is still being designed.  But
    // here's a place where we need to use that mechanism, once it's in place.

    if (GetAssembly()->IsShared())
    {
        if (pDomain == NULL)
            pDomain = GetAppDomain();

        DomainLocalBlock *pLocalBlock = pDomain->GetDomainLocalBlock();
        
        hObject = (OBJECTHANDLE) pLocalBlock->GetSlot(m_ExposedModuleObjectIndex);
        if (hObject == NULL)
        {
            hObject = pDomain->CreateHandle(NULL);
            pLocalBlock->SetSlot(m_ExposedModuleObjectIndex, hObject);
        }
    }
    else
    {
        hObject = m_ExposedModuleObject;
        if (hObject == NULL)
        {
            hObject = GetDomain()->CreateHandle(NULL);
            m_ExposedModuleObject = hObject;
        }
    }

    if (ObjectFromHandle(hObject) == NULL)
    {
        // Make sure that reflection has been initialized
        COMClass::EnsureReflectionInitialized();

        // load module builder if it is not loaded.
        if (g_pRefUtil->GetClass(RC_DynamicModule) == NULL)
        {
            // Question: do I need to worry about multi-threading? I think so...
            MethodTable *pMT = g_Mscorlib.GetClass(CLASS__MODULE_BUILDER);
            g_pRefUtil->SetClass(RC_DynamicModule, pMT);
            g_pRefUtil->SetTrueClass(RC_DynamicModule, pMT);
        }

        REFLECTMODULEBASEREF  refClass = NULL;
        HRESULT         hr = COMClass::CreateClassObjFromDynamicModule(this, &refClass);

        // either we got a refClass or we got an error code:
        _ASSERTE(SUCCEEDED(hr) == (refClass != NULL));

        if (FAILED(hr))
            COMPlusThrowHR(hr);

        // The following will only update the handle if it is currently NULL.
        // In other words, first setter wins.  We don't have to do any
        // cleanup if our guy loses, since GC will collect it.
        StoreFirstObjectInHandle(hObject, (OBJECTREF) refClass);

        // either way, we must have a non-NULL value now (since nobody will
        // reset it back to NULL underneath us)
        _ASSERTE(ObjectFromHandle(hObject) != NULL);

    }
    return ObjectFromHandle(hObject);
}


// Distinguish between the fake class associated with the module (global fields &
// functions) from normal classes.
BOOL Module::AddClass(mdTypeDef classdef)
{
    if (!RidFromToken(classdef))
    {
        OBJECTREF       pThrowable = 0;
        BOOL            result;

        // @TODO: What is reflection emit's policy for error propagation?  We are
        // dropping pThrowable on the floor here.
        GCPROTECT_BEGIN(pThrowable);
        result = SUCCEEDED(BuildClassForModule(&pThrowable));
        GCPROTECT_END();

        return result;
    }
    else
    {
        return SUCCEEDED(GetClassLoader()->AddAvailableClassDontHaveLock(this, m_dwModuleIndex, classdef));
    }
}

//---------------------------------------------------------------------------
// For the global class this builds the table of MethodDescs an adds the rids
// to the MethodDef map.
//---------------------------------------------------------------------------
HRESULT Module::BuildClassForModule(OBJECTREF *pThrowable)
{        
    EEClass        *pClass;
    HRESULT         hr;
    HENUMInternal   hEnum;
    DWORD           cFunctions, cFields;

    _ASSERTE(m_pMDImport != NULL);

    // Obtain count of global functions
    hr = m_pMDImport->EnumGlobalFunctionsInit(&hEnum);
    if (FAILED(hr))
    {
        _ASSERTE(!"Cannot count global functions");
        return hr;
    }
    cFunctions = m_pMDImport->EnumGetCount(&hEnum);
    m_pMDImport->EnumClose(&hEnum);

    // Obtain count of global fields
    hr = m_pMDImport->EnumGlobalFieldsInit(&hEnum);
    if (FAILED(hr))
    {
        _ASSERTE(!"Cannot count global fields");
        return hr;
    }
    cFields = m_pMDImport->EnumGetCount(&hEnum);
    m_pMDImport->EnumClose(&hEnum);

    // If we have any work to do...
    if (cFunctions > 0 || cFields > 0)
    {
        COUNTER_ONLY(DWORD _dwHeapSize = 0);

        hr = GetClassLoader()->LoadTypeHandleFromToken(this,
                                                       COR_GLOBAL_PARENT_TOKEN,
                                                       &pClass,
                                                       pThrowable);
        if (SUCCEEDED(hr)) 
        {
#ifdef PROFILING_SUPPORTED
            // Record load of the class for the profiler, whether successful or not.
            if (CORProfilerTrackClasses())
            {
                g_profControlBlock.pProfInterface->ClassLoadStarted((ThreadID) GetThread(),
                                                                    (ClassID) TypeHandle(pClass).AsPtr());
            }
#endif //PROFILING_SUPPORTED

#ifdef PROFILING_SUPPORTED
            // Record load of the class for the profiler, whether successful or not.
            if (CORProfilerTrackClasses())
            {
                g_profControlBlock.pProfInterface->ClassLoadFinished((ThreadID) GetThread(),
                                                                     (ClassID) TypeHandle(pClass).AsPtr(),
                                                                     SUCCEEDED(hr) ? S_OK : hr);
            }
#endif //PROFILING_SUPPORTED
        }

#ifdef DEBUGGING_SUPPORTED
        //
        // If we're debugging, let the debugger know that this class
        // is initialized and loaded now.
        //
        if (CORDebuggerAttached())
            pClass->NotifyDebuggerLoad();
#endif // DEBUGGING_SUPPORTED
      
        if (FAILED(hr))
            return hr;

#ifdef ENABLE_PERF_COUNTERS
        GetGlobalPerfCounters().m_Loading.cClassesLoaded ++;
        GetPrivatePerfCounters().m_Loading.cClassesLoaded ++;

        _dwHeapSize = pClass->GetClassLoader()->GetHighFrequencyHeap()->GetSize();

        GetGlobalPerfCounters().m_Loading.cbLoaderHeapSize = _dwHeapSize;
        GetPrivatePerfCounters().m_Loading.cbLoaderHeapSize = _dwHeapSize;
#endif

        m_pMethodTable = pClass->GetMethodTable();
    }
    else
    {
        m_pMethodTable = NULL;
    }
        
    return hr;
}

//
// Virtual defaults
//

BYTE *Module::GetILCode(DWORD target) const
{
    return ResolveILRVA(target, FALSE);
}

void Module::ResolveStringRef(DWORD Token, EEStringData *pStringData) const
{  
    _ASSERTE(TypeFromToken(Token) == mdtString);

    BOOL tempIs80Plus;
    DWORD tempCharCount;
    pStringData->SetStringBuffer (m_pMDImport->GetUserString(Token, &tempCharCount, &tempIs80Plus));

    // MD and String look at this bit in opposite ways.  Here's where we'll do the conversion.
    // MD sets the bit to true if the string contains characters greater than 80.
    // String sets the bit to true if the string doesn't contain characters greater than 80.

    pStringData->SetCharCount(tempCharCount);
    pStringData->SetIsOnlyLowChars(!tempIs80Plus);
}

//
// Used by the verifier.  Returns whether this stringref is valid.  
//
BOOL Module::IsValidStringRef(DWORD token)
{
    if(TypeFromToken(token)==mdtString)
    {
        ULONG rid;
        if((rid = RidFromToken(token)) != 0)
        {
            if(m_pMDImport->IsValidToken(token)) return TRUE;
        }
    }
    return FALSE;
}

//
// Increase the size of one of the maps, such that it can handle a RID of at least "rid".
//
// This function must also check that another thread didn't already add a LookupMap capable
// of containing the same RID.
//
LookupMap *Module::IncMapSize(LookupMap *pMap, DWORD rid)
{
    LookupMap   *pPrev = NULL;
    DWORD       dwPrevMaxIndex = 0;

    m_pLookupTableCrst->Enter();

    // Check whether we can already handle this RID index
    do
    {
        if (rid < pMap->dwMaxIndex)
        {
            // Already there - some other thread must have added it
            m_pLookupTableCrst->Leave();
            return pMap;
        }

        dwPrevMaxIndex = pMap->dwMaxIndex;
        pPrev = pMap;
        pMap = pMap->pNext;
    } while (pMap != NULL);

    _ASSERTE(pPrev != NULL); // should never happen, because there's always at least one map

    DWORD dwMinNeeded = rid - dwPrevMaxIndex + 1; // Min # elements required for this chunk
    DWORD dwBlockSize = *pPrev->pdwBlockSize;   // Min # elements required by block size
    DWORD dwSizeToAllocate;                     // Actual number of elements we will allocate

    if (dwMinNeeded > dwBlockSize)
    {
        dwSizeToAllocate = dwMinNeeded;
    }
    else
    {
        dwSizeToAllocate = dwBlockSize;
        dwBlockSize <<= 1;                      // Increase block size
        *pPrev->pdwBlockSize = dwBlockSize;
    }

    if (m_pLookupTableHeap == NULL)
    {
        m_pLookupTableHeap = new (&m_LookupTableHeapInstance) 
          LoaderHeap(g_SystemInfo.dwPageSize, RIDMAP_COMMIT_SIZE);
        if (m_pLookupTableHeap == NULL)
        {
            m_pLookupTableCrst->Leave();
            return NULL;
        }
    }

    // @perf: This AllocMem() takes its own lock unnecessarily.  Should make an unlocked AllocMem() call.
    WS_PERF_SET_HEAP(LOOKUP_TABLE_HEAP);    
    LookupMap *pNewMap = (LookupMap *) m_pLookupTableHeap->AllocMem(sizeof(LookupMap) + dwSizeToAllocate*sizeof(void*));
    WS_PERF_UPDATE_DETAIL("LookupTableHeap", sizeof(LookupMap) + dwSizeToAllocate*sizeof(void*), pNewMap);
    if (pNewMap == NULL)
    {
        m_pLookupTableCrst->Leave();
        return NULL;
    }

    // NOTE: we don't need to zero fill the map since we VirtualAlloc()'d it

    pNewMap->pNext          = NULL;
    pNewMap->dwMaxIndex     = dwPrevMaxIndex + dwSizeToAllocate;
    pNewMap->pdwBlockSize   = pPrev->pdwBlockSize;

    // pTable is not a pointer to the beginning of the table.  Rather, anyone who uses Table can
    // simply index off their RID (as long as their RID is < dwMaxIndex, and they are not serviced
    // by a previous table for lower RIDs).
    pNewMap->pTable         = ((void **) (pNewMap + 1)) - dwPrevMaxIndex;

    // Link ourselves in
    pPrev->pNext            = pNewMap;

    m_pLookupTableCrst->Leave();
    return pNewMap;
}

BOOL Module::AddToRidMap(LookupMap *pMap, DWORD rid, void *pDatum)
{
    LookupMap *pMapStart = pMap;
    _ASSERTE(pMap != NULL);

    do
    {
        if (rid < pMap->dwMaxIndex)
        {
            pMap->pTable[rid] = pDatum;
            return TRUE;
        }

        pMap = pMap->pNext;
    } while (pMap != NULL);

    pMap = IncMapSize(pMapStart, rid);
    if (pMap == NULL)
        return NULL;

    pMap->pTable[rid] = pDatum;
    return TRUE;
}

void *Module::GetFromRidMap(LookupMap *pMap, DWORD rid)
{
    _ASSERTE(pMap != NULL);

    do
    {
        if (rid < pMap->dwMaxIndex)
        {
            if (pMap->pTable[rid] != NULL)
                return pMap->pTable[rid]; 
            else
                break;
        }

        pMap = pMap->pNext;
    } while (pMap != NULL);

    return NULL;
}

#ifdef _DEBUG
void Module::DebugGetRidMapOccupancy(LookupMap *pMap, DWORD *pdwOccupied, DWORD *pdwSize)
{
    DWORD       dwMinIndex = 0;

    *pdwOccupied = 0;
    *pdwSize     = 0;

    if(pMap == NULL) return;

    // Go through each linked block
    for (; pMap != NULL; pMap = pMap->pNext)
    {
        DWORD i;
        DWORD dwIterCount = pMap->dwMaxIndex - dwMinIndex;
        void **pRealTableStart = &pMap->pTable[dwMinIndex];

        for (i = 0; i < dwIterCount; i++)
        {
            if (pRealTableStart[i] != NULL)
                (*pdwOccupied)++;
        }

        (*pdwSize) += dwIterCount;

        dwMinIndex = pMap->dwMaxIndex;
    }
}

void Module::DebugLogRidMapOccupancy()
{
    DWORD dwOccupied1, dwSize1, dwPercent1;
    DWORD dwOccupied2, dwSize2, dwPercent2;
    DWORD dwOccupied3, dwSize3, dwPercent3;
    DWORD dwOccupied4, dwSize4, dwPercent4;
    DWORD dwOccupied5, dwSize5, dwPercent5;
    DWORD dwOccupied6, dwSize6, dwPercent6;
    DWORD dwOccupied7, dwSize7, dwPercent7;
    
    DebugGetRidMapOccupancy(&m_TypeDefToMethodTableMap, &dwOccupied1, &dwSize1);
    DebugGetRidMapOccupancy(&m_TypeRefToMethodTableMap, &dwOccupied2, &dwSize2);
    DebugGetRidMapOccupancy(&m_MethodDefToDescMap, &dwOccupied3, &dwSize3);
    DebugGetRidMapOccupancy(&m_FieldDefToDescMap, &dwOccupied4, &dwSize4);
    DebugGetRidMapOccupancy(&m_MemberRefToDescMap, &dwOccupied5, &dwSize5);
    DebugGetRidMapOccupancy(&m_FileReferencesMap, &dwOccupied6, &dwSize6);
    DebugGetRidMapOccupancy(&m_AssemblyReferencesMap, &dwOccupied7, &dwSize7);

    dwPercent1 = dwOccupied1 ? ((dwOccupied1 * 100) / dwSize1) : 0;
    dwPercent2 = dwOccupied2 ? ((dwOccupied2 * 100) / dwSize2) : 0;
    dwPercent3 = dwOccupied3 ? ((dwOccupied3 * 100) / dwSize3) : 0;
    dwPercent4 = dwOccupied4 ? ((dwOccupied4 * 100) / dwSize4) : 0;
    dwPercent5 = dwOccupied5 ? ((dwOccupied5 * 100) / dwSize5) : 0;
    dwPercent6 = dwOccupied6 ? ((dwOccupied6 * 100) / dwSize6) : 0;
    dwPercent7 = dwOccupied7 ? ((dwOccupied7 * 100) / dwSize7) : 0;

    LOG((
        LF_EEMEM, 
        INFO3, 
        "   Map occupancy:\n"
        "      TypeDefToEEClass map: %4d/%4d (%2d %%)\n"
        "      TypeRefToEEClass map: %4d/%4d (%2d %%)\n"
        "      MethodDefToDesc map:  %4d/%4d (%2d %%)\n"
        "      FieldDefToDesc map:  %4d/%4d (%2d %%)\n"
        "      MemberRefToDesc map:  %4d/%4d (%2d %%)\n"
        "      FileReferences map:  %4d/%4d (%2d %%)\n"
        "      AssemblyReferences map:  %4d/%4d (%2d %%)\n"
        ,
        dwOccupied1, dwSize1, dwPercent1,
        dwOccupied2, dwSize2, dwPercent2,
        dwOccupied3, dwSize3, dwPercent3,
        dwOccupied4, dwSize4, dwPercent4,
        dwOccupied5, dwSize5, dwPercent5,
        dwOccupied6, dwSize6, dwPercent6,
        dwOccupied7, dwSize7, dwPercent7

    ));
}
#endif



LPVOID Module::GetMUThunk(LPVOID pUnmanagedIp, PCCOR_SIGNATURE pSig, ULONG cSig)
{
    if (m_pMUThunkHash == NULL)
    {
        MUThunkHash *pMUThunkHash = new MUThunkHash(this);
        if (VipInterlockedCompareExchange( (void*volatile*)&m_pMUThunkHash, pMUThunkHash, NULL) != NULL)
        {
            delete pMUThunkHash;
        }
    }
    return m_pMUThunkHash->GetMUThunk(pUnmanagedIp, pSig, cSig);
}

LPVOID Module::GetUMThunk(LPVOID pManagedIp, PCCOR_SIGNATURE pSig, ULONG cSig)
{
    LPVOID pThunk = FindUMThunkInFixups(pManagedIp, pSig, cSig);
    if (pThunk)
    {
        return pThunk;
    }
    if (m_pUMThunkHash == NULL)
    {
        UMThunkHash *pUMThunkHash = new UMThunkHash(this, GetAppDomain());
        if (VipInterlockedCompareExchange( (void*volatile*)&m_pUMThunkHash, pUMThunkHash, NULL) != NULL)
        {
            delete pUMThunkHash;
        }
    }
    return m_pUMThunkHash->GetUMThunk(pManagedIp, pSig, cSig);
}

//
// FindFunction finds a MethodDesc for a global function methoddef or ref
//

MethodDesc *Module::FindFunction(mdToken pMethod)
{
    MethodDesc* pMethodDesc = NULL;

    BEGIN_ENSURE_COOPERATIVE_GC();
    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);
        
    HRESULT hr = E_FAIL;
    
    COMPLUS_TRY
      {
        hr = EEClass::GetMethodDescFromMemberRef(this, pMethod, &pMethodDesc, &throwable);
      }
    COMPLUS_CATCH
      {
        throwable = GETTHROWABLE();
      }
    COMPLUS_END_CATCH

    if(FAILED(hr) || throwable != NULL) 
    {
        pMethodDesc = NULL;
#ifdef _DEBUG
        LPCUTF8 pszMethodName = CEEInfo::findNameOfToken(this, pMethod);
        LOG((LF_IJW, 
             LL_INFO10, "Failed to find Method: %s for Vtable Fixup\n", pszMethodName));
#endif
    }

    GCPROTECT_END();
    END_ENSURE_COOPERATIVE_GC();
        
    return pMethodDesc;
}

OBJECTREF Module::GetLinktimePermissions(mdToken token, OBJECTREF *prefNonCasDemands)
{
    OBJECTREF refCasDemands = NULL;
    GCPROTECT_BEGIN(refCasDemands);

    SecurityHelper::GetDeclaredPermissions(
        GetMDImport(),
        token,
        dclLinktimeCheck,
        &refCasDemands);

    SecurityHelper::GetDeclaredPermissions(
        GetMDImport(),
        token,
        dclNonCasLinkDemand,
        prefNonCasDemands);

    GCPROTECT_END();
    return refCasDemands;
}

OBJECTREF Module::GetInheritancePermissions(mdToken token, OBJECTREF *prefNonCasDemands)
{
    OBJECTREF refCasDemands = NULL;
    SecurityHelper::GetDeclaredPermissions(
        GetMDImport(),
        token,
        dclInheritanceCheck,
        &refCasDemands);

    SecurityHelper::GetDeclaredPermissions(
        GetMDImport(),
        token,
        dclNonCasInheritance,
        prefNonCasDemands);

    return refCasDemands;
}

OBJECTREF Module::GetCasInheritancePermissions(mdToken token)
{
    OBJECTREF refCasDemands = NULL;
    SecurityHelper::GetDeclaredPermissions(
        GetMDImport(),
        token,
        dclInheritanceCheck,
        &refCasDemands);
    return refCasDemands;
}

OBJECTREF Module::GetNonCasInheritancePermissions(mdToken token)
{
    OBJECTREF refNonCasDemands = NULL;
    SecurityHelper::GetDeclaredPermissions(
        GetMDImport(),
        token,
        dclNonCasInheritance,
        &refNonCasDemands);
    return refNonCasDemands;
}

#ifdef DEBUGGING_SUPPORTED
void Module::NotifyDebuggerLoad()
{
    if (!CORDebuggerAttached())
        return;

    // This routine iterates through all domains which contain its 
    // assembly, and send a debugger notify in them.
    // @perf: it would scale better if we directly knew which domains
    // the assembly was loaded in.

    // Note that if this is the LoadModule of an assembly manifeset, we expect to 
    // NOT send the module load for our own app domain here - instead it 
    // will be sent from the NotifyDebuggerAttach call called from 
    // Assembly::NotifyDebuggerAttach.
    //
    // @todo: there is a fragility in the code that if in fact we do send it here, 
    // the right side of the debugger will ignore it (since there's been no assembly
    // load yet), but the left side will suppress the second load module event (since
    // we've already loaded symbols.)  Thus the event gets dropped on the floor.

    AppDomainIterator i;
    
    while (i.Next())
    {
        AppDomain *pDomain = i.GetDomain();

        if (pDomain->IsDebuggerAttached() 
            && (GetDomain() == SystemDomain::System()
                || pDomain->ShouldContainAssembly(m_pAssembly, FALSE) == S_OK))
            NotifyDebuggerAttach(pDomain, ATTACH_ALL, FALSE);
    }
}

BOOL Module::NotifyDebuggerAttach(AppDomain *pDomain, int flags, BOOL attaching)
{
    if (!attaching && !pDomain->IsDebuggerAttached())
        return FALSE;

    // We don't notify the debugger about modules that don't contain any code.
    if (IsResource())
        return FALSE;
    
    BOOL result = FALSE;

    HRESULT hr = S_OK;

    LPCWSTR module = NULL;
    IMAGE_COR20_HEADER* pHeader = NULL;

    // Grab the file name
    module = GetFileName();

    // We need to check m_file directly because the debugger
    // can be called before the module is setup correctly
    if(m_file) 
        pHeader = m_file->GetCORHeader();
        
    if (FAILED(hr))
        return result;

    // Due to the wacky way in which modules/assemblies are loaded,
    // it is possible that a module is loaded before its corresponding
    // assembly has been loaded. We will defer sending the load
    // module event till after the assembly has been loaded and a 
    // load assembly event has been sent.
    if (GetClassLoader()->GetAssembly() != NULL)
    {
        if (flags & ATTACH_MODULE_LOAD)
        {
            g_pDebugInterface->LoadModule(this, 
                                          pHeader,
                                          GetILBase(),
                                          module, (DWORD)wcslen(module),
                                          GetAssembly(), pDomain,
                                          attaching);

            result = TRUE;
        }
        
        if (flags & ATTACH_CLASS_LOAD)
        {
            LookupMap *pMap;
            DWORD       dwMinIndex = 0;

            // Go through each linked block
            for (pMap = &m_TypeDefToMethodTableMap; pMap != NULL;
                 pMap = pMap->pNext)
            {
                DWORD i;
                DWORD dwIterCount = pMap->dwMaxIndex - dwMinIndex;
                void **pRealTableStart = &pMap->pTable[dwMinIndex];

                for (i = 0; i < dwIterCount; i++)
                {
                    MethodTable *pMT = (MethodTable *) (pRealTableStart[i]);

                    if (pMT != NULL && pMT->GetClass()->IsRestored())
                    {
                        EEClass *pClass = pMT->GetClass();

                        result = pClass->NotifyDebuggerAttach(pDomain, attaching) || result;
                    }
                }

                dwMinIndex = pMap->dwMaxIndex;
            }
            
            // Send a load event for the module's method table, if necessary.

            if (GetMethodTable() != NULL)
            {
                MethodTable *pMT = GetMethodTable();

                if (pMT != NULL && pMT->GetClass()->IsRestored())
                    result = pMT->GetClass()->NotifyDebuggerAttach(pDomain, attaching) || result;
            }

        }
    }

    return result;
}

void Module::NotifyDebuggerDetach(AppDomain *pDomain)
{
    if (!pDomain->IsDebuggerAttached())
        return;
        
    // We don't notify the debugger about modules that don't contain any code.
    if (IsResource())
        return;
    
    LookupMap  *pMap;
    DWORD       dwMinIndex = 0;

    // Go through each linked block
    for (pMap = &m_TypeDefToMethodTableMap; pMap != NULL;
         pMap = pMap->pNext)
    {
        DWORD i;
        DWORD dwIterCount = pMap->dwMaxIndex - dwMinIndex;
        void **pRealTableStart = &pMap->pTable[dwMinIndex];

        for (i = 0; i < dwIterCount; i++)
        {
            MethodTable *pMT = (MethodTable *) (pRealTableStart[i]);

            if (pMT != NULL && pMT->GetClass()->IsRestored())
            {
                EEClass *pClass = pMT->GetClass();

                pClass->NotifyDebuggerDetach(pDomain);
            }
        }

        dwMinIndex = pMap->dwMaxIndex;
    }

    // Send a load event for the module's method table, if necessary.

    if (GetMethodTable() != NULL)
    {
        MethodTable *pMT = GetMethodTable();

        if (pMT != NULL && pMT->GetClass()->IsRestored())
            pMT->GetClass()->NotifyDebuggerDetach(pDomain);
    }
    
    g_pDebugInterface->UnloadModule(this, pDomain);
}
#endif // DEBUGGING_SUPPORTED

// Fixup vtables stored in the header to contain pointers to method desc
// prestubs rather than metadata method tokens.
void Module::FixupVTables(OBJECTREF *pThrowable)
{
#ifndef _X86_
    // The use of the thunk table means this'll probably have to be rethought
    // for alpha. Sorry Larry.
#ifndef _IA64_
    //
    // @TODO_IA64: examine this for IA64 once needed
    //
    _ASSERTE(!"@TODO Alpha - FixupVTables(CeeLoad.Cpp)");
#endif
#endif

    // @todo: HACK!
    // If we are compiling in-process, we don't want to fixup the vtables - as it
    // will have side effects on the other copy of the module!
    if (SystemDomain::GetCurrentDomain()->IsCompilationDomain())
        return;

    IMAGE_COR20_HEADER *pHeader = GetCORHeader();

    // Check for no entries at all.
    if ((pHeader == NULL) || (pHeader->VTableFixups.VirtualAddress == 0))
        return;

    // Locate the base of the fixup entries in virtual memory.
    IMAGE_COR_VTABLEFIXUP *pFixupTable;
    pFixupTable = (IMAGE_COR_VTABLEFIXUP *)(GetILBase() + pHeader->VTableFixups.VirtualAddress);
    int iFixupRecords = pHeader->VTableFixups.Size / sizeof(IMAGE_COR_VTABLEFIXUP);

    // We need to construct a thunk table to handle backpatching. So we have to
    // make an initial pass at the fixup entries to determine how many thunks
    // we'll need.
    int iThunks = 0;

   // No records then return
    if (iFixupRecords == 0) return;

    // Take a global lock before fixing up the module
    SystemDomain::Enter();

    // See if we are the first app domain to load the module.  If not, we skip this initialization.
    // (Note that in such a case all of the thunks for the module will marshal us into the earlier domain.)

    Module* pModule = SystemDomain::System()->FindModuleInProcess(GetILBase(), this);
    DWORD dwIndex=0;
    if (pModule == NULL) 
    {
        // This is the app domain which all of our U->M thunks for this module will have 
        // affinity with.  Note that if the module is shared between multiple domains, all thunks will marshal back
        // to the original domain, so some of the thunks may cause a surprising domain switch to occur.  
        // (And furthermore note that if the original domain is unloaded, all the thunks will simply throw an 
        // exception.) This is unfortunate, but the most sane behavior we could come up with.  (In an insane world, 
        // only the sane man will appear insane.  Or maybe it's the other way around - I never can remember that.) 
        // 
        // (The essential problem is that these thunks are shared via the global process address space
        // rather than per domain, thus there is no context to figure out our domain from.  We could
        // use the current thread's domain, but that is effectively undefined in unmanaged space.)
        //
        // The bottom line is that the IJW model just doesn't fit with multiple app domain design very well, so 
        // better to have well defined limitations than flaky behavior.
        // 
        // -seantrow

        AppDomain *pAppDomain = GetAppDomain();

        DWORD numEATEntries;
        BYTE *pEATJArray = FindExportAddressTableJumpArray(GetILBase(), &numEATEntries);
        BYTE * pEATJArrayStart = pEATJArray;
        if (pEATJArray)
        {
            DWORD nEATEntry = numEATEntries;
            while (nEATEntry--)
            {
                EATThunkBuffer *pEATThunkBuffer = (EATThunkBuffer*) pEATJArray;

                mdToken md = pEATThunkBuffer->GetToken();
                if (Beta1Hack_LooksLikeAMethodDef(md))
                {
                    if(!m_pMDImport->IsValidToken(md))
                    {
                        SystemDomain::Leave();

                        LPCUTF8 szFileName;
                        Thread      *pCurThread = GetThread();
                        m_pAssembly->GetName(&szFileName);

                        #define  MAKE_TRANSLATIONFAILED pwzAssemblyName=L""
                        MAKE_WIDEPTR_FROMUTF8_FORPRINT(pwzAssemblyName, szFileName);
                        #undef  MAKE_TRANSLATIONFAILED

                        PostTypeLoadException(NULL,(LPCUTF8)"VTFixup Table",pwzAssemblyName,
                            (LPCUTF8)"Invalid token in v-table fix-up table",IDS_CLASSLOAD_GENERIC,pThrowable);
                        return;
                    }

                    MethodDesc *pMD = FindFunction(md);
                    _ASSERTE(pMD != NULL && "Invalid token in EAT Jump Buffer, use ildasm to find code gen error");
                    
                    
                    LOG((LF_IJW, LL_INFO10, "EAT  thunk for \"%s\" (target = 0x%lx)\n", 
                         pMD->m_pszDebugMethodName, pMD->GetAddrofCode()));

                    // @TODO: Check for out of memory
                    UMEntryThunk *pUMEntryThunk = (UMEntryThunk*)(GetThunkHeap()->AllocMem(sizeof(UMEntryThunk)));
                    _ASSERTE(pUMEntryThunk != NULL);
                    FillMemory(pUMEntryThunk,     sizeof(*pUMEntryThunk),     0);
                    
                    // @TODO: Check for out of memory
                    UMThunkMarshInfo *pUMThunkMarshInfo = (UMThunkMarshInfo*)(GetThunkHeap()->AllocMem(sizeof(UMThunkMarshInfo)));
                    _ASSERTE(pUMThunkMarshInfo != NULL);
                    FillMemory(pUMThunkMarshInfo, sizeof(*pUMThunkMarshInfo), 0);
                    
                    BYTE nlType = 0;
                    CorPinvokeMap unmgdCallConv;
                    
                    {
                        DWORD   mappingFlags = 0xcccccccc;
                        LPCSTR  pszImportName = (LPCSTR)POISONC;
                        mdModuleRef modref = 0xcccccccc;
                        HRESULT hr = GetMDImport()->GetPinvokeMap(md, &mappingFlags, &pszImportName, &modref);
                        if (FAILED(hr))
                        {
                            unmgdCallConv = (CorPinvokeMap)0;
                            nlType = nltAnsi;
                        }
                        else
                        {
                        
                            unmgdCallConv = (CorPinvokeMap)(mappingFlags & pmCallConvMask);
                            if (unmgdCallConv == pmCallConvWinapi)
                            {
                                unmgdCallConv = pmCallConvStdcall;
                            }
                        
                            switch (mappingFlags & (pmCharSetNotSpec|pmCharSetAnsi|pmCharSetUnicode|pmCharSetAuto))
                            {
                                case pmCharSetNotSpec: //fallthru to Ansi
                                case pmCharSetAnsi:
                                    nlType = nltAnsi;
                                    break;
                                case pmCharSetUnicode:
                                    nlType = nltUnicode;
                                    break;
                                case pmCharSetAuto:
                                    nlType = (NDirectOnUnicodeSystem() ? nltUnicode : nltAnsi);
                                    break;
                                default:
                                    //@bug: Bogus! But I can't report an error from here!
                                   _ASSERTE(!"Bad charset specified in Vtablefixup Pinvokemap.");
                            }
                        }
                        
                    }
                    
                    PCCOR_SIGNATURE pSig;
                    DWORD cSig;
                    pMD->GetSig(&pSig, &cSig);
                    pUMThunkMarshInfo->LoadTimeInit(pSig,
                                                    cSig,
                                                    this,
                                                    TRUE,
                                                    nlType,
                                                    unmgdCallConv,
                                                    md);

                    pUMEntryThunk->LoadTimeInit(NULL, NULL, pUMThunkMarshInfo, pMD, pAppDomain->GetId());

                    pEATThunkBuffer->SetTarget( (LPVOID)(pUMEntryThunk->GetCode()) );

                }
                pEATJArray = pEATJArray + IMAGE_COR_EATJ_THUNK_SIZE;
            }
        }


        // Each fixup entry describes a vtable (each slot contains a metadata token
        // at this stage).
        for (int iFixup = 0; iFixup < iFixupRecords; iFixup++)
            iThunks += pFixupTable[iFixup].Count;
        
        // Allocate the thunk table, we'll initialize it as we go.
        m_pThunkTable = new (nothrow) BYTE [iThunks * 6];
        if (m_pThunkTable == NULL) {
            SystemDomain::Leave();
            PostOutOfMemoryException(pThrowable);
            return;
        }
        
        // Now to fill in the thunk table.
        BYTE *pThunk = m_pThunkTable;
        for (iFixup = 0; iFixup < iFixupRecords; iFixup++) {
            
            // Vtables can be 32 or 64 bit.
            if (pFixupTable[iFixup].Type == COR_VTABLE_32BIT) {
                
                mdToken *pTokens = (mdToken *)(GetILBase() + pFixupTable[iFixup].RVA);
                const BYTE **pPointers = (const BYTE **)pTokens;
                
                for (int iMethod = 0; iMethod < pFixupTable[iFixup].Count; iMethod++) {
                    if(!m_pMDImport->IsValidToken(pTokens[iMethod]))
                    {
                        SystemDomain::Leave();

                        LPCUTF8 szFileName;
                        Thread      *pCurThread = GetThread();
                        m_pAssembly->GetName(&szFileName);
                        #define  MAKE_TRANSLATIONFAILED pwzAssemblyName=L""
                        MAKE_WIDEPTR_FROMUTF8_FORPRINT(pwzAssemblyName, szFileName);
                        #undef  MAKE_TRANSLATIONFAILED

                        PostTypeLoadException(NULL,(LPCUTF8)"VTFixup Table",pwzAssemblyName,
                            (LPCUTF8)"Invalid token in v-table fix-up table",IDS_CLASSLOAD_GENERIC,pThrowable);
                        return;
                    }
                    MethodDesc *pMD = FindFunction(pTokens[iMethod]);
                    _ASSERTE(pMD != NULL);
                    
#ifdef _DEBUG
                    if (pMD->IsNDirect()) {
                        LOG((LF_IJW, LL_INFO10, "[0x%lx] <-- PINV thunk for \"%s\" (target = 0x%lx)\n",(size_t)&(pTokens[iMethod]),  pMD->m_pszDebugMethodName, (size_t) (((NDirectMethodDesc*)pMD)->ndirect.m_pNDirectTarget)));
                    }
#endif
                    // Thunk the vtable slots through the single large vtable
                    // created on the module. It is this large vtable that gets
                    // backpatched as a result of jitting. This obviously causes an
                    // extra level of indirection, but it relieves us of some very
                    // tricky problems concerning backpatching duplicates across
                    // multiple vtables.
                    
                    // Point the local vtable slot to the thunk we're about to
                    // create.
                    pPointers[iMethod] = pThunk;
                    
                    // First a JMP instruction.
                    *(WORD*)pThunk = 0x25FF;
                    pThunk += 2;
                    
                    // Then the jump target (the module vtable slot address).
                    *(SLOT**)pThunk = GetMethodTable()->GetClass()->GetMethodSlot(pMD);
                    pThunk += sizeof(SLOT*);
                }
                
            } else if (pFixupTable[iFixup].Type == COR_VTABLE_64BIT)
                _ASSERTE(!"64-bit vtable fixups NYI");
            else if (pFixupTable[iFixup].Type == (COR_VTABLE_32BIT|COR_VTABLE_FROM_UNMANAGED)) {
                
                mdToken *pTokens = (mdToken *)(GetILBase() + pFixupTable[iFixup].RVA);
                const BYTE **pPointers = (const BYTE **)pTokens;
                
                for (int iMethod = 0; iMethod < pFixupTable[iFixup].Count; iMethod++) {
                    mdToken tok = pTokens[iMethod];

                    const BYTE *pPrevThunk = NULL;
                    if(!m_pMDImport->IsValidToken(tok))
                    {
                        SystemDomain::Leave();

                        LPCUTF8 szFileName;
                        Thread      *pCurThread = GetThread();
                        m_pAssembly->GetName(&szFileName);
                        #define  MAKE_TRANSLATIONFAILED pwzAssemblyName=L""
                        MAKE_WIDEPTR_FROMUTF8_FORPRINT(pwzAssemblyName, szFileName);
                        #undef  MAKE_TRANSLATIONFAILED

                        PostTypeLoadException(NULL,(LPCUTF8)"VTFixup Table",pwzAssemblyName,
                            (LPCUTF8)"Invalid token in v-table fix-up table",IDS_CLASSLOAD_GENERIC,pThrowable);
                        return;
                    }
                    pEATJArray = pEATJArrayStart;
                    if (pEATJArray)
                    {
                        DWORD nEATEntry = numEATEntries;
                        while (nEATEntry--)
                        {
                            EATThunkBuffer *pEATThunkBuffer = (EATThunkBuffer*) pEATJArray;

                            mdToken md = pEATThunkBuffer->GetToken();
                            if (Beta1Hack_LooksLikeAMethodDef(md))
                            {
                                if ( md == tok )
                                {
                                    pPrevThunk = (const BYTE *)(pEATThunkBuffer->GetTarget());
                                    break;
                                }
                            }
                            pEATJArray = pEATJArray + IMAGE_COR_EATJ_THUNK_SIZE;
                        }
                    }

                    if (pPrevThunk)
                        pPointers[iMethod] = pPrevThunk;
                    else
                    {
                        mdToken mdtoken = pTokens[iMethod];
                        MethodDesc *pMD = FindFunction(pTokens[iMethod]);
                        _ASSERTE(pMD != NULL && "Invalid token in v-table fix-up table, use ildasm to find code gen error");
                        
                        
                        LOG((LF_IJW, LL_INFO10, "[0x%lx] <-- EAT  thunk for \"%s\" (target = 0x%lx)\n", (size_t)&(pTokens[iMethod]), pMD->m_pszDebugMethodName, pMD->GetAddrofCode()));
                        
    
                        // @TODO: Check for out of memory
                        UMEntryThunk *pUMEntryThunk = (UMEntryThunk*)(GetThunkHeap()->AllocMem(sizeof(UMEntryThunk)));
                        _ASSERTE(pUMEntryThunk != NULL);
                        FillMemory(pUMEntryThunk,     sizeof(*pUMEntryThunk),     0);
    
                        // @TODO: Check for out of memory
                        UMThunkMarshInfo *pUMThunkMarshInfo = (UMThunkMarshInfo*)(GetThunkHeap()->AllocMem(sizeof(UMThunkMarshInfo)));
                        _ASSERTE(pUMThunkMarshInfo != NULL);
                        FillMemory(pUMThunkMarshInfo, sizeof(*pUMThunkMarshInfo), 0);
                        
                        BYTE nlType = 0;
                        CorPinvokeMap unmgdCallConv;
                        
                        {
                            DWORD   mappingFlags = 0xcccccccc;
                            LPCSTR  pszImportName = (LPCSTR)POISONC;
                            mdModuleRef modref = 0xcccccccc;
                            HRESULT hr = GetMDImport()->GetPinvokeMap(pTokens[iMethod], &mappingFlags, &pszImportName, &modref);
                            if (FAILED(hr))
                            {
                                unmgdCallConv = (CorPinvokeMap)0;
                                nlType = nltAnsi;
                            }
                            else
                            {
                            
                                unmgdCallConv = (CorPinvokeMap)(mappingFlags & pmCallConvMask);
                                if (unmgdCallConv == pmCallConvWinapi)
                                {
                                    unmgdCallConv = pmCallConvStdcall;
                                }
                            
                                switch (mappingFlags & (pmCharSetNotSpec|pmCharSetAnsi|pmCharSetUnicode|pmCharSetAuto))
                                {
                                    case pmCharSetNotSpec: //fallthru to Ansi
                                    case pmCharSetAnsi:
                                        nlType = nltAnsi;
                                        break;
                                    case pmCharSetUnicode:
                                        nlType = nltUnicode;
                                        break;
                                    case pmCharSetAuto:
                                        nlType = (NDirectOnUnicodeSystem() ? nltUnicode : nltAnsi);
                                        break;
                                    default:
                                        //@bug: Bogus! But I can't report an error from here!
                                        _ASSERTE(!"Bad charset specified in Vtablefixup Pinvokemap.");
                                
                                }
                            }
                            
                            
                        }
                        
                        PCCOR_SIGNATURE pSig;
                        DWORD cSig;
                        pMD->GetSig(&pSig, &cSig);
                        pUMThunkMarshInfo->LoadTimeInit(pSig, 
                                                        cSig,
                                                        this,
                                                        TRUE,
                                                        nlType,
                                                        unmgdCallConv,
                                                        mdtoken);
    
                        pUMEntryThunk->LoadTimeInit(NULL, NULL, pUMThunkMarshInfo, pMD, pAppDomain->GetId());
                        
                        pPointers[iMethod] = pUMEntryThunk->GetCode();
                    }
                }
            }
            else
                if (pFixupTable[iFixup].Type == (COR_VTABLE_32BIT|COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN))
                {
                        
                       mdToken *pTokens = (mdToken *)(GetILBase() + pFixupTable[iFixup].RVA);
                        const BYTE **pPointers = (const BYTE **)pTokens;
                
                        for (int iMethod = 0; iMethod < pFixupTable[iFixup].Count; iMethod++) 
                        {
                            mdToken tok = pTokens[iMethod];
                            pPointers[iMethod] = (new IJWNOADThunk(GetILBase(),GetAssembly()->GetManifestModule()->GetILBase(),dwIndex++,tok))->GetCode();
                        }
                }
                else
                _ASSERTE(!"Unknown vtable fixup type");
        }

        // Create the UMThunkHash here, specifically so we can remember our app domain affinity
        m_pUMThunkHash = new UMThunkHash(this, pAppDomain);
    }
    if(GetAssembly()->IsShared())
    {
        m_pADThunkTableDLSIndexForSharedClasses = SharedDomain::GetDomain()->AllocateSharedClassIndices(1);
        if (FAILED(GetAppDomain()->GetDomainLocalBlock()->SafeEnsureIndex(m_pADThunkTableDLSIndexForSharedClasses)))
            PostOutOfMemoryException(pThrowable);
    }
    else
        CreateDomainThunks();

    SystemDomain::Leave();
}

HRESULT Module::ExpandAll(DataImage *image)
{
    HRESULT         hr;
    HENUMInternal   hEnum;
    mdToken         tk;
    ClassLoader     *pLoader = GetClassLoader();

    // disable gc before collecting exceptions
    BEGIN_ENSURE_COOPERATIVE_GC();

    OBJECTREF throwable = NULL;
    GCPROTECT_BEGIN(throwable);

    // 
    // Explicitly load the global parent class.
    //

    if (m_pMethodTable != NULL)
    {
        NameHandle name(this, COR_GLOBAL_PARENT_TOKEN);
        pLoader->LoadTypeHandle(&name, &throwable);
        if (throwable != NULL)
        {
            IfFailGo(image->Error(COR_GLOBAL_PARENT_TOKEN, SecurityHelper::MapToHR(throwable), &throwable));
            throwable = NULL;
        }
    }

    //
    // Load all classes.  This also fills out the
    // RID maps for the typedefs, method defs, 
    // and field defs.
    // 
        
    IfFailGo(m_pMDImport->EnumTypeDefInit(&hEnum));

    while (m_pMDImport->EnumTypeDefNext(&hEnum, &tk))
    {
        NameHandle name(this, tk);
        pLoader->LoadTypeHandle(&name, &throwable);
        if (throwable != NULL)
        {
            IfFailGo(image->Error(tk, SecurityHelper::MapToHR(throwable), &throwable));
            throwable = NULL;
        }
    }
    m_pMDImport->EnumTypeDefClose(&hEnum);

    //
    // Fill out TypeRef RID map
    //

    IfFailGo(m_pMDImport->EnumAllInit(mdtTypeRef, &hEnum));

    while (m_pMDImport->EnumNext(&hEnum, &tk))
    {
        NameHandle name(this, tk);
        pLoader->LoadTypeHandle(&name, &throwable);
        if (throwable != NULL)
        {
            IfFailGo(image->Error(tk, SecurityHelper::MapToHR(throwable), &throwable));
            throwable = NULL;
        }
    }
    m_pMDImport->EnumClose(&hEnum);

    //
    // Fill out MemberRef RID map and va sig cookies for
    // varargs member refs.
    //

    IfFailGo(m_pMDImport->EnumAllInit(mdtMemberRef, &hEnum));

    while (m_pMDImport->EnumNext(&hEnum, &tk))
    {
        void *desc;
        BOOL fIsMethod;

        COMPLUS_TRY
          {
              EEClass::GetDescFromMemberRef(this, tk,
                                            &desc, &fIsMethod, &throwable);
          }
        COMPLUS_CATCH
          {
              throwable = GETTHROWABLE();
          }
        COMPLUS_END_CATCH

        if (throwable != NULL)
        {
            IfFailGo(image->Error(tk, SecurityHelper::MapToHR(throwable), &throwable));
            throwable = NULL;
        }
    }
    m_pMDImport->EnumClose(&hEnum);

    //
    // Fill out binder
    //

    if (m_pBinder != NULL)
        m_pBinder->BindAll();

 ErrExit:

    GCPROTECT_END();
            
    END_ENSURE_COOPERATIVE_GC();

    return hr;
}

HRESULT Module::Save(DataImage *image, mdToken *pSaveOrderArray, DWORD cSaveOrderArray)
{   
    HRESULT hr;

    //
    // Save the module
    //

    IfFailRet(image->StoreStructure(this, sizeof(Module),
                                    DataImage::SECTION_MODULE,
                                    DataImage::DESCRIPTION_MODULE));
    
    // 
    // Save padding for an EnC module, in case we want to use the zap
    // in that mode at runtime.
    //

    IfFailRet(image->Pad(sizeof(EditAndContinueModule) - sizeof(Module),
                         DataImage::SECTION_MODULE,
                         DataImage::DESCRIPTION_MODULE));
    
    //
    // If we are install-o-jitting, we don't need to keep a list of va
    // sig cookies, as we already have a complete set (of course we do
    // have to persist the cookies themselves, though.
    //

    //
    // Initialize maps of child data structures.  Note that each tables's blocks are
    // concantentated to a single block in the process.
    //

    IfFailRet(m_TypeDefToMethodTableMap.Save(image, mdTypeDefNil));
    IfFailRet(m_TypeRefToMethodTableMap.Save(image));
    IfFailRet(m_MethodDefToDescMap.Save(image, mdMethodDefNil));
    IfFailRet(m_FieldDefToDescMap.Save(image, mdFieldDefNil));
    IfFailRet(m_MemberRefToDescMap.Save(image));

    //
    // Also save the parent maps; the contents will 
    // need to be rewritten, but we can allocate the
    // space in the image.
    //

    IfFailRet(m_FileReferencesMap.Save(image));
    IfFailRet(m_AssemblyReferencesMap.Save(image));

    if (m_pBinder != NULL)
        IfFailRet(m_pBinder->Save(image));

    // 
    // Store classes.  First store classes listed in the store order array,
    // then store the rest of the classes.
    //

    mdToken *pSaveOrderArrayEnd = pSaveOrderArray + cSaveOrderArray;
    while (pSaveOrderArray < pSaveOrderArrayEnd)
    {
        mdToken token = *pSaveOrderArray;
        if (TypeFromToken(token) == mdtTypeDef)
        {
            MethodTable *pMT = LookupTypeDef(token).AsMethodTable();
            if (pMT != NULL && !image->IsStored(pMT))
                IfFailRet(pMT->Save(image));
        }
        pSaveOrderArray++;
    }

    int maxVirtualSlots = 0;

    LookupMap *m = &m_TypeDefToMethodTableMap;
    DWORD index = 0;
    while (m != NULL)
    {
        MethodTable **pTable = ((MethodTable**) m->pTable) + index;
        MethodTable **pTableEnd = ((MethodTable**) m->pTable) + m->dwMaxIndex;

        while (pTable < pTableEnd)
        {
            MethodTable *t = *pTable++;
            if (t != NULL)
            {
                if (pSaveOrderArray == NULL || !image->IsStored(t))
                    IfFailRet(t->Save(image));

                //
                // Compute the maximum vtable slot index which can be inherited from
                // another module.
                // The size of the vtable of the first parent which is in another
                // module is a starting point.
                //

                EEClass *pParentClass = t->GetClass()->GetParentClass();
                EEClass *pOtherModuleClass = pParentClass;
                while (pOtherModuleClass != NULL && pOtherModuleClass->GetModule() == this)
                    pOtherModuleClass = pOtherModuleClass->GetParentClass();

                if (pOtherModuleClass != NULL && pOtherModuleClass->GetNumVtableSlots() > maxVirtualSlots)
                    maxVirtualSlots = pOtherModuleClass->GetNumVtableSlots();

                //
                // Now, consider our interfaces - interfaces may inherit methods from earlier
                // sections of the parent's vtable, or from a different vtable.
                //
                
                if (!t->IsInterface()
                    && (pOtherModuleClass != NULL || t->IsComObjectType() || t->GetClass()->IsAbstract()))
                {
                    InterfaceInfo_t *pInterface = t->m_pIMap;
                    InterfaceInfo_t *pInterfaceEnd = pInterface + t->m_wNumInterface;

                    while (pInterface < pInterfaceEnd)
                    {
                        if (pInterface->m_wStartSlot >= pParentClass->GetNumVtableSlots())
                        {
                            //
                            // Only consider interfaces which weren't copied from our parent class. 
                            // (Other interfaces have already been covered by the above logic.)
                            //

                            MethodTable *pMT = pInterface->m_pMethodTable;
                            BOOL canInherit = FALSE;

                            
                            // 
                            // It's actually possible to inherit a method from our parent, even
                            // if the parent doesn't know about our implementation.  So we 
                            // just assume that any interface implementatio can contain
                            // inherited slots.
                            //

                            if (pOtherModuleClass != NULL)
                                canInherit = TRUE;
                            else if (t->IsComObjectType() || t->GetClass()->IsAbstract())
                            {
                                //
                                // If we are a COM wrapper class or an abstract class, we can directly inherit slots 
                                // from our interfaces.
                                //

                                EEClass *pInterfaceClass = pMT->GetClass();
                                while (pInterfaceClass != NULL)
                                {
                                    if (pInterfaceClass->GetModule() != this)
                                    {
                                        canInherit = TRUE;
                                        break;
                                    }
                                    pInterfaceClass = pInterfaceClass->GetParentClass();
                                }
                            }

                            //
                            // If we can inherit from outside the module in this interface,
                            // make sure we have enough space in the fixup table for all of the
                            // interface slots for this interface.
                            //

                            if (canInherit)
                            {
                                int maxInterfaceSlot 
                                  = pInterface->m_wStartSlot + pMT->GetClass()->GetNumVtableSlots();
                                if (maxInterfaceSlot > maxVirtualSlots)
                                    maxVirtualSlots = maxInterfaceSlot;
                            }
                        }

                        pInterface++;
                    }
                }
            }
        }

        index = m->dwMaxIndex;
        m = m->pNext;
    }

    //
    // Allocate jump target table
    // @todo: really isn't necessary to allocate the table in the "live" module,
    // but it's the easiest thing to do.
    //
    // Note that this must be stored last, since this space is associated
    // with a different stub manager.
    //

    m_cJumpTargets = maxVirtualSlots;

    if (m_cJumpTargets > 0)
    {
        ULONG size = X86JumpTargetTable::ComputeSize(maxVirtualSlots);
        m_pJumpTargetTable = new BYTE [size];
        if (m_pJumpTargetTable == NULL)
            return E_OUTOFMEMORY;

        IfFailRet(image->StoreStructure(m_pJumpTargetTable, size, 
                                        DataImage::SECTION_FIXUPS,
                                        DataImage::DESCRIPTION_FIXUPS));
    }
    else 
        m_pJumpTargetTable = 0;

    return S_OK;
}

static SLOT FixupInheritedSlot(OBJECTREF object, int slotNumber)
{
#ifdef _DEBUG
    Thread::ObjectRefNew(&object);
#endif
    MethodTable *pMT = object->GetTrueMethodTable();

    return pMT->GetModule()->FixupInheritedSlot(pMT, slotNumber);
}

static __declspec(naked) void __cdecl FixupVTableSlot()
{
#if _X86_
    // 
    // Bottom 2 bits of esp contain low 2 bits of index, and must be cleared
    // al contains high 8 bits of index, and is scratch
    // 
    __asm {

        // calculate index  =  (eax << 2) + (esp & 3)
        //                  =  ((eax << 2) + esp) - (esp & ~3)

        // shift eax by 2 bits and add in esp
        lea         eax,[esp + 4*eax]

        // reset the esp low two bits to zero
        and         esp,-4

        // subtract esp, leaving just the low two bits added into eax
        sub         eax, esp

        // Data is fixed up: eax contains index, other parameters are unchanged

        // Save regs
        push        ecx
        push        edx

        // call Module::FixupInheritedSlot
        push        eax
        push        ecx
        call        FixupInheritedSlot
        // slot is in eax

        // restore regs
        pop         edx
        pop         ecx
        
        jmp         eax
    }
#else // _X86_
    _ASSERTE(!"NYI");
#endif // _X86_
}

//
// FixupInheritedSlot is used to fix up a virtual slot which inherits
// its method from the parent class, in a preloaded image.  This is
// needed when the parent class is in a different module, as we cannot
// store a pointer to another module directly.
//
// Note that for overridden virtuals we never need this, since the
// MethodDesc will always be in the same module.
//
// Also note that this won't work for nonvirtual dispatches (since we don't
// know which superclass to dispatch the call to.)  However, we will never
// generate a nonvirtual dispatch to an inherited slot due to the way our
// method lookup works. (Even if we try to bind to an inherited slot, the 
// destination of the nonvirtual call is always based 
// on the MethodDesc which the slot refers to, which will use 
// the method table in which it is introduced.)
//

SLOT Module::FixupInheritedSlot(MethodTable *pMT, int slotNumber)
{
    //
    // We should always be restored, since this is a virtual method
    //

    _ASSERTE(pMT->GetClass()->IsRestored());
    
    // We may be racing to fix up the slot.  Check to see if the slot
    // still needs to be fixed up. (Note we need the fixup stub slot
    // value later on in the computation so this check is a requirement.)
    
    SLOT slotValue = pMT->GetVtable()[slotNumber];
    if (!pMT->GetModule()->IsJumpTargetTableEntry(slotValue))
    {
        _ASSERTE(pMT->GetClass()->GetUnknownMethodDescForSlotAddress(slotValue) != NULL);
        return slotValue;
    }

    //
    // Our parent should never be null, since we are supposed to
    // be inheriting its implementation
    //

    _ASSERTE(pMT->GetClass()->GetParentClass() != NULL);

    //
    // Get the target slot number of the method desc we are looking
    // for.  (Note that the slot number of the fixup may not be the
    // same slot number that we came through, in cases of using method
    // descs in multiple slots for interfaces.)
    //

    int targetSlotNumber = pMT->GetModule()->GetJumpTargetTableSlotNumber(slotValue);

    //
    // Get slot value from parent.  Note that parent slot may also need
    // to be fixed up.
    //

    EEClass *pParentClass = pMT->GetClass()->GetParentClass();
    MethodTable *pParentMT = pParentClass->GetMethodTable();
    int parentSlotNumber;
    
    if (targetSlotNumber < pParentClass->GetNumVtableSlots())
    {
        parentSlotNumber = targetSlotNumber;
    }
    else
    {
        //
        // This slot is actually inheriting from an interface.  This could be 
        // from the parent vtable interface section, or in the COM interop case,
        // could be from the interface itself.
        //

        InterfaceInfo_t *pInterface = pMT->GetInterfaceForSlot(targetSlotNumber);
        _ASSERTE(pInterface != NULL);

        MethodTable *pInterfaceMT = pInterface->m_pMethodTable;
        parentSlotNumber = targetSlotNumber - pInterface->m_wStartSlot;

        InterfaceInfo_t *pParentInterface = pParentMT->FindInterface(pInterfaceMT);
        if (pParentInterface == NULL)
        {
            _ASSERTE(pMT->IsComObjectType());
            pParentMT = pInterfaceMT;
        }
        else
        {
            parentSlotNumber += pParentInterface->m_wStartSlot;
        }
    }
    
    SLOT slot = pParentMT->m_Vtable[parentSlotNumber];

    //
    // See if parent slot also needs to be fixed up.
    //

    Module *pParentModule = pParentMT->GetModule();

    if (pParentModule->IsJumpTargetTableEntry(slot))
    {
        slot = pParentModule->FixupInheritedSlot(pParentMT, parentSlotNumber);
    }

    //
    // Fixup our slot and return the value.  Be careful not to stomp a slot
    // which has been backpatched during a race with the prestub.
    //

    void *prev = FastInterlockCompareExchange((void **) (pMT->GetVtable() + slotNumber), 
                                              slot, slotValue);
    if (prev == slot)
    {
        // 
        // We either lost a race to fixup the slot, or else we aren't patching the right slot.
        // (This can happen when we call through an interface on duplicated method desc slot - 
        // jitted code hitting the fixup will not know the "actual" slot number)
        //
        // The former case is rare, but the latter case would be bad perf-wise.  
        // So, in either case, we will take a one time hit here - scan the entire 
        // interface section of the vtable to see if there are any similar stubs which 
        // need to be fixed up.
        //

        if (slotNumber == targetSlotNumber)
        {
            SLOT *pStart = pMT->GetVtable() + pParentClass->GetNumVtableSlots();
            SLOT *pEnd = pMT->GetVtable() + pMT->GetClass()->GetNumVtableSlots();

            while (pStart < pEnd)
            {
                if (*pStart == slotValue)
                    FastInterlockCompareExchange((void **) pStart, slot, slotValue);
                pStart++;
            }
        }
    }

    return slot;
}

BOOL Module::IsJumpTargetTableEntry(SLOT slot)
{
    return (m_pJumpTargetTable != NULL
            && (BYTE*) slot >= m_pJumpTargetTable
            && (BYTE*) slot < m_pJumpTargetTable + X86JumpTargetTable::ComputeSize(m_cJumpTargets));
}

int Module::GetJumpTargetTableSlotNumber(SLOT slot)
{
    _ASSERTE(IsJumpTargetTableEntry(slot));
    return X86JumpTargetTable::ComputeTargetIndex((BYTE*)slot);
}

HRESULT Module::Fixup(DataImage *image, DWORD *pRidToCodeRVAMap)
{
    HRESULT hr;

    IfFailRet(image->ZERO_FIELD(m_ilBase));
    IfFailRet(image->ZERO_FIELD(m_pMDImport));
    IfFailRet(image->ZERO_FIELD(m_pEmitter));
    IfFailRet(image->ZERO_FIELD(m_pImporter));
    IfFailRet(image->ZERO_FIELD(m_pDispenser));

    IfFailRet(image->FixupPointerField(&m_pDllMain));

    IfFailRet(image->ZERO_FIELD(m_dwFlags));

    IfFailRet(image->ZERO_FIELD(m_pVASigCookieBlock));
    IfFailRet(image->ZERO_FIELD(m_pAssembly));
    IfFailRet(image->ZERO_FIELD(m_moduleRef));
    IfFailRet(image->ZERO_FIELD(m_dwModuleIndex));

    IfFailRet(image->ZERO_FIELD(m_pCrst));

#ifdef COMPRESSION_SUPPORTED
    IfFailRet(image->ZERO_FIELD(m_pInstructionDecodingTable));
#endif

    IfFailRet(image->ZERO_FIELD(m_compiledMethodRecord));
    IfFailRet(image->ZERO_FIELD(m_loadedClassRecord));

    //
    // Fixup the method table
    //

    if (image->IsStored(m_pMethodTable))
        IfFailRet(image->FixupPointerField(&m_pMethodTable));
    else
        IfFailRet(image->ZERO_FIELD(m_pMethodTable));

    IfFailRet(image->ZERO_FIELD(m_pISymUnmanagedReader)); 

    IfFailRet(image->ZERO_FIELD(m_pNextModule));

    IfFailRet(image->ZERO_FIELD(m_dwBaseClassIndex));

    IfFailRet(image->ZERO_FIELD(m_pPreloadRangeStart));
    IfFailRet(image->ZERO_FIELD(m_pPreloadRangeEnd));

    IfFailRet(image->ZERO_FIELD(m_ExposedModuleObject));

    IfFailRet(image->ZERO_FIELD(m_pLookupTableHeap));
    IfFailRet(image->ZERO_FIELD(m_pLookupTableCrst));

    IfFailRet(m_TypeDefToMethodTableMap.Fixup(image));
    IfFailRet(m_TypeRefToMethodTableMap.Fixup(image));
    IfFailRet(m_MethodDefToDescMap.Fixup(image));
    IfFailRet(m_FieldDefToDescMap.Fixup(image));
    IfFailRet(m_MemberRefToDescMap.Fixup(image));
    IfFailRet(m_FileReferencesMap.Fixup(image));
    IfFailRet(m_AssemblyReferencesMap.Fixup(image));

    //
    // Fixup binder
    //

    if (image->IsStored(m_pBinder))
    {
        IfFailRet(image->FixupPointerField(&m_pBinder));
        IfFailRet(m_pBinder->Fixup(image));
    }
    else
        IfFailRet(image->ZERO_FIELD(m_pBinder));
        

    // 
    // Fixup classes
    //

    LookupMap *m = &m_TypeDefToMethodTableMap;
    DWORD index = 0;
    while (m != NULL)
    {
        MethodTable **pTable = ((MethodTable**) m->pTable) + index;
        MethodTable **pTableEnd = ((MethodTable**) m->pTable) + m->dwMaxIndex;

        while (pTable < pTableEnd)
        {
            MethodTable *t = *pTable;
            if (image->IsStored(t))
            {
                IfFailRet(t->Fixup(image, pRidToCodeRVAMap));
                IfFailRet(image->FixupPointerField(pTable));
            }
            else
                IfFailRet(image->ZERO_FIELD(*pTable));
            
            pTable++;
        }

        index = m->dwMaxIndex;
        m = m->pNext;
    }

    m = &m_TypeRefToMethodTableMap;
    index = 0;
    while (m != NULL)
    {
        TypeHandle *pHandle = ((TypeHandle*) m->pTable) + index;
        TypeHandle *pHandleEnd = ((TypeHandle*) m->pTable) + m->dwMaxIndex;

        while (pHandle < pHandleEnd)
        {
            if (!pHandle->IsNull())
            {
                //
                // We will just zero out these fields, since all classes in here
                // should be either be typedesc classes or else in another module.
                //
                IfFailRet(image->ZeroPointerField(pHandle));
            }

            pHandle++;
        }

        index = m->dwMaxIndex;
        m = m->pNext;
    }

    // 
    // Fixup Methods
    //

    m = &m_MethodDefToDescMap;
    index = 0;
    while (m != NULL)
    {
        MethodDesc **pTable = ((MethodDesc**) m->pTable) + index;
        MethodDesc **pTableEnd = ((MethodDesc**) m->pTable) + m->dwMaxIndex;

        while (pTable < pTableEnd)
        {
            if (image->IsStored(*pTable))
                IfFailRet(image->FixupPointerField(pTable));
            else
                IfFailRet(image->ZERO_FIELD(*pTable));

            pTable++;
        }

        index = m->dwMaxIndex;
        m = m->pNext;
    }

    // 
    // Fixup Fields
    //

    m = &m_FieldDefToDescMap;
    index = 0;
    while (m != NULL)
    {
        FieldDesc **pTable = ((FieldDesc**) m->pTable) + index;
        FieldDesc **pTableEnd = ((FieldDesc**) m->pTable) + m->dwMaxIndex;

        while (pTable < pTableEnd)
        {
            if (image->IsStored(*pTable))
                IfFailRet(image->FixupPointerField(pTable));
            else
                IfFailRet(image->ZERO_FIELD(*pTable));

            pTable++;
        }

        index = m->dwMaxIndex;
        m = m->pNext;
    }

    m = &m_MemberRefToDescMap;
    index = 0;
    while (m != NULL)
    {
        MethodDesc **pTable = ((MethodDesc**) m->pTable) + index;
        MethodDesc **pTableEnd = ((MethodDesc**) m->pTable) + m->dwMaxIndex;

        while (pTable < pTableEnd)
        {
            if (image->IsStored(*pTable))
                IfFailRet(image->FixupPointerField(pTable));
            else
            {
                // @todo: we need to jump through some hoops to find
                // out what module the desc is in since it could be
                // either a MethodDesc or FieldDesc
                IfFailRet(image->ZeroPointerField(pTable));
            }

            pTable++;
        }

        index = m->dwMaxIndex;
        m = m->pNext;
    }

    //
    // Zero out file references and assembly references
    // tables.
    //
    IfFailRet(image->ZeroField(m_FileReferencesMap.pTable, 
                               m_FileReferencesMap.dwMaxIndex * sizeof(void*)));
    IfFailRet(image->ZeroField(m_AssemblyReferencesMap.pTable, 
                               m_AssemblyReferencesMap.dwMaxIndex * sizeof(void*)));

    //
    // Fixup jump target table
    //

    if (m_cJumpTargets > 0)
    {
        BYTE *imageTable = (BYTE*) image->GetImagePointer(m_pJumpTargetTable);

        int count = m_cJumpTargets;
        int index = 0;

        SIZE_T tableOffset = 0;

        while (count > 0)
        {
            int blockCount = count;
            if (blockCount > X86JumpTargetTable::MAX_BLOCK_TARGET_COUNT)
                blockCount = X86JumpTargetTable::MAX_BLOCK_TARGET_COUNT;

            int jumpOffset = X86JumpTargetTable::EmitBlock(blockCount, index, imageTable + tableOffset);

            image->FixupPointerField(m_pJumpTargetTable + tableOffset + jumpOffset, 
                                     (void *) 
                                     (m_FixupVTableJumpStub - (m_pJumpTargetTable + tableOffset + jumpOffset + 4)),
                                     DataImage::REFERENCE_STORE, DataImage::FIXUP_RELATIVE);
        
            tableOffset += X86JumpTargetTable::ComputeSize(blockCount);
            index += blockCount;
            count -= blockCount;
        }

        image->FixupPointerField(&m_pJumpTargetTable);
    }

    IfFailRet(image->ZERO_FIELD(m_pFixupBlobs));
    IfFailRet(image->ZERO_FIELD(m_cFixupBlobs));

    //
    // Set our alternate RVA static base if appropriate
    //
    
    if (GetCORHeader()->Flags & COMIMAGE_FLAGS_ILONLY)
    {
        image->FixupPointerFieldMapped(&m_alternateRVAStaticBase,
                                       (void*)(size_t) image->GetSectionBaseOffset(DataImage::SECTION_RVA_STATICS));
    }
    else
        image->ZERO_FIELD(m_alternateRVAStaticBase); 

    return S_OK;
}

HRESULT Module::Create(PEFile *pFile, PEFile *pZapFile, Module **ppModule, BOOL isEnC)
{
    HRESULT hr;

    if (pZapFile == NULL)
        return Create(pFile, ppModule, isEnC);
    
    // 
    // Verify files
    //

    IfFailRet(VerifyFile(pFile, FALSE));
    IfFailRet(VerifyFile(pZapFile, TRUE));

    //
    // Enable the zap monitor if appropriate
    //

#if ZAPMONITOR_ENABLED
    if (g_pConfig->MonitorZapStartup() || g_pConfig->MonitorZapExecution()) 
    {
        ZapMonitor *monitor = new ZapMonitor(pZapFile, pFile->GetMDImport());
        monitor->Reset();

        // Don't make a monitor for an IJW file
        if (pFile->GetCORHeader()->VTableFixups.VirtualAddress == 0)
        {
            monitor = new ZapMonitor(pFile, pFile->GetMDImport());
        monitor->Reset();
    }
    }
#endif

    //
    // Get headers
    //

    IMAGE_COR20_HEADER *pZapCORHeader = pZapFile->GetCORHeader();
    BYTE *zapBase = pZapFile->GetBase();
    CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
      (zapBase + pZapCORHeader->ManagedNativeHeader.VirtualAddress);

    if (zapBase != (BYTE*) (size_t)pZapFile->GetNTHeader()->OptionalHeader.ImageBase)
    {
        LOG((LF_ZAP, LL_WARNING, 
             "ZAP: Zap module loaded at base address 0x%08x rather than preferred address 0x%08x.\n",
             zapBase, 
             pZapFile->GetNTHeader()->OptionalHeader.ImageBase));
    }

    Module *pModule;

    DWORD image = pZapHeader->ModuleImage.VirtualAddress;
    if (image != 0)
    {
        BYTE *pILBase = image + zapBase + offsetof(Module, m_ilBase);
        
        if (FastInterlockCompareExchange((void**)pILBase, (void*) pFile->GetBase(), (void *) NULL) == NULL)
        {
#ifdef EnC_SUPPORTED
            if (isEnC && !pFile->IsSystem())
                pModule = new ((void*) (image + zapBase)) EditAndContinueModule();
            else
#endif // EnC_SUPPORTED
                pModule = new ((void*) (image + zapBase)) Module();
        }
        else
        {
            // 
            // The image has already been used in this process by another Module.
            // We have to abandon the zap file.  (Note that it isn't enough to 
            // just abandon the preload image, since the code in the file will
            // reference the image directly.
            //

            LOG((LF_ZAP, LL_WARNING, "ZAP: Preloaded module cannot be reused - abandoning zap file.\n"));

            hr = Create(pFile, ppModule, isEnC);
            if (FAILED(hr))
                return hr;

            //
            // Return S_FALSE to indicate that we didn't use the zap file.
            //

            delete pZapFile;
            return S_FALSE;
        }
    }
    else
    {
#ifdef EnC_SUPPORTED
        if (isEnC && !pFile->IsSystem())
            pModule = new EditAndContinueModule();
        else
#endif // EnC_SUPPORTED
            pModule = new Module();
    }

    IfFailRet(pModule->Init(pFile, pZapFile, image != 0));

    pModule->SetPEFile();

#ifdef EnC_SUPPORTED
    if (isEnC && !pFile->IsSystem())
    {
        pModule->SetEditAndContinue();
    }
#endif // EnC_SUPPORTED

    //
    // Set up precompiled code
    // Right now, we only have a single code manager.  Maybe eventually we will allow multiple.
    //
    
    if (pZapHeader->CodeManagerTable.VirtualAddress != 0)
    {
        CORCOMPILE_CODE_MANAGER_ENTRY *codeMgr = (CORCOMPILE_CODE_MANAGER_ENTRY *) 
          (zapBase + pZapHeader->CodeManagerTable.VirtualAddress);
        pModule->SetPrecompile();

        // 
        // Register the code with the appropriate jit manager
        //

        MNativeJitManager *jitMgr 
          = (MNativeJitManager*)ExecutionManager::GetJitForType(miManaged|miNative);
        if (!jitMgr)
            return E_OUTOFMEMORY;

        if (!ExecutionManager::AddRange((LPVOID) (codeMgr->Code.VirtualAddress + zapBase),
                                        (LPVOID) (codeMgr->Code.VirtualAddress + codeMgr->Code.Size + zapBase),
                                        jitMgr, 
                                        codeMgr->Table.VirtualAddress + zapBase))
        {
            if (jitMgr)
                delete jitMgr;
            return E_OUTOFMEMORY;
        }

        //
        // Allocate array for lazy token initialization
        //
        if (pZapHeader->DelayLoadInfo.VirtualAddress != 0)
        {
            IMAGE_DATA_DIRECTORY *pEntry = (IMAGE_DATA_DIRECTORY *)
              (zapBase + pZapHeader->DelayLoadInfo.VirtualAddress);
            IMAGE_DATA_DIRECTORY *pEntryEnd = (IMAGE_DATA_DIRECTORY *)
              (zapBase + pZapHeader->DelayLoadInfo.VirtualAddress 
                       + pZapHeader->DelayLoadInfo.Size);

            //
            // Count entries
            // @nice: it would be nice if we could guarantee that these are
            // contiguous, then we wouldn't have to loop through like this.
            //

            while (pEntry < pEntryEnd)
            {
                pModule->m_cFixupBlobs += (pEntry->Size>>2);
                pEntry++;
            }

            //
            // Allocate a block to serve as an copy of the tokens, 
            // plus a flag for each token to see if it were resolved.
            // Keeping this extra copy allows us to delay load tokens without
            // using using a mutex, since the resolution of the token is 
            // non-destructive.
            // 

            DWORD *pBlobs = new DWORD [ pModule->m_cFixupBlobs ];
            if (pBlobs == NULL)
                return E_OUTOFMEMORY;
            pModule->m_pFixupBlobs = pBlobs;

            //
            // Now copy the tokens.
            //

            pEntry = (IMAGE_DATA_DIRECTORY *)
              (zapBase + pZapHeader->DelayLoadInfo.VirtualAddress);

            while (pEntry < pEntryEnd)
            {
                CopyMemory(pBlobs, zapBase + pEntry->VirtualAddress, pEntry->Size);
#if _DEBUG
                FillMemory(zapBase + pEntry->VirtualAddress,
                           pEntry->Size, 0x55);
#endif
                pBlobs += (pEntry->Size>>2);
                pEntry++;
            }
        }
    }

    //
    // Set up preloaded image
    //
    
    if (image != 0)
    {
        pModule->SetPreload();
        pModule->SetPreloadRange((BYTE*)pModule, ((BYTE*)pModule) + pZapHeader->ModuleImage.Size);
        
        //
        // Register the preload image with the stub managers.
        // Be sure to treat the jump target table differently.
        // 

        if (pModule->m_pJumpTargetTable != NULL)
        {
            BYTE *start = zapBase + image + sizeof(Module);
            BYTE *end = pModule->m_pJumpTargetTable;

            MethodDescPrestubManager::g_pManager->m_rangeList.
              AddRange(start, end, pModule);

            start = end;
            end = start + X86JumpTargetTable::ComputeSize(pModule->m_cJumpTargets);

            X86JumpTargetTableStubManager::g_pManager->m_rangeList.
              AddRange(start, end, pModule);

            start = end;
            end = zapBase + image + pZapHeader->ModuleImage.Size; 

            MethodDescPrestubManager::g_pManager->m_rangeList.
              AddRange(start, end, pModule);
        }
        else
            MethodDescPrestubManager::g_pManager->m_rangeList.
              AddRange(zapBase + image + sizeof(Module),
                       zapBase + image + pZapHeader->ModuleImage.Size,
                       pModule);

        // 
        // Add the module's PrestubJumpStub specifically; we'l check for
        // it later...
        //
        MethodDescPrestubManager::g_pManager->m_rangeList.
          AddRange((BYTE*)pModule->m_PrestubJumpStub,
                   (BYTE*)pModule->m_PrestubJumpStub + JUMP_ALLOCATE_SIZE, 
                   pModule);

        emitJump(pModule->m_PrestubJumpStub, (void*) ThePreStub()->GetEntryPoint());
        emitJump(pModule->m_NDirectImportJumpStub, (void*) NDirectImportThunk);
        emitJump(pModule->m_FixupVTableJumpStub, (void*) FixupVTableSlot);
    }

#ifdef PROFILING_SUPPORTED
    // When profiling, let the profiler know we're done.
    if (CORProfilerTrackModuleLoads())
        g_profControlBlock.pProfInterface->ModuleLoadFinished((ThreadID) GetThread(), (ModuleID) pModule, hr);
    
#endif // PROFILING_SUPPORTED

    *ppModule = pModule;

    return S_OK;
}

Module *Module::GetBlobModule(DWORD rva)
{
    THROWSCOMPLUSEXCEPTION();

    CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
      (GetZapBase() + GetZapCORHeader()->ManagedNativeHeader.VirtualAddress);

    CORCOMPILE_IMPORT_TABLE_ENTRY *pEntry = (CORCOMPILE_IMPORT_TABLE_ENTRY *)
      (GetZapBase() + pZapHeader->ImportTable.VirtualAddress);
    CORCOMPILE_IMPORT_TABLE_ENTRY *pEntryEnd = (CORCOMPILE_IMPORT_TABLE_ENTRY *)
      (GetZapBase() + pZapHeader->ImportTable.VirtualAddress 
       + pZapHeader->ImportTable.Size);

    CORCOMPILE_IMPORT_TABLE_ENTRY *p = pEntry;
    while (TRUE)
    {
        _ASSERTE(p < pEntryEnd);

        if (rva >= p->Imports.VirtualAddress 
            && rva < p->Imports.VirtualAddress + p->Imports.Size)
            return CEECompileInfo::DecodeModule(this, p->wAssemblyRid, p->wModuleRid);

        p++;
    }
}

void Module::FixupDelayList(DWORD *list)
{
    THROWSCOMPLUSEXCEPTION();

    if (m_pFixupBlobs != NULL)
    {
        while (*list)
        {
            DWORD rva = *list++;

            CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
              (GetZapBase() + GetZapCORHeader()->ManagedNativeHeader.VirtualAddress);

            IMAGE_DATA_DIRECTORY *pEntry = (IMAGE_DATA_DIRECTORY *)
              (GetZapBase() + pZapHeader->DelayLoadInfo.VirtualAddress);
            IMAGE_DATA_DIRECTORY *pEntryEnd = (IMAGE_DATA_DIRECTORY *)
              (GetZapBase() + pZapHeader->DelayLoadInfo.VirtualAddress 
               + pZapHeader->DelayLoadInfo.Size);

            DWORD *blobs = m_pFixupBlobs;
            IMAGE_DATA_DIRECTORY *p = pEntry;
            while (TRUE)
            {
                _ASSERTE(p < pEntryEnd);

                if (rva >= p->VirtualAddress && rva < p->VirtualAddress + p->Size)
                {
                    DWORD *pBlob = &blobs[(rva - p->VirtualAddress)>>2];
                    DWORD blob = *pBlob;
                    if (blob != 0)
                    {
                        Module *pModule = GetBlobModule(blob);

                        LoadDynamicInfoEntry(this, pModule, 
                                             (BYTE*)(GetZapBase() + blob), 
                                             (int)(p - pEntry), 
                                             (DWORD*)(GetZapBase() + rva));

                        *pBlob = 0;
                                }
                    break;
                }

                blobs += (p->Size>>2);
                p++;
            }
        }
    }
}

BOOL Module::LoadTokenTables()
{
    // 
    // Don't do this during EE init!
    //
    if (g_fEEInit)
        return TRUE;

    if (!IsPrecompile())
        return TRUE;

    IMAGE_COR20_HEADER *pHeader = GetZapCORHeader();
    _ASSERTE(pHeader != NULL);
    CORCOMPILE_HEADER *pZapHeader = (CORCOMPILE_HEADER *) 
      (GetZapBase() + pHeader->ManagedNativeHeader.VirtualAddress);
    _ASSERTE(pZapHeader != NULL);

    if (pZapHeader->EEInfoTable.VirtualAddress != NULL)
    {
        void *table = (void *) (GetZapBase() + pZapHeader->EEInfoTable.VirtualAddress);
        if (FAILED(LoadEEInfoTable(this, (CORCOMPILE_EE_INFO_TABLE *) table, 
                                   pZapHeader->EEInfoTable.Size)))
            return FALSE;
    }

    if (pZapHeader->HelperTable.VirtualAddress != NULL)
    {
        void *table = (void *) (GetZapBase() + pZapHeader->HelperTable.VirtualAddress);
        if (FAILED(LoadHelperTable(this, (void **) table, 
                                   pZapHeader->HelperTable.Size)))
            return FALSE;
    }

    return TRUE;
}

#if ZAP_RECORD_LOAD_ORDER

// Want to disable the warning:
// 'header' : zero-sized array in stack object will have no elements (unless the object is aggregate initialized)
// because we create CORCOMPILE_LDO_HEADER on the stack.
// We should find a better way to deal with this...
#pragma warning( push )
#pragma warning( disable : 4815)

void Module::OpenLoadOrderLogFile()
{
    WCHAR path[MAX_PATH+4]; // add space for .ldo; FileName is guaranteed to fit in MAX_PATH
    
    wcscpy(path, GetFileName());
    WCHAR *ext = wcsrchr(path, '.');

    if (ext == NULL)
    {
        ext = path + wcslen(path);
        _ASSERTE(*ext == 0);
    }

    wcscpy(ext, L".ldo");

    m_loadOrderFile = WszCreateFile(path, GENERIC_READ | GENERIC_WRITE, 0, NULL, 
                                    OPEN_ALWAYS, 
                                    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                                    NULL);
    if (m_loadOrderFile == INVALID_HANDLE_VALUE)
    {
        DEBUG_STMT(DbgWriteEx(L"Failed to open LDO file, possible it is loaded already?"));
        return;
    }

    //
    // Update header info
    //

    LPCSTR pszName;
    GUID mvid;
    if (m_pMDImport->IsValidToken(m_pMDImport->GetModuleFromScope()))
        m_pMDImport->GetScopeProps(&pszName, &mvid);
    else
        return;

    CORCOMPILE_LDO_HEADER header;

    if( SetFilePointer(m_loadOrderFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    goto ErrExit;
    
    DWORD count;
    BOOL result = ReadFile(m_loadOrderFile, &header, sizeof(header), &count, NULL);
    if (result 
        && count == sizeof(header)
        && header.Magic == CORCOMPILE_LDO_MAGIC
        && header.Version == 0
        && mvid == header.MVID)
    {
        // 
        // The existing file was from the same assembly version - just append to it.
        //

        if(SetFilePointer(m_loadOrderFile, 0, NULL, FILE_END) == INVALID_SET_FILE_POINTER)
            goto ErrExit;
    }
    else
    {
        //
        // Either this is a new file, or it's from a previous version.  Replace the contents.
        //

        if( SetFilePointer(m_loadOrderFile, 0, NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER)
        goto ErrExit;
        
        header.Magic = CORCOMPILE_LDO_MAGIC;
        header.Version = 0;
        header.MVID = mvid;

        result = WriteFile(m_loadOrderFile, &header, 
                           sizeof(header), &count, NULL);
        _ASSERTE(result && count == sizeof(header));
    }
    
    SetEndOfFile(m_loadOrderFile);
ErrExit:
    return; 
}
#pragma warning(pop)


void Module::CloseLoadOrderLogFile()
{
    if (m_loadOrderFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_loadOrderFile);
        m_loadOrderFile = INVALID_HANDLE_VALUE;
    }
}
#endif

void Module::LogClassLoad(EEClass *pClass)
{
    _ASSERTE(pClass->GetModule() == this);

#if ZAP_RECORD_LOAD_ORDER
    if (m_loadOrderFile != INVALID_HANDLE_VALUE)
    {
        mdToken token = pClass->GetCl();
        if (RidFromToken(token) != 0)
        {
            DWORD written = 0;
            BOOL result = WriteFile(m_loadOrderFile, &token, 
                                    sizeof(token), &written, NULL);
            _ASSERTE(result && written == sizeof(token));
        }
    }
#endif

#if 0
    if (g_pConfig->LogMissingZaps()) // @todo: new config setting?
    {
        if (m_loadedClassRecord == NULL)
        {
            ArrayList *pList = new ArrayList();
            if (FastInterlockCompareExchange((void**)&m_loadedClassRecord, pList, NULL) != NULL)
            {
                _ASSERTE(m_loadedClassRecord != pList);
                delete pList;
            }
            _ASSERTE(m_loadedClassRecord != NULL);
        }

        mdToken token = pClass->GetCl();
        if (RidFromToken(token) != 0)
            m_loadedClassRecord->Append((void*)RidFromToken(token));
    }
#endif
}

void Module::LogMethodLoad(MethodDesc *pMethod)
{
    _ASSERTE(pMethod->GetModule() == this);

#if ZAP_RECORD_LOAD_ORDER
    if (m_loadOrderFile != INVALID_HANDLE_VALUE)
    {
        //
        // Don't store methods of manufactured classes.
        //

        mdToken token = pMethod->GetMemberDef();
        if (RidFromToken(token) != 0)
        {
            token = pMethod->GetMemberDef();
            if (RidFromToken(token) != 0)
            {
                DWORD written = 0;
                BOOL result = WriteFile(m_loadOrderFile, &token, 
                                        sizeof(token), &written, NULL);
                _ASSERTE(result && written == sizeof(token));
            }
        }
    }
#endif

#if 0
    if (g_pConfig->LogMissingZaps()) // @todo: new config setting?
    {
        if (m_compiledMethodRecord == NULL)
        {
            ArrayList *pList = new ArrayList();
            if (FastInterlockCompareExchange((void**)&m_compiledMethodRecord, pList, NULL) != NULL)
            {
                _ASSERTE(m_compiledMethodRecord != pList);
                delete pList;
            }
            _ASSERTE(m_compiledMethodRecord != NULL);
        }

        mdToken token = pMethod->GetMemberDef();
        if (RidFromToken(token) != 0)
        {
            // @todo: needs synchronization when called on prejitted method!!!
            m_compiledMethodRecord->Append((void*)RidFromToken(token));
    }
}
#endif
}

NLogModule *Module::CreateModuleLog()
{
    if (!IsPEFile())
        return NULL;

    NLogModule *pModule;

    if (m_moduleRef != mdFileNil)
    {
        LPCSTR pName;
        if (m_pMDImport->IsValidToken(m_pMDImport->GetModuleFromScope()))
            m_pMDImport->GetScopeProps(&pName, NULL);
        else
            return NULL;

        pModule = new NLogModule(pName);
    }
    else
        pModule = new NLogModule("");

    // Record set and order of compiled methods
    if (m_compiledMethodRecord != NULL)
    {
        NLogIndexList *pList = pModule->GetCompiledMethods();
        ArrayList::Iterator i = m_compiledMethodRecord->Iterate();
        while (i.Next())
            pList->AppendIndex((SIZE_T) i.GetElement());
    }

    // Record set and order of loaded classes
    if (m_loadedClassRecord != NULL)
    {
        NLogIndexList *pList = pModule->GetLoadedClasses();
        ArrayList::Iterator i = m_loadedClassRecord->Iterate();
        while (i.Next())
            pList->AppendIndex((SIZE_T) i.GetElement());
    }

    return pModule;
}

// ===========================================================================
// Find a matching u->m thunk in the fixups if one exists. If none exists,
// return NULL.
// ===========================================================================
LPVOID Module::FindUMThunkInFixups(LPVOID pManagedIp, PCCOR_SIGNATURE pSig, ULONG cSig)
{
    // First, look in the exports.
    DWORD numEATEntries;
    BYTE *pEATJArray = FindExportAddressTableJumpArray(GetILBase(), &numEATEntries);
    BYTE * pEATJArrayStart = pEATJArray;
    if (pEATJArray)
    {
        DWORD nEATEntry = numEATEntries;
        while (nEATEntry--)
        {
            EATThunkBuffer *pEATThunkBuffer = (EATThunkBuffer*) pEATJArray;

            mdToken md = pEATThunkBuffer->GetToken();
            if (Beta1Hack_LooksLikeAMethodDef(md))  // no longer supporting the old EAT format
            {
                UMEntryThunk *pUMEntryThunk = UMEntryThunk::RecoverUMEntryThunk(pEATThunkBuffer->GetTarget());
                MethodDesc *pMD = pUMEntryThunk->GetMethod();
                if (pMD != NULL && pMD->IsTarget(pManagedIp))
                {
                    PCCOR_SIGNATURE pSig2;
                    ULONG           cSig2;
                    pMD->GetSig(&pSig2, &cSig2);
                    if (MetaSig::CompareMethodSigs(pSig, cSig, this, pSig2, cSig2, this))
                    {
                        return (LPVOID)pUMEntryThunk->GetCode();
                    }
                }
            }
            pEATJArray = pEATJArray + IMAGE_COR_EATJ_THUNK_SIZE;
        }
    }

    // Now check the fixup tables.
    IMAGE_COR20_HEADER *pHeader;
    pHeader = GetCORHeader();

    // Check for no entries at all.
    if ((pHeader == NULL) || (pHeader->VTableFixups.VirtualAddress == 0))
        return NULL;

    // Locate the base of the fixup entries in virtual memory.
    IMAGE_COR_VTABLEFIXUP *pFixupTable;
    pFixupTable = (IMAGE_COR_VTABLEFIXUP *)(GetILBase() + pHeader->VTableFixups.VirtualAddress);
    int iFixupRecords;
    iFixupRecords = pHeader->VTableFixups.Size / sizeof(IMAGE_COR_VTABLEFIXUP);

    // No records then return
    if (iFixupRecords == 0) 
    {
        return NULL;
    }

    for (int iFixup = 0; iFixup < iFixupRecords; iFixup++) 
    {
        if (pFixupTable[iFixup].Type == (COR_VTABLE_32BIT|COR_VTABLE_FROM_UNMANAGED)) {
           const BYTE **pPointers = (const BYTE **)(GetILBase() + pFixupTable[iFixup].RVA);
           for (int iMethod = 0; iMethod < pFixupTable[iFixup].Count; iMethod++) {
                UMEntryThunk *pUMEntryThunk = UMEntryThunk::RecoverUMEntryThunk(pPointers[iMethod]);
                MethodDesc *pMD = pUMEntryThunk->GetMethod();
                if (pMD != NULL && pMD->IsTarget(pManagedIp))
                {
                    PCCOR_SIGNATURE pSig2;
                    ULONG           cSig2;
                    pMD->GetSig(&pSig2, &cSig2);
                    if (MetaSig::CompareMethodSigs(pSig, cSig, this, pSig2, cSig2, this))
                    {
                        return (LPVOID)pUMEntryThunk->GetCode();
                    }
                }
            }
        }
    }
    return NULL;
}

// ===========================================================================
// InMemoryModule
// ===========================================================================

InMemoryModule::InMemoryModule()
  : m_pCeeFileGen(NULL),
    m_sdataSection(0)
{
    HRESULT hr = Module::Init(0);
    _ASSERTE(SUCCEEDED(hr));
}

HRESULT InMemoryModule::Init(REFIID riidCeeGen)
{
    HRESULT hr;

    SetInMemory();

    IfFailGo(AllocateMaps());

    IMetaDataEmit *pEmit;
    IfFailGo(GetDispenser()->DefineScope(CLSID_CorMetaDataRuntime, 0, IID_IMetaDataEmit, (IUnknown **)&pEmit));

    SetEmit(pEmit);

    IfFailRet(CreateICeeGen(riidCeeGen, (void **)&m_pCeeFileGen));    

 ErrExit:
#ifdef PROFILING_SUPPORTED
    // If profiling, then send the pModule event so load time may be measured.
    if (CORProfilerTrackModuleLoads())
        g_profControlBlock.pProfInterface->ModuleLoadFinished((ThreadID) GetThread(), (ModuleID) this, hr);
#endif // PROFILING_SUPPORTED

    return S_OK;
}

void InMemoryModule::Destruct()
{
    if (m_pCeeFileGen)  
        m_pCeeFileGen->Release();   
    Module::Destruct();
}

REFIID InMemoryModule::ModuleType()
{
    return IID_ICorModule;  
}

BYTE* InMemoryModule::GetILCode(DWORD target) const // virtual
{
    BYTE* pByte = NULL;
    m_pCeeFileGen->GetMethodBuffer(target, &pByte); 
    return pByte;
}

BYTE* InMemoryModule::ResolveILRVA(DWORD target, BOOL hasRVA) const // virtual
{
    // This function should be call only if the target is a field or a field with RVA.
    BYTE* pByte = NULL;
    if (hasRVA == TRUE)
    {
        m_pCeeFileGen->ComputePointer(m_sdataSection, target, &pByte); 
        return pByte;
    }
    else
        return ((BYTE*) (target + ((Module *)this)->GetILBase()));
}


// ===========================================================================
// ReflectionModule
// ===========================================================================

HRESULT ReflectionModule::Init(REFIID riidCeeGen)
{
    HRESULT     hr = E_FAIL;    
    VARIANT     varOption;

    // Set the option on the dispenser turn on duplicate check for TypeDef and moduleRef
    varOption.vt = VT_UI4;
    varOption.lVal = MDDupDefault | MDDupTypeDef | MDDupModuleRef | MDDupExportedType | MDDupAssemblyRef | MDDupPermission;
    hr = GetDispenser()->SetOption(MetaDataCheckDuplicatesFor, &varOption);
    _ASSERTE(SUCCEEDED(hr));

    // turn on the thread safety!
    varOption.lVal = MDThreadSafetyOn;
    hr = GetDispenser()->SetOption(MetaDataThreadSafetyOptions, &varOption);
    _ASSERTE(SUCCEEDED(hr));

    // turn on the thread safety!
    varOption.lVal = MDThreadSafetyOn;
    hr = GetDispenser()->SetOption(MetaDataThreadSafetyOptions, &varOption);
    _ASSERTE(SUCCEEDED(hr));

    IfFailRet(InMemoryModule::Init(riidCeeGen));

    m_pInMemoryWriter = new RefClassWriter();   
    if (!m_pInMemoryWriter)
        return E_OUTOFMEMORY; 

    m_pInMemoryWriter->Init(GetCeeGen(), GetEmitter()); 

    SetReflection();

    m_ppISymUnmanagedWriter = NULL;
    m_pFileName = NULL;

    return S_OK;  

}

void ReflectionModule::Destruct()
{
    delete m_pInMemoryWriter;   

    if (m_pFileName)
    {
        delete [] m_pFileName;
        m_pFileName = NULL;
    }

    if (m_ppISymUnmanagedWriter)
    {
        Module::ReleaseIUnknown((IUnknown**)m_ppISymUnmanagedWriter);
        m_ppISymUnmanagedWriter = NULL;
    }

    InMemoryModule::Destruct();
}

REFIID ReflectionModule::ModuleType()
{
    return IID_ICorReflectionModule;    
}

// ===========================================================================
// CorModule
// ===========================================================================

// instantiate an ICorModule interface
HRESULT STDMETHODCALLTYPE CreateICorModule(REFIID riid, void **pCorModule)
{
    if (! pCorModule)   
        return E_POINTER;   
    *pCorModule = NULL; 

    CorModule *pModule = new CorModule();   
    if (!pModule)   
        return E_OUTOFMEMORY;   

    InMemoryModule *pInMemoryModule = NULL; 

    // @TODO: CTS, everywhere CreateICorModule is called then an associated loader
    // must be added before it will work correctly.
    if (riid == IID_ICorModule) {   
        pInMemoryModule = new InMemoryModule();   
    } else if (riid == IID_ICorReflectionModule) {  
        pInMemoryModule = new ReflectionModule(); 
    } else {    
        delete pModule; 
        return E_NOTIMPL;   
    }   

    if (!pInMemoryModule) { 
        delete pModule; 
        return E_OUTOFMEMORY;   
    }   
    pModule->SetModule(pInMemoryModule);    
    pModule->AddRef();  
    *pCorModule = pModule;  
    return S_OK;    
}

STDMETHODIMP CorModule::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown)
        *ppv = (IUnknown*)(ICeeGen*)this;
    else if (riid == IID_ICeeGen)   
        *ppv = (ICorModule*)this;
    if (*ppv == NULL)
        return E_NOINTERFACE;
    AddRef();   
    return S_OK;
}

STDMETHODIMP_(ULONG) CorModule::AddRef(void)
{
    return InterlockedIncrement(&m_cRefs);
}
 
STDMETHODIMP_(ULONG) CorModule::Release(void)
{
    if (InterlockedDecrement(&m_cRefs) == 0)    
        // the actual InMemoryModule will be deleted when EE goes through it's list 
        delete this;    
    return 1;   
}

CorModule::CorModule()
{
    m_pModule = NULL;   
    m_cRefs = 0;    
}

STDMETHODIMP CorModule::Initialize(DWORD flags, REFIID riidCeeGen, REFIID riidEmitter)
{
    HRESULT hr = E_FAIL;    

    ICeeGen *pCeeGen = NULL;    
    hr = m_pModule->Init(riidCeeGen); 
    if (FAILED(hr)) 
        goto exit;  
    hr = S_OK;  
    goto success;   
exit:
    if (pCeeGen)    
        pCeeGen->Release(); 
success:
    return hr;  
}

STDMETHODIMP CorModule::GetCeeGen(ICeeGen **pCeeGen)
{
    if (!pCeeGen)   
        return E_POINTER;   
    if (!m_pModule) 
        return E_FAIL;  
    *pCeeGen = m_pModule->GetCeeGen();  
    if (! *pCeeGen) 
        return E_FAIL;  
    (*pCeeGen)->AddRef();   
    return S_OK;    
}

STDMETHODIMP CorModule::GetMetaDataEmit(IMetaDataEmit **pEmitter)
{
#if 0
    if (!pEmitter)  
        return E_POINTER;   
    if (!m_pModule) 
        return E_FAIL;  
    *pEmitter = m_pModule->GetEmitter();    
    if (! *pEmitter)    
        return E_FAIL;  
    (*pEmitter)->AddRef();  
    return S_OK;    
#else
    *pEmitter = 0;
    _ASSERTE(!"Can't get scopeless IMetaDataEmit from EE");
    return E_NOTIMPL;
#endif
}



// ===========================================================================
// VASigCookies
// ===========================================================================

//==========================================================================
// Enregisters a VASig. Returns NULL for failure (out of memory.)
//==========================================================================
VASigCookie *Module::GetVASigCookie(PCCOR_SIGNATURE pVASig, Module *pScopeModule)
{
    VASigCookieBlock *pBlock;
    VASigCookie      *pCookie;

    if (pScopeModule == NULL)
        pScopeModule = this;

    pCookie = NULL;

    // First, see if we already enregistered this sig.
    // Note that we're outside the lock here, so be a bit careful with our logic
    for (pBlock = m_pVASigCookieBlock; pBlock != NULL; pBlock = pBlock->m_Next)
    {
        for (UINT i = 0; i < pBlock->m_numcookies; i++)
        {
            if (pVASig == pBlock->m_cookies[i].mdVASig)
            {
                pCookie = &(pBlock->m_cookies[i]);
                break;
            }
        }
    }

    if (!pCookie)
    {
        // If not, time to make a new one.

        // Compute the size of args first, outside of the lock.

        DWORD sizeOfArgs = MetaSig::SizeOfActualFixedArgStack(pScopeModule, pVASig, 
                                              (*pVASig & IMAGE_CEE_CS_CALLCONV_HASTHIS)==0);


        // enable gc before taking lock

        BEGIN_ENSURE_PREEMPTIVE_GC();
        m_pCrst->Enter();
        END_ENSURE_PREEMPTIVE_GC();

        // Note that we were possibly racing to create the cookie, and another thread
        // may have already created it.  We could put another check 
        // here, but it's probably not worth the effort, so we'll just take an 
        // occasional duplicate cookie instead.

        // Is the first block in the list full?
        if (m_pVASigCookieBlock && m_pVASigCookieBlock->m_numcookies 
            < VASigCookieBlock::kVASigCookieBlockSize)
        {
            // Nope, reserve a new slot in the existing block.
            pCookie = &(m_pVASigCookieBlock->m_cookies[m_pVASigCookieBlock->m_numcookies]);
        }
        else
        {
            // Yes, create a new block.
            VASigCookieBlock *pNewBlock = new VASigCookieBlock();
            if (pNewBlock)
            {
                pNewBlock->m_Next = m_pVASigCookieBlock;
                pNewBlock->m_numcookies = 0;
                m_pVASigCookieBlock = pNewBlock;
                pCookie = &(pNewBlock->m_cookies[0]);
            }
        }

        // Now, fill in the new cookie (assuming we had enough memory to create one.)
        if (pCookie)
        {
            pCookie->mdVASig = pVASig;
            pCookie->pModule  = pScopeModule;
            pCookie->pNDirectMLStub = NULL;
            pCookie->sizeOfArgs = sizeOfArgs;
        }

        // Finally, now that it's safe for ansynchronous readers to see it, 
        // update the count.
        m_pVASigCookieBlock->m_numcookies++;

        m_pCrst->Leave();
    }

    return pCookie;
}


VOID VASigCookie::Destruct()
{
    if (pNDirectMLStub)
        pNDirectMLStub->DecRef();
}

// ===========================================================================
// LookupMap
// ===========================================================================

HRESULT LookupMap::Save(DataImage *image, mdToken attribution)
{
    HRESULT hr;

    // 
    // NOTE: This relies on the fact that StoreStructure will always
    // allocate memory contiguously.
    //

    LookupMap *map = this;
    DWORD index = 0;
    while (map != NULL)
    {
        IfFailRet(image->StoreStructure(map->pTable + index, 
                                        (map->dwMaxIndex - index) * sizeof(void*),
                                        DataImage::SECTION_MODULE,
                                        DataImage::DESCRIPTION_MODULE,
                                        attribution));
        index = map->dwMaxIndex;
        map = map->pNext;
    }

    return S_OK;
}

HRESULT LookupMap::Fixup(DataImage *image)
{
    HRESULT hr;

    IfFailRet(image->FixupPointerField(&pTable));
    IfFailRet(image->ZERO_FIELD(pNext));
    IfFailRet(image->FixupPointerField(&pdwBlockSize));

    LookupMap *map = this;
    DWORD index = 0;
    while (map != NULL)
    {
        index = map->dwMaxIndex;
        map = map->pNext;
    }

    DWORD *maxIndex = (DWORD *) image->GetImagePointer(&dwMaxIndex);
    if (maxIndex == NULL)
        return E_POINTER;
    *maxIndex = index;

    return S_OK;
}

DWORD LookupMap::Find(void *pointer)
{
    LookupMap *map = this;
    DWORD index = 0;
    while (map != NULL)
    {
        void **p = map->pTable + index;
        void **pEnd = map->pTable + map->dwMaxIndex;
        while (p < pEnd)
        {
            if (*p == pointer)
                return (DWORD)(p - map->pTable);
            p++;
        }
        index = map->dwMaxIndex;
        map = map->pNext;
    }

    return 0;
}


// -------------------------------------------------------
// Stub manager for thunks.
//
// Note, the only reason we have this stub manager is so that we can recgonize UMEntryThunks for IsTransitionStub. If it
// turns out that having a full-blown stub manager for these things causes problems else where, then we can just attach
// a range list to the thunk heap and have IsTransitionStub check that after checking with the main stub manager.
// -------------------------------------------------------

ThunkHeapStubManager *ThunkHeapStubManager::g_pManager = NULL;

BOOL ThunkHeapStubManager::Init()
{
    g_pManager = new ThunkHeapStubManager();
    if (g_pManager == NULL)
        return FALSE;

    StubManager::AddStubManager(g_pManager);

    return TRUE;
}

#ifdef SHOULD_WE_CLEANUP
void ThunkHeapStubManager::Uninit()
{
    delete g_pManager;
}
#endif /* SHOULD_WE_CLEANUP */

BOOL ThunkHeapStubManager::CheckIsStub(const BYTE *stubStartAddress)
{
    // Its a stub if its in our heaps range.
    return m_rangeList.IsInRange(stubStartAddress);
}

BOOL ThunkHeapStubManager::DoTraceStub(const BYTE *stubStartAddress, 
                                       TraceDestination *trace)
{
    // We never trace through these stubs when stepping through managed code. The only reason we have this stub manager
    // is so that IsTransitionStub can recgonize UMEntryThunks.
    return FALSE;
}


#define E_PROCESS_SHUTDOWN_REENTRY    HRESULT_FROM_WIN32(ERROR_PROCESS_ABORTED)



#ifdef _X86_
__declspec(naked)  void _cdecl IJWNOADThunk::MakeCall()
{
    struct 
    {
        IJWNOADThunk* This;
        AppDomain* pDomain;
        LPCVOID RetAddr;
        Module* pMod;
    } Vars;
    #define LocalsSize 16

    _asm enter LocalsSize+4,0; 
    _asm push ebx;
    _asm push ecx;
    _asm push edx;
    _asm push esi;
    _asm push edi;

    
    _asm mov Vars.This,eax;

    //careful above this point
    _ASSERTE(sizeof(Vars)<=LocalsSize); 
    SetupThread();

    Vars.pDomain=GetAppDomain();
    if(!Vars.pDomain)
    {
        _ASSERTE(!"Appdomain should've been set up by SetupThread");
        Vars.pDomain=SystemDomain::System()->DefaultDomain();
    }
    Vars.RetAddr=0;

    if(Vars.pDomain)
    {
        Vars.RetAddr=Vars.This->LookupInCache(Vars.pDomain);

        if (Vars.RetAddr==NULL)
        {
            Vars.pDomain->EnterLoadLock();
            Vars.pMod=Vars.pDomain->FindModule__Fixed(Vars.This->m_pModulebase); 
            Vars.pDomain->LeaveLoadLock();  

            if (Vars.pMod==NULL)
                Vars.pMod=Vars.pDomain->LoadModuleIfSharedDependency(Vars.This->m_pAssemblybase,Vars.This->m_pModulebase); 

            if (Vars.pMod!=NULL)
            {
                // jump to the real thunk
                Vars.RetAddr=(Vars.pMod->GetADThunkTable()[Vars.This->m_dwIndex]).GetCode();
                Vars.This->AddToCache(Vars.pDomain,Vars.RetAddr);
            }
        }

        if(Vars.RetAddr)
        {
            _asm pop edi;
            _asm pop esi;
            _asm pop edx;
            _asm pop ecx;
            _asm pop ebx;
            _asm mov eax,Vars.RetAddr;
            _asm leave;
            _asm jmp eax;
        }
    }
    _asm pop edi;
    _asm pop esi;
    _asm pop edx;
    _asm pop ecx;
    _asm pop ebx;
    _asm leave;
    SafeNoModule();
};
#else
void __cdecl IJWNOADThunk::MakeCall()
{
    _ASSERTE(!"@todo ia64");
}
#endif

void IJWNOADThunk::SafeNoModule()
{
    if (!CanRunManagedCode())
    {
        Thread* pThread=GetThread();

        // DO NOT IMPROVE THIS EXCEPTION!  It cannot be a managed exception.  It
        // cannot be a real exception object because we cannot execute any managed
        // code here.
        if(pThread)
            pThread->m_fPreemptiveGCDisabled = 0;
        COMPlusThrowBoot(E_PROCESS_SHUTDOWN_REENTRY);
    }
    NoModule();
}

void IJWNOADThunk::NoModule()
{
    THROWSCOMPLUSEXCEPTION();
    COMPlusThrowHR(COR_E_DLLNOTFOUND);
}

void Module::SetADThunkTable(UMEntryThunk* pTable)
{
    if (!GetAssembly()->IsShared())
    {
        m_pADThunkTable=pTable;
    }
    else
    {
        DomainLocalBlock *pLocalBlock = GetAppDomain()->GetDomainLocalBlock();
        _ASSERTE(pLocalBlock);
        if (pLocalBlock && SUCCEEDED(pLocalBlock->SafeEnsureIndex(m_pADThunkTableDLSIndexForSharedClasses)))
            pLocalBlock->SetSlot(m_pADThunkTableDLSIndexForSharedClasses,pTable);
        else
        {
            _ASSERTE(!"Unexpected DLS problem");
        }
    }
};

UMEntryThunk*   Module::GetADThunkTable()
{
    if (!GetAssembly()->IsShared())
    {
        return m_pADThunkTable;
    };
    DomainLocalBlock* pLocalBlock=GetAppDomain()->GetDomainLocalBlock();
    UMEntryThunk* pThunkTable=NULL;
    _ASSERTE(pLocalBlock);
    if (pLocalBlock && SUCCEEDED(pLocalBlock->SafeEnsureIndex(m_pADThunkTableDLSIndexForSharedClasses)))
    {
        pThunkTable=(UMEntryThunk*)pLocalBlock->GetSlot(m_pADThunkTableDLSIndexForSharedClasses);
        if (pThunkTable==NULL)
            CreateDomainThunks();// Not initialized for this domain yet
        pThunkTable=(UMEntryThunk*)pLocalBlock->GetSlot(m_pADThunkTableDLSIndexForSharedClasses);
        _ASSERTE(pThunkTable);
        return pThunkTable;
    }
    return NULL;
};

void  Module::CreateDomainThunks()
{
    AppDomain *pAppDomain = GetAppDomain();
    if(!pAppDomain)
    {
        _ASSERTE(!"No appdomain");
        return ;
    }
    IMAGE_COR20_HEADER *pHeader = GetCORHeader();

    // Check for no entries at all.
    if ((pHeader == NULL) || (pHeader->VTableFixups.VirtualAddress == 0))
        return;
    IMAGE_COR_VTABLEFIXUP *pFixupTable;
    pFixupTable = (IMAGE_COR_VTABLEFIXUP *)(GetILBase() + pHeader->VTableFixups.VirtualAddress);
    int iFixupRecords = pHeader->VTableFixups.Size / sizeof(IMAGE_COR_VTABLEFIXUP);

    DWORD iThunks=0;
    for (int iFixup = 0; iFixup < iFixupRecords; iFixup++)
        if (pFixupTable[iFixup].Type==(COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN|COR_VTABLE_32BIT))
            iThunks += pFixupTable[iFixup].Count;
    if (iThunks==0)
        return;

    UMEntryThunk* pTable=((UMEntryThunk*)(GetThunkHeap()->AllocMem(sizeof(UMEntryThunk)*iThunks)));
    _ASSERTE(pTable);
    DWORD dwCurrIndex=0;
    for (iFixup = 0; iFixup < iFixupRecords; iFixup++) 
    {          
        if (pFixupTable[iFixup].Type == (COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN|COR_VTABLE_32BIT)) 
        {
            const BYTE **pPointers = (const BYTE **)(GetILBase() + pFixupTable[iFixup].RVA);   
            for (int iMethod = 0; iMethod < pFixupTable[iFixup].Count; iMethod++) 
            {
                IJWNOADThunk* pThk=IJWNOADThunk::FromCode(pPointers[iMethod]);
                mdToken tok=pThk->GetToken(); //!!
                if(!m_pMDImport->IsValidToken(tok))
                {
                    _ASSERTE(!"bad token");
                    return;
                }
                MethodDesc *pMD = FindFunction(tok);
                _ASSERTE(pMD != NULL && "Invalid token in v-table fix-up table, use ildasm to find code gen error");
    
                // @TODO: Check for out of memory
                UMThunkMarshInfo *pUMThunkMarshInfo = (UMThunkMarshInfo*)(GetThunkHeap()->AllocMem(sizeof(UMThunkMarshInfo)));
                _ASSERTE(pUMThunkMarshInfo != NULL);
                FillMemory(pUMThunkMarshInfo, sizeof(*pUMThunkMarshInfo), 0);
                
                BYTE nlType = 0;
                CorPinvokeMap unmgdCallConv;
                
                {
                    DWORD   mappingFlags = 0xcccccccc;
                    LPCSTR  pszImportName = (LPCSTR)POISONC;
                    mdModuleRef modref = 0xcccccccc;
                    HRESULT hr = GetMDImport()->GetPinvokeMap(tok, &mappingFlags, &pszImportName, &modref);
                    if (FAILED(hr))
                    {
                        unmgdCallConv = (CorPinvokeMap)0;
                        nlType = nltAnsi;
                    }
                    else
                    {
                    
                        unmgdCallConv = (CorPinvokeMap)(mappingFlags & pmCallConvMask);
                        if (unmgdCallConv == pmCallConvWinapi)
                        {
                            unmgdCallConv = pmCallConvStdcall;
                        }
                    
                        switch (mappingFlags & (pmCharSetNotSpec|pmCharSetAnsi|pmCharSetUnicode|pmCharSetAuto))
                        {
                            case pmCharSetNotSpec: //fallthru to Ansi
                            case pmCharSetAnsi:
                            nlType = nltAnsi;
                            break;
                            case pmCharSetUnicode:
                                nlType = nltUnicode;
                                break;
                            case pmCharSetAuto:
                                nlType = (NDirectOnUnicodeSystem() ? nltUnicode : nltAnsi);
                                break;
                            default:
                                //@bug: Bogus! But I can't report an error from here!
                                _ASSERTE(!"Bad charset specified in Vtablefixup Pinvokemap.");
                        
                        }
                    }

                }
                
                PCCOR_SIGNATURE pSig;
                DWORD cSig;
                pMD->GetSig(&pSig, &cSig);
                pUMThunkMarshInfo->LoadTimeInit(pSig, 
                                                cSig,
                                                this,
                                                TRUE,
                                                nlType,
                                                unmgdCallConv,
                                                tok);

                pTable[dwCurrIndex].LoadTimeInit(NULL, NULL, pUMThunkMarshInfo, pMD, pAppDomain->GetId());
                if (pAppDomain->GetId()==pThk->GetCachedAD())
                    pThk->SetCachedDest(pTable[dwCurrIndex].GetCode());


                dwCurrIndex++;                    
            }
        }
    }
    SetADThunkTable(pTable);
}


inline LPCVOID IJWNOADThunk::LookupInCache(AppDomain* pDomain)
{
    if (pDomain->GetId()==m_StartAD)
        return m_StartADRetAddr;
    return NULL; // secondary cache will be here
};

inline void IJWNOADThunk::AddToCache(AppDomain* pDomain,LPCVOID pRetAddr)
{
    return; // secondary cache will be here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ceeload.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEELOAD.H
// 

// CEELOAD.H defines the class use to represent the PE file
// ===========================================================================
#ifndef CEELOAD_H_
#define CEELOAD_H_

#include <windows.h>
#include <wtypes.h> // for HFILE, HANDLE, HMODULE
#include <fusion.h>
#include "vars.hpp" // for LPCUTF8
#include "hash.h"
#include "cormap.hpp"
#include "dataimage.h"
#include "cgensys.h"
#include "corsym.h"
#include "typehandle.h"
#include "arraylist.h"
#include "PEFile.h"
#include <member-offset-info.h>

class PELoader;
class Stub;
class MethodDesc;
class FieldDesc;
class Crst;
class AssemblySecurityDescriptor;
class ClassConverter;
class RefClassWriter;
class InMemoryModule;
class ReflectionModule;
class EEStringData;
class MethodDescChunk;
class Assembly;
class BaseDomain;
class AppDomain;
class InMemoryModule;
class ReflectionModule;
class SystemDomain;
class Module;
class NLogModule;

#ifndef GOLDEN
#define ZAP_RECORD_LOAD_ORDER 1
#endif

// Used to help clean up interfaces
struct HelpForInterfaceCleanup
{
    void *pData;
    void (__stdcall *pFunction) (void*);
};

//
// LookupMaps are used to implement RID maps
//

struct LookupMap
{
    // This is not actually a pointer to the beginning of the
    // allocated memory, but instead a pointer to &pTable[-MinIndex].
    // Thus, if we know that this LookupMap is the correct one, simply
    // index into it.
    void              **pTable;
    struct LookupMap   *pNext;
    DWORD               dwMaxIndex;
    DWORD              *pdwBlockSize; // These all point to the same block size

    DWORD Find(void *pointer);

    HRESULT Save(DataImage *image, mdToken attribution = mdTokenNil);
    HRESULT Fixup(DataImage *image);
};

// 
// VASigCookies are allocated to encapsulate a varargs call signature.
// A reference to the cookie is embedded in the code stream.  Cookies
// are shared amongst call sites with identical signatures in the same 
// module
//

struct VASigCookie
{
    // The JIT wants knows that the size of the arguments comes first   
    // so please keep this field first  
    unsigned        sizeOfArgs;             // size of argument list
    Stub           *pNDirectMLStub;         // will be use if target is NDirect (tag == 0)
    PCCOR_SIGNATURE mdVASig;                // The debugger depends on this being here,
                                            // so please don't move it without changing
                                            // the GetVAInfo debugger routine.
    Module*        pModule;
    VOID Destruct();
};

//
// VASigCookies are allocated in VASigCookieBlocks to amortize
// allocation cost and allow proper bookkeeping.
//

struct VASigCookieBlock
{
    enum {
#ifdef _DEBUG
        kVASigCookieBlockSize = 2 
#else
        kVASigCookieBlockSize = 20 
#endif
    };

    VASigCookieBlock    *m_Next;
    UINT                 m_numcookies;
    VASigCookie          m_cookies[kVASigCookieBlockSize];
};


//
// A Module is the primary unit of code packaging in the runtime.  It
// corresponds mostly to an OS executable image, although other kinds
// of modules exist. 
//
class UMEntryThunk;
class Module
{
    friend HRESULT InitializeMiniDumpBlock();
    friend class ZapMonitor;
    friend struct MEMBER_OFFSET_INFO(Module);

 public:

#ifdef _DEBUG
    // Force verification even if it's turned off
    BOOL                    m_fForceVerify;
#endif

private:

    PEFile                  *m_file;
    PEFile                  *m_zapFile;

    BYTE                    *m_ilBase;

    IMDInternalImport       *m_pMDImport;
    IMetaDataEmit           *m_pEmitter;
    IMetaDataImport         *m_pImporter;
    IMetaDataDispenserEx    *m_pDispenser;

    MethodDesc              *m_pDllMain;

    enum {
        INITIALIZED                 = 0x00000001,
        HAS_CRITICAL_SECTION        = 0x00000002,
        IS_IN_MEMORY                = 0x00000004,
        IS_REFLECTION               = 0x00000008,
        IS_PRELOAD                  = 0x00000010,
        SUPPORTS_UPDATEABLE_METHODS = 0x00000020,
        CLASSES_FREED               = 0x00000040,
        IS_PEFILE                   = 0x00000080,
        IS_PRECOMPILE               = 0x00000100,
        IS_EDIT_AND_CONTINUE        = 0x00000200,

        //
        // Note: the order of these must match the order defined in
        // cordbpriv.h for DebuggerAssemblyControlFlags. The three
        // values below should match the values defined in
        // DebuggerAssemblyControlFlags when shifted right
        // DEBUGGER_INFO_SHIFT bits.
        //
        DEBUGGER_USER_OVERRIDE_PRIV = 0x00000400,
        DEBUGGER_ALLOW_JIT_OPTS_PRIV= 0x00000800,
        DEBUGGER_TRACK_JIT_INFO_PRIV= 0x00001000,
        DEBUGGER_ENC_ENABLED        = 0x00002000,
        DEBUGGER_PDBS_COPIED        = 0x00004000,
        DEBUGGER_INFO_MASK_PRIV     = 0x00007c00,
        DEBUGGER_INFO_SHIFT_PRIV    = 10,

        IS_RESOURCE                 = 0x00100000,
        CLASSES_HASHED              = 0x00200000,

        // flag used to mark member ref pointers to field descriptors in the member ref cache
        IS_FIELD_MEMBER_REF         = 0x00000001
    };

    DWORD                   m_dwFlags;

    // Linked list of VASig cookie blocks: protected by m_pStubListCrst
    VASigCookieBlock        *m_pVASigCookieBlock;

    Assembly                *m_pAssembly;
    mdFile                  m_moduleRef;
    int                     m_dwModuleIndex;

    Crst                   *m_pCrst;
    BYTE                    m_CrstInstance[sizeof(Crst)];

    // May point to the default instruction decoding table, in which
    // case we should not free it
    void *                  m_pInstructionDecodingTable;

    MethodTable             *m_pMethodTable;

    // Debugging symbols reader interface. This will only be
    // initialized if needed, either by the debugging subsystem or for
    // an exception.
    ISymUnmanagedReader     *m_pISymUnmanagedReader;
    PCRITICAL_SECTION        m_pISymUnmanagedReaderLock;

    // Next module loaded by the same classloader (all modules loaded by the same classloader
    // are linked through this field).
    Module *                m_pNextModule;

    // Base DLS index for classes in this module
    SIZE_T                  m_dwBaseClassIndex;

    // Range of preloaded image, to facilitate proper cleanup
    void                    *m_pPreloadRangeStart;
    void                    *m_pPreloadRangeEnd;

    // Table of thunks for unmanaged vtables
    BYTE *                  m_pThunkTable;

    // Exposed object of Class object for the module
    union
    {
        OBJECTHANDLE        m_ExposedModuleObject;      // non-shared
        SIZE_T              m_ExposedModuleObjectIndex; // shared
    };

    LoaderHeap *            m_pLookupTableHeap;
    BYTE                    m_LookupTableHeapInstance[sizeof(LoaderHeap)]; // For in-place new()

    // For protecting additions to the heap
    Crst                   *m_pLookupTableCrst;
    BYTE                    m_LookupTableCrstInstance[sizeof(Crst)];

    // Linear mapping from TypeDef token to MethodTable *
    LookupMap               m_TypeDefToMethodTableMap;
    DWORD                   m_dwTypeDefMapBlockSize;

    // Linear mapping from TypeRef token to TypeHandle *
    LookupMap               m_TypeRefToMethodTableMap;

    DWORD                   m_dwTypeRefMapBlockSize;

    // Linear mapping from MethodDef token to MethodDesc *
    LookupMap               m_MethodDefToDescMap;
    DWORD                   m_dwMethodDefMapBlockSize;

    // Linear mapping from FieldDef token to FieldDesc*
    LookupMap               m_FieldDefToDescMap;
    DWORD                   m_dwFieldDefMapBlockSize;

    // Linear mapping from MemberRef token to MethodDesc*, FieldDesc*
    LookupMap               m_MemberRefToDescMap;
    DWORD                   m_dwMemberRefMapBlockSize;

    // Mapping from File token to Module *
    LookupMap               m_FileReferencesMap;
    DWORD                   m_dwFileReferencesMapBlockSize;

    // Mapping of AssemblyRef token to Assembly *
    LookupMap               m_AssemblyReferencesMap;
    DWORD                   m_dwAssemblyReferencesMapBlockSize;

    // Pointer to binder, if we have one
    friend class Binder;
    Binder                  *m_pBinder;

    // This buffer is used to jump to the prestub in preloaded modules
    BYTE                    m_PrestubJumpStub[JUMP_ALLOCATE_SIZE];

    // This buffer is used to jump to the ndirect import stub in preloaded modules
    BYTE                    m_NDirectImportJumpStub[JUMP_ALLOCATE_SIZE];

    // This buffer is used to jump to vtable fixup stub
    BYTE                    m_FixupVTableJumpStub[JUMP_ALLOCATE_SIZE];

    BYTE                    *m_pJumpTargetTable;
    int                     m_cJumpTargets;

    DWORD                   *m_pFixupBlobs;
    DWORD                   m_cFixupBlobs;

    BYTE                    *m_alternateRVAStaticBase;

#if ZAP_RECORD_LOAD_ORDER
    HANDLE                  m_loadOrderFile;
#endif

    // Stats for prejit log
    ArrayList               *m_compiledMethodRecord;
    ArrayList               *m_loadedClassRecord;

    // LoaderHeap for storing thunks
    LoaderHeap              *m_pThunkHeap;

    // Self-initializing accessor for m_pThunkHeap
    LoaderHeap              *GetThunkHeap();
protected:
    UMEntryThunk            *m_pADThunkTable;
    SIZE_T                   m_pADThunkTableDLSIndexForSharedClasses;
public:
    UMEntryThunk*           GetADThunkTable();
    void                    SetADThunkTable(UMEntryThunk* pTable);

 protected:
    void CreateDomainThunks();
    HRESULT RuntimeInit();
    HRESULT Init(BYTE *baseAddress);

    HRESULT Init(PEFile *pFile, PEFile *pZapFile, BOOL preload);
    
    HRESULT AllocateMaps();

    // Flags    

    void SetInMemory() { m_dwFlags |= IS_IN_MEMORY; }
    void SetPEFile() { m_dwFlags |= IS_PEFILE; }
    void SetReflection() { m_dwFlags |= IS_REFLECTION; }
    void SetPreload() { m_dwFlags |= IS_PRELOAD; }
    void SetPrecompile() { m_dwFlags |= IS_PRECOMPILE; }
    void SetSupportsUpdateableMethods() { m_dwFlags |= SUPPORTS_UPDATEABLE_METHODS; }
    void SetInitialized() { m_dwFlags |= INITIALIZED; }
    void SetEditAndContinue() 
    { 
        LOG((LF_CORDB, LL_INFO10000, "SetEditAndContinue: this:0x%x, %s\n", GetFileName()));
        m_dwFlags |= IS_EDIT_AND_CONTINUE; 
    }

    void SetPreloadRange(void *start, void *end) 
      { m_pPreloadRangeStart = start; m_pPreloadRangeEnd = end; }

    void SetMDImport(IMDInternalImport *pImport);
    void SetEmit(IMetaDataEmit *pEmit);

    // RID maps
    LookupMap *IncMapSize(LookupMap *pMap, DWORD rid);
    BOOL AddToRidMap(LookupMap *pMap, DWORD rid, void *pDatum);
    void *GetFromRidMap(LookupMap *pMap, DWORD rid);

#ifdef _DEBUG
    void DebugGetRidMapOccupancy(LookupMap *pMap, 
                                 DWORD *pdwOccupied, DWORD *pdwSize);
    void DebugLogRidMapOccupancy();
#endif

    static HRESULT VerifyFile(PEFile *file, BOOL fZap);

    static HRESULT Create(PEFile *pFile, Module **ppModule, BOOL isEnC);

 public:

    static HRESULT Create(PEFile *pFile, PEFile *pZap, Module **ppModule, BOOL isEnC);
    static HRESULT CreateResource(PEFile *file, Module **ppModule);

    Module()
    {
        m_pUMThunkHash = NULL;
        m_pMUThunkHash = NULL;
        m_file = NULL;
        m_pISymUnmanagedReaderLock = NULL;
    }

    // flags
    void SetResource() { m_dwFlags |=  IS_RESOURCE; }
    BOOL IsResource() { return ((m_dwFlags & IS_RESOURCE) != 0);}

    void SetClassesHashed() { m_dwFlags |=  CLASSES_HASHED; }
    BOOL AreClassesHashed() { return ((m_dwFlags & CLASSES_HASHED) != 0);}

    VOID LOCK()
    {
        m_pCrst->Enter();
    }
    
    VOID UNLOCK()
    {
        m_pCrst->Leave();
    }
    virtual void Destruct();

    HRESULT SetContainer(Assembly *pAssembly, 
                         int moduleIndex,
                         mdToken moduleRef,
                         BOOL fResource,
                         OBJECTREF *pThrowable);
    
    void FixupVTables(OBJECTREF *pThrowable);

    void ReleaseMDInterfaces(BOOL fForEnC=FALSE);
    void FreeClassTables();
    void Unload();
    void UnlinkClasses(AppDomain *pDomain);

    InMemoryModule *GetInMemoryModule()
    {
        _ASSERTE(IsInMemory());
        return (InMemoryModule *) this;
    }
    ReflectionModule *GetReflectionModule()
    {
        _ASSERTE(IsReflection());
        return (ReflectionModule *) this;
    }

    // This API is only used in reflection emit to set up the in-memory manifest module to have
    // a back pointer back to assembly.
    void SetAssembly(Assembly *pAssembly) {m_pAssembly = pAssembly;}

    MethodTable *GetMethodTable() 
    { 
        return m_pMethodTable; 
    }

    Assembly* GetAssembly()
    {
        return m_pAssembly;
    }

    int GetClassLoaderIndex()
    {
        return m_dwModuleIndex;
    }

    ClassLoader *GetClassLoader();
    BaseDomain* GetDomain();
    AssemblySecurityDescriptor* GetSecurityDescriptor();

    mdFile GetModuleRef()
    {
        return m_moduleRef;
    }

    BYTE *GetILBase()
    {
        return m_ilBase;
    }

    void *GetInstructionDecodingTable()
    {
        return m_pInstructionDecodingTable;
    }

    void SetBaseClassIndex(SIZE_T index)
    {
        m_dwBaseClassIndex = index;
    }

    SIZE_T GetBaseClassIndex()
    {
        return m_dwBaseClassIndex;
    }

    BOOL IsInMemory() { return (m_dwFlags & IS_IN_MEMORY) != 0; }
    BOOL IsPEFile() { return (m_dwFlags & IS_PEFILE) != 0; }
    BOOL IsReflection() { return (m_dwFlags & IS_REFLECTION) != 0; }
    BOOL IsPreload() { return (m_dwFlags & IS_PRELOAD) != 0; }
    BOOL IsPrecompile() { return (m_dwFlags & IS_PRECOMPILE) != 0; }
    BOOL SupportsUpdateableMethods() { return (m_dwFlags & SUPPORTS_UPDATEABLE_METHODS) != 0; }
    BOOL IsInitialized() { return (m_dwFlags & INITIALIZED) != 0; }
    BOOL IsEditAndContinue() { return (m_dwFlags & IS_EDIT_AND_CONTINUE) != 0; }

    BOOL IsPreloadedObject(void *address)
      { return address >= m_pPreloadRangeStart && address < m_pPreloadRangeEnd; }

    BOOL IsSystem();
    BOOL IsSystemFile() { return m_file != NULL && m_file->IsSystem(); }

    BOOL IsSystemClasses();
    BOOL IsFullyTrusted();

    IMDInternalImport *GetMDImport() const
    {
        _ASSERTE(m_pMDImport != NULL);
        return m_pMDImport;
    }

    IMDInternalImport *GetZapMDImport() const
    {
        _ASSERTE(m_zapFile != NULL);
        return m_zapFile->GetMDImport();
    }

    PEFile *GetPEFile()
    {
        _ASSERTE(IsPEFile());
        return m_file;
    }

    IMAGE_NT_HEADERS *GetNTHeader() 
    { 
        return GetPEFile()->GetNTHeader(); 
    }
    IMAGE_COR20_HEADER *GetCORHeader() 
    { 
        return GetPEFile()->GetCORHeader(); 
    }

    LPCWSTR GetFileName();
    HRESULT GetFileName(LPSTR name, DWORD max, DWORD *count);

    // Note: to get the public assembly importer, call GetAssembly()->GetManifestAssemblyImport()
    IMetaDataEmit *GetEmitter();
    IMetaDataImport *GetImporter();
    IMetaDataDispenserEx *GetDispenser();
    
    static HRESULT ConvertMDInternalToReadWrite(IMDInternalImport **ppImport);
    HRESULT ConvertMDInternalToReadWrite() 
    { return ConvertMDInternalToReadWrite(&m_pMDImport); }

    Module *GetNextModule() { return m_pNextModule; }
    void SetNextModule(Module *pModule) { m_pNextModule = pModule; }
    
    ISymUnmanagedReader *GetISymUnmanagedReader(void);
    HRESULT UpdateISymUnmanagedReader(IStream *pStream);
    HRESULT SetSymbolBytes(BYTE *pSyms, DWORD cbSyms);

    // This is used by the debugger, in case the symbols aren't
    // available in an on-disk .pdb file (reflection emit, 
    // Assembly.Load(byte[],byte[]), etc.
    CGrowableStream *m_pIStreamSym;
    CGrowableStream *GetInMemorySymbolStream()
    {
        return m_pIStreamSym;
    }

    void SetInMemorySymbolStream(CGrowableStream *pStream)
    {
        m_pIStreamSym = pStream;
    }

    static HRESULT TrackIUnknownForDelete(IUnknown *pUnk,
                                          IUnknown ***pppUnk,
                                          HelpForInterfaceCleanup *pCleanHelp=NULL);
    static void ReleaseAllIUnknowns(void);
    static void ReleaseIUnknown(IUnknown *pUnk);
    static void ReleaseIUnknown(IUnknown **pUnk);
    void ReleaseISymUnmanagedReader(void);

    static void ReleaseMemoryForTracking();
    
    void FusionCopyPDBs(LPCWSTR moduleName);

    void DisplayFileLoadError(HRESULT hrRpt);

    OBJECTREF GetExposedModuleObject(AppDomain *pDomain=NULL);
    OBJECTREF GetExposedModuleBuilderObject(AppDomain *pDomain=NULL);

    // Classes
    BOOL AddClass(mdTypeDef classdef);
    HRESULT BuildClassForModule(OBJECTREF *pThrowable);

    // Resolving
    virtual BYTE *GetILCode(DWORD target) const;
    void ResolveStringRef(DWORD Token, EEStringData *pStringData) const;
    virtual BYTE *ResolveILRVA(DWORD rva, BOOL hasRVA) const { return ((BYTE*) (rva + m_ilBase)); }
    BOOL IsValidStringRef(DWORD rva);

    // RID maps
    TypeHandle LookupTypeDef(mdTypeDef token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtTypeDef);
        return (TypeHandle) GetFromRidMap(&m_TypeDefToMethodTableMap, 
                                           RidFromToken(token));
    }
    BOOL StoreTypeDef(mdTypeDef token, TypeHandle value)
    {
        _ASSERTE(TypeFromToken(token) == mdtTypeDef);
        return AddToRidMap(&m_TypeDefToMethodTableMap, 
                           RidFromToken(token),
                           value.AsPtr());
    }
    mdTypeDef FindTypeDef(TypeHandle type)
    {
        return m_TypeDefToMethodTableMap.Find(type.AsPtr()) | mdtTypeDef;
    }
    DWORD GetTypeDefMax() { return m_TypeDefToMethodTableMap.dwMaxIndex; }

    TypeHandle LookupTypeRef(mdTypeRef token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtTypeRef);
        return (TypeHandle) GetFromRidMap(&m_TypeRefToMethodTableMap, 
                                           RidFromToken(token));
    }
    BOOL StoreTypeRef(mdTypeRef token, TypeHandle value)
    {
        _ASSERTE(TypeFromToken(token) == mdtTypeRef);
        return AddToRidMap(&m_TypeRefToMethodTableMap, 
                           RidFromToken(token),
                           value.AsPtr());
    }
    mdTypeRef FindTypeRef(TypeHandle type)
    {
        return m_TypeRefToMethodTableMap.Find(type.AsPtr()) | mdtTypeRef;
    }
    DWORD GetTypeRefMax() { return m_TypeRefToMethodTableMap.dwMaxIndex; }

    MethodDesc *LookupMethodDef(mdMethodDef token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtMethodDef);
        return (MethodDesc*) GetFromRidMap(&m_MethodDefToDescMap, 
                                           RidFromToken(token));
    }
    BOOL StoreMethodDef(mdMethodDef token, MethodDesc *value)
    {
        _ASSERTE(TypeFromToken(token) == mdtMethodDef);
        return AddToRidMap(&m_MethodDefToDescMap, 
                           RidFromToken(token),
                           value);
    }
    mdMethodDef FindMethodDef(MethodDesc *value)
    {
        return m_MethodDefToDescMap.Find(value) | mdtMethodDef;
    }
    DWORD GetMethodDefMax() { return m_MethodDefToDescMap.dwMaxIndex; }

    FieldDesc *LookupFieldDef(mdFieldDef token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtFieldDef);
        return (FieldDesc*) GetFromRidMap(&m_FieldDefToDescMap, 
                                           RidFromToken(token));
    }
    BOOL StoreFieldDef(mdFieldDef token, FieldDesc *value)
    {
        _ASSERTE(TypeFromToken(token) == mdtFieldDef);
        return AddToRidMap(&m_FieldDefToDescMap, 
                           RidFromToken(token),
                           value);
    }
    mdFieldDef FindFieldDef(FieldDesc *value)
    {
        return m_FieldDefToDescMap.Find(value) | mdtFieldDef;
    }
    DWORD GetFieldDefMax() { return m_FieldDefToDescMap.dwMaxIndex; }

    void *LookupMemberRef(mdMemberRef token, BOOL *pfIsMethod)
    { 
        _ASSERTE(TypeFromToken(token) == mdtMemberRef);
        void *pResult = GetFromRidMap(&m_MemberRefToDescMap, 
                                      RidFromToken(token));
        *pfIsMethod = ((size_t)pResult & IS_FIELD_MEMBER_REF) == 0;
        return (void*)((size_t)pResult & ~(size_t)IS_FIELD_MEMBER_REF);
    }
    MethodDesc *LookupMemberRefAsMethod(mdMemberRef token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtMemberRef);
        MethodDesc *pMethodDesc = (MethodDesc*)GetFromRidMap(&m_MemberRefToDescMap, 
                                                             RidFromToken(token));
        _ASSERTE(((size_t)pMethodDesc & IS_FIELD_MEMBER_REF) == 0);
        return pMethodDesc;
    }
    BOOL StoreMemberRef(mdMemberRef token, FieldDesc *value)
    {
        _ASSERTE(TypeFromToken(token) == mdtMemberRef);
        return AddToRidMap(&m_MemberRefToDescMap, 
                           RidFromToken(token),
                           (void*)((size_t)value | IS_FIELD_MEMBER_REF));
    }
    BOOL StoreMemberRef(mdMemberRef token, MethodDesc *value)
    {
        _ASSERTE(TypeFromToken(token) == mdtMemberRef);
        return AddToRidMap(&m_MemberRefToDescMap, 
                           RidFromToken(token),
                           value);
    }
    mdMemberRef FindMemberRef(MethodDesc *value)
    {
        return m_MemberRefToDescMap.Find(value) | mdtMemberRef;
    }
    mdMemberRef FindMemberRef(FieldDesc *value)
    {
        return m_MemberRefToDescMap.Find(value) | mdtMemberRef;
    }
    DWORD GetMemberRefMax() { return m_MemberRefToDescMap.dwMaxIndex; }

    Module *LookupFile(mdFile token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtFile);
        return (Module*) GetFromRidMap(&m_FileReferencesMap, 
                                           RidFromToken(token));
    }
    BOOL StoreFile(mdFile token, Module *value)
    {
        _ASSERTE(TypeFromToken(token) == mdtFile);
        return AddToRidMap(&m_FileReferencesMap, 
                           RidFromToken(token),
                           value);
    }
    mdFile FindFile(Module *value)
    {
        return m_FileReferencesMap.Find(value) | mdtFile;
    }
    DWORD GetFileMax() { return m_FileReferencesMap.dwMaxIndex; }

    Assembly *LookupAssemblyRef(mdAssemblyRef token)
    { 
        _ASSERTE(TypeFromToken(token) == mdtAssemblyRef);
        return (Assembly*) GetFromRidMap(&m_AssemblyReferencesMap, 
                                       RidFromToken(token));
    }
    BOOL StoreAssemblyRef(mdAssemblyRef token, Assembly *value)
    {
        _ASSERTE(TypeFromToken(token) == mdtAssemblyRef);
        return AddToRidMap(&m_AssemblyReferencesMap, 
                           RidFromToken(token),
                           value);
    }
    mdAssemblyRef FindAssemblyRef(Assembly *value)
    {
        return m_AssemblyReferencesMap.Find(value) | mdtAssemblyRef;
    }
    DWORD GetAssemblyRefMax() { return m_AssemblyReferencesMap.dwMaxIndex; }

    MethodDesc *FindFunction(mdToken pMethod);

    // Methods for declarative linktime and inheritance
    OBJECTREF GetLinktimePermissions(mdToken token, OBJECTREF *prefNonCasDemands);
    OBJECTREF GetInheritancePermissions(mdToken token, OBJECTREF *prefNonCasDemands);
    OBJECTREF GetCasInheritancePermissions(mdToken token);
    OBJECTREF GetNonCasInheritancePermissions(mdToken token);
    
#ifdef DEBUGGING_SUPPORTED
    // Debugger stuff
    void NotifyDebuggerLoad();
    BOOL NotifyDebuggerAttach(AppDomain *pDomain, int level, BOOL attaching);
    void NotifyDebuggerDetach(AppDomain *pDomain);

    DebuggerAssemblyControlFlags GetDebuggerInfoBits(void)
    {
        return (DebuggerAssemblyControlFlags)((m_dwFlags &
                                               DEBUGGER_INFO_MASK_PRIV) >>
                                              DEBUGGER_INFO_SHIFT_PRIV);
    }

    void SetDebuggerInfoBits(DebuggerAssemblyControlFlags newBits)
    {
        _ASSERTE(((newBits << DEBUGGER_INFO_SHIFT_PRIV) &
                  ~DEBUGGER_INFO_MASK_PRIV) == 0);

        m_dwFlags &= ~DEBUGGER_INFO_MASK_PRIV;
        m_dwFlags |= (newBits << DEBUGGER_INFO_SHIFT_PRIV);
    }
#endif // DEBUGGING_SUPPORTED

    // Get any cached ITypeLib* for the module. 
    ITypeLib *GetTypeLib(); 
    // Cache the ITypeLib*, if one is not already cached.   
    void SetTypeLib(ITypeLib *pITLB);   
    ITypeLib *GetTypeLibTCE(); 
    void SetTypeLibTCE(ITypeLib *pITLB);   

    // Enregisters a VASig. Returns NULL for failure (out of memory.)
    VASigCookie *GetVASigCookie(PCCOR_SIGNATURE pVASig, Module *pScopeModule = NULL);

    // DLL entry point
    MethodDesc *GetDllEntryPoint()
    {
        return m_pDllMain;
    }
    void SetDllEntryPoint(MethodDesc *pMD)
    {
        m_pDllMain = pMD;
    }

    LPVOID GetUMThunk(LPVOID pManagedIp, PCCOR_SIGNATURE pSig, ULONG cSig);
    LPVOID GetMUThunk(LPVOID pUnmanagedIp, PCCOR_SIGNATURE pSig, ULONG cSig);

    //
    // Zap file stuff
    //

 private:

    LPVOID FindUMThunkInFixups(LPVOID pManagedIp, PCCOR_SIGNATURE pSig, ULONG cSig);

    class UMThunkHash *m_pUMThunkHash;
    class MUThunkHash *m_pMUThunkHash;
 public:

    BYTE *GetZapBase() 
      { return (m_zapFile == NULL ? 0 : m_zapFile->GetBase()); }
    IMAGE_COR20_HEADER *GetZapCORHeader()
      { return (m_zapFile == NULL ? 0 : m_zapFile->GetCORHeader()); }
    
    BYTE *GetAlternateRVAStaticBase()
      { return m_alternateRVAStaticBase; }

    Module *GetBlobModule(DWORD rva);
    void FixupDelayList(DWORD *list);
    
    HRESULT ExpandAll(DataImage *image);
    HRESULT Save(DataImage *image, mdToken *pSaveOrderArray, DWORD cSaveOrderArray);
    HRESULT Fixup(DataImage *image, DWORD *pRidToCodeRVAMap);
    SLOT __cdecl FixupInheritedSlot(MethodTable *pMT, int slotNumber);

    BOOL LoadTokenTables();

    BYTE *GetPrestubJumpStub() { return m_PrestubJumpStub; }
    BYTE *GetNDirectImportJumpStub() { return m_NDirectImportJumpStub; }
    BYTE *GetJumpTargetTable() { return m_pJumpTargetTable; }
    BOOL IsJumpTargetTableEntry(SLOT addr);
    int GetJumpTargetTableSlotNumber(SLOT addr);

    void LogClassLoad(EEClass *pClass);
    void LogHeapAccess(DWORD dwSection, ULONG uOffset, void *strAddress);
    void LogMethodLoad(MethodDesc *pMethod);

#if ZAP_RECORD_LOAD_ORDER
    void OpenLoadOrderLogFile();
    void CloseLoadOrderLogFile();
#endif

    NLogModule *CreateModuleLog();
};

//
// An InMemoryModule is a module loaded from a memory image
//

class InMemoryModule : public Module
{
 private:
     Assembly* m_pCreatingAssembly;

 public:
    HCEESECTION m_sdataSection;
 protected:
    ICeeGen *m_pCeeFileGen; 
 public:
    InMemoryModule();

    virtual HRESULT Init(REFIID riidCeeGen);

    void Destruct();

    ICeeGen *GetCeeGen() { return m_pCeeFileGen; }  

    virtual REFIID ModuleType();    

    // Overides functions to access sections
    virtual BYTE* GetILCode(DWORD target) const;
    virtual BYTE* ResolveILRVA(DWORD target, BOOL hasRVA) const;

    Assembly* GetCreatingAssembly( void )
    {
        return m_pCreatingAssembly;
    }

    void SetCreatingAssembly( Assembly* assembly )
    {
        m_pCreatingAssembly = assembly;
    }


};


//
// A ReflectionModule is a module created by reflection
//

// {F5398690-98FE-11d2-9C56-00A0C9B7CC45}
extern const GUID DECLSPEC_SELECT_ANY IID_ICorReflectionModule = 
{ 0xf5398690, 0x98fe, 0x11d2, { 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45 } };
class ReflectionModule : public InMemoryModule 
{
private:
    ISymUnmanagedWriter **m_ppISymUnmanagedWriter;
    RefClassWriter       *m_pInMemoryWriter;
    WCHAR                *m_pFileName;

public:
    HRESULT Init(REFIID riidCeeGen);

    void Destruct();
 
    RefClassWriter *GetClassWriter()    
    {   
        return m_pInMemoryWriter;   
    }   

    ISymUnmanagedWriter *GetISymUnmanagedWriter()
    {
        // If we haven't set up room for a writer, then we certinally
        // haven't set one, so just return NULL.
        if (m_ppISymUnmanagedWriter == NULL)
            return NULL;
        else
            return *m_ppISymUnmanagedWriter;
    }

    ISymUnmanagedWriter **GetISymUnmanagedWriterAddr()
    {
        // We must have setup room for the writer before trying to get
        // the address for it. Any calls to this before a
        // SetISymUnmanagedWriter are very incorrect.
        _ASSERTE(m_ppISymUnmanagedWriter != NULL);
        
        return m_ppISymUnmanagedWriter;
    }

    HRESULT SetISymUnmanagedWriter(ISymUnmanagedWriter *pWriter, HelpForInterfaceCleanup* hlp=NULL)
    {
        // Setting to NULL when we've never set a writer before should
        // do nothing.
        if ((pWriter == NULL) && (m_ppISymUnmanagedWriter == NULL))
            return S_OK;
        
        // Make room for the writer if necessary.
        if (m_ppISymUnmanagedWriter == NULL)
        {
       
            return Module::TrackIUnknownForDelete(
                                   (IUnknown*)pWriter,
                                   (IUnknown***)&m_ppISymUnmanagedWriter,
                                   hlp);
        }
        else
        {
            if (*m_ppISymUnmanagedWriter)
                ((IUnknown*)(*m_ppISymUnmanagedWriter))->Release();
            *m_ppISymUnmanagedWriter = pWriter;
            return S_OK;
        }
    }

    WCHAR *GetFileName()
    {
        return m_pFileName;
    }

    void SetFileName(WCHAR *fileName)
    {
        if (fileName != NULL)
        {
            DWORD len = (DWORD)wcslen(fileName);

            if (len > 0)
            {
                _ASSERTE(m_pFileName == NULL);

                m_pFileName = new WCHAR[len+1];

                if (m_pFileName != NULL)
                {
                    wcscpy(m_pFileName, fileName);
                }
            }
        }
    }

    virtual REFIID ModuleType();    
};

//
// CorModule is a COM wrapper for modules
//

class CorModule : public ICorModule 
{
    long m_cRefs;   
    InMemoryModule *m_pModule;  

  public:
    CorModule();    
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void **ppInterface);

    STDMETHODIMP Initialize(DWORD flags, REFIID riidCeeGen, REFIID riidEmitter);
    STDMETHODIMP GetCeeGen(ICeeGen **pCeeGen);  
    STDMETHODIMP GetMetaDataEmit(IMetaDataEmit **pEmitter); 

    void SetModule(InMemoryModule *pModule) {   
        m_pModule = pModule;    
    }   
    InMemoryModule *GetModule(void) {   
        return m_pModule;   
    }   
    ReflectionModule *GetReflectionModule() {   
        _ASSERTE(m_pModule->ModuleType() == IID_ICorReflectionModule);  
        return reinterpret_cast<ReflectionModule *>(m_pModule); 
    }   
};


//----------------------------------------------------------------------
// VASigCookieEx (used to create a fake VASigCookie for unmanaged->managed
// calls to vararg functions. These fakes are distinguished from the
// real thing by having a null mdVASig.
//----------------------------------------------------------------------
struct VASigCookieEx : public VASigCookie
{
    const BYTE *m_pArgs;        // pointer to first unfixed unmanaged arg
};



#endif // CEELOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ceemain.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEEMAIN.CPP
// 
// ===========================================================================

#include "common.h"

// declare global variables
#define DECLARE_DATA
#include "vars.hpp"
#include "veropcodes.hpp"
#undef DECLARE_DATA

#include "DbgAlloc.h"
#include "log.h"
#include "ceemain.h"
#include "clsload.hpp"
#include "object.h"
#include "hash.h"
#include "ecall.h"
#include "ceemain.h"
#include "ndirect.h"
#include "syncblk.h"
#include "COMMember.h"
#include "COMString.h"
#include "COMSystem.h"
#include "EEConfig.h"
#include "stublink.h"
#include "handletable.h"
#include "method.hpp"
#include "codeman.h"
#include "gcscan.h"
#include "frames.h"
#include "threads.h"
#include "stackwalk.h"
#include "gc.h"
#include "interoputil.h"
#include "security.h"
#include "nstruct.h"
#include "DbgInterface.h"
#include "EEDbgInterfaceImpl.h"
#include "DebugDebugger.h"
#include "CorDBPriv.h"
#include "remoting.h"
#include "COMDelegate.h"
#include "nexport.h"
#include "icecap.h"
#include "AppDomain.hpp"
#include "CorMap.hpp"
#include "PerfCounters.h"
#include "RWLock.h"
#include "IPCManagerInterface.h"
#include "tpoolwrap.h"
#include "nexport.h"
#include "COMCryptography.h"
#include "InternalDebug.h"
#include "corhost.h"
#include "binder.h"
#include "olevariant.h"

#include "compluswrapper.h"
#include "IPCFuncCall.h"
#include "PerfLog.h"
#include "..\dlls\mscorrc\resource.h"

#include "COMNlsInfo.h"

#include "util.hpp"
#include "ShimLoad.h"

#include "zapmonitor.h"
#include "ComThreadPool.h"

#include "StackProbe.h"
#include "PostError.h"

#include "Timeline.h"

#include "minidumppriv.h"

#ifdef PROFILING_SUPPORTED 
#include "ProfToEEInterfaceImpl.h"
#endif // PROFILING_SUPPORTED

#include "notifyexternals.h"
#include "corsvcpriv.h"

#include "StrongName.h"
#include "COMCodeAccessSecurityEngine.h"
#include "SyncClean.hpp"
#include "PEVerifier.h"
#include <dump-tables.h>

#ifdef CUSTOMER_CHECKED_BUILD
#include "CustomerDebugHelper.h"
#endif

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


#   define DEAD_OBJECT_CACHE_SIZE 30*1024*1024 

HRESULT RunDllMain(MethodDesc *pMD, HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);

static HRESULT InitializeIPCManager(void);
static void TerminateIPCManager(void);

static HRESULT InitializeMiniDumpBlock();
static HRESULT InitializeDumpDataBlock();


static int GetThreadUICultureName(LPWSTR szBuffer, int length);
static int GetThreadUICultureParentName(LPWSTR szBuffer, int length);
static int GetThreadUICultureId();


static HRESULT NotifyService();

BOOL g_fSuspendOnShutdown = FALSE;

#ifdef DEBUGGING_SUPPORTED
static HRESULT InitializeDebugger(void);
static void TerminateDebugger(void);
extern "C" HRESULT __cdecl CorDBGetInterface(DebugInterface** rcInterface);
static void GetDbgProfControlFlag();
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
static HRESULT InitializeProfiling();
static void TerminateProfiling(BOOL fProcessDetach);
#endif // PROFILING_SUPPORTED

static HRESULT InitializeGarbageCollector();
static void TerminateGarbageCollector();

// This is our Ctrl-C, Ctrl-Break, etc. handler.
static BOOL WINAPI DbgCtrlCHandler(DWORD dwCtrlType)
{
#ifdef DEBUGGING_SUPPORTED
    if (CORDebuggerAttached() &&
        (dwCtrlType == CTRL_C_EVENT || dwCtrlType == CTRL_BREAK_EVENT))
    {
        return g_pDebugInterface->SendCtrlCToDebugger(dwCtrlType);      
    }
    else
#endif // DEBUGGING_SUPPORTED
    {
        g_fInControlC = true;     // only for weakening assertions in checked build.
        return FALSE;               // keep looking for a real handler.
    }
}

BOOL g_fEEStarted = FALSE;

// ---------------------------------------------------------------------------
// %%Function: GetStartupInfo
// 
// Get Configuration Information
// 
// ---------------------------------------------------------------------------

typedef HRESULT (STDMETHODCALLTYPE* pGetHostConfigurationFile)(LPCWSTR, DWORD*);
void GetStartupInformation()
{
    HINSTANCE hMod = WszGetModuleHandle(L"mscoree.dll");
    if(hMod) {
        FARPROC pGetStartupFlags = GetProcAddress(hMod, "GetStartupFlags");
        if(pGetStartupFlags) {
            int flags = pGetStartupFlags();
            if(flags & STARTUP_CONCURRENT_GC) 
                g_IGCconcurrent = 1;
            else
                g_IGCconcurrent = 0;

            g_dwGlobalSharePolicy = (flags&STARTUP_LOADER_OPTIMIZATION_MASK)>>1;

        }

        pGetHostConfigurationFile GetHostConfigurationFile = (pGetHostConfigurationFile) GetProcAddress(hMod, "GetHostConfigurationFile");
        if(GetHostConfigurationFile) {
            HRESULT hr = GetHostConfigurationFile(g_pszHostConfigFile, &g_dwHostConfigFile);
            if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)) {
                g_pszHostConfigFile = new WCHAR[g_dwHostConfigFile];
                if(g_pszHostConfigFile) {
                    if(FAILED(GetHostConfigurationFile(g_pszHostConfigFile, &g_dwHostConfigFile))) {
                        delete [] g_pszHostConfigFile;
                        g_pszHostConfigFile = NULL;
                    }
                }
            }
        }
    }
}


// ---------------------------------------------------------------------------
// %%Function: EEStartup
// 
// Parameters:
//  fFlags                  - Initialization flags for the engine.  See the
//                              COINITIEE enumerator for valid values.
// 
// Returns:
//  S_OK                    - On success
// 
// Description:
//  Reserved to initialize the EE runtime engine explicitly.  Right now most
//  work is actually done inside the DllMain.
// ---------------------------------------------------------------------------

void InitFastInterlockOps(); // cgenxxx.cpp
// Start up and shut down critical section, spin lock
CRITICAL_SECTION          g_LockStartup;

// Remember how the last startup of EE went.
HRESULT g_EEStartupStatus;
HINSTANCE g_pFusionDll = NULL;

void OutOfMemoryCallbackForEE()
{
    FailFast(GetThread(),FatalOutOfMemory);
}

// EEStartup: all execution engine specific stuff should go
// in here

HRESULT EEStartup(DWORD fFlags)
{    
#ifdef _DEBUG
    Crst::InitializeDebugCrst();
#endif
    
    ::SetConsoleCtrlHandler(DbgCtrlCHandler, TRUE/*add*/);

    UtilCodeCallback::RegisterOutOfMemoryCallback(OutOfMemoryCallbackForEE);

    extern BOOL g_EnableLicensingInterop;
#ifdef GOLDEN // Replace GOLDEN with appropriate feature name
    g_EnableLicensingInterop = TRUE;
#else
    g_EnableLicensingInterop = TRUE; //EEConfig::GetConfigDWORD(L"EnableLicensing", FALSE);
#endif
#if ENABLE_TIMELINE
    Timeline::Startup();
#endif

    HRESULT hr = S_OK;

    // Stack probes have no dependencies
    if (FAILED(hr = InitStackProbes()) )
        return hr;
    
    // A hash of all function type descs on the system (to maintain type desc
    // identity).    
    InitializeCriticalSection(&g_sFuncTypeDescHashLock);
    LockOwner lock = {&g_sFuncTypeDescHashLock, IsOwnerOfOSCrst};
    g_sFuncTypeDescHash.Init(20, &lock);

    InitEventStore();

    // Go get configuration information this is necessary
    // before the EE has started.
    GetStartupInformation();
    
    if (FAILED(hr = CoInitializeCor(COINITCOR_DEFAULT)))
        return hr;

    g_fEEInit = true;

    // Set the COR system directory for side by side
    IfFailGo(SetInternalSystemDirectory());

    // get any configuration information from the registry
    if (!g_pConfig)
    {
        EEConfig *pConfig = new EEConfig();
        IfNullGo(pConfig);

        PVOID pv = InterlockedCompareExchangePointer(
            (PVOID *) &g_pConfig, (PVOID) pConfig, NULL);

        if (pv != NULL)
            delete pConfig;
    }

    g_pConfig->sync();

    if (g_pConfig->GetConfigDWORD(L"BreakOnEELoad", 0)) {
#ifdef _DEBUG
        _ASSERTE(!"Loading EE!");
#else
                DebugBreak();
#endif
        }

#ifdef STRESS_LOG
#ifndef _DEBUG
    if (REGUTIL::GetConfigDWORD(L"StressLog", 0))
#endif
    {
        unsigned facilities = REGUTIL::GetConfigDWORD(L"LogFacility", LF_ALL);
        unsigned bytesPerThread = REGUTIL::GetConfigDWORD(L"StressLogSize", 0x10000);
        StressLog::Initialize(facilities, bytesPerThread);
    }
#endif            

#ifdef LOGGING
    InitializeLogging();
#endif            

#ifdef ENABLE_PERF_LOG
    PerfLog::PerfLogInitialize();
#endif //ENABLE_PERF_LOG

#if METADATATRACKER_ENABLED
    MetaDataTracker::MetaDataTrackerInit();
#endif

#ifndef PLATFORM_CE
    // Initialize all our InterProcess Communications with COM+
    IfFailGo(InitializeIPCManager());
#endif // !PLATFORM_CE

#ifdef ENABLE_PERF_COUNTERS 
    hr = PerfCounters::Init();
    _ASSERTE(SUCCEEDED(hr));
    IfFailGo(hr);
#endif

    // We cache the SystemInfo for anyone to use throughout the
    // life of the DLL.   The root scanning tables adjust sizes
    // on NT64...
    GetSystemInfo(&g_SystemInfo);

    // This should be false but lets reset it anyways 
    g_SystemLoad = false;
    
    // Set callbacks so that LoadStringRC knows which language our
    // threads are in so that it can return the proper localized string.
    SetResourceCultureCallbacks(
        GetThreadUICultureName,
        GetThreadUICultureId,
        GetThreadUICultureParentName
    );

    // Set up the cor handle map. This map is used to load assemblies in
    // memory instead of using the normal system load
    IfFailGo(CorMap::Attach());

#ifdef _X86_
    if (!ProcessorFeatures::Init())
        IfFailGo(E_FAIL);
#endif

    // Init the switch to thread API.
    if (!InitSwitchToThread())
        IfFailGo(E_FAIL);

    if (!HardCodedMetaSig::Init())
        IfFailGo(E_FAIL);
    if (!OleVariant::Init())
        IfFailGo(E_FAIL);
    if (!Stub::Init())
        IfFailGo(E_FAIL);
    if (!LazyStubMaker::Init())
        IfFailGo(E_FAIL);
      // weak_short, weak_long, strong; no pin
    if(! Ref_Initialize())
        IfFailGo(E_FAIL);

    // Initialize remoting
    if(!CRemotingServices::Initialize())
        IfFailGo(E_FAIL);

    // Initialize contexts
    if(!Context::Initialize())
        IfFailGo(E_FAIL);

    if (!InitThreadManager())
        IfFailGo(E_FAIL);

#ifdef REMOTING_PERF
    CRemotingServices::OpenLogFile();
#endif

#if ZAPMONITOR_ENABLED
    if (g_pConfig->MonitorZapStartup() || g_pConfig->MonitorZapExecution())
        ZapMonitor::Init(g_pConfig->MonitorZapStartup() >= 3
                         || g_pConfig->MonitorZapExecution() >= 3);
#endif

    // Initialize RWLocks
    CRWLock::ProcessInit();

#ifdef DEBUGGING_SUPPORTED
    // Check the debugger/profiling control environment variable to
    // see if there's any work to be done.
    GetDbgProfControlFlag();
#endif // DEBUGGING_SUPPORTED

    // Setup the domains. Threads are started in a default domain.
    IfFailGo(SystemDomain::Attach());
        
#ifdef DEBUGGING_SUPPORTED
    // This must be done before initializing the debugger services so that
    // if the client chooses to attach the debugger that it gets in there
    // in time for the initialization of the debugger services to
    // recognize that someone is already trying to attach and get everything
    // to work accordingly.
    IfFailGo(NotifyService());

    //
    // Initialize the debugging services. This must be done before any
    // EE thread objects are created, and before any classes or
    // modules are loaded.
    //
    hr = InitializeDebugger();
    _ASSERTE(SUCCEEDED(hr));
    IfFailGo(hr);
#endif // DEBUGGING_SUPPORTED

#ifdef PROFILING_SUPPORTED
    // Initialize the profiling services.
    hr = InitializeProfiling();

    _ASSERTE(SUCCEEDED(hr));
    IfFailGo(hr);
#endif // PROFILING_SUPPORTED

    if (!InitializeExceptionHandling())
        IfFailGo(E_FAIL);

#ifndef PLATFORM_CE
    //
    // Install our global exception filter
    //
    InstallUnhandledExceptionFilter();
#endif // !PLATFORM_CE

    if (SetupThread() == NULL)
        IfFailGo(E_FAIL);

#ifndef PLATFORM_CE
#ifndef _ALPHA_
// Give PerfMon a chance to hook up to us
        IPCFuncCallSource::DoThreadSafeCall();
#endif // !_ALPHA_
#endif // !PLATFORM_CE

    if (!InitPreStubManager())
        IfFailGo(E_FAIL);
    if (!InitializeCom())
        IfFailGo(E_FAIL);

    // Before setting up the execution manager initialize the first part
    // of the JIT helpers.  
    if (!InitJITHelpers1())
        IfFailGo(E_FAIL);

    if (! SUCCEEDED(InitializeGarbageCollector()) ) 
        IfFailGo(E_FAIL);

    if (! SUCCEEDED(SyncClean::Init(FALSE))) {
        IfFailGo(E_FAIL);
    }

    if (! SyncBlockCache::Attach())
        IfFailGo(E_FAIL);

    // Start up the EE intializing all the global variables
    if (!ECall::Init())
        IfFailGo(E_FAIL);

    if (!NDirect::Init())
        IfFailGo(E_FAIL);

    if (!UMThunkInit())
        IfFailGo(E_FAIL);

    if (!COMDelegate::Init())
        IfFailGo(E_FAIL);

    // Set up the sync block
    if (! SyncBlockCache::Start())
        IfFailGo(E_FAIL);

    if (! ExecutionManager::Init())
        IfFailGo(E_FAIL);

#ifdef _USE_NLS_PLUS_TABLE
    if (!COMNlsInfo::InitializeNLS())
        IfFailGo(E_FAIL);
#endif //_USE_NLS_PLUS_TABLE
    
    // Start up security
    IfFailGo(Security::Start());

#if ZAPMONITOR_ENABLED
    // We need to put in an exception handler at this point, so we can handle AVs which
    // occur as a result of preloaded mscorlib.
    INSTALL_COMPLUS_EXCEPTION_HANDLER();
#endif

    //
    // @TODO_IA64: put this back in ASAP
    //
#ifndef _IA64_
    IfFailGo(SystemDomain::System()->Init());
#endif // !_IA64_

#ifdef PROFILING_SUPPORTED
    // @TODO: HACK: simonhal: This is to compensate for the DefaultDomain hack contained in
    // SystemDomain::Attach in which the first user domain is created before profiling
    // services can be initialized.  Profiling services cannot be moved to before the
    // hack because it needs SetupThread to be called.
        
    SystemDomain::NotifyProfilerStartup();
#endif // PROFILING_SUPPORTED



    // Verify that the structure sizes of our MethodDescs support proper
    // aligning for atomic stub replacement.
    //
    // Because the checked build adds debugging fields to MethodDescs,
    // this can't be a simple assert (or else having the wrong
    // number of debugging fields might cause the assert to pass
    // in checked while misaligning methoddescs in the free build.)
    //
    // So we force a DebugBreak() which is uninformative but at least
    // prevents the bug from being unnoticed.
    //
    // Since the actual test is a compile-time constant, we expect
    // the free build to optimize it away.
    if ( ( sizeof(MethodDescChunk) & (METHOD_ALIGN - 1) ) ||
         ( sizeof(MethodDesc) & (METHOD_ALIGN - 1) ) ||
         ( sizeof(ECallMethodDesc) & (METHOD_ALIGN - 1) ) ||
         ( sizeof(NDirectMethodDesc) & (METHOD_ALIGN - 1) ) ||
         ( sizeof(EEImplMethodDesc) & (METHOD_ALIGN - 1) ) ||
         ( sizeof(ArrayECallMethodDesc) & (METHOD_ALIGN - 1) ) ||
         ( sizeof(ComPlusCallMethodDesc) & (METHOD_ALIGN - 1) ) )
    {
        _ASSERTE(!"If you got here, you changed the size of a MethodDesc in such a way that it's no longer a multiple of METHOD_ALIGN. Don't do this.");
        DebugBreak();
    }

    g_fEEInit = false;

    //
    // Now that we're done initializing, fixup token tables in any modules we've 
    // loaded so far.
    //
#ifndef _IA64_
    SystemDomain::System()->NotifyNewDomainLoads(SystemDomain::System()->DefaultDomain());

    IfFailGo(SystemDomain::System()->DefaultDomain()->SetupSharedStatics());

    IfFailGo(SystemDomain::System()->FixupSystemTokenTables());

#ifdef DEBUGGING_SUPPORTED

    LOG((LF_CORDB, LL_INFO1000, "EEStartup: adding default domain 0x%x\n",
        SystemDomain::System()->DefaultDomain()));
        
    // Make a call to publish the DefaultDomain for the debugger, etc
    // @todo: Remove this call if we ever decide to lazily create
    // the DefaultDomain. 
    SystemDomain::System()->PublishAppDomainAndInformDebugger(
                         SystemDomain::System()->DefaultDomain());
#endif // DEBUGGING_SUPPORTED
#endif // _IA64_

    IfFailGo(InitializeMiniDumpBlock());
    IfFailGo(InitializeDumpDataBlock());


#if ZAPMONITOR_ENABLED
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
#endif

#if defined( PERFALLOC )
    if (PerfNew::GetEnabledPerfAllocStats() >= PERF_ALLOC_STARTUP)
        PerfNew::PerfAllocReport();
    if (PerfVirtualAlloc::GetEnabledVirtualAllocStats() >= PERF_VIRTUAL_ALLOC_STARTUP)
        PerfVirtualAlloc::ReportPerfAllocStats();
#endif

    g_fEEStarted = TRUE;

    return S_OK;

ErrExit:
    CoUninitializeCor();
    if (!FAILED(hr))
        hr = E_FAIL;

    g_fEEInit = false;

    return hr;
}

// Low-level mechanism for aborting startup in error conditions
BOOL        g_fExceptionsOK = FALSE;
HRESULT     g_StartupFailure = S_OK;

DWORD FilterStartupException(LPEXCEPTION_POINTERS p)
{
    g_StartupFailure = p->ExceptionRecord->ExceptionInformation[0];
    // Make sure we got a failure code in this case
    if (!FAILED(g_StartupFailure))
        g_StartupFailure = E_FAIL;
    
    if (p->ExceptionRecord->ExceptionCode == BOOTUP_EXCEPTION_COMPLUS)
    {
        // Don't ever handle the exception in a checked build
#ifndef _DEBUG
        return EXCEPTION_EXECUTE_HANDLER;
#endif
    }

    return EXCEPTION_CONTINUE_SEARCH;
}

HRESULT TryEEStartup(DWORD fFlags)
{
    // If we ever fail starting up, always fail for the same reason from now
    // on.

    if (!FAILED(g_StartupFailure))
    {
        // Catch the BOOTUP_EXCEPTION_COMPLUS exception code - this is 
        // what we throw if COMPlusThrow is called before the EE is initialized

        __try 
          {
              g_StartupFailure = EEStartup(fFlags);
              g_fExceptionsOK = TRUE;
          }
        __except (FilterStartupException(GetExceptionInformation()))
          {
              // Make sure we got a failure code in this case
              if (!FAILED(g_StartupFailure))
                  g_StartupFailure = E_FAIL;
          }
    }

    return g_StartupFailure;
}

// ---------------------------------------------------------------------------
// %%Function: CoEEShutdownCOM(BOOL fIsDllUnloading)
// 
// Parameters:
//  BOOL fIsDllUnloading :: is it safe point for full cleanup
// 
// Returns:
//  Nothing
// 
// Description:
//  COM Objects shutdown stuff should be done here
// ---------------------------------------------------------------------------
void STDMETHODCALLTYPE CoEEShutDownCOM()
{
    static long AlreadyDone = -1;

    if (g_fEEStarted != TRUE)
        return;

    if (FastInterlockIncrement(&AlreadyDone) != 0)
        return;

    // The ReleaseComPlusWrappers code requires a thread to be setup.
    Thread *pThread = SetupThread();
    _ASSERTE(pThread);

    // Release all the RCW's in all the contexts.
    ComPlusWrapperCache::ReleaseComPlusWrappers(NULL);

    // remove any tear-down notification we have setup
    RemoveTearDownNotifications();
}


// Force the EE to shutdown now.
void ForceEEShutdown()
{
    Thread *pThread = GetThread();
    BOOL    toggleGC = (pThread && pThread->PreemptiveGCDisabled());

    if (toggleGC)
        pThread->EnablePreemptiveGC();

    // Don't bother to take the lock for this case.
    // EnterCriticalSection(&g_LockStartup);

    if (toggleGC)
        pThread->DisablePreemptiveGC();

    STRESS_LOG0(LF_SYNC, INFO3, "EEShutDown invoked from managed Runtime.Exit()\n");
    EEShutDown(FALSE);
    SafeExitProcess(SystemNative::LatchedExitCode);   // may have changed during shutdown

    // LeaveCriticalSection(&g_LockStartup);   
}

#ifdef STRESS_THREAD
CStackArray<Thread **> StressThread;
#endif

//---------------------------------------------------------------------------
// %%Function: void STDMETHODCALLTYPE CorExitProcess(int exitCode)
// 
// Parameters:
//  BOOL fIsDllUnloading :: is it safe point for full cleanup
// 
// Returns:
//  Nothing
// 
// Description:
//  COM Objects shutdown stuff should be done here
// ---------------------------------------------------------------------------
extern "C" void STDMETHODCALLTYPE CorExitProcess(int exitCode)
{
    if (g_RefCount <=0 || g_fEEShutDown)
        return;
 
    Thread *pThread = SetupThread();
    if (pThread && !(pThread->PreemptiveGCDisabled()))
    {
        pThread->DisablePreemptiveGC();
    }

    CoEEShutDownCOM();

    // The exit code for the process is communicated in one of two ways.  If the
    // entrypoint returns an 'int' we take that.  Otherwise we take a latched
    // process exit code.  This can be modified by the app via System.SetExitCode().
    SystemNative::LatchedExitCode = exitCode;

    // Bump up the ref-count on the module
    HMODULE hMod = WszLoadLibrary(L"mscoree.dll");
    for (int i =0; i<5; i++)
        WszLoadLibrary(L"mscoree.dll");

    ForceEEShutdown();

}

#if defined(STRESS_HEAP)
#ifdef SHOULD_WE_CLEANUP
extern void StopUniqueStackMap ();
#endif /* SHOULD_WE_CLEANUP */
#endif
#include "..\ildasm\DynamicArray.h"
struct RVAFSE // RVA Field Start & End
{
    BYTE* pbStart;
    BYTE* pbEnd;
};
extern DynamicArray<RVAFSE> *g_drRVAField;

// ---------------------------------------------------------------------------
// %%Function: EEShutDown(BOOL fIsDllUnloading)
// 
// Parameters:
//  BOOL fIsDllUnloading :: is it safe point for full cleanup
// 
// Returns:
//  Nothing
// 
// Description:
//  All ee shutdown stuff should be done here
// ---------------------------------------------------------------------------
void STDMETHODCALLTYPE EEShutDown(BOOL fIsDllUnloading)
{
    Thread * pThisThread = GetThread();
    BOOL fPreemptiveGCDisabled = FALSE;
    if (pThisThread && !(pThisThread->PreemptiveGCDisabled()))
    {
        fPreemptiveGCDisabled = TRUE;
        pThisThread->DisablePreemptiveGC();
    }
#ifndef GOLDEN

//#ifdef DEBUGGING_SUPPORTED

    // This memory touch just insures that the MSDEV debug helpers are 
    // not completely optimized away in a BBT build
    extern void* debug_help_array[];
    debug_help_array[0]  = 0;
//#endif // DEBUGGING_SUPPORTED
#endif // !GOLDEN

    // If the process is detaching then set the global state.
    // This is used to get around FreeLibrary problems.
    if(fIsDllUnloading)
        g_fProcessDetach = true;

// may cause AV under Win9x, but I remove it under NT too
// so if there happen to be consequences, devs would see them
//#ifdef _DEBUG
// if (!RunningOnWin95())
//    ::SetConsoleCtrlHandler(DbgCtrlCHandler, FALSE/*remove*/);
//#endif // _DEBUG

    STRESS_LOG1(LF_SYNC, LL_INFO10, "EEShutDown entered unloading = %d\n", fIsDllUnloading);

#ifdef _DEBUG
    if (_DbgBreakCount)
    {
        _ASSERTE(!"An assert was hit before EE Shutting down");
    }
#endif          

#ifdef _DEBUG
    if (g_pConfig->GetConfigDWORD(L"BreakOnEEShutdown", 0))
        _ASSERTE(!"Shutting down EE!");
#endif

#ifdef DEBUGGING_SUPPORTED
    // This is a nasty, terrible, horrible thing. If we're being
    // called from our DLL main, then the odds are good that our DLL
    // main has been called as the result of some person calling
    // ExitProcess. That rips the debugger helper thread away very
    // ungracefully. This check is an attempt to recognize that case
    // and avoid the impending hang when attempting to get the helper
    // thread to do things for us.
    if ((g_pDebugInterface != NULL) && g_fProcessDetach)
        g_pDebugInterface->EarlyHelperThreadDeath();
#endif // DEBUGGING_SUPPORTED

    // We only do the first part of the shutdown once.
    static long OnlyOne = -1;
    if (FastInterlockIncrement(&OnlyOne) != 0) {
        if (!fIsDllUnloading) {
            // I'm in a regular shutdown -- but another thread got here first. 
            // It's a race if I return from here -- I'll call ExitProcess next, and
            // rip things down while the first thread is half-way through a
            // nice cleanup.  Rather than do that, I should just wait until the
            // first thread calls ExitProcess().  I'll die a nice death when that
            // happens.
            Thread *pThread = SetupThread();
            HANDLE h = pThread->GetThreadHandle();
            pThread->EnablePreemptiveGC();
            pThread->DoAppropriateAptStateWait(1,&h,FALSE,INFINITE,TRUE);
            _ASSERTE (!"Should not reach here");
        } else {
            // I'm in the final shutdown and the first part has already been run.
            goto part2;
        }
    }

    // Indicate the EE is the shut down phase.
    g_fEEShutDown |= ShutDown_Start; 

    BOOL fFinalizeOK = TRUE;

#if METADATATRACKER_ENABLED
    MetaDataTracker::ReportAndDie();
#endif

    // We perform the final GC only if the user has requested it through the GC class.
        // We should never do the final GC for a process detach
    if (!g_fProcessDetach)
    {
        g_fEEShutDown |= ShutDown_Finalize1;
        if (pThisThread == NULL) {
            SetupThread ();
            pThisThread = GetThread();
        }
        g_pGCHeap->EnableFinalization();
        fFinalizeOK = g_pGCHeap->FinalizerThreadWatchDog();
    }

    g_RefCount = 0; // reset the ref-count 

    // Ok.  Let's stop the EE.
    if (!g_fProcessDetach)
    {
        g_fEEShutDown |= ShutDown_Finalize2;
        if (fFinalizeOK) {
            fFinalizeOK = g_pGCHeap->FinalizerThreadWatchDog();
        }
        else
            return;
    }
    
    g_fForbidEnterEE = true;

#ifdef PROFILING_SUPPORTED
    // If profiling is enabled, then notify of shutdown first so that the
    // profiler can make any last calls it needs to.  Do this only if we
    // are not detaching
    if (IsProfilerPresent())
    {
        // Write zap logs before detaching the profiler, so we get the 
        // profiling flags correct
        SystemDomain::System()->WriteZapLogs();

        // If EEShutdown is not being called due to a ProcessDetach event, so
        // the profiler should still be present
        if (!g_fProcessDetach)
        {
            LOG((LF_CORPROF, LL_INFO10, "**PROF: EEShutDown entered.\n"));
            g_profControlBlock.pProfInterface->Shutdown((ThreadID) GetThread());
        }

        g_fEEShutDown |= ShutDown_Profiler;
        // Free the interface objects.
        TerminateProfiling(g_fProcessDetach);

        // EEShutdown is being called due to a ProcessDetach event, so the
        // profiler has already been unloaded and we must set the profiler
        // status to profNone so we don't attempt to send any more events to
        // the profiler
        if (g_fProcessDetach)
            g_profStatus = profNone;
    }
#endif // PROFILING_SUPPORTED

    // CoEEShutDownCOM moved to
    // the Finalizer thread. See bug 87809
    if (!g_fProcessDetach)
    {
        g_fEEShutDown |= ShutDown_COM;
        if (fFinalizeOK) {
            g_pGCHeap->FinalizerThreadWatchDog();
        }
        else
            return;
    }

#ifdef _DEBUG
    else
#ifdef SHOULD_WE_CLEANUP
        if(!isThereOpenLocks())
        {
            g_fEEShutDown |= ShutDown_COM;
            //CoEEShutDownCOM();
        }
#else
        g_fEEShutDown |= ShutDown_COM;
#endif /* SHOULD_WE_CLEANUP */
#endif
    
#ifdef _DEBUG
#ifdef SHOULD_WE_CLEANUP
    if (!g_fProcessDetach || !isThereOpenLocks())
    {   //@todo: Raja: you deleted this line on 6/22 -- please recheck.
        g_fEEShutDown |= ShutDown_SyncBlock;
        //SyncBlockCache::Detach();
    }
#else
    g_fEEShutDown |= ShutDown_SyncBlock;
#endif /* SHOULD_WE_CLEANUP */
#endif    
    
#ifdef _DEBUG
    // This releases any metadata interfaces that may be held by leaked
    // ISymUnmanagedReaders or Writers. We do this in phase two now that
    // we know any such readers or writers can no longer be in use.
    //
    // Note: we only do this in a debug build to support our wacky leak
    // detection.
    if (g_fProcessDetach)
        Module::ReleaseMemoryForTracking();
#endif

    // Save the security policy cache as necessary.
    Security::SaveCache();
    // Cleanup memory used by security engine.
    COMCodeAccessSecurityEngine::CleanupSEData();

    // This is the end of Part 1.
part2:

#if ZAPMONITOR_ENABLED
    ZapMonitor::Uninit(); 
#endif
        
#ifdef REMOTING_PERF
    CRemotingServices::CloseLogFile();
#endif

    // On the new plan, we only do the tear-down under the protection of the loader
    // lock -- after the OS has stopped all other threads.
    if (fIsDllUnloading)
    {
        g_fEEShutDown |= ShutDown_Phase2;

        TerminateEventStore();

        SyncClean::Terminate();

#if ZAPMONITOR_ENABLED
        ZapMonitor::Uninit(); 
#endif
        
        // Shutdown finalizer before we suspend all background threads. Otherwise we
        // never get to finalize anything. Obviously.
        
#ifdef _DEBUG
        if (_DbgBreakCount)
        {
            _ASSERTE(!"An assert was hit After Finalizer run");
        }
#endif          
#ifdef SHOULD_WE_CLEANUP
        BOOL fShouldWeCleanup = FALSE;

#ifdef _DEBUG

        BOOL fForceNoShutdownCleanup = g_pConfig->GetConfigDWORD(L"ForceNoShutdownCleanup", 0);
        BOOL fShutdownCleanup = g_pConfig->GetConfigDWORD(L"ShutdownCleanup", 0);
        BOOL fAssertOnLocks = g_pConfig->GetConfigDWORD(L"AssertOnLocks", 0);
        BOOL fAssertOnLeak = g_pConfig->GetConfigDWORD(L"AllocAssertOnLeak", 0);
        // See if we have any open locks that would prevent us from cleaning up
        if (fShutdownCleanup && !fForceNoShutdownCleanup)
        {
            fShouldWeCleanup = fShutdownCleanup && !isThereOpenLocks();
            if (isThereOpenLocks())
            {
                printf("!!!!!!!OPEN LOCKS DETECTED! NO CLEANUP WILL BE PERFORMED!!!!!!!\n");
                OutputDebugStringA("!!!!!!!OPEN LOCKS DETECTED! NO CLEANUP WILL BE PERFORMED!!!!!!!\n");

                if (fAssertOnLocks || fAssertOnLeak)
                    _ASSERTE(0 && "Open locks were detected. No Cleanup will be performed");
            }
        }
#endif

        if (fShouldWeCleanup) {

            // The host config file was created during start up by asking
            // the shim.
            if(g_pszHostConfigFile) {
                delete [] g_pszHostConfigFile;
                g_pszHostConfigFile = NULL;
            }

#ifdef STRESS_THREAD
            DWORD dwThreads = g_pConfig->GetStressThreadCount();
            if (dwThreads > 1)
            {
                Thread **threads;
                while ((threads == StressThread.Pop()) != NULL) {
                    delete [] threads;
                }
                StressThread.Clear();
            }
#endif
    
#if defined(STRESS_HEAP)
            StopUniqueStackMap ();
#endif
            // All background threads must either get out of the EE, or they must be suspended
            // at a safe GC point.  Note that some threads could have started up or entered
            // the EE since the time when we decided to shut down.  Even if they aren't
            // background threads, they cannot change our decision to shut down.
            //
            // For now, don't do this in the Detach case.
            //
            // Also, try to restrict our weakening of asserts to those cases where we really
            // can't predict what is happening.
            _ASSERTE(dbg_fDrasticShutdown == FALSE);
            if (!g_fInControlC)
            {
#ifdef _DEBUG
                if (g_pThreadStore->DbgBackgroundThreadCount() > 0)
                    dbg_fDrasticShutdown = TRUE;
#endif
                ThreadStore::UnlockThreadStore();
            }

        } // SHUTDOWN_CLEANUP
#endif /* SHOULD_WE_CLEANUP */
    
        // No longer process exceptions
        g_fNoExceptions = true;
    
#ifndef PLATFORM_CE
        //
        // Remove our global exception filter. If it was NULL before, we want it to be null now.
        //
        UninstallUnhandledExceptionFilter();
#endif // !PLATFORM_CE

#ifdef SHOULD_WE_CLEANUP
        TerminateExceptionHandling();
#endif /* SHOULD_WE_CLEANUP */
    
        Thread *t = GetThread();
    
#ifdef SHOULD_WE_CLEANUP
        if (fShouldWeCleanup) {

            COMMember::Terminate();

            OleVariant::Terminate();

            HardCodedMetaSig::Terminate();
        
            // Cleanup contexts
            Context::Cleanup();
        
            // Cleanup remoting
            CRemotingServices::Cleanup();
        
            // Cleanup RWLocks
            CRWLock::ProcessCleanup();
        
            FreeUnusedStubs();
        
    #if 0 
    #ifdef _DEBUG
            Interpreter::m_pILStubCache->Dump();
            ECall::m_pECallStubCache->Dump();
    #endif
    #endif
        
            // reinitialize the global hard coded signatures. (craigsi)
            // If the EE is restarted the pointers in the signatures
            // must be pointing to their original position.
            if(!fIsDllUnloading)
                HardCodedMetaSig::Reinitialize();
        
            if(g_pPreallocatedOutOfMemoryException) 
            {
                DestroyGlobalHandle(g_pPreallocatedOutOfMemoryException);
                g_pPreallocatedOutOfMemoryException = NULL;
            }
        
            if(g_pPreallocatedStackOverflowException) 
            {
                DestroyGlobalHandle(g_pPreallocatedStackOverflowException);
                g_pPreallocatedStackOverflowException = NULL;
            }
        
            if(g_pPreallocatedExecutionEngineException) 
            {
                DestroyGlobalHandle(g_pPreallocatedExecutionEngineException);
                g_pPreallocatedExecutionEngineException = NULL;
            }
    
            // Release the debugger special thread list
            CorHost::CleanupDebuggerSpecialThreadList();
        }
#endif /* SHOULD_WE_CLEANUP */
    
        // @TODO: This does things which shouldn't occur in part 2.  Namely, 
        // calling managed dll main callbacks (AppDomain::SignalProcessDetach), and 
        // RemoveAppDomainFromIPC.
        // 
        // (If we move those things to earlier, this can be called only if fShouldWeCleanup.)
        SystemDomain::DetachBegin();
        
        if (t != NULL)
        {
            t->CoUninitalize();
    
#ifdef DEBUGGING_SUPPORTED
            //
            // If we're debugging, let the debugger know that this thread is
            // gone. Need to do this here for the final thread because the 
            // DetachThread() function relies on the AppDomain object being around
            if (CORDebuggerAttached())
                g_pDebugInterface->DetachThread(t);
#endif // DEBUGGING_SUPPORTED
        }
        
#ifdef SHOULD_WE_CLEANUP
        if (fShouldWeCleanup) {
            COMDelegate::Terminate();
            NDirect::Terminate();
            ECall::Terminate();
        
            SyncBlockCache::Stop();
            TerminateCom();
        }
#endif /* SHOULD_WE_CLEANUP */

#ifdef DEBUGGING_SUPPORTED
        // inform debugger that it should ignore any "ThreadDetach" events
        // after this point...
        if (CORDebuggerAttached())
            g_pDebugInterface->IgnoreThreadDetach();
#endif // DEBUGGING_SUPPORTED
     
        // Before we detach from the system domain we need to release all the exposed
        // thread objects. This is required since otherwise the thread's will later try
        // to access their exposed objects which will have been destroyed. Also in here
        // we will clear the threads' context and AD before these are deleted in DetachEnd
#ifdef SHOULD_WE_CLEANUP
        if (fShouldWeCleanup)
            ThreadStore::ReleaseExposedThreadObjects();
    
        if (fShouldWeCleanup)
            Binder::Shutdown();        
        
        if (fShouldWeCleanup)
            SystemDomain::DetachEnd();
    

        if (fShouldWeCleanup) {

            COMString::Stop();         // must precede TerminateGarbageCollector()
        
            CorCommandLine::Shutdown();
        
            ExecutionManager::Terminate();
        
            UMThunkTerminate();
        
            TerminatePreStubManager();
            LazyStubMaker::Terminate();
            Stub::Terminate();
            TerminateGarbageCollector();
        
            // Note that the following call is not matched with a balancing InitForFinalization.
            // That call happens elsewhere, after Object's method table is ready.
            MethodTable::TerminateForFinalization();
        
    #ifdef _USE_NLS_PLUS_TABLE
            COMNlsInfo::ShutdownNLS();
    #endif //_USE_NLS_PLUS_TABLE
        
            //
            // The debugger wants this thread destroyed before it gets
            // terminated.  Furthermore, the debugger can't really wait for
            // the thread to get destroyed in TerminateThreadManager below, so
            // we do it here now. This must also be done before we terminate
            // the execution manager.
            if (t != NULL)
                DestroyThread(t);

            // ************************************************************************
            //
            // From this point on, the current thread will hang if we toggle its GC mode.
            // That's because GetThread() will return 0.  So we cannot detect that we are
            // the GC Thread.  But we may have the system suspended (ostensibly for a GC
            // but actually so background threads make no progress).
            //
            // We must be very selective about what code we run from here on down.
            //
            // ************************************************************************

            TerminateThreadManager();

            ThreadPoolNative::ShutDown();

            // Clear security (cleans up handles)
            Security::Stop();
        }  // SHUTDOWN_CLEANUP
#endif /* SHOULD_WE_CLEANUP */
    
#ifdef DEBUGGING_SUPPORTED
        // Terminate the debugging services.
        // The profiling infrastructure makes one last call (to Terminate),
        // wherein the profiler may call into the in-proc debugger.  Since
        // we don't do much herein, we put this after TerminateProfiling.
        TerminateDebugger();
#endif // DEBUGGING_SUPPORTED

        Ref_Shutdown(); // shut down the handle table

        // Terminate Perf Counters as late as we can (to get the most data)
#ifdef ENABLE_PERF_COUNTERS
#ifdef SHOULD_WE_CLEANUP
#ifdef _DEBUG
        // Make sure that all instances of LoaderHeaps are deleted by this time
        // since we pass a raw pointer to the LoaderHeap to increment the 
        // m_Loading.cbLoaderHeapBytes perfcounter !.
        if (fShouldWeCleanup) 
        {
            _ASSERTE (UnlockedLoaderHeap::s_dwNumInstancesOfLoaderHeaps == 0);
        }
#endif // _DEBUG
#endif /* SHOULD_WE_CLEANUP */

        PerfCounters::Terminate();
#endif // ENABLE_PERF_COUNTERS
    
#ifndef PLATFORM_CE
        // Terminate the InterProcess Communications with COM+
        TerminateIPCManager();
    
#ifdef ENABLE_PERF_LOG
        PerfLog::PerfLogDone();
#endif //ENABLE_PERF_LOG
    
   
        // Give PerfMon a chance to hook up to us
        // Have perfmon resync list *after* we close IPC so that it will remove 
        // this process
        IPCFuncCallSource::DoThreadSafeCall();
#endif // !PLATFORM_CE
    
        // Shut down the module mapper. It does not have any dependency on 
        // other EE resources
#ifdef SHOULD_WE_CLEANUP
        if (fShouldWeCleanup)
            CorMap::Detach();
#endif /* SHOULD_WE_CLEANUP */
    
#ifndef PLATFORM_CE
        // Shutdown the Cryptography code.  It has no dependencies on any other
        //  EE resources
#ifdef SHOULD_WE_CLEANUP
        if (fShouldWeCleanup)
            COMCryptography::Terminate();
#endif /* SHOULD_WE_CLEANUP */
#endif // !PLATFORM_CE
    
        TerminateStackProbes();

#ifdef SHOULD_WE_CLEANUP
        // Free up the global variables
        if (fShouldWeCleanup) {
            ZeroMemory(g_pPredefinedArrayTypes, (ELEMENT_TYPE_MAX)*sizeof(ArrayTypeDesc*));
            g_pObjectClass = NULL;
            g_pStringClass = NULL;
            g_pArrayClass = NULL;
            g_pExceptionClass = NULL;
            g_pDelegateClass = NULL;
            g_pMultiDelegateClass = NULL;   
            
            g_TrapReturningThreads = 0;
        
       
            if(g_pFusionDll)
                FreeLibrary(g_pFusionDll);
        
            if(!fIsDllUnloading) {
                CoUninitializeCor();        
            }
            
            if(g_drRVAField) {
                delete g_drRVAField;
                g_drRVAField = NULL;
            }

            if (g_pConfig) {
                delete g_pConfig;
                g_pConfig = NULL;
            }
            MngStdInterfaceMap::FreeMemory();
            GetStaticLogHashTable()->FreeMemory();
            g_sFuncTypeDescHash.ClearHashTable();
            DeleteCriticalSection(&g_sFuncTypeDescHashLock);

#ifdef CUSTOMER_CHECKED_BUILD
        CustomerDebugHelper::Terminate();
#endif

            ShutdownCompRC();

#ifdef _DEBUG
            Crst::DeleteDebugCrst();
#endif
            
        }
#endif /* SHOULD_WE_CLEANUP */
#ifdef ENABLE_TIMELINE        
        Timeline::Shutdown();
#endif
#ifdef _DEBUG
        if (_DbgBreakCount)
            _ASSERTE(!"EE Shutting down after an assert");
#endif          

#ifdef _DEBUG
#ifdef SHOULD_WE_CLEANUP
        if (fShouldWeCleanup)
            DbgAllocReport();
#endif /* SHOULD_WE_CLEANUP */
#endif

#ifdef _DEBUG
#ifdef SHOULD_WE_CLEANUP
        // Determine whether we should report CRT memory leaks
        SetReportingOfCRTMemoryLeaks(fShouldWeCleanup&fAssertOnLeak);
#endif /* SHOULD_WE_CLEANUP */
#endif
    
        extern unsigned FcallTimeHist[];
        LOG((LF_STUBS, LL_INFO10, "FcallHist %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n",
        FcallTimeHist[0], FcallTimeHist[1], FcallTimeHist[2], FcallTimeHist[3],
        FcallTimeHist[4], FcallTimeHist[5], FcallTimeHist[6], FcallTimeHist[7],
        FcallTimeHist[8], FcallTimeHist[9], FcallTimeHist[10]));


        STRESS_LOG0(LF_SYNC, LL_INFO10, "EEShutdown shutting down logging\n");

#ifdef STRESS_LOG
    // StressLog::Terminate();      // The EE kills threads during shutdown, and those threads
                        // may hold the Stresslog lock.  To avoid deadlock, we simply
                        // don't clean up and live with the memory leak.  
#endif            
    
#ifdef LOGGING
        ShutdownLogging();
#endif          


#ifdef SHOULD_WE_CLEANUP
        if ( (!fShouldWeCleanup) && pThisThread && fPreemptiveGCDisabled )
        {
            pThisThread->EnablePreemptiveGC();
        }
#else
        if (pThisThread && fPreemptiveGCDisabled)
        {
            pThisThread->EnablePreemptiveGC();
        }
#endif /* SHOULD_WE_CLEANUP */


    }


}

static BOOL fDidComStartedEE = FALSE;
// ---------------------------------------------------------------------------
// %%Function: COMShutdown()
// 
// Parameters:
//  none
// 
// Returns:
//  Nothing
// 
// Description: com interop shutdown routine
//  Must be called by client on shut down in order to free up the system.
// ---------------------------------------------------------------------------

void   COMShutdown()
{
    // We don't want to count this critical section, since we're setting it in order
    // to enter our shutdown code. We'd never get 0 open locks if we counted this one.
    // LOCKCOUNTINC
    BOOL bMustShutdown = FALSE;    

    EnterCriticalSection(&g_LockStartup);    
    if (fDidComStartedEE == TRUE)
    {
        fDidComStartedEE = FALSE;
        bMustShutdown = TRUE;     
    }

    LeaveCriticalSection(&g_LockStartup);    

    if( bMustShutdown == TRUE )
    {
        _ASSERTE(g_RefCount > 0);
        STRESS_LOG0(LF_SYNC, INFO3, "EEShutDown invoked from COMShutdown\n");
        EEShutDown(FALSE);        
    }

    // LOCKCOUNTDEC
}


// ---------------------------------------------------------------------------
// %%Function: CanRunManagedCode()
// 
// Parameters:
//  none
// 
// Returns:
//  true or false
// 
// Description: Indicates if one is currently allowed to run managed code.
// ---------------------------------------------------------------------------
bool CanRunManagedCode()
{
    // V.Next - we need to get establish a better doctrine for shutdown
    // code.

    // If we are shutting down the runtime, then we cannot run code.
    if (g_fForbidEnterEE == true)
        return false;

    // If we are finaling live objects or processing ExitProcess event,
    // we can not allow managed method to run unless the current thread
    // is the finalizer thread
    if ((g_fEEShutDown & ShutDown_Finalize2) && GetThread() != g_pGCHeap->GetFinalizerThread())
        return false;
    
        // If pre-loaded objects are not present, then no way.
    if (g_pPreallocatedOutOfMemoryException == NULL)
        return false;
    return true;
}


// ---------------------------------------------------------------------------
// %%Function: COMStartup()
// 
// Parameters:
//  none
// 
// Returns:
//  Nothing
// 
// Description: com interop startup routine
// ---------------------------------------------------------------------------
HRESULT  COMStartup()
{
    static HRESULT hr = S_OK;

    if (FAILED(hr))
        return hr;

    if (g_fEEShutDown)
        return E_FAIL;

    LOCKCOUNTINCL("COMStartup in Ceemain");

    EnterCriticalSection(&g_LockStartup);
    if (g_RefCount == 0)
    {
        g_RefCount = 1;
        //_ASSERTE(fDidComStartedEE == FALSE);
        fDidComStartedEE = TRUE;

        hr = TryEEStartup(0);
        INCTHREADLOCKCOUNT();
        if (hr == S_OK)
            hr = QuickCOMStartup();

        if (hr == S_OK)
            hr = SystemDomain::SetupDefaultDomain();

        if (hr != S_OK)
            g_RefCount = 0;
    }

    LeaveCriticalSection(&g_LockStartup);
    LOCKCOUNTDECL("COMStartup in Ceemain");

    // Only proceed if successful
    if (SUCCEEDED(hr))
    {
        //could be an external thread
        Thread* pThread = SetupThread();

        if (pThread == 0)
            hr = E_OUTOFMEMORY;
    }        

    return hr;
}

BOOL    g_fComStarted = FALSE;

// Call this when you know that the EE has already been started, and that you have a refcount on it
HRESULT QuickCOMStartup()
{
    HRESULT hr = S_OK;

    // Could be an external thread.
    Thread* pThread = SetupThread();
    if (pThread == 0)
        return E_OUTOFMEMORY;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION()
    {       
        if (g_fComStarted == FALSE)
        {
            GCHeap::GetFinalizerThread()->SetRequiresCoInitialize();
            // Attempt to set the thread's apartment model (to MTA by default). May not
            // succeed (if someone beat us to the punch). That doesn't matter (since
            // COM+ objects are now apartment agile), we only care that a CoInitializeEx
            // has been performed on this thread by us.
            pThread->SetApartment(Thread::AS_InMTA);        

            // set the finalizer event
            GCHeap::EnableFinalization();  

            //setup tear-down notifications
            SetupTearDownNotifications(); 

        }   
        g_fComStarted = TRUE;
    }
    ENDCANNOTTHROWCOMPLUSEXCEPTION()

    return hr;
}


// ---------------------------------------------------------------------------
// %%Function: CoInitializeEE(DWORD fFlags)
// 
// Parameters:
//  none
// 
// Returns:
//  Nothing
// 
// Description:
//  Must be called by client on shut down in order to free up the system.
// ---------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE CoInitializeEE(DWORD fFlags)
{   
    LOCKCOUNTINCL("CoInitializeEE in Ceemain");

    EnterCriticalSection(&g_LockStartup);
    // Increment RefCount, if it is one then we
    // need to initialize the EE.
    g_RefCount++;
    
    if(g_RefCount <= 1 && !g_fEEStarted && !g_fEEInit) {
        g_EEStartupStatus = TryEEStartup(fFlags);
        // We did not have a Thread structure when we EnterCriticalSection.
        // Bump the counter now to account for it.
        INCTHREADLOCKCOUNT();
        if(SUCCEEDED(g_EEStartupStatus) && (fFlags & COINITEE_MAIN) == 0) {
            SystemDomain::SetupDefaultDomain();
        }
    }

    LeaveCriticalSection(&g_LockStartup);
    LOCKCOUNTDECL("CoInitializeEE in Ceemain");

    return SUCCEEDED(g_EEStartupStatus) ? (SetupThread() ? S_OK : E_OUTOFMEMORY) : g_EEStartupStatus;
}


// ---------------------------------------------------------------------------
// %%Function: CoUninitializeEE
// 
// Parameters:
//  none
// 
// Returns:
//  Nothing
// 
// Description:
//  Must be called by client on shut down in order to free up the system.
// ---------------------------------------------------------------------------
void STDMETHODCALLTYPE CoUninitializeEE(BOOL fFlags)
{
    BOOL bMustShutdown = FALSE;
    
    // Take a lock and decrement the 
    // ref count. If it reaches 0 then
    // release the VM
    LOCKCOUNTINCL("CoUnInitializeEE in Ceemain");

    EnterCriticalSection(&g_LockStartup);
    if (g_RefCount > 0)
    {       
        g_RefCount--;   
        if(g_RefCount == 0) 
        {                                    
            if (!fFlags)
            {
                bMustShutdown = TRUE;
            } 
        }       
    }

    LeaveCriticalSection(&g_LockStartup);
    LOCKCOUNTDECL("CoUninitializeEE in Ceemain");
    
    if( bMustShutdown == TRUE )
    {
        STRESS_LOG0(LF_SYNC, LL_INFO10, "EEShutDown invoked from CoUninitializeEE\n");
        EEShutDown(fFlags);
    }
}


//*****************************************************************************
// This entry point is called from the native DllMain of the loaded image.  
// This gives the COM+ loader the chance to dispatch the loader event.  The 
// first call will cause the loader to look for the entry point in the user 
// image.  Subsequent calls will dispatch to either the user's DllMain or
// their Module derived class.
// Under WinCE, there are a couple of extra parameters because the hInst is not
// the module's base load address.
//*****************************************************************************
BOOL STDMETHODCALLTYPE _CorDllMain(     // TRUE on success, FALSE on error.
    HINSTANCE   hInst,                  // Instance handle of the loaded module.
    DWORD       dwReason,               // Reason for loading.
    LPVOID      lpReserved              // Unused.
#ifdef PLATFORM_CE
    ,
    LPVOID      pDllBase,               // Base load address of the DLL.
    DWORD       dwRva14,                // RVA of the COM+ header.
    DWORD       dwSize14                // Size of the COM+ header
#endif // PLATFORM_CE
    )
{
    BOOL retval;

//// Win9x: during PROCESS_DETACH as a result of process termination
//// everything on the stack allocated
//// before PROCESS_DETACH notification is not reliable.
//// Any global and thread variables that track information
//// on the stack should be reset here.
    if (dwReason==DLL_PROCESS_DETACH&&lpReserved&&RunningOnWin95())
    {
        if (GetThreadTLSIndex()!=-1)
            TlsSetValue(GetThreadTLSIndex(),NULL);
        if (GetAppDomainTLSIndex()!=-1)
            TlsSetValue(GetAppDomainTLSIndex(),NULL);
    }
///////



#ifdef PLATFORM_CE

    retval = ExecuteDLL(hInst,dwReason,lpReserved,pDllBase,dwRva14);

#else // !PLATFORM_CE

    retval = ExecuteDLL(hInst,dwReason,lpReserved);

#endif // !PLATFORM_CE

    return retval;
}

// This function will do some additional PE Checks to make sure everything looks good.
// We must do these before we run any managed code (that's why we can't do them in PEVerifier, as
// managed code is used to determine the policy settings)
HRESULT DoAdditionalPEChecks(HINSTANCE hInst)
{
    IMAGE_COR20_HEADER* pCor;
    IMAGE_DOS_HEADER*   pDos;
    IMAGE_NT_HEADERS*   pNT;
    BOOL fData = FALSE;
            
    // Get PE headers
    if(!SUCCEEDED(CorMap::ReadHeaders((PBYTE) hInst, &pDos, &pNT, &pCor, fData, 0)))
        return COR_E_BADIMAGEFORMAT;

    if (!PEVerifier::CheckPEManagedStack(pNT))
        return COR_E_BADIMAGEFORMAT;

    // Everything seems ok
    return S_OK;
}

//*****************************************************************************
// This entry point is called from the native entry piont of the loaded 
// executable image.  The command line arguments and other entry point data
// will be gathered here.  The entry point for the user image will be found
// and handled accordingly.
// Under WinCE, there are a couple of extra parameters because the hInst is not
// the module's base load address and the others are not available elsewhere.
//*****************************************************************************
__int32 STDMETHODCALLTYPE _CorExeMain(  // Executable exit code.
#ifdef PLATFORM_CE
    HINSTANCE hInst,                    // Exe's HINSTANCE
    HINSTANCE hPrevInst,                // The old Win31 prev instance crap!
    LPWSTR  lpCmdLine,                  // User supplied command-line
    int     nCmdShow,                   // Windows "show" parameter.
    LPVOID  pExeBase,                   // Base load address of the EXE.
    DWORD   dwRva14,                    // RVA of the COM+ header.
    DWORD   dwSize14                    // Size of the COM+ header
#endif // PLATFORM_CE
    )
{
    BOOL bretval = 0;
    
    // Make sure PE file looks ok
    HRESULT hr;
    if (FAILED(hr = DoAdditionalPEChecks(WszGetModuleHandle(NULL))))
    {
        VMDumpCOMErrors(hr);
        SetLatchedExitCode (-1);
        goto exit2;        
    }

    // Before we initialize the EE, make sure we've snooped for all EE-specific
    // command line arguments that might guide our startup.
#ifdef PLATFORM_CE
    CorCommandLine::SetArgvW(lpCmdLine);
#else // !PLATFORM_CE
    //
    // @TODO_IA64: should we change this function name?  The behavior is different
    // between 64- and 32-bit, which is unexpected when using the same name
    // on both platforms
    //
    WCHAR   *pCmdLine = WszGetCommandLine();
    CorCommandLine::SetArgvW(pCmdLine);
#ifdef _X86_
    //
    // In WinWrap.h, we #define WszGetCommandLine to be GetCommandLineW for WinCE or
    // non-X86 platforms, which means that the memory pointed to by the returned 
    // pointer WAS NOT ALLOCATED BY US.  As a result, we should only be deleting 
    // it on non-CE X86.  Since the WinCE case is handled above, we need to handle
    // the non-X86 case here.
    //
    delete[] pCmdLine;
#endif // _X86_
#endif // !PLATFORM_CE

    HRESULT result = CoInitializeEE(COINITEE_DEFAULT | COINITEE_MAIN);
    if (FAILED(result)) 
    {
        VMDumpCOMErrors(result);
        SetLatchedExitCode (-1);
        goto exit;
    }

    // This will be called from a EXE so this is a self referential file so I am going to call
    // ExecuteEXE which will do the work to make a EXE load.
#ifdef PLATFORM_CE
        bretval = ExecuteEXE((HINSTANCE) pExeBase, lpCmdLine, nCmdShow, dwRva14);
#else // !PLATFORM_CE
        bretval = ExecuteEXE(WszGetModuleHandle(NULL));
#endif // !PLATFORM_CE
    if (!bretval) {
        // The only reason I've seen this type of error in the wild is bad 
        // metadata file format versions and inadequate error handling for 
        // partially signed assemblies.  While this may happen during 
        // development, our customers should not get here.  This is a back-stop 
        // to catch CLR bugs. If you see this, please try to find a better way 
        // to handle your error, like throwing an unhandled exception.
        CorMessageBoxCatastrophic(NULL, IDS_EE_COREXEMAIN_FAILED_TEXT, IDS_EE_COREXEMAIN_FAILED_TITLE, MB_ICONSTOP, TRUE);
        SetLatchedExitCode (-1);
    }


exit:
    STRESS_LOG1(LF_ALL, LL_INFO10, "Program exiting: return code = %d\n", GetLatchedExitCode());

    STRESS_LOG0(LF_SYNC, LL_INFO10, "EEShutDown invoked from _CorExeMain\n");
    EEShutDown(FALSE);

exit2:
    SafeExitProcess(GetLatchedExitCode());
    __assume(0); // We never get here
}

//*****************************************************************************
// This entry point is called from the native entry piont of the loaded 
// executable image.  The command line arguments and other entry point data
// will be gathered here.  The entry point for the user image will be found
// and handled accordingly.
// Under WinCE, there are a couple of extra parameters because the hInst is not
// the module's base load address and the others are not available elsewhere.
//*****************************************************************************
__int32 STDMETHODCALLTYPE _CorExeMain2( // Executable exit code.
    PBYTE   pUnmappedPE,                // -> memory mapped code
    DWORD   cUnmappedPE,                // Size of memory mapped code
    LPWSTR  pImageNameIn,               // -> Executable Name
    LPWSTR  pLoadersFileName,           // -> Loaders Name
    LPWSTR  pCmdLine)                   // -> Command Line
{
    BOOL bRetVal = 0;
    Module *pModule = NULL;
    PEFile *pFile = NULL;
    HRESULT hr = E_FAIL;

    // Strong name validate if necessary.
    if (!StrongNameSignatureVerification(pImageNameIn,
                                         SN_INFLAG_INSTALL|SN_INFLAG_ALL_ACCESS|SN_INFLAG_RUNTIME,
                                         NULL) &&
        StrongNameErrorInfo() != CORSEC_E_MISSING_STRONGNAME) {
        LOG((LF_ALL, LL_INFO10, "Program exiting due to strong name verification failure\n"));
        return -1;
    }

    // Before we initialize the EE, make sure we've snooped for all EE-specific
    // command line arguments that might guide our startup.
    CorCommandLine::SetArgvW(pCmdLine);

    HRESULT result = CoInitializeEE(COINITEE_DEFAULT);
    if (FAILED(result)) {
        VMDumpCOMErrors(result);
        SetLatchedExitCode (-1);
        goto exit;
    }

#if ZAPMONITOR_ENABLED
    // We need to put in an exception handler at this point, so we can handle AVs which
    // occur as a result of initialization
    INSTALL_COMPLUS_EXCEPTION_HANDLER();
#endif
    hr = PEFile::Create(pUnmappedPE, cUnmappedPE, 
                        pImageNameIn, 
                        pLoadersFileName, 
                        NULL, 
                        &pFile,
                        FALSE);

    if (SUCCEEDED(hr)) {
        // Executables are part of the system domain
        hr = SystemDomain::ExecuteMainMethod(pFile, pImageNameIn);
        bRetVal = SUCCEEDED(hr);
    }

    if (!bRetVal) {
        // The only reason I've seen this type of error in the wild is bad 
        // metadata file format versions and inadequate error handling for 
        // partially signed assemblies.  While this may happen during 
        // development, our customers should not get here.  This is a back-stop 
        // to catch CLR bugs. If you see this, please try to find a better way 
        // to handle your error, like throwing an unhandled exception.
        CorMessageBoxCatastrophic(NULL, IDS_EE_COREXEMAIN2_FAILED_TEXT, IDS_EE_COREXEMAIN2_FAILED_TITLE, MB_ICONSTOP, TRUE);
        SetLatchedExitCode (-1);
    }


#if ZAPMONITOR_ENABLED
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
#endif

#if defined( PERFALLOC )
    if (PerfNew::GetEnabledPerfAllocStats() >= PERF_ALLOC_STARTUP)
        PerfNew::PerfAllocReport();
    if (PerfVirtualAlloc::GetEnabledVirtualAllocStats() >= PERF_VIRTUAL_ALLOC_STARTUP)
        PerfVirtualAlloc::ReportPerfAllocStats();
#endif

exit:
    LOG((LF_ALL, LL_INFO10, "Program exiting: return code = %d\n", GetLatchedExitCode()));

    LOG((LF_SYNC, INFO3, "EEShutDown invoked from _CorExeMain2\n"));
    EEShutDown(FALSE);

    SafeExitProcess(GetLatchedExitCode());
    __assume(0); // We never get here
}


//*****************************************************************************
// This is the call point to wire up an EXE.  In this case we have the HMODULE
// and just need to make sure we do to correct self referantial things.
//*****************************************************************************

#ifdef PLATFORM_CE
STDMETHODCALLTYPE ExecuteEXE(HMODULE hMod,
                             LPWSTR lpCmdLine,
                             int    nCmdShow,
                             DWORD  dwRva14)
#else // !PLATFORM_CE
STDMETHODCALLTYPE ExecuteEXE(HMODULE hMod)
#endif // !PLATFORM_CE
{
    BOOL retval = FALSE;
    Module *pModule = NULL;

    _ASSERTE(hMod);
    if (!hMod)
        return retval;

    // Strong name validate if necessary.
    WCHAR wszImageName[MAX_PATH + 1];
    if (!WszGetModuleFileName(hMod, wszImageName, MAX_PATH))
        return retval;
    if(!StrongNameSignatureVerification(wszImageName,
                                          SN_INFLAG_INSTALL|SN_INFLAG_ALL_ACCESS|SN_INFLAG_RUNTIME,
                                          NULL)) 
    {
        HRESULT hrError=StrongNameErrorInfo();
        if (hrError != CORSEC_E_MISSING_STRONGNAME)
        {
            CorMessageBox(NULL, IDS_EE_INVALID_STRONGNAME, IDS_EE_INVALID_STRONGNAME_TITLE, MB_ICONSTOP, TRUE, wszImageName);

            if (g_fExceptionsOK)
            {
                #define MAKE_TRANSLATIONFAILED pImageName=""
                MAKE_UTF8PTR_FROMWIDE(pImageName,wszImageName);
                #undef MAKE_TRANSLATIONFAILED
                PostFileLoadException(pImageName,TRUE,NULL,hrError,THROW_ON_ERROR);
            }
            return retval;
        }
    }

#ifdef PLATFORM_CE
    PEFile::RegisterBaseAndRVA14(hMod, hMod, dwRva14);
#endif // PLATFORM_CE

#if ZAPMONITOR_ENABLED
    // We need to put in an exception handler at this point, so we can handle AVs which
    // occur as a result of initialization
    INSTALL_COMPLUS_EXCEPTION_HANDLER();
#endif

    PEFile *pFile;
    HRESULT hr = PEFile::Create(hMod, &pFile, FALSE);

    if (SUCCEEDED(hr)) {
        // Executables are part of the system domain
        hr = SystemDomain::ExecuteMainMethod(pFile, wszImageName);
        retval = SUCCEEDED(hr);
    }

#if ZAPMONITOR_ENABLED
    UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
#endif

#if defined( PERFALLOC )
    if (PerfNew::GetEnabledPerfAllocStats() >= PERF_ALLOC_STARTUP)
        PerfNew::PerfAllocReport();
    if (PerfVirtualAlloc::GetEnabledVirtualAllocStats() >= PERF_VIRTUAL_ALLOC_STARTUP)
        PerfVirtualAlloc::ReportPerfAllocStats();
#endif
    
    return retval;
}

//*****************************************************************************
// This is the call point to make a DLL that is already loaded into our address 
// space run. There will be other code to actually have us load a DLL due to a 
// class referance.
//*****************************************************************************
#ifdef PLATFORM_CE
BOOL STDMETHODCALLTYPE ExecuteDLL(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved, LPVOID pDllBase, DWORD dwRva14)
#else // !PLATFORM_CE
BOOL STDMETHODCALLTYPE ExecuteDLL(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
#endif // !PLATFORM_CE
{
    BOOL    ret = FALSE;
    PEFile *pFile = NULL;
    HRESULT hr;
    switch (dwReason) 
    {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        {
            _ASSERTE(hInst);
            if (!hInst)
                return FALSE;

            if (dwReason == DLL_PROCESS_ATTACH) {
                if (FAILED(CoInitializeEE(COINITEE_DLL)))
                    return FALSE;
                else {
                    // If a worker thread does a LoadLibrary and the EE has already
                    // started on another thread then we need to setup this thread 
                    // correctly.
                    if(SetupThread() == NULL)
                        return NULL;
                }
            }
            // IJW assemblies cause the thread doing the process attach to 
            // re-enter ExecuteDLL and do a thread attach. This happens when
            // CoInitializeEE() above executed
            else if (! (GetThread() && GetThread()->GetDomain() && CanRunManagedCode()) )
                return TRUE;

#ifdef PLATFORM_CE
            PEFile::RegisterBaseAndRVA14((HMODULE)hInst, pDllBase, dwRva14);
#endif // PLATFORM_CE

            IMAGE_COR20_HEADER* pCor;
            IMAGE_DOS_HEADER*   pDos;
            IMAGE_NT_HEADERS*   pNT;
            
            if(SUCCEEDED(CorMap::ReadHeaders((PBYTE) hInst, &pDos, &pNT, &pCor, FALSE, 0)))
            {
                //
                // A module cannot be successfully created around a PEFile
                // which does not own its HMODULE.  So, we do a LoadLibrary
                // here to claim it.
                //


                // Fixup any EAT's with a bootstrap thunk
                DWORD numEATEntries;
                BOOL  hasFixups;
                BYTE *pEATJArray = FindExportAddressTableJumpArray((BYTE*)hInst, &numEATEntries, &hasFixups);
                if (pEATJArray) 
                {
                    while (numEATEntries--) 
                    {
                        EATThunkBuffer *pEATThunkBuffer = (EATThunkBuffer*) pEATJArray;
                        pEATThunkBuffer->InitForBootstrap(pFile);
                        pEATJArray = pEATJArray + IMAGE_COR_EATJ_THUNK_SIZE;
                    }
                }

                // Get the entry point for the IJW module
                mdMethodDef tkEntry = pCor->EntryPointToken;

                BOOL   hasEntryPoint = (TypeFromToken(tkEntry) == mdtMethodDef &&
                                        !IsNilToken(tkEntry));

                // IJW modules can be compiled with /noentry, in which case they don't
                // have entrypoints but they may still have VTable 1fixups that need
                // processing
                if (hasEntryPoint || hasFixups)
                {
                    MethodDesc *pMD;
                    AppDomain *pDomain;
                    Module* pModule;
                    Assembly* pAssembly;
                    Thread* pThread;
                    BOOL fWasGCDisabled;

                    // Disable GC if not already disabled
                    pThread = GetThread();

                    fWasGCDisabled = pThread->PreemptiveGCDisabled();
                    if (fWasGCDisabled == FALSE)
                        pThread->DisablePreemptiveGC();

                    pDomain = SystemDomain::GetCurrentDomain();
                    _ASSERTE(pDomain);

                    //
                    // Go ahead and create the assembly now.
                    //
                    
                    if (SUCCEEDED(PEFile::Create((HMODULE)hInst, &pFile, FALSE))) 
                    {

                        LPCWSTR pFileName = pFile->GetFileName();
                        HMODULE newMod = WszLoadLibrary(pFileName);
                        BOOL fFreeModule = FALSE;
                        _ASSERTE(newMod == (HMODULE) hInst);

                        OBJECTREF pThrowable = NULL;
                        BEGINCANNOTTHROWCOMPLUSEXCEPTION();
                        GCPROTECT_BEGIN(pThrowable);
                        IAssembly* pFusionAssembly = pThread->GetFusionAssembly();
                        if (pFusionAssembly)
                        {
                            DWORD dwSize = MAX_PATH;
                            WCHAR szPath[MAX_PATH];
                            WCHAR *pPath = &(szPath[0]);
                            hr = pFusionAssembly->GetManifestModulePath(pPath,
                                                        &dwSize);
                            if(hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
                            {
                                pPath = (WCHAR*) _alloca(dwSize*sizeof(WCHAR));
                                hr = pFusionAssembly->GetManifestModulePath(pPath,
                                                        &dwSize);
                            }
                            if (SUCCEEDED(hr)&&_wcsicmp(pPath,pFileName)==0)
                                pThread->SetFusionAssembly(NULL);  //just in case someone decides to load local library
                            else
                                pFusionAssembly=NULL;  // IAssembly is for another file

                        }
                        
                        
                        hr = pDomain->LoadAssembly(pFile, 
                                                   pFusionAssembly, // Passed from PEfile::Create
                                                   &pModule, 
                                                   &pAssembly,
                                                   NULL,
                                                   NULL,
                                                   FALSE, 
                                                   &pThrowable);
                        
                        if (pFusionAssembly)
                            pFusionAssembly->Release();  // we don't need it anymore

                        Thread* pThread = GetThread();
                        BOOL bRedirectingEP = (pThread!=NULL&&pThread->IsRedirectingEntryPoint());
                            

                        if(hr == COR_E_ASSEMBLYEXPECTED)
                            if(!bRedirectingEP) 
                            {
                                // We should be part of an assembly
                                hr = PEFile::Create((HMODULE)hInst, &pFile, FALSE);
                                if(SUCCEEDED(hr)) 
                                {
                                    pAssembly = pThread->GetAssembly();
                                    mdFile kFile = pThread->GetAssemblyModule();
                                    if(pAssembly) 
                                        hr = pAssembly->LoadFoundInternalModule(pFile,
                                                                                kFile,
                                                                                FALSE,
                                                                                &pModule,
                                                                                &pThrowable);
                                }
                            }
                            else
                                ret=TRUE; //well, it is success...
 
                        GCPROTECT_END();
                        ENDCANNOTTHROWCOMPLUSEXCEPTION();
                        
                        if (SUCCEEDED(hr))
                        {
                            // If we successfully built a PEFILE around the image
                            // and it has been hooked into our structures then
                            // the destruction of the pefile needs to clean up 
                            // the image.
                            pFile->ShouldDelete();

                            ret = TRUE;
                            if (hasEntryPoint
                                && !pDomain->IsCompilationDomain())
                            {
                                pMD = pModule->FindFunction(tkEntry);
                                if (pMD)
                                {
                                    pModule->SetDllEntryPoint(pMD);
                                    if (FAILED(RunDllMain(pMD, hInst, dwReason, lpReserved)))
                                    {
                                        pModule->SetDllEntryPoint(NULL);
                                        ret = FALSE;
                                    }
                                }
                            }
                        }

                        if(fFreeModule)
                            delete pModule;

                        if (fWasGCDisabled == FALSE)
                            pThread->EnablePreemptiveGC();
                    }
                }
                else 
                {
                    ret = TRUE;
                    
                    // If there is no user entry point, then we don't want the
                    // thread start/stop events going through because it'll cause
                    // us to do a module lookup every time.
                    DisableThreadLibraryCalls(hInst);
                }
            }
            break;
        }

        default:
        {
            ret = TRUE;

            // If the EE is still intact, the run user entry points.  Otherwise
            // detach was handled when the app domain was stopped.
            if (CanRunManagedCode() &&
                FAILED(SystemDomain::RunDllMain(hInst, dwReason, lpReserved)))
                    ret = FALSE;
            
            // This does need to match the attach. We will only unload dll's 
            // at the end and CoUninitialize will just bounce at 0. WHEN and IF we
            // get around to unloading IL DLL's during execution prior to
            // shutdown we will need to bump the reference one to compensate
            // for this call.
            if (dwReason == DLL_PROCESS_DETACH && !g_fFatalError)
                CoUninitializeEE(TRUE);

            break;
        }
    }

    return ret;
}


//
// Initialize the Garbage Collector
//

HRESULT InitializeGarbageCollector()
{
    HRESULT hr;

    // Build the special Free Object used by the Generational GC
    g_pFreeObjectMethodTable = (MethodTable *) new (nothrow) BYTE[sizeof(MethodTable) - sizeof(SLOT)];
    if (g_pFreeObjectMethodTable == NULL)
        return (E_OUTOFMEMORY);

    // As the flags in the method table indicate there are no pointers
    // in the object, there is no gc descriptor, and thus no need to adjust
    // the pointer to skip the gc descriptor.

    g_pFreeObjectMethodTable->m_BaseSize = ObjSizeOf (ArrayBase);
    g_pFreeObjectMethodTable->m_pEEClass = NULL;
    g_pFreeObjectMethodTable->m_wFlags   = MethodTable::enum_flag_Array;
    g_pFreeObjectMethodTable->m_ComponentSize = 1;


   {
        GCHeap *pGCHeap = new (nothrow) GCHeap();
        if (!pGCHeap)
            return (E_OUTOFMEMORY);
        hr = pGCHeap->Initialize();            

        g_pGCHeap = pGCHeap;
    }            

    return(hr);
}



//
// Shutdown the Garbage Collector
//

#ifdef SHOULD_WE_CLEANUP
VOID TerminateGarbageCollector()
{
    g_pGCHeap->Shutdown();
    delete g_pGCHeap;
    g_pGCHeap = NULL;

    // As the flags in the method table indicate there are no pointers
    // in the object, there was no gc descriptor allocated and thus
    // we didn't adjust the pointer at allocation time, and thus there
    // is no need anymore to back adjust here.

    delete [] (BYTE*)g_pFreeObjectMethodTable;
}
#endif /* SHOULD_WE_CLEANUP */



//*****************************************************************************
//@FUTURE - LBS
// There will need to be a LoadClassByName which will actually perform the LoadLibrary
// By calling PELoader::Open() with a module name,  This will come in later but most of
// the code is in place to make - if (peloader->open(szModuleName)) work!
//*****************************************************************************


//*****************************************************************************
// This is the part of the old-style DllMain that initializes the
// stuff that the EE team works on. It's called from the real DllMain
// up in MSCOREE land. Separating the DllMain tasks is simply for
// convenience due to the dual build trees.
//*****************************************************************************
BOOL STDMETHODCALLTYPE EEDllMain( // TRUE on success, FALSE on error.
    HINSTANCE   hInst,             // Instance handle of the loaded module.
    DWORD       dwReason,          // Reason for loading.
    LPVOID      lpReserved)        // Unused.
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {     
            // init sync operations
            InitFastInterlockOps();
            // Initialization lock
            InitializeCriticalSection(&g_LockStartup);
            // Remember module instance
            g_pMSCorEE = hInst;

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            // lpReserved is NULL if we're here because someone called FreeLibrary
            // and non-null if we're here because the process is exiting
            if (lpReserved)
                g_fProcessDetach = TRUE;
            
            if (g_RefCount > 0 || g_fEEStarted)
            {
                Thread *pThread = GetThread();
                if (pThread == NULL)
                    break;
                if (g_pGCHeap->IsGCInProgress()
                    && (pThread != g_pGCHeap->GetGCThread()
                        || !g_fSuspendOnShutdown))
                    break;

                // Deliberately leak this critical section, since we rely on it to
                // coordinate the EE shutdown -- even if we are called from another
                // DLL's DLL_PROCESS_DETACH notification, which is potentially after
                // we received our own detach notification and terminated.
                //
                // DeleteCriticalSection(&g_LockStartup);

                LOG((LF_SYNC, INFO3, "EEShutDown invoked from EEDllMain\n"));
                EEShutDown(TRUE); // shut down EE if it was started up
            }
            break;
        }

        case DLL_THREAD_DETACH:
        {
#ifdef STRESS_LOG
            StressLog::ThreadDetach();
#endif
            // Don't destroy threads here if we're in shutdown (shutdown will
            // clean up for us instead).

            // Don't use GetThread because perhaps we didn't initialize yet, or we
            // have already shutdown the EE.  Note that there is a race here.  We
            // might ask for TLS from a slot we just released.  We are assuming that
            // nobody re-allocates that same slot while we are doing this.  It just
            // isn't worth locking for such an obscure case.
            DWORD   tlsVal = GetThreadTLSIndex();

            if (tlsVal != (DWORD)-1 && CanRunManagedCode())
            {
                Thread  *thread = (Thread *) ::TlsGetValue(tlsVal);
    
                if (thread)
                {                       
                    // reset the CoInitialize state
                    // so we don't call CoUninitialize during thread detach
                    thread->ResetCoInitialized();
                    DetachThread(thread);
                }
            }
        }
    }

    return TRUE;
}

//*****************************************************************************
// Helper function to call the managed registration services.
//*****************************************************************************
enum EnumRegServicesMethods
{
    RegServicesMethods_RegisterAssembly = 0,
    RegServicesMethods_UnregisterAssembly,
    RegServicesMethods_LastMember
};

HRESULT InvokeRegServicesMethod(EnumRegServicesMethods Method, HMODULE hMod)
{                   
    HRESULT hr = S_OK;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    PEFile *pFile = NULL;
    Module *pModule = NULL;
    AppDomain *pDomain = NULL;
    Assembly* pAssembly = NULL;
    Thread* pThread = GetThread();
    OBJECTREF pThrowable = NULL;
    BOOL fWasGCDisabled;

#ifdef PLATFORM_CE
    _ASSERTE(!"We need to get the RVA14 and DllBase parameters somehow");
#else // !PLATFORM_CE
    hr = PEFile::Create(hMod, &pFile, FALSE);
#endif // !PLATFORM_CE

    if (FAILED(hr))
        goto Exit;

    // Disable GC if not already disabled
    fWasGCDisabled = pThread->PreemptiveGCDisabled();
    if (fWasGCDisabled == FALSE)
        pThread->DisablePreemptiveGC();

    // Add the assembly to the current domain.
    pDomain = SystemDomain::GetCurrentDomain();
    _ASSERTE(pDomain);


    GCPROTECT_BEGIN(pThrowable);
    hr = pDomain->LoadAssembly(pFile, 
                               NULL,   // Not From fusion
                               &pModule, 
                               &pAssembly,
                               NULL,
                               NULL,
                               FALSE,
                               &pThrowable);
    GCPROTECT_END();

    if (FAILED(hr))
        goto Exit;

    COMPLUS_TRY
    {
        // The names of the RegistrationServices methods.
        static BinderMethodID aMethods[] =
        {
            METHOD__REGISTRATION_SERVICES__REGISTER_ASSEMBLY,
            METHOD__REGISTRATION_SERVICES__UNREGISTER_ASSEMBLY
        };

        // Retrieve the method desc to use.
        MethodDesc *pMD = g_Mscorlib.GetMethod(aMethods[Method]);

        // Allocate the RegistrationServices object.
        OBJECTREF RegServicesObj = AllocateObject(g_Mscorlib.GetClass(CLASS__REGISTRATION_SERVICES));
        GCPROTECT_BEGIN(RegServicesObj)
        {
            // Validate that both methods take the same parameters.
            _ASSERTE(g_Mscorlib.GetMethodSig(METHOD__REGISTRATION_SERVICES__REGISTER_ASSEMBLY)
                     == g_Mscorlib.GetMethodSig(METHOD__REGISTRATION_SERVICES__UNREGISTER_ASSEMBLY));

            // Invoke the method itself.
            INT64 Args[] = { 
                ObjToInt64(RegServicesObj),
                ObjToInt64(pAssembly->GetExposedObject())
            };

            pMD->Call(Args, METHOD__REGISTRATION_SERVICES__REGISTER_ASSEMBLY);
        }
        GCPROTECT_END();
    }
    COMPLUS_CATCH
    {
        hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH

    // Restore the GC state.
    if (fWasGCDisabled == FALSE)
        pThread->EnablePreemptiveGC();

Exit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();
    return hr;
}

//*****************************************************************************
// This entry point is called to register the classes contained inside a 
// COM+ assembly.
//*****************************************************************************
STDAPI EEDllRegisterServer(HMODULE hMod)
{
    // Start up the runtime since we are going to use managed code to actually
    // do the registration.
    HRESULT hr = CoInitializeEE(COINITEE_DLL);
    if (FAILED(hr))
        return hr;

    hr = InvokeRegServicesMethod(RegServicesMethods_RegisterAssembly, hMod);

    // Shut down the runtime now that we have finished the registration.
    CoUninitializeEE(COINITEE_DLL);
    return hr;
}

//*****************************************************************************
// This entry point is called to unregister the classes contained inside a 
// COM+ assembly.
//*****************************************************************************
STDAPI EEDllUnregisterServer(HMODULE hMod)
{
    // Start up the runtime since we are going to use managed code to actually
    // do the unregistration.
    HRESULT hr = CoInitializeEE(COINITEE_DLL);
    if (FAILED(hr))
        return hr;

    hr = InvokeRegServicesMethod(RegServicesMethods_UnregisterAssembly, hMod);

    // Shut down the runtime now that we have finished the unregistration.
    CoUninitializeEE(COINITEE_DLL);
    return hr;
}

#ifdef DEBUGGING_SUPPORTED
//*****************************************************************************
// This is used to get the proc address by name of a proc in MSCORDBC.DLL
// It will perform a LoadLibrary if necessary.
//*****************************************************************************
static HRESULT GetDBCProc(char *szProcName, FARPROC *pProcAddr)
{
    _ASSERTE(szProcName != NULL);
    _ASSERTE(pProcAddr != NULL);

    HRESULT  hr = S_OK;
    Thread  *thread = GetThread();
    BOOL     toggleGC = (thread && thread->PreemptiveGCDisabled());

    if (toggleGC)
        thread->EnablePreemptiveGC();

    // If the library hasn't already been loaded, do so
    if (g_pDebuggerDll == NULL)
    {
        DWORD lgth = _MAX_PATH + 1;
        WCHAR wszFile[_MAX_PATH + 1];
        hr = GetInternalSystemDirectory(wszFile, &lgth);
        if(FAILED(hr)) goto leav;

        wcscat(wszFile, L"mscordbc.dll");
        g_pDebuggerDll = WszLoadLibrary(wszFile);

        if (g_pDebuggerDll == NULL)
        {
            LOG((LF_CORPROF | LF_CORDB, LL_INFO10,
                 "MSCORDBC.DLL not found.\n"));
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto leav;
        }
    }
    _ASSERTE(g_pDebuggerDll != NULL);

    // Get the pointer to the requested function
    *pProcAddr = GetProcAddress(g_pDebuggerDll, szProcName);

    // If the proc address was not found, return error
    if (pProcAddr == NULL)
    {
        LOG((LF_CORPROF | LF_CORDB, LL_INFO10,
             "'%s' not found in MSCORDBC.DLL\n"));
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto leav;
    }

leav:

    if (toggleGC)
        thread->DisablePreemptiveGC();

    return hr;
}
#endif // DEBUGGING_SUPPORTED

#ifdef DEBUGGING_SUPPORTED
//*****************************************************************************
// This gets the environment var control flag for Debugging and Profiling
//*****************************************************************************
extern "C"
{
    _CRTIMP unsigned long __cdecl strtoul(const char *, char **, int);
}
static void GetDbgProfControlFlag()
{
    // Check the debugger/profiling control environment variable to
    // see if there's any work to be done.
    g_CORDebuggerControlFlags = DBCF_NORMAL_OPERATION;
    
    char buf[32];
    DWORD len = GetEnvironmentVariableA(CorDB_CONTROL_ENV_VAR_NAME,
                                        buf, sizeof(buf));
    _ASSERTE(len < sizeof(buf));

    char *szBad;
    int  iBase;
    if (len > 0 && len < sizeof(buf))
    {
        iBase = (*buf == '0' && (*(buf + 1) == 'x' || *(buf + 1) == 'X')) ? 16 : 10;
        ULONG dbg = strtoul(buf, &szBad, iBase) & DBCF_USER_MASK;

        if (dbg == 1)
            g_CORDebuggerControlFlags |= DBCF_GENERATE_DEBUG_CODE;
    }

    len = GetEnvironmentVariableA(CorDB_CONTROL_REMOTE_DEBUGGING,
                                  buf, sizeof(buf));
    _ASSERTE(len < sizeof(buf));

    if (len > 0 && len < sizeof(buf))
    {
        iBase = (*buf == '0' && (*(buf + 1) == 'x' || *(buf + 1) == 'X')) ? 16 : 10;
        ULONG rmt = strtoul(buf, &szBad, iBase);

        if (rmt == 1)
            g_CORDebuggerControlFlags |= DBCF_ACTIVATE_REMOTE_DEBUGGING;
    }
}
#endif // DEBUGGING_SUPPORTED

/*
 * This will initialize the profiling services, if profiling is enabled.
 */

#define LOGPROFFAILURE(msg)                                                \
    {                                                                      \
        HANDLE hEventLog = RegisterEventSourceA(NULL, "CLR");             \
        if (hEventLog != NULL)                                             \
        {                                                                  \
            const char *szMsg = msg;                                       \
            ReportEventA(hEventLog, EVENTLOG_ERROR_TYPE, 0, 0, NULL, 1, 0, \
                         &szMsg, NULL);                                    \
            DeregisterEventSource(hEventLog);                              \
        }                                                                  \
    }


#ifdef PROFILING_SUPPORTED
#define ENV_PROFILER L"COR_PROFILER"
#define ENV_PROFILER_A "COR_PROFILER"
static HRESULT InitializeProfiling()
{
    HRESULT hr;

    // This has to be called to initialize the WinWrap stuff so that WszXXX
    // may be called.
    OnUnicodeSystem();

    // Find out if profiling is enabled
    DWORD fProfEnabled = g_pConfig->GetConfigDWORD(CorDB_CONTROL_ProfilingL, 0, REGUTIL::COR_CONFIG_ALL, FALSE);
    
    // If profiling is not enabled, return.
    if (fProfEnabled == 0)
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: Profiling not enabled.\n"));
        return (S_OK);
    }

    LOG((LF_CORPROF, LL_INFO10, "**PROF: Initializing Profiling Services.\n"));

    // Get the CLSID of the profiler to CoCreate
    LPWSTR wszCLSID = g_pConfig->GetConfigString(ENV_PROFILER, FALSE);

    // If the environment variable doesn't exist, profiling is not enabled.
    if (wszCLSID == NULL)
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: Profiling flag set, but required "
             "environment variable does not exist.\n"));

        LOGPROFFAILURE("Profiling flag set, but required environment ("
                       ENV_PROFILER_A ") was not set.");

        return (S_FALSE);
    }

    //*************************************************************************
    // Create the EE interface to provide to the profiling services
    ProfToEEInterface *pProfEE =
        (ProfToEEInterface *) new (nothrow) ProfToEEInterfaceImpl();

    if (pProfEE == NULL)
        return (E_OUTOFMEMORY);

    // Initialize the interface
    hr = pProfEE->Init();

    if (FAILED(hr))
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: ProfToEEInterface::Init failed.\n"));

        LOGPROFFAILURE("Internal profiling services initialization failure.");

        delete pProfEE;
        delete [] wszCLSID;
        return (S_FALSE);
    }
    
    //*************************************************************************
    // Provide the EE interface to the Profiling services
    SETPROFTOEEINTERFACE *pSetProfToEEInterface;
    hr = GetDBCProc("SetProfToEEInterface", (FARPROC *)&pSetProfToEEInterface);

    if (FAILED(hr))
    {
        LOGPROFFAILURE("Internal profiling services initialization failure.");

        delete [] wszCLSID;
        return (S_FALSE);
    }

    _ASSERTE(pSetProfToEEInterface != NULL);

    // Provide the newly created and inited interface
    pSetProfToEEInterface(pProfEE);

    //*************************************************************************
    // Get the Profiling services interface
    GETEETOPROFINTERFACE *pGetEEToProfInterface;
    hr = GetDBCProc("GetEEToProfInterface", (FARPROC *)&pGetEEToProfInterface);
    _ASSERTE(pGetEEToProfInterface != NULL);

    pGetEEToProfInterface(&g_profControlBlock.pProfInterface);
    _ASSERTE(g_profControlBlock.pProfInterface != NULL);

    // Check if we successfully got an interface to 
    if (g_profControlBlock.pProfInterface == NULL)
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: GetEEToProfInterface failed.\n"));

        LOGPROFFAILURE("Internal profiling services initialization failure.");

        pSetProfToEEInterface(NULL);

        delete pProfEE;
        delete [] wszCLSID;
        return (S_FALSE);
    }

    //*************************************************************************
    // Now ask the profiling services to CoCreate the profiler

    // Indicate that the profiler is in initialization phase
    g_profStatus = profInInit;

    // This will CoCreate the profiler
    hr = g_profControlBlock.pProfInterface->CreateProfiler(wszCLSID);
    delete [] wszCLSID;

    if (FAILED(hr))
    {
        LOG((LF_CORPROF, LL_INFO10, "**PROF: No profiler registered, or "
             "CoCreate failed.  Shutting down profiling.\n"));

        LOGPROFFAILURE("Failed to CoCreate profiler.");

        // Notify the profiling services that the EE is shutting down
        g_profControlBlock.pProfInterface->Terminate(FALSE);
        g_profControlBlock.pProfInterface = NULL;
        g_profStatus = profNone;

        return (S_FALSE);
    }

    LOG((LF_CORPROF, LL_INFO10, "**PROF: Profiler created and enabled.\n"));

    // @TODO SIMONHAL: Remove this when concurrent GC profiler events are
    //                 fully supported

    // If the profiler is interested in tracking GC events, then we must
    // disable concurrent GC since concurrent GC can allocate and kill
    // objects without relocating and thus not doing a heap walk.
    if (CORProfilerTrackGC())
        g_pConfig->SetGCconcurrent(0);

    // If the profiler has requested the use of the inprocess debugging API
    // then we need to initialize the services here.
    if (CORProfilerInprocEnabled())
    {
        hr = g_pDebugInterface->InitInProcDebug();
        _ASSERTE(SUCCEEDED(hr));

        InitializeCriticalSection(&g_profControlBlock.crSuspendLock);
    }

    // Indicate that profiling is properly initialized.
    g_profStatus = profInit;
    return (hr);
}

/*
 * This will terminate the profiling services, if profiling is enabled.
 */
static void TerminateProfiling(BOOL fProcessDetach)
{
    _ASSERTE(g_profStatus != profNone);

    // If we have a profiler interface active, then terminate it.
    if (g_profControlBlock.pProfInterface)
    {
        // Notify the profiling services that the EE is shutting down
        g_profControlBlock.pProfInterface->Terminate(fProcessDetach);
        g_profControlBlock.pProfInterface = NULL;
    }

    // If the profiler has requested the use of the inprocess debugging API
    // then we need to uninitialize the critical section here
    if (CORProfilerInprocEnabled())
    {
        HRESULT hr = g_pDebugInterface->UninitInProcDebug();
        _ASSERTE(SUCCEEDED(hr));

        DeleteCriticalSection(&g_profControlBlock.crSuspendLock);
    }

    g_profStatus = profNone;
}
#endif // PROFILING_SUPPORTED

#ifdef DEBUGGING_SUPPORTED
//
// InitializeDebugger initialized the Runtime-side COM+ Debugging Services
//
static HRESULT InitializeDebugger(void)
{
    HRESULT hr = S_OK;

    // The right side depends on this, so if it changes, then
    // FIELD_OFFSET_NEW_ENC_DB should be changed, as well.
    _ASSERTE(FIELD_OFFSET_NEW_ENC == 0x07FFFFFB); 
    
    LOG((LF_CORDB, LL_INFO10,
         "Initializing left-side debugging services.\n"));
    
    FARPROC gi = (FARPROC) &CorDBGetInterface;

    // Init the interface the EE provides to the debugger,
    // ask the debugger for its interface, and if all goes
    // well call Startup on the debugger.
    EEDbgInterfaceImpl::Init();

    if (g_pEEDbgInterfaceImpl == NULL)
        return (E_OUTOFMEMORY);

    typedef HRESULT __cdecl CORDBGETINTERFACE(DebugInterface**);
    hr = ((CORDBGETINTERFACE*)gi)(&g_pDebugInterface);

    if (SUCCEEDED(hr))
    {
        g_pDebugInterface->SetEEInterface(g_pEEDbgInterfaceImpl);
        hr = g_pDebugInterface->Startup();

        if (SUCCEEDED(hr))
        {
            // If there's a DebuggerThreadControl interface, then we
            // need to update the DebuggerSpecialThread list.
            if (CorHost::GetDebuggerThreadControl())
            {
                hr = CorHost::RefreshDebuggerSpecialThreadList();
                _ASSERTE((SUCCEEDED(hr)) && (hr != S_FALSE));
            }

            LOG((LF_CORDB, LL_INFO10,
                 "Left-side debugging services setup.\n"));
        }
        else
            LOG((LF_CORDB, LL_INFO10,
                 "Failed to Startup debugger. HR=0x%08x\n",
                 hr));
    }
    
    if (!SUCCEEDED(hr))
    {   
        LOG((LF_CORDB, LL_INFO10, "Debugger setup failed."
             " HR=0x%08x\n", hr));
        
        EEDbgInterfaceImpl::Terminate();
        g_pDebugInterface = NULL;
        g_pEEDbgInterfaceImpl = NULL;
    }
    
    // If there is a DebuggerThreadControl interface, then it was set before the debugger
    // was initialized and we need to provide this interface now.  If debugging is already
    // initialized then the IDTC pointer is passed in when it is set through CorHost
    IDebuggerThreadControl *pDTC = CorHost::GetDebuggerThreadControl();

    if (SUCCEEDED(hr) && pDTC)
        g_pDebugInterface->SetIDbgThreadControl(pDTC);

    return hr;
}


//
// TerminateDebugger shuts down the Runtime-side COM+ Debugging Services
//
static void TerminateDebugger(void)
{
    // Notify the out-of-process debugger that shutdown of the in-process debugging support has begun. This is only
    // really used in interop debugging scenarios.
    g_pDebugInterface->ShutdownBegun();

#ifdef EnC_SUPPORTED
    EditAndContinueModule::ClassTerm();
#endif // EnC_SUPPORTED

    LOG((LF_CORDB, LL_INFO10, "Shutting down left-side debugger services.\n"));
    
    g_pDebugInterface->StopDebugger();
    
    EEDbgInterfaceImpl::Terminate();

    g_CORDebuggerControlFlags = DBCF_NORMAL_OPERATION;
    g_pDebugInterface = NULL;
    g_pEEDbgInterfaceImpl = NULL;

    CorHost::CleanupDebuggerThreadControl();
}

#endif // DEBUGGING_SUPPORTED

// Import from mscoree.obj
HINSTANCE GetModuleInst();


// ---------------------------------------------------------------------------
// Initializes the shared memory block with information required to perform
// a managed minidump.
// ---------------------------------------------------------------------------

HRESULT InitializeDumpDataBlock()
{
    g_ClassDumpData.version = 1;
    ClassDumpTableBlock* block = 
      g_pIPCManagerInterface->GetClassDumpTableBlock();
    _ASSERTE(block != NULL);
    block->table = &g_ClassDumpData;
    return S_OK;
}


// ---------------------------------------------------------------------------
// Initializes the shared memory block with information required to perform
// a managed minidump.
// ---------------------------------------------------------------------------
HRESULT InitializeMiniDumpBlock()
{
    MiniDumpBlock *pMDB = g_pIPCManagerInterface->GetMiniDumpBlock();
    _ASSERTE(pMDB); 

    // Grab the full path for either mscorwks.dll or mscorsvr.dll
    DWORD res = WszGetModuleFileName(GetModuleInst(), pMDB->szCorPath, NumItems(pMDB->szCorPath));

    // Save the size of the minidump internal data structure
    pMDB->pInternalData = &g_miniDumpData;
    pMDB->dwInternalDataSize = sizeof(MiniDumpInternalData);

    // If we failed to get the module file name, bail
    if (res == 0) {
        DWORD errcode = GetLastError();
        HRESULT hr = errcode? HRESULT_FROM_WIN32(errcode) : E_UNEXPECTED;
        return(hr);
    }

    //
    // Now fill in the MiniDumpInternalData structure
    //

    // Fill out information about the ThreadStore object
    g_miniDumpData.ppb_g_pThreadStore = (PBYTE*) &g_pThreadStore;
    g_miniDumpData.cbThreadStoreObjectSize = sizeof(ThreadStore);

    // Fill out information about Thread objects
    g_miniDumpData.cbThreadObjectSize = sizeof(Thread);
    g_miniDumpData.ppbThreadListHead = (PBYTE *)&(g_pThreadStore->m_ThreadList.m_pHead->m_pNext);
    g_miniDumpData.cbThreadNextOffset = offsetof(Thread, m_LinkStore);
    g_miniDumpData.cbThreadHandleOffset = offsetof(Thread, m_ThreadHandle);
    g_miniDumpData.cbThreadStackBaseOffset = offsetof(Thread, m_CacheStackBase);
    g_miniDumpData.cbThreadContextOffset = offsetof(Thread, m_Context);
    g_miniDumpData.cbThreadDomainOffset = offsetof(Thread, m_pDomain);
    g_miniDumpData.cbThreadLastThrownObjectHandleOffset = offsetof(Thread, m_LastThrownObjectHandle);
    g_miniDumpData.cbThreadTEBOffset = offsetof(Thread, m_pTEB);

    // Fill out information about the ExecutionManager range tree
    g_miniDumpData.ppbEEManagerRangeTree = (PBYTE *) &ExecutionManager::m_RangeTree;

    // Fill out information on whether or not this is a debug build
#ifdef _DEBUG
    g_miniDumpData.fIsDebugBuild = TRUE;
#else
    g_miniDumpData.fIsDebugBuild = FALSE;
#endif

    // Fill out information about MethodDesc's
    g_miniDumpData.cbMethodDescSize = sizeof(MethodDesc);
    g_miniDumpData.cbOffsetOf_m_wFlags = offsetof(MethodDesc, m_wFlags);
    g_miniDumpData.cbOffsetOf_m_dwCodeOrIL = offsetof(MethodDesc, m_CodeOrIL);
    g_miniDumpData.cbMD_IndexOffset = (SIZE_T) MDEnums::MD_IndexOffset;
    g_miniDumpData.cbMD_SkewOffset = (SIZE_T) MDEnums::MD_SkewOffset;

#ifdef _DEBUG
    g_miniDumpData.cbOffsetOf_m_pDebugEEClass = offsetof(MethodDesc, m_pDebugEEClass);
    g_miniDumpData.cbOffsetOf_m_pszDebugMethodName = offsetof(MethodDesc, m_pszDebugMethodName);;
    g_miniDumpData.cbOffsetOf_m_pszDebugMethodSignature = offsetof(MethodDesc, m_pszDebugMethodSignature);
#else
    g_miniDumpData.cbOffsetOf_m_pDebugEEClass = -1;
    g_miniDumpData.cbOffsetOf_m_pszDebugMethodName = -1;
    g_miniDumpData.cbOffsetOf_m_pszDebugMethodSignature = -1;
#endif

    // Fill out information about MethodDescChunk
    g_miniDumpData.cbMethodDescChunkSize = sizeof(MethodDescChunk);
    g_miniDumpData.cbOffsetOf_m_tokrange = offsetof(MethodDescChunk, m_tokrange);

    // Fill out MethodTable information
    g_miniDumpData.cbSizeOfMethodTable = sizeof(MethodTable);
    g_miniDumpData.cbOffsetOf_MT_m_pEEClass = offsetof(MethodTable, m_pEEClass);
    g_miniDumpData.cbOffsetOf_MT_m_pModule = offsetof(MethodTable, m_pModule);
    g_miniDumpData.cbOffsetOf_MT_m_wFlags = offsetof(MethodTable, m_wFlags);
    g_miniDumpData.cbOffsetOf_MT_m_BaseSize = offsetof(MethodTable, m_BaseSize);
    g_miniDumpData.cbOffsetOf_MT_m_ComponentSize = offsetof(MethodTable, m_ComponentSize);
    g_miniDumpData.cbOffsetOf_MT_m_wNumInterface = offsetof(MethodTable, m_wNumInterface);
    g_miniDumpData.cbOffsetOf_MT_m_pIMap = offsetof(MethodTable, m_pIMap);
    g_miniDumpData.cbOffsetOf_MT_m_cbSlots = offsetof(MethodTable, m_cbSlots);
    g_miniDumpData.cbOffsetOf_MT_m_Vtable = offsetof(MethodTable, m_Vtable);

    // Fill out EEClass information
    g_miniDumpData.cbSizeOfEEClass = sizeof(EEClass);
    g_miniDumpData.cbOffsetOf_CLS_m_cl = offsetof(EEClass, m_cl);
    g_miniDumpData.cbOffsetOf_CLS_m_pParentClass = offsetof(EEClass, m_pParentClass);
    g_miniDumpData.cbOffsetOf_CLS_m_pLoader = offsetof(EEClass, m_pLoader);
    g_miniDumpData.cbOffsetOf_CLS_m_pMethodTable = offsetof(EEClass, m_pMethodTable);
    g_miniDumpData.cbOffsetOf_CLS_m_wNumVtableSlots = offsetof(EEClass, m_wNumVtableSlots);
    g_miniDumpData.cbOffsetOf_CLS_m_wNumMethodSlots = offsetof(EEClass, m_wNumMethodSlots);
    g_miniDumpData.cbOffsetOf_CLS_m_dwAttrClass = offsetof(EEClass, m_dwAttrClass);
    g_miniDumpData.cbOffsetOf_CLS_m_VMFlags = offsetof(EEClass, m_VMFlags);
    g_miniDumpData.cbOffsetOf_CLS_m_wNumInstanceFields = offsetof(EEClass, m_wNumInstanceFields);
    g_miniDumpData.cbOffsetOf_CLS_m_wNumStaticFields = offsetof(EEClass, m_wNumStaticFields);
    g_miniDumpData.cbOffsetOf_CLS_m_wThreadStaticOffset = offsetof(EEClass, m_wThreadStaticOffset);
    g_miniDumpData.cbOffsetOf_CLS_m_wContextStaticOffset = offsetof(EEClass, m_wContextStaticOffset);
    g_miniDumpData.cbOffsetOf_CLS_m_wThreadStaticsSize = offsetof(EEClass, m_wThreadStaticsSize);
    g_miniDumpData.cbOffsetOf_CLS_m_wContextStaticsSize = offsetof(EEClass, m_wContextStaticsSize);
    g_miniDumpData.cbOffsetOf_CLS_m_pFieldDescList = offsetof(EEClass, m_pFieldDescList);
    g_miniDumpData.cbOffsetOf_CLS_m_SiblingsChain = offsetof(EEClass, m_SiblingsChain);
    g_miniDumpData.cbOffsetOf_CLS_m_ChildrenChain = offsetof(EEClass, m_ChildrenChain);
#ifdef _DEBUG
    g_miniDumpData.cbOffsetOf_CLS_m_szDebugClassName = offsetof(EEClass, m_szDebugClassName);
#else
    g_miniDumpData.cbOffsetOf_CLS_m_szDebugClassName = -1;
#endif

    // Fill out Context information
    g_miniDumpData.cbSizeOfContext = sizeof(Context);
    g_miniDumpData.cbOffsetOf_CTX_m_pDomain = offsetof(Context, m_pDomain);

    // Fill out stub call instruction struct information
    g_miniDumpData.cbSizeOfStubCallInstrs = sizeof(StubCallInstrs);
    g_miniDumpData.cbOffsetOf_SCI_m_wTokenRemainder = offsetof(StubCallInstrs, m_wTokenRemainder);

    // Fill out information about the Module class
    g_miniDumpData.cbSizeOfModule = sizeof(Module);
    g_miniDumpData.cbOffsetOf_MOD_m_dwFlags = offsetof(Module, m_dwFlags);
    g_miniDumpData.cbOffsetOf_MOD_m_pAssembly = offsetof(Module, m_pAssembly);
    g_miniDumpData.cbOffsetOf_MOD_m_file = offsetof(Module, m_file);
    g_miniDumpData.cbOffsetOf_MOD_m_zapFile = offsetof(Module, m_zapFile);
    g_miniDumpData.cbOffsetOf_MOD_m_pLookupTableHeap = offsetof(Module, m_pLookupTableHeap);
    g_miniDumpData.cbOffsetOf_MOD_m_TypeDefToMethodTableMap = offsetof(Module, m_TypeDefToMethodTableMap);
    g_miniDumpData.cbOffsetOf_MOD_m_TypeRefToMethodTableMap = offsetof(Module, m_TypeRefToMethodTableMap);
    g_miniDumpData.cbOffsetOf_MOD_m_MethodDefToDescMap = offsetof(Module, m_MethodDefToDescMap);
    g_miniDumpData.cbOffsetOf_MOD_m_FieldDefToDescMap = offsetof(Module, m_FieldDefToDescMap);
    g_miniDumpData.cbOffsetOf_MOD_m_MemberRefToDescMap = offsetof(Module, m_MemberRefToDescMap);
    g_miniDumpData.cbOffsetOf_MOD_m_FileReferencesMap = offsetof(Module, m_FileReferencesMap);
    g_miniDumpData.cbOffsetOf_MOD_m_AssemblyReferencesMap = offsetof(Module, m_AssemblyReferencesMap);
    g_miniDumpData.cbOffsetOf_MOD_m_pNextModule = offsetof(Module, m_pNextModule);
    g_miniDumpData.cbOffsetOf_MOD_m_dwBaseClassIndex = offsetof(Module, m_dwBaseClassIndex);

    // Fill out information about PEFile objects
    g_miniDumpData.cbSizeOfPEFile = sizeof(PEFile);
    g_miniDumpData.cbOffsetOf_PEF_m_wszSourceFile = offsetof(PEFile, m_wszSourceFile);
    g_miniDumpData.cbOffsetOf_PEF_m_hModule = offsetof(PEFile, m_hModule);
    g_miniDumpData.cbOffsetOf_PEF_m_base = offsetof(PEFile, m_base);
    g_miniDumpData.cbOffsetOf_PEF_m_pNT = offsetof(PEFile, m_pNT);

    // Fill out information about PEFile objects
    g_miniDumpData.cbSizeOfCORCOMPILE_METHOD_HEADER = sizeof(CORCOMPILE_METHOD_HEADER);
    g_miniDumpData.cbOffsetOf_CCMH_gcInfo = offsetof(CORCOMPILE_METHOD_HEADER, gcInfo);
    g_miniDumpData.cbOffsetOf_CCMH_methodDesc = offsetof(CORCOMPILE_METHOD_HEADER, methodDesc);

    // This defines extra blocks that should be saved in a minidump
    g_miniDumpData.rgExtraBlocks[g_miniDumpData.cExtraBlocks].pbStart = (PBYTE) &GCHeap::FinalizerThread;
    g_miniDumpData.rgExtraBlocks[g_miniDumpData.cExtraBlocks].cbLen = sizeof(GCHeap::FinalizerThread);
    g_miniDumpData.cExtraBlocks++;

    g_miniDumpData.rgExtraBlocks[g_miniDumpData.cExtraBlocks].pbStart = (PBYTE) &GCHeap::GcThread;
    g_miniDumpData.rgExtraBlocks[g_miniDumpData.cExtraBlocks].cbLen = sizeof(GCHeap::GcThread);
    g_miniDumpData.cExtraBlocks++;

    // This code is for NTSD's SOS extention
#include "clear-class-dump-defs.h"

#define BEGIN_CLASS_DUMP_INFO_DERIVED(klass, parent) \
    g_ClassDumpData.p ## klass ## Vtable = (DWORD_PTR) ## klass ## ::GetFrameVtable();
#define END_CLASS_DUMP_INFO_DERIVED(klass, parent)

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO(klass)
#define END_ABSTRACT_CLASS_DUMP_INFO(klass)

#define BEGIN_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)
#define END_ABSTRACT_CLASS_DUMP_INFO_DERIVED(klass, parent)

#define CDI_CLASS_MEMBER_OFFSET(member)

#include "frame-types.h"

    return (S_OK);
}


#ifndef PLATFORM_CE
// ---------------------------------------------------------------------------
// Initialize InterProcess Communications for COM+
// 1. Allocate an IPCManager Implementation and hook it up to our interface *
// 2. Call proper init functions to activate relevant portions of IPC block
// ---------------------------------------------------------------------------
static HRESULT InitializeIPCManager(void)
{
        HRESULT hr = S_OK;
        HINSTANCE hInstIPCBlockOwner = 0;

        DWORD pid = 0;
        // Allocate the Implementation. Everyone else will work through the interface
        g_pIPCManagerInterface = new (nothrow) IPCWriterInterface();

        if (g_pIPCManagerInterface == NULL)
        {
                hr = E_OUTOFMEMORY;
                goto errExit;
        }

        pid = GetCurrentProcessId();


        // Do general init
        hr = g_pIPCManagerInterface->Init();

        if (!SUCCEEDED(hr)) 
        {
                goto errExit;
        }

        // Generate IPCBlock for our PID. Note that for the other side of the debugger,
        // they'll hook up to the debuggee's pid (and not their own). So we still
        // have to pass the PID in.
        hr = g_pIPCManagerInterface->CreatePrivateBlockOnPid(pid, FALSE, &hInstIPCBlockOwner);
        
        if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS)) 
        {
                // We failed to create the IPC block because it has already been created. This means that 
                // two mscoree's have been loaded into the process.
                WCHAR strFirstModule[256];
                WCHAR strSecondModule[256];

                // Get the name and path of the first loaded MSCOREE.DLL.
                if (!hInstIPCBlockOwner || !WszGetModuleFileName(hInstIPCBlockOwner, strFirstModule, 256))
                        wcscpy(strFirstModule, L"<Unknown>");

                // Get the name and path of the second loaded MSCOREE.DLL.
                if (!WszGetModuleFileName(g_pMSCorEE, strSecondModule, 256))
                        wcscpy(strSecondModule, L"<Unknown>");

                // Load the format strings for the title and the message body.
                CorMessageBox(NULL, IDS_EE_TWO_LOADED_MSCOREE_MSG, IDS_EE_TWO_LOADED_MSCOREE_TITLE, MB_ICONSTOP, TRUE, strFirstModule, strSecondModule);
                goto errExit;
        }

errExit:
        // If any failure, shut everything down.
        if (!SUCCEEDED(hr)) 
            TerminateIPCManager();

        return hr;

}

// ---------------------------------------------------------------------------
// Terminate all InterProcess operations
// ---------------------------------------------------------------------------
static void TerminateIPCManager(void)
{
    if (g_pIPCManagerInterface != NULL)
    {
        g_pIPCManagerInterface->Terminate();

        delete g_pIPCManagerInterface;
        g_pIPCManagerInterface = NULL;
    }
}
// ---------------------------------------------------------------------------
// Impl for LoadStringRC Callback: In VM, we let the thread decide culture
// copy culture name into szBuffer and return length
// ---------------------------------------------------------------------------
static int GetThreadUICultureName(LPWSTR szBuffer, int length)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Thread * pThread = GetThread();

    if (pThread == NULL) {
        _ASSERT(length > 0);
        szBuffer[0] = 0;
        return 0;
    }

    return pThread->GetCultureName(szBuffer, length, TRUE);
}

// ---------------------------------------------------------------------------
// Impl for LoadStringRC Callback: In VM, we let the thread decide culture
// copy culture name into szBuffer and return length
// ---------------------------------------------------------------------------
static int GetThreadUICultureParentName(LPWSTR szBuffer, int length)
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Thread * pThread = GetThread();

    if (pThread == NULL) {
        _ASSERT(length > 0);
        szBuffer[0] = 0;
        return 0;
    }

    return pThread->GetParentCultureName(szBuffer, length, TRUE);
}


// ---------------------------------------------------------------------------
// Impl for LoadStringRC Callback: In VM, we let the thread decide culture
// Return an int uniquely describing which language this thread is using for ui.
// ---------------------------------------------------------------------------
static int GetThreadUICultureId()
{
    CANNOTTHROWCOMPLUSEXCEPTION();

    Thread * pThread = GetThread();

    if (pThread == NULL) {
        return UICULTUREID_DONTCARE;
    }

    return pThread->GetCultureId(TRUE);
}

// ---------------------------------------------------------------------------
// If requested, notify service of runtime startup
// ---------------------------------------------------------------------------
static HRESULT NotifyService()
{
    HRESULT hr = S_OK;
    ServiceIPCControlBlock *pIPCBlock = g_pIPCManagerInterface->GetServiceBlock();
    _ASSERTE(pIPCBlock);

    if (pIPCBlock->bNotifyService)
    {
        // Used for building terminal server names
        WCHAR wszSharedMemBlockName[256];

        // Attempt to create the service's shared memory block.
        //
        // PERF: We are no longer calling GetSystemMetrics in an effort to prevent
        //       superfluous DLL loading on startup.  Instead, we're prepending
        //       "Global\" to named kernel objects if we are on NT5 or above.  The
        //       only bad thing that results from this is that you can't debug
        //       cross-session on NT4.  Big bloody deal.
        if (RunningOnWinNT5())
            wcscpy(wszSharedMemBlockName, L"Global\\" SERVICE_MAPPED_MEMORY_NAME);
        else
            wcscpy(wszSharedMemBlockName, SERVICE_MAPPED_MEMORY_NAME);

        // Open the service's shared memory block
        HANDLE hEventBlock = WszOpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE,
                                                FALSE, wszSharedMemBlockName);
        _ASSERTE(hEventBlock != NULL);

        // Fail gracefully, since this should not bring the entire runtime down
        if (hEventBlock == NULL)
            return (S_FALSE);

        // Get a pointer valid in this process
        ServiceEventBlock *pEventBlock = (ServiceEventBlock *) MapViewOfFile(
            hEventBlock, FILE_MAP_ALL_ACCESS, 0, 0, 0);
        _ASSERTE(pEventBlock != NULL);

        // Check for error
        if (pEventBlock == NULL)
        {
            DWORD res = GetLastError();
            CloseHandle(hEventBlock);
            return (S_FALSE);
        }

        // Get a handle for the service process, dup handle access
        HANDLE hSvcProc = OpenProcess(PROCESS_DUP_HANDLE, FALSE,
                                      pEventBlock->dwServiceProcId);
        _ASSERTE(hSvcProc != NULL);

        // Check for error
        if (hSvcProc == NULL)
        {
            UnmapViewOfFile(pEventBlock);
            CloseHandle(hEventBlock);
            return (S_FALSE);
        }

        // Handle to this process
        HANDLE hThisProc = GetCurrentProcess();
        _ASSERTE(hThisProc != NULL);

        // Duplicate the service lock into this process
        HANDLE hSvcLock;
        BOOL bSvcLock = DuplicateHandle(hSvcProc, pEventBlock->hSvcLock,
                                        hThisProc, &hSvcLock, 0, FALSE,
                                        DUPLICATE_SAME_ACCESS);
        _ASSERTE(bSvcLock);

        // Check for error
        if (!bSvcLock)
        {
            UnmapViewOfFile(pEventBlock);
            CloseHandle(hEventBlock);
            CloseHandle(hSvcProc);
            CloseHandle(hThisProc);
            return (S_FALSE);
        }

        // Duplicate the service lock into this process
        HANDLE hFreeEventSem;
        BOOL bFreeEventSem =
            DuplicateHandle(hSvcProc, pEventBlock->hFreeEventSem, hThisProc,
                            &hFreeEventSem, 0, FALSE, DUPLICATE_SAME_ACCESS);
        _ASSERTE(bFreeEventSem);

        // Check for error
        if (!bFreeEventSem)
        {
            CloseHandle(hSvcLock);
            UnmapViewOfFile(pEventBlock);
            CloseHandle(hEventBlock);
            CloseHandle(hSvcProc);
            CloseHandle(hThisProc);
            return (S_FALSE);
        }

        // Create the event for continuing
        HANDLE hContEvt = WszCreateEvent(NULL, TRUE, FALSE, NULL);
        _ASSERTE(hContEvt);

        if (hContEvt == NULL)
        {
            CloseHandle(hFreeEventSem);
            CloseHandle(hSvcLock);
            UnmapViewOfFile(pEventBlock);
            CloseHandle(hEventBlock);
            CloseHandle(hSvcProc);
            CloseHandle(hThisProc);
            return (S_OK);
        }

        //
        // If the service notifies a process of this runtime starting up, and
        // that process chooses not to attach, then the service will set this
        // event and the runtime will continue.  If the notified process chooses
        // to attach, then the event is set on this end when the attach is
        // finally complete and we can continue to run.  That's the reason for
        // keeping a hold of it here and also duplicating it into the service.
        //

        // Get a count from the semaphore
        WaitForSingleObject(hFreeEventSem, INFINITE);
        CloseHandle(hFreeEventSem);

        // Grab the service lock
        WaitForSingleObject(hSvcLock, INFINITE);

        if (pIPCBlock->bNotifyService)
        {
            // Get an event from the free list
            ServiceEvent *pEvent = pEventBlock->GetFreeEvent();

            // Fill out the data
            pEvent->eventType = runtimeStarted;
            pEvent->eventData.runtimeStartedData.dwProcId = GetCurrentProcessId();
            pEvent->eventData.runtimeStartedData.hContEvt = hContEvt;

            // Notify the service of the event
            HANDLE hDataAvailEvt;
            BOOL bDataAvailEvt = DuplicateHandle(
                hSvcProc, pEventBlock->hDataAvailableEvt,hThisProc, &hDataAvailEvt,
                0, FALSE, DUPLICATE_SAME_ACCESS);
            _ASSERTE(bDataAvailEvt);

            // Check for error
            if (!bDataAvailEvt)
            {
                // Add the event back to the free list
                pEventBlock->FreeEvent(pEvent);

                // Release the lock
                ReleaseMutex(hSvcLock);

                UnmapViewOfFile(pEventBlock);
                CloseHandle(hEventBlock);
                CloseHandle(hSvcProc);
                CloseHandle(hSvcLock);
                CloseHandle(hThisProc);

                return (S_FALSE);
            }

            // Queue the event
            pEventBlock->QueueEvent(pEvent);

            // Release the lock
            ReleaseMutex(hSvcLock);

            // Indicate that the event is available
            SetEvent(hDataAvailEvt);
            CloseHandle(hDataAvailEvt);

            // Wait until the notification is received and they return.
            WaitForSingleObject(hContEvt, INFINITE);
        }
        else
        {
            // Release the lock
            ReleaseMutex(hSvcLock);
        }

        // Clean up
        UnmapViewOfFile(pEventBlock);
        CloseHandle(hEventBlock);
        CloseHandle(hSvcProc);
        CloseHandle(hThisProc);
        CloseHandle(hSvcLock);
        CloseHandle(hContEvt);
    }

    // Continue with EEStartup
    return (hr);
}

#endif // !PLATFORM_CE


// The runtime must be in the appropriate thread mode when we exit, so that we
// aren't surprised by the thread mode when our DLL_PROCESS_DETACH occurs, or when
// other DLLs call Release() on us in their detach [dangerous!], etc.
__declspec(noreturn)
void SafeExitProcess(int exitCode)
{
    Thread *pThread = (GetThreadTLSIndex() == ~0U ? NULL : GetThread());
    BOOL    bToggleGC = (pThread && pThread->PreemptiveGCDisabled());

    if (bToggleGC)
        pThread->EnablePreemptiveGC();

#ifdef PLATFORM_CE
    exit(exitCode);
#else // !PLATFORM_CE
    ::ExitProcess(exitCode);
#endif // !PLATFORM_CE
}


// ---------------------------------------------------------------------------
// Export shared logging code for JIT, et.al.
// ---------------------------------------------------------------------------
#ifdef _DEBUG

extern VOID LogAssert( LPCSTR szFile, int iLine, LPCSTR expr);
extern "C"
__declspec(dllexport)
VOID LogHelp_LogAssert( LPCSTR szFile, int iLine, LPCSTR expr)
{
    LogAssert(szFile, iLine, expr);
}

extern BOOL NoGuiOnAssert();
extern "C"
__declspec(dllexport)
BOOL LogHelp_NoGuiOnAssert()
{
    return NoGuiOnAssert();
}

extern VOID TerminateOnAssert();
extern "C"
__declspec(dllexport)
VOID LogHelp_TerminateOnAssert()
{
//  __asm int 3;
    TerminateOnAssert();

}

#else // !_DEBUG

extern "C"
__declspec(dllexport)
VOID LogHelp_LogAssert( LPCSTR szFile, int iLine, LPCSTR expr) {}


extern "C"
__declspec(dllexport)
BOOL LogHelp_NoGuiOnAssert() { return FALSE; }

extern "C"
__declspec(dllexport)
VOID LogHelp_TerminateOnAssert() {}

#endif // _DEBUG


#ifndef ENABLE_PERF_COUNTERS
//
// perf counter stubs for builds which don't have perf counter support
// These are needed because we export these functions in our DLL


Perf_Contexts* GetPrivateContextsPerfCounters()
{
    return NULL;
}

Perf_Contexts* GetGlobalContextsPerfCounters()
{
    return NULL;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cachelinealloc.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//---------------------------------------------------------------------------
// CCacheLineAllocator
//
// @doc
// @module	cachelineAlloc.h
//
//		This file defines the CacheLine Allocator class.
//
// @comm
//
//    
// <nl> Definitions.:
// <nl>	Class Name						Header file
// <nl>	---------------------------		---------------
// <nl>	<c CCacheLineAllocator>			BAlloc.h
//
// <nl><nl>
//  Notes:
//		The CacheLineAllocator maintains a pool of free CacheLines
//		
//		The CacheLine Allocator provides static member functions 
//		GetCacheLine and FreeCacheLine,
//		
// <nl><nl>
// Revision History:<nl>
//	[01] 03-11-96	rajak		Implemented <nl>
//---------------------------------------------------------------------------
#ifndef _H_CACHELINE_ALLOCATOR_
#define _H_CACHELINE_ALLOCATOR_

#include "list.h"

#pragma pack(push)
#pragma pack(1)

class CacheLine
{
public:
    enum
    {
        numEntries = 15,
        numValidBytes = numEntries*4
    };

    // store next pointer and the entries
    SLink   m_link;
    union
    {
        void*   m_pAddr[numEntries];
        BYTE    m_xxx[numValidBytes];
    };

    // init
    void Init32()
    {
        // initialize cacheline
        memset(&m_link,0,32); 
    }

    void Init64()
    {
        // initialize cacheline
        memset(&m_link,0,64); 
    }

    CacheLine()
    {
        // initialize cacheline
        memset(&m_link,0,sizeof(CacheLine)); 
    }
};
#pragma pack(pop)

typedef CacheLine* LPCacheLine;

/////////////////////////////////////////////////////////
//		class CCacheLineAllocator
//		Handles Allocation/DeAllocation of cache lines
//		used for hash table overflow buckets
///////////////////////////////////////////////////////
class CCacheLineAllocator 
{
    typedef SList<CacheLine, offsetof(CacheLine,m_link), true> REGISTRYLIST;
    typedef SList<CacheLine, offsetof(CacheLine,m_link), true> FREELIST32;
    typedef SList<CacheLine, offsetof(CacheLine,m_link), true> FREELIST64;

public:

    //constructor
    CCacheLineAllocator ();
    //destructor
    ~CCacheLineAllocator ();
   
    // free cacheline blocks
    FREELIST32         m_freeList32; //32 byte 
    FREELIST64         m_freeList64; //64 byte

    // registry for virtual free
    REGISTRYLIST     m_registryList;
    
    void *VAlloc(ULONG cbSize);

    void VFree(void* pv);

	// GetCacheLine, 
	void *	GetCacheLine32();
    
    // GetCacheLine, 
	void *	GetCacheLine64();

	// FreeCacheLine, 
	void FreeCacheLine32(void *pCacheLine);

	// FreeCacheLine, 
	void FreeCacheLine64(void *pCacheLine);

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cgensys.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENSYS.H -
//
// Generic header for choosing system-dependent helpers
//
// 

#ifndef __cgensys_h__
#define __cgensys_h__

class MethodDesc;
class Stub;
class PrestubMethodFrame;
class Thread;
class NDirectMethodFrame;
class ComPlusMethodFrame;
class CallSig;
class IFrameState;
class CrawlFrame;
struct EE_ILEXCEPTION_CLAUSE;

#include <cgencpu.h>

void ResumeAtJit(PCONTEXT pContext, LPVOID oldFP);
void ResumeAtJitEH   (CrawlFrame* pCf, BYTE* startPC, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, Thread *pThread, BOOL unwindStack);
int  CallJitEHFilter (CrawlFrame* pCf, BYTE* startPC, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel, OBJECTREF thrownObj);
void CallJitEHFinally(CrawlFrame* pCf, BYTE* startPC, EE_ILEXCEPTION_CLAUSE *EHClausePtr, DWORD nestingLevel);

// Trivial wrapper designed to get around VC's restrictions regarding
// COMPLUS_TRY & object unwinding.
inline CPUSTUBLINKER *NewCPUSTUBLINKER()
{
    return new CPUSTUBLINKER();
}

// Try to determine the L2 cache size of the machine - return 0 if unknown or no L2 cache
size_t GetL2CacheSize();



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\ceemain.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CEEMAIN.H
// 

// CEEMAIN.H defines the entrypoints into the Virtual Execution Engine and
// gets the load/run process going.
// ===========================================================================
#ifndef CEEMain_H 
#define CEEMain_H

#include <wtypes.h> // for HFILE, HANDLE, HMODULE

// IMPORTANT - The entrypoints for CE are different and a different parameter set.
#ifdef PLATFORM_CE

// This is a placeholder for getting going while there are still holes in the execution method.
STDMETHODCALLTYPE ExecuteEXE(HMODULE hMod,LPWSTR lpCmdLine,int nCmdShow,DWORD dwRva14);
BOOL STDMETHODCALLTYPE ExecuteDLL(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved, LPVOID pDllBase, DWORD dwRva14);

#else // !PLATFORM_CE- Desktop entrypoints

// This is a placeholder for getting going while there are still holes in the execution method.
BOOL STDMETHODCALLTYPE ExecuteEXE(HMODULE hMod);
BOOL STDMETHODCALLTYPE ExecuteDLL(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);

#endif // !PLATFORM_CE

// Force shutdown of the EE
void ForceEEShutdown();

// Internal replacement for OS ::ExitProcess()
__declspec(noreturn)
void SafeExitProcess(int exitCode);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cgenshx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENSHX.H -
//
// Various helper routines for generating alpha assembly code.
//
// 

#ifndef _SH3_
#error Should only include cgenshx.h for SHx builds
#endif


#ifndef _CGENSHX_H_
#define _CGENSHX_H_

#include "stublink.h"

// default return value type
typedef INT32 PlatformDefaultReturnType;

// Implemented in STUBSHX.SRC
extern "C" void __cdecl PreStubTemplate(void);
// BUGBUG--ARULM: We're not correctly supporting 64-bit return values yet!! TODO--ARULM
extern "C" INT32 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, UINT32 numArgSlots, PCCOR_SIGNATURE pSig, 
                                               Module *pmodule, const BYTE  *pArgsEnd, BOOL fIsStatic);
extern "C" INT32 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall);
#ifdef DEBUG
extern "C" void __stdcall WrapCall(void *target);
#endif

// Implemented in CGENSHX.CPP
extern "C" void CopyPreStubTemplate(Stub *preStub);

// Non-CPU-specific helper functions called by the CPU-dependent code in STUBSHX.SRC
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic, PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst);
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);

// Non-CPU-specific helper functions called by the CPU-dependent code generated by CGENSHX.CPP
// BUGBUG--ARULM: We're not correctly supporting 64-bit return values yet!! TODO--ARULM
extern "C" INT32 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame);
extern "C" INT32 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame);
VOID OnStubObjectTripThread();
VOID OnStubScalarTripThread();

// required alignment for data
#define DATA_ALIGNMENT 4

inline void getFPReturn(BYTE rt, INT64 retval)
{
    // @TODO SH4 (SH3 doesn't need anything)
}
inline void getFPReturnSmall(INT32 *retval)
{
    // @TODO SH4 (SH3 doesn't need anything)
}
inline void setFPReturn(BYTE rt, INT64 retVal)
{
    // @TODO SH4 (SH3 doesn't need anything)
}

class StubLinkerSHX : public StubLinker
{
  public:
    VOID SHXEmitCurrentThreadFetch();   
    VOID EmitMethodStubProlog(LPVOID pFrameVptr);
    VOID EmitECallMethodStub(__int16 numargbytes, StubStyle style); 
    void CreateNDirectOrComPlusStubBody(LPVOID pfnHelper, BOOL fRequiresCleanup);   
    VOID EmitMethodStubEpilog(__int16 numargbytes, StubStyle style, 
                              __int16 shadowStackArgBytes = 0);


    //===========================================================================
    // Emits code to adjust for a static delegate target.
    VOID EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray)
    {
        //@todo: implement.
    }


    //===========================================================================
    // Emits code for MulticastDelegate.Invoke()
    VOID EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat)
    {
        //@todo: implement.
    }
};

//----------------------------------------------------------------------
// Method Stub and Align Defines....
//----------------------------------------------------------------------
//
// The StubCall we insert at the starts of each Function Desc consists of
//      MOV.L   @(4, PC), R1    ; load stub address from just below 
//      MOVA    @(8, PC), R0    ; move MethodDesc address to R0 for stub    
//      JMP     @R1             ; jump to it (don't call or we'll trash PR) 
//      NOP                     ; branch delay & also dword-align   
//      .data.l <stub address>  ; 4-byte stub absolute address  

struct StubCallInstrs {
    WORD    mov1;   
    WORD    mov2;   
    WORD    jmp;    
    WORD    nop;    
    DWORD   stubaddr;   
};

#define METHOD_CALL_PRESTUB_SIZE    sizeof(StubCallInstrs) 
#define METHOD_PREPAD               METHOD_CALL_PRESTUB_SIZE   // # extra bytes to allocate in addition to sizeof(Method)
#define METHOD_ALIGN                1 // required alignment for StubCallInstrs


//**********************************************************************
// Parameter size
//**********************************************************************

#define NATIVE_STACK_ELEM_SIZE      4   

typedef INT32 StackElemType;
#define STACK_ELEM_SIZE sizeof(StackElemType)

void SetupSlotToAddrMap(StackElemType *psrc, const void **pArgSlotToAddrMap, CallSig &callSig);

// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

// Get address of actual arg within widened arg
#define ArgTypeAddr(stack, type)      ((type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))    

// Get value of actual arg within widened arg
#define ExtractArg(stack, type)   (*(type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))   

#define CEE_PARM_SIZE(size) (max(size), sizeof(INT32))
#define CEE_SLOT_COUNT(size) ((max(size), sizeof(INT32))/INT32)

#define DECLARE_ECALL_DEFAULT_ARG(vartype, varname)   \
    vartype varname;    

#define DECLARE_ECALL_OBJECTREF_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_PTR_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_I1_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I2_ARG(vartype, varname)   \
    vartype varname;    

#define DECLARE_ECALL_I4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_R4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_I8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    

#define DECLARE_ECALL_R8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);    


//**********************************************************************
// Frames
//**********************************************************************

//--------------------------------------------------------------------
// This represents the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
// SHx saves 7 registers
    INT32       reg1;
    INT32       reg2;
    INT32       reg3;
    INT32       reg4;
    INT64       reg5;
    INT64       reg6;
    INT64       reg7;
};

#define ARGUMENTREGISTERS_SIZE 0


#define PLATFORM_FRAME_ALIGN(val) (val)

#define VC5FRAME_SIZE   0   


#define DECLARE_PLATFORM_FRAME_INFO \
    UINT32      m_eip;              \
    UINT32      m_esp;              \
    UINT32 *getIPSaveAddr() {       \
        return &m_eip;              \
    }                               \
    UINT32 *getSPSaveAddr() {       \
        return &m_esp;              \
    }                               \
    UINT32 getIPSaveVal() {         \
        return m_eip;               \
    }                               \
    UINT32 getSPSaveVal() {         \
        return m_esp;               \
    }   

//**********************************************************************
// Exception handling
//**********************************************************************

inline LPVOID GetIP(CONTEXT *context) {
    return (LPVOID)(context->Fir);
}

inline void SetIP(CONTEXT *context, LPVOID eip) {
    context->Fir = (UINT32)eip;
}

inline LPVOID GetSP(CONTEXT *context) {
    _ASSERTE(!"nyi");
}

inline BYTE *getStubCallAddr(MethodDesc *fd) {
    return ((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE;
}

inline const BYTE *getStubAddr(MethodDesc *fd) {
    // The stub address is located in the last DWORD before the the MethodDesc  
    // Note on SHX this is now an *absolute* address    
    return (LPBYTE) (*(((DWORD*)fd)-1));
}

inline UINT32 getStubDisp(MethodDesc *fd) {
    return getStubAddr(fd) - (const BYTE*)fd;
}

inline UINT32 setStubAddrInterlocked(MethodDesc *pFD, UINT32 stubAddr) {
    // The offset must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE( 0 == (((UINT32)pFD) & 3) );
    // The stub address is located in the last DWORD before the the MethodDesc  
    // Note on SHX this is now an *absolute* address    
    return InterlockedExchange((PLONG)(((DWORD*)pFD)-1), stubAddr);
}

inline Stub *setStubCallPointInterlocked(MethodDesc *pFD, Stub *pStub) {
    BYTE *prevAddr = (BYTE *) setStubAddrInterlocked(pFD, (UINT32)pStub->GetEntryPoint());    
    return Stub::RecoverStub(prevAddr);
}

inline void emitStubCall(MethodDesc *pFD, BYTE *stubAddr) {
    WORD *target = (WORD*)getStubCallAddr(pFD);
    _ASSERTE(0 == (((UINT32)pFD) & 3));
    _ASSERTE(0 == (((UINT32)target) & 3));
    target[0] = 0xD101; // MOV.L @(4, PC), R1   ; load stub address from just below 
    target[1] = 0xC702; // MOVA  @(8, PC), R0   ; move MethodDesc address to R0 for stub    
    target[2] = 0x412B; // JMP   @R1            ; jump to it (don't call or we'll trash PR) 
    target[3] = 0x0009; // NOP                  ; branch delay & also dword-align   
    setStubAddrInterlocked(pFD, stubAddr);  
}



inline void emitCall(LPBYTE pBuffer, LPVOID target)
{
    _ASSERTE(!"NYI");
}

inline LPVOID getCallTarget(const BYTE *pCall)
{
    _ASSERTE(!"NYI");
    return NULL;
}


// Used for Marshalling Language (RunML function)

typedef INT32 SignedParmSourceType;
typedef UINT32 UnsignedParmSourceType;
typedef float FloatParmSourceType;
typedef double DoubleParmSourceType;
typedef INT32 SignedI1TargetType;
typedef UINT32 UnsignedI1TargetType;
typedef INT32 SignedI2TargetType;
typedef UINT32 UnsignedI2TargetType;
typedef INT32 SignedI4TargetType;
typedef UINT32 UnsignedI4TargetType;



#define PTRDST(type)            ((type*)( ((BYTE*&)pdst) -= sizeof(LPVOID) ))

#define STDST(type,val)         (*((type*)( ((BYTE*&)pdst) -= sizeof(type) )) = (val))


#define STPTRDST(type, val) STDST(type, val)    
#define LDSTR4()                STDST(UINT32, (UINT32)LDSRC(UnsignedParmSourceType))    
#define LDSTR8()                STDST(UNALIGNED UINT64, LDSRC(UNALIGNED UINT64))    


inline MLParmSize(int parmSize)
{
    return ((parmSize + sizeof(INT32) - 1) & ~((ULONG)(sizeof(INT32) - 1)));
}


// Routines used by debugger support functions such as codepatch.cpp or
// exception handling code.
//

inline unsigned short CORDbgGetInstruction(const unsigned char* address)
{
    // SHX instructions are all 2-bytes
    return *((unsigned short*)address);
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
    // insert: trapa #00000001
    *(unsigned short *) (address) = 0xC301;
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 unsigned short instruction)
{
    // SHX instructions are all 2-bytes
    *((unsigned short*)address) = instruction;
}

inline void CORDbgAdjustPCForBreakInstruction(CONTEXT* pContext)
{
    // @todo: implement for SHX. This may be a no-op on SHX.
}

#define CORDbg_BREAK_INSTRUCTION_SIZE 2


// Some platform-specific stuff in support of the "Contexts" feature:
//
// When we generate thunks for CtxProxy VTables, they look something like:
//
//  MOV.L   @(, PC), R1 ; load address of CtxProxy::HandleCall from just below  
//  MOV.W   @(, PC), R0 ; load slot number from below that  
//  JMP     @R1         ; jump to it    
//  NOP                 ; delay slot & dword align  
//  .data.  <CtxProxy::HandleCall>  ; absolute address of CtxProxy::HandleCall  
//  .data.l <slot number>   ; 4-byte stub absolute address  
//
// Total is (unfortunately) 16 bytes

#define ThunkChunk_ThunkSize    16      // size of the above code.


// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps();


VOID __cdecl RareDisableHelper(Thread *pThread)
{
    _ASSERTE(!"NYI");
}

inline BOOL IsUnmanagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}

inline BOOL IsManagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}



#endif _CGENSHX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cgenalpha.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENALPHA.H -
//
// Various helper routines for generating alpha assembly code.
//
// DO NOT INCLUDE THIS FILE DIRECTLY - ALWAYS USE CGENSYS.H INSTEAD
//

#ifndef _ALPHA_
#error Should only include cgenalpha for ALPHA builds
#endif

#ifndef __cgenalpha_h__
#define __cgenalpha_h__

#include <alphaops.h>
#include "stublink.h"

// FCALL is the norm on this platform (everything is passed in
// registers and not on the stack)
#define FCALLAVAILABLE 1

// required alignment for data
#define DATA_ALIGNMENT 8

// default return value type
typedef INT64 PlatformDefaultReturnType;

void  emitStubCall(MethodDesc *pFD, BYTE *stubAddr);
Stub *setStubCallPointInterlocked(MethodDesc *pFD, Stub *pStub, Stub *pExpectedStub);

inline void emitCall(LPBYTE pBuffer, LPVOID target)
{
    _ASSERTE(!"@TODO Alpha - emitCall (cGenAlpha.h)");
}

inline LPVOID getCallTarget(const BYTE *pCall)
{
    _ASSERTE(!"@TODO Alpha - getCallTarget (cGenAlpha.h)");
    return NULL;
}

inline void emitJump(LPBYTE pBuffer, LPVOID target)
{
    _ASSERTE(!"@TOTO Alpha - emitJump (cGenAlpha.h)");
}

inline void updateJumpTarget(LPBYTE pBuffer, LPVOID target)
{
    _ASSERTE(!"@TOTO Alpha - updateJumpTarget (cGenAlpha.h)");
}

inline LPVOID getJumpTarget(const BYTE *pJump)
{
    _ASSERTE(!"@TODO Alpha - getJumpTarget (cGenAlpha.h)");
    return NULL;
}

inline UINT32 setStubAddrInterlocked(MethodDesc *pFD, UINT32 stubAddr, 
									 UINT32 expectedStubAddr)
{
	SIZE_T result = (SIZE_T)
	  FastInterlockCompareExchange((void **)(((long*)pFD)-1), 
								   (void *)(stubAddr - (UINT32)pFD), 
								   (void *)(expectedStubAddr - (UINT32)pFD)) 
	  + (UINT32)pFD;

	// result is the previous value of the stub - 
	// instead return the current value of the stub

	if (result == expectedStubAddr)
		return stubAddr;
	else
		return result;
}

class MethodDesc;

// CPU-dependent functions
extern "C" void __cdecl PreStubTemplate(void);
extern "C" INT64 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, UINT32 numArgSlots, PCCOR_SIGNATURE pSig,
                                               Module *pmodule, const BYTE  *pArgsEnd, BOOL fIsStatic);
extern "C" INT64 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall);
extern "C" void __stdcall WrapCall(void *target);
extern "C" void CopyPreStubTemplate(Stub *preStub);
// Non-CPU-specific helper functions called by the CPU-dependent code
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic, PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst);
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);
extern "C" INT64 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame);
extern "C" INT64 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame);

extern "C" DWORD __stdcall GetSpecificCpuType();

extern "C" void setFPReturn(int fpSize, INT64 retVal);
extern "C" void getFPReturn(int fpSize, INT64 &retval);
extern "C" void getFPReturnSmall(INT32 *retval);


//**********************************************************************
// Parameter size
//**********************************************************************

typedef UINT64 NativeStackElem;
typedef UINT64 StackElemType;

#define STACK_ELEM_SIZE  sizeof(StackElemType)
#define NATIVE_STACK_ELEM_SIZE sizeof(StackElemType)

// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

void SetupSlotToAddrMap(StackElemType *psrc, const void **pArgSlotToAddrMap, CallSig &callSig);

// Get address of actual arg within widened arg
#define ArgTypeAddr(stack, type)      ((type *) (stack))

// Get value of actual arg within widened arg
#define ExtractArg(stack, type)   (*(type *) (stack))

#define CEE_PARM_SIZE(size) (max(size), sizeof(INT64))
#define CEE_SLOT_COUNT(size) ((max(size), sizeof(INT64))/INT64)

#define DECLARE_ECALL_DEFAULT_ARG(vartype, varname)		\
    vartype varname;									\
	INT32 fill_##varname;

#define DECLARE_ECALL_OBJECTREF_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_PTR_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I1_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I2_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I8_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_R8_ARG(vartype, varname)   \
    vartype varname;

//**********************************************************************
// Frames
//**********************************************************************

//--------------------------------------------------------------------
// This represents the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
    INT64       reg1;
    INT64       reg2;
    INT64       reg3;
    INT64       reg4;
    INT64       reg5;
    INT64       reg6;
};

//--------------------------------------------------------------------
// This represents the arguments that are stored in volatile registers.
// This should not overlap the CalleeSavedRegisters since those are already
// saved separately and it would be wasteful to save the same register twice.
// If we do use a non-volatile register as an argument, then the ArgIterator
// will probably have to communicate this back to the PromoteCallerStack
// routine to avoid a double promotion.
//
// @todo M6: It's silly for a method that has <N arguments to save N
// registers. A good perf item would be for the frame to save only
// the registers it actually needs. This means that NegSpaceSize()
// becomes a function of the callsig.
//--------------------------------------------------------------------
struct ArgumentRegisters {

#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  INT32  m_##regname;
#include "eecallconv.h"

};

#define ARGUMENTREGISTERS_SIZE sizeof(ArgumentRegisters)
#define NUM_ARGUMENT_REGISTERS 0

#define PLATFORM_FRAME_ALIGN(val) (((val) + 15) & ~15)

#define VC5FRAME_SIZE   0


#define DECLARE_PLATFORM_FRAME_INFO \
    UINT64      m_fir;              \
    UINT64      m_sp;               \
    UINT64 *getIPSaveAddr() {       \
        return &m_fir;              \
    }                               \
    UINT64 *getSPSaveAddr() {       \
        return &m_sp;               \
    }                               \
    UINT64 getIPSaveVal() {         \
        return m_fir;               \
    }                               \
    UINT64 getSPSaveVal() {         \
        return m_sp;                \
    }

//**********************************************************************
// Exception handling
//**********************************************************************

inline LPVOID GetIP(CONTEXT *context) {
    return (LPVOID)(context->Fir);
}

inline void SetIP(CONTEXT *context, LPVOID eip) {
    context->Fir = (UINT64)eip;
}

inline LPVOID GetSP(CONTEXT *context) {
    _ASSERTE(!"NYI");
}

//----------------------------------------------------------------------
// Encodes Alpha registers. The numbers are chosen to match the opcode
// encoding.
//----------------------------------------------------------------------
enum AlphaReg {
    // used for expression evaluations and to hold the integer function results. Not preserved across procedure calls.
    iV0 = 0,

    // Temporary registers used for expression evaluations. Not preserved across procedure calls.
    iT0 = 1,
    iT1 = 2,
    iT2 = 3,
    iT3 = 4,
    iT4 = 5,
    ik5 = 6,
    iT6 = 7,
    iT7 = 8,

    // Saved registers. Preserved across procedure calls.
    iS0 = 9,
    iS1 = 10,
    iS2 = 11,
    iS3 = 12,
    iS4 = 13,
    iS5 = 14,

    // Contains the frame pointer (if needed); otherwise, a saved register.
    iFP = 15,

    // Used to pass the first six integer type actual arguments. Not preserved across procedure calls.
    iA0 = 16,
    iA1 = 17,
    iA2 = 18,
    iA3 = 19,
    iA4 = 20,
    iA5 = 21,

    // Temporary registers used for expression evaluations. Not preserved across procedure calls.
    iT8 = 22,
    iT9 = 23,
    iT10 = 24,
    iT11 = 25,

    // Contains the return address. Preserved across procedure calls.
    iRA = 26,

    // Contains the procedure value and used for expression evaluation. Not preserved across procedure calls.
    iPV = 27,

    // Reserved for the assembler. Not preserved across procedure calls.
    iAT = 28,

    // Contains the global pointer for compiler-generated code. Not preserved across procedure calls.Note:  Register $gp should not be altered. For more information, refer to the Windows NT for Alpha AXP Calling Standard.
    iGP = 29,

    // Contains the stack pointer. Preserved across procedure calls.
    iSP = 30,

    // Always has the value 0.
    iZero = 31
};

enum AlphaInstruction {
    opJSR   = 0x1A,
    opLDA   = 0x08,
    opLDAH  = 0x09,
    opLDL   = 0x28,
    opLDQ   = 0x29,
    opSTL   = 0x2C,
    opSTQ   = 0x2D,
    opBSR   = 0x34,
};

const DWORD opMask =        0xFC000000;
const DWORD raMask =        0x03E00000;
const DWORD rbMask =        0x001F0000;
const DWORD dispMaskMem =   0x0000FFFF;
const DWORD dispMaskBr =    0x001FFFFF;

#define ALPHA_MEM_INST(op, Ra, Rb, disp) ((op << 26) | ( (Ra << 21) & raMask) | ( (Rb << 16) & rbMask) | (disp & dispMaskMem))
#define ALPHA_BR_INST(op, Ra, disp) ((op << 26) | ( (Ra << 21) & raMask) | ((disp/4) & dispMaskBr))

class StubLinkerAlpha : public StubLinker
{
  public:
    VOID EmitUnboxMethodStub(MethodDesc* pRealMD);
    //----------------------------------------------------------------
    //
    // VOID EmitSharedMethodStubEpilog(StubStyle style,
    //                                             unsigned offsetRetThunk)
    //      shared epilog, uses a return thunk within the methoddesc
    //--------------------------------------------------------------------
    VOID EmitSharedMethodStubEpilog(StubStyle style,
                                    unsigned offsetRetThunk);
    VOID EmitSecurityWrapperStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub);
    VOID EmitSecurityInterceptorStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub);

// @TODO:	Check to see which ones of these need to be public.
//			Most of them are probably private...
    VOID Emit32Swap(UINT32 val);
    VOID AlphaEmitLoadRegWith32(AlphaReg Ra, UINT32 imm32);
    VOID AlphaEmitStorePtr(AlphaReg Ra, AlphaReg Rb, INT16 imm16);
    VOID AlphaEmitStoreReg(AlphaReg Ra, AlphaReg Rb, INT16 imm16);
    VOID AlphaEmitLoadPtr(AlphaReg Ra, AlphaReg Rb, INT16 imm16);
    VOID AlphaEmitMemoryInstruction(AlphaInstruction op, AlphaReg Ra, AlphaReg Rb, INT16 imm16);

    VOID AlphaEmitLoadPV(CodeLabel *target);
    VOID EmitMethodStubProlog(LPVOID pFrameVptr);
    VOID EmitMethodStubEpilog(__int16 numArgBytes, StubStyle style,
                              __int16 shadowStackArgBytes = 0);

    //===========================================================================
    // Emits code to adjust for a static delegate target.
    VOID EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray)
    {
        //@todo: implement.
        _ASSERTE(!"@TODO Alpha - EmitShuffleThunk (cGenAlpha.h)");
    }

    //===========================================================================
    // Emits code for MulticastDelegate.Invoke()
    VOID EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat)
    {
        //@todo: implement.
        _ASSERTE(!"@TODO Alpha - EmitMulticastInvoke (cGenAlpha.h)");
    }

    //===========================================================================
    // Emits code to do an array operation.
    VOID EmitArrayOpStub(const struct ArrayOpScript *pArrayOpScript)
    {
        //@todo: implement.
        _ASSERTE(!"@TODO Alpha - EmitArrayOpStub (cGenAlpha.h)");
    }
};

inline VOID StubLinkerAlpha::AlphaEmitStorePtr(AlphaReg Ra, AlphaReg Rb, INT16 imm16) {
    // only store a pointer size, not int64, for ops where we depend on that size, such as the Frame structure
    AlphaEmitMemoryInstruction(sizeof(INT_PTR) == sizeof(INT64) ? opSTQ : opSTL, Ra, Rb, imm16);
}

inline VOID StubLinkerAlpha::AlphaEmitStoreReg(AlphaReg Ra, AlphaReg Rb, INT16 imm16) {
    AlphaEmitMemoryInstruction(opSTQ, Ra, Rb, imm16);
}

inline VOID StubLinkerAlpha::AlphaEmitLoadPtr(AlphaReg Ra, AlphaReg Rb, INT16 imm16) {
    // only load a pointer size, not int64, for ops where we depend on that size, such as the Frame structure
    AlphaEmitMemoryInstruction(sizeof(INT_PTR) == sizeof(INT64) ? opLDQ : opLDL, Ra, Rb, imm16);
}

//----------------------------------------------------------------------
// Method Stub and Align Defines....
//----------------------------------------------------------------------

// We are dealing with three DWORD instructions of the following form:
//      LDAH    t12,addr(zero)
//      LDA     t12,addr(t12)
//      JSR     ra, t12
//
// The first instruction contains the high (16-bit) half of target address
// and the second contains the low half.

struct CallStubInstrs {
    INT16 high;         // declare as signed so get sign-extension
    UINT16 ldah;
    INT16 low;          // declare as signed so get sign-extension
    UINT16 lda;
    DWORD branch;
};

#define METHOD_CALL_PRESTUB_SIZE    sizeof(CallStubInstrs)
#define METHOD_ALIGN_PAD            8                          // # extra bytes to allocate in addition to sizeof(Method)
#define METHOD_PREPAD               METHOD_CALL_PRESTUB_SIZE   // # extra bytes to allocate in addition to sizeof(Method)
#define JUMP_ALLOCATE_SIZE          METHOD_CALL_PRESTUB_SIZE   // # extra bytes to allocate in addition to sizeof(Method)

inline BYTE *getStubCallAddr(MethodDesc *fd) {
    return ((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE;
}

inline BYTE *getStubCallTargetAddr(MethodDesc *fd) {
    return (BYTE*)(*((UINT32*)(fd) - 1) + (UINT32)fd);
}

inline void setStubCallTargetAddr(MethodDesc *fd, const BYTE *addr) {
    FastInterlockExchange((LONG*)fd - 1, (UINT32)addr - (UINT32)fd);
}

inline BYTE *getStubCallAddr(BYTE *pBuf) {
    return ((BYTE*)pBuf) + 3;   // have allocate 8 bytes, so go in 3 to find call instr point
}

inline BYTE *getStubJumpAddr(BYTE *pBuf) {
    return ((BYTE*)pBuf) + 3;   // have allocate 8 bytes, so go in 3 to find jmp instr point
}

inline const BYTE *getStubAddr(MethodDesc *fd) {
    CallStubInstrs *inst = (CallStubInstrs*)(((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE);
    return (const BYTE*)( (((INT32)inst->high) << 16) + (INT32)inst->low);
}

inline UINT32 getStubDisp(MethodDesc *fd) {
    return getStubAddr(fd) - (const BYTE*)fd;
}

//----------------------------------------------------------
// Used for Marshalling Language (RunML function)
//----------------------------------------------------------

typedef INT64 SignedParmSourceType;
typedef UINT64 UnsignedParmSourceType;
typedef double FloatParmSourceType;
typedef double DoubleParmSourceType;
typedef INT64 SignedI1TargetType;
typedef UINT64 UnsignedI1TargetType;
typedef INT64 SignedI2TargetType;
typedef UINT64 UnsignedI2TargetType;
typedef INT64 SignedI4TargetType;
typedef UINT64 UnsignedI4TargetType;

#define HANDLE_NDIRECT_NUMERIC_PARMS \
        case ELEMENT_TYPE_I1:     \
        case ELEMENT_TYPE_I2:     \
        case ELEMENT_TYPE_I4:  \
        case ELEMENT_TYPE_CHAR:     \
        case ELEMENT_TYPE_BOOLEAN:     \
        IN_WIN32(case ELEMENT_TYPE_I:)                 \
            psl->MLEmit(ML_COPYI4);  \
            pheader->m_cbDstBuffer += MLParmSize(4);  \
            break;  \
  \
        case ELEMENT_TYPE_U1:    \
        case ELEMENT_TYPE_U2:     \
        case ELEMENT_TYPE_U4:  \
        IN_WIN32(case ELEMENT_TYPE_U:)                 \
            psl->MLEmit(ML_COPYU4);  \
            pheader->m_cbDstBuffer += MLParmSize(4);  \
            break;  \
  \
        IN_WIN64(case ELEMENT_TYPE_I:)                 \
        IN_WIN64(case ELEMENT_TYPE_U:)                 \
        case ELEMENT_TYPE_I8:  \
        case ELEMENT_TYPE_U8:  \
            psl->MLEmit(ML_COPY8);  \
            pheader->m_cbDstBuffer += MLParmSize(8);  \
            break;  \
  \
        case ELEMENT_TYPE_R4:     \
            psl->MLEmit(ML_COPYR4);  \
            pheader->m_cbDstBuffer += MLParmSize(4);  \
            break;  \
  \
        case ELEMENT_TYPE_R8:  \
            psl->MLEmit(ML_COPYR8);  \
            pheader->m_cbDstBuffer += MLParmSize(8);  \
            break;  \


inline MLParmSize(int parmSize)
{
    return max(sizeof(INT64), parmSize);
}

inline int MLParmSize(CorElementType mtype)
{
    return 8;
}

struct MLParmInfo {
    UINT32 numArgumentBytes;    // total number of bytes of arguments
    UINT32 curArgNum;           // current argument (left to right) that are working on - copy from right to left
    BOOL outgoing;              // whether are calling out (TRUE) or into (FALSE) the EE
};

#define DECLARE_ML_PARM_INFO(numStackArgumentBytes, outgoing) \
    MLParmInfo parmInfo = {(numStackArgumentBytes), numStackArgumentBytes/STACK_ELEM_SIZE, outgoing}, *pParmInfo = &parmInfo;


#define PTRDST(type)            (--pParmInfo->curArgNum, ((type*)( ((BYTE*&)pdst) -= sizeof(LPVOID) )))

#define STDST(type,val)         (--pParmInfo->curArgNum, (*((type*)( ((BYTE*&)pdst) -= sizeof(type) )) = (val)))


// Must zero out high bytes of the pointer destination
#define STPTRDST(type,val)  (--pParmInfo->curArgNum, \
                           *((StackElemType*)( ((BYTE*&)pdst) -= sizeof(StackElemType) )) = (0), \
                           *((type*)(pdst)) = (val))

void LdStFPWorker(int size, const void *&psrc, void *&pdst, int dstinc, int &dstbump, int *pbump, MLParmInfo *pParmInfo);
//#define LDSTR4() LdStFPWorker(4, psrc, pdst, dstinc, dstbump, pbump, pParmInfo)
//#define LDSTR8() LdStFPWorker(8, psrc, pdst, dstinc, dstbump, pbump, pParmInfo)
#define LDSTR4() _ASSERTE(!"Broken")
#define LDSTR8() _ASSERTE(!"Broken")

#define CALL_DLL_FUNCTION(pTarget, pEndArguments, pParmInfo) \
    CallDllFunction(pTarget, pEndArguments, pParmInfo->numArgumentBytes/NATIVE_STACK_ELEM_SIZE)

//
// Routines used by debugger support functions such as codepatch.cpp or
// exception handling code.
//

inline unsigned int CORDbgGetInstruction(const unsigned char* address)
{
    return *((unsigned int*)address);
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
    //
    // @todo: use correct break opcode.
    //
    //*(unsigned int *)(address) = 0x????????;
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 unsigned short instruction)
{
    *((unsigned int*)address) = instruction;
}

inline void CORDbgAdjustPCForBreakInstruction(CONTEXT* pContext)
{
    _ASSERTE(!"@TODO Alpha - CORDbgAdjustPCForBreakInstruction (CGenAlpha.h)");
}

#define CORDbg_BREAK_INSTRUCTION_SIZE 4


// Some platform-specific stuff in support of the "Contexts" feature:
//
// When we generate thunks for CtxProxy VTables, they look something like:
//
//             load     register, <slot>
//             branch   CtxProxy::HandleCall
//
// Assuming short displacements, we can do this in 8 bytes.

#define ThunkChunk_ThunkSize    8      // size of the above code.


// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps();

// SEH info forward declarations

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    LPVOID Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

struct ComToManagedExRecord; // defined in cgenx86.cpp
// one of the internal exception SEH handlers
EXCEPTION_DISPOSITION __cdecl  ComToManagedExceptHandler (
                                 PEXCEPTION_RECORD pExcepRecord,
                                  ComToManagedExRecord* pEstFrame,
                                  PCONTEXT pContext,
                                  LPVOID    pDispatcherContext);



//VOID __cdecl RareDisableHelper(Thread *pThread)
//{
//    _ASSERTE(!"@TODO Alpha - RareDisableHelper (cGenAlpha.h)");
//}


// Access to the TEB (TIB) from ntalpha.h
#ifdef _ALPHA_                          // winnt
void *_rdteb(void);                     // winnt
#if defined(_M_ALPHA)                   // winnt
#pragma intrinsic(_rdteb)               // winnt
#endif // _M_ALPHA                      // winnt
#endif // _ALPHA_                       // winnt

#if defined(_M_ALPHA)
#define NtCurrentTeb() ((struct _TEB *)_rdteb())
#else // !_M_ALPHA
struct _TEB *
NtCurrentTeb(void);
#endif // _M_ALPHA

inline BOOL IsUnmanagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}

inline BOOL IsManagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}


#endif // __cgenalpha_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\class.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CLASS.H
//
// ===========================================================================
// This file decribes the structure of the in memory class layout.
// The class will need to actually be created using CreateClass() which will
// return a EEClass*.
// ===========================================================================
#ifndef CLASS_H
#define CLASS_H


#include "vars.hpp"
#include "cor.h"
#include "codeman.h"
#include "hash.h"
#include "crst.h"
#include "stdinterfaces.h"
#include "ObjectHandle.h"
#include "cgensys.h"
#include "DeclSec.h"

#include "list.h"
#include "spinlock.h"
#include "typehandle.h"
#include "PerfCounters.h"

#include "binder.h"

#include <member-offset-info.h>

#define MAX_LOG2_PRIMITIVE_FIELD_SIZE   3

//@TODO 64bit....
#define LOG2SLOT    2

// forward declarations
class ClassLoader;
class MethodTable;
class EEClass;
class Module;
class MethodDesc;
class ECallMethodDesc;
class ArrayECallMethodDesc;
class FieldDesc;
class EnCFieldDesc;
class Stub;
class Object;
class EEClass;
struct LayoutRawFieldInfo;
class FieldMarshaler;
class MetaSig;
class ArrayClass;
class AppDomain;
class Module;
class MethodDescChunk;
struct DomainLocalClass;


#ifdef _DEBUG 
#define VALIDATE_INTERFACE_MAP(pMT) \
if (pMT->m_pIMap){ \
    InterfaceInfo_t* _pIMap_; \
    if (pMT->HasDynamicInterfaceMap()) \
        _pIMap_ = (InterfaceInfo_t*)(((BYTE *)pMT->m_pIMap) - sizeof(DWORD) - sizeof(InterfaceInfo_t)); \
    else \
        _pIMap_ = (InterfaceInfo_t*)(((BYTE *)pMT->m_pIMap) - sizeof(InterfaceInfo_t)); \
    _ASSERTE(_pIMap_->m_pMethodTable == (MethodTable *)(size_t)0xCDCDCDCD); \
    _ASSERTE(_pIMap_->m_wStartSlot == 0xCDCD); \
    _ASSERTE(_pIMap_->m_wFlags == 0xCDCD); \
} 
#else
#define VALIDATE_INTERFACE_MAP(pMT)
#endif

//============================================================================
// This is the inmemory structure of a class and it will evolve.
//============================================================================

// @TODO - LBS
// Add a sync block
// Also this class currently has everything public - this may changes
// Might also need to hold onto the meta data loader fot this class

//
// A EEClass contains an array of these structures, which describes each interface implemented
// by this class (directly declared or indirectly declared).
//
typedef struct
{
    enum {
        interface_declared_on_class = 0x1
    };

    MethodTable* m_pMethodTable;        // Method table of the interface
    WORD         m_wFlags;
    WORD         m_wStartSlot;          // starting slot of interface in vtable
} InterfaceInfo_t;

//
// This struct contains cached information on the GUID associated with a type. 
//

typedef struct
{
    GUID         m_Guid;                // The actual guid of the type.
    BOOL         m_bGeneratedFromName;  // A boolean indicating if it was generated from the 
                                        // name of the type.
} GuidInfo;

//
// A temporary structure used when loading and resolving classes
//
class LoadingEntry_t
{
public:
        // Silly helper needed so we can new this in a routine with a __try in it
    static LoadingEntry_t* newEntry() {
        return new LoadingEntry_t();
    }

    LoadingEntry_t() {
        InitializeCriticalSection(&m_CriticalSection);
        m_pClass = NULL;
        m_dwWaitCount    = 1;
        m_hrResult = E_FAIL; 
        m_ohThrowable = NULL;
    }

    ~LoadingEntry_t() {
        DeleteCriticalSection(&m_CriticalSection);
        if (m_ohThrowable != NULL)
            DestroyGlobalHandle(m_ohThrowable);
    }

    OBJECTREF GetErrorObject() {
        if (m_ohThrowable == 0)
            return(OBJECTREF((size_t)NULL));
        else
            return(ObjectFromHandle(m_ohThrowable));
    }

    void SetErrorObject(OBJECTREF obj) {
        _ASSERTE(m_ohThrowable == NULL);
        // This global handle means that only agile exceptions can be set here.
        // I think this is OK since we I believe only throw a known set of exceptions.
        m_ohThrowable = CreateGlobalHandle(NULL);
        StoreFirstObjectInHandle(m_ohThrowable, obj);
    }

    friend class ClassLoader;       // Hack really need to beef up the API above
private:
    CRITICAL_SECTION    m_CriticalSection;
    EEClass *           m_pClass;
    DWORD               m_dwWaitCount;
    HRESULT             m_hrResult;
    OBJECTHANDLE        m_ohThrowable;
};


//
// Class used to map MethodTable slot numbers to COM vtable slots numbers
// (either for calling a classic COM component or for constructing a classic COM
// vtable via which COM components can call managed classes). This structure is
// embedded in the EEClass but the mapping list itself is only allocated if the
// COM vtable is sparse.
//

class SparseVTableMap
{
public:

    SparseVTableMap();
    ~SparseVTableMap();

    void ShutDown();

    // First run through MT slots calling RecordGap wherever a gap in VT slots
    // occurs.
    BOOL RecordGap(WORD StartMTSlot, WORD NumSkipSlots);

    // Then call FinalizeMapping to create the actual mapping list.
    BOOL FinalizeMapping(WORD TotalMTSlots);

    // Map MT to VT slot.
    WORD LookupVTSlot(WORD MTSlot);

    // Retrieve the number of slots in the vtable (both empty and full).
    WORD GetNumVTableSlots();

    // Methods to persist structure
    HRESULT Save(DataImage *image, mdToken attribution);
    HRESULT Fixup(DataImage *image);

private:

    enum { MapGrow = 4 };

    struct Entry
    {
        WORD    m_Start;        // Starting MT slot number
        WORD    m_Span;         // # of consecutive slots that map linearly
        WORD    m_MapTo;        // Starting VT slot number
    };

    Entry      *m_MapList;      // Pointer to array of Entry structures
    WORD        m_MapEntries;   // Number of entries in above
    WORD        m_Allocated;    // Number of entries allocated

    WORD        m_LastUsed;     // Index of last entry used in successful lookup

    WORD        m_VTSlot;       // Current VT slot number, used during list build
    WORD        m_MTSlot;       // Current MT slot number, used during list build

    BOOL AllocOrExpand();       // Allocate or expand the mapping list for a new entry
};

//
// GC data appears before the beginning of the MethodTable
//
// Method table structure
// ======================
// GC info (variable size)
// EEClass*                 <--- MethodTable pointer points to here
// Flags (DWORD)
// Vtable slot #0
// Vtable slot #1
// Vtable slot #2
// ...
//
//
// It's also important to be aware of how Context Proxies are laid out.  Ideally,
// there is a single VTable for all context proxies, regardless of the types they
// proxy to.  (In practice, there may be a small number of VTables because we
// might not be able to enlarge the existing VTable sufficiently).
//
// There is also a single CtxProxy class that derives from Object.  When we
// instantiate proxies, we start off with the MethodTable of that class.  This
// gives us the correct GC info, base size, etc.  We use that starting point
// to build a shared VTable that is embedded into an accurate MethodTable.

class MethodTable
{
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(MethodTable);

public:
    enum
    {
        //
        // DO NOT use flags that have bits set in the low 2 bytes.
        // These flags are DWORD sized so that our atomic masking
        // operations can operate on the entire 4-byte aligned DWORD
        // inestead of the logical non-aligned WORD of flags.  This
        // is also the reason for the union around m_ComponentSize
        // and m_wFlags below.
        //
        enum_flag_Array                 =    0x10000,
        enum_flag_large_Object          =    0x20000,
        enum_flag_ContainsPointers      =    0x40000,
        enum_flag_ClassInited           =    0x80000, // definitely ran vs. maybe not ran <clinit>
        enum_flag_HasFinalizer          =   0x100000, // instances require finalization
        enum_flag_Sparse                =   0x200000, // vtables for this interface are sparse
        enum_flag_Shared                =   0x400000, // This method table is shared among multiple logical classes
        enum_flag_Unrestored            =   0x800000, // Preloaded class needs to be restored

        enum_TransparentProxy           =  0x1000000, // tranparent proxy
        enum_flag_SharedAssembly        =  0x2000000, // Class is in a shared assembly
        enum_flag_NotTightlyPacked      =  0x4000000, // the fields of the valuetype are not tightly packed (not valid for classes)

        enum_CtxProxyMask               = 0x10000000, // class is a context proxy
        enum_ComEventItfMask            = 0x20000000, // class is a special COM event interface 
        enum_ComObjectMask              = 0x40000000, // class is a com object
        enum_InterfaceMask              = 0x80000000, // class is a interface
    };

    enum
    {
        NO_SLOT = 0xffff
    };

    // Special access for setting up String object method table correctly
    friend class ClassLoader;
private:
    // Use AllocateNewMT to create new MethodTables. Don't call delete/
    // new or the ctor.
    void operator delete(void *pData)
    {
        _ASSERTE(!"Call MethodTable::AllocateNewMT to create a MT");
    }    

    void *operator new(size_t dummy)
    {
        _ASSERTE(!"Call MethodTable::AllocateNewMT to create a MT");
    }
    
    MethodTable()
    {
        _ASSERTE(!"Call MethodTable::AllocateNewMT to create a MT");
    }

public:

    struct
    {
        // This stuff must be first in the struct and should fit on a cache line - don't move it.
        
        union
        {
            WORD       m_ComponentSize;         // Component size for array objects or value classes, zero otherwise    
            DWORD      m_wFlags;
        };

        DWORD           m_BaseSize;             // Base size of instance of this class

        EEClass*        m_pEEClass;             // class object
        
        union
        {
            LPVOID*     m_pInterfaceVTableMap;  // pointer to subtable for interface/vtable mapping
            GuidInfo*   m_pGuidInfo;            // The cached guid inforation for interfaces.
        };

    };

    
    WORD                m_wNumInterface;        // number of interfaces in the interface map
    BYTE                m_NormType;             // The CorElementType for this class (most classes = ELEMENT_TYPE_CLASS)

    Module*             m_pModule;

    WORD                m_wCCtorSlot;           // slot of class constructor
    WORD                m_wDefaultCtorSlot;     // slot of default constructor

    InterfaceInfo_t*    m_pIMap;                // pointer interface map for classes.


private:
    union
    {
        // valid only if EEClass::IsBlittable() or EEClass::HasLayout() is true
        UINT32          m_cbNativeSize; // size of fixed portion in bytes

        // For COM+ wrapper objects that extend an unmanaged class, this field
        // may contain a delegate to be called to allocate the aggregated
        // unmanaged class (instead of using CoCreateInstance).
        OBJECTHANDLE    m_ohDelegate;

        // For interfaces this contains the COM interface type.
        CorIfaceAttr    m_ComInterfaceType;
    };

protected:

    // for interfaces, this is the default stub to give out
    // this could be a specialized stub if there is only
    // one introduction of this interface

    //@TODO optimize
    // for non interface classes this could be a specialized
    // interface invoke stub which can be used if a class implements
    // only one interface

    DWORD   m_cbSlots; // total slots in this vtable

    
public:

    // vtable slots follow - variable length
    // Unfortunately, this must be public so I can easily access it from inline ASM.
    SLOT    m_Vtable[1];

    // This is the way to create a new method table. Don't try calling new directly.
    static MethodTable * AllocateNewMT(DWORD dwVtableSlots, DWORD dwStaticFieldBytes, DWORD dwGCSize, DWORD dwNumInterfaces, ClassLoader *pLoader, BOOL isIFace, BOOL bHasDynamicInterfaceMap);

    // checks whether the class initialiser should be run on this class, and runs it if necessary
    BOOL            CheckRunClassInit(OBJECTREF *pThrowable);

    // Retrieves the domain local class block (if any), and runs class init if appropriate
    BOOL            CheckRunClassInit(OBJECTREF *pThrowable,
                                      DomainLocalClass **ppLocalClass,
                                      AppDomain *pDomain = NULL);

    // Retrieves the COM interface type.
    CorIfaceAttr    GetComInterfaceType();
    CorClassIfaceAttr GetComClassInterfaceType();
    DWORD           GetBaseSize()       { _ASSERTE(m_BaseSize % sizeof(void*) == 0); return(m_BaseSize); }
    WORD            GetComponentSize()  { return(m_ComponentSize); }
    BOOL            IsArray()           { return(m_wFlags & enum_flag_Array); }
    BOOL            IsLargeObject()     { return(m_wFlags & enum_flag_large_Object); }
    int             IsClassInited()     { return(m_wFlags & enum_flag_ClassInited); }
    BOOL            HasSharedMethodTable() { return(m_wFlags & enum_flag_Shared); }
    DWORD           ContainsPointers()  { return(m_wFlags & enum_flag_ContainsPointers); }
    BOOL            IsNotTightlyPacked(){ return (m_wFlags & enum_flag_NotTightlyPacked); }

        // This is what would be used in a signature for this type.  One exception is enumerations,
        // for those the type is the underlying type.  
    CorElementType  GetNormCorElementType() { return CorElementType(m_NormType); }
    BOOL            IsValueClass();
    BOOL            IsContextful();
    BOOL            IsMarshaledByRef();
    BOOL            IsExtensibleRCW();

    BOOL            IsAgileAndFinalizable();

    Module *GetModule()
    {
        return m_pModule;
    }

    Assembly *GetAssembly()
    {
        return m_pModule->GetAssembly();
    }

    BaseDomain *GetDomain()
    {
        return m_pModule->GetDomain();
    }

    // num slots in the vtable.
    unsigned GetTotalSlots()
    {
        return m_cbSlots;
    }

    unsigned GetInterfaceMethodSlots()
    {
        //_ASSERTE(IsInterface());
        return m_cbSlots;
    }

    // Is Transparent proxy class
    int IsTransparentProxyType()
    {
        return m_wFlags & enum_TransparentProxy;
    }

    // class is a context proxy class
    int IsCtxProxyType()
    {
        // NOTE: If you change this, change the asm version in
        // JIT_IsInstanceOfClass.
        return m_wFlags & enum_CtxProxyMask;
    }
    
    // class is a interface
    int IsInterfaceType()
    {
        return m_wFlags & enum_InterfaceMask;
    }

    // class is a special COM event interface
    int IsComEventItfType()
    {
        return m_wFlags & enum_ComEventItfMask;
    }

    // class is a com object class
    int IsComObjectType()
    {
        return m_wFlags & enum_ComObjectMask;
    }

    int HasDynamicInterfaceMap()
    {
        // currently all ComObjects except
        // for __ComObject have dynamic Interface maps
        return m_wNumInterface > 0 && IsComObjectType() && GetParentMethodTable() != g_pObjectClass;
    }

    int IsSparse()
    {
        return m_wFlags & enum_flag_Sparse;
    }
    
    int IsRestored()
    {
        return !(m_wFlags & enum_flag_Unrestored);
    }

    __forceinline int IsRestoredAndClassInited()
    {
        return (m_wFlags & (enum_flag_Unrestored|enum_flag_ClassInited))
          == enum_flag_ClassInited;
    }

    BOOL HasDefaultConstructor()
    {
        return m_wDefaultCtorSlot != NO_SLOT;
    }

    BOOL HasClassConstructor()
    {
        return m_wCCtorSlot != NO_SLOT;
    }

    WORD GetDefaultConstructorSlot()
    {
        _ASSERTE(HasDefaultConstructor());
        return m_wDefaultCtorSlot;
    }

    WORD GetClassConstructorSlot()
    {
        _ASSERTE(HasClassConstructor());
        return m_wCCtorSlot;
    }

    MethodDesc *GetDefaultConstructor()
    {
        _ASSERTE(HasDefaultConstructor());
        return GetMethodDescForSlot(GetDefaultConstructorSlot());
    }

    MethodDesc *GetClassConstructor()
    {
        _ASSERTE(HasClassConstructor());
        return GetMethodDescForSlot(GetClassConstructorSlot());
    }

    void CheckRestore();
    
    BOOL IsInterface();

    BOOL IsShared()
    {
        return m_wFlags & enum_flag_SharedAssembly;
    }

    // uniquely identifes this class in the Domain table
    SIZE_T GetSharedClassIndex();

    // mark the class as having its <clinit> run.  (Or it has none)
    void SetClassInited();

    void SetClassRestored();

    void SetSharedMethodTable()
    {
        m_wFlags |= enum_flag_Shared;
    }

    void SetNativeSize(UINT32 nativeSize)
    {
        m_cbNativeSize = nativeSize;
    }

    void SetShared()
    {
        m_wFlags |= enum_flag_SharedAssembly;
    }

    // mark the class type as interface
    void SetInterfaceType()
    {
        m_wFlags |= enum_InterfaceMask;
    }

    // Set the COM interface type.
    void SetComInterfaceType(CorIfaceAttr ItfType)
    {
        _ASSERTE(IsInterface());
        m_ComInterfaceType = ItfType;
    }

    // mark the class type as a special COM event interface
    void SetComEventItfType()
    {
        _ASSERTE(IsInterface());
        m_wFlags |= enum_ComEventItfMask;
    }

    // mark the class type as com class
    void SetComObjectType();

    // mark as transparent proxy type
    void SetTransparentProxyType();

    // mark the class type as context proxy
    void SetCtxProxyType()
        {
            m_wFlags |= enum_CtxProxyMask;
        }

    // This is only used during shutdown, to suppress assertions
    void MarkAsNotThunking()
    {
        m_wFlags &= (~(enum_CtxProxyMask | enum_TransparentProxy));
    }

    void SetContainsPointers()
    {
        m_wFlags |= enum_flag_ContainsPointers;
    }

    void SetNotTightlyPacked()
    {
        m_wFlags |= enum_flag_NotTightlyPacked;
    }

    void SetSparse()
    {
        m_wFlags |= enum_flag_Sparse;
    }

    inline SLOT *GetVtable()
    {
        return &m_Vtable[0];
    }

    static DWORD GetOffsetOfVtable()
    {
        return offsetof(MethodTable, m_Vtable);
    }

    static DWORD GetOffsetOfNumSlots()
    {
        return offsetof(MethodTable, m_cbSlots);
    }

    inline EEClass* GetClass()
    {
        return m_pEEClass;
    }
    inline EEClass** GetClassPtr()
    {
        return &m_pEEClass;
    }

    inline InterfaceInfo_t* GetInterfaceMap()
    {
        VALIDATE_INTERFACE_MAP(this);

        #ifdef _DEBUG
            return (m_wNumInterface) ? m_pIMap : NULL;
        #else
            return m_pIMap;
        #endif
    }

    inline unsigned GetNumInterfaces()
    {
        VALIDATE_INTERFACE_MAP(this);
        return m_wNumInterface;
    }

    inline LPVOID *GetInterfaceVTableMap()
    {
        _ASSERTE(!IsInterface());       
        return m_pInterfaceVTableMap;
    }
        
    inline GuidInfo *GetGuidInfo()
    {
        _ASSERTE(IsInterface());
        return m_pGuidInfo;
    }

    inline UINT32 GetNativeSize()
    {
        //_ASSERTE(m_pEEClass->HasLayout());
        return m_cbNativeSize;
    }

    static UINT32 GetOffsetOfNativeSize()
    {
        return (UINT32)(offsetof(MethodTable, m_cbNativeSize));
    }

    InterfaceInfo_t* FindInterface(MethodTable *pInterface);

    MethodDesc *GetMethodDescForInterfaceMethod(MethodDesc *pInterfaceMD);

    // COM interop helpers
    // accessors for m_pComData
    LPVOID         GetComClassFactory();
    LPVOID         GetComCallWrapperTemplate();
    void           SetComClassFactory(LPVOID pComData);
    void           SetComCallWrapperTemplate(LPVOID pComData);
    
    MethodDesc* GetMethodDescForSlot(DWORD slot);

    MethodDesc* GetUnboxingMethodDescForValueClassMethod(MethodDesc *pMD);

    MethodTable * GetParentMethodTable();
    // helper to get parent class skipping over COM class in 
    // the hierarchy
    MethodTable * GetComPlusParentMethodTable();

    // We find a lot of information from the VTable.  But sometimes the VTable is a
    // thunking layer rather than the true type's VTable.  For instance, context
    // proxies use a single VTable for proxies to all the types we've loaded.
    // The following service adjusts a MethodTable based on the supplied instance.  As
    // we add new thunking layers, we just need to teach this service how to navigate
    // through them.
    MethodTable *AdjustForThunking(OBJECTREF or);
    FORCEINLINE BOOL         IsThunking()    { return IsCtxProxyType() || IsTransparentProxyType(); }

    // get dispatch vtable for interface
    LPVOID GetDispatchVtableForInterface(MethodTable* pMTIntfClass);
    // get start slot for interface
    DWORD       GetStartSlotForInterface(MethodTable* pMTIntfClass);
    // get start slot for interface
    DWORD       GetStartSlotForInterface(DWORD index);
    // get the interface given a slot
    InterfaceInfo_t *GetInterfaceForSlot(DWORD slotNumber);
    // get the method desc given the interface method desc
    MethodDesc *GetMethodDescForInterfaceMethod(MethodDesc *pItfMD, OBJECTREF pServer);
    // get the address of code given the method desc and server
    static const BYTE *GetTargetFromMethodDescAndServer(MethodDesc *pMD, OBJECTREF *ppServer, BOOL fContext);

    // Does this class have non-trivial finalization requirements?
    DWORD               HasFinalizer()
    {
        return (m_wFlags & enum_flag_HasFinalizer);
    }

    DWORD  CannotUseSuperFastHelper()
    {
        return HasFinalizer() || IsLargeObject();
    }

    DWORD  GetStaticSize();

    void                MaybeSetHasFinalizer();

    static void         CallFinalizer(Object *obj);
    static void         InitForFinalization();
#ifdef SHOULD_WE_CLEANUP
    static void         TerminateForFinalization();
#endif /* SHOULD_WE_CLEANUP */

    OBJECTREF GetObjCreateDelegate();
    void SetObjCreateDelegate(OBJECTREF orDelegate);

    HRESULT InitInterfaceVTableMap();

    void GetExtent(BYTE **ppStart, BYTE **ppEnd);

    HRESULT Save(DataImage *image);
    HRESULT Fixup(DataImage *image, DWORD *pRidToCodeRVAMap);

    // Support for dynamically added interfaces on extensible RCW's.
    InterfaceInfo_t* GetDynamicallyAddedInterfaceMap();
    unsigned GetNumDynamicallyAddedInterfaces();
    InterfaceInfo_t* FindDynamicallyAddedInterface(MethodTable *pInterface);
    void AddDynamicInterface(MethodTable *pItfMT);

    void InstantiateStaticHandles(OBJECTREF **pHandles, BOOL fFieldPointers);
    void FixupStaticMethodTables();

    OBJECTREF Allocate();
    OBJECTREF Box(void *data, BOOL mayHaveRefs = TRUE);

private:

    static MethodDesc  *s_FinalizerMD;
};


//=======================================================================
// Adjunct to the EEClass structure for classes w/ layout
//=======================================================================
class EEClassLayoutInfo
{
    friend HRESULT CollectLayoutFieldMetadata(
       mdTypeDef cl,                // cl of the NStruct being loaded
       BYTE packingSize,            // packing size (from @dll.struct)
       BYTE nlType,                 // nltype (from @dll.struct)
       BOOL fExplicitOffsets,       // explicit offsets?
       EEClass *pParentClass,       // the loaded superclass
       ULONG cMembers,              // total number of members (methods + fields)
       HENUMInternal *phEnumField,  // enumerator for field
       Module* pModule,             // Module that defines the scope, loader and heap (for allocate FieldMarshalers)
       EEClassLayoutInfo *pEEClassLayoutInfoOut,  // caller-allocated structure to fill in.
       LayoutRawFieldInfo *pInfoArrayOut, // caller-allocated array to fill in.  Needs room for cMember+1 elements
       OBJECTREF *pThrowable
    );

    friend class EEClass;

    private:
        // size (in bytes) of fixed portion of NStruct.
        UINT32      m_cbNativeSize;


        // 1,2,4 or 8: this is equal to the largest of the alignment requirements
        // of each of the EEClass's members. If the NStruct extends another NStruct,
        // the base NStruct is treated as the first member for the purpose of
        // this calculation.
        //
        // Because the alignment requirement of any struct member is capped
        // to the structs declared packing size, this value will never exceed
        // m_DeclaredPackingSize.
        BYTE        m_LargestAlignmentRequirementOfAllMembers;


        // 1,2,4 or 8: this is the packing size specified in the @dll.struct()
        // metadata.
        // When this struct is embedded inside another struct, its alignment
        // requirement is the smaller of the containing struct's m_DeclaredPackingSize
        // and the inner struct's m_LargestAlignmentRequirementOfAllMembers.
        BYTE        m_DeclaredPackingSize;

        // nltAnsi or nltUnicode (nltAuto never appears here: the loader pretransforms
        // this to Ansi or Unicode.)
        BYTE        m_nlType;


        // TRUE if no explicit offsets are specified in the metadata (EE
        // will compute offsets based on the packing size and nlType.)
        BYTE        m_fAutoOffset;

        // # of fields that are of the calltime-marshal variety.
        UINT        m_numCTMFields;

        // An array of FieldMarshaler data blocks, used to drive call-time
        // marshaling of NStruct reference parameters. The number of elements
        // equals m_numCTMFields.
        FieldMarshaler *m_pFieldMarshalers;


        // TRUE if the GC layout of the class is bit-for-bit identical
        // to its unmanaged counterpart (i.e. no internal reference fields,
        // no ansi-unicode char conversions required, etc.) Used to
        // optimize marshaling.
        BYTE        m_fBlittable;

    public:
        BOOL GetNativeSize() const
        {
            return m_cbNativeSize;
        }


        BYTE GetLargestAlignmentRequirementOfAllMembers() const
        {
            return m_LargestAlignmentRequirementOfAllMembers;
        }

        BYTE GetDeclaredPackingSize() const
        {
            return m_DeclaredPackingSize;
        }

        BYTE GetNLType() const
        {
            return m_nlType;
        }

        UINT GetNumCTMFields() const
        {
            return m_numCTMFields;
        }

        const FieldMarshaler *GetFieldMarshalers() const
        {
            return m_pFieldMarshalers;
        }

        BOOL IsAutoOffset() const
        {
            return m_fAutoOffset;
        }

        BOOL IsBlittable() const
        {
            return m_fBlittable;
        }
};



//
// This structure is used only when the classloader is building the interface map.  Before the class
// is resolved, the EEClass contains an array of these, which are all interfaces *directly* declared
// for this class/interface by the metadata - inherited interfaces will not be present if they are
// not specifically declared.
//
// This structure is destroyed after resolving has completed.
//
typedef struct
{
    EEClass *   m_pClass;
} BuildingInterfaceInfo_t;



//
// We should not need to touch anything in here once the classes are all loaded, unless we
// are doing reflection.  Try to avoid paging this data structure in.
//

// Size of hash bitmap for method names
#define METHOD_HASH_BYTES  8

// Hash table size - prime number
#define METHOD_HASH_BITS    61



// These are some macros for forming fully qualified class names for a class.
// These are abstracted so that we can decide later if a max length for a
// class name is acceptable.
#define DefineFullyQualifiedNameForClass() \
    CQuickBytes _qb_;\
    char* _szclsname_ = (char *)_qb_.Alloc(MAX_CLASSNAME_LENGTH * sizeof(CHAR));


#define DefineFullyQualifiedNameForClassOnStack() \
    char _szclsname_[MAX_CLASSNAME_LENGTH];
        
#define DefineFullyQualifiedNameForClassW() \
    CQuickBytes _qb2_;\
    WCHAR* _wszclsname_ = (WCHAR *)_qb2_.Alloc(MAX_CLASSNAME_LENGTH * sizeof(WCHAR));   

#define DefineFullyQualifiedNameForClassWOnStack() \
    WCHAR _wszclsname_[MAX_CLASSNAME_LENGTH];

#define GetFullyQualifiedNameForClassNestedAware(pClass) \
    pClass->_GetFullyQualifiedNameForClassNestedAware(_szclsname_, MAX_CLASSNAME_LENGTH)
#define GetFullyQualifiedNameForClassNestedAwareW(pClass) \
    pClass->_GetFullyQualifiedNameForClassNestedAware(_wszclsname_, MAX_CLASSNAME_LENGTH)

#define GetFullyQualifiedNameForClass(pClass) \
    pClass->_GetFullyQualifiedNameForClass(_szclsname_, MAX_CLASSNAME_LENGTH)
#define GetFullyQualifiedNameForClassW(pClass) \
    pClass->_GetFullyQualifiedNameForClass(_wszclsname_, MAX_CLASSNAME_LENGTH)

//
// Flags for m_VMFlags
//
enum
{
    VMFLAG_RESOLVED                        = 0x00000001,
    VMFLAG_INITED                          = 0x00000002,  // definitely vs. maybe run <clinit>
    VMFLAG_ARRAY_CLASS                     = 0x00000004,
    VMFLAG_CLASS_INIT_ERROR                = 0x00000008,  // encountered error during <clinit>
    VMFLAG_ISBLOBCLASS                     = 0x00000010,  

// Set this if this class or its parent have instance fields which
// must be explicitly inited in a constructor (e.g. pointers of any
// kind, gc or native).
//
// Currently this is used by the verifier when verifying value classes
// - it's ok to use uninitialised value classes if there are no
// pointer fields in them.

    VMFLAG_HAS_FIELDS_WHICH_MUST_BE_INITED = 0x00000020,  
    VMFLAG_HASLAYOUT                       = 0x00000040,
    VMFLAG_ISNESTED                        = 0x00000080,  
    VMFLAG_UNRESTORED                      = 0x00000100,  
    VMFLAG_CONTEXTFUL                      = 0x00000200,
    VMFLAG_MARSHALEDBYREF                  = 0x00000400,
    VMFLAG_SHARED                          = 0x00000800,
    VMFLAG_CCTOR                           = 0x00001000,
    VMFLAG_ENUMTYPE                        = 0x00002000,
    VMFLAG_TRUEPRIMITIVE                   = 0x00004000,
    VMFLAG_HASOVERLAYEDFIELDS              = 0x00008000,
    VMFLAG_RESTORING                       = 0x00010000,
    // interfaces may have a coclass attribute
    VMFLAG_HASCOCLASSATTRIB                = 0x00020000,

#if CHECK_APP_DOMAIN_LEAKS
    // these could move to a separate flag if necessary as all are needed only
    // under debug
    VMFLAG_APP_DOMAIN_AGILE                = 0x00040000,
    VMFLAG_CHECK_APP_DOMAIN_AGILE          = 0x00080000,
    VMFLAG_APP_DOMAIN_AGILITY_DONE         = 0x00100000,

#endif

    VMFLAG_CONFIG_CHECKED                  = 0x00200000,
    VMFLAG_REMOTE_ACTIVATED                = 0x00400000,    
    VMFLAG_VALUETYPE                       = 0x00800000,
    VMFLAG_NO_GUID                         = 0x01000000,
    VMFLAG_HASNONPUBLICFIELDS              = 0x02000000,
    VMFLAG_REMOTING_PROXY_ATTRIBUTE        = 0x04000000,
    VMFLAG_CONTAINS_STACK_PTR              = 0x08000000,
    VMFLAG_ISSINGLEDELEGATE                = 0x10000000,
    VMFLAG_ISMULTIDELEGATE                 = 0x20000000,
    VMFLAG_PREFER_ALIGN8                   = 0x40000000, // Would like to have 8-byte alignment

    VMFLAG_CCW_APP_DOMAIN_AGILE            = 0x80000000,
};


//
// This enum represents the property methods that can be passed to FindPropertyMethod().
//

enum EnumPropertyMethods
{
    PropertyGet = 0,
    PropertySet = 1,
};


//
// This enum represents the event methods that can be passed to FindEventMethod().
//

enum EnumEventMethods
{
    EventAdd = 0,
    EventRemove = 1,
    EventRaise = 2,
};


class MethodNameHash;
class MethodNameCache;
class SystemDomain;
class Assembly;
class DeadlockAwareLockedListElement;

class EEClass // DO NOT CREATE A NEW EEClass USING NEW!
{
    // DO NOT ADD FRIENDS UNLESS ABSOLUTELY NECESSARY
    // USE ACCESSORS TO READ/WRITE private field members

    // To access bmt stuff
    friend class FieldDesc;
    // To access offset of private fields
    friend HRESULT InitializeMiniDumpBlock();
    friend struct MEMBER_OFFSET_INFO(EEClass);

public:

#ifdef _DEBUG
    LPUTF8  m_szDebugClassName; // This is the *fully qualified* class name
    BOOL m_fDebuggingClass;     // Laying out the class specified in BreakOnClassBuild

    inline LPUTF8 GetDebugClassName () { return m_szDebugClassName; }
    inline void SetDebugClassName (LPUTF8 szDebugClassName) { m_szDebugClassName = szDebugClassName; }
#endif // _DEBUG

    inline SparseVTableMap* GetSparseVTableMap () { return m_pSparseVTableMap; }
    inline void SetSparseVTableMap (SparseVTableMap* pSparseVTableMap) { m_pSparseVTableMap = pSparseVTableMap; }
    
    inline void SetInterfaceId (UINT32 dwInterfaceId) { m_dwInterfaceId = dwInterfaceId; }
    inline void SetNumMethodSlots (WORD wNumMethodSlots) { m_wNumMethodSlots = wNumMethodSlots; }
    
    inline WORD GetDupSlots () { return m_wDupSlots; }
    inline void SetDupSlots (WORD wDupSlots) { m_wDupSlots = wDupSlots; }
    
    inline void SetNumInterfaces (WORD wNumInterfaces) { m_wNumInterfaces = wNumInterfaces; }
    inline void SetParentClass (EEClass *pParentClass) { /*GetMethodTable()->SetParentMT (pParentClass->GetMethodTable());*/ m_pParentClass = pParentClass; }
    
    inline EEClass* GetSiblingsChain () { return m_SiblingsChain; }
    inline void SetSiblingsChain (EEClass* pSiblingsChain) { m_SiblingsChain = pSiblingsChain; }
    
    inline EEClass* GetChildrenChain () { return m_ChildrenChain; }
    inline void SetChildrenChain (EEClass* pChildrenChain) { m_ChildrenChain = pChildrenChain; }
    
    inline void SetNumInstanceFields (WORD wNumInstanceFields) { m_wNumInstanceFields = wNumInstanceFields; }
    inline void SetNumStaticFields (WORD wNumStaticFields) { m_wNumStaticFields = wNumStaticFields; }
    inline void SetNumGCPointerSeries (WORD wNumGCPointerSeries) { m_wNumGCPointerSeries = wNumGCPointerSeries; }

    inline WORD GetNumHandleStatics () { return m_wNumHandleStatics; }
    inline void SetNumHandleStatics (WORD wNumHandleStatics) { m_wNumHandleStatics = wNumHandleStatics; }
    
    inline void SetNumInstanceFieldBytes (DWORD dwNumInstanceFieldBytes) { m_dwNumInstanceFieldBytes = dwNumInstanceFieldBytes; }
    
    inline ClassLoader* GetLoader () { return m_pLoader; }
    inline void SetLoader (ClassLoader* pLoader) { m_pLoader = pLoader; }
    
    inline FieldDesc* GetFieldDescList () { return m_pFieldDescList; }
    inline void SetFieldDescList (FieldDesc* pFieldDescList) { m_pFieldDescList = pFieldDescList; }
    
    inline void SetAttrClass (DWORD dwAttrClass) { m_dwAttrClass = dwAttrClass; }
    inline void SetVMFlags (DWORD fVMFlags) { m_VMFlags = fVMFlags; }
    inline void SetSecProps (SecurityProperties fSecProps) { m_SecProps = fSecProps; }
    
    inline mdTypeDef Getcl () { return m_cl; }
    inline void Setcl (mdTypeDef cl) { m_cl = cl; }
    
    inline MethodDescChunk* GetChunks () { return m_pChunks; }
    inline void SetChunks (MethodDescChunk* pChunks) { m_pChunks = pChunks; }
    
    inline WORD GetThreadStaticsSize () { return m_wThreadStaticsSize; }
    inline void SetThreadStaticsSize (WORD wThreadStaticsSize) { m_wThreadStaticsSize = wThreadStaticsSize; }
    
    inline WORD GetContextStaticsSize () { return m_wContextStaticsSize; }
    inline void SetContextStaticsSize (WORD wContextStaticsSize) { m_wContextStaticsSize = wContextStaticsSize; }
    
    inline WORD GetThreadStaticOffset () { return m_wThreadStaticOffset; }
    inline void SetThreadStaticOffset (WORD wThreadStaticOffset) { m_wThreadStaticOffset = wThreadStaticOffset; }
    
    inline WORD GetContextStaticOffset () { return m_wContextStaticOffset; }
    inline void SetContextStaticOffset (WORD wContextStaticOffset) { m_wContextStaticOffset = wContextStaticOffset; }

    inline void SetExposedClassObject (OBJECTREF *ExposedClassObject) { m_ExposedClassObject = ExposedClassObject; }
    
    inline LPVOID GetccwTemplate () { return m_pccwTemplate; }
    inline void SetccwTemplate (LPVOID pccwTemplate) { m_pccwTemplate = pccwTemplate; }
    
    inline LPVOID GetComclassfac () { return m_pComclassfac; }
    inline void SetComclassfac (LPVOID pComclassfac) { m_pComclassfac = pComclassfac; }

    MethodNameHash *CreateMethodChainHash();

protected:
    // prevents any other class from doing a new()
    EEClass(ClassLoader *pLoader)
    {
        m_VMFlags        = 0;
        m_pLoader        = pLoader;
        m_pMethodTable   = NULL;
        
       m_pccwTemplate   = NULL;  // com specific data
       m_pComclassfac   = NULL; // com speciic data
       
#ifdef _DEBUG
        m_szDebugClassName = NULL;
        m_fDebuggingClass = FALSE;
#endif // _DEBUG
        m_ExposedClassObject = NULL;
        m_pChunks = NULL;
        //union
        m_SiblingsChain = NULL; //m_pCoClassForIntf = NULL (union)
        m_ChildrenChain = NULL;
    }

    EEClass *m_pParentClass;
    WORD   m_wNumVtableSlots;  // Includes only vtable methods (which come first in the table)
    WORD   m_wNumMethodSlots;  // Includes vtable + non-vtable methods, but NOT duplicate interface methods
    WORD   m_wDupSlots;         // value classes have some duplicate slots at the end

    // @TODO: Does this duplicate NumInterfaces in the MT?
    WORD   m_wNumInterfaces;

    
    // We have the parent pointer above.  In order to efficiently backpatch, we need
    // to find all the children of the current type.  This is achieved with a chain of
    // children.  The SiblingsChain is used as the linkage of that chain.
    //
    // Strictly speaking, we could remove m_pParentClass and put it at the end of the
    // sibling chain.  But the perf would really suffer for casting, so we burn the space.
    EEClass *m_SiblingsChain;    
    
    union
    {
        // coclass for an interface
        EEClass* m_pCoClassForIntf;
        // children chain, refer above
        EEClass *m_ChildrenChain;
    };

    ~EEClass()
    {
    }

private:
    enum
    {
        METHOD_IMPL_NOT,
        METHOD_IMPL,
        METHOD_IMPL_COUNT
    };

    enum
    {
        METHOD_TYPE_NORMAL,
        METHOD_TYPE_INTEROP,
        METHOD_TYPE_ECALL,
        METHOD_TYPE_NDIRECT,
        METHOD_TYPE_COUNT
    };
    SparseVTableMap *m_pSparseVTableMap;      // Used to map MethodTable slots to VTable slots
    UINT32 m_dwInterfaceId;

    // Only used in the resolve phase of the classloader
    BOOL ExpandInterface(InterfaceInfo_t *pInterfaceMap, 
                         EEClass *pNewInterface, 
                         DWORD *pdwInterfaceListSize, 
                         DWORD *pdwMaxInterfaceMethods,
                         BOOL fDirect);
    BOOL CreateInterfaceMap(BuildingInterfaceInfo_t *pBuildingInterfaceList, 
                            InterfaceInfo_t *ppInterfaceMap, 
                            DWORD *pdwInterfaceListSize, 
                            DWORD *pdwMaxInterfaceMethods);

    static DWORD CouldMethodExistInClass(EEClass *pClass, LPCUTF8 pszMethodName, DWORD dwHashName);


    // Helper methods called from DoRunClassInit().
    BOOL RunClassInit(DeadlockAwareLockedListElement *pEntry, OBJECTREF *pThrowable);

    HRESULT LoaderFindMethodInClass(
        MethodNameHash **   ppMethodHash,
        LPCUTF8             pszMemberName,
        Module*             pModule,
        mdMethodDef         mdToken,
        MethodDesc **       ppMethodDesc,
        PCCOR_SIGNATURE *   ppMemberSignature,
        DWORD *             pcMemberSignature,
        DWORD               dwHashName
    );

    //The following structs are used in buildmethodtable
    // The 'bmt' in front of each struct reminds us these are for BuildMethodTable

    // for each 64K token range, stores the number of methods found within that token range,
    // the current methoddescchunk being filled in and the next available index within
    // that chunk. Note that we'll very rarely generate a TokenRangeNode for any range
    // other than 0..64K range.
    struct bmtTokenRangeNode {
        BYTE    tokenHiByte;
        DWORD   cMethods;
        DWORD   dwCurrentChunk;
        DWORD   dwCurrentIndex;
        
        bmtTokenRangeNode *pNext;
    
    };

    struct bmtErrorInfo{
        UINT resIDWhy;
        LPCUTF8 szMethodNameForError;
        mdToken dMethodDefInError;
        OBJECTREF *pThrowable;

        // Set the reason and the offending method def. If the method information
        // is not from this class set the method name and it will override the method def.
        inline bmtErrorInfo() : resIDWhy(0), szMethodNameForError(NULL), dMethodDefInError(mdMethodDefNil), pThrowable(NULL) {}

    };

    struct bmtProperties {
        // Com Interop, ComWrapper classes extend from ComObject
        BOOL fIsComObjectType;                  // whether this class is an isntance of ComObect class
        
        BOOL fNoSanityChecks;
        
        BOOL fIsMngStandardItf;                 // Set to true if the interface is a manages standard interface.
        BOOL fSparse;                           // Set to true if a sparse interface is being used.

        BOOL fComEventItfType;                  // Set to true if the class is a special COM event interface.

        inline bmtProperties() { memset((void *)this, NULL, sizeof(*this)); }
    };
        
    struct bmtVtable {
        DWORD dwCurrentVtableSlot;
        DWORD dwCurrentNonVtableSlot;
        DWORD dwStaticFieldBytes;
        DWORD dwStaticGCFieldBytes;
        SLOT* pVtable;                          // Temporary vtable
        SLOT* pNonVtable;
        DWORD dwMaxVtableSize;                  // Upper bound on size of vtable
        WORD  wDefaultCtorSlot;
        WORD  wCCtorSlot;
        
        inline bmtVtable() { memset((void *)this, NULL, sizeof(*this)); }
    };

    struct bmtParentInfo {
        DWORD dwNumParentInterfaces;
        MethodDesc **ppParentMethodDescBuf;     // Cache for declared methods
        MethodDesc **ppParentMethodDescBufPtr;  // Pointer for iterating over the cache

        WORD NumParentPointerSeries;
        MethodNameHash *pParentMethodHash;
        
        inline bmtParentInfo() { memset((void *)this, NULL, sizeof(*this)); }
    };

    struct bmtInterfaceInfo {
        DWORD dwTotalNewInterfaceMethods;
        InterfaceInfo_t *pInterfaceMap;         // Temporary interface map
        DWORD *pdwOriginalStart;                // If an interface is moved this is the original starting location.
        DWORD dwInterfaceMapSize;               // # members in interface map
        DWORD dwLargestInterfaceSize;           // # members in largest interface we implement  
        DWORD dwMaxExpandedInterfaces;          // Upper bound on size of interface map
        DWORD dwCurInterface;
        MethodDesc **ppInterfaceMethodDescList; // List of MethodDescs for current interface (_alloca()'d)  

        InterfaceInfo_t *pInterfaces;
        
        MethodDesc ***pppInterfaceImplementingMD; // List of MethodDescs that implement interface methods

        inline bmtInterfaceInfo() { memset((void *)this, NULL, sizeof(*this)); }
    };
        
    struct bmtEnumMethAndFields {
        DWORD dwNumStaticFields;
        DWORD dwNumInstanceFields;
        DWORD dwNumStaticObjRefFields;
        DWORD dwNumDeclaredFields;           // For calculating amount of FieldDesc's to allocate
        DWORD dwNumDeclaredMethods;          // For calculating amount of MethodDesc's to allocate
        DWORD dwNumUnboxingMethods;

        HENUMInternal hEnumField;
        HENUMInternal hEnumMethod;
        BOOL fNeedToCloseEnumField;
        BOOL fNeedToCloseEnumMethod;

        DWORD dwNumberMethodImpls;              // Number of method impls defined for this type
        HENUMInternal hEnumDecl;                // Method Impl's contain a declaration
        HENUMInternal hEnumBody;                //  and a body.
        BOOL fNeedToCloseEnumMethodImpl;        //  

        inline bmtEnumMethAndFields() { memset((void *)this, NULL, sizeof(*this)); }
    };

    struct bmtMetaDataInfo {
        DWORD cMethods;                     // # meta-data methods of this class
        DWORD cMethAndGaps;                 // # meta-data methods of this class ( including the gaps )
        DWORD cFields;                      // # meta-data fields of this class
        mdToken *pFields;                   // Enumeration of metadata fields
        mdToken *pMethods;                  // Enumeration of metadata methods
        DWORD *pFieldAttrs;                 // Enumeration of the attributes of the fields
        DWORD *pMethodAttrs;                // Enumeration of the attributes of the methods
        DWORD *pMethodImplFlags;            // Enumeration of the method implementation flags
        ULONG *pMethodRVA;                  // Enumeration of the method RVA's
        DWORD *pMethodClassifications;      // Enumeration of the method classifications
        LPSTR *pstrMethodName;              // Enumeration of the method names
        BYTE *pMethodImpl;                 // Enumeration of impl value
        BYTE *pMethodType;                  // Enumeration of type value
        
        bmtTokenRangeNode *ranges[METHOD_TYPE_COUNT][METHOD_IMPL_COUNT]; //linked list of token ranges that contain at least one method
        
        mdToken *pMethodBody;               // MethodDef's for the bodies of MethodImpls. Must be defined in this type.
        mdToken *pMethodDecl;               // Method token that body implements. Is a MethodDef

        inline bmtMetaDataInfo() { memset((void *)this, NULL, sizeof(*this)); }
    };

    struct bmtMethodDescSet {
        DWORD dwNumMethodDescs;         // # MD's 
        DWORD dwNumUnboxingMethodDescs; // # Unboxing MD's
        DWORD dwChunks;                 // # chunks to allocate
        MethodDescChunk **pChunkList;    // Array of pointers to chunks
    };

    struct bmtMethAndFieldDescs {
        MethodDesc **ppUnboxMethodDescList; // Keep track unboxed entry points (for value classes)
        MethodDesc **ppMethodDescList;      // MethodDesc pointer for each member
        FieldDesc **ppFieldDescList;        // FieldDesc pointer (or NULL if field not preserved) for each field        
        void **ppMethodAndFieldDescList;

        bmtMethodDescSet sets[METHOD_TYPE_COUNT][METHOD_IMPL_COUNT];

        MethodDesc *pBodyMethodDesc;        // The method desc for the body.

        inline bmtMethAndFieldDescs() { memset((void *)this, NULL, sizeof(*this)); }
    };

    struct bmtFieldPlacement {
        // For compacting field placement
        DWORD StaticFieldStart[MAX_LOG2_PRIMITIVE_FIELD_SIZE+1];            // Byte offset where to start placing fields of this size
        DWORD InstanceFieldStart[MAX_LOG2_PRIMITIVE_FIELD_SIZE+1];
        DWORD NumStaticFieldsOfSize[MAX_LOG2_PRIMITIVE_FIELD_SIZE+1];       // # Fields of this size

        DWORD NumInstanceFieldsOfSize[MAX_LOG2_PRIMITIVE_FIELD_SIZE+1];
        DWORD FirstInstanceFieldOfSize[MAX_LOG2_PRIMITIVE_FIELD_SIZE+1];
        DWORD GCPointerFieldStart;
        DWORD NumInstanceGCPointerFields;   // does not include inherited pointer fields
        DWORD NumStaticGCPointerFields;   // does not include inherited pointer fields

        inline bmtFieldPlacement() { memset((void *)this, NULL, sizeof(*this)); }
    };

    struct bmtInternalInfo {
        IMDInternalImport *pInternalImport;
        Module *pModule;
        mdToken cl;

        inline bmtInternalInfo() { memset((void *)this, NULL, sizeof(*this)); }
    };

    enum bmtFieldLayoutTag {empty, nonoref, oref};

    // used for calculating pointer series for tdexplicit
    struct bmtGCSeries {
        UINT numSeries;
        struct Series {
            UINT offset;
            UINT len;
        } *pSeries;
        bmtGCSeries() : numSeries(0), pSeries(NULL) {}
    };

    struct bmtMethodImplInfo {
        DWORD        pIndex;     // Next open spot in array, we load the BodyDesc's up in order of appearance in the 
                                 // type's list of methods (a body can appear more then once in the list of MethodImpls)
        mdToken*     pDeclToken; // Either the token or the method desc is set for the declaration
        MethodDesc** pDeclDesc;  // Method descs for Declaration. If null then Declaration is in this type and use the token
        MethodDesc** pBodyDesc;  // Method descs created for Method impl bodies

        void AddMethod(MethodDesc* pBody, MethodDesc* pDesc, mdToken mdDecl)
        {
            _ASSERTE(pDesc == NULL || mdDecl == mdTokenNil);
            pDeclDesc[pIndex] = pDesc;
            pDeclToken[pIndex] = mdDecl;
            pBodyDesc[pIndex++] = pBody;
        }
        
        MethodDesc* GetDeclarationMethodDesc(DWORD i)
        {
            _ASSERTE(i < pIndex);
            return pDeclDesc[i];
        }

        mdToken GetDeclarationToken(DWORD i)
        {
            _ASSERTE(i < pIndex);
            return pDeclToken[i];
        }

        MethodDesc* GetBodyMethodDesc(DWORD i)
        {
            _ASSERTE(i < pIndex);
            return pBodyDesc[i];
        }
        inline bmtMethodImplInfo() { memset((void*) this, NULL, sizeof(*this)); }
    };

    //These functions are used by BuildMethodTable
    HRESULT ResolveInterfaces(BuildingInterfaceInfo_t*, bmtInterfaceInfo*, bmtProperties*, 
                              bmtVtable*, bmtParentInfo*);
    // Finds a method declaration from a MemberRef or Def. It handles the case where
    // the Ref or Def point back to this class even though it has not been fully 
    // laid out.
    HRESULT FindMethodDeclaration(bmtInternalInfo* bmtInternal, 
                                  mdToken  pToken,       // Token that is being located (MemberRef or MemberDef)
                                  mdToken* pDeclaration, // Method definition for Member
                                  BOOL fSameClass,       // Does the declaration need to be in this class
                                  Module** pModule,       // Module that the Method Definitions is part of
                                  bmtErrorInfo* bmtError);

    HRESULT EnumerateMethodImpls(bmtInternalInfo*, 
                                 bmtEnumMethAndFields*, 
                                 bmtMetaDataInfo*, 
                                 bmtMethodImplInfo* bmtMethodImpl,
                                 bmtErrorInfo*);
    HRESULT EnumerateClassMembers(bmtInternalInfo*, 
                                  bmtEnumMethAndFields*, 
                                  bmtMethAndFieldDescs*, 
                                  bmtProperties*, 
                                  bmtMetaDataInfo*, 
                                  bmtVtable*, 
                                  bmtErrorInfo*);
    HRESULT AllocateMethodFieldDescs(bmtProperties* bmtProp, bmtMethAndFieldDescs*, bmtMetaDataInfo*, 
                                     bmtVtable*, bmtEnumMethAndFields*, bmtInterfaceInfo*, 
                                     bmtFieldPlacement*, bmtParentInfo*);
    HRESULT InitializeFieldDescs(FieldDesc *,const LayoutRawFieldInfo*,bmtInternalInfo*, 
                                 bmtMetaDataInfo*, bmtEnumMethAndFields*, bmtErrorInfo*, EEClass***, 
                                 bmtMethAndFieldDescs*, bmtFieldPlacement*, unsigned * totalDeclaredSize);

    HRESULT PlaceMembers(bmtInternalInfo* bmtInternal, 
                         bmtMetaDataInfo* bmtMetaData, 
                         bmtErrorInfo* bmtError, 
                         bmtProperties* bmtProp, 
                         bmtParentInfo* bmtParent, 
                         bmtInterfaceInfo* bmtInterface, 
                         bmtMethAndFieldDescs* bmtMFDescs, 
                         bmtEnumMethAndFields* bmtEnumMF, 
                         bmtMethodImplInfo* bmtMethodImpl,
                         bmtVtable* bmtVT);

    HRESULT InitMethodDesc(MethodDesc *pNewMD,
                           DWORD Classification,
                           mdToken tok,
                           DWORD dwImplFlags,
                           DWORD dwMemberAttrs,
                           BOOL  fEnC,
                           DWORD RVA,          // Only needed for NDirect case
                           BYTE *ilBase,        // Only needed for NDirect case
                           IMDInternalImport *pIMDII,  // Needed for NDirect, EEImpl(Delegate) cases
                           LPCSTR pMethodName // Only needed for mcEEImpl (Delegate) case
#ifdef _DEBUG
                           , LPCUTF8 pszDebugMethodName,
                           LPCUTF8 pszDebugClassName,
                           LPUTF8 pszDebugMethodSignature
#endif //_DEBUG //@todo Is it bad to have a diff sig in debug/retail?
                           );

    HRESULT PlaceMethodImpls(bmtInternalInfo* bmtInternal,
                             bmtMethodImplInfo* bmtMethodImpl,
                             bmtErrorInfo* bmtError, 
                             bmtInterfaceInfo* bmtInterface, 
                             bmtVtable* bmtVT);

    HRESULT PlaceLocalDeclaration(mdMethodDef      mdef,
                                  MethodDesc*      body,
                                  bmtInternalInfo* bmtInternal,
                                  bmtErrorInfo*    bmtError, 
                                  bmtVtable*       bmtVT,
                                  DWORD*           slots,
                                  MethodDesc**     replaced,
                                  DWORD*           pSlotIndex,
                                  PCCOR_SIGNATURE* ppBodySignature,
                                  DWORD*           pcBodySignature);

    HRESULT PlaceInterfaceDeclaration(MethodDesc*       pDecl,
                                      MethodDesc*       body,
                                      bmtInternalInfo*  bmtInternal,
                                      bmtInterfaceInfo* bmtInterface, 
                                      bmtErrorInfo*     bmtError, 
                                      bmtVtable*        bmtVT,
                                      DWORD*            slots,
                                      MethodDesc**      replaced,
                                      DWORD*            pSlotIndex,
                                      PCCOR_SIGNATURE*  ppBodySignature,
                                      DWORD*            pcBodySignature);

    HRESULT PlaceParentDeclaration(MethodDesc*       pDecl,
                                   MethodDesc*       body,
                                   bmtInternalInfo*  bmtInternal,
                                   bmtErrorInfo*     bmtError, 
                                   bmtVtable*        bmtVT,
                                   DWORD*            slots,
                                   MethodDesc**      replaced,
                                   DWORD*            pSlotIndex,
                                   PCCOR_SIGNATURE*  ppBodySignature,
                                   DWORD*            pcBodySignature);
        
    // Gets the original method for the slot even if the method
    // is currently occupied by a method impl. If the method
    // impl is one defined on this class then an error is 
    // returned.
    HRESULT GetRealMethodImpl(MethodDesc* pMD,
                              DWORD dwVtableSlot,
                              MethodDesc** ppResult);
    
    HRESULT DuplicateValueClassSlots(bmtMetaDataInfo*, 
                                     bmtMethAndFieldDescs*, 
                                     bmtInternalInfo*, 
                                     bmtVtable*);

    HRESULT PlaceVtableMethods(bmtInterfaceInfo*, 
                               bmtVtable*, 
                               bmtMetaDataInfo*, 
                               bmtInternalInfo*, 
                               bmtErrorInfo*, 
                               bmtProperties*, 
                               bmtMethAndFieldDescs*);

    HRESULT PlaceStaticFields(bmtVtable*, bmtFieldPlacement*, bmtEnumMethAndFields*);
    HRESULT PlaceInstanceFields(bmtFieldPlacement*, bmtEnumMethAndFields*, bmtParentInfo*, bmtErrorInfo*, EEClass***);
    HRESULT SetupMethodTable(bmtVtable*, bmtInterfaceInfo*, bmtInternalInfo*, bmtProperties*, 
                             bmtMethAndFieldDescs*, bmtEnumMethAndFields*, 
                             bmtErrorInfo*, bmtMetaDataInfo*, bmtParentInfo*);
    HRESULT HandleGCForValueClasses(bmtFieldPlacement*, bmtEnumMethAndFields*, EEClass***);
    HRESULT CreateHandlesForStaticFields(bmtEnumMethAndFields*, bmtInternalInfo*, EEClass***, bmtVtable *bmtVT, bmtErrorInfo*);
    HRESULT VerifyInheritanceSecurity(bmtInternalInfo*, bmtErrorInfo*, bmtParentInfo*, bmtEnumMethAndFields*);
    HRESULT FillRIDMaps(bmtMethAndFieldDescs*, bmtMetaDataInfo*, bmtInternalInfo*);            

// HACK: Akhune : first phase of getting all accesses to EEClass moved to MethodTable. 
public:
    HRESULT MapSystemInterfaces();
private:

    HRESULT CheckForValueType(bmtErrorInfo*);
    HRESULT CheckForEnumType(bmtErrorInfo*);
    HRESULT CheckForRemotingProxyAttrib(bmtInternalInfo *bmtInternal, bmtProperties* bmtProp);
    VOID GetCoClassAttribInfo();
    HRESULT CheckForSpecialTypes(bmtInternalInfo *bmtInternal, bmtProperties *bmtProp);
    HRESULT SetContextfulOrByRef(bmtInternalInfo*);
    HRESULT HandleExplicitLayout(bmtMetaDataInfo *bmtMetaData, bmtMethAndFieldDescs *bmtMFDescs, 
                                 EEClass **pByValueClassCache, bmtInternalInfo* bmtInternal, 
                                 bmtGCSeries *pGCSeries, bmtErrorInfo *bmtError);
    HRESULT CheckValueClassLayout(char *pFieldLayout, UINT fieldOffset, BOOL* pfVerifiable);
    HRESULT FindPointerSeriesExplicit(UINT instanceSliceSize, char *pFieldLayout, bmtGCSeries *pGCSeries);
    HRESULT HandleGCForExplicitLayout(bmtGCSeries *pGCSeries);
    HRESULT AllocateMDChunks(bmtTokenRangeNode *pTokenRanges, DWORD type, DWORD impl, DWORD *pNumChunks, MethodDescChunk ***ppItfMDChunkList);

    void GetPredefinedAgility(Module *pModule, mdTypeDef td, BOOL *pfIsAgile, BOOL *pfIsCheckAgile);

    static bmtTokenRangeNode *GetTokenRange(mdToken tok, bmtTokenRangeNode **ppHead);

    // this accesses the field size which is temporarily stored in m_pMTOfEnclosingClass
    // during class loading. Don't use any other time
    DWORD GetFieldSize(FieldDesc *pFD);
    DWORD InstanceSliceOffsetForExplicit(BOOL containsPointers);
    
    // Tests to see if the member on the child class violates a visibility rule. Will fill out
    // bmtError and returns an error code on a violation
    HRESULT TestOverRide(DWORD dwParentAttrs, DWORD dwMemberAttrs, BOOL isSameAssembly, bmtErrorInfo* bmtError);

    // Heuristic to detemine if we would like instances of this class 8 byte aligned
    BOOL ShouldAlign8(DWORD dwR8Fields, DWORD dwTotalFields);

// HACK: Akhune : first phase of getting all accesses to EEClass moved to MethodTable. 
public:
    // Subtypes are recorded in a chain from the super, so that we can e.g. backpatch
    // up & down the hierarchy.
    void    NoticeSubtype(EEClass *pSub);
    void    RemoveSubtype(EEClass *pSub);

private:
    // Number of fields in the class, including inherited fields (includes
    WORD   m_wNumInstanceFields;
    WORD   m_wNumStaticFields;

    // Number of pointer series
    WORD    m_wNumGCPointerSeries;

    // Number of static handles allocated
    WORD    m_wNumHandleStatics;

    // # of bytes of instance fields stored in GC object
    DWORD   m_dwNumInstanceFieldBytes;  // Warning, this can be any number, it is NOT rounded up to DWORD alignment etc

    ClassLoader *m_pLoader;

    // includes all methods in the vtable
    MethodTable *m_pMethodTable;

    // a pointer to a list of FieldDescs declared in this class
    // There are (m_wNumInstanceFields - m_pParentClass->m_wNumInstanceFields + m_wNumStaticFields) entries
    // in this array
    FieldDesc *m_pFieldDescList;
    // returns the number of elements in the m_pFieldDescList array
    DWORD FieldDescListSize();

    // Number of elements in pInterfaces or pBuildingInterfaceList (depending on whether the class
    DWORD   m_dwAttrClass;
    DWORD   m_VMFlags;

    BYTE    m_MethodHash[METHOD_HASH_BYTES];

    //
    // @TODO [brianbec]: This is currently a void* (opaque type in cor.h).  It needs
    //                   to be a destructible class once the security metadata schema
    //                   is formally defined.
    //
    SecurityProperties m_SecProps ;

    mdTypeDef m_cl; // CL is valid only in the context of the module (and its scope)
    

    MethodDescChunk     *m_pChunks;

    WORD    m_wThreadStaticOffset;  // Offset which points to the TLS storage
    WORD    m_wContextStaticOffset; // Offset which points to the CLS storage
    WORD    m_wThreadStaticsSize;   // Size of TLS fields 
    WORD    m_wContextStaticsSize;  // Size of CLS fields

    static MetaSig      *s_cctorSig;

public :
    EEClass * GetParentClass ();
    EEClass * GetCoClassForInterface();
    void SetupCoClassAttribInfo();
    
    EEClass ** GetParentClassPtr ();
    EEClass * GetEnclosingClass();  
   
    BOOL    HasRemotingProxyAttribute();

    void    GetGuid(GUID *pGuid, BOOL bGenerateIfNotFound);
    FieldDesc *GetFieldDescListRaw();
    WORD    GetNumInstanceFields();
    WORD    GetNumIntroducedInstanceFields();
    WORD    GetNumStaticFields();
    WORD    GetNumVtableSlots();
    void SetNumVtableSlots(WORD wNumVtableSlots);
    void IncrementNumVtableSlots();
    WORD    GetNumMethodSlots();
    WORD     GetNumGCPointerSeries();
    WORD    GetNumInterfaces();
    DWORD    GetAttrClass();
    DWORD    GetVMFlags();
    DWORD*   GetVMFlagsPtr();
    PSECURITY_PROPS  GetSecProps();
    BaseDomain * GetDomain();
    Assembly * GetAssembly();
    Module * GetModule();
    ClassLoader * GetClassLoader();
    mdTypeDef  GetCl();
    InterfaceInfo_t * GetInterfaceMap();
    int    IsInited();
    DWORD  IsResolved();
    DWORD  IsRestored();

    DWORD IsComClassInterface();
    VOID SetIsComClassInterface();

    DWORD  IsRestoring();
    int    IsInitedAndRestored();
    DWORD  IsInitError();
    DWORD  IsValueClass();
    void   SetValueClass();
    DWORD  IsShared();
    DWORD  IsValueTypeClass();
    DWORD  IsObjectClass();

    DWORD  IsAnyDelegateClass();
    DWORD  IsDelegateClass();
    DWORD  IsSingleDelegateClass();
    DWORD  IsMultiDelegateClass();
    DWORD  IsAnyDelegateExact();
    DWORD  IsSingleDelegateExact();
    DWORD  IsMultiDelegateExact();
    void   SetIsSingleDelegate();
    void   SetIsMultiDelegate();

    BOOL   IsContextful();
    BOOL   IsMarshaledByRef();
    BOOL   IsAlign8Candidate();
    void   SetAlign8Candidate();
    void   SetContextful();
    void   SetMarshaledByRef();
    BOOL   IsConfigChecked();
    void   SetConfigChecked();
    BOOL   IsRemoteActivated();
    void   SetRemoteActivated();    


#if CHECK_APP_DOMAIN_LEAKS

    BOOL   IsAppDomainAgile();
    BOOL   IsCheckAppDomainAgile();
    BOOL   IsAppDomainAgilityDone();
    void   SetAppDomainAgile();
    void   SetCheckAppDomainAgile();
    void   SetAppDomainAgilityDone();

    BOOL   IsTypesafeAppDomainAgile();
    BOOL   IsNeverAppDomainAgile();

    HRESULT SetAppDomainAgileAttribute(BOOL fForceSet = FALSE);

#endif

    BOOL   IsCCWAppDomainAgile();
    void   SetCCWAppDomainAgile();

    void SetCCWAppDomainAgileAttribute();

    MethodDescChunk *GetChunk();
    void AddChunk(MethodDescChunk *chunk);

    void  SetResolved();
    void  SetClassInitError();
    void  SetClassConstructor();
    void  SetInited();
    void  SetHasLayout();
    void  SetHasOverLayedFields();
    void  SetIsNested();
    DWORD  IsInterface();
    BOOL   IsSharedInterface();
    DWORD  IsArrayClass();
    DWORD  IsAbstract();
    DWORD  IsSealed();
    DWORD  IsComImport();
    BOOL   IsExtensibleRCW();

    DWORD HasVarSizedInstances();
    void InitInterfaceVTableMap();

    CorIfaceAttr GetComInterfaceType();
    CorClassIfaceAttr GetComClassInterfaceType();

    void GetEventInterfaceInfo(EEClass **ppSrcItfClass, EEClass **ppEvProvClass);
    EEClass *GetDefItfForComClassItf();

    BOOL ContainsStackPtr() 
    {
        return m_VMFlags & VMFLAG_CONTAINS_STACK_PTR;
    }

    // class has layout
    BOOL HasLayout()
    {
        return m_VMFlags & VMFLAG_HASLAYOUT;
    }

    BOOL HasOverLayedField()
    {
        return m_VMFlags & VMFLAG_HASOVERLAYEDFIELDS;
    }

    BOOL HasExplicitFieldOffsetLayout()
    {
        return IsTdExplicitLayout(GetAttrClass()) && HasLayout();
    }

    BOOL IsNested()
    {
        return m_VMFlags & VMFLAG_ISNESTED;
    }

    BOOL IsClass()
    {
        return !IsEnum() && !IsInterface() && !IsValueClass();
    }

    DWORD GetProtection()
    {
        return (m_dwAttrClass & tdVisibilityMask);
    }

    // class is blittable
    BOOL IsBlittable();

    // Can the type be seen outside the assembly
    DWORD IsExternallyVisible();

    //
    // Security properties accessor methods
    //

    SecurityProperties* GetSecurityProperties();
    BOOL RequiresLinktimeCheck();
    BOOL RequiresInheritanceCheck();
    BOOL RequiresNonCasLinktimeCheck();
    BOOL RequiresCasInheritanceCheck();
    BOOL RequiresNonCasInheritanceCheck();

    void *operator new(size_t size, ClassLoader *pLoader);
    void destruct();

    // We find a lot of information from the VTable.  But sometimes the VTable is a
    // thunking layer rather than the true type's VTable.  For instance, context
    // proxies use a single VTable for proxies to all the types we've loaded.
    // The following service adjusts a EEClass based on the supplied instance.  As
    // we add new thunking layers, we just need to teach this service how to navigate
    // through them.
    EEClass *AdjustForThunking(OBJECTREF or);
    BOOL     IsThunking()       { return m_pMethodTable->IsThunking(); }


    // Helper routines for the macros defined at the top of this class.
    // You probably should not use these functions directly.
    LPUTF8 _GetFullyQualifiedNameForClassNestedAware(LPUTF8 buf, DWORD dwBuffer);
    LPWSTR _GetFullyQualifiedNameForClassNestedAware(LPWSTR buf, DWORD dwBuffer);
    LPUTF8 _GetFullyQualifiedNameForClass(LPUTF8 buf, DWORD dwBuffer);
    LPWSTR _GetFullyQualifiedNameForClass(LPWSTR buf, DWORD dwBuffer);

    LPCUTF8 GetFullyQualifiedNameInfo(LPCUTF8 *ppszNamespace);

    // Similar to the above, but the caller provides the buffer.
    HRESULT StoreFullyQualifiedName(LPUTF8 pszFullyQualifiedName, DWORD cBuffer, LPCUTF8 pszNamespace, LPCUTF8 pszName);
    HRESULT StoreFullyQualifiedName(LPWSTR pszFullyQualifiedName, DWORD cBuffer, LPCUTF8 pszNamespace, LPCUTF8 pszName);

        // Method to find an interface in the type.
    InterfaceInfo_t* FindInterface(MethodTable *pMT);

        // Methods used to determine if a type supports a given interface.
    BOOL        StaticSupportsInterface(MethodTable *pInterfaceMT);
    BOOL        SupportsInterface(OBJECTREF pObject, MethodTable *pMT);
    BOOL        ComObjectSupportsInterface(OBJECTREF pObj, MethodTable* pMT);

    MethodDesc *FindMethod(LPCUTF8 pwzName, LPHARDCODEDMETASIG pwzSignature, MethodTable *pDefMT = NULL, BOOL bCaseSensitive = TRUE);
        // typeHnd is the type handle associated with the class being looked up.
        // It has additional information in the case of a shared class (Arrays)
    MethodDesc *FindMethod(LPCUTF8 pszName, 
                           PCCOR_SIGNATURE pSignature, DWORD cSignature, 
                           Module* pModule, 
                           DWORD dwRequiredAttributes,  // Pass in mdTokenNil if no attributes need to be matched
                           MethodTable *pDefMT = NULL, 
                           BOOL bCaseSensitive = TRUE, 
                           TypeHandle typeHnd=TypeHandle());
    MethodDesc *FindMethod(mdMethodDef mb);
    MethodDesc *InterfaceFindMethod(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, DWORD *slotNum, BOOL bCaseSensitive = TRUE);

    MethodDesc *FindPropertyMethod(LPCUTF8 pszName, EnumPropertyMethods Method, BOOL bCaseSensitive = TRUE);
    MethodDesc *FindEventMethod(LPCUTF8 pszName, EnumEventMethods Method, BOOL bCaseSensitive = TRUE);

    MethodDesc *FindMethodByName(LPCUTF8 pszName, BOOL bCaseSensitive = TRUE);

    FieldDesc *FindField(LPCUTF8 pszName, LPHARDCODEDMETASIG pszSignature, BOOL bCaseSensitive = TRUE);
#ifndef BJ_HACK
    FieldDesc *FindField(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, BOOL bCaseSensitive = TRUE);
#define FindField_Int FindField
#else
    FieldDesc *FindField(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, BOOL bCaseSensitive = TRUE)
    {
        return (FindFieldInherited(pszName, pSignature, cSignature, pModule, bCaseSensitive));
    }
    FieldDesc *FindField_Int(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, BOOL bCaseSensitive = TRUE);
#endif

    FieldDesc *FindFieldInherited(LPCUTF8 pzName, LPHARDCODEDMETASIG pzSignature, BOOL bCaseSensitive = TRUE);
    FieldDesc *FindFieldInherited(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, BOOL bCaseSensitive = TRUE);

    MethodDesc *FindConstructor(LPHARDCODEDMETASIG pwzSignature);
    MethodDesc *FindConstructor(PCCOR_SIGNATURE pSignature,DWORD cSignature, Module* pModule);

    // Tests the throwable keeping the debug asserts quite. Since, class canbe built while GC is enabled or
    // disabled this routine helps remove unnecessary asserts.
    BOOL TestThrowable(OBJECTREF* pThrowable);



    HRESULT BuildMethodTable(Module *pModule, 
                             mdToken cl, 
                             BuildingInterfaceInfo_t *pBuildingInterfaceList, 
                             const LayoutRawFieldInfo *pLayoutRawFieldInfos,
                             OBJECTREF *pThrowable);

#ifdef DEBUGGING_SUPPORTED
    void NotifyDebuggerLoad();
    BOOL NotifyDebuggerAttach(AppDomain *domain, BOOL attaching);
    void NotifyDebuggerDetach(AppDomain *domain);
#endif // DEBUGGING_SUPPORTED

#ifdef EnC_SUPPORTED
    HRESULT AddMethod(mdMethodDef methodDef, COR_ILMETHOD *pNewCode);
    HRESULT AddField(mdFieldDef fieldDesc);
    HRESULT FixupFieldDescForEnC(EnCFieldDesc *pFD, mdFieldDef fieldDef);
#endif // EnC_SUPPORTED

    // @todo: This function should go away once we're done with scopes completely - prasadt.
    IMDInternalImport *GetMDImport();    
    MethodTable* GetMethodTable();
    SLOT *GetVtable();
    SLOT *GetStaticsTable();
    MethodDesc* GetMethodDescForSlot(DWORD slot);
    MethodDesc* GetUnboxingMethodDescForValueClassMethod(MethodDesc *pMD);
    MethodDesc* GetMethodDescForUnboxingValueClassMethod(MethodDesc *pMD);
    SLOT *GetMethodSlot(MethodDesc* method);    // Works for both static and virtual method
    SLOT GetFixedUpSlot(DWORD slot);
    MethodDesc* GetStaticMethodDescForSlot(DWORD slot);
    MethodDesc* GetUnknownMethodDescForSlot(DWORD slot);
    static MethodDesc* GetUnknownMethodDescForSlotAddress(SLOT addr);
    void SetMethodTableForTransparentProxy(MethodTable*  pMT);
    void SetMethodTable(MethodTable*  pMT);

    //==========================================================================
    // This function is very specific about how it constructs a EEClass.
    //==========================================================================
    static HRESULT CreateClass(Module *pModule, mdTypeDef cl, BOOL fHasLayout, BOOL fDelegate, BOOL fIsBlob, BOOL fIsEnum, EEClass** ppEEClass);
    static void CreateObjectClassMethodHashBitmap(EEClass *pObjectClass);

    // Warning, this field can be byte unaligned
    DWORD   GetNumInstanceFieldBytes();
    DWORD   GetAlignedNumInstanceFieldBytes();

    // Restore preloaded class
    BOOL CheckRestore();
    void Restore();

    // called from MethodTable::CheckRunClassInit().  The class wasn't marked as
    // inited while we were there, so let's attempt to do the work.
    BOOL            DoRunClassInit(OBJECTREF *pThrowable, 
                                   AppDomain *pDomain = NULL,
                                   DomainLocalClass **ppLocalClass = NULL);

    DomainLocalClass *GetDomainLocalClassNoLock(AppDomain *pDomain);
    

    DWORD HasFieldsWhichMustBeInited()
    {
        return (m_VMFlags & VMFLAG_HAS_FIELDS_WHICH_MUST_BE_INITED);
    }
    DWORD HasNonPublicFields()
    {
        return (m_VMFlags & VMFLAG_HASNONPUBLICFIELDS);
    }

    //==========================================================================
    // Mechanism for accessing the COM+ Exposed class object (the one programmers
    // see via reflection).
    //==========================================================================

    // There are two version of GetExposedClassObject.  The GetExposedClassObject()
    //  method will get the class object.  If it doesn't exist it will be created.
    //  GetExistingExposedClassObject() will reteurn null if the Class object doesn't exist.
    OBJECTREF      GetExposedClassObject();
    FORCEINLINE OBJECTREF      GetExistingExposedClassObject() {
        if (m_ExposedClassObject == NULL)
            return NULL;
        else
            return *m_ExposedClassObject;
    }
    
    static HRESULT GetDescFromMemberRef(Module *pModule,               // Scope for the memberRef and mdEnclosingRef
                                        mdMemberRef MemberRef,         // MemberRef to resolve
                                        mdToken mdEnclosingRef,        // Optional typeref not to load (allows self-references) 
                                                                       // Returns S_FALSE if it equals parent token (ppDesc is not set)
                                        void **ppDesc,                 // Returned method desc, hr will equal S_OK
                                        BOOL *pfIsMethod,              // Returns TRUE if **ppDesc is a MethodDesc, FALSE if it is a FieldDesc 
                                        OBJECTREF *pThrowable = NULL); // Error must be GC protected

    static HRESULT GetDescFromMemberRef(Module *pModule,    // See above for description of parameters.
                                        mdMemberRef MemberRef, 
                                        void **ppDesc, 
                                        BOOL *pfIsMethod,              // Returns TRUE if **ppDesc is a MethodDesc, FALSE if it is a FieldDesc 
                                        OBJECTREF *pThrowable = NULL)
    { 
        HRESULT hr = GetDescFromMemberRef(pModule, MemberRef, mdTypeRefNil, ppDesc, pfIsMethod, pThrowable);
        if(hr == S_FALSE) hr = E_FAIL; // not a valid return 
        return hr;
    }
    
    static HRESULT GetMethodDescFromMemberRef(Module *pModule, mdMemberRef MemberRef, MethodDesc **ppMethodDesc, OBJECTREF *pThrowable = NULL);
    static HRESULT GetFieldDescFromMemberRef(Module *pModule, mdMemberRef MemberRef, FieldDesc **ppFieldDesc, OBJECTREF *pThrowable = NULL);

    // Backpatch up and down the class hierarchy, as aggressively as possible
    static BOOL PatchAggressively(MethodDesc *pMD, SLOT pCode);

    static void DisableBackpatching();
    static void EnableBackpatching();
    void UnlinkChildrenInDomain(AppDomain *pDomain);

    // COM interop helpers
    // accessors for m_pComData
    LPVOID         GetComClassFactory();
    LPVOID         GetComCallWrapperTemplate();
    void           SetComClassFactory(LPVOID pComData);
    void           SetComCallWrapperTemplate(LPVOID pComData);

    // Helper GetParentComPlusClass, skips over COM class in the hierarchy
    EEClass* GetParentComPlusClass();

    // The following two methods are to support enum types.    
    BOOL    IsEnum();
    void    SetEnum();

    void GetExtent(BYTE **ppStart, BYTE **ppEnd);

    // Does this value class one of our special ELEMENT_TYPE* types?
    BOOL    IsTruePrimitive();

    HRESULT Save(DataImage *image);
    HRESULT Fixup(DataImage *image, MethodTable *pMethodTable, DWORD *pRidToCodeRVAMap);

    // Unload class on app domain termination
    void Unload();

    // Return the offsets which store pointers to special statics like
    // thread local statics or context local statics
    inline WORD    GetThreadLocalStaticOffset() { return m_wThreadStaticOffset; }
    inline WORD    GetContextLocalStaticOffset() { return m_wContextStaticOffset; }

    // Return the total size of the special statics like thread local or context
    // local statics
    inline WORD    GetThreadLocalStaticsSize() { return m_wThreadStaticsSize; }
    inline WORD    GetContextLocalStaticsSize() { return m_wContextStaticsSize; }

protected:
    // m_ExposedClassObject is a RuntimeType instance for this class.  But
    // do NOT use it for Arrays or remoted objects!  All arrays of objects 
    // share the same EEClass.  -- BrianGru, 9/11/2000
    OBJECTREF      *m_ExposedClassObject;   
    LPVOID         m_pccwTemplate;  // com specific data
    LPVOID         m_pComclassfac; // com speciic data

public:
    EEClassLayoutInfo *GetLayoutInfo();

    UINT32          AssignInterfaceId();
    UINT32          GetInterfaceId();

    static HRESULT MapInterfaceFromSystem(AppDomain* pDomain, MethodTable* pTable);
    HRESULT MapSystemInterfacesToDomain(AppDomain* pDomain);

    // Used for debugging class layout. Dumps to the debug console
    // when debug is true.
    void DebugDumpVtable(LPCUTF8 pszClassName, BOOL debug);
    void DebugDumpFieldLayout(LPCUTF8 pszClassName, BOOL debug);
    void DebugRecursivelyDumpInstanceFields(LPCUTF8 pszClassName, BOOL debug);
    void DebugDumpGCDesc(LPCUTF8 pszClassName, BOOL debug);
};

inline EEClass *EEClass::GetParentClass ()
{
    _ASSERTE(IsRestored() || IsRestoring());

    return m_pParentClass;
}

inline EEClass* EEClass::GetCoClassForInterface()
{
    _ASSERTE(IsInterface());
    if (m_pCoClassForIntf == NULL)
    {
        if (IsComClassInterface())
        {
            SetupCoClassAttribInfo();
        }
    }
    
    return m_pCoClassForIntf;
};

inline EEClass **EEClass::GetParentClassPtr ()
{
    _ASSERTE(IsRestored() || IsRestoring());

    return &m_pParentClass;
}


inline FieldDesc *EEClass::GetFieldDescListRaw()
{
    // Careful about using this method. If it's possible that fields may have been added via EnC, then
    // must use the FieldDescIterator as any fields added via EnC won't be in the raw list
    return m_pFieldDescList;
}

inline WORD   EEClass::GetNumInstanceFields()
{
    return m_wNumInstanceFields;
}

inline WORD   EEClass::GetNumIntroducedInstanceFields()
{
    _ASSERTE(IsRestored() || IsValueClass());
    // Special check for IsRestored - local variable value types may be 
    // reachable but not restored.
    if (IsRestored() && GetParentClass() != NULL)
        return m_wNumInstanceFields - GetParentClass()->GetNumInstanceFields();
    return m_wNumInstanceFields;
}

inline WORD   EEClass::GetNumStaticFields()
{
    return m_wNumStaticFields;
}

inline WORD   EEClass::GetNumVtableSlots()
{
    return m_wNumVtableSlots;
}

inline void EEClass::SetNumVtableSlots(WORD wNumVtableSlots) 
{ 
    m_wNumVtableSlots = wNumVtableSlots; 
}

inline void EEClass::IncrementNumVtableSlots() 
{ 
    m_wNumVtableSlots++; 
}

inline WORD   EEClass::GetNumMethodSlots()
{
    return m_wNumMethodSlots;
}

inline WORD    EEClass::GetNumGCPointerSeries()
{
    return m_wNumGCPointerSeries;
}

inline WORD   EEClass::GetNumInterfaces()
{
    return m_wNumInterfaces;
}

inline DWORD   EEClass::GetAttrClass()
{
    return m_dwAttrClass;
}

inline DWORD   EEClass::GetVMFlags()
{
    return m_VMFlags;
}

inline DWORD*  EEClass::GetVMFlagsPtr()
{
    return &m_VMFlags;
}

inline PSECURITY_PROPS EEClass::GetSecProps()
{
    return &m_SecProps ;
}

inline Module *EEClass::GetModule()
{
    return GetMethodTable()->GetModule();
}

inline mdTypeDef EEClass::GetCl()
{
    return m_cl; // CL is valid only in the context of the module (and its scope)
}

inline ClassLoader *EEClass::GetClassLoader()
{
    // Lazy init the loader pointer, if necessary.
    
    if (m_pLoader == NULL)
    {
        _ASSERTE(m_pMethodTable != NULL);
        m_pLoader = GetModule()->GetClassLoader();
        _ASSERTE(m_pLoader != NULL);
    }
        
    return m_pLoader;
}

inline InterfaceInfo_t *EEClass::GetInterfaceMap()
{
    return GetMethodTable()->GetInterfaceMap();
}

inline int EEClass::IsInited()
{
    return (m_VMFlags & VMFLAG_INITED);
}

inline DWORD EEClass::IsRestored()
{
    return !(m_VMFlags & VMFLAG_UNRESTORED);
}

inline DWORD EEClass::IsComClassInterface()
{
    return (m_VMFlags & VMFLAG_HASCOCLASSATTRIB);
}

inline VOID EEClass::SetIsComClassInterface()
{
    m_VMFlags |= VMFLAG_HASCOCLASSATTRIB;
}

inline DWORD EEClass::IsRestoring()
{
    return (m_VMFlags & VMFLAG_RESTORING);
}

inline int EEClass::IsInitedAndRestored()
{
    return (m_VMFlags & (VMFLAG_INITED|VMFLAG_UNRESTORED)) == VMFLAG_INITED;
}

inline DWORD EEClass::IsResolved()
{
    return (m_VMFlags & VMFLAG_RESOLVED);
}

inline DWORD EEClass::IsInitError()
{
    return (m_VMFlags & VMFLAG_CLASS_INIT_ERROR);
}

inline DWORD EEClass::IsValueClass()
{
    return (m_VMFlags & VMFLAG_VALUETYPE);
}

inline void EEClass::SetValueClass()
{
    m_VMFlags |= VMFLAG_VALUETYPE;
}

inline DWORD EEClass::IsShared()
{
    return m_VMFlags & VMFLAG_SHARED;
}

inline DWORD EEClass::IsObjectClass()
{
    return (this == g_pObjectClass->GetClass());
}

// Is this System.ValueType?
inline DWORD EEClass::IsValueTypeClass()
{
    return this == g_pValueTypeClass->GetClass();
}

// Is this a contextful class?
inline BOOL EEClass::IsContextful()
{
    return m_VMFlags & VMFLAG_CONTEXTFUL;
}

// Is this class marshaled by reference
inline BOOL EEClass::IsMarshaledByRef()
{
    return m_VMFlags & VMFLAG_MARSHALEDBYREF;
}

inline BOOL EEClass::IsConfigChecked()
{    
    return m_VMFlags & VMFLAG_CONFIG_CHECKED;   
}

inline void EEClass::SetConfigChecked()
{
    // remembers that we went through the rigorous
    // checks to decide whether this class should be
    // activated locally or remote
    FastInterlockOr(
        (ULONG *) &m_VMFlags, 
        VMFLAG_CONFIG_CHECKED);
}

inline BOOL EEClass::IsRemoteActivated()
{
    // These methods are meant for strictly MBR classes
    _ASSERTE(!IsContextful() && IsMarshaledByRef());
    
    // We have to have gone through the long path
    // at least once to rely on this flag.
    _ASSERTE(IsConfigChecked());
    
    return m_VMFlags & VMFLAG_REMOTE_ACTIVATED;
}

inline void EEClass::SetRemoteActivated()
{
    FastInterlockOr(
        (ULONG *) &m_VMFlags, 
        VMFLAG_REMOTE_ACTIVATED|VMFLAG_CONFIG_CHECKED);
}


inline BOOL EEClass::HasRemotingProxyAttribute()
{
    return m_VMFlags & VMFLAG_REMOTING_PROXY_ATTRIBUTE;
}

inline BOOL EEClass::IsEnum()
{
    return (m_VMFlags & VMFLAG_ENUMTYPE);
}

inline BOOL EEClass::IsTruePrimitive()
{
    return (m_VMFlags & VMFLAG_TRUEPRIMITIVE);
}

inline void EEClass::SetEnum()
{
    m_VMFlags |= VMFLAG_ENUMTYPE;
}

inline BOOL EEClass::IsAlign8Candidate()
{
    return (m_VMFlags & VMFLAG_PREFER_ALIGN8);
}

inline void EEClass::SetAlign8Candidate()
{
    m_VMFlags |= VMFLAG_PREFER_ALIGN8;
}


inline void EEClass::SetContextful()
{
    COUNTER_ONLY(GetPrivatePerfCounters().m_Context.cClasses++);
    COUNTER_ONLY(GetGlobalPerfCounters().m_Context.cClasses++);

    m_VMFlags |= (VMFLAG_CONTEXTFUL | VMFLAG_MARSHALEDBYREF);
}

inline void EEClass::SetMarshaledByRef()
{
    m_VMFlags |= VMFLAG_MARSHALEDBYREF;
}

inline MethodDescChunk *EEClass::GetChunk()
{
    return m_pChunks;
}

inline void EEClass::SetResolved()
{
    FastInterlockOr((ULONG *) &m_VMFlags, VMFLAG_RESOLVED);
}

inline void EEClass::SetClassInitError()
{
    _ASSERTE(!IsShared());

    FastInterlockOr((ULONG *) &m_VMFlags, VMFLAG_CLASS_INIT_ERROR);
}

inline void EEClass::SetClassConstructor()
{
    FastInterlockOr((ULONG *) &m_VMFlags, VMFLAG_CCTOR);
}

inline void EEClass::SetInited()
{
    _ASSERTE(!IsShared() || GetNumStaticFields() == 0);

    GetMethodTable()->SetClassInited();
}

inline void EEClass::SetHasLayout()
{
    m_VMFlags |= VMFLAG_HASLAYOUT;
}

inline void EEClass::SetHasOverLayedFields()
{
    m_VMFlags |= VMFLAG_HASOVERLAYEDFIELDS;
}

inline void EEClass::SetIsNested()
{
    m_VMFlags |= VMFLAG_ISNESTED;
}

inline DWORD EEClass::IsInterface()
{
    return IsTdInterface(m_dwAttrClass);
}

inline DWORD EEClass::IsExternallyVisible()
{
    if (IsTdPublic(m_dwAttrClass))
        return TRUE;
    if (!IsTdNestedPublic(m_dwAttrClass))
        return FALSE;
    EEClass *pClass = this;
    while ((pClass = pClass->GetEnclosingClass()) != NULL && IsTdNestedPublic(pClass->m_dwAttrClass))
         ;
    return pClass && IsTdPublic(pClass->m_dwAttrClass);
}


inline DWORD EEClass::IsArrayClass()
{
        // m_pMethodTable could be 0 when doing stand alone importation
    _ASSERTE(m_pMethodTable == 0 || ((m_VMFlags & VMFLAG_ARRAY_CLASS) != 0) == (GetMethodTable()->IsArray() != 0));
    return (m_VMFlags & VMFLAG_ARRAY_CLASS);
}

inline DWORD EEClass::HasVarSizedInstances()
{
    return this == g_pStringClass->GetClass() || IsArrayClass();
}

inline DWORD EEClass::IsAbstract()
{
    return IsTdAbstract(m_dwAttrClass);
}

inline DWORD  EEClass::IsSealed()
{
    return IsTdSealed(m_dwAttrClass);
}

inline DWORD EEClass::IsComImport()
{
    return IsTdImport(m_dwAttrClass);
}

inline BOOL EEClass::IsExtensibleRCW()
{
    return GetMethodTable()->IsExtensibleRCW();
}

inline DWORD EEClass::IsAnyDelegateClass()
{
    return IsSingleDelegateClass() || IsMultiDelegateClass();
}

inline DWORD EEClass::IsDelegateClass()
{
    return IsSingleDelegateClass();
}

inline DWORD EEClass::IsSingleDelegateClass()
{
    return (m_VMFlags & VMFLAG_ISSINGLEDELEGATE);
}

inline DWORD EEClass::IsMultiDelegateClass()
{
    return (m_VMFlags & VMFLAG_ISMULTIDELEGATE);
}

inline DWORD EEClass::IsAnyDelegateExact()
{
    return IsSingleDelegateExact() || IsMultiDelegateExact();
}

inline DWORD EEClass::IsSingleDelegateExact()
{
    return this->GetMethodTable() == g_pDelegateClass;
}

inline DWORD EEClass::IsMultiDelegateExact()
{
    return this->GetMethodTable() == g_pMultiDelegateClass;
}

inline void EEClass::SetIsSingleDelegate()
{
    m_VMFlags |= VMFLAG_ISSINGLEDELEGATE;
}

inline void EEClass::SetIsMultiDelegate()
{
    m_VMFlags |= VMFLAG_ISMULTIDELEGATE;
}

inline CorIfaceAttr EEClass::GetComInterfaceType()
{
    return m_pMethodTable->GetComInterfaceType();
}

#if CHECK_APP_DOMAIN_LEAKS

// This flag is set (in a checked build only?) for classes whose 
// instances are always app domain agile.  This can 
// be either because of type system guarantees or because
// the class is explicitly marked.

inline BOOL EEClass::IsAppDomainAgile()
{
    return (m_VMFlags & VMFLAG_APP_DOMAIN_AGILE);
}

inline void EEClass::SetAppDomainAgile()
{
    m_VMFlags |= VMFLAG_APP_DOMAIN_AGILE;
}

// This flag is set in a checked build for classes whose 
// instances may be marked app domain agile, but agility
// isn't guaranteed by type safety.  The JIT will compile
// in extra checks to field assignment on some fields
// in such a class.

inline BOOL EEClass::IsCheckAppDomainAgile()
{
    return (m_VMFlags & VMFLAG_CHECK_APP_DOMAIN_AGILE);
}

inline void EEClass::SetCheckAppDomainAgile()
{
    m_VMFlags |= VMFLAG_CHECK_APP_DOMAIN_AGILE;
}

// This flag is set in a checked build to indicate that the
// appdomain agility for a class had been set. This is used
// for debugging purposes to make sure that we don't allocate
// an object before the agility is set.

inline BOOL EEClass::IsAppDomainAgilityDone()
{
    return (m_VMFlags & VMFLAG_APP_DOMAIN_AGILITY_DONE);
}

inline void EEClass::SetAppDomainAgilityDone()
{
    m_VMFlags |= VMFLAG_APP_DOMAIN_AGILITY_DONE;
}

//
// This predicate checks whether or not the class is "naturally"
// app domain agile - that is:
//      (1) it is in the system domain
//      (2) all the fields are app domain agile
//      (3) it has no finalizer
//
// Or, this also returns true for a proxy type which is allowed
// to have cross app domain refs.
//

inline BOOL EEClass::IsTypesafeAppDomainAgile()
{
    return IsAppDomainAgile() && !IsCheckAppDomainAgile();
}

//
// This predictate tests whether any instances are allowed
// to be app domain agile.  
//

inline BOOL EEClass::IsNeverAppDomainAgile()
{
    return !IsAppDomainAgile() && !IsCheckAppDomainAgile();
}

#endif // CHECK_APP_DOMAIN_AGILE

inline BOOL MethodTable::IsAgileAndFinalizable()
{
    // Right now, System.Thread is the only case of this. 
    // Things should stay this way - please don't change without talking to EE team.
    return this == g_pThreadClass;
}

// This flag is set to indicate that the CCW's created to expose 
// managed types to COM are agile or not.

inline BOOL EEClass::IsCCWAppDomainAgile()
{
    return (m_VMFlags & VMFLAG_CCW_APP_DOMAIN_AGILE);
}

inline void EEClass::SetCCWAppDomainAgile()
{
    m_VMFlags |= VMFLAG_CCW_APP_DOMAIN_AGILE;
}

inline void MethodTable::CheckRestore()
{
    if (!IsRestored())
        GetClass()->CheckRestore();
}
    
inline BOOL MethodTable::IsValueClass()
{
    return GetClass()->IsValueClass();
}

inline BOOL MethodTable::IsContextful()
{
    return m_pEEClass->IsContextful();
}

inline BOOL MethodTable::IsMarshaledByRef()
{
    return m_pEEClass->IsMarshaledByRef();
}

inline BOOL MethodTable::IsExtensibleRCW()
{
    return IsComObjectType() && !GetClass()->IsComImport();
}

inline CorClassIfaceAttr MethodTable::GetComClassInterfaceType() 
{ 
    return m_pEEClass->GetComClassInterfaceType(); 
}

//
// Security properties accessor methods
//

inline SecurityProperties* EEClass::GetSecurityProperties()
{
    SecurityProperties* psp = PSPS_FROM_PSECURITY_PROPS(&m_SecProps);
    _ASSERTE((IsArrayClass() || psp != NULL) &&
             "Security properties object expected for non-array class");
    return psp;
}

inline BOOL EEClass::RequiresLinktimeCheck()
{
    PSecurityProperties psp = GetSecurityProperties();
    return psp && psp->RequiresLinktimeCheck();
}

inline BOOL EEClass::RequiresInheritanceCheck()
{
    PSecurityProperties psp = GetSecurityProperties();
    return psp && psp->RequiresInheritanceCheck();
}

inline BOOL EEClass::RequiresNonCasLinktimeCheck()
{
    PSecurityProperties psp = GetSecurityProperties();
    return psp && psp->RequiresNonCasLinktimeCheck();
}

inline BOOL EEClass::RequiresCasInheritanceCheck()
{
    PSecurityProperties psp = GetSecurityProperties();
    return psp && psp->RequiresCasInheritanceCheck();
}

inline BOOL EEClass::RequiresNonCasInheritanceCheck()
{
    PSecurityProperties psp = GetSecurityProperties();
    return psp && psp->RequiresNonCasInheritanceCheck();
}

inline IMDInternalImport* EEClass::GetMDImport()
{
    return GetModule()->GetMDImport();
}

inline MethodTable* EEClass::GetMethodTable()
{
    return m_pMethodTable;
}

inline SLOT *EEClass::GetVtable()
{
    _ASSERTE(m_pMethodTable != NULL);
    return m_pMethodTable->GetVtable();
}

inline void EEClass::SetMethodTableForTransparentProxy(MethodTable*  pMT)
{
    // Transparent proxy class' true method table 
    // is replaced by a global thunk table 

    _ASSERTE(pMT->IsTransparentProxyType() && 
            m_pMethodTable->IsTransparentProxyType());

    m_pMethodTable = pMT;
}

inline void EEClass::SetMethodTable(MethodTable*  pMT)
{
    m_pMethodTable = pMT;
}

inline DWORD   EEClass::GetNumInstanceFieldBytes()
{
    return(m_dwNumInstanceFieldBytes);
}

inline DWORD   EEClass::GetAlignedNumInstanceFieldBytes()
{
    return ((m_dwNumInstanceFieldBytes + 3) & (~3));
}

inline LPVOID EEClass::GetComCallWrapperTemplate()
{
    return m_pccwTemplate;
}

inline LPVOID EEClass::GetComClassFactory()
{
    return m_pComclassfac;
}

// Helper GetParentComPlusClass, skips over COM class in the hierarchy
inline EEClass* EEClass::GetParentComPlusClass()
{
    if (GetParentClass() && GetParentClass()->IsComImport())
    {
        // skip Com Import and ComObject class
        _ASSERTE(GetParentClass()->GetParentClass() != NULL);
        _ASSERTE(GetParentClass()->GetParentClass()->GetParentClass() != NULL);
        _ASSERTE(GetParentClass()->GetParentClass()->GetParentClass()->GetParentClass() != NULL);
        _ASSERTE(GetParentClass()->GetParentClass()->GetParentClass()->IsMarshaledByRef());
        _ASSERTE(GetParentClass()->GetParentClass()->GetParentClass()->GetParentClass()->IsObjectClass());
        return GetParentClass()->GetParentClass()->GetParentClass();
    }
    else
        return GetParentClass();
}

inline void EEClass::SetComCallWrapperTemplate(LPVOID pComData)
{
    m_pccwTemplate = pComData;
}


inline void EEClass::SetComClassFactory(LPVOID pComData)
{
    m_pComclassfac = pComData;
}

inline DWORD EEClass::InstanceSliceOffsetForExplicit(BOOL containsPointers)
{
    DWORD dwInstanceSliceOffset = (GetParentClass() != NULL) ? GetParentClass()->m_dwNumInstanceFieldBytes : 0;
    // Since this class contains pointers, align it on an DWORD boundary if we aren't already
    if (containsPointers && dwInstanceSliceOffset & 3)
        dwInstanceSliceOffset = (dwInstanceSliceOffset+3) & (~3);
    return dwInstanceSliceOffset;
}


typedef EEClass *LPEEClass;


class LayoutEEClass : public EEClass
{
public:
    EEClassLayoutInfo m_LayoutInfo;

    LayoutEEClass(ClassLoader *pLoader) : EEClass(pLoader)
    {
#ifdef _DEBUG
        FillMemory(&m_LayoutInfo, sizeof(m_LayoutInfo), 0xcc);
#endif
    }
};

class UMThunkMarshInfo;

class DelegateEEClass : public EEClass
{
public:
    Stub    *m_pStaticShuffleThunk;
    MethodDesc *m_pInvokeMethod;
    UMThunkMarshInfo *m_pUMThunkMarshInfo;
    MethodDesc *m_pBeginInvokeMethod;
    MethodDesc *m_pEndInvokeMethod;


    DelegateEEClass(ClassLoader *pLoader) : EEClass(pLoader)
    {
        m_pStaticShuffleThunk = NULL;
        m_pInvokeMethod = NULL;
        m_pUMThunkMarshInfo = NULL;
        m_pBeginInvokeMethod = NULL;
        m_pEndInvokeMethod = NULL;
    }

    BOOL CanCastTo(DelegateEEClass* toType);
};

class EnumEEClass : public EEClass
{
    friend EEClass;

 private:

    DWORD           m_countPlusOne; // biased by 1 so zero can be used as uninit flag
    union
    {
        void        *m_values;
        BYTE        *m_byteValues;
        USHORT      *m_shortValues;
        UINT        *m_intValues;
        UINT64      *m_longValues;
    };
    LPCUTF8         *m_names;

 public:
    EnumEEClass(ClassLoader *pLoader) : EEClass(pLoader)
    {
        // Rely on zero init from LoaderHeap
    }

    BOOL EnumTablesBuilt() { return m_countPlusOne > 0; }

    DWORD GetEnumCount() { return m_countPlusOne-1; } // note -1 because of bias

    int GetEnumLogSize();

    // These all return arrays of size GetEnumCount() : 
    BYTE *GetEnumByteValues() { return m_byteValues; }
    USHORT *GetEnumShortValues() { return m_shortValues; }
    UINT *GetEnumIntValues() { return m_intValues; }
    UINT64 *GetEnumLongValues() { return m_longValues; }
    LPCUTF8 *GetEnumNames() { return m_names; }

    enum
    {
        NOT_FOUND = 1
    };

    DWORD FindEnumValueIndex(BYTE value);
    DWORD FindEnumValueIndex(USHORT value);
    DWORD FindEnumValueIndex(UINT value);
    DWORD FindEnumValueIndex(UINT64 value);
    DWORD FindEnumNameIndex(LPCUTF8 name);
    
    HRESULT BuildEnumTables();
};


// Dynamically generated array class structure
class ArrayClass : public EEClass
{
    friend struct MEMBER_OFFSET_INFO(ArrayClass);
private:

    ArrayClass *    m_pNext;            // next array class loaded by the same classloader

    // Strike needs to be able to determine the offset of certain bitfields.
    // Bitfields can't be used with /offsetof/.
    // Thus, the union/structure combination is used to determine where the
    // bitfield begins, without adding any additional space overhead.
    union {
        struct
            {
            unsigned char m_dwRank_begin;
            unsigned char m_ElementType_begin;
            };
        struct {
            unsigned char m_dwRank : 8;

            // Cache of element type in m_ElementTypeHnd
            CorElementType  m_ElementType : 8;
        };
    };

    TypeHandle      m_ElementTypeHnd;
    MethodDesc*     m_elementCtor; // if is a value class array and has a default constructor, this is it
    
public:
    DWORD GetRank() {
        return m_dwRank;
    }
    void SetRank (unsigned Rank) {
        m_dwRank = Rank;
    }

    MethodDesc* GetElementCtor() {
        return(m_elementCtor);  
    }
    void SetElementCtor (MethodDesc *elementCtor) {
        m_elementCtor = elementCtor;
    }

    TypeHandle GetElementTypeHandle() {
        return m_ElementTypeHnd;
    }
    void SetElementTypeHandle (TypeHandle ElementTypeHnd) {
        m_ElementTypeHnd = ElementTypeHnd;
    }


    CorElementType GetElementType() {
        return m_ElementType;
    }
    void SetElementType(CorElementType ElementType) {
        m_ElementType = ElementType;
    }

    ArrayClass* GetNext () {
        return m_pNext;
    }
    void SetNext (ArrayClass *pNext) {
        m_pNext = pNext;
    }
//private:


    // Allocate a new MethodDesc for the methods we add to this class
    ArrayECallMethodDesc *AllocArrayMethodDesc(
                MethodDescChunk *pChunk,
                DWORD   dwIndex,
        LPCUTF8 pszMethodName,
        PCCOR_SIGNATURE pShortSig,
        DWORD   cShortSig,
        DWORD   dwNumArgs,
        DWORD   dwVtableSlot,
        CorInfoIntrinsics   intrinsicID = CORINFO_INTRINSIC_Illegal
    );

};

/*************************************************************************/
/* An ArrayTypeDesc represents a Array of some pointer type. */

class ArrayTypeDesc : public ParamTypeDesc
{
public:
    ArrayTypeDesc(MethodTable* arrayMT, TypeHandle elementType) :
        ParamTypeDesc(arrayMT->GetNormCorElementType(), arrayMT, elementType) {
        INDEBUG(Verify());
        }
            
        // placement new operator
    void* operator new(size_t size, void* spot) {   return (spot); }

    TypeHandle GetElementTypeHandle() {
        return GetTypeParam();
    }

    unsigned GetRank() {
        return(GetArrayClass()->GetRank());
    }

    MethodDesc* GetElementCtor() {
        return(GetArrayClass()->GetElementCtor());
    }

    INDEBUG(BOOL Verify();)

private:
    ArrayClass *GetArrayClass() {
        ArrayClass* ret = (ArrayClass *) m_TemplateMT->GetClass();
        _ASSERTE(ret->IsArrayClass());
        return ret;
    }

};

inline TypeHandle::TypeHandle(EEClass* aClass)
{
    m_asMT = aClass->GetMethodTable(); 
    INDEBUG(Verify());
}

inline ArrayTypeDesc* TypeHandle::AsArray()
{ 
    _ASSERTE(IsArray());
    return (ArrayTypeDesc*) AsTypeDesc();
}

inline BOOL TypeHandle::IsByRef() { 
    return(IsTypeDesc() && AsTypeDesc()->IsByRef());

}

inline MethodTable* TypeHandle:: GetMethodTable()                 
{
    if (IsUnsharedMT()) 
        return AsMethodTable();
    else
        return(AsTypeDesc()->GetMethodTable());
}

inline CorElementType TypeHandle::GetNormCorElementType() {
    if (IsUnsharedMT())
        return AsMethodTable()->GetNormCorElementType();
    else 
        return AsTypeDesc()->GetNormCorElementType();
}

inline EEClass* TypeHandle::GetClassOrTypeParam() {
    if (IsUnsharedMT())
        return AsMethodTable()->GetClass();

    _ASSERTE(AsTypeDesc()->GetNormCorElementType() >= ELEMENT_TYPE_PTR);
    return AsTypeDesc()->GetTypeParam().GetClassOrTypeParam();
}

inline MethodTable*  TypeDesc::GetMethodTable() {
    _ASSERTE(m_IsParamDesc);
    ParamTypeDesc* asParam = (ParamTypeDesc*) this;
    return(asParam->m_TemplateMT);
    }

inline TypeHandle TypeDesc::GetTypeParam() {
    _ASSERTE(m_IsParamDesc);
    ParamTypeDesc* asParam = (ParamTypeDesc*) this;
    return(asParam->m_Arg);
}

inline BaseDomain* TypeDesc::GetDomain() {
    return GetTypeParam().GetClassOrTypeParam()->GetDomain();
}

inline BOOL EEClass::IsBlittable()
{
    // Either we have an opaque bunch of bytes, or we have some fields that are
    // all isomorphic and explicitly layed out.
    return  ((m_VMFlags & VMFLAG_ISBLOBCLASS) != 0 && GetNumInstanceFields() == 0) ||
            (HasLayout() && ((LayoutEEClass*)this)->GetLayoutInfo()->IsBlittable());
}

inline UINT32 EEClass::GetInterfaceId()
{
      // This should only be called on interfaces.
    _ASSERTE(IsInterface());
    _ASSERTE(IsRestored() || IsRestoring());
    _ASSERTE(m_dwInterfaceId != -1);
    
    return m_dwInterfaceId;
}

//==========================================================================
// These routines manage the prestub (a bootstrapping stub that all
// FunctionDesc's are initialized with.)
//==========================================================================
BOOL InitPreStubManager();
#ifdef SHOULD_WE_CLEANUP
VOID TerminatePreStubManager();
#endif /* SHOULD_WE_CLEANUP */
Stub *ThePreStub();
Stub *TheUMThunkPreStub();


//-----------------------------------------------------------
// Invokes a specified non-static method on an object.
//-----------------------------------------------------------

void CallDefaultConstructor(OBJECTREF ref);

// NOTE: Please don't call these methods.  They binds to the constructor
// by doing name lookup, which is very expensive.
INT64 CallConstructor(LPHARDCODEDMETASIG szMetaSig, const BYTE *pArgs);
INT64 CallConstructor(LPHARDCODEDMETASIG szMetaSig, const __int64 *pArgs);

extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);

extern "C" INT64 CallDescrWorker(LPVOID        pSrcEnd,             //[edx+0]
                                 UINT32                   numStackSlots,       //[edx+4]
                                 const ArgumentRegisters *pArgumentRegisters,  //[edx+8]
                                 LPVOID                   pTarget              //[edx+12]
                                 );

    // We dont need a special descr worker for the varargs case 
    // TODO: should we just rename and rip out this define?
#define CallVADescrWorker CallDescrWorker


// Hack: These classification bits need cleanup bad: for now, this gets around
// IJW setting both mdUnmanagedExport & mdPinvokeImpl on expored methods.
#define IsReallyMdPinvokeImpl(x) ( ((x) & mdPinvokeImpl) && !((x) & mdUnmanagedExport) )

//
// The MethodNameHash is a temporary loader structure which may be allocated if there are a large number of
// methods in a class, to quickly get from a method name to a MethodDesc (potentially a chain of MethodDescs).
//

#define METH_NAME_CACHE_SIZE        5
#define MAX_MISSES                  3

// Entry in the method hash table
class MethodHashEntry
{
public:
    MethodHashEntry *   m_pNext;        // Next item with same hash value
    DWORD               m_dwHashValue;  // Hash value
    MethodDesc *        m_pDesc;
    LPCUTF8             m_pKey;         // Method name
};

class MethodNameHash
{
public:

    MethodHashEntry **m_pBuckets;       // Pointer to first entry for each bucket
    DWORD             m_dwNumBuckets;
    BYTE *            m_pMemory;        // Current pointer into preallocated memory for entries
    BYTE *            m_pMemoryStart;   // Start pointer of pre-allocated memory fo entries
#ifdef _DEBUG
    BYTE *            m_pDebugEndMemory;
#endif

    MethodNameHash()
    {
        m_pMemoryStart = NULL;
    }

    ~MethodNameHash()
    {
        if (m_pMemoryStart != NULL)
            delete(m_pMemoryStart);
    }

    // Returns TRUE for success, FALSE for failure
    BOOL Init(DWORD dwMaxEntries);

    // Insert new entry at head of list
    void Insert(LPCUTF8 pszName, MethodDesc *pDesc);

    // Return the first MethodHashEntry with this name, or NULL if there is no such entry
    MethodHashEntry *Lookup(LPCUTF8 pszName, DWORD dwHash);
};

class MethodNameCache
{

public:
    MethodNameHash  *m_pMethodNameHash[METH_NAME_CACHE_SIZE];
    EEClass         *m_pParentClass[METH_NAME_CACHE_SIZE];
    DWORD           m_dwWeights[METH_NAME_CACHE_SIZE];
    DWORD           m_dwLightWeight;
    DWORD           m_dwNumConsecutiveMisses;

    MethodNameCache()
    {
        for (int i = 0; i < METH_NAME_CACHE_SIZE; i++)
        {
            m_pMethodNameHash[i] = NULL;
            m_pParentClass[i] = NULL;
            m_dwWeights[i] = 0;
        }
        m_dwLightWeight = 0;
        m_dwNumConsecutiveMisses = 0;
    }

    ~MethodNameCache()
    {
        ClearCache();
    }

    VOID ClearCache()
    {
        m_dwLightWeight = 0;
        m_dwNumConsecutiveMisses = 0;

        for (int index = 0; index < METH_NAME_CACHE_SIZE; index++)
        {
            m_pParentClass[index] = NULL;
            m_dwWeights[index] = 0;
            if (m_pMethodNameHash[index])
            {
                delete m_pMethodNameHash[index];
                m_pMethodNameHash[index] = NULL;
            }
        }
    }

    MethodNameHash *GetMethodNameHash(EEClass *pParentClass);

    BOOL IsInCache(MethodNameHash *pHash)
    {
        for (int index = 0; index < METH_NAME_CACHE_SIZE; index++)
        {
            if (m_pMethodNameHash[index] == pHash)
                return TRUE;
        }
        return FALSE;
    }
};

#ifdef EnC_SUPPORTED

struct EnCAddedFieldElement;

#endif // EnC_SUPPORTED


class FieldDescIterator
{
private:
    int m_iteratorType;
    EEClass *m_pClass;
    int m_currField;
    int m_totalFields;

#ifdef EnC_SUPPORTED
    BOOL m_isEnC;
    EnCAddedFieldElement* m_pCurrListElem;
    FieldDesc* NextEnC();
#endif // EnC_SUPPORTED

  public:
    enum IteratorType { 
       INSTANCE_FIELDS = 0x1, 
       STATIC_FIELDS   = 0x2, 
       ALL_FIELDS      = (INSTANCE_FIELDS | STATIC_FIELDS) 
    };
    FieldDescIterator(EEClass *pClass, int iteratorType);
    FieldDesc* Next();
};

#endif // CLASS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\classfactory.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "common.h"
//#include "ClassFactory3.h"
#include "winwrap.h"
#include "ComCallWrapper.h"
#include "permset.h"
#include "frames.h"
#include "excep.h"

#include "registration.h"
#include "reflectwrap.h"

#include "remoting.h"
#include "ReflectUtil.h"

BOOL g_EnableLicensingInterop = FALSE;


HRESULT  COMStartup(); // ceemain.cpp

// Allocate a com+ object given the method table pointer
HRESULT STDMETHODCALLTYPE EEInternalAllocateInstance(LPUNKNOWN pOuter, MethodTable* pMT, BOOL fHasLicensing, REFIID riid, BOOL fDesignTime, BSTR bstrKey, void** ppv);
HRESULT STDMETHODCALLTYPE EEAllocateInstance(LPUNKNOWN pOuter, MethodTable* pMT, BOOL fHasLicensing, REFIID riid, BOOL fDesignTime, BSTR bstrKey, void** ppv);

// CTS, M10 change only. We do something special for ie
extern const GUID  __declspec(selectany) CLSID_IEHost = { 0xca35cb3d, 0x357, 0x11d3, { 0x87, 0x29, 0x0, 0xc0, 0x4f, 0x79, 0xed, 0xd } };
extern const GUID  __declspec(selectany) CLSID_CorIESecurityManager = { 0x5eba309, 0x164, 0x11d3, { 0x87, 0x29, 0x0, 0xc0, 0x4f, 0x79, 0xed, 0xd } };
// ---------------------------------------------------------------------------
// %%Class EEClassFactory
// IClassFactory implementation for COM+ objects
// ---------------------------------------------------------------------------
class EEClassFactory : public IClassFactory2
{
#define INTPTR              long
    MethodTable*            m_pvReserved; 
    ULONG                   m_cbRefCount;
    AppDomain*              m_pDomain;
    BOOL                    m_hasLicensing;
public:
    EEClassFactory(MethodTable* pTable, AppDomain* pDomain)
    {
        _ASSERTE(pTable != NULL);
        LOG((LF_INTEROP, LL_INFO100, "EEClassFactory::EEClassFactory for class %s\n", pTable->GetClass()->m_szDebugClassName));
        m_pvReserved = pTable;
        m_cbRefCount = 0;
        m_pDomain = pDomain;
                pDomain->GetComCallWrapperCache()->AddRef();
        m_hasLicensing = FALSE;
        EEClass *pcls = pTable->GetClass();
        while (pcls != NULL && pcls != g_pObjectClass->GetClass())
        {
            if (pcls->GetMDImport()->GetCustomAttributeByName(pcls->GetCl(), "System.ComponentModel.LicenseProviderAttribute", 0,0) == S_OK)
            {
                m_hasLicensing = TRUE;
                break;
            }
            pcls = pcls->GetParentClass();
        }

    }

    ~EEClassFactory()
    {
        LOG((LF_INTEROP, LL_INFO100, "EEClassFactory::~ for class %s\n", m_pvReserved->GetClass()->m_szDebugClassName));
        m_pDomain->GetComCallWrapperCache()->Release();
    }

    STDMETHODIMP    QueryInterface( REFIID iid, void **ppv);
    
    STDMETHODIMP_(ULONG)    AddRef()
    {
        INTPTR      l = FastInterlockIncrement((LONG*)&m_cbRefCount);
        return l;
    }
    STDMETHODIMP_(ULONG)    Release()
    {
        INTPTR      l = FastInterlockDecrement((LONG*)&m_cbRefCount);
        if (l == 0)
            delete this;
        return l;
    }

    STDMETHODIMP CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void** ppv);
    STDMETHODIMP LockServer(BOOL fLock);
    STDMETHODIMP GetLicInfo(LPLICINFO pLicInfo);
    STDMETHODIMP RequestLicKey(DWORD, BSTR * pbstrKey);
    STDMETHODIMP CreateInstanceLic(IUnknown *punkOuter, IUnknown*, REFIID riid, BSTR btrKey, void **ppUnk);
    
    
    STDMETHODIMP CreateInstanceWithContext(LPUNKNOWN punkContext, 
                                           LPUNKNOWN punkOuter, 
                                           REFIID riid, 
                                           void** ppv);

};

// ---------------------------------------------------------------------------
// %%Function: QueryInterface   
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::QueryInterface(
    REFIID iid,
    void **ppv)
{
    if (ppv == NULL)
        return E_POINTER;

    *ppv = NULL;

    if (iid == IID_IClassFactory || 
        iid == IID_IClassFactory2 ||
        iid == IID_IUnknown)
    {

        // Until IClassFactory2 is completely working, we don't want
        // to tell callers we support it.
        if ( (g_EnableLicensingInterop == FALSE || !m_hasLicensing) && iid == IID_IClassFactory2)
        {
            return E_NOINTERFACE;
        }

        *ppv = (IClassFactory2 *)this;
        AddRef();
    }

    return (*ppv != NULL) ? S_OK : E_NOINTERFACE;
}  // CClassFactory::QueryInterface

// ---------------------------------------------------------------------------
// %%Function: CreateInstance    
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::CreateInstance(
    LPUNKNOWN punkOuter,
    REFIID riid,
    void** ppv)
{       
    // allocate a com+ object
    // this will allocate the object in the correct context
    // we might end up with a tear-off on our COM+ context proxy
    HRESULT hr = EEInternalAllocateInstance(punkOuter, m_pvReserved,m_hasLicensing,riid, TRUE, NULL, ppv);

    return hr;
}  // CClassFactory::CreateInstance


// ---------------------------------------------------------------------------
// %%Function: CreateInstance    
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::CreateInstanceWithContext(LPUNKNOWN punkContext, 
                                                       LPUNKNOWN punkOuter, 
                                                       REFIID riid, 
                                                       void** ppv)
{
        HRESULT hr = EEInternalAllocateInstance(punkOuter, m_pvReserved,m_hasLicensing,riid, TRUE, NULL, ppv);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: LockServer 
//  Unimplemented, always returns S_OK.
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::LockServer(
    BOOL fLock)
{
    return S_OK;
}  // CClassFactory::LockServer



// ---------------------------------------------------------------------------
// %%Function: GetLicInfo 
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::GetLicInfo(LPLICINFO pLicInfo)
{
    HRESULT hr = E_FAIL;
    if (!pLicInfo)
    {
        return E_POINTER;
    }
    Thread* pThread = SetupThread();
    if( !pThread)
    {
        return E_OUTOFMEMORY;
    }
    
    BOOL fToggleGC = !pThread->PreemptiveGCDisabled();
    if (fToggleGC)
        pThread->DisablePreemptiveGC();

    

    COMPLUS_TRYEX(pThread)
    {        
        MethodTable *pHelperMT = pThread->GetDomain()->GetLicenseInteropHelperMethodTable(m_pvReserved->GetClass()->GetClassLoader());

        MethodDesc *pMD = pHelperMT->GetClass()->FindMethod("GetLicInfo", &gsig_IM_LicenseInteropHelper_GetLicInfo);

        OBJECTREF pHelper = NULL; // LicenseInteropHelper
        GCPROTECT_BEGIN(pHelper);
        pHelper = AllocateObject(pHelperMT);
        INT32 fRuntimeKeyAvail = 0;
        INT32 fLicVerified     = 0;

        INT64 args[4];
        args[0] = ObjToInt64(pHelper);
        *((TypeHandle*)&(args[3])) = TypeHandle(m_pvReserved);
        args[2] = (INT64)&fRuntimeKeyAvail;
        args[1] = (INT64)&fLicVerified;

        pMD->Call(args);
    
        pLicInfo->cbLicInfo = sizeof(LICINFO);
        pLicInfo->fRuntimeKeyAvail = fRuntimeKeyAvail;
        pLicInfo->fLicVerified     = fLicVerified;
        GCPROTECT_END();
        hr = S_OK;
    } 
    COMPLUS_CATCH 
    {
        // Retrieve the HRESULT from the exception.
        hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH
    
    if (fToggleGC)
        pThread->EnablePreemptiveGC();

    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: RequestLicKey 
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::RequestLicKey(DWORD, BSTR * pbstrKey)
{
    HRESULT hr = E_FAIL;
    if (!pbstrKey)
    {
        return E_POINTER;
    }
    *pbstrKey = NULL;
    Thread* pThread = SetupThread();
    if( !pThread)
    {
        return E_OUTOFMEMORY;
    }
    
    BOOL fToggleGC = !pThread->PreemptiveGCDisabled();
    if (fToggleGC)
        pThread->DisablePreemptiveGC();

    

    COMPLUS_TRYEX(pThread)
    {        
        MethodTable *pHelperMT = pThread->GetDomain()->GetLicenseInteropHelperMethodTable(m_pvReserved->GetClass()->GetClassLoader());

        MethodDesc *pMD = pHelperMT->GetClass()->FindMethod("RequestLicKey", &gsig_IM_LicenseInteropHelper_RequestLicKey);

        OBJECTREF pHelper = NULL; // LicenseInteropHelper
        GCPROTECT_BEGIN(pHelper);
        pHelper = AllocateObject(pHelperMT);
        INT64 args[3];
        args[0] = ObjToInt64(pHelper);
        *((TypeHandle*)&(args[2])) = TypeHandle(m_pvReserved);
        args[1] = (INT64)pbstrKey;

        hr = (HRESULT)pMD->Call(args);
    
        GCPROTECT_END();
    } 
    COMPLUS_CATCH 
    {
        // Retrieve the HRESULT from the exception.
        hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH
    
    if (fToggleGC)
        pThread->EnablePreemptiveGC();

    return hr;
}
// ---------------------------------------------------------------------------
// %%Function: CreateInstanceLic 
// ---------------------------------------------------------------------------
STDMETHODIMP EEClassFactory::CreateInstanceLic(IUnknown *punkOuter, IUnknown*pUnkReserved, REFIID riid, BSTR bstrKey, void **ppUnk)
{
    if (!ppUnk)
    {
        return E_POINTER;
    }
    *ppUnk = NULL;

    if (pUnkReserved != NULL)
    {
        return E_NOTIMPL;
    }
    if (bstrKey == NULL)
    {
        return E_POINTER;
    }
    // allocate a com+ object
    // this will allocate the object in the correct context
    // we might end up with a tear-off on our COM+ context proxy
    return EEInternalAllocateInstance(punkOuter, m_pvReserved,m_hasLicensing,riid, /*fDesignTime=*/FALSE, bstrKey, ppUnk);
}


// Allocate a com+ object given the method table pointer
HRESULT STDMETHODCALLTYPE EEAllocateInstance(LPUNKNOWN pOuter, MethodTable* pMT, BOOL fHasLicensing, REFIID riid, BOOL fDesignTime, BSTR bstrKey, void** ppv)
{
    BOOL fCtorAlreadyCalled = FALSE;

    _ASSERTE(pMT != NULL);
    if (ppv == NULL)
        return E_POINTER;

    if ( (!fDesignTime) && bstrKey == NULL )
        return E_POINTER;

    // aggregating objects should QI for IUnknown
    if (pOuter != NULL && !IsEqualIID(riid, IID_IUnknown))
        return E_INVALIDARG;

    HRESULT hr = E_OUTOFMEMORY;

    //could be an external thread
    // call set up thread
    Thread* pThread = SetupThread();
    if( !pThread)
    {
        return hr;
    }

    OBJECTREF pThrownObject = NULL;

    BOOL fToggleGC = !pThread->PreemptiveGCDisabled();
    if (fToggleGC)
        pThread->DisablePreemptiveGC();

    COMPLUS_TRYEX(pThread)
    {        
        *ppv = NULL;
        ComCallWrapper* pWrap = NULL;
        //@todo constructor stuff
        OBJECTREF       newobj; 

        // classes that extend COM Imported class are special
        if (ExtendsComImport(pMT))
        {
            newobj = AllocateObjectSpecial(pMT);
        }
        else if (CRemotingServices::RequiresManagedActivation(pMT->GetClass()) != NoManagedActivation)
        {
            fCtorAlreadyCalled = TRUE;
            newobj = CRemotingServices::CreateProxyOrObject(pMT, TRUE);
        }
        else
        {
            // If the class doesn't have a LicenseProviderAttribute, let's not
            // suck in the LicenseManager class and his friends.
            if (!fHasLicensing)
            {
                newobj = FastAllocateObject( pMT );
            }
            else
            {
                if (!g_EnableLicensingInterop)
                {
                    newobj = FastAllocateObject( pMT );
                }
                else
                {
                    MethodTable *pHelperMT = pThread->GetDomain()->GetLicenseInteropHelperMethodTable(pMT->GetClass()->GetClassLoader());

                    MethodDesc *pMD = pHelperMT->GetClass()->FindMethod("AllocateAndValidateLicense", 
                                                                        &gsig_IM_LicenseInteropHelper_AllocateAndValidateLicense);
                    OBJECTREF pHelper = NULL; // LicenseInteropHelper
                    GCPROTECT_BEGIN(pHelper);
                    pHelper = AllocateObject(pHelperMT);
                    INT64 args[4];
                    args[0] = ObjToInt64(pHelper);
                    *((TypeHandle*)&(args[3])) = TypeHandle(pMT);
                    args[2] = (INT64)bstrKey;
                    args[1] = fDesignTime ? 1 : 0;
                    INT64 result = pMD->Call(args);
                    newobj = Int64ToObj(result);
                    fCtorAlreadyCalled = TRUE;
                    GCPROTECT_END();
                }
            }
        }
        
        GCPROTECT_BEGIN(newobj);

        //get wrapper for the object, this could enable GC
        pWrap =  ComCallWrapper::InlineGetWrapper(&newobj); 
    
        // don't call any constructors if we already have called them
        if (!fCtorAlreadyCalled)
            CallDefaultConstructor(newobj);
            
        GCPROTECT_END();            

        // enable GC
        pThread->EnablePreemptiveGC();
        
        if (pOuter == NULL)
        {
            // return the tear-off
            *ppv = ComCallWrapper::GetComIPfromWrapper(pWrap, riid, NULL, TRUE);
            hr = *ppv ? S_OK : E_NOINTERFACE;
        }
        else
        {
            // aggreation support, 
            pWrap->InitializeOuter(pOuter);                                             
            {
                hr = pWrap->GetInnerUnknown(ppv);
            }
        }        

        // disable GC 
        pThread->DisablePreemptiveGC();

        ComCallWrapper::Release(pWrap); // release the ref-count (from InlineGetWrapper)
    } 
    COMPLUS_CATCH 
    {
        // Retrieve the HRESULT from the exception.
        hr = SetupErrorInfo(GETTHROWABLE());
    }
    COMPLUS_END_CATCH
    
    if (fToggleGC)
        pThread->EnablePreemptiveGC();

    LOG((LF_INTEROP, LL_INFO100, "EEAllocateInstance for class %s object %8.8x\n", pMT->GetClass()->m_szDebugClassName, *ppv));

    return hr;
}

IUnknown *AllocateEEClassFactoryHelper(EEClass *pClass)
{
    return (IUnknown*)new EEClassFactory(pClass->GetMethodTable(), SystemDomain::GetCurrentDomain());
}

HRESULT InitializeClass(Thread* pThread, EEClass* pClass)
{
    THROWSCOMPLUSEXCEPTION();

    OBJECTREF throwable = NULL;
    HRESULT hr = S_OK;
    GCPROTECT_BEGIN(throwable)
    // Make sure the class has a default public constructor.
    MethodDesc *pMD = NULL;
    if (pClass->GetMethodTable()->HasDefaultConstructor())
        pMD = pClass->GetMethodTable()->GetDefaultConstructor();
    if (pMD == NULL || !pMD->IsPublic()) {
        hr = COR_E_MEMBERACCESS;
    }
    else {
        // Call class init if necessary
        if (!pClass->DoRunClassInit(&throwable)) 
            COMPlusThrow(throwable);
    }
    GCPROTECT_END();
    return hr;
}

// try to load a com+ class and give out an IClassFactory
HRESULT STDMETHODCALLTYPE  EEDllGetClassObject(
                            REFCLSID rclsid,
                            REFIID riid,
                            LPVOID FAR *ppv)
{
    HRESULT hr = S_OK;
    EEClass* pClass;
    Thread* pThread = NULL;
    IUnknown* pUnk = NULL;

    if (ppv == NULL)
    {
        return  E_POINTER;
    }

    if (FAILED(hr = COMStartup()))
        return hr;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    // Retrieve the current thread.
    pThread = GetThread();
    _ASSERTE(pThread);
    _ASSERTE(!pThread->PreemptiveGCDisabled());

    COMPLUS_TRY
    {
        // Switch to cooperative GC mode.
        pThread->DisablePreemptiveGC();

        pClass = GetEEClassForCLSID(rclsid);

        // If we can't find the class based on the CLSID or if the registered managed
        // class is ComImport class then fail the call.
        if (!pClass || pClass->IsComImport())
        {
            hr = REGDB_E_CLASSNOTREG;
        }
        else 
        {
            hr = InitializeClass(pThread, pClass);
        }
            // Switch back to preemptive.
        pThread->EnablePreemptiveGC();
        // If we failed return
        if(FAILED(hr)) {
            goto LExit;
        }


        // @TODO: DM, We really should cache the class factories instead of creating a 
        // new one every time.

        // @TODO: CTS, Class factory needs to keep track of the domain. When we 
        // we support IClassFactoryEX the class may have to be created in a different 
        // AppDomain. This will mean we need to create a new Module in the domain
        // for the dll and return a class from there. We won't know we need a new
        // domain unless we now which one the factory is created for.
        pUnk = AllocateEEClassFactoryHelper(pClass);
        if (pUnk == NULL) 
            COMPlusThrowOM();

        // Bump up the count to protect the object
        pUnk->AddRef(); 

        // Query for the requested interface.
        hr = pUnk->QueryInterface(riid, ppv); //QI 

        // Now remove the extra addref that we made, this could delete the object
        // if the riid is not supported
        pUnk->Release();  

    }
    COMPLUS_CATCH
    {
        pThread->DisablePreemptiveGC();
        hr = SetupErrorInfo(GETTHROWABLE());
        pThread->EnablePreemptiveGC();
    }
    COMPLUS_END_CATCH

LExit:

    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
} //EEDllGetClassObject

// Temporary Functions to get a object based on a name
STDAPI ClrCreateManagedInstance(LPCWSTR typeName,
                                REFIID riid,
                                LPVOID FAR *ppv)
{
    if (ppv == NULL)
        return E_POINTER;

    if (typeName == NULL) return E_INVALIDARG;

    HRESULT hr = S_OK;
    OBJECTREF Throwable = NULL;
    Thread* pThread = NULL;
    IUnknown* pUnk = NULL;

    BEGINCANNOTTHROWCOMPLUSEXCEPTION();

    MAKE_UTF8PTR_FROMWIDE(pName, typeName);
    EEClass* pClass = NULL;

    if (FAILED(hr = COMStartup()))
        return hr;

    // Retrieve the current thread.
    pThread = GetThread();
    _ASSERTE(pThread);
    _ASSERTE(!pThread->PreemptiveGCDisabled());

    COMPLUS_TRY
    {
        // Switch to cooperative GC mode.
        pThread->DisablePreemptiveGC();

        AppDomain* pDomain = SystemDomain::GetCurrentDomain();
        _ASSERTE(pDomain);
        
        GCPROTECT_BEGIN(Throwable)
        pClass = pDomain->FindAssemblyQualifiedTypeHandle(pName,
                                                          true,
                                                          NULL,
                                                          NULL, 
                                                          &Throwable).GetClass();
        if (!pClass)
        {
            if(Throwable != NULL)
                COMPlusThrow(Throwable);
            hr = REGDB_E_CLASSNOTREG;
        }
        else {
            hr = InitializeClass(pThread, pClass);
        }
        GCPROTECT_END();

        // Switch back to preemptive.
        pThread->EnablePreemptiveGC();

        // If we failed return
        if(FAILED(hr)) goto LExit;

        // @TODO: DM, We really should cache the class factories instead of creating a 
        // new one every time.

        // @TODO: CTS, Class factory needs to keep track of the domain. When we 
        // we support IClassFactoryEX the class may have to be created in a different 
        // AppDomain. This will mean we need to create a new Module in the domain
        // for the dll and return a class from there. We won't know we need a new
        // domain unless we now which one the factory is created for.
        pUnk = AllocateEEClassFactoryHelper(pClass);
        if (pUnk == NULL) 
            COMPlusThrowOM();

        // Bump up the count to protect the object
        pUnk->AddRef(); 

        IClassFactory *pFactory;
        // Query for the requested interface.
        hr = pUnk->QueryInterface(IID_IClassFactory, (void**) &pFactory); //QI 
        if(SUCCEEDED(hr)) {
            hr = pFactory->CreateInstance(NULL, riid, ppv);
            pFactory->Release();
        }

        // Now remove the extra addref that we made, this could delete the object
        // if the riid is not supported
        pUnk->Release();  
    }
    COMPLUS_CATCH
    {
        pThread->DisablePreemptiveGC();
        hr = SetupErrorInfo(GETTHROWABLE());
        pThread->EnablePreemptiveGC();
    }
    COMPLUS_END_CATCH

LExit:
    ENDCANNOTTHROWCOMPLUSEXCEPTION();

    return hr;
}



// Allocate a com+ object given the method table pointer
HRESULT STDMETHODCALLTYPE EEInternalAllocateInstance(LPUNKNOWN pOuter, MethodTable* pMT, BOOL fHasLicensing, REFIID riid, BOOL fDesignTime, BSTR bstrKey, void** ppv)
{
    _ASSERTE(pMT != NULL);
    if (ppv == NULL)
        return E_POINTER;

    *ppv = NULL;

    // aggregating objects should QI for IUnknown
    if (pOuter != NULL && !IsEqualIID(riid, IID_IUnknown))
        return E_INVALIDARG;

    HRESULT hr = E_OUTOFMEMORY;
            
    //could be an external thread
    // call set up thread
    Thread* pThread = SetupThread();

    if (!pThread)
        return hr;

    // allocate a com+ object
    hr = EEAllocateInstance(pOuter, pMT,fHasLicensing,riid, fDesignTime, bstrKey, ppv);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     RegisterTypeForComClientsNative    public
//
//  Synopsis:   Registers a class factory with COM classic for a given type 
//              and CLSID. Later we can receive activations on this factory
//              and we return a CCW.
//
//  Note:       Assumes that the managed version of the method has already
//              set the thread to be in MTA.
//
//  History:    26-July-2000   TarunA      Created
//
//+----------------------------------------------------------------------------
VOID __stdcall RegisterTypeForComClientsNative(RegisterTypeForComClientsNativeArgs *pArgs)
{
    THROWSCOMPLUSEXCEPTION();

    // The arguments are already checked for NULL in the managed code.
    _ASSERTE((pArgs->pType != NULL) && pArgs->pGuid);

    // The type must be a runtime time to be able to extract a method table from it.
    if (pArgs->pType->GetMethodTable() != g_pRefUtil->GetClass(RC_Class))
        COMPlusThrowArgumentException(L"type", L"Argument_MustBeRuntimeType");

    EEClass *pClass = ((ReflectClass *)((REFLECTCLASSBASEREF)(pArgs->pType))->GetData())->GetClass();

    HRESULT hr = S_OK;
    DWORD dwCookie = 0;
    IUnknown *pUnk = NULL;
    Thread *t = NULL;
    BOOL toggleGC = FALSE;

    pUnk = (IUnknown*)new EEClassFactory(pClass->GetMethodTable(),
                                         SystemDomain::GetCurrentDomain());                                            
    if (pUnk == NULL) 
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // bump up the count to protect the object
    pUnk->AddRef(); 

    // Enable GC
    t = GetThread();
    toggleGC = (t && t->PreemptiveGCDisabled());
    if (toggleGC)
        t->EnablePreemptiveGC();

    // Call CoRegisterClassObject   
    hr = ::CoRegisterClassObject(*(pArgs->pGuid),
                                 pUnk,
                                 CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                                 REGCLS_MULTIPLEUSE,
                                 &dwCookie
                                 );
exit:
    if (toggleGC)
        t->DisablePreemptiveGC();

    if(FAILED(hr))
    {
        if(NULL != pUnk)
        {
            pUnk->Release();
        }

        if (hr == E_OUTOFMEMORY)
            COMPlusThrowOM();
        else
            FATAL_EE_ERROR();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\cgenx86.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// CGENX86.H -
//
// Various helper routines for generating x86 assembly code.
//
// DO NOT INCLUDE THIS FILE DIRECTLY - ALWAYS USE CGENSYS.H INSTEAD
//


#ifndef _X86_
#error Should only include "cgenx86.h" for X86 builds
#endif

#ifndef __cgenx86_h__
#define __cgenx86_h__

#include "stublink.h"

// FCALL is available on this platform
#define FCALLAVAILABLE 1


// preferred alignment for data
#define DATA_ALIGNMENT 4

class MethodDesc;
class FramedMethodFrame;
class Module;
struct ArrayOpScript;
struct DeclActionInfo;

// default return value type
typedef INT64 PlatformDefaultReturnType;

// CPU-dependent functions
extern "C" void __cdecl PreStubTemplate(void);
extern "C" INT64 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, UINT32 numArgSlots, PCCOR_SIGNATURE pSig,
                                               Module *pmodule, const BYTE  *pArgsEnd, BOOL fIsStatic);
extern "C" INT64 __cdecl CallDllFunction(LPVOID pTarget, LPVOID pEndArguments, UINT32 numArgumentSlots, BOOL fThisCall);
extern "C" void __stdcall WrapCall(void *target);
extern "C" void CopyPreStubTemplate(Stub *preStub);
// Non-CPU-specific helper functions called by the CPU-dependent code
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic, PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst);
extern "C" const BYTE * __stdcall PreStubWorker(PrestubMethodFrame *pPFrame);
extern "C" INT64 __stdcall NDirectGenericStubWorker(Thread *pThread, NDirectMethodFrame *pFrame);
extern "C" INT64 __stdcall ComPlusToComWorker(Thread *pThread, ComPlusMethodFrame* pFrame);

extern "C" DWORD __stdcall GetSpecificCpuType();

void *GetWrapCallFunctionReturn();



//**********************************************************************
// This structure captures the format of the METHOD_PREPAD area (behind
// the MethodDesc.)
//**********************************************************************
#pragma pack(push,1)

struct StubCallInstrs
{
    UINT16      m_wTokenRemainder;      //a portion of the methoddef token. The rest is stored in the chunk
    BYTE        m_chunkIndex;           //index to recover chunk

// This is a stable and efficient entrypoint for the method
    BYTE        m_op;                   //this is either a jump (0xe9) or a call (0xe8)
    UINT32      m_target;               //pc-relative target for jump or call
};

#pragma pack(pop)


#define METHOD_PREPAD               8 // # extra bytes to allocate in addition to sizeof(Method)
#define METHOD_CALL_PRESTUB_SIZE    5 // x86: CALL(E8) xx xx xx xx
#define METHOD_ALIGN                8 // required alignment for StubCallInstrs

#define JUMP_ALLOCATE_SIZE          8 // # bytes to allocate for a jump instrucation

//**********************************************************************
// Parameter size
//**********************************************************************

typedef INT32 StackElemType;
#define STACK_ELEM_SIZE sizeof(StackElemType)


// !! This expression assumes STACK_ELEM_SIZE is a power of 2.
#define StackElemSize(parmSize) (((parmSize) + STACK_ELEM_SIZE - 1) & ~((ULONG)(STACK_ELEM_SIZE - 1)))

// Get address of actual arg within widened arg
#define ArgTypeAddr(stack, type)      ((type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))

// Get value of actual arg within widened arg
#define ExtractArg(stack, type)   (*(type *) ((BYTE*)stack + StackElemSize(sizeof(type)) - sizeof(type)))

#define CEE_PARM_SIZE(size) (max(size), sizeof(INT32))
#define CEE_SLOT_COUNT(size) ((max(size), sizeof(INT32))/INT32)

#define DECLARE_ECALL_DEFAULT_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_OBJECTREF_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_PTR_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I1_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I2_ARG(vartype, varname)   \
    vartype varname;

#define DECLARE_ECALL_I4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R4_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_I8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

#define DECLARE_ECALL_R8_ARG(vartype, varname)   \
    DECLARE_ECALL_DEFAULT_ARG(vartype, varname);

inline BYTE *getStubCallAddr(MethodDesc *fd) {
    return ((BYTE*)fd) - METHOD_CALL_PRESTUB_SIZE;
}

inline BYTE *getStubCallTargetAddr(MethodDesc *fd) {
    return (BYTE*)(*((UINT32*)(fd) - 1) + (UINT32)fd);
}

inline void setStubCallTargetAddr(MethodDesc *fd, const BYTE *addr) {
    FastInterlockExchange((LONG*)fd - 1, (UINT32)addr - (UINT32)fd);
}

inline BYTE *getStubCallAddr(BYTE *pBuf) {
    return ((BYTE*)pBuf) + 3;   // have allocate 8 bytes, so go in 3 to find call instr point
}

inline BYTE *getStubJumpAddr(BYTE *pBuf) {
    return ((BYTE*)pBuf) + 3;   // have allocate 8 bytes, so go in 3 to find jmp instr point
}

//**********************************************************************
// Frames
//**********************************************************************
//--------------------------------------------------------------------
// This represents some of the TransitionFrame fields that are
// stored at negative offsets.
//--------------------------------------------------------------------
struct CalleeSavedRegisters {
    INT32       edi;
    INT32       esi;
    INT32       ebx;
    INT32       ebp;
};

//--------------------------------------------------------------------
// This represents the arguments that are stored in volatile registers.
// This should not overlap the CalleeSavedRegisters since those are already
// saved separately and it would be wasteful to save the same register twice.
// If we do use a non-volatile register as an argument, then the ArgIterator
// will probably have to communicate this back to the PromoteCallerStack
// routine to avoid a double promotion.
//
// @todo M6: It's silly for a method that has <N arguments to save N
// registers. A good perf item would be for the frame to save only
// the registers it actually needs. This means that NegSpaceSize()
// becomes a function of the callsig.
//--------------------------------------------------------------------
struct ArgumentRegisters {

#define DEFINE_ARGUMENT_REGISTER_BACKWARD(regname)  INT32 regname;
#include "eecallconv.h"

};


#define ARGUMENTREGISTERS_SIZE sizeof(ArgumentRegisters)


#define PLATFORM_FRAME_ALIGN(val) (val)

#ifdef _DEBUG

//-----------------------------------------------------------------------
// Under DEBUG, stubs push 8 additional bytes of info in order to
// allow the VC debugger to stacktrace through stubs. This info
// is pushed right after the callee-saved-registers. The stubs
// also must keep ebp pointed to this structure. Note that this
// precludes the use of ebp by the stub itself.
//-----------------------------------------------------------------------
struct VC5Frame
{
    INT32      m_savedebp;
    INT32      m_returnaddress;
};
#define VC5FRAME_SIZE   sizeof(VC5Frame)
#else
#define VC5FRAME_SIZE   0
#endif




#define DECLARE_PLATFORM_FRAME_INFO \
    UINT32      m_eip;              \
    UINT32      m_esp;              \
    UINT32 *getIPSaveAddr() {       \
        return &m_eip;              \
    }                               \
    UINT32 *getSPSaveAddr() {       \
        return &m_esp;              \
    }                               \
    UINT32 getIPSaveVal() {         \
        return m_eip;               \
    }                               \
    UINT32 getSPSaveVal() {         \
        return m_esp;               \
    }

//**********************************************************************
// Exception handling
//**********************************************************************

inline LPVOID GetIP(CONTEXT *context) {
    return (LPVOID)(context->Eip);
}

inline void SetIP(CONTEXT *context, LPVOID eip) {
    context->Eip = (UINT32)eip;
}

inline LPVOID GetSP(CONTEXT *context) {
    return (LPVOID)(context->Esp);
}

inline LPVOID GetSP()
{
    LPVOID SPval;
    __asm mov SPval, esp
    return SPval;
}

inline void SetSP(LPVOID newSP)
{
    LPVOID newSPVal = newSP;
    __asm mov esp, newSPVal
}

//
// Note: the debugger relies on the fact that the stub call is a CALL NEAR32
// with an opcode of 0xe8. See Debug\CorDB\Inprocess.cpp, function
// CorDBIsStubCall.
//
// -- mikemag Sun Jun 28 17:48:42 1998
//
inline void emitStubCall(MethodDesc *pFD, BYTE *stubAddr) {
    BYTE *target = getStubCallAddr(pFD);
    target[0] = 0xe8; // CALL NEAR32
    *((UINT32*)(target+1)) = (UINT32)(size_t)(stubAddr - pFD);
}

inline UINT32 getStubDisp(MethodDesc *fd) {
    return *( ((UINT32*)fd)-1);
}


inline void emitCall(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe8; //CALLNEAR32
    *((LPVOID*)(1+pBuffer)) = (LPVOID) (((LPBYTE)target) - (pBuffer+5));
}

inline LPVOID getCallTarget(const BYTE *pCall)
{
    _ASSERTE(pCall[0] == 0xe8);
    return (LPVOID) (pCall + 5 + *((UINT32*)(1 + pCall)));
}

inline void emitJump(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe9; //JUMPNEAR32
    *((LPVOID*)(1+pBuffer)) = (LPVOID) (((LPBYTE)target) - (pBuffer+5));
}

inline void updateJumpTarget(LPBYTE pBuffer, LPVOID target)
{
    pBuffer[0] = 0xe9; //JUMPNEAR32
    InterlockedExchange((long*)(1+pBuffer), (DWORD) (((LPBYTE)target) - (pBuffer+5)));
}

inline LPVOID getJumpTarget(const BYTE *pJump)
{
    _ASSERTE(pJump[0] == 0xe9);
    return (LPVOID) (pJump + 5 + *((UINT32*)(1 + pJump)));
}

inline UINT32 setCallAddrInterlocked(UINT32 *callAddr, UINT32 stubAddr, 
									 UINT32 expectedStubAddr)
{
	SIZE_T result = (SIZE_T)
	  FastInterlockCompareExchange((void **) callAddr, 
								   (void *)(stubAddr - ((UINT32)callAddr + sizeof(UINT32))), 
								   (void *)(expectedStubAddr - ((UINT32)callAddr + sizeof(UINT32)))) 
	  + (UINT32)callAddr + sizeof(UINT32);

	// result is the previous value of the stub - 
	// instead return the current value of the stub

	if (result == expectedStubAddr)
		return stubAddr;
	else
		return result;
}

inline Stub *setStubCallPointInterlocked(MethodDesc *pFD, Stub *pStub, 
										 Stub *pExpectedStub) {
    // The offset must be 32-bit aligned for atomicity to be guaranteed.
    _ASSERTE( 0 == (((UINT32)pFD) & 3) );

	UINT32 stubAddr = (UINT32)pStub->GetEntryPoint();
	UINT32 expectedStubAddr = (UINT32)pExpectedStub->GetEntryPoint();

	UINT32 newStubAddr = setCallAddrInterlocked((UINT32 *)(((long*)pFD)-1), 
												stubAddr, expectedStubAddr);

	if (newStubAddr == stubAddr)
		 return pStub;
	else
		 return Stub::RecoverStub((BYTE *) newStubAddr);
}

inline const BYTE *getStubAddr(MethodDesc *fd) {
    return (const BYTE *)(getStubDisp(fd) + (UINT32)fd);
}

//----------------------------------------------------------
// Marshalling Language support
//----------------------------------------------------------
typedef INT32 SignedParmSourceType;
typedef UINT32 UnsignedParmSourceType;
typedef float FloatParmSourceType;
typedef double DoubleParmSourceType;
typedef INT32 SignedI1TargetType;
typedef UINT32 UnsignedI1TargetType;
typedef INT32 SignedI2TargetType;
typedef UINT32 UnsignedI2TargetType;
typedef INT32 SignedI4TargetType;
typedef UINT32 UnsignedI4TargetType;


#define PTRDST(type)            ((type*)( ((BYTE*&)pdst) -= sizeof(LPVOID) ))

#define STDST(type,val)         (*((type*)( ((BYTE*&)pdst) -= sizeof(type) )) = (val))

#define STPTRDST(type, val)     STDST(type, val)
#define LDSTR4()                STDST(UINT32, (UINT32)LDSRC(UnsignedParmSourceType))
#define LDSTR8()                STDST(UNALIGNED UINT64, LDSRC(UNALIGNED UINT64))


inline MLParmSize(int parmSize)
{
    return ((parmSize + sizeof(INT32) - 1) & ~((ULONG)(sizeof(INT32) - 1)));
}


inline void setFPReturn(int fpSize, INT64 retVal)
{
    if (fpSize == 4) {
        __asm{
            lea eax, retVal
            fld dword ptr [eax]
        }
    } else if (fpSize == 8) {
        __asm{
            lea eax, retVal
            fld qword ptr [eax]
        }
    }
}

inline void getFPReturn(int fpSize, INT64 &retval)
{
   if (fpSize == 4) {
        __asm{
            mov eax, retval
            fstp dword ptr [eax]
        }
    } else if (fpSize == 8) {
        __asm{
            mov eax, retval
            fstp qword ptr [eax]
        }
    }
}

inline void getFPReturnSmall(INT32 *retval)
{
    __asm
    {
        mov   eax, retval
        fstp  dword ptr [eax]
    }
}

//----------------------------------------------------------------------
// Encodes X86 registers. The numbers are chosen to match Intel's opcode
// encoding.
//----------------------------------------------------------------------
enum X86Reg {
    kEAX = 0,
    kECX = 1,
    kEDX = 2,
    kEBX = 3,
    // kESP intentionally omitted because of its irregular treatment in MOD/RM
    kEBP = 5,
    kESI = 6,
    kEDI = 7

};


// Get X86Reg indexes of argument registers (indices start from 0).
X86Reg GetX86ArgumentRegister(unsigned int index);



//----------------------------------------------------------------------
// Encodes X86 conditional jumps. The numbers are chosen to match
// Intel's opcode encoding.
//----------------------------------------------------------------------
class X86CondCode {
    public:
        enum cc {
            kJA   = 0x7,
            kJAE  = 0x3,
            kJB   = 0x2,
            kJBE  = 0x6,
            kJC   = 0x2,
            kJE   = 0x4,
            kJZ   = 0x4,
            kJG   = 0xf,
            kJGE  = 0xd,
            kJL   = 0xc,
            kJLE  = 0xe,
            kJNA  = 0x6,
            kJNAE = 0x2,
            kJNB  = 0x3,
            kJNBE = 0x7,
            kJNC  = 0x3,
            kJNE  = 0x5,
            kJNG  = 0xe,
            kJNGE = 0xc,
            kJNL  = 0xd,
            kJNLE = 0xf,
            kJNO  = 0x1,
            kJNP  = 0xb,
            kJNS  = 0x9,
            kJNZ  = 0x5,
            kJO   = 0x0,
            kJP   = 0xa,
            kJPE  = 0xa,
            kJPO  = 0xb,
            kJS   = 0x8,
        };
};


//----------------------------------------------------------------------
// StubLinker with extensions for generating X86 code.
//----------------------------------------------------------------------
class StubLinkerX86 : public StubLinker
{
    public:
        VOID X86EmitAddReg(X86Reg reg, __int8 imm8);
        VOID X86EmitSubReg(X86Reg reg, __int8 imm8);
        VOID X86EmitPushReg(X86Reg reg);
        VOID X86EmitPopReg(X86Reg reg);
        VOID X86EmitPushRegs(unsigned regSet);
        VOID X86EmitPopRegs(unsigned regSet);
        VOID X86EmitPushImm32(UINT value);
        VOID X86EmitPushImm8(BYTE value);
        VOID X86EmitZeroOutReg(X86Reg reg);
        VOID X86EmitNearJump(CodeLabel *pTarget);
        VOID X86EmitCondJump(CodeLabel *pTarget, X86CondCode::cc condcode);
        VOID X86EmitCall(CodeLabel *target, int iArgBytes, BOOL returnLabel = FALSE);
        VOID X86EmitReturn(int iArgBytes);
        VOID X86EmitCurrentThreadFetch();
        VOID X86EmitCurrentThreadFetchEx(X86Reg dstreg, unsigned preservedRegSet);
        VOID X86EmitSetupThread();
        VOID X86EmitIndexRegLoad(X86Reg dstreg, X86Reg srcreg, __int32 ofs);
        VOID X86EmitIndexRegStore(X86Reg dstreg, __int32 ofs, X86Reg srcreg);
        VOID X86EmitIndexPush(X86Reg srcreg, __int32 ofs);
        VOID X86EmitSPIndexPush(__int8 ofs);
        VOID X86EmitIndexPop(X86Reg srcreg, __int32 ofs);
        VOID X86EmitSubEsp(INT32 imm32);
        VOID X86EmitAddEsp(INT32 imm32);
        VOID X86EmitOffsetModRM(BYTE opcode, X86Reg altreg, X86Reg indexreg, __int32 ofs);
        VOID X86EmitEspOffset(BYTE opcode, X86Reg altreg, __int32 ofs);

        // These are used to emit calls to notify the profiler of transitions in and out of
        // managed code through COM->COM+ interop
        VOID EmitProfilerComCallProlog(PVOID pFrameVptr, X86Reg regFrame);
        VOID EmitProfilerComCallEpilog(PVOID pFrameVptr, X86Reg regFrame);



        // Emits the most efficient form of the operation:
        //
        //    opcode   altreg, [basereg + scaledreg*scale + ofs]
        //
        // or
        //
        //    opcode   [basereg + scaledreg*scale + ofs], altreg
        //
        // (the opcode determines which comes first.)
        //
        //
        // Limitations:
        //
        //    scale must be 0,1,2,4 or 8.
        //    if scale == 0, scaledreg is ignored.
        //    basereg and altreg may be equal to 4 (ESP) but scaledreg cannot
        //    for some opcodes, "altreg" may actually select an operation
        //      rather than a second register argument.
        //    

        VOID X86EmitOp(BYTE    opcode,
                       X86Reg  altreg,
                       X86Reg  basereg,
                       __int32 ofs = 0,
                       X86Reg  scaledreg = (X86Reg)0,
                       BYTE    scale = 0
                       );


        // Emits
        //
        //    opcode altreg, modrmreg
        //
        // or
        //
        //    opcode modrmreg, altreg
        //
        // (the opcode determines which one comes first)
        //
        // For single-operand opcodes, "altreg" actually selects
        // an operation rather than a register.

        VOID X86EmitR2ROp(BYTE opcode, X86Reg altreg, X86Reg modrmreg);



        VOID EmitEnable(CodeLabel *pForwardRef);
        VOID EmitRareEnable(CodeLabel *pRejoinPoint);

        VOID EmitDisable(CodeLabel *pForwardRef);
        VOID EmitRareDisable(CodeLabel *pRejoinPoint, BOOL bIsCallIn);
        VOID EmitRareDisableHRESULT(CodeLabel *pRejoinPoint, CodeLabel *pExitPoint);

        VOID X86EmitSetup(CodeLabel *pForwardRef);
        VOID EmitRareSetup(CodeLabel* pRejoinPoint);

        void EmitComMethodStubProlog(LPVOID pFrameVptr, CodeLabel** rgRareLabels,
                                     CodeLabel** rgRejoinLabels, LPVOID pSEHHandler,
                                     BOOL bShouldProfile);

        void EmitEnterManagedStubEpilog(LPVOID pFrameVptr, unsigned numStackBytes,
                    CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels,
                    BOOL bShouldProfile);

        void EmitComMethodStubEpilog(LPVOID pFrameVptr, unsigned numStackBytes,
                            CodeLabel** rgRareLabels, CodeLabel** rgRejoinLabels,
                            LPVOID pSEHHAndler, BOOL bShouldProfile);

        //========================================================================
        //  void StubLinkerX86::EmitSEHProlog(LPVOID pvFrameHandler)
        //  Prolog for setting up SEH for stubs that enter managed code from unmanaged
        //  assumptions: esi has the current frame pointer
        void StubLinkerX86::EmitSEHProlog(LPVOID pvFrameHandler);

        //===========================================================================
        //  void StubLinkerX86::EmitUnLinkSEH(unsigned offset)
        //  negOffset is the offset from the current frame where the next exception record
        //  pointer is stored in the stack
        //  for e.g. COM to managed frames the pointer to next SEH record is in the stack
        //          after the ComMethodFrame::NegSpaceSize() + 4 ( address of handler)
        //
        //  also assumes ESI is pointing to the current frame
        void StubLinkerX86::EmitUnLinkSEH(unsigned offset);

        VOID EmitMethodStubProlog(LPVOID pFrameVptr);
        VOID EmitMethodStubEpilog(__int16 numArgBytes, StubStyle style,
                                  __int16 shadowStackArgBytes = 0);

        VOID EmitUnboxMethodStub(MethodDesc* pRealMD);

        //----------------------------------------------------------------
        //
        // VOID EmitSharedMethodStubEpilog(StubStyle style,
        //                                             unsigned offsetRetThunk)
        //      shared epilog, uses a return thunk within the methoddesc
        //--------------------------------------------------------------------
        VOID EmitSharedMethodStubEpilog(StubStyle style,
                                               unsigned offsetRetThunk);
        //========================================================================
        //  shared Epilog for stubs that enter managed code from COM
        //  uses a return thunk within the method desc
        void EmitSharedComMethodStubEpilog(LPVOID pFrameVptr,
                                           CodeLabel** rgRareLabels,
                                           CodeLabel** rgRejoinLabels,
                                           unsigned offsetReturnThunk,
                                           BOOL bShouldProfile);

        //===========================================================================
        // Emits code to repush the original arguments in the virtual calling
        // convention format.
        VOID EmitShadowStack(MethodDesc *pMD);

        VOID EmitSecurityWrapperStub(__int16 numArgBytes, MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions);
        VOID EmitSecurityInterceptorStub(MethodDesc* pMD, BOOL fToStub, LPVOID pRealStub, DeclActionInfo *pActions);

        //===========================================================================
        // Emits code for MulticastDelegate.Invoke()
        VOID EmitMulticastInvoke(UINT32 sizeofactualfixedargstack, BOOL fSingleCast, BOOL fReturnFloat);

        //===========================================================================
        // Emits code to adjust for a static delegate target.
        VOID EmitShuffleThunk(struct ShuffleEntry *pShuffeEntryArray);

        //===========================================================================
        // Emits code to capture the lasterror code.
        VOID EmitSaveLastError();


        //===========================================================================
        // Emits code to do an array operation.
        VOID EmitArrayOpStub(const ArrayOpScript*);

        //===========================================================================
        // Emits code to throw a rank exception
        VOID EmitRankExceptionThrowStub(UINT cbFixedArgs);

        //===========================================================================
        // Emits code to touch pages
        // Inputs:
        //   eax = first byte of data
        //   edx = first byte past end of data
        //
        // Trashes eax, edx, ecx
        //
        // Pass TRUE if edx is guaranteed to be strictly greater than eax.
        VOID EmitPageTouch(BOOL fSkipNullCheck);


#ifdef _DEBUG
        VOID X86EmitDebugTrashReg(X86Reg reg);
#endif
    private:
        VOID X86EmitSubEspWorker(INT32 imm32);


};






#ifdef _DEBUG
//-------------------------------------------------------------------------
// This is a helper function that stubs in DEBUG go through to call
// outside code. This is only there to provide a code section return
// address because VC's stack tracing breaks otherwise.
//
// WARNING: Trashes ESI. This is not a C-callable function.
//-------------------------------------------------------------------------
VOID WrapCall(LPVOID pFunc);
#endif

//
// Routines used by debugger support functions such as codepatch.cpp or
// exception handling code.
//
// GetInstruction, InsertBreakpoint, and SetInstruction all operate on
// a _single_ byte of memory. This is really important. If you only
// save one byte from the instruction stream before placing a breakpoint,
// you need to make sure to only replace one byte later on.
//

inline DWORD CORDbgGetInstruction(const unsigned char* address)
{
    return *address; // retrieving only one byte is important
}

inline void CORDbgInsertBreakpoint(const unsigned char* address)
{
    *((unsigned char*)address) = 0xCC; // int 3 (single byte patch)
}

inline void CORDbgSetInstruction(const unsigned char* address,
                                 DWORD instruction)
{
    *((unsigned char*)address)
          = (unsigned char) instruction; // setting one byte is important
}

inline void CORDbgAdjustPCForBreakInstruction(CONTEXT* pContext)
{
    pContext->Eip -= 1;
}

#define CORDbg_BREAK_INSTRUCTION_SIZE 1


// Some platform-specific stuff in support of the "Contexts" feature:
//
// When we generate thunks for CtxProxy VTables, they look like:
//
//             MOV   EAX, <slot>
//             JMP   CtxProxy::HandleCall
//
#define ThunkChunk_ThunkSize    10      // size of the above code


// Adjust the generic interlocked operations for any platform specific ones we
// might have.
void InitFastInterlockOps();



// SEH info forward declarations

typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    LPVOID Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

struct ComToManagedExRecord; // defined in cgenx86.cpp
// one of the internal exception SEH handlers
EXCEPTION_DISPOSITION __cdecl  ComToManagedExceptHandler (
                                 PEXCEPTION_RECORD pExcepRecord,
                                  ComToManagedExRecord* pEstFrame,
                                  PCONTEXT pContext,
                                  LPVOID    pDispatcherContext);

// Access to the TEB (TIB) from nti386.h
#if defined(MIDL_PASS) || !defined(_M_IX86)
struct _TEB *
NTAPI
NtCurrentTeb( void );
#else
#pragma warning (disable:4035)        // disable 4035 (function must return something)
#define PcTeb 0x18
_inline struct _TEB * NtCurrentTeb( void ) { __asm mov eax, fs:[PcTeb] }
#pragma warning (default:4035)        // reenable it
#endif // defined(MIDL_PASS) || defined(__cplusplus) || !defined(_M_IX86)


inline BOOL IsUnmanagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return sizeofvaluetype > 8;
}

inline BOOL IsManagedValueTypeReturnedByRef(UINT sizeofvaluetype) 
{
	return TRUE;
}


#define X86_INSTR_HLT  0xf4    //opcode value of X86 HLT instruction


#endif // __cgenx86_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\vm\class.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
// File: CLASS.CPP
//
// ===========================================================================
// This file contains CreateClass() which will return a EEClass*.
// Calling create class is the ONLY way a EEClass should be allocated.
// ===========================================================================
//

#include "common.h"

#include "clsload.hpp"
#include "method.hpp"
#include "class.h"
#include "object.h"
#include "field.h"
#include "util.hpp"
#include "excep.h"
#include "siginfo.hpp"
#include "threads.h"
#include "stublink.h"
#include "ecall.h"
#include "COMPlusWrapper.h"
#include "ComClass.h"
#include "ndirect.h"
#include "gcdesc.h"
#include "verifier.hpp"
#include "JITInterface.h"
#include "ComCallWrapper.h"
#include "EEConfig.h"
#include "log.h"
#include "nstruct.h"
#include "cgensys.h"
#include "gc.h"
#include "ReflectUtil.h"
#include "security.h"
#include "COMStringBuffer.h"
#include "DbgInterface.h"
#include "COMDelegate.h"
#include "COMMember.h"
#include "SigFormat.h"
#include "compluscall.h"
#include "remoting.h"
#include "icecap.h"
#include "EEProfInterfaces.h"
#include "nexport.h"
#include "nstruct.h"
#include "wsperf.h"
#include "ListLock.h"
#include "MethodImpl.h"
#include "jumptargettable.h"
#include "utsem.h"
#include "GuidFromName.h"
#include "stackprobe.h"
#include "EnCEE.h"
#include "EnCEE.h"
#include "ComSynchronizable.h"
#include "CustomAttribute.h"

#include "listlock.inl"

// this file handles string conversion errors for itself
#undef  MAKE_TRANSLATIONFAILED


// Helper functions to sort GCdescs by offset (decending order)
int __cdecl compareCGCDescSeries(const void *arg1, const void *arg2)
{
    CGCDescSeries* gcInfo1 = (CGCDescSeries*) arg1;
    CGCDescSeries* gcInfo2 = (CGCDescSeries*) arg2;

    return (int)(gcInfo2->GetSeriesOffset() - gcInfo1->GetSeriesOffset());
}



//-----------------------------------------------------------------------------------
// The following is needed to monitor RVA fields overlapping in InitializeFieldDescs
//
#define RVA_FIELD_VALIDATION_ENABLED
//#define RVA_FIELD_OVERLAPPING_VALIDATION_ENABLED
#include "..\ildasm\DynamicArray.h"
struct RVAFSE // RVA Field Start & End
{
    BYTE* pbStart;
    BYTE* pbEnd;
};
DynamicArray<RVAFSE> *g_drRVAField = NULL;
ULONG                   g_ulNumRVAFields=0;
//-----------------------------------------------------------------------------------
// utsem.h defines UNLOCK which conflicts with UNLOCK in ComPlusWrapperCache
#undef UNLOCK

#define UNPLACED_NONVTABLE_SLOT_NUMBER ((WORD) -2)

#include "Assembly.hpp"

extern "C" void* GetGp(void);

// Typedef for string comparition functions.
typedef int (__cdecl *UTF8StringCompareFuncPtr)(const char *, const char *);

char* FormatSig(MethodDesc* pMD);

// Cache the MethodDesc where the Finalize method was placed into Object's MethodTable.
MethodDesc *MethodTable::s_FinalizerMD;
MetaSig    *EEClass::s_cctorSig;

#ifdef _DEBUG

BOOL TypeHandle::Verify() 
{
    if (IsNull())
        return(true);

    if (IsUnsharedMT()) {
        // **********TEMOPORARILY commented out. TarunA to fix it.
        //_ASSERTE(m_asMT->GetClass()->GetMethodTable() == m_asMT);   // Sane method table

        // This assert really should be here, but at the moment it is violated
        // (benignly), in JitInterface when you ask for a class when all you have
        // is a methodDesc of an array method.  
        // _ASSERTE(!m_asMT->IsArray());
        }
    else {
        if (IsArray())
            AsArray()->Verify();
    }
    return(true);
}

BOOL ParamTypeDesc::Verify() {
    _ASSERTE(m_TemplateMT == 0 || m_TemplateMT == m_TemplateMT->GetClass()->GetMethodTable());
    _ASSERTE(!GetTypeParam().IsNull());
    _ASSERTE(!(GetTypeParam().IsUnsharedMT() && GetTypeParam().AsMethodTable()->IsArray()));
    _ASSERTE(CorTypeInfo::IsModifier(m_Type)); 
    GetTypeParam().Verify();
    return(true);
}

BOOL ArrayTypeDesc::Verify() {
    _ASSERTE(m_TemplateMT->IsArray());
    _ASSERTE(CorTypeInfo::IsArray(m_Type));
    ParamTypeDesc::Verify();
    return(true);
}

#endif

unsigned TypeHandle::GetSize() {
    CorElementType type = GetNormCorElementType();
    if (type == ELEMENT_TYPE_VALUETYPE)
        return(AsClass()->GetNumInstanceFieldBytes());
    return(GetSizeForCorElementType(type));
}

Module* TypeHandle::GetModule() { 
    if (IsTypeDesc())
        return AsTypeDesc()->GetModule();
    return(AsMethodTable()->GetModule());
}

Assembly* TypeHandle::GetAssembly() { 
    if (IsTypeDesc())
        return AsTypeDesc()->GetAssembly();
    return(AsMethodTable()->GetAssembly());
}

BOOL TypeHandle::IsArray() { 
    return(IsTypeDesc() && CorTypeInfo::IsArray(AsTypeDesc()->GetNormCorElementType()));
}

BOOL TypeHandle::CanCastTo(TypeHandle type) {
    if (*this == type)
        return(true);

    if (IsTypeDesc())
        return AsTypeDesc()->CanCastTo(type);
                
    if (!type.IsUnsharedMT())
        return(false);
    return ClassLoader::StaticCanCastToClassOrInterface(AsClass(), type.AsClass()) != 0;
}

unsigned TypeHandle::GetName(char* buff, unsigned buffLen) {
    if (IsTypeDesc())
        return(AsTypeDesc()->GetName(buff, buffLen));

    AsMethodTable()->GetClass()->_GetFullyQualifiedNameForClass(buff, buffLen);
    _ASSERTE(strlen(buff) < buffLen-1);
    return((unsigned)strlen(buff));
}

TypeHandle TypeHandle::GetParent() {
    if (IsTypeDesc())
        return(AsTypeDesc()->GetParent());

    EEClass* parentClass = AsMethodTable()->GetClass()->GetParentClass();
    if (parentClass == 0)
        return(TypeHandle());
    return TypeHandle(parentClass->GetMethodTable());
}

Module* TypeDesc::GetModule() { 
    // Note here we are making the assumption that a typeDesc lives in
    // the classloader of its element type.  

    if (CorTypeInfo::IsModifier(m_Type)) {
        TypeHandle param = GetTypeParam();
        _ASSERTE(!param.IsNull());
        return(param.GetModule());
    }

    _ASSERTE(m_Type == ELEMENT_TYPE_FNPTR);
    FunctionTypeDesc* asFtn = (FunctionTypeDesc*) this;
    return(asFtn->GetSig()->GetModule());

}

Assembly* TypeDesc::GetAssembly() { 
    // Note here we are making the assumption that a typeDesc lives in
    // the classloader of its element type.  
    TypeHandle param = GetTypeParam();
    _ASSERTE(!param.IsNull());
    return(param.GetAssembly());
}

unsigned TypeDesc::GetName(char* buff, unsigned buffLen)
{
    CorElementType kind = GetNormCorElementType();

    return ConstructName(kind, 
                         CorTypeInfo::IsModifier(kind) ? GetTypeParam() : TypeHandle(),
                         kind == ELEMENT_TYPE_ARRAY ? ((ArrayTypeDesc*) this)->GetRank() : 0, 
                         buff, buffLen);
}


unsigned TypeDesc::ConstructName(CorElementType kind, TypeHandle param, int rank, 
                                 char* buff, unsigned buffLen)
{
    char* origBuff = buff;
    char* endBuff = &buff[buffLen];

    if (CorTypeInfo::IsModifier(kind))
    {
        buff += param.GetName(buff, buffLen);
    }

    switch(kind) {
    case ELEMENT_TYPE_BYREF:
        if (buff < endBuff)
            *buff++ = '&';
        break;
    case ELEMENT_TYPE_PTR:
        if (buff < endBuff)
            *buff++ = '*';
        break;
    case ELEMENT_TYPE_SZARRAY:
        if (&buff[2] <= endBuff) {
            *buff++ = '[';
            *buff++ = ']';
        }
        break;
    case ELEMENT_TYPE_ARRAY: {
        if (&buff[rank+2] <= endBuff) {
            *buff++ = '[';
            
            if (rank == 1)
                *buff++ = '*';
            else {
                while(--rank > 0)
                    *buff++ = ',';
            }
            
            *buff++ = ']';
        }
        break;
    }
    case ELEMENT_TYPE_FNPTR:
    default: 
        const char* name = CorTypeInfo::GetFullName(kind);
        _ASSERTE(name != 0);
        unsigned len = (unsigned)strlen(name);
        if (buff + len < endBuff) {
            strcpy(buff, name);
            buff += len;
        }
    }

    if (buff < endBuff)
        *buff = 0;
    _ASSERTE(buff <= endBuff);
    return buff - origBuff;
}

BOOL TypeDesc::CanCastTo(TypeHandle toType) {

    if (!toType.IsTypeDesc()) {
        if (GetMethodTable() == 0)      // I don't have an underlying method table, I am not an object.  
            return(false);

            // This does the right thing if 'type' == System.Array or System.Object, System.Clonable ...
        return(ClassLoader::StaticCanCastToClassOrInterface(GetMethodTable()->GetClass(), toType.AsClass()) != 0);
    }

    TypeDesc* toTypeDesc = toType.AsTypeDesc();

    CorElementType toKind = toTypeDesc->GetNormCorElementType();
    CorElementType fromKind = GetNormCorElementType();

    // The element kinds must match, only exception is that SZARRAY matches a one dimension ARRAY 
    if (!(toKind == fromKind || (CorTypeInfo::IsArray(toKind) && fromKind == ELEMENT_TYPE_SZARRAY)))
        return(false);
    
    // Is it a parameterized type?
    if (CorTypeInfo::IsModifier(toKind)) {
        if (toKind == ELEMENT_TYPE_ARRAY) {
            ArrayTypeDesc* fromArray = (ArrayTypeDesc*) this;
            ArrayTypeDesc* toArray = (ArrayTypeDesc*) toTypeDesc;
            
            if (fromArray->GetRank() != toArray->GetRank())
                return(false);
        }

            // While boxed value classes inherit from object their 
            // unboxed versions do not.  Parameterized types have the
            // unboxed version, thus, if the from type parameter is value 
            // class then only an exact match works.  
        TypeHandle fromParam = GetTypeParam();
        TypeHandle toParam = toTypeDesc->GetTypeParam();
        if (fromParam == toParam)
            return(true);
        
            // Object parameters dont need an exact match but only inheritance, check for that
        CorElementType fromParamCorType = fromParam.GetNormCorElementType();
        if (CorTypeInfo::IsObjRef(fromParamCorType))
            return(fromParam.CanCastTo(toParam));

        
            // Enums with the same underlying type are interchangable 
        if (CorTypeInfo::IsPrimitiveType(fromParamCorType) &&
            fromParamCorType == toParam.GetNormCorElementType()) {

            EEClass* pFromClass = fromParam.GetClass();
            EEClass* pToClass = toParam.GetClass();
            if (pFromClass && (pFromClass->IsEnum() || pFromClass->IsTruePrimitive()) &&
                pToClass && (pToClass->IsEnum()   || pToClass->IsTruePrimitive())) {
                return(true);
            }
        }

            // Anything else is not a match.
        return(false);
    }

    _ASSERTE(toKind == ELEMENT_TYPE_TYPEDBYREF || CorTypeInfo::IsPrimitiveType(toKind));
    return(true);
}

TypeHandle TypeDesc::GetParent() {

    CorElementType kind = GetNormCorElementType();
    if (CorTypeInfo::IsArray(kind)) {
        _ASSERTE(kind == ELEMENT_TYPE_SZARRAY || kind == ELEMENT_TYPE_ARRAY);
        return g_pArrayClass;
    }
    if (CorTypeInfo::IsPrimitiveType(kind))
        return(g_pObjectClass);
    return(TypeHandle());
}

    
OBJECTREF ParamTypeDesc::CreateClassObj()
{
    THROWSCOMPLUSEXCEPTION();
    if (!m_ReflectClassObject) {

        COMClass::EnsureReflectionInitialized();
        BaseDomain *pBaseDomain = GetDomain();
        
        switch(GetNormCorElementType()) {
        case ELEMENT_TYPE_ARRAY:
        case ELEMENT_TYPE_SZARRAY:
        {
            // Lookup the array to see if we have already built it.
            ReflectArrayClass *newArray = new (pBaseDomain) ReflectArrayClass();
            if (!newArray)
                COMPlusThrowOM();
            newArray->Init((ArrayTypeDesc*)this);
            
            // Let all threads fight over who wins using InterlockedCompareExchange.
            // Only the winner can set m_ReflectClassObject from NULL.      
            // Because memory is coming out of the LoaderHeap we do not delete it .. ;^(
            FastInterlockCompareExchange ((void**)&m_ReflectClassObject, newArray, NULL);
        
        }
        break;
        
        case ELEMENT_TYPE_BYREF:
        case ELEMENT_TYPE_PTR:
        {
            ReflectTypeDescClass *newTD = new (pBaseDomain) ReflectTypeDescClass();
            if (!newTD)
                COMPlusThrowOM();
            newTD->Init(this);
            
            // Let all threads fight over who wins using InterlockedCompareExchange.
            // Only the winner can set m_ReflectClassObject from NULL.      
            // Because memory is coming out of the LoaderHeap we do not delete it .. ;^(
            FastInterlockCompareExchange ((void**)&m_ReflectClassObject, newTD, NULL);
        }
        break;
        
        default:
            _ASSERTE(!"We should never be here");
            return NULL;
        }
    }

    return m_ReflectClassObject->GetClassObject();
}

//
// The MethodNameHash is a temporary loader structure which may be allocated if there are a large number of
// methods in a class, to quickly get from a method name to a MethodDesc (potentially a chain of MethodDescs).
//

// Returns TRUE for success, FALSE for failure
BOOL MethodNameHash::Init(DWORD dwMaxEntries)
{
    // Given dwMaxEntries, determine a good value for the number of hash buckets
    m_dwNumBuckets = (dwMaxEntries / 10);

    if (m_dwNumBuckets < 4)
        m_dwNumBuckets = 4;

    WS_PERF_SET_HEAP(SYSTEM_HEAP);
    // We're given the number of hash table entries we're going to insert, so we can allocate the appropriate size
    m_pMemoryStart = new BYTE[dwMaxEntries*sizeof(MethodHashEntry) + m_dwNumBuckets*sizeof(MethodHashEntry*)];
    if (m_pMemoryStart == NULL)
        return FALSE;
    WS_PERF_UPDATE("MethodNameHash:Init", dwMaxEntries*sizeof(MethodHashEntry) + m_dwNumBuckets*sizeof(MethodHashEntry*), m_pMemoryStart);
#ifdef _DEBUG
    m_pDebugEndMemory = m_pMemoryStart + dwMaxEntries*sizeof(MethodHashEntry) + m_dwNumBuckets*sizeof(MethodHashEntry*);
#endif

    // Current alloc ptr
    m_pMemory       = m_pMemoryStart;

    // Allocate the buckets out of the alloc ptr
    m_pBuckets      = (MethodHashEntry**) m_pMemory;
    m_pMemory += sizeof(MethodHashEntry*)*m_dwNumBuckets;

    // Buckets all point to empty lists to begin with
    memset(m_pBuckets, 0, sizeof(MethodHashEntry*)*m_dwNumBuckets);

    return TRUE;
}

// Insert new entry at head of list
void MethodNameHash::Insert(LPCUTF8 pszName, MethodDesc *pDesc)
{
    DWORD           dwHash = HashStringA(pszName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    MethodHashEntry*pNewEntry;

    pNewEntry = (MethodHashEntry *) m_pMemory;
    m_pMemory += sizeof(MethodHashEntry);

#ifdef _DEBUG
    _ASSERTE(m_pMemory <= m_pDebugEndMemory);
#endif

    // Insert at head of bucket chain
    pNewEntry->m_pNext        = m_pBuckets[dwBucket];
    pNewEntry->m_pDesc        = pDesc;
    pNewEntry->m_dwHashValue  = dwHash;
    pNewEntry->m_pKey         = pszName;

    m_pBuckets[dwBucket] = pNewEntry;
}

// Return the first MethodHashEntry with this name, or NULL if there is no such entry
MethodHashEntry *MethodNameHash::Lookup(LPCUTF8 pszName, DWORD dwHash)
{
    if (!dwHash)
        dwHash = HashStringA(pszName);
    DWORD           dwBucket = dwHash % m_dwNumBuckets;
    MethodHashEntry*pSearch;

    for (pSearch = m_pBuckets[dwBucket]; pSearch; pSearch = pSearch->m_pNext)
    {
        if (pSearch->m_dwHashValue == dwHash && !strcmp(pSearch->m_pKey, pszName))
            return pSearch;
    }

    return NULL;
}

MethodNameHash *MethodNameCache::GetMethodNameHash(EEClass *pParentClass)
{

    MethodNameHash *pMethodHash = NULL;

    for (DWORD i = 0; i < METH_NAME_CACHE_SIZE; i++)
    {
        if (pParentClass == m_pParentClass[i])
        {
            pMethodHash = m_pMethodNameHash[i];
            m_dwNumConsecutiveMisses = 0;
            m_dwWeights[i]++;
            if (m_dwLightWeight == i)
            {
                for (DWORD j = 0; j < METH_NAME_CACHE_SIZE; j++)
                    if (j != i && m_dwWeights[j] < m_dwWeights[i])
                    {
                        m_dwLightWeight = j;
                        break;
                    }
            }
        }
        if (pMethodHash)
            break;
    }
        
    if (!pMethodHash)
    {
        m_dwNumConsecutiveMisses++;

        // There may be such a method, so we will now create a hash table to reduce the pain for
        // further lookups
        pMethodHash = pParentClass->CreateMethodChainHash();
        if (pMethodHash == NULL)
            return NULL;

        DWORD dwWeightOfNewClass = 1 + (pParentClass->GetNumVtableSlots() / 50);
        if (m_dwWeights[m_dwLightWeight] < dwWeightOfNewClass || m_dwNumConsecutiveMisses > MAX_MISSES)
        {
            DWORD index = m_dwLightWeight;
            DWORD oldWeight = m_dwWeights[m_dwLightWeight];
            m_dwWeights[index] = dwWeightOfNewClass;

            if (oldWeight == 0 && m_dwLightWeight < (METH_NAME_CACHE_SIZE - 1))
                m_dwLightWeight++;
            else
                for (DWORD j = 0; j < METH_NAME_CACHE_SIZE; j++)
                    if (j != index && m_dwWeights[j] < dwWeightOfNewClass)
                    {
                        m_dwLightWeight = j;
                        break;
                    }


            if (m_dwNumConsecutiveMisses > MAX_MISSES)
                m_dwNumConsecutiveMisses = 0;

            if (m_pMethodNameHash[index])
                delete m_pMethodNameHash[index];
            m_pMethodNameHash[index] = pMethodHash;
            m_pParentClass[index] = pParentClass;
        }
    }

    return pMethodHash;
}

//
// For each method in Object, we set the bit corresponding to Hash(MethodName).  This allows us to determine
// very easily whether a method definitely does not override something in Object.
//
#define OBJ_CLASS_METHOD_HASH_BITMAP_BITS 103
DWORD               g_ObjectClassMethodHashBitmap[(OBJ_CLASS_METHOD_HASH_BITMAP_BITS/8)+4];
BOOL                g_ObjectClassMethodHashBitmapInited = FALSE;

//@TODO why isn't this defined anywhere?
#define MAX(a,b)    (((a)>(b))?(a):(b))

// Log (base 2) of the size of a pointer on this platform....

#ifndef _WIN64
#define LOG2PTR     2
#else
//#error 64 Bit - Study this carefully before enabling
#define LOG2PTR     3
#endif

#ifdef _DEBUG
static  unsigned g_dupMethods = 0;
#endif

// Define this to cause all vtable and field information to be dumped to the screen
//#define FULL_DEBUG

// mark the class as having its <clinit> run.  (Or it has none)
void MethodTable::SetClassInited()
{
    _ASSERTE(!IsShared() 
             || GetClass()->GetNumStaticFields() == 0 
             || g_Mscorlib.IsClass(this, CLASS__SHARED_STATICS));

    FastInterlockOr(&m_wFlags, enum_flag_ClassInited);
    FastInterlockOr(m_pEEClass->GetVMFlagsPtr(), VMFLAG_INITED);
}

// mark the class as having been restored.
void MethodTable::SetClassRestored()
{
    FastInterlockAnd(&m_wFlags, ~enum_flag_Unrestored);
    FastInterlockAnd(m_pEEClass->GetVMFlagsPtr(), ~(VMFLAG_UNRESTORED | VMFLAG_RESTORING));
}


void MethodTable::SetComObjectType()
{
    m_wFlags |= enum_ComObjectMask;    
    if (m_wNumInterface == 0)
    {
        // if you got zero interfaces you better use the
        // default interface map        
        m_pInterfaceVTableMap = GetThread()->GetDomain()->GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers();
    }
}

// mark as transparent proxy type
void MethodTable::SetTransparentProxyType()
{
    m_wFlags |= enum_TransparentProxy;
    m_pInterfaceVTableMap = GetThread()->GetDomain()->GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers();
}


LPVOID MethodTable::GetComCallWrapperTemplate()
{
    return GetClass()->GetComCallWrapperTemplate();
}

void MethodTable::SetComCallWrapperTemplate(LPVOID pv)
{
    GetClass()->SetComCallWrapperTemplate(pv);
}

LPVOID MethodTable::GetComClassFactory()
{
    return GetClass()->GetComClassFactory();
}

void MethodTable::SetComClassFactory(LPVOID pv)
{
    GetClass()->SetComClassFactory(pv);
}


BOOL MethodTable::IsInterface()
{
    return GetClass()->IsInterface();
}

SIZE_T MethodTable::GetSharedClassIndex()
{
    _ASSERTE(IsShared());

    return GetModule()->GetBaseClassIndex() + RidFromToken(GetClass()->GetCl()) - 1;
}

MethodDesc* MethodTable::GetMethodDescForSlot(DWORD slot)
{
    return GetClass()->GetMethodDescForSlot(slot);
}

MethodDesc* MethodTable::GetUnboxingMethodDescForValueClassMethod(MethodDesc *pMD)
{
    return GetClass()->GetUnboxingMethodDescForValueClassMethod(pMD);
}

MethodTable * MethodTable::GetParentMethodTable()
{
    EEClass* pClass = GetClass()->GetParentClass();
    return (pClass != NULL) ? pClass->GetMethodTable() : NULL;
}

// helper to get parent class skipping over COM class in 
// the hierarchy
MethodTable * MethodTable::GetComPlusParentMethodTable()
{
    EEClass* pClass = GetClass()->GetParentComPlusClass();
    return (pClass != NULL) ? pClass->GetMethodTable() : NULL;
}

BOOL EEClass::IsSharedInterface()
{
    // all shared interfaces in shared domain
    return (IsInterface() && (GetModule()->GetDomain() == SharedDomain::GetDomain()));
}

SLOT* EEClass::GetMethodSlot(MethodDesc* method)
{
    _ASSERTE(m_pMethodTable != NULL);

    DWORD slot = method->GetSlot();

    //
    // Fixup the slot address if necessary
    //

    GetFixedUpSlot(slot);

    //
    // Return the slot
    //

    return(&GetVtable()[slot]);
}

// Get Dispatch vtable for interface
// returns NULL if interface not found.
LPVOID MethodTable::GetDispatchVtableForInterface(MethodTable* pMTIntfClass)
{
    _ASSERTE(!IsThunking());

        DWORD StartSlot;

        // Start by handling pure COM+ objects.
        if (!IsComObjectType())
        {
                StartSlot = GetStartSlotForInterface(pMTIntfClass);
                return StartSlot != -1 ? (LPVOID) &GetVtable()[StartSlot] : NULL;
        }

        // We now handle __ComObject class that doesn't have Dynamic Interface Map
        
        if (!HasDynamicInterfaceMap())
        {
            // parent should be Object for __COmObject
            _ASSERTE(GetParentMethodTable() == g_pObjectClass);
             // Com objects are special, just return the interface vtable.
            return (LPVOID)pMTIntfClass->GetVtable();
        }

        // Now we handle the more complex extensible RCW's. The first thing to do is check
        // to see if the static definition of the extensible RCW specifies that the class
        // implements the interface.
        StartSlot = GetStartSlotForInterface(pMTIntfClass);
        if (StartSlot != -1)
            return (LPVOID) &GetVtable()[StartSlot];

        // The interface is not in the static class definition so we need to look at the
        // dynamic interfaces.
        if (FindDynamicallyAddedInterface(pMTIntfClass))
        {
                // This interface was added to the class dynamically so it is implemented
                // by the COM object. We treat this dynamically added interfaces the same
                // way we treat COM objects. That is by using the interface vtable.
            return (LPVOID)pMTIntfClass->GetVtable();
        }

        // The interface is not implemented by this class.
        return NULL;
}

// get start slot for interface
// returns -1 if interface not found
DWORD MethodTable::GetStartSlotForInterface(MethodTable* pMTIntfClass)
{
    InterfaceInfo_t* pInfo = FindInterface(pMTIntfClass);

    if (pInfo != NULL)
    {
        DWORD startSlot = pInfo->m_wStartSlot;
        _ASSERTE(startSlot != -1);
        return startSlot;
    }

    return -1;
}

// get start slot for interface.
// This does no lookup.  You better know that this MethodTable has an interface
// in its map at that index -- or else you are reading garbage and will die.
DWORD MethodTable::GetStartSlotForInterface(DWORD index)
{
    _ASSERTE(index < m_wNumInterface);
    InterfaceInfo_t* pInfo = &m_pIMap[index];

    _ASSERTE(pInfo != NULL);
    DWORD startSlot = pInfo->m_wStartSlot;

    _ASSERTE(startSlot != -1);
    return startSlot;
}

InterfaceInfo_t *MethodTable::GetInterfaceForSlot(DWORD slotNumber)
{
    InterfaceInfo_t *pInterfaces = m_pIMap;
    InterfaceInfo_t *pInterfacesEnd = m_pIMap + m_wNumInterface; 

    while (pInterfaces < pInterfacesEnd)
    {
        DWORD startSlot = pInterfaces->m_wStartSlot;
        if (slotNumber >= startSlot)
        {
            MethodTable *pMT = pInterfaces->m_pMethodTable;

            // Make sure that all interfaces have no nonvirtual slots - otherwise
            // we need to touch the class object to get the vtable section size
            _ASSERTE(pMT->GetTotalSlots() == pMT->GetClass()->GetNumVtableSlots());

            if (slotNumber - startSlot < pMT->GetTotalSlots())
                return pInterfaces;
        }
        pInterfaces++;
    }

    return NULL;
}

// get the method desc given the interface method desc
MethodDesc *MethodTable::GetMethodDescForInterfaceMethod(MethodDesc *pItfMD, OBJECTREF pServer)
{
    MethodTable * pItfMT =  pItfMD->GetMethodTable();
    _ASSERTE(pItfMT->IsInterface());
    
    MethodTable *pServerMT = pServer->GetMethodTable()->AdjustForThunking(pServer);
    MethodDesc *pMD = NULL;

    // First handle pure COM+ types
    if(!IsComObjectType())
    {
        // Get the start slot using the interface class
        DWORD start = pServerMT->GetStartSlotForInterface(pItfMT);
        if(-1 != start)
        {
            pMD = pServerMT->GetMethodDescForSlot(start + pItfMD->GetSlot());    
        }        
    }
    else
    {
        _ASSERTE(pServerMT == this);

        // We now handle __ComObject class that doesn't have Dynamic Interface Map        
        if (!HasDynamicInterfaceMap())
        {
            pMD = pItfMD;
        }
        else
        {
            // Now we handle the more complex extensible RCW's. The first thing to do is check
            // to see if the static definition of the extensible RCW specifies that the class
            // implements the interface.
            DWORD start = GetStartSlotForInterface(pItfMT);
            if (-1 != start)
            {
                pMD = GetMethodDescForSlot(start + pItfMD->GetSlot());    
            }
            // The interface is not in the static class definition so we need to look at the
            // dynamic interfaces.
            else if (FindDynamicallyAddedInterface(pItfMT))
            {
                // This interface was added to the class dynamically so it is implemented
                // by the COM object. We treat this dynamically added interfaces the same
                // way we treat COM objects. That is by using the interface vtable.
                pMD = pItfMD;
            }
        }
    }

    return pMD;
}

// This is a helper routine to get the address of code from the server and method descriptor
// It is used by remoting to figure out the address to which the method call needs to be 
// dispatched.
const BYTE *MethodTable::GetTargetFromMethodDescAndServer(MethodDesc *pMD, OBJECTREF *ppServer, BOOL fContext)
{
    THROWSCOMPLUSEXCEPTION();

    TRIGGERSGC();

    if(pMD->GetMethodTable()->IsInterface())
    {
        _ASSERTE(*ppServer != NULL);
        MethodDesc* pMDTemp = pMD;

        // NOTE: This method can trigger GC
        pMD = (*ppServer)->GetMethodTable()->GetMethodDescForInterfaceMethod(pMD, *ppServer);
        if(NULL == pMD)
        {
            LPCWSTR szClassName;   
            DefineFullyQualifiedNameForClassW();
            szClassName = GetFullyQualifiedNameForClassW(pMDTemp->GetClass());

            #define MAKE_TRANSLATIONFAILED szMethodName=L""
            MAKE_WIDEPTR_FROMUTF8_FORPRINT(szMethodName, pMDTemp->GetName());
            #undef MAKE_TRANSLATIONFAILED
            
            COMPlusThrow(kMissingMethodException, IDS_EE_MISSING_METHOD, szClassName, szMethodName);
        }
    }

    // get the target depending on whether the method is virtual or non-virtual
    // like a constructor, private or final method
    const BYTE* pTarget = NULL;

    if (pMD->GetMethodTable()->IsInterface())
    {
        // Handle the special cases where the invoke is happening through an interface class 
        // (typically for COM interop).
        pTarget = pMD->GetUnsafeAddrofCode();
    }
    else
    {
        //if(!fContext)
        //{
            pTarget = (pMD->DontVirtualize() ? pMD->GetPreStubAddr() : pMD->GetAddrofCode(*ppServer));
        //}
        /*else
        {
            // This is the case where we are forcing the execution of the call in the current
            // context. We have to infer the actual address of code from either the stub or
            // the vtable.
            if(pMD->DontVirtualize())
            {
                pTarget = NULL;
            }
            else
            {
                MethodTable *pServerMT = (*ppServer)->GetMethodTable()->AdjustForThunking(*ppServer);
                pTarget = (BYTE *)*(pServerMT->GetClass()->GetMethodSlot(pMD));
            }
        }*/
        
    }

    _ASSERTE(NULL != pTarget);

    return pTarget;
}

void *EEClass::operator new(size_t size, ClassLoader *pLoader)
{
#ifdef _DEBUG
    pLoader->m_dwEEClassData += size;
#endif
    void *pTmp;
    WS_PERF_SET_HEAP(LOW_FREQ_HEAP);    
    pTmp = pLoader->GetLowFrequencyHeap()->AllocMem(size);
    WS_PERF_UPDATE_DETAIL("EEClass new LowFreq", size, pTmp);
    return pTmp;
}



// Static helper to create a new method table. This is the only
// way to allocate a new MT. Don't try calling new / ctor.
MethodTable * MethodTable::AllocateNewMT(
    DWORD dwVtableSlots, 
    DWORD dwStaticFieldBytes, 
    DWORD dwGCSize, 
    DWORD dwNumInterfaces, 
    ClassLoader *pLoader, 
    BOOL isIFace, 
    BOOL bHasDynamicInterfaceMap
)
{
    // GCSize must be aligned
    _ASSERTE((dwGCSize & 3) == 0);

    size_t size = sizeof(MethodTable);

#ifdef _DEBUG
    BOOL bEmptyIMap = FALSE;

    // Add an extra slot if the table is empty.
    if (dwNumInterfaces == 0)
    {
        dwNumInterfaces++;
        bEmptyIMap = TRUE;
    }

    // interface map is placed at the end of the vtable,
    // in the debug build, make sure it is not getting trashed
    dwNumInterfaces++;
#endif

    // size without the interface map
    DWORD cbTotalSize = (DWORD)size + dwVtableSlots * sizeof(SLOT) + dwStaticFieldBytes + dwGCSize;

    // size with the interface map. DynamicInterfaceMap have an extra DWORD added to the end of the normal interface
        // map. This will be used to store the count of dynamically added interfaces (the ones that are not in 
        // the metadata but are QI'ed for at runtime).
    DWORD newSize = cbTotalSize + (bHasDynamicInterfaceMap ? sizeof(DWORD) : 0) + dwNumInterfaces * sizeof(InterfaceInfo_t); 

    WS_PERF_SET_HEAP(HIGH_FREQ_HEAP);    
    BYTE *pData = (BYTE *) pLoader->GetHighFrequencyHeap()->AllocMem(newSize);

    if (pData == NULL)
        return NULL;

    WS_PERF_UPDATE_DETAIL("MethodTable:new:HighFreq", newSize, pData);

    MethodTable* pMT = (MethodTable*)(pData + dwGCSize);

#ifdef _DEBUG
    pLoader->m_dwGCSize += dwGCSize;
    pLoader->m_dwInterfaceMapSize += (dwNumInterfaces * sizeof(InterfaceInfo_t));
    pLoader->m_dwMethodTableSize += (DWORD)size;
    pLoader->m_dwVtableData += (dwVtableSlots * sizeof(SLOT));
    pLoader->m_dwStaticFieldData += dwStaticFieldBytes;
#endif

    // initialize the total number of slots 
    pMT->m_cbSlots = dwVtableSlots; 

    // interface map is at the end of the vtable
    pMT->m_pIMap = (InterfaceInfo_t *)(pData+cbTotalSize);                    // pointer interface map

    pMT->m_pInterfaceVTableMap = NULL;

    _ASSERTE(((WORD) dwNumInterfaces) == dwNumInterfaces);

    // in the debug build, keep a dummmy slot just above the IMAP to
    // make sure it is not getting trashed.

#ifdef _DEBUG

    pMT->m_pIMap->m_wStartSlot = 0xCDCD;
    pMT->m_pIMap->m_wFlags = 0xCDCD;
    pMT->m_pIMap->m_pMethodTable = (MethodTable*)((sizeof(int *) == 4)?0xCDCDCDCDL:0xCDCDCDCDCDCDCDCD);
    pMT->m_wNumInterface = (WORD) (dwNumInterfaces-1);

    pMT->m_pIMap = (InterfaceInfo_t*)(((BYTE*)pMT->m_pIMap) + sizeof(InterfaceInfo_t));

    // Readjust the IMap size because we added an extra one above.
    if (bEmptyIMap)
        pMT->m_wNumInterface = 0;
#else

    pMT->m_wNumInterface = (WORD) dwNumInterfaces;

#endif

    // Extensible RCW's are prefixed with the count of dynamic interfaces.
    if (bHasDynamicInterfaceMap)
    {
        pMT->m_pIMap = (InterfaceInfo_t*)(((BYTE*)pMT->m_pIMap) + sizeof(DWORD));
        *(((DWORD *)pMT->m_pIMap) - 1) = 0;
    }

    WS_PERF_UPDATE_COUNTER(METHOD_TABLE, HIGH_FREQ_HEAP, 1);
    WS_PERF_UPDATE_COUNTER(VTABLES, HIGH_FREQ_HEAP, dwVtableSlots * sizeof(SLOT));
    WS_PERF_UPDATE_COUNTER(GCINFO, HIGH_FREQ_HEAP, dwGCSize);
    WS_PERF_UPDATE_COUNTER(INTERFACE_MAPS, HIGH_FREQ_HEAP, dwNumInterfaces*sizeof(InterfaceInfo_t));
    WS_PERF_UPDATE_COUNTER(STATIC_FIELDS, HIGH_FREQ_HEAP, dwStaticFieldBytes);
    
    return pMT;
}

void EEClass::destruct()
{
    // If we haven't been restored, we can ignore the class
    if (!IsRestored())
        return;

    // we can't count on the parent class still being around. If it lives in another module that
    // module may have already been unloaded. So nuke it here and catch any refernces to parent
    // later.
    SetParentClass (NULL);

    if (IsInterface() && m_dwInterfaceId != ((UINT32)(-1)))
    {
        // Mark our entry in the global interface map vtable so it can be reclaimed.
        SystemDomain::GetAddressOfGlobalInterfaceVTableMap()[m_dwInterfaceId] = (LPVOID)(-2);
    }

#ifdef PROFILING_SUPPORTED
    // If profiling, then notify the class is getting unloaded.
    ClassID clsId = NULL;
    if (CORProfilerTrackClasses() && !IsArrayClass())
        g_profControlBlock.pProfInterface->ClassUnloadStarted(
            (ThreadID) GetThread(), clsId = (ClassID) TypeHandle(this).AsPtr());
#endif // PROFILING_SUPPORTED
    
    // clean up any COM Data
    if (m_pccwTemplate)
        CleanupCCWTemplate(m_pccwTemplate);
    m_pccwTemplate = NULL;

    if (m_pComclassfac)
        CleanupComclassfac(m_pComclassfac);
    m_pComclassfac = NULL;
    

    if (IsAnyDelegateClass()) {
        if ( ((DelegateEEClass*)this)->m_pStaticShuffleThunk ) {
            ((DelegateEEClass*)this)->m_pStaticShuffleThunk->DecRef();
        }
        delete ((DelegateEEClass*)this)->m_pUMThunkMarshInfo;
    }

    // The following is rather questionable.  If we are destructing the context
    // proxy class, we don't want it asserting everywhere that its vtable is
    // strange.  So lose the flag to suppress the asserts.  We're unloading the
    // class anyway.
    m_pMethodTable->MarkAsNotThunking();

    // Destruct the method descs by walking the chunks.
    DWORD i, n;
    MethodDescChunk *pChunk = m_pChunks;
    while (pChunk != NULL)
    {
        n = pChunk->GetCount();
        for (i = 0; i < n; i++)
        {
            MethodDesc *pMD = pChunk->GetMethodDescAt(i);
            pMD->destruct();
        }
        pChunk = pChunk->GetNextChunk();
    }

    // Destroy the reflection StaticFinalField stuff
    // @TODO: How should we clean this up.  We are failing because
    //  this stuff is run way after the VM is working.
    //if (*m_ExposedClassObject != NULL) {
    //  REFLECTCLASSBASEREF pRefClass;
    //  pRefClass = (REFLECTCLASSBASEREF) GetExposedClassObject();
    //  FieldDesc* fld = (FieldDesc*) pRefClass->GetData();
    //  if (fld)
    //      delete fld;
    //}

    if (m_pSparseVTableMap != NULL && !GetModule()->IsPreloadedObject(this))
        delete m_pSparseVTableMap;

#ifdef PROFILING_SUPPORTED
    // If profiling, then notify the class is getting unloaded.
    if (CORProfilerTrackClasses() && !IsArrayClass())
        g_profControlBlock.pProfInterface->ClassUnloadFinished((ThreadID) GetThread(), clsId, S_OK);
#endif // PROFILING_SUPPORTED
}



// Subtypes are recorded in a chain from the super, so that we can e.g. backpatch
// up & down the hierarchy.
void EEClass::NoticeSubtype(EEClass *pSub)
{
    // We have no locks around ourselves.  To avoid heavy-weight locking and the
    // potential for deadlocks, all insertions happen with interlocked
    // instructions.  But, during appdomain unloading, the teardown relies on the fact
    // that the EE is suspended and only one thread is active.  Therefore we must be in
    // cooperative mode now to ensure that we are prevented from interfering with an
    // unload.
    BEGIN_ENSURE_COOPERATIVE_GC();

    // Only attempt to be the first child if it looks like no others are present,
    // to avoid excessive LOCK prefixes on MP machines.
    if (m_ChildrenChain == NULL)
        if (FastInterlockCompareExchange((void **) &m_ChildrenChain,
                                         pSub,
                                         NULL) == NULL)
        {
            goto done;
        }

    // We have to add ourselves to the sibling chain.  Add at the head.
    while (TRUE)
    {
        // Grab atomically each time through
        EEClass *pOldHead = m_ChildrenChain;

        _ASSERTE(pOldHead && "How did a remove happen while we are in cooperative mode?");

        pSub->m_SiblingsChain = pOldHead;
        if (FastInterlockCompareExchange((void **) &m_ChildrenChain,
                                         pSub,
                                         pOldHead) == pOldHead)
        {
            break;
        }
        // someone raced to add a sibling.  Skip over all newly added siblings and
        // keep trying.
    }
    
done:
    END_ENSURE_COOPERATIVE_GC();
}

/* static */
TypeHandle TypeHandle::MergeTypeHandlesToCommonParent(TypeHandle ta, TypeHandle tb)
{
    _ASSERTE(!ta.IsNull() && !tb.IsNull());

    if (ta == tb)
        return ta;

    // Handle the array case
    if (ta.IsArray()) 
    {
        if (tb.IsArray())
            return MergeArrayTypeHandlesToCommonParent(ta, tb);
        ta = TypeHandle(g_pArrayClass);         // keep merging from here. 
    }
    else if (tb.IsArray())
        tb = TypeHandle(g_pArrayClass);

    _ASSERTE(ta.IsUnsharedMT() && tb.IsUnsharedMT());


    MethodTable *pMTa = ta.AsMethodTable(); 
    MethodTable *pMTb = tb.AsMethodTable();
    InterfaceInfo_t *pBInterfaceMap;
    InterfaceInfo_t *pAInterfaceMap;
    DWORD i;

    if (pMTb->IsInterface())
    {

        if (pMTa->IsInterface())
        {
            //
            // Both classes are interfaces.  Check that if one 
            // interface extends the other.
            //
            // Does tb extend ta ?
            //

            pBInterfaceMap = pMTb->GetInterfaceMap();

            for (i = 0; i < pMTb->GetNumInterfaces(); i++)
            {
                if (TypeHandle(pBInterfaceMap[i].m_pMethodTable) == ta)
                {
                    // tb extends ta, so our merged state should be ta
                    return ta;
                }
            }

            //
            // Does tb extend ta ?
            //
            pAInterfaceMap = pMTa->GetInterfaceMap();

            for (i = 0; i < pMTa->GetNumInterfaces(); i++)
            {
                if (TypeHandle(pAInterfaceMap[i].m_pMethodTable) == tb)
                {
                    // ta extends tb, so our merged state should be tb
                    return tb;
                }
            }

InterfaceMerge:
            //@TODO: HACK - An incredibly slow work around for the @todo below that
            // allows WFCSelfhost to verify.
            for (i = 0; i < pMTb->GetNumInterfaces(); i++)
            {
                for (DWORD j = 0; j < pMTa->GetNumInterfaces(); j++)
                {
                    if (TypeHandle(pAInterfaceMap[j].m_pMethodTable) == TypeHandle(pBInterfaceMap[i].m_pMethodTable))
                    {
                        return TypeHandle(pAInterfaceMap[j].m_pMethodTable);
                    }
                }
            }

            // @TODO: Create a temp interface which is the intersection of the two interfaces.
        
            // No compatible merge found - using Object
            return TypeHandle(g_pObjectClass);
        }
        else
        {

            //
            // tb is an interface, but ta is not - check that ta
            // implements tb
            //
            // @TODO: Is a class-interface merge legal?
            //
            InterfaceInfo_t *pAInterfaceMap = pMTa->GetInterfaceMap();

            for (i = 0; i < pMTa->GetNumInterfaces(); i++)
            {
                if (TypeHandle(pAInterfaceMap[i].m_pMethodTable) == tb)
                {
                    // It does implement it, so our merged state should be tb
                    return tb;
                }
            }

            // No compatible merge found - using Object
            return TypeHandle(g_pObjectClass);
        }
    }
    else if (pMTa->IsInterface())
    {
        //
        // ta is an interface, but tb is not - therefore check that 
        // tb implements ta
        //


        InterfaceInfo_t *pBInterfaceMap = pMTb->GetInterfaceMap();

        for (i = 0; i < pMTb->GetNumInterfaces(); i++)
        {
            if (TypeHandle(pBInterfaceMap[i].m_pMethodTable) == ta)
            {
                // It does implement it, so our merged state should be ta
                return ta;
            }
        }

        // No compatible merge found - using Object
        return TypeHandle(g_pObjectClass);
    }

    DWORD   aDepth = 0;
    DWORD   bDepth = 0;
    TypeHandle tSearch;

    // find the depth in the class hierarchy for each class
    for (tSearch = ta; (!tSearch.IsNull()); tSearch = tSearch.GetParent())
        aDepth++;

    for (tSearch = tb; (!tSearch.IsNull()); tSearch = tSearch.GetParent())
        bDepth++;
    
    // for whichever class is lower down in the hierarchy, walk up the superclass chain
    // to the same level as the other class
    while (aDepth > bDepth)
    {
        ta = ta.GetParent();
        aDepth--;
    }

    while (bDepth > aDepth)
    {
        tb = tb.GetParent();
        bDepth--;
    }

    while (ta != tb)
    {
        ta = ta.GetParent();
        tb = tb.GetParent();
    }

    if (ta == TypeHandle(g_pObjectClass))
    {
        pBInterfaceMap = pMTb->GetInterfaceMap();
        pAInterfaceMap = pMTa->GetInterfaceMap();
        goto InterfaceMerge;
    }

    // If no compatible merge is found, we end up using Object

    _ASSERTE(!ta.IsNull());

    return ta;
}

/* static */
TypeHandle TypeHandle::MergeArrayTypeHandlesToCommonParent(TypeHandle ta, TypeHandle tb)
{
    TypeHandle taElem;
    TypeHandle tMergeElem;

    // If they match we are good to go.
    if (ta == tb)
        return ta;

    if (ta == TypeHandle(g_pArrayClass))
        return ta;
    else if (tb == TypeHandle(g_pArrayClass))
        return tb;

    // Get the rank and kind of the first array
    DWORD rank = ta.AsArray()->GetRank();
    CorElementType taKind = ta.GetNormCorElementType();
    CorElementType mergeKind = taKind;

    // if no match on the rank the common ancestor is System.Array
    if (rank != tb.AsArray()->GetRank())
        return TypeHandle(g_pArrayClass);

    CorElementType tbKind = tb.GetNormCorElementType();

    if (tbKind != taKind)
    {
        if (CorTypeInfo::IsArray(tbKind) && 
            CorTypeInfo::IsArray(taKind) && rank == 1)
            mergeKind = ELEMENT_TYPE_SZARRAY;
        else
            return TypeHandle(g_pArrayClass);
    }

    // If both are arrays of reference types, return an array of the common
    // ancestor.
    taElem = ta.AsArray()->GetElementTypeHandle();
    if (taElem == tb.AsArray()->GetElementTypeHandle())
    {
        // The element types match, so we are good to go.
        tMergeElem = taElem;
    }
    else if (taElem.IsArray() && tb.AsArray()->GetElementTypeHandle().IsArray())
    {
        // Arrays - Find the common ancestor of the element types.
        tMergeElem = MergeArrayTypeHandlesToCommonParent(taElem, tb.AsArray()->GetElementTypeHandle());
    }
    else if (CorTypeInfo::IsObjRef(taElem.GetSigCorElementType()) &&
            CorTypeInfo::IsObjRef(tb.AsArray()->GetElementTypeHandle().GetSigCorElementType()))
    {
        // Find the common ancestor of the element types.
        tMergeElem = MergeTypeHandlesToCommonParent(taElem, tb.AsArray()->GetElementTypeHandle());
    }
    else
    {
        // The element types have nothing in common.
        return TypeHandle(g_pArrayClass);
    }

    // Load the array of the merged element type.
    return tMergeElem.GetModule()->GetClassLoader()->FindArrayForElem(tMergeElem, mergeKind, rank);
}

EEClassLayoutInfo *EEClass::GetLayoutInfo()
{
    _ASSERTE(HasLayout());
    return &((LayoutEEClass *) this)->m_LayoutInfo;
}

UINT32 EEClass::AssignInterfaceId()
{
    THROWSCOMPLUSEXCEPTION();

    _ASSERTE(IsInterface());
    _ASSERTE(m_dwInterfaceId == -1);

    // !!! HACK COUGH UGGH
    // We currently can only have one "shared" vtable map mgr 
    // - so use the system domain for all shared classes
    BaseDomain *pDomain = GetModule()->GetDomain();

    if (pDomain == SharedDomain::GetDomain())
        pDomain = SystemDomain::System();

    m_dwInterfaceId = pDomain->GetInterfaceVTableMapMgr().AllocInterfaceId();

    return m_dwInterfaceId;
}

void EEClass::GetGuid(GUID *pGuid, BOOL bGenerateIfNotFound)
{
    THROWSCOMPLUSEXCEPTION();

    SIZE_T      cchName;                // Length of the name (possibly after decoration).
    CQuickArray<BYTE> rName;            // Buffer to accumulate signatures.
    SIZE_T      cbCur;                  // Current offset.
    HRESULT     hr = S_OK;              // A result.
    LPWSTR      szName;                 // Name to turn to a guid.
    MethodTable*pMT = GetMethodTable(); // This classes method table.
    BOOL        bGenerated = FALSE;     // A flag indicating if we generated the GUID from name.

    _ASSERTE(pGuid != NULL);

    // First check to see if we have already cached the guid for this type.
    // We currently only cache guids on interfaces.
    if (IsInterface() && pMT->GetGuidInfo())
    {
        if (pMT->GetGuidInfo()->m_bGeneratedFromName)
        {
            // If the GUID was generated from the name then only return it
            // if bGenerateIfNotFound is set.
            if (bGenerateIfNotFound)
                *pGuid = pMT->GetGuidInfo()->m_Guid;
            else
                *pGuid = GUID_NULL;
            }
        else
        {
            *pGuid = pMT->GetGuidInfo()->m_Guid;
        }
        return;
    }

    if (m_VMFlags & VMFLAG_NO_GUID)
        *pGuid = GUID_NULL;
    else
    {
        // If there is a GUID in the metadata then return that.
        GetMDImport()->GetItemGuid(GetCl(), pGuid);

        if (*pGuid == GUID_NULL)
        {
            // Remember that we didn't find the GUID, so we can skip looking during 
            // future checks. (Note that this is a very important optimization in the 
            // prejit case.)

            FastInterlockOr(&m_VMFlags, VMFLAG_NO_GUID);
        }
    }

    if (*pGuid == GUID_NULL && bGenerateIfNotFound)
    {
        // For interfaces, concatenate the signatures of the methods and fields.
        if (!IsNilToken(GetCl()) && IsInterface())
        {
            // Retrieve the stringized interface definition.
            cbCur = GetStringizedItfDef(TypeHandle(GetMethodTable()), rName);

            // Pad up to a whole WCHAR.
            if (cbCur % sizeof(WCHAR))
            {
                SIZE_T cbDelta = sizeof(WCHAR) - (cbCur % sizeof(WCHAR));
                IfFailThrow(rName.ReSize(cbCur + cbDelta));
                memset(rName.Ptr() + cbCur, 0, cbDelta);
                cbCur += cbDelta;
            }

            // Point to the new buffer.
            cchName = cbCur / sizeof(WCHAR);
            szName = reinterpret_cast<LPWSTR>(rName.Ptr());
        }
        else
        {
            // Get the name of the class.
            DefineFullyQualifiedNameForClassW();
            szName = GetFullyQualifiedNameForClassNestedAwareW(this);
            if (szName == NULL)
                return;
            cchName = wcslen(szName);

            // Enlarge buffer for class name.
            cbCur = cchName * sizeof(WCHAR);
            IfFailThrow(rName.ReSize(cbCur+ sizeof(WCHAR) ));
            wcscpy(reinterpret_cast<LPWSTR>(rName.Ptr()), szName);
            
            // Add the assembly guid string to the class name.
            IfFailThrow(GetStringizedTypeLibGuidForAssembly(GetAssembly(), rName, cbCur, &cbCur));

            // Pad to a whole WCHAR.
            if (cbCur % sizeof(WCHAR))
            {
                IfFailThrow(rName.ReSize(cbCur + sizeof(WCHAR)-(cbCur%sizeof(WCHAR))));
                while (cbCur % sizeof(WCHAR))
                    rName[cbCur++] = 0;
            }
            
            // Point to the new buffer.
            szName = reinterpret_cast<LPWSTR>(rName.Ptr());
            cchName = cbCur / sizeof(WCHAR);
            // Dont' want to have to pad.
            _ASSERTE((sizeof(GUID) % sizeof(WCHAR)) == 0);
        }

        // Generate guid from name.
        CorGuidFromNameW(pGuid, szName, cchName);

        // Remeber we generated the guid from the type name.
        bGenerated = TRUE;
    }

    // Cache the guid in the type, if not already cached. 
    // We currently only do this for interfaces.
    if (IsInterface() && !pMT->GetGuidInfo() && *pGuid != GUID_NULL)
    {
        // Allocate the guid information.
        GuidInfo *pInfo = 
            (GuidInfo*)GetClassLoader()->GetHighFrequencyHeap()->AllocMem(sizeof(GuidInfo), TRUE);
        pInfo->m_Guid = *pGuid;
        pInfo->m_bGeneratedFromName = bGenerated;

        // Set in in the interface method table.
        pMT->m_pGuidInfo = pInfo;
    }
}



//==========================================================================
// This function is very specific about how it constructs a EEClass.  It first
// determines the necessary size of the vtable and the number of statics that
// this class requires.  The necessary memory is then allocated for a EEClass
// and its vtable and statics.  The class members are then initialized and
// the memory is then returned to the caller
//
// LPEEClass CreateClass()
//
// Parameters :
//      [in] scope - scope of the current class not the one requested to be opened
//      [in] cl - class token of the class to be created.
//      [out] ppEEClass - pointer to pointer to hold the address of the EEClass
//                        allocated in this function.
// Return : returns an HRESULT indicating the success of this function.
//
// This parameter has been removed but might need to be reinstated if the
// global for the metadata loader is removed.
//      [in] pIMLoad - MetaDataLoader class/object for the current scope.


//==========================================================================
HRESULT EEClass::CreateClass(Module *pModule, mdTypeDef cl, BOOL fHasLayout, BOOL fDelegate, BOOL fIsBlob, BOOL fIsEnum, LPEEClass* ppEEClass)
{
    _ASSERTE(!(fHasLayout && fDelegate));

    HRESULT hr = S_OK;
    EEClass *pEEClass = NULL;
    IMDInternalImport *pInternalImport;
    ClassLoader *pLoader;

    if (!ppEEClass)
        return E_FAIL;
    //============================================================================
    // @TODO - LBS!
    // vtabsize and static size need to be converted from pointer sizes to #'s
    // of bytes this will be very important for 64 bit NT!
    // We will need to call on IMetaDataLoad to get these sizes and fill out the
    // tables

    // From the classref call on metadata to resolve the classref and check scope
    // to make sure that this class is in the same scope otherwise we need to open
    // a new scope and possibly file.

    // if the scopes are different call the code to load a new file and get the new scope

    // scopes are the same so we can use the existing scope to get the class info

    // This method needs to be fleshed out.more it currently just returns enough
    // space for the defined EEClass and the vtable and statics are not set.
    //=============================================================================
    pLoader = pModule->GetClassLoader();

    if (fHasLayout)
    {
        pEEClass = new (pLoader) LayoutEEClass(pLoader);
    }
    else if (fDelegate)
    {
        pEEClass = new (pLoader) DelegateEEClass(pLoader);
    }
    else if (fIsEnum)
    {
        pEEClass = new (pLoader) EnumEEClass(pLoader);
    }
    else
    {
        pEEClass = new (pLoader) EEClass(pLoader);
    }

    if (pEEClass == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    pEEClass->m_cl = cl;

    pInternalImport = pModule->GetMDImport();

    mdToken tkExtends = mdTokenNil;
    pInternalImport->GetTypeDefProps(
        cl,
        &pEEClass->m_dwAttrClass,
        &tkExtends
    );
    DWORD dwAttrClass = pEEClass->m_dwAttrClass; //cache the value to avoid multiple dereferencing

    // MDVal check: can't be both tdSequentialLayout and tdExplicitLayout
    if((dwAttrClass & tdLayoutMask) == tdLayoutMask)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (IsTdInterface(dwAttrClass))
    {
        // MDVal check: must have nil tkExtends and must be tdAbstract
        if((tkExtends & 0x00FFFFFF)||(!IsTdAbstract(dwAttrClass))) { hr = E_FAIL; goto exit; }
        // Set the interface ID to -1 to indicate it hasn't been set yet.
        pEEClass->m_dwInterfaceId = -1;
    }

    //
    // Initialize SecurityProperties structure
    //

    if (Security::IsSecurityOn() && IsTdHasSecurity(dwAttrClass))
    {
        DWORD dwSecFlags;
        DWORD dwNullDeclFlags;

        hr = Security::GetDeclarationFlags(pInternalImport, cl, &dwSecFlags, &dwNullDeclFlags);
        if (FAILED(hr))
            goto exit;

        pEEClass->m_SecProps.SetFlags(dwSecFlags, dwNullDeclFlags);
    }

    if (fIsBlob)
        pEEClass->m_VMFlags |= VMFLAG_ISBLOBCLASS;

    if (pModule->GetAssembly()->IsShared())
        pEEClass->m_VMFlags |= VMFLAG_SHARED;

    if (fHasLayout)
        pEEClass->SetHasLayout();

#ifdef _DEBUG
    pModule->GetClassLoader()->m_dwDebugClasses++;
#endif

exit:
    if (FAILED(hr))
    {
        // @TODO delete pEEClass
        *ppEEClass = NULL;
    }
    else
    {
        *ppEEClass = pEEClass;
    }

    return hr;
}


//
// @TODO: Would be nice to not add Object's ctor method
//
/* static */ void EEClass::CreateObjectClassMethodHashBitmap(EEClass *pObjectClass)
{
    DWORD i;

    for (i = 0; i < pObjectClass->GetNumVtableSlots(); i++)
    {

        MethodDesc *pCurMethod = pObjectClass->GetUnknownMethodDescForSlot(i);
        LPCUTF8 pszMemberName;

        pszMemberName = pCurMethod->GetNameOnNonArrayClass();
        _ASSERTE(pszMemberName != NULL);

        DWORD dwBitNum = HashStringA(pszMemberName) % OBJ_CLASS_METHOD_HASH_BITMAP_BITS;
        g_ObjectClassMethodHashBitmap[dwBitNum >> 3] |= (1 << (dwBitNum & 7));
    }

    g_ObjectClassMethodHashBitmapInited = TRUE;
}

//
// Look at this method carefully before using.
//
// Returns whether this method could exist in this class or its superclasses.  However, constructors
// and clinits are never added to the hash table, so it won't find them.
//
// If this returns 0, the method definitely does NOT exist.  If it returns non-zero, it may exist.
//
/* static */ DWORD EEClass::CouldMethodExistInClass(EEClass *pClass, LPCUTF8 pszMethodName, DWORD dwHashName)
{

    if (dwHashName == 0)
        dwHashName         = HashStringA(pszMethodName);
    DWORD    dwMethodHashBit    = dwHashName % METHOD_HASH_BITS;

    _ASSERTE(pClass != NULL);

    if (pClass->IsInterface())
    {
        // If it's an interface, we search only one node - we do not recurse into the parent, Object
        return (pClass->m_MethodHash[dwMethodHashBit >> 3] & (1 << (dwMethodHashBit & 7)));
    }
    else
    {
        do
        {
            if (pClass->m_MethodHash[dwMethodHashBit >> 3] & (1 << (dwMethodHashBit & 7)))
            {
                // This class may have a method by this name

                // If it's the Object class, we have a second hash bitmap, so if the second hash bitmap says "no",
                // then we're ok
                if (pClass->GetMethodTable() == g_pObjectClass && g_ObjectClassMethodHashBitmapInited)
                {
                    DWORD dwObjBitNum = dwHashName % OBJ_CLASS_METHOD_HASH_BITMAP_BITS;
                    if (g_ObjectClassMethodHashBitmap[dwObjBitNum >> 3] & (1 << (dwObjBitNum & 7)))
                        return TRUE;
                }
                else
                {
                    if (!g_ObjectClassMethodHashBitmapInited)
                        CreateObjectClassMethodHashBitmap(g_pObjectClass->GetClass());
                    return TRUE;
                }
            }

            pClass = pClass->GetParentClass();
        } while (pClass != NULL);
    }

    return FALSE;
}


//
// Create a hash of all methods in this class.  The hash is from method name to MethodDesc.
//
MethodNameHash *EEClass::CreateMethodChainHash()
{
    MethodNameHash * pHash = new MethodNameHash();
    DWORD            i;
    WS_PERF_SET_HEAP(SYSTEM_HEAP);
    WS_PERF_UPDATE("EEClass:MethodHash", 0, pHash);
    if (pHash == NULL)
        goto failure;

    if (pHash->Init(GetNumVtableSlots()) == FALSE)
        goto failure;

    for (i = 0; i < GetNumVtableSlots(); i++)
    {
        MethodDesc *pCurMethod = GetUnknownMethodDescForSlot(i);
        MethodDesc *pRealDesc;      
        if(SUCCEEDED(GetRealMethodImpl(pCurMethod, i, &pRealDesc))) 
        {
            if (pRealDesc != NULL)
            {
                // We use only method names on this class or a base
                // class. If the method impl points to a method 
                // defined on the interface then we use the bodies
                // name.
                if(pRealDesc->IsInterface())
                    pRealDesc = pCurMethod;

                LPCUTF8     pszName = pRealDesc->GetNameOnNonArrayClass();
                
                pHash->Insert(pszName, pCurMethod); // We keep the body alias'd with the derivied
            }
        }
    }

    // success
    return pHash;

failure:
    if (pHash != NULL)
        delete pHash;

    return NULL;
}


EEClass *EEClass::GetEnclosingClass()
{
    if (! IsNested())
        return NULL;

    mdTypeDef tdEnclosing = mdTypeDefNil;
    HRESULT hr = GetModule()->GetMDImport()->GetNestedClassProps(GetCl(), &tdEnclosing);

    _ASSERTE(SUCCEEDED(hr));

    MethodTable *pMT = GetModule()->LookupTypeDef(tdEnclosing).AsMethodTable();
    if (pMT)
        return pMT->GetClass();
    NameHandle name(GetModule(), tdEnclosing);
    return GetClassLoader()->LoadTypeHandle(&name).GetClass();
}

void EEClass::AddChunk(MethodDescChunk *chunk)
{
    chunk->SetNextChunk(m_pChunks);
    m_pChunks = chunk;
}

#ifdef EnC_SUPPORTED

HRESULT EEClass::FixupFieldDescForEnC(EnCFieldDesc *pFD, mdFieldDef fieldDef)
{
    LOG((LF_ENC, LL_INFO100, "EEClass::InitializeFieldDescForEnC %s\n", GetMDImport()->GetNameOfFieldDef(fieldDef)));

#ifdef _DEBUG
    BOOL shouldBreak = g_pConfig->GetConfigDWORD(L"EncFixupFieldBreak", 0);
    if (shouldBreak > 0) {
        _ASSERTE(!"EncFixupFieldBreak");
    }
#endif
    bmtMetaDataInfo bmtMetaData;
    bmtMetaData.cFields = 1;
    bmtMetaData.pFields = (mdToken*)_alloca(sizeof(mdToken));
    bmtMetaData.pFields[0] = fieldDef;
    bmtMetaData.pFieldAttrs = (DWORD*)_alloca(sizeof(DWORD));
    bmtMetaData.pFieldAttrs[0] = GetModule()->GetMDImport()->GetFieldDefProps(fieldDef);

    bmtMethAndFieldDescs bmtMFDescs;
    // We need to alloc the memory, but don't have to fill it in.  InitializeFieldDescs
    // will copy pFD (1st arg) into here.
    bmtMFDescs.ppFieldDescList = (FieldDesc**)_alloca(sizeof(FieldDesc*));

    bmtEnumMethAndFields bmtEnumMF;
    bmtFieldPlacement bmtFP;

    // We don't have to fill this in - it'll be filled in if something goes wrong.
    // We'll ignore it, but a bad HRESULT will be returned, so it's ok.
    bmtErrorInfo bmtError;

    bmtInternalInfo bmtInternal;
    bmtInternal.pInternalImport = GetModule()->GetMDImport();
    bmtInternal.pModule = GetModule();
    bmtInternal.cl = m_cl; // This isn't actually used by InitializeFieldDescs right now,
                           // but it seems too fragile to not fill this in.

    // We shouldn't have to fill this in b/c we're not allowed to EnC value classes, or
    // anything else with layout info associated with it.
    LayoutRawFieldInfo *pLayoutRawFieldInfos = (LayoutRawFieldInfo*)_alloca((2) * sizeof(LayoutRawFieldInfo));
 
    // If not NULL, it means there are some by-value fields, and this contains an entry for each instance or static field,
    // which is NULL if not a by value field, and points to the EEClass of the field if a by value field.  Instance fields
    // come first, statics come second.
    EEClass **pByValueClassCache = NULL;

    // InitializeFieldDescs are going to change these numbers to something wrong,
    // even though we already have the right numbers.  Save & restore after.
    WORD   wNumInstanceFields = m_wNumInstanceFields;
    WORD   wNumStaticFields = m_wNumStaticFields;
    unsigned totalDeclaredFieldSize = 0;

    HRESULT hr = InitializeFieldDescs(pFD, 
                                      pLayoutRawFieldInfos, 
                                      &bmtInternal, 
                                      &bmtMetaData, 
                                      &bmtEnumMF, 
                                      &bmtError, 
                                      &pByValueClassCache, 
                                      &bmtMFDescs, 
                                      &bmtFP,
                                      &totalDeclaredFieldSize);
                                      
    // Restore now
    m_wNumInstanceFields = wNumInstanceFields;
    m_wNumStaticFields = wNumStaticFields;
    
    // PERF: For now, we turn off the fast equality check for valuetypes when a 
    // a field is modified by EnC. Consider doing a check and setting the bit only when
    // necessary.
    if (IsValueClass())
    {
        GetMethodTable()->SetNotTightlyPacked();
    }

    // even if InitializeFieldDesc fails, we want to know which field we're looking at.
    pFD->SetMemberDef(fieldDef); 

    if (! SUCCEEDED(hr))
        return hr;

    if (pByValueClassCache) {
        pFD->SetByValueClass(*pByValueClassCache);
    }
    pFD->SetMethodTable(GetMethodTable());
    pFD->SetEnCNew();
    
    return S_OK;
}

HRESULT EEClass::AddField(mdFieldDef fieldDef)
{
    LOG((LF_ENC, LL_INFO100, "EEClass::AddField %s\n", GetMDImport()->GetNameOfFieldDef(fieldDef)));

    // Here we allocate a FieldDesc and set just enough info to be able to fix it up later
    // when we're running in managed code.
    EnCAddedFieldElement *pAddedField = (EnCAddedFieldElement *) GetClassLoader()->GetHighFrequencyHeap()->AllocMem(sizeof(EnCAddedFieldElement));
    DWORD dwFieldAttrs = GetMDImport()->GetFieldDefProps(fieldDef);
    pAddedField->Init(IsFdStatic(dwFieldAttrs));
    
    EnCFieldDesc *pNewFD = &pAddedField->m_fieldDesc;

    if (pNewFD->IsStatic())
        ++m_wNumStaticFields;
    else
        ++m_wNumInstanceFields;

    EnCEEClassData *pEnCClass = ((EditAndContinueModule*)GetModule())->GetEnCEEClassData(this);
    if (! pEnCClass)
        return E_FAIL;

    pEnCClass->AddField(pAddedField);
    GetModule()->StoreFieldDef(fieldDef, pNewFD);

    pNewFD->SetMethodTable(GetMethodTable());

    // try to fixup the field desc, will fail if have to load classes as are currently running
    // on the debugger thread and then the fd will be marked as needing fixup
    pNewFD->Fixup(fieldDef);

    return S_OK;
}

//
// Add a new method to a class. This could be static, virtual or non-virtual and could override
// an existing virtual.
//
// First we want to do some checks (eg, we've got an RVA or else we're not expecting an RVA).
// Then we classify it based on the type of MethodDesc that we'll create.
// We create a new MethodDescChunk that contains just 1 MethodDesc, which we then initialize.
// Note that this is intended for use in Edit and Continue only - the regular code path
// to follow is through BuildMethodTable.
// 
#define MAX_DIST_FROM_VTABLE 0xFFFF
HRESULT EEClass::AddMethod(mdMethodDef methodDef, COR_ILMETHOD *pNewCode)
{ 
    LOG((LF_ENC, LL_INFO100, "EEClass::AddMethod %s\n", GetMDImport()->GetNameOfMethodDef(methodDef)));
    DWORD dwDescrOffset;
    DWORD dwImplFlags;
    MethodClassification Classification;
    HRESULT hr = S_OK;

    GetMDImport()->GetMethodImplProps(methodDef, &dwDescrOffset, &dwImplFlags);

    DWORD dwMemberAttrs = GetMDImport()->GetMethodDefProps(methodDef);

    if (IsMdAbstract(dwMemberAttrs)) 
    {
        LOG((LF_ENC, LL_INFO100, "**Error** EEClass::AddMethod abstract methods not supported\n"));
        return E_FAIL;
    }

    // for now start with static methods
    // need to add to our linked list
    // then change findmethod to find it here
    // add to rid table
    IMDInternalImport *pImport = GetMDImport();
#ifdef _DEBUG

    mdTypeDef   parentTypeDef;
    
    hr = pImport->GetParentToken(methodDef, &parentTypeDef);

    _ASSERTE(!FAILED(hr)); // If this fails, we'll know why the debug 
                           // build is behaving differently.
    if (FAILED(hr)) 
        return E_FAIL;   

    DWORD dwParentAttrs;
    pImport->GetTypeDefProps(parentTypeDef, &dwParentAttrs, 0); 

    RVA_OR_SHOULD_BE_ZERO(pNewCode, dwParentAttrs, dwMemberAttrs, dwImplFlags, pImport, methodDef);

#endif //_DEBUG

    // Determine the classification of the method being added. 
    if (pNewCode == 0 && ((IsReallyMdPinvokeImpl(dwMemberAttrs) || IsMiInternalCall(dwImplFlags)) && NDirect::HasNAT_LAttribute(pImport, methodDef)==S_OK))
    {
        Classification = mcNDirect;
    }
    else if (IsInterface() && !IsMdStatic(dwMemberAttrs))
    {
        Classification = mcComInterop;
    }
    else if (IsMiRuntime(dwImplFlags))
    {
        Classification = mcEEImpl;
    }
    else
    {
        Classification = mcIL;
    }

    // Create the chunk somewhere we'll know is within range of the VTable
    MethodDescChunk *pChunk = MethodDescChunk::CreateChunk(GetClassLoader()->GetHighFrequencyHeap(),
                                                           1, 
                                                           Classification, 
                                                           ::GetTokenRange(methodDef));
    if (pChunk == NULL)
        return E_OUTOFMEMORY;
        
    pChunk->SetMethodTable(GetMethodTable());
    MethodDesc *pNewMD = pChunk->GetFirstMethodDesc();
    memset(pNewMD, 0, sizeof(MethodDesc));

    // Set the method desc's classification and chunk index.
    pNewMD->SetChunkIndex(0, Classification);

    LPCSTR pName = NULL;
    if (Classification == mcEEImpl)
    {
        pName = pImport->GetNameOfMethodDef(methodDef);
    }

    hr = InitMethodDesc(pNewMD,
                        Classification,
                        methodDef,
                        dwImplFlags,
                        dwMemberAttrs,
                        TRUE,
                        // subtract base because code expects an RVA and will add base back to get actual address
                        (DWORD)((Classification == mcNDirect ||
                                 Classification == mcEEImpl) 
                                 ? 0 : (BYTE *)pNewCode - GetModule()->GetILBase()),
                        GetModule()->GetILBase(),
                        pImport,  
                        pName
#ifdef _DEBUG
                        , pImport->GetNameOfMethodDef(methodDef),
                        m_szDebugClassName,
                        NULL 
#endif //_DEBUG 
                        );

    if (FAILED(hr))
    {
        return hr;
    }

    SLOT *pSlotMemory;
    MethodDesc *pParentMD = NULL;
    // need to check if we are overriding an pre-existing virtual function, in which case want to just
    // update this class' slot rather than create a new one. We start searching at one above this class as 
    // will always find it in current class (because has been added to the delta PE). If no parent, then
    // couldn't be overriding an inherited slot. If are overriding, make sure isn't an override of a function
    // added via EnC, in which case don't have a slot to update
    if (pNewMD->IsVirtual() &&
            this->GetParentClass() != NULL &&
            (pParentMD = ((EditAndContinueModule*)GetModule())->FindVirtualFunction(this->GetParentClass(), methodDef)) != NULL &&
            ! pParentMD->IsEnCNewVirtual()) 
    {
        // just write over the existing slot where we are overriding
        pSlotMemory = pParentMD->GetSlot() + GetVtable();
        pNewMD->SetSlot(pParentMD->GetSlot());     // use same slot as parent
        LOG((LF_ENC, LL_INFO100, "  EEClass::AddMethod using existing slot %d\n", pParentMD->GetSlot()/sizeof(SLOT) ));
    } 
    else 
    {
        // Method not overriding an existing slot, so need new slot
        // The new slot needs to be located appropriately.
        const BYTE *pVTable = (const BYTE *)GetVtable();
        const BYTE *pLowerBound = pVTable;
        const BYTE *pUpperBound = pVTable + MAX_DIST_FROM_VTABLE;
        
        LoaderHeap *pHeap = GetClassLoader()->GetHighFrequencyHeap();

        // Can we find acceptable memory within the heap?  I hope so!
        if ( pHeap->CanAllocMemWithinRange(sizeof(SLOT), 
                                           (BYTE *)pLowerBound, 
                                           (BYTE *)pUpperBound, 
                                           TRUE))
        {
            // method not overriding an existing slot, so need new slot
            pSlotMemory = (SLOT *) pHeap->AllocMem(sizeof(SLOT));
            // If we couldn't get something, well, we're screwed, so give up
            if (!pSlotMemory)
            {
                return CORDBG_E_ENC_INTERNAL_ERROR;
            }
        }
        else
        {
            // Guess not - but we've got a backup!!  Go look for some of that
            // memory that we squirreled away immediately following the methodtables
            // in memory.
        
            // @todo Win64 different alignment for win64?
            // This needs to be DWORD aligned, if not drop the first couple bytes
            if( (WORD)pLowerBound % 4 != 0)
                pLowerBound += (WORD)pLowerBound % 4;
        
            // This needs to be DWORD aligned, if not drop the last couple bytes
            if( (WORD)pUpperBound % 4 != 0)
                pUpperBound -= (WORD)pUpperBound % 4;

            _ASSERTE((WORD)pLowerBound % 4 == 0);
            _ASSERTE((WORD)pUpperBound % 4 == 0);

            // In SetupMethodTables, we added extra slots to be used here.  Go get one that's
            // in range.
            EditAndContinueModule *pEACM = (EditAndContinueModule*)GetModule();
            _ASSERTE(pEACM!=NULL);
            
            pSlotMemory = (SLOT *)pEACM->m_pRangeList->FindIdWithinRange(pLowerBound, pUpperBound);
            // If we couldn't get something, well, we're screwed, so give up
            if (!pSlotMemory)
            {
                return CORDBG_E_ENC_INTERNAL_ERROR;
            }

            // Now remove the slot we just used
            SLOT *pEnd = pSlotMemory;

            // First we should figure out if there was any more space in the range we got.      
            // Shouldn't be a lot of work, since ENC_EXTRA_SLOT_COUNT should be small
            for(int i = 0; i < ENC_EXTRA_SLOT_COUNT; i++)
            {
                if(!pEACM->m_pRangeList->IsInRange((const BYTE *)pEnd))
                {
                    _ASSERTE(pEnd > pSlotMemory);
                    break;
                }

                // See if the next element is here.
                pEnd++;
            }

            // Yank the range.
            pEACM->m_pRangeList->RemoveRanges(pSlotMemory);
            LOG((LF_CORDB, LL_INFO10000, "EEC:AM: removed range (0x%x, 0x%x) from SLOT pool\n",
                            (const BYTE *)pSlotMemory, (const BYTE *)pEnd));

            // If there's still space, add the remaining space back in.
            if (pEnd > pSlotMemory)
            {
                LOG((LF_CORDB, LL_INFO10000, "EEC:AM: Re-added range (0x%x, 0x%x) to SLOT pool\n",
                                (const BYTE *)(pSlotMemory+1), (const BYTE *)pEnd));

                // Note that just like in SetupMethodTable, pEnd will point to memory that's
                // NOT valid - it's one beyond the range.
                BOOL fAdded = pEACM->m_pRangeList->AddRange((const BYTE *)(pSlotMemory+1), 
                                              (const BYTE *)pEnd, 
                                              (pSlotMemory+1));

                // We'll re-use the space we just freed in RemoveRanges, above
                _ASSERTE(fAdded); 
            }
        }
       
        pNewMD->SetSlot((WORD)(pSlotMemory - GetVtable()));     // this makes the slot index refer to our new slot @TODO - LBS pointer math
        if (pNewMD->IsVirtual())
            pNewMD->SetEnCNewVirtual();
            
        LOG((LF_ENC, LL_INFO100, "  EEClass::AddMethod adding new slot\n"));
    }

    *pSlotMemory = (SLOT) pNewMD->GetPreStubAddr();
    _ASSERTE(((BYTE*)pSlotMemory - (BYTE*)GetVtable()) % 4 == 0); // should always be 4-byte aligned, but just in case
    _ASSERTE(((pSlotMemory - GetVtable()) >= -32768) &&
             ((pSlotMemory - GetVtable()) <= 32767)); // Slot number is only 16 bits.

    if ((pSlotMemory - GetVtable()) < -32768 || ((pSlotMemory - GetVtable()) > 32767))
        return E_OUTOFMEMORY;

    GetModule()->StoreMethodDef(methodDef, pNewMD);

    return S_OK;
}
#endif // EnC_SUPPORTED

//
// Find a method in this class hierarchy - used ONLY by the loader during layout.  Do not use at runtime.
//
// *ppMethodHash may be NULL - if so, a MethodNameHash may be created.
// *ppMemberSignature must be NULL on entry - it and *pcMemberSignature may or may not be filled out
//
// ppMethodDesc will be filled out with NULL if no matching method in the hierarchy is found.
//
// Returns FALSE if there was an error of some kind.
//
HRESULT EEClass::LoaderFindMethodInClass(
    MethodNameHash **   ppMethodHash,
    LPCUTF8             pszMemberName,
    Module*             pModule,
    mdMethodDef         mdToken,
    MethodDesc **       ppMethodDesc,
    PCCOR_SIGNATURE *   ppMemberSignature,
    DWORD *             pcMemberSignature,
    DWORD               dwHashName
)
{
    MethodHashEntry *pEntry;
    DWORD            dwNameHashValue;

    _ASSERTE(pModule);
    _ASSERTE(*ppMemberSignature == NULL);

    // No method found yet
    *ppMethodDesc = NULL;

    // Use the hash bitmap to exclude the easy cases
    if (CouldMethodExistInClass(GetParentClass(), pszMemberName, dwHashName) == 0)
        return S_OK; // No such method by this name exists in the hierarchy

    // Have we created a hash of all the methods in the class chain?
    if (*ppMethodHash == NULL)
    {
        // There may be such a method, so we will now create a hash table to reduce the pain for
        // further lookups

        // Optimization disabled until synchronization issues sorted out
        //*ppMethodHash = g_pMethodNameCache->GetMethodNameHash(GetParentClass()); 
        *ppMethodHash = GetParentClass()->CreateMethodChainHash();
        if (ppMethodHash == NULL)
            return E_OUTOFMEMORY;
    }

    // We have a hash table, so use it
    pEntry = (*ppMethodHash)->Lookup(pszMemberName, dwHashName);
    if (pEntry == NULL)
        return S_OK; // No method by this name exists in the hierarchy

    // Get signature of the method we're searching for - we will need this to verify an exact name-signature match
    *ppMemberSignature = pModule->GetMDImport()->GetSigOfMethodDef(
        mdToken,
        pcMemberSignature
    );

    // Hash value we are looking for in the chain
    dwNameHashValue = pEntry->m_dwHashValue;

    // We've found a method with the same name, but the signature may be different
    // Traverse the chain of all methods with this name
    while (1)
    {
        PCCOR_SIGNATURE pHashMethodSig;
        DWORD       cHashMethodSig;

        // Get sig of entry in hash chain
        pEntry->m_pDesc->GetSig(&pHashMethodSig, &cHashMethodSig);

        if (MetaSig::CompareMethodSigs(*ppMemberSignature, *pcMemberSignature, pModule,
                                       pHashMethodSig, cHashMethodSig, pEntry->m_pDesc->GetModule()))
        {
            // Found a match
            *ppMethodDesc = pEntry->m_pDesc;
            return S_OK;
        }

        // Advance to next item in the hash chain which has the same name
        do
        {
            pEntry = pEntry->m_pNext; // Next entry in the hash chain

            if (pEntry == NULL)
                return S_OK; // End of hash chain, no match found
        } while ((pEntry->m_dwHashValue != dwNameHashValue) || (strcmp(pEntry->m_pKey, pszMemberName) != 0));
    }

    return S_OK;
}


//
// Given an interface map to fill out, expand pNewInterface (and its sub-interfaces) into it, increasing
// pdwInterfaceListSize as appropriate, and avoiding duplicates.
//
BOOL EEClass::ExpandInterface(InterfaceInfo_t *pInterfaceMap, 
                              EEClass *pNewInterface, 
                              DWORD *pdwInterfaceListSize, 
                              DWORD *pdwMaxInterfaceMethods,
                              BOOL fDirect)
{
    DWORD i;

    // The interface list contains the fully expanded set of interfaces from the parent then
    // we start adding all the interfaces we declare. We need to know which interfaces
    // we declare but do not need duplicates of the ones we declare. This means we can
    // duplicate our parent entries.

    // Is it already present in the list?
    for (i = 0; i < (*pdwInterfaceListSize); i++)
    {
        if (pInterfaceMap[i].m_pMethodTable == pNewInterface->m_pMethodTable) {
            if(fDirect)
                pInterfaceMap[i].m_wFlags |= InterfaceInfo_t::interface_declared_on_class;
            return TRUE; // found it, don't add it again
        }
    }

    if (pNewInterface->GetNumVtableSlots() > *pdwMaxInterfaceMethods)
        *pdwMaxInterfaceMethods = pNewInterface->GetNumVtableSlots();

    // Add it and each sub-interface
    pInterfaceMap[*pdwInterfaceListSize].m_pMethodTable = pNewInterface->m_pMethodTable;
    pInterfaceMap[*pdwInterfaceListSize].m_wStartSlot = (WORD) -1;
    pInterfaceMap[*pdwInterfaceListSize].m_wFlags = 0;

    if(fDirect)
        pInterfaceMap[*pdwInterfaceListSize].m_wFlags |= InterfaceInfo_t::interface_declared_on_class;

    (*pdwInterfaceListSize)++;

    InterfaceInfo_t* pNewIPMap = pNewInterface->m_pMethodTable->GetInterfaceMap();
    for (i = 0; i < pNewInterface->m_wNumInterfaces; i++)
    {
        if (ExpandInterface(pInterfaceMap, pNewIPMap[i].m_pMethodTable->GetClass(), pdwInterfaceListSize, pdwMaxInterfaceMethods, FALSE) == FALSE)
            return FALSE;
    }

    return TRUE;
}



//
// Fill out a fully expanded interface map, such that if we are declared to implement I3, and I3 extends I1,I2,
// then I1,I2 are added to our list if they are not already present.
//
// Returns FALSE for failure.  Currently we don't fail, but @TODO perhaps we should fail if we recurse
// too much.
//
BOOL EEClass::CreateInterfaceMap(BuildingInterfaceInfo_t *pBuildingInterfaceList, InterfaceInfo_t *pInterfaceMap, DWORD *pdwInterfaceListSize, DWORD *pdwMaxInterfaceMethods)
{
    WORD    i;

    *pdwInterfaceListSize = 0;
    // First inherit all the parent's interfaces.  This is important, because our interface map must
    // list the interfaces in identical order to our parent.
    if (GetParentClass() != NULL)
    {
        InterfaceInfo_t *pParentInterfaceMap = GetParentClass()->GetInterfaceMap();

        // The parent's interface list is known to be fully expanded
        for (i = 0; i < GetParentClass()->m_wNumInterfaces; i++)
        {
            // Need to keep track of the interface with the largest number of methods
            if (pParentInterfaceMap[i].m_pMethodTable->GetClass()->GetNumVtableSlots() > *pdwMaxInterfaceMethods)
                *pdwMaxInterfaceMethods = pParentInterfaceMap[i].m_pMethodTable->GetClass()->GetNumVtableSlots();

            pInterfaceMap[*pdwInterfaceListSize].m_pMethodTable = pParentInterfaceMap[i].m_pMethodTable;
            pInterfaceMap[*pdwInterfaceListSize].m_wStartSlot = (WORD) -1;
            pInterfaceMap[*pdwInterfaceListSize].m_wFlags = 0;
            (*pdwInterfaceListSize)++;
        }
    }

    // Go through each interface we explicitly implement (if a class), or extend (if an interface)
    for (i = 0; i < m_wNumInterfaces; i++)
    {
        EEClass *pDeclaredInterface = pBuildingInterfaceList[i].m_pClass;

        if (ExpandInterface(pInterfaceMap, pDeclaredInterface, pdwInterfaceListSize, pdwMaxInterfaceMethods, TRUE) == FALSE)
            return FALSE;
    }

    return TRUE;
}


// Do a test on the execeptions to see if it is set. This routine assumes 
// that the throwable has been protected. It also disables GC in debug to
// keep the ASSERTS quite. This is not necessary in retail because we
// are just checking of non-null not a specific value (which may change
// during GC)
BOOL EEClass::TestThrowable(OBJECTREF* pThrowable)
{
    if (!pThrowableAvailable(pThrowable))
        return FALSE;

    _ASSERTE(IsProtectedByGCFrame(pThrowable));

    BOOL result;

#ifdef _DEBUG
    BEGIN_ENSURE_COOPERATIVE_GC();
#endif

    result = *pThrowable != NULL;

#ifdef _DEBUG
    END_ENSURE_COOPERATIVE_GC();
#endif
    return result;
}

//
// Builds the method table, allocates MethodDesc, handles overloaded members, attempts to compress
// interface storage.  All dependent classes must already be resolved!
//
// Interface compression strategy:
//
// (NOTE: We do not build interface maps for interfaces - we do have an interface map structure,
//        but this simply lists all the interfaces - the slot number is set to -1).
//
// Stage 1: An interface map is created.  The interface map is a list of ALL interfaces which this
//          class implements, whether they were declared explicitly, or were inherited from the
//          parent class, or through interface inheritance.
//
//          First, the parent's interface map is copied (the parent's interface map is guaranteed
//          to be fully expanded).  Then new interfaces are added to it - for each interface which
//          this class explicitly implements, that interface and all of its sub-interfaces are
//          added to the interface map (duplicates are not added).
//
//          Example: Parent class's interface map is { I1 }
//                   Derived class extends Parent, implements I2
//                   Interface I2 extends I3, I4
//
//          Then the Derived class's interface map will be: { I1, I2, I3, I4 }
//
// Stage 2: We enumerate all the methods in our class.  Methods which are "other" methods
//          (i.e. non-vtable methods, such as statics and privates) are handled separately, and
//          will not be discussed further.
//
//          Each vtable method (i.e. non-private and non-static methods) is then enumerated
//          and then designated as placed (and given a vtable slot number) or unplaced (given a
//          -1 vtable slot number).
//
//          If it overrides a parent method, then it is automatically placed - it must use the
//          same slot.
//
//          If it is not an interface method -that is, no interface implemented by this class has
//          such a method, then it is placed in the first available vtable slot.
//
//          Otherwise, if it is an interface method, then is set to be unplaced (given slot -1).
//
// Stage 3: Interface placement.
//
// Stage 3A)Inherited placement.  We attempt to copy as much as we can from the parent's interface
//          map.  The parent's interface map is guaranteed to list interfaces in the same order as
//          our own interface map.
//
//          We can steal interface placement information from the parent only if the interface in
//          question lies entirely within the parent's class vtable methods (i.e. does not extend
//          into the duplicated vtable slot area).  That is, the Interface.VtableStartSlot +
//          Interface.NumMethods < ParentClass.VtableSize.
//
// Stage 3B)By this point, we know how many vtable slots are required for the class, since we
//          know how many methods the parent had, how many were overridden, and how many are new.
//          If we need to duplicate some vtable slots to create interface lists, these duplications will
//          occur starting at this point in the vtable (dwCurrentDuplicateVtableSlot).
//
//          For each interface in our interface map, we look at all methods in that interface.
//
//          a) If NONE of those methods have been placed, then we place them all, in the order
//          given by the interface, starting at the first available vtable slot.  We update the
//          placed slot number for each placed method.  The interface map entry for this interface
//          is updated to point at the correct starting vtable slot.
//
//          b) If ALL of the methods were already placed, but they were all placed in consecutive
//          vtable slots, then we simply point the interface map entry for this interface at the
//          appropriate slot.  Just because their placement slot numbers weren't consecutive,
//          it doesn't mean that these methods don't exist somewhere consecutively.  For example,
//          they could exist in the vtable at dwCurrentDuplicateVtableSlot or later (being
//          duplicated in the correct order for some other interface).  So we look there also,
//          to see if we can find all of our interface methods laid out in the correct order,
//          anywhere in the entire vtable.
//
//          Failing a) and b), we create a vtable slot for each interface method, starting at
//          dwCurrentDuplicateVtableSlot (the value of this variable is advanced as we add more
//          duplicate slots).  Some of the methods we are creating duplicate slots for may be
//          class methods which have never been placed, so if they haven't, they are placed at
//          the first available vtable slot.
//
// @FUTURE: If a derived class declares that it implements I1, I2, but I2 extends I1, then it
//          would be advantageous to rearrange the order of declared interfaces.  If we place
//          I1 first, there is no guarantee that we can gain any compression from placing I2
//          after it - we may need to create some duplicate slots.  On the other hand, if we
//          place I2 then I1, I1 will fit entirely inside I2.
//
/****************************************************************************************
    IMPORTANT NOTE: 

    The following is the new version of BuildMethodTable. It has been factored into 
    smaller functions so that it is easier to manage. The old version is located at the
    bottom of this file for reference purposes. It has been commented out. 

    @TODO: remove the old version of BuildMethodTable near the end of M10, or when we 
            are comfortable with the new version.

*****************************************************************************************/
HRESULT EEClass::BuildMethodTable(Module *pModule,
                                  mdToken cl,
                                  BuildingInterfaceInfo_t *pBuildingInterfaceList,
                                  const LayoutRawFieldInfo *pLayoutRawFieldInfos,
                                  OBJECTREF *pThrowable)
{
    HRESULT hr = S_OK;
    
    // The following structs, defined as private members of EEClass, contain the necessary local
    // parameters needed for BuildMethodTable

    // Look at the struct definitions for a detailed list of all parameters available
    // to BuildMethodTable.
    
    bmtErrorInfo bmtError;
    bmtProperties bmtProp;
    bmtVtable bmtVT;
    bmtParentInfo bmtParent;
    bmtInterfaceInfo bmtInterface;
    bmtEnumMethAndFields bmtEnumMF;
    bmtMetaDataInfo bmtMetaData;
    bmtMethAndFieldDescs bmtMFDescs;
    bmtFieldPlacement bmtFP;
    bmtInternalInfo bmtInternal;
    bmtGCSeries bmtGCSeries;
    bmtMethodImplInfo bmtMethodImpl;

    //Initialize structs

    bmtError.resIDWhy = IDS_CLASSLOAD_GENERIC;          // Set the reason and the offending method def. If the method information
    bmtError.pThrowable =  pThrowable;

    bmtInternal.pInternalImport = pModule->GetMDImport();
    bmtInternal.pModule = pModule;
    bmtInternal.cl = cl;

    // If not NULL, it means there are some by-value fields, and this contains an entry for each instance or static field,
    // which is NULL if not a by value field, and points to the EEClass of the field if a by value field.  Instance fields
    // come first, statics come second.
    EEClass **pByValueClassCache = NULL;
   
    // If not NULL, it means there are some by-value fields, and this contains an entry for each inst

#ifdef _DEBUG
    LPCUTF8 className;
    LPCUTF8 nameSpace;
    bmtInternal.pInternalImport->GetNameOfTypeDef(cl, &className, &nameSpace);

    unsigned fileNameSize = 0;
    LPCWSTR fileName = NULL;
    if (pModule->IsPEFile()) {
        fileName = pModule->GetPEFile()->GetLeafFileName();
        if (fileName != 0)
            fileNameSize = (unsigned int) wcslen(fileName) + 2;
    }

    m_szDebugClassName = (char*) GetClassLoader()->GetHighFrequencyHeap()->AllocMem(sizeof(char)*(strlen(className) + strlen(nameSpace) + fileNameSize + 2));
    _ASSERTE(m_szDebugClassName);   
    strcpy(m_szDebugClassName, nameSpace); 
    if (strlen(nameSpace) > 0) {
        m_szDebugClassName[strlen(nameSpace)] = '.';
        m_szDebugClassName[strlen(nameSpace) + 1] = '\0';
    }
    strcat(m_szDebugClassName, className); 

    if (fileNameSize != 0) {
        char* ptr = m_szDebugClassName + strlen(m_szDebugClassName);
        *ptr++ = '[';
        while(*fileName != 0)
            *ptr++ = char(*fileName++);
        *ptr++ = ']';
        *ptr++ = 0;
    }

    if (g_pConfig->ShouldBreakOnClassBuild(className)) {
        _ASSERTE(!"BreakOnClassBuild");
        m_fDebuggingClass = TRUE;
    }
#endif // _DEBUG

    DWORD i;

    COMPLUS_TRY 
    {

        //Get Check Point for the thread-based allocator
        Thread *pThread = GetThread();
        void* checkPointMarker = pThread->m_MarshalAlloc.GetCheckpoint();

        
        // this class must not already be resolved
        _ASSERTE(IsResolved() == FALSE);

        // If this is mscorlib, then don't perform some sanity checks on the layout
        bmtProp.fNoSanityChecks = ((g_pObjectClass != NULL) && pModule == g_pObjectClass->GetModule());

#ifdef _DEBUG
        LPCUTF8 pszDebugName,pszDebugNamespace;
        
        pModule->GetMDImport()->GetNameOfTypeDef(GetCl(), &pszDebugName, &pszDebugNamespace);

        LOG((LF_CLASSLOADER, LL_INFO1000, "Loading class \"%s%s%s\" from module \"%ws\" in domain 0x%x %s\n",
            *pszDebugNamespace ? pszDebugNamespace : "",
            *pszDebugNamespace ? NAMESPACE_SEPARATOR_STR : "",
            pszDebugName,
            pModule->GetFileName(),
            pModule->GetDomain(),
            (pModule->IsSystem()) ? "System Domain" : ""
        ));
#endif

        // Interfaces have a parent class of Object, but we don't really want to inherit all of
        // Object's virtual methods, so pretend we don't have a parent class - at the bottom of this
        // function we reset GetParentClass()
        if (IsInterface())
        {
            SetParentClass (NULL);
        }

        // Check to see if the class is an valuetype
        hr = CheckForValueType(&bmtError);
        IfFailGoto(hr, exit);

        // Check to see if the class is an enumeration
        hr = CheckForEnumType(&bmtError);
        IfFailGoto(hr, exit);
        

        // Com Import classes are special
        if (IsComImport() && IsClass())
        {
            if(GetParentClass() != g_pObjectClass->GetClass())
            {
                // ComImport classes can't extend from any other class
                bmtError.resIDWhy = IDS_CLASSLOAD_CANTEXTEND;
                IfFailGoto(COR_E_TYPELOAD, exit);
            }
            
            if(HasLayout())
            {
                // ComImport classes cannot have layout information.
                bmtError.resIDWhy = IDS_CLASSLOAD_COMIMPCANNOTHAVELAYOUT;
                IfFailGoto(COR_E_TYPELOAD, exit);
            }

            // ComImport classes extend from our _ComObject Class
            MethodTable *pCOMMT = SystemDomain::GetDefaultComObject();
            _ASSERTE(pCOMMT);
            SetParentClass (pCOMMT->GetClass());

            // if the current class is imported
            bmtProp.fIsComObjectType = TRUE;
        }

        if (GetParentClass())
        {
            // parent class must already be resolved
            _ASSERTE(GetParentClass()->IsResolved());
            if (GetParentClass()->GetMethodTable()->IsComObjectType())
            {
                // if the parent class is of ComObectType
                // so is the child
                bmtProp.fIsComObjectType = TRUE;
            }
        }
        else if (! (IsInterface() ) ) {

            if(g_pObjectClass != NULL) {
                BYTE* base = NULL;
                Assembly* pAssembly = pModule->GetAssembly();
                if(pAssembly && pAssembly->GetManifestFile())
                    base = pAssembly->GetManifestFile()->GetBase();

                if(base != g_pObjectClass->GetAssembly()->GetManifestFile()->GetBase() &&
                   GetCl() != COR_GLOBAL_PARENT_TOKEN)
                {
                    bmtError.resIDWhy = IDS_CLASSLOAD_PARENTNULL;
                    IfFailGoto(COR_E_TYPELOAD, exit);            
                }
            }
        }

        // Check for special types.
        hr = CheckForSpecialTypes(&bmtInternal, &bmtProp);
        IfFailGoto(hr, exit);

        // Set the contextful or marshalbyref flag if necessary
        hr = SetContextfulOrByRef(&bmtInternal);
        IfFailGoto(hr, exit);

        // resolve unresolved interfaces, determine an upper bound on the size of the interface map,
        // and determine the size of the largest interface (in # slots)
        hr = ResolveInterfaces(pBuildingInterfaceList, &bmtInterface, &bmtProp, &bmtVT, &bmtParent);
        IfFailGoto(hr, exit);
        
        // Enumerate this class's members
        hr = EnumerateMethodImpls(&bmtInternal, &bmtEnumMF, &bmtMetaData, &bmtMethodImpl, &bmtError);
        IfFailGoto(hr, exit);

        // Enumerate this class's members
        hr = EnumerateClassMembers(&bmtInternal, 
                                   &bmtEnumMF, 
                                   &bmtMFDescs,
                                   &bmtProp, 
                                   &bmtMetaData,
                                   &bmtVT, 
                                   &bmtError);
        IfFailGoto(hr, exit);

        WS_PERF_SET_HEAP(SYSTEM_HEAP);

         // Allocate a MethodDesc* for each method (needed later when doing interfaces), and a FieldDesc* for each field
        hr = AllocateMethodFieldDescs(&bmtProp, &bmtMFDescs, &bmtMetaData, &bmtVT, 
                                      &bmtEnumMF, &bmtInterface, &bmtFP, &bmtParent);
        IfFailGoto(hr, exit);

        unsigned totalDeclaredFieldSize=0;

        // Go thru all fields and initialize their FieldDescs.
        hr = InitializeFieldDescs(m_pFieldDescList, pLayoutRawFieldInfos, &bmtInternal, 
                                  &bmtMetaData, &bmtEnumMF, &bmtError, 
                                  &pByValueClassCache, &bmtMFDescs, &bmtFP,
                                  &totalDeclaredFieldSize);
        IfFailGoto(hr, exit);

        // Determine vtable placement for each member in this class
        hr = PlaceMembers(&bmtInternal, &bmtMetaData, &bmtError, 
                          &bmtProp, &bmtParent, &bmtInterface, 
                          &bmtMFDescs, &bmtEnumMF, 
                          &bmtMethodImpl, &bmtVT);
        IfFailGoto(hr, exit);

        // First copy what we can leverage from the parent's interface map.
        // The parent's interface map will be identical to the beginning of this class's interface map (i.e.
        // the interfaces will be listed in the identical order).
        if (bmtParent.dwNumParentInterfaces > 0)
        {
            InterfaceInfo_t *pParentInterfaceList = GetParentClass()->GetInterfaceMap();

#ifdef _DEBUG
            // Check that the parent's interface map is identical to the beginning of this 
            // class's interface map
            for (i = 0; i < bmtParent.dwNumParentInterfaces; i++)
                _ASSERTE(pParentInterfaceList[i].m_pMethodTable == bmtInterface.pInterfaceMap[i].m_pMethodTable);
#endif

            for (i = 0; i < bmtParent.dwNumParentInterfaces; i++)
            {
#ifdef _DEBUG
                MethodTable *pMT = pParentInterfaceList[i].m_pMethodTable;
                EEClass* pClass = pMT->GetClass();

                // If the interface resides entirely inside the parent's class methods (i.e. no duplicate
                // slots), then we can place this interface in an identical spot to in the parent.
                //
                // Note carefully: the vtable for this interface could start within the first GetNumVtableSlots()
                // entries, but could actually extend beyond it, if we were particularly efficient at placing
                // this interface, so check that the end of the interface vtable is before
                // GetParentClass()->GetNumVtableSlots().

                _ASSERTE(pParentInterfaceList[i].m_wStartSlot + pClass->GetNumVtableSlots() <= 
                         GetParentClass()->GetNumVtableSlots());
#endif
                // Interface lies inside parent's methods, so we can place it
                bmtInterface.pInterfaceMap[i].m_wStartSlot = pParentInterfaceList[i].m_wStartSlot;
            }
        }

        //
        // If we are a class, then there may be some unplaced vtable methods (which are by definition
        // interface methods, otherwise they'd already have been placed).  Place as many unplaced methods
        // as possible, in the order preferred by interfaces.  However, do not allow any duplicates - once
        // a method has been placed, it cannot be placed again - if we are unable to neatly place an interface,
        // create duplicate slots for it starting at dwCurrentDuplicateVtableSlot.  Fill out the interface
        // map for all interfaces as they are placed.
        //
        // If we are an interface, then all methods are already placed.  Fill out the interface map for
        // interfaces as they are placed.
        //
        if (!IsInterface())
        {
            hr = PlaceVtableMethods(&bmtInterface, &bmtVT, &bmtMetaData, &bmtInternal, &bmtError, &bmtProp, &bmtMFDescs);
            IfFailGoto(hr, exit);

            hr = PlaceMethodImpls(&bmtInternal, &bmtMethodImpl, &bmtError, &bmtInterface, &bmtVT);
            IfFailGoto(hr, exit);

        }


        // If we're a value class, we want to create duplicate slots and MethodDescs for all methods in the vtable
        // section (i.e. not privates or statics).
        hr = DuplicateValueClassSlots(&bmtMetaData, &bmtMFDescs, 
                                      &bmtInternal, &bmtVT);
        IfFailGoto(hr, exit);


        // ensure we filled out all vtable slots
        _ASSERTE(bmtVT.dwCurrentVtableSlot == GetNumVtableSlots());

#ifdef _DEBUG
        if (IsInterface() == FALSE)
        {
            for (i = 0; i < m_wNumInterfaces; i++)
                _ASSERTE(bmtInterface.pInterfaceMap[i].m_wStartSlot != (WORD) -1);
        }
#endif

        // Place all non vtable methods
        for (i = 0; i < bmtVT.dwCurrentNonVtableSlot; i++)
        {
            MethodDesc *pMD = (MethodDesc *) bmtVT.pNonVtable[i];

            _ASSERTE(pMD->m_wSlotNumber == i);
            pMD->m_wSlotNumber += (WORD) bmtVT.dwCurrentVtableSlot;
            bmtVT.pVtable[pMD->m_wSlotNumber] = (SLOT) pMD->GetPreStubAddr();
        }

        if (bmtVT.wDefaultCtorSlot != MethodTable::NO_SLOT)
            bmtVT.wDefaultCtorSlot += (WORD) bmtVT.dwCurrentVtableSlot;

        if (bmtVT.wCCtorSlot != MethodTable::NO_SLOT)
            bmtVT.wCCtorSlot += (WORD) bmtVT.dwCurrentVtableSlot;

        bmtVT.dwCurrentNonVtableSlot += bmtVT.dwCurrentVtableSlot;

        // ensure we didn't overflow the temporary vtable
        _ASSERTE(bmtVT.dwCurrentNonVtableSlot <= bmtVT.dwMaxVtableSize);

        m_wNumMethodSlots = (WORD) bmtVT.dwCurrentNonVtableSlot;


        // Place static fields
        hr = PlaceStaticFields(&bmtVT, &bmtFP, &bmtEnumMF);
        IfFailGoto(hr, exit);

#if _DEBUG
        if (m_wNumStaticFields > 0)
        {
            LOG((LF_CODESHARING, 
                 LL_INFO10000, 
                 "Placing %d %sshared statics (%d handles) for class %s.\n", 
                 m_wNumStaticFields, IsShared() ? "" : "un", m_wNumHandleStatics, 
                 pszDebugName));
        }
#endif
  
    //#define NumStaticFieldsOfSize $$$$$
    //#define StaticFieldStart $$$$$
    
        if (IsBlittable())
        {
            m_wNumGCPointerSeries = 0;
            bmtFP.NumInstanceGCPointerFields = 0;

#if 0
            // If an explicit size is specified in the metadata, this represents
            // a C-style struct with no EE-recognizable fields.
            ULONG cbTotalSize = 0;
            if (SUCCEEDED(pModule->GetMDImport()->GetClassTotalSize(cl, &cbTotalSize)) && cbTotalSize)
            {
                m_dwNumInstanceFieldBytes = cbTotalSize;
            }
            else
#endif
            {
                _ASSERTE(HasLayout());
                m_dwNumInstanceFieldBytes = ((LayoutEEClass*)this)->GetLayoutInfo()->m_cbNativeSize;
            }
        }
        else
        {
            _ASSERTE(!IsBlittable());

            if (HasExplicitFieldOffsetLayout()) 
            {
                hr = HandleExplicitLayout(&bmtMetaData, &bmtMFDescs, pByValueClassCache, &bmtInternal, &bmtGCSeries, &bmtError);
            }
            else
            {
                // Place instance fields
                hr = PlaceInstanceFields(&bmtFP, &bmtEnumMF, &bmtParent, &bmtError, &pByValueClassCache);
            }
            IfFailGoto(hr, exit);
        }
        
            // We enforce that all value classes have non-zero size
        if (IsValueClass() && m_dwNumInstanceFieldBytes == 0)
        {
            bmtError.resIDWhy = IDS_CLASSLOAD_ZEROSIZE;
            hr = COR_E_TYPELOAD;
            goto exit;
        }
        // Now setup the method table
        hr = SetupMethodTable(&bmtVT, 
                              &bmtInterface,  
                              &bmtInternal,  
                              &bmtProp,  
                              &bmtMFDescs,  
                              &bmtEnumMF,  
                              &bmtError,  
                              &bmtMetaData,  
                              &bmtParent);
        IfFailGoto(hr, exit);

        if (IsValueClass() && (m_dwNumInstanceFieldBytes != totalDeclaredFieldSize || HasOverLayedField()))
        {
            GetMethodTable()->SetNotTightlyPacked();
        }

        // If this is an interface then assign the interface ID.
        if (IsInterface())
        {
            // Assign the interface ID.
            AssignInterfaceId();
            GetCoClassAttribInfo();

#ifdef _DEBUG
            LPCUTF8 pszDebugName,pszDebugNamespace;
            pModule->GetMDImport()->GetNameOfTypeDef(cl, &pszDebugName, &pszDebugNamespace);
    
            LOG((LF_CLASSLOADER, LL_INFO1000, "Interface class \"%s%s%s\" given Interface ID 0x%x by AppDomain 0x%x %s\n",
                *pszDebugNamespace ? pszDebugNamespace : "",
                *pszDebugNamespace ? "." : "",
                pszDebugName,
                m_dwInterfaceId,
                pModule->GetDomain(),
                (pModule->IsSystem()) ? "System Domain" : ""
                ));
#endif
        }

        if (IsSharedInterface())
            // need to copy this to all the appdomains interface managers
            SystemDomain::PropogateSharedInterface(GetInterfaceId(), GetMethodTable()->GetVtable());
        else if (IsInterface())
            // it's an interface but not shared, so just save it in our own interface manager
            (GetModule()->GetDomain()->GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers())[GetInterfaceId()] = (LPVOID)(GetMethodTable()->GetVtable());

        if (HasExplicitFieldOffsetLayout()) 
            // Perform relevant GC calculations for tdexplicit
            hr = HandleGCForExplicitLayout(&bmtGCSeries);
        else
            // Perform relevant GC calculations for value classes
            hr = HandleGCForValueClasses(&bmtFP, &bmtEnumMF, &pByValueClassCache);

        IfFailGoto(hr, exit);

        // GC reqires the series to be sorted.  
        // TODO: fix it so that we emit them in the correct order in the first place.  
        if (GetMethodTable()->ContainsPointers()) 
        { 
            CGCDesc* gcDesc = CGCDesc::GetCGCDescFromMT(GetMethodTable());
            qsort(gcDesc->GetLowestSeries(), (int)gcDesc->GetNumSeries(), sizeof(CGCDescSeries), compareCGCDescSeries);
        }
        
        if (!GetMethodTable()->HasClassConstructor()
            && (!IsShared() || bmtEnumMF.dwNumStaticFields == 0))
        {
            // Mark the class as needing no static initialization
            SetInited();
        }

        // Notice whether this class requires finalization
        GetMethodTable()->MaybeSetHasFinalizer();
        
#if CHECK_APP_DOMAIN_LEAKS
        // Figure out if we're domain agile..
        // Note that this checks a bunch of field directly on the class & method table, 
        // so it needs to come late in the game.
        hr = SetAppDomainAgileAttribute();
        IfFailGoto(hr, exit);
#endif

        // Figure out if CCW's created to expose this type to COM need to be agile.
        SetCCWAppDomainAgileAttribute();

        // Create handles for the static fields that contain object references 
        // and allocate the ones that are value classes.
        hr = CreateHandlesForStaticFields(&bmtEnumMF, &bmtInternal, &pByValueClassCache, &bmtVT, &bmtError);
        IfFailGoto(hr, exit);


        // If we have a non-interface class, then do inheritance security
        // checks on it. The check starts by checking for inheritance
        // permission demands on the current class. If these first checks
        // succeeded, then the cached declared method list is scanned for
        // methods that have inheritance permission demands.
        hr = VerifyInheritanceSecurity(&bmtInternal, &bmtError, &bmtParent, &bmtEnumMF);
        IfFailGoto(hr, exit);

        // We need to populate our com map with an system ids. They are globally unique and
        // fit into our table.
        hr = MapSystemInterfaces();
        IfFailGoto(hr, exit);

        // Check for the RemotingProxy Attribute
        if (IsContextful())
        {
            _ASSERTE(g_pObjectClass);
            // Skip mscorlib marshal-by-ref classes since they all 
            // are assumed to have the default proxy attribute
            if (!(pModule == g_pObjectClass->GetModule()))
            {
                hr = CheckForRemotingProxyAttrib(&bmtInternal,&bmtProp);
                IfFailGoto(hr, exit);
            }
        }

        _ASSERTE(SUCCEEDED(hr));

            // structs with GC poitners MUST be pointer sized aligned because the GC assumes it
        if (IsValueClass() && GetMethodTable()->ContainsPointers() &&  m_dwNumInstanceFieldBytes % sizeof(void*) != 0)
        {
            bmtError.resIDWhy = IDS_CLASSLOAD_BADFORMAT;
            hr = COR_E_TYPELOAD;
            goto exit;
        }
       
exit:
        if (SUCCEEDED(hr))
        {
            if (g_pObjectClass == NULL)
            {
                // Create a hash of all Object's method names in a special bitmap
                LPCUTF8 pszName;
                LPCUTF8 pszNamespace;
                
                // First determine whether we are Object
                GetMDImport()->GetNameOfTypeDef(GetCl(), &pszName, &pszNamespace);
                
                if (!strcmp(pszName, "Object") && !strcmp(pszNamespace, g_SystemNS))
                    CreateObjectClassMethodHashBitmap(this);
            }

            if (IsInterface())
            {
                // Reset parent class
                SetParentClass (g_pObjectClass->GetClass());
            }

            SetResolved();

            // NOTE. NOTE!! the EEclass can now be accessed by other threads.
            // Do NOT place any initialization after this pointer

#ifdef _DEBUG
            NameHandle name(pModule, cl);
            _ASSERTE (pModule->GetClassLoader()->LookupInModule(&name).IsNull()
                      && "RID map already has this MethodTable");
#endif
            // !!! JIT can get to a MT through FieldDesc.
            // !!! We need to publish MT before FieldDesc's.
            if (!pModule->StoreTypeDef(cl, TypeHandle(GetMethodTable())))
                hr = E_OUTOFMEMORY;
            else
            {
                // Now that the class is ready, fill out the RID maps
                hr = FillRIDMaps(&bmtMFDescs, &bmtMetaData, &bmtInternal);

                // Okay the EEClass is all set to go, insert the class into our clsid hash table
                // Note: Only insert the type if it isn't a value class.
                if (!IsValueClass())
                    GetClassLoader()->InsertClassForCLSID(this);
            }
        } else {

            LPCUTF8 pszClassName, pszNameSpace;
            pModule->GetMDImport()->GetNameOfTypeDef(GetCl(), &pszClassName, &pszNameSpace);

            if ((! bmtError.dMethodDefInError || bmtError.dMethodDefInError == mdMethodDefNil) &&
                bmtError.szMethodNameForError == NULL) {
                if (hr == E_OUTOFMEMORY)
                    PostOutOfMemoryException(pThrowable);
                else
                    pModule->GetAssembly()->PostTypeLoadException(pszNameSpace, pszClassName,
                                                                  bmtError.resIDWhy, pThrowable);
            }
            else {
                LPCUTF8 szMethodName;
                if(bmtError.szMethodNameForError == NULL)
                    szMethodName = (bmtInternal.pInternalImport)->GetNameOfMethodDef(bmtError.dMethodDefInError);
                else
                    szMethodName = bmtError.szMethodNameForError;

                pModule->GetAssembly()->PostTypeLoadException(pszNameSpace, pszClassName,
                                                              szMethodName, bmtError.resIDWhy, pThrowable);
            }
        }

#ifdef _DEBUG
        if (g_pConfig->ShouldDumpOnClassLoad(pszDebugName))
        {
            LOG((LF_ALWAYS, LL_ALWAYS, "Method table summary for '%s':\n", pszDebugName));
            LOG((LF_ALWAYS, LL_ALWAYS, "Number of static fields: %d\n", bmtEnumMF.dwNumStaticFields));
            LOG((LF_ALWAYS, LL_ALWAYS, "Number of instance fields: %d\n", bmtEnumMF.dwNumInstanceFields));
            LOG((LF_ALWAYS, LL_ALWAYS, "Number of static obj ref fields: %d\n", bmtEnumMF.dwNumStaticObjRefFields));
            LOG((LF_ALWAYS, LL_ALWAYS, "Number of declared fields: %d\n", bmtEnumMF.dwNumDeclaredFields));
            LOG((LF_ALWAYS, LL_ALWAYS, "Number of declared methods: %d\n", bmtEnumMF.dwNumDeclaredMethods));
            DebugDumpVtable(pszDebugName, false);
            DebugDumpFieldLayout(pszDebugName, false);
            DebugDumpGCDesc(pszDebugName, false);
        }
#endif
       
        STRESS_LOG3(LF_CLASSLOADER,  LL_INFO1000, "BuildMethodTable: finished method table for module %p token %x = %pT \n",
             pModule, cl, GetMethodTable());
        
        //deallocate space allocated by the thread-based allocator
        pThread->m_MarshalAlloc.Collapse(checkPointMarker);
    
        if (bmtParent.pParentMethodHash != NULL)
            delete(bmtParent.pParentMethodHash);
        WS_PERF_UPDATE_DETAIL("BuildMethodTable:DELETE", 0, bmtParent.pParentMethodHash);

        if (bmtMFDescs.ppUnboxMethodDescList != NULL)
            delete[] bmtMFDescs.ppUnboxMethodDescList;
        WS_PERF_UPDATE_DETAIL("BuildMethodTable:DELETE []", 0, bmtMFDescs.ppUnboxMethodDescList);

        if (bmtMFDescs.ppMethodAndFieldDescList != NULL)
            delete[] bmtMFDescs.ppMethodAndFieldDescList;
        WS_PERF_UPDATE_DETAIL("BuildMethodTable:DELETE []", 0, bmtMFDescs.ppMethodAndFieldDescList);

        // delete our temporary vtable
        if (bmtVT.pVtable != NULL)
            delete[] bmtVT.pVtable;
        WS_PERF_UPDATE_DETAIL("BuildMethodTable:DELETE []", 0, bmtVT.pVtable);

        // pFields and pMethods are allocated on the stack so we don't need to delete them.

        if (pByValueClassCache != NULL)
            HeapFree(GetProcessHeap(), 0, pByValueClassCache);
        WS_PERF_UPDATE_DETAIL("BuildMethodTable:DELETE []", 0, pByValueClassCache);

        if (bmtEnumMF.fNeedToCloseEnumField)
            (bmtInternal.pInternalImport)->EnumClose(&bmtEnumMF.hEnumField);

        if (bmtEnumMF.fNeedToCloseEnumMethod)
            (bmtInternal.pInternalImport)->EnumClose(&bmtEnumMF.hEnumMethod);

        if (bmtEnumMF.fNeedToCloseEnumMethodImpl) {
            (bmtInternal.pInternalImport)->EnumMethodImplClose(&bmtEnumMF.hEnumBody,
                                                               &bmtEnumMF.hEnumDecl);
        }
            
#ifdef _DEBUG
        if (FAILED(hr))
        {
            // This totally junk code allows setting a breakpoint on this line
            hr = hr;
        }
#endif
    }
    COMPLUS_CATCH
    {
        hr = COR_E_TYPELOAD;
    } 
    COMPLUS_END_CATCH
    return hr;
}


HRESULT EEClass::MapSystemInterfaces()
{
    // Loop through our interface map to ensure that all the system interfaces are defined in our
    // com map.
    Assembly* pAssembly = GetAssembly();
    AppDomain* pDomain = SystemDomain::GetCurrentDomain();
    return MapSystemInterfacesToDomain(pDomain);
}

HRESULT EEClass::MapSystemInterfacesToDomain(AppDomain* pDomain)
{
    if(pDomain != (AppDomain*) SystemDomain::System()) {
        if(IsInterface()) {
            _ASSERTE(GetMethodTable());
            MapInterfaceFromSystem(pDomain, GetMethodTable());
        }
        InterfaceInfo_t *pMap = GetInterfaceMap();
        DWORD size = GetMethodTable()->GetNumInterfaces();
        for(DWORD i = 0; i < size; i ++) {
            MethodTable* pTable = pMap[i].m_pMethodTable;
            MapInterfaceFromSystem(pDomain, pTable);
        }
    }
    return S_OK;
}

/* static */
HRESULT EEClass::MapInterfaceFromSystem(AppDomain* pDomain, MethodTable* pTable)
{
    Module *pModule = pTable->GetModule();
    BaseDomain* pOther = pModule->GetDomain();
    // !!! HACK COUGH UGGH
    // We currently can only have one "shared" vtable map mgr 
    // - so use the system domain for all shared classes
    if (pOther == SharedDomain::GetDomain())
        pOther = SystemDomain::System();

    if(pOther == SystemDomain::System()) {
        EEClass* pClass = pTable->GetClass();

        DWORD id = pClass->GetInterfaceId();
        pDomain->GetInterfaceVTableMapMgr().EnsureInterfaceId(id);
        (pDomain->GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers())[id] = (LPVOID)(pTable->GetVtable());
    }
    return S_OK;
}

//
// Used by BuildMethodTable
//
// Resolve unresolved interfaces, determine an upper bound on the size of the interface map,
// and determine the size of the largest interface (in # slots)
//

HRESULT EEClass::ResolveInterfaces(BuildingInterfaceInfo_t *pBuildingInterfaceList, bmtInterfaceInfo* bmtInterface, bmtProperties* bmtProp, bmtVtable* bmtVT, bmtParentInfo* bmtParent)
{
    HRESULT hr = S_OK;
    DWORD i;
    Thread *pThread = GetThread();

    // resolve unresolved interfaces, determine an upper bound on the size of the interface map,
    // and determine the size of the largest interface (in # slots)
    bmtInterface->dwMaxExpandedInterfaces = 0; // upper bound on max # interfaces implemented by this class

    // First look through the interfaces explicitly declared by this class
    for (i = 0; i < m_wNumInterfaces; i++)
    {
        EEClass *pInterface = pBuildingInterfaceList[i].m_pClass;

        _ASSERTE(pInterface->IsResolved());

        bmtInterface->dwMaxExpandedInterfaces += (1+ pInterface->m_wNumInterfaces);
    }

    // Now look at interfaces inherited from the parent
    if (GetParentClass() != NULL)
    {
        InterfaceInfo_t *pParentInterfaceMap = GetParentClass()->GetInterfaceMap();

        for (i = 0; i < GetParentClass()->m_wNumInterfaces; i++)
        {
            MethodTable *pMT = pParentInterfaceMap[i].m_pMethodTable;
            EEClass *pClass = pMT->GetClass();

            bmtInterface->dwMaxExpandedInterfaces += (1+pClass->m_wNumInterfaces);
        }
    }

    // Create a fully expanded map of all interfaces we implement
    bmtInterface->pInterfaceMap = (InterfaceInfo_t *) pThread->m_MarshalAlloc.Alloc(sizeof(InterfaceInfo_t) * bmtInterface->dwMaxExpandedInterfaces);
    if (bmtInterface->pInterfaceMap == NULL)
    {
        IfFailRet(E_OUTOFMEMORY);
    }

    // # slots of largest interface
    bmtInterface->dwLargestInterfaceSize = 0;

    if (CreateInterfaceMap(pBuildingInterfaceList, bmtInterface->pInterfaceMap, &bmtInterface->dwInterfaceMapSize, &bmtInterface->dwLargestInterfaceSize) == FALSE)
    {
        IfFailRet(COR_E_TYPELOAD);
    }
        
    _ASSERTE(bmtInterface->dwInterfaceMapSize <= bmtInterface->dwMaxExpandedInterfaces);

    if (bmtInterface->dwLargestInterfaceSize > 0)
    {
        // This is needed later - for each interface, we get the MethodDesc pointer for each
        // method.  We need to be able to persist at most one interface at a time, so we
        // need enough memory for the largest interface.
        bmtInterface->ppInterfaceMethodDescList = (MethodDesc**) 
            pThread->m_MarshalAlloc.Alloc(bmtInterface->dwLargestInterfaceSize * sizeof(MethodDesc*));
        if (bmtInterface->ppInterfaceMethodDescList == NULL)
        {
            IfFailRet(E_OUTOFMEMORY);
        }
    }

    // For all the new interfaces we bring in, sum the methods
    bmtInterface->dwTotalNewInterfaceMethods = 0;
    if (GetParentClass() != NULL)
    {
        for (i = GetParentClass()->m_wNumInterfaces; i < (bmtInterface->dwInterfaceMapSize); i++)
            bmtInterface->dwTotalNewInterfaceMethods += 
                bmtInterface->pInterfaceMap[i].m_pMethodTable->GetClass()->GetNumVtableSlots();
    }

    // The interface map is probably smaller than dwMaxExpandedInterfaces, so we'll copy the
    // appropriate number of bytes when we allocate the real thing later.

    // Update m_wNumInterfaces to be for the fully expanded interface list
    m_wNumInterfaces = (WORD) bmtInterface->dwInterfaceMapSize;

    // Inherit parental slot counts
    if (GetParentClass() != NULL)
    {
        bmtVT->dwCurrentVtableSlot      = GetParentClass()->GetNumVtableSlots();
        bmtParent->dwNumParentInterfaces   = GetParentClass()->m_wNumInterfaces;
        bmtParent->NumParentPointerSeries  = GetParentClass()->m_wNumGCPointerSeries;

        if (GetParentClass()->HasFieldsWhichMustBeInited())
            m_VMFlags |= VMFLAG_HAS_FIELDS_WHICH_MUST_BE_INITED;
    }
    else
    {
        bmtVT->dwCurrentVtableSlot         = 0;
        bmtParent->dwNumParentInterfaces   = 0;
        bmtParent->NumParentPointerSeries  = 0;
    }

    memset(m_MethodHash, 0, METHOD_HASH_BYTES);

    bmtVT->dwCurrentNonVtableSlot      = 0;

    // Init the currently number of vtable slots to the number that our parent has - we inc
    // this as we find non-overloaded instnace methods.
    SetNumVtableSlots ((WORD) bmtVT->dwCurrentVtableSlot);

    bmtInterface->pppInterfaceImplementingMD = (MethodDesc ***) pThread->m_MarshalAlloc.Alloc(sizeof(MethodDesc *) * bmtInterface->dwMaxExpandedInterfaces);
    memset(bmtInterface->pppInterfaceImplementingMD, 0, sizeof(MethodDesc *) * bmtInterface->dwMaxExpandedInterfaces);

    return hr;

}

HRESULT EEClass::EnumerateMethodImpls(bmtInternalInfo* bmtInternal, 
                                      bmtEnumMethAndFields* bmtEnumMF, 
                                      bmtMetaDataInfo* bmtMetaData,
                                      bmtMethodImplInfo* bmtMethodImpl,
                                      bmtErrorInfo* bmtError)
{
    HRESULT hr = S_OK;
    IMDInternalImport *pMDInternalImport = bmtInternal->pInternalImport;
    DWORD rid, attr, maxRidMD, maxRidMR;
    mdToken tkParent, tkGrandparent;
    PCCOR_SIGNATURE pSigDecl=NULL,pSigBody = NULL;
    ULONG           cbSigDecl, cbSigBody;
    hr = pMDInternalImport->EnumMethodImplInit(m_cl, 
                                               &(bmtEnumMF->hEnumBody),
                                               &(bmtEnumMF->hEnumDecl));
    if (SUCCEEDED(hr)) {
        bmtEnumMF->fNeedToCloseEnumMethodImpl = true;
        bmtEnumMF->dwNumberMethodImpls = pMDInternalImport->EnumMethodImplGetCount(&(bmtEnumMF->hEnumBody),
                                                                                   &(bmtEnumMF->hEnumDecl));
        
        if(bmtEnumMF->dwNumberMethodImpls) {
            bmtMetaData->pMethodBody = (mdToken*) GetThread()->m_MarshalAlloc.Alloc(bmtEnumMF->dwNumberMethodImpls *
                                                                                    sizeof(mdToken));
            bmtMetaData->pMethodDecl = (mdToken*) GetThread()->m_MarshalAlloc.Alloc(bmtEnumMF->dwNumberMethodImpls *
                                                                                    sizeof(mdToken));
            bmtMethodImpl->pBodyDesc = (MethodDesc**) GetThread()->m_MarshalAlloc.Alloc(bmtEnumMF->dwNumberMethodImpls *
                                                                                        sizeof(MethodDesc*));
            bmtMethodImpl->pDeclDesc = (MethodDesc**) GetThread()->m_MarshalAlloc.Alloc(bmtEnumMF->dwNumberMethodImpls *
                                                                                        sizeof(MethodDesc*));
            bmtMethodImpl->pDeclToken = (mdToken*) GetThread()->m_MarshalAlloc.Alloc(bmtEnumMF->dwNumberMethodImpls *
                                                                                     sizeof(mdToken));
            mdToken theBody,theDecl;
            mdToken* pBody = bmtMetaData->pMethodBody;
            mdToken* pDecl = bmtMetaData->pMethodDecl;
            
            maxRidMD = pMDInternalImport->GetCountWithTokenKind(mdtMethodDef);
            maxRidMR = pMDInternalImport->GetCountWithTokenKind(mdtMemberRef);
            for(DWORD i = 0; i < bmtEnumMF->dwNumberMethodImpls; i++) {
                
                if(!pMDInternalImport->EnumMethodImplNext(&(bmtEnumMF->hEnumBody),
                                                          &(bmtEnumMF->hEnumDecl),
                                                          &theBody,
                                                          pDecl))
                break;
                
                if(TypeFromToken(theBody) != mdtMethodDef) {
                    Module* pModule;
                    hr = FindMethodDeclaration(bmtInternal,
                                               theBody,
                                               pBody,
                                               TRUE,
                                               &pModule,
                                               bmtError);
                    if(FAILED(hr)) {
                        //_ASSERTE(SUCCEEDED(hr) && "MethodImpl Body: FindMethodDeclaration failed");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_ILLEGAL_BODY;
                        IfFailRet(hr);
                    }
                    _ASSERTE(pModule == bmtInternal->pModule);
                    theBody = *pBody;
                }
                else 
                    *pBody = theBody;

                // Now that the tokens of Decl and Body are obtained, do the MD validation

                // Decl may ne a MemberRef
                theDecl = *pDecl;
                rid = RidFromToken(theDecl);
                if(TypeFromToken(theDecl) == mdtMethodDef) 
                {
                    // Decl must be valid token
                    if ((rid == 0)||(rid > maxRidMD))
                    {
                        //_ASSERTE(!"MethodImpl Decl token out of range");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_ILLEGAL_TOKEN_DECL;
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // Decl must be mdVirtual
                    attr = pMDInternalImport->GetMethodDefProps(theDecl);
                    if(!IsMdVirtual(attr))
                    {
                        //_ASSERTE(!"MethodImpl Decl method not virtual");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_NONVIRTUAL_DECL;
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // Decl must not be final
                    if(IsMdFinal(attr))
                    {
                        //_ASSERTE(!"MethodImpl Decl method final");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_FINAL_DECL;                        
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // If Decl's parent is other than this class, Decl must not be private
                    hr = pMDInternalImport->GetParentToken(theDecl,&tkParent);
                    IfFailRet(hr);
                    if((m_cl != tkParent)&&IsMdPrivate(attr))
                    {
                        //_ASSERTE(!"MethodImpl Decl method private");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_PRIVATE_DECL;                        
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // Decl's parent must not be tdSealed
                    pMDInternalImport->GetTypeDefProps(tkParent,&attr,&tkGrandparent);
                    if(IsTdSealed(attr))
                    {
                        //_ASSERTE(!"MethodImpl Decl's parent class sealed");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_SEALED_DECL;                        
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // Get signature and length
                    pSigDecl = pMDInternalImport->GetSigOfMethodDef(theDecl,&cbSigDecl);
                }
                else 
                {
                    // Decl must be valid token
                    if ((rid == 0)||(rid > maxRidMR))
                    {
                        //_ASSERTE(!"MethodImpl Decl token out of range");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_ILLEGAL_TOKEN_DECL;
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // Get signature and length
                    pMDInternalImport->GetNameAndSigOfMemberRef(theDecl,&pSigDecl,&cbSigDecl);
                }
                // Body must be valid token
                rid = RidFromToken(theBody);
                if ((rid == 0)||(rid > maxRidMD))
                {
                    //_ASSERTE(!"MethodImpl Body token out of range");
                    bmtError->resIDWhy = IDS_CLASSLOAD_MI_ILLEGAL_TOKEN_BODY;
                    IfFailRet(COR_E_TYPELOAD);
                }
                // Body must not be static
                attr = pMDInternalImport->GetMethodDefProps(theBody);
                if(IsMdStatic(attr))
                {
                    //_ASSERTE(!"MethodImpl Body method static");
                    bmtError->resIDWhy = IDS_CLASSLOAD_MI_ILLEGAL_STATIC;
                    IfFailRet(COR_E_TYPELOAD);
                }

                // Body's parent must be this class
                hr = pMDInternalImport->GetParentToken(theBody,&tkParent);
                IfFailRet(hr);
                if(tkParent != m_cl)
                {
                    //_ASSERTE(!"MethodImpl Body's parent class different");
                    bmtError->resIDWhy = IDS_CLASSLOAD_MI_ILLEGAL_BODY;
                    IfFailRet(COR_E_TYPELOAD);
                }
                // Decl's and Body's signatures must match
                if(pSigDecl && cbSigDecl)
                {
                    if((pSigBody = pMDInternalImport->GetSigOfMethodDef(theBody,&cbSigBody)) != NULL && cbSigBody)
                    {
                        // Can't use memcmp because there may be two AssemblyRefs
                        // in this scope, pointing to the same assembly, etc.).
                        if (!MetaSig::CompareMethodSigs(pSigDecl,
                                                        cbSigDecl,
                                                        bmtInternal->pModule,
                                                        pSigBody,
                                                        cbSigBody,
                                                        bmtInternal->pModule))
                        {
                            //_ASSERTE(!"MethodImpl Decl's and Body's signatures mismatch");
                            bmtError->resIDWhy = IDS_CLASSLOAD_MI_BODY_DECL_MISMATCH;
                            IfFailRet(COR_E_TYPELOAD);
                        }
                    }
                    else
                    {
                        //_ASSERTE(!"MethodImpl Body's signature unavailable");
                        bmtError->resIDWhy = IDS_CLASSLOAD_MI_MISSING_SIG_BODY;
                        IfFailRet(COR_E_TYPELOAD);
                    }
                }
                else
                {
                    //_ASSERTE(!"MethodImpl Decl's signature unavailable");
                    bmtError->resIDWhy = IDS_CLASSLOAD_MI_MISSING_SIG_DECL;
                    IfFailRet(COR_E_TYPELOAD);
                }

                pBody++;
                pDecl++;
            }
        }
    }
    return hr;
}


//
// Used by BuildMethodTable
//
// Retrieve or add the TokenRange node for a particular token and nodelist.
/*static*/ EEClass::bmtTokenRangeNode *EEClass::GetTokenRange(mdToken tok, bmtTokenRangeNode **ppHead)
{
    BYTE tokrange = ::GetTokenRange(tok);
    bmtTokenRangeNode *pWalk = *ppHead;
    while (pWalk)
    {
        if (pWalk->tokenHiByte == tokrange)
        {
            return pWalk;
        }
        pWalk = pWalk->pNext;
    }

    // If we got here, this is the first time we've seen this token range.
    bmtTokenRangeNode *pNewNode = (bmtTokenRangeNode*)(GetThread()->m_MarshalAlloc.Alloc(sizeof(bmtTokenRangeNode)));
    pNewNode->tokenHiByte = tokrange;
    pNewNode->cMethods = 0;
    pNewNode->dwCurrentChunk = 0;
    pNewNode->dwCurrentIndex = 0;
    pNewNode->pNext = *ppHead;
    *ppHead = pNewNode;
    return pNewNode;
}

typedef struct _SigArguments
{
    Module* pScopeModule;
    Module* pExternalModule;
} CompareSigArguments;

static BOOL SigCompare(PCCOR_SIGNATURE pvScopeSignature, DWORD cbScopeSignature, 
                       PCCOR_SIGNATURE pvExternalSignature, DWORD cbExternalSignature,
                       void* pSigArgs)
{
    CompareSigArguments *pArgs = (CompareSigArguments*) pSigArgs;
    return MetaSig::CompareMethodSigs(pvScopeSignature, cbScopeSignature, pArgs->pScopeModule,
                                      pvExternalSignature, cbExternalSignature, pArgs->pExternalModule);
                                      
}


//
//
// Find a method declaration that must reside in the scope passed in. This method cannot be called if
// the reference travels to another scope. 
//
// Protect against finding a declaration that lives within
// us (the type being created)
//  
HRESULT EEClass::FindMethodDeclaration(bmtInternalInfo* bmtInternal, 
                                       mdToken  pToken,       // Token that is being located (MemberRef or MemberDef)
                                       mdToken* pDeclaration, // Method definition for Member
                                       BOOL fSameClass,       // Does the declaration need to be in this class
                                       Module** pModule,       // Module that the Method Definitions is part of
                                       bmtErrorInfo* bmtError)
{
    HRESULT hr = S_OK;

    IMDInternalImport *pMDInternalImport = bmtInternal->pInternalImport;
    MethodDesc* pMethod = NULL;

//      // We are currently assumming that most MethodImpls will be used
//      // to define implementation for methods defined on an interface
//      // or base type. Therefore, we try to load entry first. If that
//      // indicates the member is on our type then we check meta data.
//      hr = GetDescFromMemberRef(bmtInternal->pModule, 
//  pToken,
//                                        GetCl(),
//                                        (void**) (&pMethod),
//                                        bmtError->pThrowable);
//      if(FAILED(hr) && !pThrowableAvailable(bmtError->pThrowable)) { // it was us we were find
    
    *pModule = bmtInternal->pModule;
    PCCOR_SIGNATURE pSig;  // Signature of Member
    DWORD           cSig;
    LPCUTF8         szMember = NULL;
    // The token should be a member ref or def. If it is a ref then we need to travel
    // back to us hopefully. 
    if(TypeFromToken(pToken) == mdtMemberRef) {
        // Get the parent
        mdToken typeref = pMDInternalImport->GetParentOfMemberRef(pToken);
        // If parent is a method def then this is a varags method
        if (TypeFromToken(typeref) == mdtMethodDef) {
            mdTypeDef typeDef;
            hr = pMDInternalImport->GetParentToken(typeref, &typeDef);
            
            // Make sure it is a typedef
            if (TypeFromToken(typeDef) != mdtTypeDef) {
                _ASSERTE(!"MethodDef without TypeDef as Parent");
                IfFailRet(COR_E_TYPELOAD);
            }
            _ASSERTE(typeDef == GetCl());
            // This is the real method we are overriding
            // @TODO: CTS this may be illegal and we could throw an error
            *pDeclaration = mdtMethodDef; 
        }
        else if (TypeFromToken(typeref) == mdtTypeSpec) {
            _ASSERTE(!"Method impls cannot override a member parented to a TypeSpec");
            IfFailRet(COR_E_TYPELOAD);
        }
        else {
            // Verify that the ref points back to us
            mdToken tkDef;

            // We only get here when we know the token does not reference a type
            // in a different scope. 
            if(TypeFromToken(typeref) == mdtTypeRef) {
                
                
                LPCUTF8 pszNameSpace;
                LPCUTF8 pszClassName;
                
                pMDInternalImport->GetNameOfTypeRef(typeref, &pszNameSpace, &pszClassName);
                mdToken tkRes = pMDInternalImport->GetResolutionScopeOfTypeRef(typeref);
                hr = pMDInternalImport->FindTypeDef(pszNameSpace,
                                                    pszClassName,
                                                    (TypeFromToken(tkRes) == mdtTypeRef) ? tkRes : mdTokenNil,
                                                    &tkDef);
                if(fSameClass && tkDef != GetCl()) 
                {
                    IfFailRet(COR_E_TYPELOAD);
                }
            }
            else 
                tkDef = GetCl();

            szMember = pMDInternalImport->GetNameAndSigOfMemberRef(pToken,
                                                                   &pSig,
                                                                   &cSig);
            if(isCallConv(MetaSig::GetCallingConventionInfo(*pModule, pSig), 
                          IMAGE_CEE_CS_CALLCONV_FIELD)) {
                return VLDTR_E_MR_BADCALLINGCONV;
            }
            
            hr = pMDInternalImport->FindMethodDef(tkDef,
                                                  szMember, 
                                                  pSig, 
                                                  cSig, 
                                                  pDeclaration); 
            IfFailRet(hr);
        }
    }
    else if(TypeFromToken(pToken) == mdtMethodDef) {
        mdTypeDef typeDef;
        
        // Verify that we are the parent
        hr = pMDInternalImport->GetParentToken(pToken, &typeDef); 
        IfFailRet(hr);
        
        if(typeDef != GetCl()) 
        {
            IfFailRet(COR_E_TYPELOAD);
        }
        
        *pDeclaration = pToken;
    }
    else {
        IfFailRet(COR_E_TYPELOAD);
    }
    return hr;
}

    //
// Used by BuildMethodTable
//
// Enumerate this class's members
//  
HRESULT EEClass::EnumerateClassMembers(bmtInternalInfo* bmtInternal, 
                                       bmtEnumMethAndFields* bmtEnumMF, 
                                       bmtMethAndFieldDescs* bmtMF, 
                                       bmtProperties* bmtProp, 
                                       bmtMetaDataInfo* bmtMetaData, 
                                       bmtVtable* bmtVT, 
                                       bmtErrorInfo* bmtError)
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD   dwNumECallMethodDescs = 0;
    Thread *pThread = GetThread();
    IMDInternalImport *pMDInternalImport = bmtInternal->pInternalImport;
    mdToken tok;
    DWORD dwMemberAttrs;
    BOOL fIsClassEnum = IsEnum();
    BOOL fIsClassInterface = IsInterface();
    BOOL fIsClassValueType = IsValueClass();
    BOOL fIsClassComImport = IsComImport();
    BOOL fIsClassNotAbstract = (IsTdAbstract(m_dwAttrClass) == 0);
    PCCOR_SIGNATURE pMemberSignature;
    ULONG           cMemberSignature;

    //
    // Run through the method list and calculate the following:
    // # methods.
    // # "other" methods (i.e. static or private)
    // # non-other methods
    //

    bmtVT->dwMaxVtableSize     = 0; // we'll fix this later to be the real upper bound on vtable size
    bmtMetaData->cMethods = 0;

    hr = pMDInternalImport->EnumInit(mdtMethodDef, m_cl, &(bmtEnumMF->hEnumMethod));
    if (FAILED(hr))
    {
        _ASSERTE(!"Cannot count memberdefs");
        IfFailRet(hr);
    }
    bmtEnumMF->fNeedToCloseEnumMethod = true;

    // Allocate an array to contain the method tokens as well as information about the methods.
    bmtMetaData->cMethAndGaps = pMDInternalImport->EnumGetCount(&(bmtEnumMF->hEnumMethod));
    bmtMetaData->pMethods = (mdToken*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(mdToken));
    bmtMetaData->pMethodAttrs = (DWORD*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(DWORD));
    bmtMetaData->pMethodRVA = (ULONG*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(ULONG));
    bmtMetaData->pMethodImplFlags = (DWORD*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(DWORD));
    bmtMetaData->pMethodClassifications = (DWORD*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(DWORD));
    bmtMetaData->pstrMethodName = (LPSTR*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(LPSTR));
    bmtMetaData->pMethodImpl = (BYTE*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(BYTE));
    bmtMetaData->pMethodType = (BYTE*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cMethAndGaps * sizeof(BYTE));
    enum { SeenInvoke = 1, SeenBeginInvoke = 2, SeenEndInvoke = 4, SeenCtor = 8 };
    unsigned delegateMethods = 0;

    for (i = 0; i < bmtMetaData->cMethAndGaps; i++)
    {
        ULONG dwMethodRVA;
        DWORD dwImplFlags;
        DWORD Classification;
        LPSTR strMethodName;
        
        //
        // Go to the next method and retrieve its attributes.
        //

        pMDInternalImport->EnumNext(&(bmtEnumMF->hEnumMethod), &tok);
        DWORD   rid = RidFromToken(tok);
        if ((rid == 0)||(rid > pMDInternalImport->GetCountWithTokenKind(mdtMethodDef)))
        {
            _ASSERTE(!"Method token out of range");
            IfFailRet(COR_E_TYPELOAD);
        }

        dwMemberAttrs = pMDInternalImport->GetMethodDefProps(tok);
        if (IsMdRTSpecialName(dwMemberAttrs) || IsMdVirtual(dwMemberAttrs) || IsAnyDelegateClass())
        {
            strMethodName = (LPSTR)pMDInternalImport->GetNameOfMethodDef(tok);
            if(IsStrLongerThan(strMethodName,MAX_CLASS_NAME))
            {
                _ASSERTE(!"Method Name Too Long");
                IfFailRet(COR_E_TYPELOAD);
            }
        }
        else
            strMethodName = NULL;

        //
        // We need to check if there are any gaps in the vtable. These are
        // represented by methods with the mdSpecial flag and a name of the form
        // _VTblGap_nnn (to represent nnn empty slots) or _VTblGap (to represent a
        // single empty slot).
        //

        if (IsMdRTSpecialName(dwMemberAttrs))
        {
            // The slot is special, but it might not be a vtable spacer. To
            // determine that we must look at the name.
            if (strncmp(strMethodName, "_VtblGap", 8) == 0)
            {
                                //
                // This slot doesn't really exist, don't add it to the method
                // table. Instead it represents one or more empty slots, encoded
                // in the method name. Locate the beginning of the count in the
                // name. There are these points to consider:
                //   There may be no count present at all (in which case the
                //   count is taken as one).
                //   There may be an additional count just after Gap but before
                //   the '_'. We ignore this.
                                //

                LPCSTR pos = strMethodName + 8;

                // Skip optional number.
                while ((*pos >= '0') && (*pos <= '9'))
                    pos++;

                WORD n = 0;

                // Check for presence of count.
                if (*pos == '\0')
                    n = 1;
                else
                {
                    // Skip '_'.
                    _ASSERTE(*pos == '_');
                    if (*pos != '_')
                    {
                        bmtMetaData->cMethods++;
                        continue;
                    }
                    pos++;

                    // Read count.
                    while ((*pos >= '0') && (*pos <= '9'))
                    {
                        _ASSERTE(n < 6552);
                        n *= 10;
                        n += *pos - '0';
                        pos++;
                    }

                    // Check for end of name.
                    _ASSERTE(*pos == '\0');
                    if (*pos != '\0')
                    {
                        bmtMetaData->cMethods++;
                        continue;
                    }
                }

                // Record vtable gap in mapping list.
                if (m_pSparseVTableMap == NULL)
                    m_pSparseVTableMap = new SparseVTableMap();

                if (!m_pSparseVTableMap->RecordGap((WORD)bmtMetaData->cMethods, n))
                {
                    IfFailRet(E_OUTOFMEMORY);
                }

                bmtProp->fSparse = true;
                continue;
            }

        }


        //
        // This is a real method so add it to the enumeration of methods. We now need to retrieve 
        // information on the method and store it for later use.
        //
        int CurMethod = bmtMetaData->cMethods++;
        pMDInternalImport->GetMethodImplProps(tok, &dwMethodRVA, &dwImplFlags);
        //
        // But first - minimal flags validity checks
        //
        // No methods in Enums!
        if(fIsClassEnum)
        {
            BAD_FORMAT_ASSERT(!"Method in an Enum");
            IfFailRet(COR_E_TYPELOAD);
        }
        // RVA : 0 
        if(dwMethodRVA != 0)
        {
            if(fIsClassComImport)
            {
                BAD_FORMAT_ASSERT(!"Method with RVA!=0 in an Import");
                IfFailRet(COR_E_TYPELOAD);
            }
            if(IsMdAbstract(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Abstract Method with RVA!=0");
                IfFailRet(COR_E_TYPELOAD);
            }
            if(IsMiRuntime(dwImplFlags))
            {
                BAD_FORMAT_ASSERT(!"Runtime-Implemented Method with RVA!=0");
                IfFailRet(COR_E_TYPELOAD);
            }
            if(IsMiInternalCall(dwImplFlags))
            {
                BAD_FORMAT_ASSERT(!"Internal Call Method with RVA!=0");
                IfFailRet(COR_E_TYPELOAD);
            }
        }

        // Abstract / not abstract
        if(IsMdAbstract(dwMemberAttrs))
        {
            if(fIsClassNotAbstract)
            {
                BAD_FORMAT_ASSERT(!"Abstract Method in Non-Abstract Class");
                IfFailRet(COR_E_TYPELOAD);
            }
            if(!IsMdVirtual(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Non-Vitrual Abstract Method");
                IfFailRet(COR_E_TYPELOAD);
            }
        }
        else if(fIsClassInterface && strMethodName &&
                (strcmp(strMethodName, COR_CCTOR_METHOD_NAME)))
        {
            BAD_FORMAT_ASSERT(!"Non-abstract, non-cctor Method in an Interface");
            IfFailRet(COR_E_TYPELOAD);
        }

        // Virtual / not virtual
        if(IsMdVirtual(dwMemberAttrs))
        {
            if(IsMdPinvokeImpl(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Virtual PInvoke Implemented Method");
                IfFailRet(COR_E_TYPELOAD);
            }
            if(IsMdStatic(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Virtual Static Method");
                IfFailRet(COR_E_TYPELOAD);
            }
            if(strMethodName && (0==strcmp(strMethodName, COR_CTOR_METHOD_NAME)))
            {
                BAD_FORMAT_ASSERT(!"Virtual Instance Constructor");
                IfFailRet(COR_E_TYPELOAD);
            }
        }

        // No synchronized methods in ValueTypes
        if(fIsClassValueType && IsMiSynchronized(dwImplFlags))
        {
            BAD_FORMAT_ASSERT(!"Synchronized Method in Value Type");
            IfFailRet(COR_E_TYPELOAD);
        }

        // Global methods:
        if(m_cl == COR_GLOBAL_PARENT_TOKEN)
        {
            if(!IsMdStatic(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Non-Static Global Method");
                IfFailRet(COR_E_TYPELOAD);
            }
            if (strMethodName)  //@todo: investigate mc++ generating null name
            {
                if(0==strcmp(strMethodName, COR_CTOR_METHOD_NAME))
                {
                    BAD_FORMAT_ASSERT(!"Global Instance Constructor");
                    IfFailRet(COR_E_TYPELOAD);
                }
            }
        }
        // Signature validation
        pMemberSignature = pMDInternalImport->GetSigOfMethodDef(tok,&cMemberSignature);
        hr = validateTokenSig(tok,pMemberSignature,cMemberSignature,dwMemberAttrs,pMDInternalImport);
        if (FAILED(hr)) 
        {
            //_ASSERTE(!"Invalid Signature");
            bmtError->resIDWhy = hr;
            bmtError->dMethodDefInError = tok;
            IfFailRet(hr);
        }

        //
        // Determine the method's classification.
        //

        if (IsReallyMdPinvokeImpl(dwMemberAttrs) || IsMiInternalCall(dwImplFlags))
        {
            hr = NDirect::HasNAT_LAttribute(pMDInternalImport, tok);
            if (FAILED(hr)) 
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_BADPINVOKE;
                bmtError->dMethodDefInError = bmtMetaData->pMethods[i];
                IfFailRet(hr);
            }
                    
            if (hr == S_FALSE)
            {                               
                if (fIsClassComImport || bmtProp->fComEventItfType)
                {
                    // tlbimported component
                    if (IsMdRTSpecialName(dwMemberAttrs)) 
                    {
                        // constructor is special
                        Classification = mcECall;
                    }
                    else
                    {
                        // Tlbimported components we have some 
                        // method descs in the call which are just used
                        // for handling methodimpls of all interface methods
                        Classification = mcComInterop;
                    }
                }
                else if (dwMethodRVA == 0)
                    Classification = mcECall;
                else                 
                    Classification = mcNDirect;
            }
            else
                Classification = mcNDirect;
        }
        else if (IsMiRuntime(dwImplFlags)) 
        {
                // currently the only runtime implemented functions are delegate instance methods 
            if (!IsAnyDelegateClass() || IsMdStatic(dwMemberAttrs) || IsMdAbstract(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Bad used of Runtime Impl attribute");
                IfFailRet(COR_E_TYPELOAD);
            }
            if (IsMdRTSpecialName(dwMemberAttrs))   // .ctor 
            {
                if (strcmp(strMethodName, COR_CTOR_METHOD_NAME) != 0 || IsMdVirtual(dwMemberAttrs) || (delegateMethods & SeenCtor))
                {
                    BAD_FORMAT_ASSERT(!"Bad flags on delegate constructor");
                    IfFailRet(COR_E_TYPELOAD);
                }
                delegateMethods |= SeenCtor;
                Classification = mcECall;
            }
            else 
            {
                if (strcmp(strMethodName, "Invoke") == 0 && !(delegateMethods & SeenInvoke))
                    delegateMethods |= SeenInvoke;
                else if (strcmp(strMethodName, "BeginInvoke") == 0 && !(delegateMethods & SeenBeginInvoke))
                    delegateMethods |= SeenBeginInvoke;
                else if (strcmp(strMethodName, "EndInvoke") == 0 && !(delegateMethods & SeenEndInvoke))
                    delegateMethods |= SeenEndInvoke;
                else 
                {
                    BAD_FORMAT_ASSERT(!"unknown delegate method");
                    IfFailRet(COR_E_TYPELOAD);
                }
                Classification = mcEEImpl;
            }
        }
        else
        {
            if (fIsClassInterface && !IsMdStatic(dwMemberAttrs))
            {
                // If the interface is a standard managed interface then allocate space for an ECall method desc.
                // Otherwise allocate space for an interface call method desc.
                if (bmtProp->fIsMngStandardItf)
                    Classification = mcECall;
                else
                    Classification = mcComInterop;
            }
            else
            {
                Classification = mcIL;
            }
        }

#ifdef _DEBUG
        // We don't allow stack based declarative security on ecalls, fcalls and
        // other special purpose methods implemented by the EE (the interceptor
        // we use doesn't play well with non-jitted stubs).
        if ((Classification == mcECall || Classification == mcEEImpl) &&
            (IsMdHasSecurity(dwMemberAttrs) || IsTdHasSecurity(m_dwAttrClass)))
        {
            DWORD dwSecFlags;
            DWORD dwNullDeclFlags;

            LPSTR szMethodName = (LPSTR)pMDInternalImport->GetNameOfMethodDef(tok);

            if (IsTdHasSecurity(m_dwAttrClass) &&
                SUCCEEDED(Security::GetDeclarationFlags(pMDInternalImport, GetCl(), &dwSecFlags, &dwNullDeclFlags)))
            {
                if (dwSecFlags & ~dwNullDeclFlags & DECLSEC_RUNTIME_ACTIONS)
                    _ASSERTE(!"Cannot add stack based declarative security to a class containing an ecall/fcall/special method.");
            }
            if (IsMdHasSecurity(dwMemberAttrs) &&
                SUCCEEDED(Security::GetDeclarationFlags(pMDInternalImport, tok, &dwSecFlags, &dwNullDeclFlags)))
            {
                if (dwSecFlags & ~dwNullDeclFlags & DECLSEC_RUNTIME_ACTIONS)
                    _ASSERTE(!"Cannot add stack based declarative security to an ecall/fcall/special method.");
            }
        }
#endif

        // count how many overrides this method does All methods bodies are defined
        // on this type so we can just compare the tok with the body token found
        // from the overrides.
        for(DWORD impls = 0; impls < bmtEnumMF->dwNumberMethodImpls; impls++) {
            if(bmtMetaData->pMethodBody[impls] == tok) {
                Classification |= mdcMethodImpl;
                break;
            }
        }

        //
        // Compute the type & other info
        //

        // Set the index into the storage locations
        BYTE impl;
        if (Classification & mdcMethodImpl) 
            impl = METHOD_IMPL;
        else 
            impl = METHOD_IMPL_NOT;

        BYTE type;
        if ((Classification & mdcClassification)  == mcNDirect)
        {
            type = METHOD_TYPE_NDIRECT;
        }
        else if ((Classification & mdcClassification) == mcECall
                 || (Classification & mdcClassification) == mcEEImpl)
        {
            type = METHOD_TYPE_ECALL;
        }
        else if ((Classification & mdcClassification) == mcComInterop)
        {
            type = METHOD_TYPE_INTEROP;
        }
        else
        {
            type = METHOD_TYPE_NORMAL;
        }

        //
        // Store the method and the information we have gathered on it in the metadata info structure.
        //

        bmtMetaData->pMethods[CurMethod] = tok;
        bmtMetaData->pMethodAttrs[CurMethod] = dwMemberAttrs;
        bmtMetaData->pMethodRVA[CurMethod] = dwMethodRVA;
        bmtMetaData->pMethodImplFlags[CurMethod] = dwImplFlags;
        bmtMetaData->pMethodClassifications[CurMethod] = Classification;
        bmtMetaData->pstrMethodName[CurMethod] = strMethodName;
        bmtMetaData->pMethodImpl[CurMethod] = impl;
        bmtMetaData->pMethodType[CurMethod] = type;

        //
        // Update the count of the various types of methods.
        //
        
        bmtVT->dwMaxVtableSize++;
        bmtEnumMF->dwNumDeclaredMethods++;

        BOOL hasUnboxing = (IsValueClass()
                            && !IsMdStatic(dwMemberAttrs) 
                            && IsMdVirtual(dwMemberAttrs) 
                            && !IsMdRTSpecialName(dwMemberAttrs));
        
        if (hasUnboxing)
            bmtEnumMF->dwNumUnboxingMethods++;
        
        bmtMF->sets[type][impl].dwNumMethodDescs++;
        if (hasUnboxing)
            bmtMF->sets[type][impl].dwNumUnboxingMethodDescs++;
            
        GetTokenRange(tok, &(bmtMetaData->ranges[type][impl]))->cMethods 
          += (hasUnboxing ? 2 : 1);
    }
    _ASSERTE(i == bmtMetaData->cMethAndGaps);
    pMDInternalImport->EnumReset(&(bmtEnumMF->hEnumMethod));

    //
    // If the interface is sparse, we need to finalize the mapping list by
    // telling it how many real methods we found.
    //
    
    if (bmtProp->fSparse)
    {
        if (!m_pSparseVTableMap->FinalizeMapping((WORD)bmtMetaData->cMethods))
        {
            return(E_OUTOFMEMORY);
        }
    }
    
    //
    // Run through the field list and calculate the following:
    // # static fields
    // # static fields that contain object refs.
    // # instance fields
    //

    bmtEnumMF->dwNumStaticFields        = 0;
    bmtEnumMF->dwNumStaticObjRefFields  = 0;
    bmtEnumMF->dwNumInstanceFields      = 0;

    hr = pMDInternalImport->EnumInit(mdtFieldDef, m_cl, &(bmtEnumMF->hEnumField));
    if (FAILED(hr))
    {
        _ASSERTE(!"Cannot count memberdefs");
        IfFailRet(hr);
    }
    bmtMetaData->cFields = pMDInternalImport->EnumGetCount(&(bmtEnumMF->hEnumField));
    bmtEnumMF->fNeedToCloseEnumField = true;

    // Retrieve the fields and store them in a temp array.
    bmtMetaData->pFields = (mdToken*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cFields * sizeof(mdToken));
    bmtMetaData->pFieldAttrs = (DWORD*)pThread->m_MarshalAlloc.Alloc(bmtMetaData->cFields * sizeof(DWORD));

    DWORD   dwFieldLiteralInitOnly = fdLiteral | fdInitOnly;

    for (i = 0; pMDInternalImport->EnumNext(&(bmtEnumMF->hEnumField), &tok); i++)
    {
        //
        // Retrieve the attributes of the field.
        //
        DWORD   rid = tok & 0x00FFFFFF;
        if ((rid == 0)||(rid > pMDInternalImport->GetCountWithTokenKind(mdtFieldDef)))
        {
            BAD_FORMAT_ASSERT(!"Field token out of range");
            IfFailRet(COR_E_TYPELOAD);
        }
        
        dwMemberAttrs = pMDInternalImport->GetFieldDefProps(tok);

        
        //
        // Store the field and its attributes in the bmtMetaData structure for later use.
        //
        
        bmtMetaData->pFields[i] = tok;
        bmtMetaData->pFieldAttrs[i] = dwMemberAttrs;
        
        if((dwMemberAttrs & fdFieldAccessMask)==fdFieldAccessMask)
        {
            BAD_FORMAT_ASSERT(!"Invalid Field Acess Flags");
            IfFailRet(COR_E_TYPELOAD);
        }
        if((dwMemberAttrs & dwFieldLiteralInitOnly)==dwFieldLiteralInitOnly)
        {
            BAD_FORMAT_ASSERT(!"Field is Literal and InitOnly");
            IfFailRet(COR_E_TYPELOAD);
        }

            // can only have static global fields
        if(m_cl == COR_GLOBAL_PARENT_TOKEN)
        {
            if(!IsMdStatic(dwMemberAttrs))
            {
                BAD_FORMAT_ASSERT(!"Non-Static Global Field");
                IfFailRet(COR_E_TYPELOAD);
            }
        }

        //
        // Update the count of the various types of fields.
        //

        if (IsFdStatic(dwMemberAttrs))
        {
            if (!IsFdLiteral(dwMemberAttrs))
            {
                bmtEnumMF->dwNumStaticFields++;
            }
        }
        else
        {
            bmtEnumMF->dwNumInstanceFields++;
            if(fIsClassInterface)
            {
                BAD_FORMAT_ASSERT(!"Instance Field in an Interface");
                IfFailRet(COR_E_TYPELOAD);
            }
        }
    }
    _ASSERTE(i == bmtMetaData->cFields);
    if(fIsClassEnum && (bmtEnumMF->dwNumInstanceFields==0))
    {
        // Commented out because Reflection Emit doesn't check for this.
        _ASSERTE(!"No Instance Field in an Enum");
        IfFailRet(COR_E_TYPELOAD);
    }

    bmtEnumMF->dwNumDeclaredFields = bmtEnumMF->dwNumStaticFields + bmtEnumMF->dwNumInstanceFields;

    return hr;
}

//
// Used by AllocateMethodFieldDescs
//
// Allocates the chunks used to contain the method descs.
//
HRESULT EEClass::AllocateMDChunks(bmtTokenRangeNode *pTokenRanges, DWORD type, DWORD impl, DWORD *pNumChunks, MethodDescChunk ***ppItfMDChunkList)
{
    HRESULT hr = S_OK;

    _ASSERTE(*ppItfMDChunkList == NULL);

    static DWORD classifications[METHOD_TYPE_COUNT][METHOD_IMPL_COUNT] = 
    { 
        { mcIL, mcIL | mdcMethodImpl },
        { mcComInterop, mcComInterop | mdcMethodImpl },
        { mcECall, mcECall | mdcMethodImpl },
        { mcNDirect, mcNDirect | mdcMethodImpl }
    };
    static CounterTypeEnum dataStructureTypes[METHOD_TYPE_COUNT] = 
    {
        METHOD_DESC,
        COMPLUS_METHOD_DESC,
        NDIRECT_METHOD_DESC, // @nice: add new value here
        NDIRECT_METHOD_DESC
    };

    DWORD Classification = classifications[type][impl];
        
    bmtTokenRangeNode *pTR = pTokenRanges;
    *pNumChunks = 0;
    while (pTR)
    {
        
        // Note: Since dwCurrentChunk isn't being used at this stage, we'll steal it to store
        // away the chunk count. 
        // After this function, we'll set it to its intended value.
        pTR->dwCurrentChunk = MethodDescChunk::GetChunkCount(pTR->cMethods, Classification);
        (*pNumChunks) += pTR->dwCurrentChunk;
        pTR = pTR->pNext;
    }
    
    *ppItfMDChunkList = (MethodDescChunk**)GetThread()->m_MarshalAlloc.Alloc((*pNumChunks) * sizeof(MethodDescChunk*));

    // @TODO: CTS. update profiling to handle the new types of method descs
    // Determine which data structure type will be created.
    CounterTypeEnum DataStructureType = dataStructureTypes[type];

    // Allocate the chunks for the method descs.
    pTR = pTokenRanges;
    DWORD chunkIdx = 0;
    while (pTR)
    {
        DWORD NumChunks = pTR->dwCurrentChunk;
        DWORD dwMDAllocs = pTR->cMethods;
        pTR->dwCurrentChunk = chunkIdx;
        for (DWORD i = 0; i < NumChunks; i++)
        {
            DWORD dwElems = min(dwMDAllocs, MethodDescChunk::GetMaxMethodDescs(Classification));
            MethodDescChunk *pChunk = MethodDescChunk::CreateChunk(GetClassLoader()->GetHighFrequencyHeap(), 
                                                                   dwElems, 
                                                                   Classification,
                                                                   pTR->tokenHiByte);
            if (pChunk == NULL)
            {
                IfFailRet(E_OUTOFMEMORY);
            }

            (*ppItfMDChunkList)[chunkIdx++] = pChunk;
            dwMDAllocs -= dwElems;

            WS_PERF_UPDATE_COUNTER(DataStructureType, HIGH_FREQ_HEAP, dwElems);
        }
        pTR = pTR->pNext;
    }

    return hr;
}

//
// Used by BuildMethodTable
//
// Allocate a MethodDesc* for each method (needed later when doing interfaces), and a FieldDesc* for each field
//
HRESULT EEClass::AllocateMethodFieldDescs(bmtProperties* bmtProp, 
                                          bmtMethAndFieldDescs* bmtMFDescs, 
                                          bmtMetaDataInfo* bmtMetaData, 
                                          bmtVtable* bmtVT, 
                                          bmtEnumMethAndFields* bmtEnumMF, 
                                          bmtInterfaceInfo* bmtInterface, 
                                          bmtFieldPlacement* bmtFP, 
                                          bmtParentInfo* bmtParent)
{
    HRESULT hr = S_OK;
    DWORD i;
    Thread *pThread = GetThread();

    // Allocate a MethodDesc* for each method (needed later when doing interfaces), and a FieldDesc* for each field
    bmtMFDescs->ppMethodAndFieldDescList = new void* [bmtMetaData->cMethods + bmtMetaData->cFields];

    if (bmtMFDescs->ppMethodAndFieldDescList == NULL)
    {
        IfFailRet(E_OUTOFMEMORY);
    }
    WS_PERF_UPDATE("EEClass:BuildMethodTable, POINTERS to methoddesc,fielddesc", 
                   sizeof(void *)*(bmtMetaData->cMethods+bmtMetaData->cFields), 
                   bmtMFDescs->ppMethodAndFieldDescList);

    bmtMFDescs->ppMethodDescList = (MethodDesc**) bmtMFDescs->ppMethodAndFieldDescList;
    bmtMFDescs->ppFieldDescList = (FieldDesc**) &(bmtMFDescs->ppMethodAndFieldDescList[bmtMetaData->cMethods]);

    // Init the list
    for (i = 0; i < (bmtMetaData->cMethods+bmtMetaData->cFields); i++)
        bmtMFDescs->ppMethodAndFieldDescList[i] = NULL;

    // Create a temporary function table (we don't know how large the vtable will be until the very end,
    // since duplicated interfaces are stored at the end of it).  Calculate an upper bound.
    //
    // Upper bound is: The parent's class vtable size, plus every method declared in
    //                 this class, plus the size of every interface we implement
    //
    // In the case of value classes, we add # InstanceMethods again, since we have boxed and unboxed versions
    // of every vtable method.
    //
    if (IsValueClass())
    {
        bmtVT->dwMaxVtableSize += bmtEnumMF->dwNumDeclaredMethods;
        WS_PERF_SET_HEAP(SYSTEM_HEAP);
        bmtMFDescs->ppUnboxMethodDescList = new MethodDesc* [bmtMetaData->cMethods];
        if (bmtMFDescs->ppUnboxMethodDescList == NULL)
        {
            IfFailRet(E_OUTOFMEMORY);
        }
        memset(bmtMFDescs->ppUnboxMethodDescList, 0, sizeof(MethodDesc*)*bmtMetaData->cMethods);

        WS_PERF_UPDATE("EEClass:BuildMethodTable, for valuclasses", sizeof(MethodDesc*)*bmtMetaData->cMethods, bmtMFDescs->ppMethodAndFieldDescList);
    }


    // sanity check

    _ASSERTE(!GetParentClass() || (bmtInterface->dwInterfaceMapSize - GetParentClass()->m_wNumInterfaces) >= 0);
    // add parent vtable size 
    bmtVT->dwMaxVtableSize += bmtVT->dwCurrentVtableSlot;

    for (i = 0; i < m_wNumInterfaces; i++)
    {
        // We double the interface size because we may end up duplicating the Interface for MethodImpls
        bmtVT->dwMaxVtableSize += (bmtInterface->pInterfaceMap[i].m_pMethodTable->GetClass()->GetNumVtableSlots() * 2);
    }

    WS_PERF_SET_HEAP(SYSTEM_HEAP);
    // Allocate the temporary vtable
    bmtVT->pVtable = new SLOT[bmtVT->dwMaxVtableSize];
    if (bmtVT->pVtable == NULL)
    {
        IfFailRet(E_OUTOFMEMORY);
    }
#ifdef _DEBUG
    memset(bmtVT->pVtable, 0, sizeof(SLOT)*bmtVT->dwMaxVtableSize);
#endif
    WS_PERF_UPDATE("EEClass:BuildMethodTable, tempVtable", sizeof(SLOT)*bmtVT->dwMaxVtableSize, bmtVT->pVtable);

    bmtVT->pNonVtable = (SLOT *) pThread->m_MarshalAlloc.Alloc(sizeof(SLOT)*bmtMetaData->cMethods);
    memset(bmtVT->pNonVtable, 0, sizeof(SLOT)*bmtMetaData->cMethods);

    if (GetParentClass() != NULL)
    {
        if (GetParentClass()->GetModule()->IsPreload())
        {
            //
            // Make sure all parent slots are fixed up before we copy the vtable,
            // since the fixup rules don't work if we copy down fixup addresses.
            //

            for (int i=0; i<GetParentClass()->GetNumVtableSlots(); i++)
                GetParentClass()->GetFixedUpSlot(i);
        }

        // Copy parent's vtable into our "temp" vtable
        memcpy(
            bmtVT->pVtable,
            GetParentClass()->GetVtable(),
            GetParentClass()->GetNumVtableSlots() * sizeof(SLOT)
        );

#if 0
        // @todo: Figure out the right way to override Equals for value
        // types only.
        //
        // This is broken because
        // (a) g_pObjectClass->FindMethod("Equals", &gsig_IM_Obj_RetBool); will return
        //      the EqualsValue method
        // (b) When mscorlib has been preloaded (and thus the munge already done
        //      ahead of time), we cannot easily find both methods 
        //      to compute EqualsAddr & EqualsSlot
        //
        // For now, the Equals method has a runtime check to see if it's
        // comparing value types.
        //

        // If it is a value type, over ride a few of the base class methods.
        if (IsValueClass())
        {
            static ULONG EqualsAddr = 0;
            static WORD EqualsSlot;

            // If we haven't been through here yet, get some stuff from the Object class definition.
            if (EqualsAddr == 0)
            {
                // Get the slot of the Equals method.
                MethodDesc *pEqualsMD = g_pObjectClass->FindMethod("Equals", &gsig_IM_Obj_RetBool);
                _ASSERTE(pEqualsMD != NULL);
                EqualsSlot = pEqualsMD->GetSlot();

                // Get the address of the EqualsValue method.
                MethodDesc *pEqualsValueMD = g_pObjectClass->FindMethod("EqualsValue", &gsig_IM_Obj_RetBool);
                _ASSERTE(pEqualsValueMD != NULL);
                EqualsAddr = (ULONG) pEqualsValueMD->GetPreStubAddr();
                _ASSERTE(EqualsAddr != 0);

                // Patch the EqualsValue method desc in a dangerous way to
                // look like the Equals method desc.
                pEqualsValueMD->SetSlot(EqualsSlot);
                pEqualsValueMD->SetMemberDef(pEqualsMD->GetMemberDef());
            }

            // Override the valuetype "Equals" with "EqualsValue".
            bmtVT->pVtable[EqualsSlot] = EqualsAddr;
        }
#endif
    }


    // We'll be counting the # fields of each size as we go along
    for (i = 0; i <= MAX_LOG2_PRIMITIVE_FIELD_SIZE; i++)
    {
        bmtFP->NumStaticFieldsOfSize[i]    = 0;
        bmtFP->NumInstanceFieldsOfSize[i]  = 0;
    }

    // Allocate blocks of MethodDescs and FieldDescs for all declared methods and fields
    if ((bmtEnumMF->dwNumDeclaredMethods + bmtEnumMF->dwNumDeclaredFields) > 0)
    {
        // In order to avoid allocating a field pointing back to the method
        // table in every single method desc, we allocate memory in the
        // following manner:
        //   o  Field descs get a single contiguous block.
        //   o  Method descs of different sizes (normal vs NDirect) are
        //      allocated in different MethodDescChunks.
        //   o  Each method desc chunk starts with a header, and has 
        //      at most MAX_ method descs (if there are more
        //      method descs of a given size, multiple chunks are allocated).
        // This way method descs can use an 8-bit offset field to locate the
        // pointer to their method table.

        WS_PERF_SET_HEAP(HIGH_FREQ_HEAP); 
        
        // Allocate fields first.
        if (bmtEnumMF->dwNumDeclaredFields > 0)
        {
            m_pFieldDescList = (FieldDesc *)
                GetClassLoader()->GetHighFrequencyHeap()->AllocMem(bmtEnumMF->dwNumDeclaredFields * 
                                                                   sizeof(FieldDesc));
            if (m_pFieldDescList == NULL)
            {
                IfFailRet(E_OUTOFMEMORY);
            }
            WS_PERF_UPDATE_DETAIL("BuildMethodTable:bmtEnumMF->dwNumDeclaredFields*sizeof(FieldDesc)",
                                  bmtEnumMF->dwNumDeclaredFields * sizeof(FieldDesc), m_pFieldDescList);
            WS_PERF_UPDATE_COUNTER(FIELD_DESC, HIGH_FREQ_HEAP, bmtEnumMF->dwNumDeclaredFields);
        }

#ifdef _DEBUG
        GetClassLoader()->m_dwDebugFieldDescs += bmtEnumMF->dwNumDeclaredFields;
        GetClassLoader()->m_dwFieldDescData += (bmtEnumMF->dwNumDeclaredFields * sizeof(FieldDesc));
#endif

        for (DWORD impl=0; impl<METHOD_IMPL_COUNT; impl++)
            for (DWORD type=0; type<METHOD_TYPE_COUNT; type++)
            {
                bmtMethodDescSet *set = &bmtMFDescs->sets[type][impl];

                DWORD dwAllocs = set->dwNumMethodDescs + set->dwNumUnboxingMethodDescs;
                if (dwAllocs > 0)
                {
                    IfFailRet(AllocateMDChunks(bmtMetaData->ranges[type][impl], 
                                               type, impl, 
                                               &set->dwChunks, &set->pChunkList));
                }
#ifdef _DEBUG
                GetClassLoader()->m_dwDebugMethods += dwAllocs;
                for (UINT i=0; i<set->dwChunks; i++)
                    GetClassLoader()->m_dwMethodDescData += 
                      set->pChunkList[i]->Sizeof();
#endif
            }


        bmtParent->ppParentMethodDescBuf = (MethodDesc **)
            pThread->m_MarshalAlloc.Alloc(2 * bmtEnumMF->dwNumDeclaredMethods *
                                          sizeof(MethodDesc*));

        if (bmtParent->ppParentMethodDescBuf == NULL)
        {
            IfFailRet(E_OUTOFMEMORY);
        }

        bmtParent->ppParentMethodDescBufPtr = bmtParent->ppParentMethodDescBuf;
    }
    else
    {
        // No fields or methods
        m_pFieldDescList = NULL;
    }

    return hr;
}

//
// Heuristic to determine if we should have instances of this class 8 byte aligned
//
BOOL EEClass::ShouldAlign8(DWORD dwR8Fields, DWORD dwTotalFields)
{
    return dwR8Fields*2>dwTotalFields && dwR8Fields>=2;
}

//
// Used by BuildMethodTable
//
// Go thru all fields and initialize their FieldDescs.
//
HRESULT EEClass::InitializeFieldDescs(FieldDesc *pFieldDescList, 
                                      const LayoutRawFieldInfo* pLayoutRawFieldInfos, 
                                      bmtInternalInfo* bmtInternal, 
                                      bmtMetaDataInfo* bmtMetaData, 
                                      bmtEnumMethAndFields* bmtEnumMF, 
                                      bmtErrorInfo* bmtError, 
                                      EEClass*** pByValueClassCache, 
                                      bmtMethAndFieldDescs* bmtMFDescs, 
                                      bmtFieldPlacement* bmtFP,
                                      unsigned* totalDeclaredSize)
{
    HRESULT hr = S_OK;
    DWORD i;
    IMDInternalImport *pInternalImport = bmtInternal->pInternalImport; // to avoid multiple dereferencings

    FieldMarshaler *pNextFieldMarshaler = NULL;
    if (HasLayout())
    {
        pNextFieldMarshaler = (FieldMarshaler*)(GetLayoutInfo()->GetFieldMarshalers());
    }

     
//========================================================================
// BEGIN:
//    Go thru all fields and initialize their FieldDescs.
//========================================================================

    DWORD   dwCurrentDeclaredField = 0;
    DWORD   dwCurrentStaticField   = 0;
    DWORD   dwSharedThreadStatic = 0;
    DWORD   dwUnsharedThreadStatic = 0;
    DWORD   dwSharedContextStatic = 0;
    DWORD   dwUnsharedContextStatic = 0;
    BOOL    fSetThreadStaticOffset = FALSE;     // Do we have thread local static fields ?
    BOOL    fSetContextStaticOffset = FALSE;    // Do we have context local static fields ?
    DWORD   dwR8Fields              = 0;        // Number of R8's the class has
    
#ifdef RVA_FIELD_VALIDATION_ENABLED
    Module* pMod = bmtInternal->pModule;
#endif
    for (i = 0; i < bmtMetaData->cFields; i++)
    {
        PCCOR_SIGNATURE pMemberSignature;
        DWORD       cMemberSignature;
        DWORD       dwMemberAttrs;

        dwMemberAttrs = bmtMetaData->pFieldAttrs[i];
        
        // We don't store static final primitive fields in the class layout
        
        if (IsFdLiteral(dwMemberAttrs))
            continue;
        
        if(!IsFdPublic(dwMemberAttrs)) m_VMFlags |= VMFLAG_HASNONPUBLICFIELDS;

        pMemberSignature = pInternalImport->GetSigOfFieldDef(bmtMetaData->pFields[i], &cMemberSignature);
        // Signature validation
        IfFailRet(validateTokenSig(bmtMetaData->pFields[i],pMemberSignature,cMemberSignature,dwMemberAttrs,pInternalImport));
        
        FieldDesc * pFD;
        DWORD       dwLog2FieldSize = 0;
        BOOL        bCurrentFieldIsGCPointer = FALSE;
        PCCOR_SIGNATURE pFieldSig = pMemberSignature;
        CorElementType ElementType, FieldDescElementType;
        mdToken     dwByValueClassToken = 0;
        EEClass *   pByValueClass = NULL;
        BOOL        fIsByValue = FALSE;
        BOOL        fIsRVA = FALSE;
        BOOL        fIsThreadStatic = FALSE;
        BOOL        fIsContextStatic = FALSE;
        BOOL        fHasRVA = FALSE;
        
        // Get type
        if (!isCallConv(*pFieldSig++, IMAGE_CEE_CS_CALLCONV_FIELD))
        {
            IfFailRet(COR_E_TYPELOAD);
        }

        // Determine if a static field is special i.e. RVA based, local to
        // a thread or a context        
        if(IsFdStatic(dwMemberAttrs))
        {
            if(IsFdHasFieldRVA(dwMemberAttrs))
            {
                fHasRVA = TRUE;
            }
            if(S_OK == pInternalImport->GetCustomAttributeByName(bmtMetaData->pFields[i],
                                                                                "System.ThreadStaticAttribute",
                                                                                NULL,
                                                                                NULL))
            {
                fIsThreadStatic = TRUE;
                fSetThreadStaticOffset = TRUE;
            }
            if(S_OK == pInternalImport->GetCustomAttributeByName(bmtMetaData->pFields[i],
                                                                                "System.ContextStaticAttribute",
                                                                                NULL,
                                                                                NULL))
            {
                fIsContextStatic = TRUE;
                fSetContextStaticOffset = TRUE;
            }

            // Do some sanity checks that we are not mixing context and thread
            // relative statics.
            if (fIsThreadStatic && fIsContextStatic)
            {
                //@TODO TarunA Define a hresult for this failure.
                IfFailRet(COR_E_TYPELOAD);
            }
        }
        
    SET_ELEMENT_TYPE:
        ElementType = (CorElementType) *pFieldSig++;
        
    GOT_ELEMENT_TYPE:
        // Type to store in FieldDesc - we don't want to have extra case statements for
        // ELEMENT_TYPE_STRING, SDARRAY etc., so we convert all object types to CLASS.
        // Also, BOOLEAN, CHAR are converted to U1, I2.
        FieldDescElementType = ElementType;
        switch (ElementType)
        {
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
        {
            dwLog2FieldSize = 0;
            break;
        }
            
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        {
            dwLog2FieldSize = 1;
            break;
        }
        
        case ELEMENT_TYPE_I:
            ElementType = ELEMENT_TYPE_I4;
            goto GOT_ELEMENT_TYPE;

        case ELEMENT_TYPE_U:
            ElementType = ELEMENT_TYPE_U4;
            goto GOT_ELEMENT_TYPE;

        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_R4:
            {
                dwLog2FieldSize = 2;
                break;
            }
            
        case ELEMENT_TYPE_BOOLEAN:
            {
                //                FieldDescElementType = ELEMENT_TYPE_U1;
                dwLog2FieldSize = 0;
                break;
            }
            
        case ELEMENT_TYPE_CHAR:
            {
                //                FieldDescElementType = ELEMENT_TYPE_U2;
                dwLog2FieldSize = 1;
                break;
            }
            
        case ELEMENT_TYPE_R8:
            dwR8Fields++;
            // Fall through

        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
            {
               dwLog2FieldSize = 3;
                break;
            }
            
        case ELEMENT_TYPE_FNPTR:
        case ELEMENT_TYPE_PTR:   // ptrs are unmanaged scalars, for layout
            {
                // 64 bit stuff
                dwLog2FieldSize = ((sizeof(SLOT) == 4) ? 2 : 3);
                break;
            }
            
        case ELEMENT_TYPE_STRING:
        case ELEMENT_TYPE_SZARRAY:      // single dim, zero
        case ELEMENT_TYPE_ARRAY:        // all other arrays
        case ELEMENT_TYPE_CLASS: // objectrefs
        case ELEMENT_TYPE_OBJECT:
        case ELEMENT_TYPE_VAR:
            {
                // 64 bit stuff
                dwLog2FieldSize = ((sizeof(SLOT) == 4) ? 2 : 3);
                bCurrentFieldIsGCPointer = TRUE;
                FieldDescElementType = ELEMENT_TYPE_CLASS;
                
                if (IsFdStatic(dwMemberAttrs) == 0)
                {
                    m_VMFlags |= VMFLAG_HAS_FIELDS_WHICH_MUST_BE_INITED;
                }
                else
                {
                    // Increment the number of static fields that contain object references.
                    bmtEnumMF->dwNumStaticObjRefFields++;
                }
                break;
            }
            
        case ELEMENT_TYPE_VALUETYPE: // a byvalue class field
            {
                // Need to check whether we have an instance of a by-value class
                CorSigUncompressToken(pFieldSig, &dwByValueClassToken);
                fIsByValue = TRUE;
                
                // By-value class
                _ASSERTE(dwByValueClassToken != 0);
#ifndef RVA_FIELD_VALIDATION_ENABLED                
                if (fHasRVA)
                    break;
#endif
                // It's possible a value class X can have a static field of type X, so we have to catch this
                // special case.
                //
                // We want to avoid calling LoadClass() and having it fail, since that causes all sorts of things
                // (like the converter module) to get loaded.
                if (this->IsValueClass())
                {
                    if (dwByValueClassToken == this->GetCl())
                    {
                        // TypeDef token
                        if (!IsFdStatic(dwMemberAttrs))
                        {
                            bmtError->resIDWhy = IDS_CLASSLOAD_VALUEINSTANCEFIELD;
                            return COR_E_TYPELOAD;
                        }
                    
                        pByValueClass = this;
                    }
                    else
                    {
                        if (IsFdStatic(dwMemberAttrs) && (TypeFromToken(dwByValueClassToken) == mdtTypeRef))
                        {
                            // It's a typeref - check if it's a class that has a static field of itself
                            mdTypeDef ValueCL;
                        
                            // @TODO: It would be nice if we didn't have to do this.  Right now every time there is a
                            // static value class, we're going to take this longer code path.
                            LPCUTF8 pszNameSpace;
                            LPCUTF8 pszClassName;
                            pInternalImport->GetNameOfTypeRef(dwByValueClassToken, &pszNameSpace, &pszClassName);
                            if(IsStrLongerThan((char*)pszClassName,MAX_CLASS_NAME)
                                || IsStrLongerThan((char*)pszNameSpace,MAX_CLASS_NAME)
                                || (strlen(pszClassName)+strlen(pszNameSpace)+1 >= MAX_CLASS_NAME))
                            {
                                _ASSERTE(!"Full Name ofTypeRef Too Long");
                                return (COR_E_TYPELOAD);
                            }
                            mdToken tkRes = pInternalImport->GetResolutionScopeOfTypeRef(dwByValueClassToken);
                            if(TypeFromToken(tkRes) == mdtTypeRef)
                            {
                                DWORD rid = RidFromToken(tkRes);
                                if((rid==0)||(rid > pInternalImport->GetCountWithTokenKind(mdtTypeRef)))
                                {
                                    _ASSERTE(!"TypeRef Token Out of Range");
                                    return(COR_E_TYPELOAD);
                                }
                            }
                            else tkRes = mdTokenNil;
                        
                            if (SUCCEEDED(pInternalImport->FindTypeDef(pszNameSpace,
                                                                                    pszClassName,
                                                                       tkRes,
                                                                                    &ValueCL)))
                            {
                                if (ValueCL == this->GetCl())
                                        pByValueClass = this;
                            }
                        } // If field is static typeref
                    } // If field is self-referencing
                } // If 'this' is a value class

                if (!pByValueClass) {
                    NameHandle name(bmtInternal->pModule, dwByValueClassToken);
                    if (bmtInternal->pModule->IsEditAndContinue() && GetThread() == NULL)
                        name.SetTokenNotToLoad(tdAllTypes);
                    pByValueClass = GetClassLoader()->LoadTypeHandle(&name, bmtError->pThrowable).GetClass();
    
                    if(! pByValueClass) {
                        IfFailRet(COR_E_TYPELOAD);
                    }
                }

                
                // IF it is an enum, strip it down to its underlying type

                if (pByValueClass->IsEnum()) {
                    _ASSERTE((pByValueClass == this && bmtEnumMF->dwNumInstanceFields == 1)
                             || pByValueClass->GetNumInstanceFields() == 1);      // enums must have exactly one field
                    FieldDesc* enumField = pByValueClass->m_pFieldDescList;
                    _ASSERTE(!enumField->IsStatic());   // no real static fields on enums
                    ElementType = enumField->GetFieldType();
                    _ASSERTE(ElementType != ELEMENT_TYPE_VALUETYPE);
                    fIsByValue = FALSE; // we're going to treat it as the underlying type now
                    goto GOT_ELEMENT_TYPE;
                }
                else if ( (pByValueClass->IsValueClass() == FALSE) &&
                          (pByValueClass != g_pEnumClass->GetClass()) ) {
                    _ASSERTE(!"Class must be declared to be by value to use as by value");
                    return hr;
                }

                // If it is an illegal type, say so
                if (pByValueClass->ContainsStackPtr())
                    goto BAD_FIELD;

                // If a class has a field of type ValueType with non-public fields in it, 
                // the class must "inherit" this characteristic
                if (pByValueClass->HasNonPublicFields())
                {
                    m_VMFlags |= VMFLAG_HASNONPUBLICFIELDS;
                }

#ifdef RVA_FIELD_VALIDATION_ENABLED
                if (fHasRVA)
                {
                    dwLog2FieldSize = IsFdStatic(dwMemberAttrs) ? LOG2PTR : 0;
                    break;
                }
#endif

                if (IsFdStatic(dwMemberAttrs) == 0)
                {
                    if (pByValueClass->HasFieldsWhichMustBeInited())
                        m_VMFlags |= VMFLAG_HAS_FIELDS_WHICH_MUST_BE_INITED;
                }
                else
                {
                    // Increment the number of static fields that contain object references.
                    if (!IsFdHasFieldRVA(dwMemberAttrs)) 
                        bmtEnumMF->dwNumStaticObjRefFields++;
                }
                
                // Need to create by value class cache.  For E&C, this pointer will get
                // cached indefinately and not cleaned up as the parent descriptors are
                // in the low frequency heap.  Use HeapAlloc with the intent of leaking
                // this pointer and avoiding the assert (jlz, bug 41344).
                if (*pByValueClassCache == NULL)
                {
                    WS_PERF_SET_HEAP(SYSTEM_HEAP);
                    *pByValueClassCache = (EEClass **) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (bmtEnumMF->dwNumInstanceFields + bmtEnumMF->dwNumStaticFields) * sizeof(EEClass **));
                    if (*pByValueClassCache == NULL)
                    {
                        FailFast(GetThread(), FatalOutOfMemory);
                    }
                    
                    WS_PERF_UPDATE("EEClass:BuildMethodTable, by valueclasscache", sizeof(EEClass*)*(bmtEnumMF->dwNumInstanceFields + bmtEnumMF->dwNumStaticFields), *pByValueClassCache);                 
                }
                
                // Static fields come after instance fields in this list
                if (IsFdStatic(dwMemberAttrs))
                {
                    (*pByValueClassCache)[bmtEnumMF->dwNumInstanceFields + dwCurrentStaticField] = pByValueClass;
                    dwLog2FieldSize = LOG2PTR; // handle
                }
                else
                {
                    (*pByValueClassCache)[dwCurrentDeclaredField] = pByValueClass;
                    dwLog2FieldSize = 0; // unused
                }
                
                break;
            }
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            // Just skip the custom modifier token.
            CorSigUncompressToken(pFieldSig);
            goto SET_ELEMENT_TYPE;
        default:
            {
                BAD_FIELD:
                bmtError->resIDWhy = IDS_CLASSLOAD_BAD_FIELD;
                IfFailRet(COR_E_TYPELOAD);
            }
        }

        
        // Static fields are not packed
        if (IsFdStatic(dwMemberAttrs) && (dwLog2FieldSize < 2))
            dwLog2FieldSize = 2;
        
        if (!IsFdStatic(dwMemberAttrs))
        {
            pFD = &pFieldDescList[dwCurrentDeclaredField];
            *totalDeclaredSize += (1 << dwLog2FieldSize);
        }
        else /* (dwMemberAttrs & mdStatic) */
        {
            pFD = &pFieldDescList[bmtEnumMF->dwNumInstanceFields + dwCurrentStaticField];
        }
        
        bmtMFDescs->ppFieldDescList[i] = pFD;
        
        const LayoutRawFieldInfo *pLayoutFieldInfo;
        
        pLayoutFieldInfo    = NULL;
        
        if (HasLayout())
        {
            const LayoutRawFieldInfo *pwalk = pLayoutRawFieldInfos;
            while (pwalk->m_MD != mdFieldDefNil)
            {
                if (pwalk->m_MD == bmtMetaData->pFields[i])
                {
                    
                    pLayoutFieldInfo = pwalk;
                    CopyMemory(pNextFieldMarshaler,
                               &(pwalk->m_FieldMarshaler),
                               MAXFIELDMARSHALERSIZE);
                    
                    pNextFieldMarshaler->m_pFD = pFD;
                    pNextFieldMarshaler->m_dwExternalOffset = pwalk->m_offset;
                    
                    ((BYTE*&)pNextFieldMarshaler) += MAXFIELDMARSHALERSIZE;
                    break;
                }
                pwalk++;
            }
        }
        
        LPCSTR pszFieldName = NULL;
#ifdef _DEBUG
        pszFieldName = pInternalImport->GetNameOfFieldDef(bmtMetaData->pFields[i]);
#endif
        // Initialize contents
        pFD->Init(
                  bmtMetaData->pFields[i],
                  FieldDescElementType,
                  dwMemberAttrs,
                  IsFdStatic(dwMemberAttrs),
                  fHasRVA,
                  fIsThreadStatic,
                  fIsContextStatic,
                  pszFieldName
                  );

        // Check if the ValueType field containing non-publics is overlapped
        if(HasExplicitFieldOffsetLayout()
            && pLayoutFieldInfo
            && pLayoutFieldInfo->m_fIsOverlapped
            && pByValueClass
            && pByValueClass->HasNonPublicFields())
        {
            
            if (!Security::CanSkipVerification(GetAssembly()))
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_BADOVERLAP;
                IfFailRet(COR_E_TYPELOAD);
            }
        }
            
        if (fIsByValue)
        {
            if (!IsFdStatic(dwMemberAttrs) &&
                (IsBlittable() || HasExplicitFieldOffsetLayout()))
            {
                pFD->m_pMTOfEnclosingClass =
                    (MethodTable *)(size_t)((*pByValueClassCache)[dwCurrentDeclaredField]->GetNumInstanceFieldBytes()); // @todo WIN64 - conversion from DWORD to MethodTable * of greater size (GetNumInstanceFieldBytes)

                if (pLayoutFieldInfo)
                    IfFailRet(pFD->SetOffset(pLayoutFieldInfo->m_offset));
                else
                    pFD->SetOffset(FIELD_OFFSET_VALUE_CLASS);
            }
            else
            {
                // static value class fields hold a handle, which is ptr sized
                // (instance field layout ignores this value)
                pFD->m_pMTOfEnclosingClass = (MethodTable *) LOG2PTR;
                pFD->SetOffset(FIELD_OFFSET_VALUE_CLASS);
            }
        }
        else
        {
            // Use the field's MethodTable to temporarily store the field's size
            pFD->m_pMTOfEnclosingClass = (MethodTable *)(size_t)dwLog2FieldSize;
            
            // -1 means that this field has not yet been placed
            // -2 means that this is a GC Pointer field not yet places
            if ((IsBlittable() || HasExplicitFieldOffsetLayout()) && !(IsFdStatic(dwMemberAttrs)))
                IfFailRet(pFD->SetOffset(pLayoutFieldInfo->m_offset));
            else if (bCurrentFieldIsGCPointer)
                pFD->SetOffset(FIELD_OFFSET_UNPLACED_GC_PTR);
            else
                pFD->SetOffset(FIELD_OFFSET_UNPLACED);
        }
        
        if (!IsFdStatic(dwMemberAttrs))
        {
            if (!fIsByValue)
            {
                if (++bmtFP->NumInstanceFieldsOfSize[dwLog2FieldSize] == 1)
                    bmtFP->FirstInstanceFieldOfSize[dwLog2FieldSize] = dwCurrentDeclaredField;
            }
            
            dwCurrentDeclaredField++;
            
            if (bCurrentFieldIsGCPointer)
                bmtFP->NumInstanceGCPointerFields++;
        }
        else /* static fields */
        {
            
            // Static fields are stored in the vtable after the vtable and interface slots.  We don't
            // know how large the vtable will be, so we will have to fixup the slot number by
            // <vtable + interface size> later.
            dwCurrentStaticField++;
            if(fHasRVA)
            {
#ifdef RVA_FIELD_VALIDATION_ENABLED
                    // Check if we place ObjectRefs into RVA field
                    if((FieldDescElementType==ELEMENT_TYPE_CLASS)
                        ||((FieldDescElementType==ELEMENT_TYPE_VALUETYPE)
                            &&pByValueClass->HasFieldsWhichMustBeInited()))
                    {
                        _ASSERTE(!"ObjectRef in an RVA field");
                        bmtError->resIDWhy = IDS_CLASSLOAD_BAD_FIELD;
                        IfFailRet(COR_E_TYPELOAD);
                    }
                    // Check if we place ValueType with non-public fields into RVA field
                    if((FieldDescElementType==ELEMENT_TYPE_VALUETYPE)
                            &&pByValueClass->HasNonPublicFields())
                    {
                        if (!Security::CanSkipVerification(GetAssembly()))
                        {
                            _ASSERTE(!"ValueType with non-public fields as a type of an RVA field");
                            bmtError->resIDWhy = IDS_CLASSLOAD_BAD_FIELD;
                            IfFailRet(COR_E_TYPELOAD);
                        }
                    }
#endif
                    // Set the field offset
                    DWORD rva;
                    IfFailRet(pInternalImport->GetFieldRVA(pFD->GetMemberDef(), &rva)); 
#ifdef RVA_FIELD_VALIDATION_ENABLED
                    if(pMod->IsPEFile())
                    {
                        IMAGE_NT_HEADERS *NtHeaders = pMod->GetPEFile()->GetNTHeader();
                        ULONG i, Nsect = NtHeaders->FileHeader.NumberOfSections;
                        PIMAGE_SECTION_HEADER NtSection = IMAGE_FIRST_SECTION( NtHeaders );
                        DWORD       rva_end = rva + (FieldDescElementType==ELEMENT_TYPE_VALUETYPE ?
                            pByValueClass->GetNumInstanceFieldBytes() 
                            : GetSizeForCorElementType(FieldDescElementType));
                        DWORD   sec_start,sec_end,filler,roundup = NtHeaders->OptionalHeader.SectionAlignment;
                        for (i=0; i<Nsect; i++, NtSection++) 
                        {
                            sec_start = NtSection->VirtualAddress;
                            sec_end   = NtSection->Misc.VirtualSize;
                            filler    = sec_end & (roundup-1);
                            if(filler) filler = roundup-filler;
                            sec_end += sec_start+filler;

                            if ((rva >= sec_start) && (rva < sec_end))
                            {
                                if ((rva_end < sec_start) || (rva_end > sec_end)) i = Nsect;
                                break;
                            }
                        }
                        if(i >= Nsect)
                        {
                            if (!Security::CanSkipVerification(GetAssembly()))
                            {
                                _ASSERTE(!"Illegal RVA of a mapped field");
                                bmtError->resIDWhy = IDS_CLASSLOAD_BAD_FIELD;
                                IfFailRet(COR_E_TYPELOAD);
                            }
                        }
                    }
#endif
                    IfFailRet(pFD->SetOffsetRVA(rva));
#ifdef RVA_FIELD_OVERLAPPING_VALIDATION_ENABLED
                    // Check if the field overlaps with known RVA fields
                    BYTE*   pbModuleBase = pMod->GetILBase();
                    DWORD       dwSizeOfThisField = FieldDescElementType==ELEMENT_TYPE_VALUETYPE ?
                        pByValueClass->GetNumInstanceFieldBytes() : GetSizeForCorElementType(FieldDescElementType); 
                    BYTE* FDfrom = pbModuleBase + pFD->GetOffset();
                    BYTE* FDto = FDfrom + dwSizeOfThisField;
                    
                    ULONG j;
                    if(g_drRVAField)
                    {
                        for(j=1; j < g_ulNumRVAFields; j++)
                        {
                            if((*g_drRVAField)[j].pbStart >= FDto) continue;
                            if((*g_drRVAField)[j].pbEnd <= FDfrom) continue;
                            /*
                            _ASSERTE(!"Overlapping RVA fields");
                            bmtError->resIDWhy = IDS_CLASSLOAD_BAD_FIELD;
                            IfFailRet(COR_E_TYPELOAD);
                            */
                        }
                    }
                    else
                        g_drRVAField = new DynamicArray<RVAFSE>;
                    (*g_drRVAField)[g_ulNumRVAFields].pbStart = FDfrom;
                    (*g_drRVAField)[g_ulNumRVAFields].pbEnd = FDto;
                    g_ulNumRVAFields++;
#endif
                    ;
                    
                }
                else if (fIsThreadStatic) 
                {
                    DWORD size = 1 << dwLog2FieldSize;
                    if(IsShared())
                    {
                        IfFailRet(pFD->SetOffset(dwSharedThreadStatic));
                        dwSharedThreadStatic += size;
                    }
                    else
                    {
                        IfFailRet(pFD->SetOffset(dwUnsharedThreadStatic));
                        dwUnsharedThreadStatic += size;
                    }
                }
                else if (fIsContextStatic) 
                {
                    DWORD size = 1 << dwLog2FieldSize;
                    if(IsShared())
                    {
                        IfFailRet(pFD->SetOffset(dwSharedContextStatic));
                        dwSharedContextStatic += size;
                    }
                    else
                    {
                        IfFailRet(pFD->SetOffset(dwUnsharedContextStatic));
                        dwUnsharedContextStatic += size;
                    }
                }
            else
            {
                bmtFP->NumStaticFieldsOfSize[dwLog2FieldSize]++;
            
                if (bCurrentFieldIsGCPointer || fIsByValue)
                    bmtFP->NumStaticGCPointerFields++;
            }
        }
    }

    m_wNumStaticFields   = (WORD) bmtEnumMF->dwNumStaticFields;
    m_wNumInstanceFields = (WORD) (dwCurrentDeclaredField + (GetParentClass() ? GetParentClass()->m_wNumInstanceFields : 0));

    if (ShouldAlign8(dwR8Fields, m_wNumInstanceFields))
    {
        SetAlign8Candidate();
    }

    if(fSetThreadStaticOffset)
    {
        if(IsShared())
        {
            SetThreadStaticOffset ((WORD)BaseDomain::IncSharedTLSOffset());
            m_wThreadStaticsSize = (WORD)dwSharedThreadStatic;
        }
        else
        {
            SetThreadStaticOffset ((WORD)GetDomain()->IncUnsharedTLSOffset());
            m_wThreadStaticsSize = (WORD)dwUnsharedThreadStatic;
        }

    }

    if(fSetContextStaticOffset)
    {
        if(IsShared())
        {
            SetContextStaticOffset ((WORD)BaseDomain::IncSharedCLSOffset());
            m_wContextStaticsSize = (WORD)dwSharedContextStatic;
        }
        else
        {
            SetContextStaticOffset ((WORD)GetDomain()->IncUnsharedCLSOffset());
            m_wContextStaticsSize = (WORD)dwUnsharedContextStatic;
        }
    }
    
    //========================================================================
    // END:
    //    Go thru all fields and initialize their FieldDescs.
    //========================================================================
    
    
    return hr;
}



HRESULT EEClass::TestOverRide(DWORD dwParentAttrs, DWORD dwMemberAttrs, BOOL isSameAssembly, bmtErrorInfo* bmtError)
{
    HRESULT hr = COR_E_TYPELOAD;

    // Virtual methods cannot be static
    if (IsMdStatic(dwMemberAttrs)) {
        //_ASSERTE(!"A method cannot be both static and virtual");
        bmtError->resIDWhy = IDS_CLASSLOAD_STATICVIRTUAL;
        IfFailRet(hr);
    }

    // if the method marks itself as check visibility the the method must be 
    // public, FamORAssem, or family
    if(!isSameAssembly && 
       IsMdCheckAccessOnOverride(dwParentAttrs) &&
       ((dwParentAttrs & mdMemberAccessMask) < mdFamily)) {
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_ACCESS_FAILURE;
        IfFailRet(hr);
    }

    // Check that we are not attempting to reduce the access level of a method
    // (public -> FamORAssem -> family -> FamANDAssem -> default(package) -> private -> PrivateScope)
    // (public -> FamORAssem -> assem  -> FamANDAssem -> default(package) -> private -> PrivateScope)
    if (IsMdAssem(dwParentAttrs)) {
        if (IsMdFamily(dwMemberAttrs) ||
            (dwMemberAttrs & mdMemberAccessMask) < (mdMemberAccessMask & dwParentAttrs) ) {
            bmtError->resIDWhy = IDS_CLASSLOAD_REDUCEACCESS;
            IfFailRet(hr);
        }
    }
    else {
        if((dwMemberAttrs & mdMemberAccessMask) < (dwParentAttrs & mdMemberAccessMask)) {

            // bug fix 31375: we will allow derived method to be Family if the base method is FamOrAssem and derived
            // and base class are not from the same assembly.
            //
            if (!(IsMdFamORAssem(dwParentAttrs) && IsMdFamily(dwMemberAttrs) && isSameAssembly == FALSE)) {
                bmtError->resIDWhy = IDS_CLASSLOAD_REDUCEACCESS;
                IfFailRet(hr);
            }
        }
    }

    return S_OK;
}

//
// Used by BuildMethodTable
//
// Determine vtable placement for each member in this class
//

HRESULT EEClass::PlaceMembers(bmtInternalInfo* bmtInternal, 
                              bmtMetaDataInfo* bmtMetaData, 
                              bmtErrorInfo* bmtError, 
                              bmtProperties* bmtProp, 
                              bmtParentInfo* bmtParent, 
                              bmtInterfaceInfo* bmtInterface, 
                              bmtMethAndFieldDescs* bmtMFDescs, 
                              bmtEnumMethAndFields* bmtEnumMF, 
                              bmtMethodImplInfo* bmtMethodImpl,
                              bmtVtable* bmtVT)
{

#ifdef _DEBUG
    LPCUTF8 pszDebugName,pszDebugNamespace;
    bmtInternal->pModule->GetMDImport()->GetNameOfTypeDef(GetCl(), &pszDebugName, &pszDebugNamespace);
#endif

    HRESULT hr = S_OK;
    DWORD i, j;
    DWORD  dwClassDeclFlags = 0xffffffff;
    DWORD  dwClassNullDeclFlags = 0xffffffff;
    IMAGE_NT_HEADERS *pNT = bmtInternal->pModule->IsPEFile() ?
                                bmtInternal->pModule->GetPEFile()->GetNTHeader() : NULL;
    ULONG Nsections = pNT ? pNT->FileHeader.NumberOfSections : 0;

    bmtVT->wCCtorSlot = MethodTable::NO_SLOT;
    bmtVT->wDefaultCtorSlot = MethodTable::NO_SLOT;

    for (i = 0; i < bmtMetaData->cMethods; i++)
        {
        LPCUTF8     szMemberName = NULL;
        PCCOR_SIGNATURE pMemberSignature = NULL;
        DWORD       cMemberSignature = 0;
        DWORD       dwMemberAttrs;
        DWORD       dwDescrOffset;
        DWORD       dwImplFlags;
        BOOL        fMethodImplementsInterface = FALSE;
        DWORD       dwMDImplementsInterfaceNum = 0;
        DWORD       dwMDImplementsSlotNum = 0;
        DWORD       dwMethodHashBit;
        DWORD       dwParentAttrs;

        dwMemberAttrs = bmtMetaData->pMethodAttrs[i];
        dwDescrOffset = bmtMetaData->pMethodRVA[i];
        dwImplFlags = bmtMetaData->pMethodImplFlags[i];

        DWORD Classification = bmtMetaData->pMethodClassifications[i];
        DWORD type = bmtMetaData->pMethodType[i];
        DWORD impl = bmtMetaData->pMethodImpl[i];

        // for IL code that is implemented here must have a valid code RVA
        // this came up due to a linker bug where the ImplFlags/DescrOffset were
        // being set to null and we weren't coping with it
        if (dwDescrOffset == 0)
        {
            if((dwImplFlags == 0 || IsMiIL(dwImplFlags) || IsMiOPTIL(dwImplFlags)) &&
               !IsMiRuntime(dwImplFlags) &&
               !IsMdAbstract(dwMemberAttrs) &&
               !IsReallyMdPinvokeImpl(dwMemberAttrs) &&
               !IsMiInternalCall(dwImplFlags) &&
               !(bmtInternal->pModule)->IsReflection() && 
               !(IsInterface() && !IsMdStatic(dwMemberAttrs)) && 
               bmtInternal->pModule->GetAssembly()->GetDomain()->IsExecutable())
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_MISSINGMETHODRVA;
                bmtError->dMethodDefInError = bmtMetaData->pMethods[i];
                IfFailRet(COR_E_TYPELOAD);
            }
        }
        else if(Nsections)
        {
            IMAGE_SECTION_HEADER *pSecHdr = IMAGE_FIRST_SECTION(pNT);
            for(j = 0; j < Nsections; j++,pSecHdr++)
            {
                if((dwDescrOffset >= pSecHdr->VirtualAddress)&&
                  (dwDescrOffset < pSecHdr->VirtualAddress+pSecHdr->Misc.VirtualSize)) break;
            }
            if(j >= Nsections)
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_MISSINGMETHODRVA;
                bmtError->dMethodDefInError = bmtMetaData->pMethods[i];
                IfFailRet(COR_E_TYPELOAD);
            }
        }

        // If this member is a method which overrides a parent method, it will be set to non-NULL
        MethodDesc *pParentMethodDesc = NULL;

        BOOL        fIsInitMethod = FALSE;

        BOOL        fIsCCtor = FALSE;
        BOOL        fIsDefaultCtor = FALSE;

        szMemberName = bmtMetaData->pstrMethodName[i];
#ifdef _DEBUG
        if(m_fDebuggingClass && g_pConfig->ShouldBreakOnMethod(szMemberName))
            _ASSERTE(!"BreakOnMethodName");
#endif
        // constructors and class initialisers are special
        if (IsMdRTSpecialName(dwMemberAttrs))
        {
            {
                if (IsMdStatic(dwMemberAttrs)) {
                    // Verify the name for the class constuctor.
                    if(strcmp(szMemberName, COR_CCTOR_METHOD_NAME))
                        hr = COR_E_TYPELOAD;

                    else {
                        // Validate that we have the correct signature for the .cctor
                        pMemberSignature = bmtInternal->pInternalImport->GetSigOfMethodDef(bmtMetaData->pMethods[i],
                                                                                           &cMemberSignature
                                                                                           );
                        PCCOR_SIGNATURE pbBinarySig;
                        ULONG           cbBinarySig;
                        // .cctor must return void, have default call conv, and have no args
                        unsigned cconv,nargs;
                        pbBinarySig = pMemberSignature;
                        cconv = CorSigUncompressData(pbBinarySig);
                        nargs = CorSigUncompressData(pbBinarySig);

                            // TODO: comparisions of return type and call convention unecessary as ComaprMethodSigs does that
                        if((*pbBinarySig != ELEMENT_TYPE_VOID)||(nargs!=0)||(cconv != IMAGE_CEE_CS_CALLCONV_DEFAULT))
                            hr = COR_E_TYPELOAD;
                        else {
                            if(FAILED(gsig_SM_RetVoid.GetBinaryForm(&pbBinarySig, &cbBinarySig)))
                                hr = COR_E_EXECUTIONENGINE;
                            else {
                                if (MetaSig::CompareMethodSigs(pbBinarySig, cbBinarySig, 
                                                               SystemDomain::SystemModule(), 
                                                               pMemberSignature, cMemberSignature, bmtInternal->pModule)) 
                                    fIsCCtor = TRUE;
                                else
                                    hr = COR_E_TYPELOAD;
                            }
                        }
                    }
                }
                else {
                    // Verify the name for a constructor.
                    if(strcmp(szMemberName, COR_CTOR_METHOD_NAME) != 0)
                    {
                        hr = COR_E_TYPELOAD;
                    }
                    else 
                    {
                        // See if this is a default constructor.  If so, remember it for later.
                        pMemberSignature = bmtInternal->pInternalImport->GetSigOfMethodDef(bmtMetaData->pMethods[i],
                                                                                           &cMemberSignature
                                                                                           );
                        PCCOR_SIGNATURE pbBinarySig;
                        ULONG           cbBinarySig;
                        // .ctor must return void
                        pbBinarySig = pMemberSignature;
                        CorSigUncompressData(pbBinarySig); // get call conv out of the way
                        CorSigUncompressData(pbBinarySig); // get num args out of the way

                            // TODO: explicit check for return type unnecessary, done in compareMethodSigs
                        if(*pbBinarySig != ELEMENT_TYPE_VOID) 
                            hr = COR_E_TYPELOAD;
                        else {
                            if(FAILED(gsig_IM_RetVoid.GetBinaryForm(&pbBinarySig, &cbBinarySig)))
                                hr = COR_E_EXECUTIONENGINE;
                            else {
                                if (MetaSig::CompareMethodSigs(pbBinarySig, cbBinarySig, 
                                                               SystemDomain::SystemModule(), 
                                                               pMemberSignature, cMemberSignature, bmtInternal->pModule)) 
                                    fIsDefaultCtor = TRUE;
                            }
                        }

                        fIsInitMethod = TRUE;
                    }
                }
            }
            // We have as specially marked member, verify that it is has a legitimate signature
            if(FAILED(hr)) {
                bmtError->resIDWhy = IDS_CLASSLOAD_BADSPECIALMETHOD;
                bmtError->dMethodDefInError = bmtMetaData->pMethods[i];
                IfFailRet(hr);
            }
        } else { // The method does not have the special marking
            
            if (IsMdVirtual(dwMemberAttrs)) 
            {

                // Hash that a method with this name exists in this class
                // Note that ctors and static ctors are not added to the table
                DWORD dwHashName = HashStringA(szMemberName);
                dwMethodHashBit = dwHashName % METHOD_HASH_BITS;
                m_MethodHash[dwMethodHashBit >> 3] |= (1 << (dwMethodHashBit & 7));

                // If the member is marked with a new slot we do not need to find it
                // in the parent
                if (!IsMdNewSlot(dwMemberAttrs)) 
                {
                    // If we're not doing sanity checks, then assume that any method declared static
                    // does not attempt to override some virtual parent.
                    if (!IsMdStatic(dwMemberAttrs) &&
                        GetParentClass() != NULL) {
                        
                        // Attempt to find the method with this name and signature in the parent class.
                        // This method may or may not create pParentMethodHash (if it does not already exist).
                        // It also may or may not fill in pMemberSignature/cMemberSignature. 
                        // An error is only returned when we can not create the hash.
                        IfFailRet(LoaderFindMethodInClass(&(bmtParent->pParentMethodHash), 
                                                          szMemberName, 
                                                          bmtInternal->pModule, 
                                                          bmtMetaData->pMethods[i], 
                                                          &pParentMethodDesc, 
                                                          &pMemberSignature, &cMemberSignature,
                                                          dwHashName));


                        if (pParentMethodDesc != NULL) {
                            dwParentAttrs = pParentMethodDesc->GetAttrs();

                            _ASSERTE(IsMdVirtual(dwParentAttrs) && "Non virtual methods should not be searched");
                            _ASSERTE(fIsInitMethod == FALSE);

                            // if we end up pointing at a slot that is final we are not allowed to override it.
                            if(IsMdFinal(dwParentAttrs)) {
                                bmtError->resIDWhy = IDS_CLASSLOAD_MI_FINAL_DECL;                        
                                bmtError->dMethodDefInError = bmtMetaData->pMethods[i];
                                bmtError->szMethodNameForError = NULL;
                                IfFailRet(COR_E_TYPELOAD);
                            }
                            else if(!bmtProp->fNoSanityChecks) {
                                BOOL isSameAssembly = (pParentMethodDesc->GetClass()->GetClassLoader()->GetAssembly() == 
                                                       GetClassLoader()->GetAssembly());
                                hr = TestOverRide(dwParentAttrs, dwMemberAttrs, isSameAssembly, bmtError);
                                if(FAILED(hr)) {
                                        //_ASSERTE(!"Attempting to reduce access of public method");
                                    bmtError->dMethodDefInError = bmtMetaData->pMethods[i];
                                    return hr;
                                }
                            }
                        }
                    }
                }
            }
        }


        if(pParentMethodDesc == NULL) {
            // This method does not exist in the parent.  If we are a class, check whether this
            // method implements any interface.  If true, we can't place this method now.
            if ((IsInterface() == FALSE) &&
                (   IsMdPublic(dwMemberAttrs) &&
                    IsMdVirtual(dwMemberAttrs) &&
                    !IsMdStatic(dwMemberAttrs) &&
                    !IsMdRTSpecialName(dwMemberAttrs))) {
                
                // Don't check parent class interfaces - if the parent class had to implement an interface,
                // then it is already guaranteed that we inherited that method.
                for (j = (GetParentClass() ? GetParentClass()->m_wNumInterfaces : 0); 
                     j < bmtInterface->dwInterfaceMapSize; 
                     j++) 
                {

                    EEClass *pInterface;
                    
                    pInterface = bmtInterface->pInterfaceMap[j].m_pMethodTable->GetClass();
                    
                    if (CouldMethodExistInClass(pInterface, szMemberName, 0) == 0)
                        continue;
                    
                    // We've been trying to avoid asking for the signature - now we need it
                    if (pMemberSignature == NULL) {
                        
                        pMemberSignature = bmtInternal->pInternalImport->GetSigOfMethodDef(
                                                                                           bmtMetaData->pMethods[i],
                                                                                           &cMemberSignature
                                                                                           );
                    }
                
                    DWORD slotNum = -1;
                    if (pInterface->InterfaceFindMethod(szMemberName, 
                                                        pMemberSignature, cMemberSignature,
                                                        bmtInternal->pModule, &slotNum)) {
                    
                        // This method implements an interface - don't place it
                        fMethodImplementsInterface = TRUE;

                        // Keep track of this fact and use it while placing the interface
                        _ASSERTE(slotNum != -1);
                        if (bmtInterface->pppInterfaceImplementingMD[j] == NULL)
                        {
                            bmtInterface->pppInterfaceImplementingMD[j] = (MethodDesc**)GetThread()->m_MarshalAlloc.Alloc(sizeof(MethodDesc *) * pInterface->GetNumVtableSlots());
                            memset(bmtInterface->pppInterfaceImplementingMD[j], 0, sizeof(MethodDesc *) * pInterface->GetNumVtableSlots());
                        }
                        dwMDImplementsInterfaceNum = j;
                        dwMDImplementsSlotNum = slotNum;
                        break;
                    }
                }
            }
        }
        
        // Now we know the classification we can allocate the correct type of
        // method desc and perform any classification specific initialization.
        
        bmtTokenRangeNode *pTR = GetTokenRange(bmtMetaData->pMethods[i], 
                                               &(bmtMetaData->ranges[type][impl]));
        _ASSERTE(pTR->cMethods != 0);

        bmtMethodDescSet *set = &bmtMFDescs->sets[type][impl];

        // The MethodDesc we allocate for this method
        MethodDesc *pNewMD = set->pChunkList[pTR->dwCurrentChunk]->GetMethodDescAt(pTR->dwCurrentIndex);

        LPCSTR pName = bmtMetaData->pstrMethodName[i];
        if (pName == NULL)
            pName = bmtInternal->pInternalImport->GetNameOfMethodDef(bmtMetaData->pMethods[i]);

        // Write offset into the chunk back into the method desc. This
        // allows us to calculate the location of (and thus the value of)
        // the method table pointer for this method desc.
        pNewMD->SetChunkIndex(pTR->dwCurrentIndex, Classification);

        // Update counters to prepare for next method desc allocation.
        pTR->dwCurrentIndex++;
        if (pTR->dwCurrentIndex == MethodDescChunk::GetMaxMethodDescs(Classification))
        {
            pTR->dwCurrentChunk++;
            pTR->dwCurrentIndex = 0;
        }

#ifdef _DEBUG
        LPCUTF8 pszDebugMethodName = bmtInternal->pInternalImport->GetNameOfMethodDef(bmtMetaData->pMethods[i]);
#endif //_DEBUG

        // Do the init specific to each classification of MethodDesc & assing some common fields
        hr = InitMethodDesc(pNewMD, 
                            Classification,
                            bmtMetaData->pMethods[i],
                            dwImplFlags,
                            dwMemberAttrs,
                            FALSE,
                            dwDescrOffset,          
                            bmtInternal->pModule->GetILBase(),
                            bmtInternal->pInternalImport,
                            pName
#ifdef _DEBUG
                            , pszDebugMethodName,
                            pszDebugName,
                            "" // FIX this happens on global methods, give better info 
#endif // _DEBUG
                           );
        if (FAILED(hr))
        {
            return hr;
        }

        _ASSERTE(bmtParent->ppParentMethodDescBufPtr != NULL);
        _ASSERTE(((bmtParent->ppParentMethodDescBufPtr - bmtParent->ppParentMethodDescBuf) / sizeof(MethodDesc*))
                  < bmtEnumMF->dwNumDeclaredMethods);
        *(bmtParent->ppParentMethodDescBufPtr++) = pParentMethodDesc;
        *(bmtParent->ppParentMethodDescBufPtr++) = pNewMD;

        if (fMethodImplementsInterface  && IsMdVirtual(dwMemberAttrs))
            bmtInterface->pppInterfaceImplementingMD[dwMDImplementsInterfaceNum][dwMDImplementsSlotNum] = pNewMD;

        DWORD dwMethDeclFlags = 0;
        DWORD dwMethNullDeclFlags = 0;

        if (Security::IsSecurityOn())
        {
            if ( IsMdHasSecurity(dwMemberAttrs) || IsTdHasSecurity(m_dwAttrClass) )
            {
                // Disable inlining for any function which does runtime declarative
                // security actions.
                if (pNewMD->GetSecurityFlags(bmtInternal->pInternalImport,
                                             bmtMetaData->pMethods[i],
                                             GetCl(),
                                             &dwClassDeclFlags,
                                             &dwClassNullDeclFlags,
                                             &dwMethDeclFlags,
                                             &dwMethNullDeclFlags) & DECLSEC_RUNTIME_ACTIONS)
                    {
                        pNewMD->SetNotInline(true);

                        // Speculatively mark intercepted here, we may revert
                        // this if we optimize a demand out at jit time, but at
                        // worst we'll cause a racing thread to indirect through
                        // the pre stub needlessly.
                        pNewMD->SetIntercepted(true);
                    }
            }

            if ( IsMdHasSecurity(dwMemberAttrs) )
            {
                // We only care about checks that are not empty...
                dwMethDeclFlags &= ~dwMethNullDeclFlags;

                if ( dwMethDeclFlags & (DECLSEC_LINK_CHECKS|DECLSEC_NONCAS_LINK_DEMANDS) )
                {
                    pNewMD->SetRequiresLinktimeCheck();
                }

                if ( dwMethDeclFlags & (DECLSEC_INHERIT_CHECKS|DECLSEC_NONCAS_INHERITANCE) )
                {
                    pNewMD->SetRequiresInheritanceCheck();
                }
            }

            // Linktime checks on a method override those on a class.
            // If the method has an empty set of linktime checks,
            // then don't require linktime checking for this method.
            if ( this->RequiresLinktimeCheck() && !(dwMethNullDeclFlags & DECLSEC_LINK_CHECKS) )
            {
                pNewMD->SetRequiresLinktimeCheck();
            }

            if ( pParentMethodDesc != NULL &&
                (pParentMethodDesc->RequiresInheritanceCheck() ||
                pParentMethodDesc->ParentRequiresInheritanceCheck()) )
            {
                pNewMD->SetParentRequiresInheritanceCheck();
            }

            // Methods on an interface that includes an UnmanagedCode check
            // suppression attribute are assumed to be interop methods. We ask
            // for linktime checks on these.
            // Also place linktime checks on all P/Invoke calls.
            if ((IsInterface() &&
                 bmtInternal->pInternalImport->GetCustomAttributeByName(GetCl(),
                                                                        COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI,
                                                                        NULL,
                                                                        NULL) == S_OK) ||
                pNewMD->IsNDirect() ||
                (pNewMD->IsComPlusCall() && !IsInterface()))
            {
                pNewMD->SetRequiresLinktimeCheck();
            }

            // All public methods on public types will do a link demand of
            // full trust, unless AllowUntrustedCaller attribute is set
            if (
#ifdef _DEBUG
                g_pConfig->Do_AllowUntrustedCaller_Checks() &&
#endif
                !pNewMD->RequiresLinktimeCheck())
            {
                // If the method is public (visible outside it's assembly), 
                // and the type is public and the assembly
                // is not marked with AllowUntrustedCaller attribute, do
                // a link demand for full trust on all callers note that
                // this won't be effective on virtual overrides. The caller
                // can allways do a virtual call on the base type / interface

                if (Security::MethodIsVisibleOutsideItsAssembly(
                        dwMemberAttrs, m_dwAttrClass))
                {
                    _ASSERTE(m_pLoader);
                    _ASSERTE(GetAssembly());

                    // See if the Assembly has AllowUntrustedCallerChecks CA
                    // Pull this page in last

                    if (!GetAssembly()->AllowUntrustedCaller())
                        pNewMD->SetRequiresLinktimeCheck();
                }
            }
        }

        if (IsMdHasSecurity(dwMemberAttrs))
            pNewMD->SetHasSecurity();

        bmtMFDescs->ppMethodDescList[i] = pNewMD;

        // Make sure that ecalls have a 0 rva.  This is assumed by the prejit fixup logic
        _ASSERTE(((Classification & ~mdcMethodImpl) != mcECall) || dwDescrOffset == 0);

        if (IsMdStatic(dwMemberAttrs) ||
            !IsMdVirtual(dwMemberAttrs) ||
            IsMdRTSpecialName(dwMemberAttrs))
        {
            // non-vtable method
            _ASSERTE( bmtVT->pNonVtable[ bmtVT->dwCurrentNonVtableSlot ] == NULL);

            bmtVT->pNonVtable[ bmtVT->dwCurrentNonVtableSlot ] = (SLOT) pNewMD; // Not prestub addr
            pNewMD->m_wSlotNumber = (WORD) bmtVT->dwCurrentNonVtableSlot;

            if (fIsDefaultCtor)
                bmtVT->wDefaultCtorSlot = (WORD) bmtVT->dwCurrentNonVtableSlot;
            else if (fIsCCtor)
                bmtVT->wCCtorSlot = (WORD) bmtVT->dwCurrentNonVtableSlot;

            bmtVT->dwCurrentNonVtableSlot++;
        }
        else
        {
            pNewMD->m_wSlotNumber = -1; // mark it initially as unplaced
            // vtable method
            if (IsInterface())
            {
                // if we're an interface, our slot number is fixed
                IncrementNumVtableSlots();

                _ASSERTE( bmtVT->pVtable[ bmtVT->dwCurrentVtableSlot ] == NULL);

                bmtVT->pVtable[ bmtVT->dwCurrentVtableSlot ] = (SLOT) pNewMD->GetPreStubAddr();
                pNewMD->m_wSlotNumber = (WORD) bmtVT->dwCurrentVtableSlot;
                bmtVT->dwCurrentVtableSlot++;
            }
            else if (pParentMethodDesc != NULL)
            {
                WORD slotNumber = pParentMethodDesc->m_wSlotNumber;
                // If the MethodDesc was inherited by an interface but not implemented,
                // then the interface's MethodDesc is sitting in the slot and will not reflect
                // the true slot number. Need to find the starting slot of the interface in
                // the parent class to figure out the true slot (starting slot + itf slot)
                if (pParentMethodDesc->IsInterface())
                {
                    _ASSERTE(GetParentClass() != NULL);
                    MethodTable *pItfMT = pParentMethodDesc->GetMethodTable();
                    InterfaceInfo_t *pItfMap = GetParentClass()->GetInterfaceMap();
                    InterfaceInfo_t *pItfMapEnd = pItfMap + GetParentClass()->GetNumInterfaces();
                    while (pItfMap < pItfMapEnd)
                    {
                        if (pItfMap->m_pMethodTable == pItfMT)
                        {
                            slotNumber += pItfMap->m_wStartSlot;
                            break;
                        }
                        pItfMap++;
                    }
                    _ASSERTE(pItfMap < pItfMapEnd);
                }
                // we are overriding a parent method, so place this method now
                bmtVT->pVtable[slotNumber] = (SLOT) pNewMD->GetPreStubAddr();
                pNewMD->m_wSlotNumber = slotNumber;
                if (pParentMethodDesc->IsDuplicate())
                {
                    pNewMD->SetDuplicate();
                }
            }
            // Place it unless we will do it when laying out an interface or it is a body to
            // a method impl. If it is an impl then we will use the slots used by the definition.
            else if (!fMethodImplementsInterface)
            {
                IncrementNumVtableSlots();

                bmtVT->pVtable[ bmtVT->dwCurrentVtableSlot ] = (SLOT) pNewMD->GetPreStubAddr();
                pNewMD->m_wSlotNumber = (WORD) bmtVT->dwCurrentVtableSlot;
                bmtVT->dwCurrentVtableSlot++;
            }

        }

        // If the method desc is a Method Impl then fill in the Array of bodies. Since
        // this Method desc can be used more then once fill all the instances of the
        // body. Go and find the declarations, if the declaration is in this type
        // then store the Token.
        if(Classification & mdcMethodImpl) {
            for(DWORD m = 0; m < bmtEnumMF->dwNumberMethodImpls; m++) {
                if(bmtMetaData->pMethods[i] == bmtMetaData->pMethodBody[m]) {
                    MethodDesc* desc = NULL;
                    BOOL fIsMethod;
                    mdToken mdDecl = bmtMetaData->pMethodDecl[m];
                    hr = GetDescFromMemberRef(bmtInternal->pModule,
                                              mdDecl,
                                              m_cl,
                                              (void**) &desc,
                                              &fIsMethod,
                                              bmtError->pThrowable);
                    if(SUCCEEDED(hr) && desc != NULL && !TestThrowable(bmtError->pThrowable)) {
                        // We found an external member reference
                        _ASSERTE(fIsMethod);
                        mdDecl = mdTokenNil;
                        // Make sure the body is virtaul
                        if(!IsMdVirtual(dwMemberAttrs)) {
                            bmtError->resIDWhy = IDS_CLASSLOAD_MI_MUSTBEVIRTUAL;
                            bmtError->dMethodDefInError = bmtMetaData->pMethods[i]; 
                            bmtError->szMethodNameForError = NULL;
                            IfFailRet(COR_E_TYPELOAD);
                        }
                    }
                    else {
                        if(pThrowableAvailable(bmtError->pThrowable)) *(bmtError->pThrowable) = NULL;
                        hr = S_OK;
                        desc = NULL;
                        if(TypeFromToken(mdDecl) != mdtMethodDef) {
                            Module* pModule;
                            hr = FindMethodDeclaration(bmtInternal,
                                                       mdDecl,
                                                       &mdDecl,
                                                       FALSE,
                                                       &pModule,
                                                       bmtError);
                            IfFailRet(hr);
                            _ASSERTE(pModule == bmtInternal->pModule);
                            
                            // Make sure the virtual states are the same
                            DWORD dwDescAttrs = bmtInternal->pInternalImport->GetMethodDefProps(mdDecl);
                            if(IsMdVirtual(dwMemberAttrs) != IsMdVirtual(dwDescAttrs)) {
                                bmtError->resIDWhy = IDS_CLASSLOAD_MI_VIRTUALMISMATCH;
                                bmtError->dMethodDefInError = bmtMetaData->pMethods[i]; 
                                bmtError->szMethodNameForError = NULL;
                                IfFailRet(COR_E_TYPELOAD);
                            }
                        }
                    }
                    bmtMethodImpl->AddMethod(pNewMD,
                                             desc,
                                             mdDecl);
                }
            }
        }

            // check for proper use of hte Managed and native flags
        if (IsMiManaged(dwImplFlags)) {
            if (IsMiIL(dwImplFlags) || IsMiRuntime(dwImplFlags)) // IsMiOPTIL(dwImplFlags) no longer supported
            {
                // No need to set code address, pre stub used automatically.
            }
            else 
            {
                if (IsMiNative(dwImplFlags))
                {
                    // For now simply disallow managed native code if you turn this on you have to at least 
                    // insure that we have SkipVerificationPermission or equivalent
                    BAD_FORMAT_ASSERT(!"Managed native not presently supported");
                    // if (!IsMDAbstract()) pNewMD->SetAddrofCode((BYTE*) (bmtInternal->pModule)->GetILBase() + pNewMD->GetRVA());
                }
                    // TODO this should really say bad implementation flags
                bmtError->resIDWhy = IDS_CLASSLOAD_BAD_MANAGED_RVA;
                bmtError->dMethodDefInError = bmtMetaData->pMethods[i]; 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }
        }
        else {
            if (IsMiNative(dwImplFlags) && (GetCl() == COR_GLOBAL_PARENT_TOKEN))
            {
                // global function unmanaged entrypoint via IJW thunk was handled
                // above.
            }
            else
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_BAD_UNMANAGED_RVA;
                bmtError->dMethodDefInError = bmtMetaData->pMethods[i]; 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }
            if (Classification != mcNDirect) 
            {
                BAD_FORMAT_ASSERT(!"Bad unmanaged code entry point");
                IfFailRet(COR_E_TYPELOAD);
            }
        }
        
        // Turn off inlining for contextful and marshalbyref classes
        // so that we can intercept calls for remoting.  Also, any calls
        // that are marked in the metadata as not being inlineable.
        if(IsMarshaledByRef() || IsMiNoInlining(dwImplFlags))
        {
            // Contextful classes imply marshal by ref but not vice versa
            _ASSERTE(!IsContextful() || IsMarshaledByRef());
            pNewMD->SetNotInline(true);
        }
    } /* end ... for each member */

    return hr;

}

// InitMethodDesc takes a pointer to space that's already allocated for the
// particular type of MethodDesc, and initializes based on the other info.
// This factors logic between PlaceMembers (the regular code path) & AddMethod 
// (Edit & Continue (EnC) code path) so we don't have to maintain separate copies.
HRESULT EEClass::InitMethodDesc(MethodDesc *pNewMD, // This is should actually be of the correct 
                                            // sub-type, based on Classification
                        DWORD Classification,
                        mdToken tok,
                        DWORD dwImplFlags,  
                        DWORD dwMemberAttrs,
                        BOOL  fEnC,
                        DWORD RVA,          // Only needed for NDirect case
                        BYTE *ilBase,        // Only needed for NDirect case
                        IMDInternalImport *pIMDII,  // Needed for NDirect, EEImpl(Delegate) cases
                        LPCSTR pMethodName // Only needed for mcEEImpl (Delegate) case
#ifdef _DEBUG
                        , LPCUTF8 pszDebugMethodName,
                        LPCUTF8 pszDebugClassName,
                        LPUTF8 pszDebugMethodSignature
#endif //_DEBUG //@todo Is it bad to have a diff sig in debug/retail?
                        )
{
    LOG((LF_CORDB, LL_EVERYTHING, "EEC::IMD: pNewMD:0x%x for tok:0x%x (%s::%s)\n", 
        pNewMD, tok, pszDebugClassName, pszDebugMethodName));

    HRESULT hr = S_OK;

    // Now we know the classification we can allocate the correct type of
    // method desc and perform any classification specific initialization.

    NDirectMethodDesc *pNewNMD;

    switch (Classification & mdcClassification)
    {
    case mcNDirect:
        // Zero init the method desc. Should go away once all the fields are
        // initialized manually.
        if(Classification & mdcMethodImpl) 
            memset(pNewMD, 0, sizeof(MI_NDirectMethodDesc));
        else {
            memset(pNewMD, 0, sizeof(NDirectMethodDesc));
        }

        // NDirect specific initialization.
        pNewNMD = (NDirectMethodDesc*)pNewMD;

        if (RVA != 0 && 
            IsMiUnmanaged(dwImplFlags) && IsMiNative(dwImplFlags) //@todo: why is Banjara emitting a method RVA of 0x1050 for their bjlib.dll P/Invokes? 
                                                                  // Need this clause here to prevent us from treating their P/Invokes as earlybounds.
            )
        {
            pNewNMD->InitSubClassification(pNewNMD->kEarlyBound);

            pNewNMD->InitEarlyBoundNDirectTarget(ilBase, RVA);
        }
        else
        {
            // regular sysimport
            pNewNMD->InitSubClassification(pNewNMD->kLateBound);

            pNewNMD->ndirect.m_pNDirectTarget = (LPVOID) pNewNMD->ndirect.m_ImportThunkGlue;
        }

        pNewNMD->ndirect.m_pMLHeader = 0;
        emitCall( pNewNMD->ndirect.m_ImportThunkGlue, NDirectImportThunk );
        pNewNMD->InitMarshCategory();

        break;

    case mcECall:
    case mcEEImpl:
        // Zero init the method desc. Should go away once all the fields are
        // initialized manually.
        if(Classification & mdcMethodImpl) 
            memset(pNewMD, 0, sizeof(MI_ECallMethodDesc));
        else {
            memset(pNewMD, 0, sizeof(ECallMethodDesc));
        }

        // EEImpl specific initialization.
        if ((Classification & mdcClassification) == mcEEImpl)
        {
            // For the Invoke method we will set a standard invoke method.
            _ASSERTE(IsAnyDelegateClass());

            // For the asserts, either the pointer is NULL (since the class hasn't
            // been constructed yet), or we're in EnC mode, meaning that the class
            // does exist, but we may be re-assigning the field to point to an
            // updated MethodDesc

            // TODO: I am amazed that replacing the invoke method with EnC works.  
            // For example: delegate d of type D(int) points at function f(int).  Now 
            // you change D's invoke method from Invoke(int) to Invoke(int, int)
            // Thus you can now do d.invoke(2,3), but that will try to call a 
            // function f(int)!.  Seems like we have an AV for sure.  
            // Anyway, this and EnC, which we punted for V1.  - Vancem 

            if (strcmp(pMethodName, "Invoke") == 0)
            {
                _ASSERTE(fEnC || NULL == ((DelegateEEClass*)this)->m_pInvokeMethod);
                ((DelegateEEClass*)this)->m_pInvokeMethod = pNewMD;
            }
            else if (strcmp(pMethodName, "BeginInvoke") == 0)
            {
                _ASSERTE(fEnC || NULL == ((DelegateEEClass*)this)->m_pBeginInvokeMethod);
                ((DelegateEEClass*)this)->m_pBeginInvokeMethod = pNewMD;
            }
            else if (strcmp(pMethodName, "EndInvoke") == 0)
            {
                _ASSERTE(fEnC || NULL == ((DelegateEEClass*)this)->m_pEndInvokeMethod);
                ((DelegateEEClass*)this)->m_pEndInvokeMethod = pNewMD;
            }
            else
            {
                hr = E_FAIL;
                return hr;
            }
        } 

        // StoredSig specific intialization
        {
            StoredSigMethodDesc *pNewSMD = (StoredSigMethodDesc*) pNewMD;;
            DWORD cSig;
            PCCOR_SIGNATURE pSig = pIMDII->GetSigOfMethodDef(tok, &cSig);
            pNewSMD->m_pSig = pSig;
            pNewSMD->m_cSig = cSig;
        }

        break;

    case mcIL:
        // Zero init the method desc. Should go away once all the fields are
        // initialized manually.
        if(Classification & mdcMethodImpl) 
            memset(pNewMD, 0, sizeof(MI_MethodDesc));
        else {
            memset(pNewMD, 0, sizeof(MethodDesc));
        }

        break;

    case mcComInterop:
        // Zero init the method desc. Should go away once all the fields are
        // initialized manually.
        if(Classification & mdcMethodImpl) 
            memset(pNewMD, 0, sizeof(MI_ComPlusCallMethodDesc));       
        else
            memset(pNewMD, 0, sizeof(ComPlusCallMethodDesc));       

        break;

    default:
        _ASSERTE(!"Failed to set a method desc classification");
    }

    // Set the method desc's classification.
    pNewMD->SetClassification(Classification & mdcClassification);
    pNewMD->SetMethodImpl((Classification & mdcMethodImpl) ? TRUE : FALSE);
    // pNewMD->SetLivePointerMapIndex(-1);

#ifdef _IA64_

#ifdef _DEBUG
    //
    // assert that the gp of the target is the same as the current gp
    //
    ULONG64 gp = *(((ULONG64*)PreStubWorker)+1);
    _ASSERTE((void*)gp == GetGp());
#endif // _DEBUG
    //
    // @TODO_IA64: make this go through a stub?
    //

    //
    // grab the fn pointer out of the function descriptor
    //
    void*   pActualCode     = *((void**)PreStubWorker);
    emitStubCall(pNewMD, (UINT64)pActualCode);
#else
    emitStubCall(pNewMD, (BYTE*)(ThePreStub()->GetEntryPoint()));
#endif // !_IA64_
    pNewMD->SetMemberDef(tok);

    if (IsMdStatic(dwMemberAttrs))
        pNewMD->SetStatic();

    if (IsMiSynchronized(dwImplFlags))
        pNewMD->SetSynchronized();

    pNewMD->SetRVA(RVA);

#ifdef _DEBUG
    pNewMD->m_pszDebugMethodName = (LPUTF8)pszDebugMethodName;
    pNewMD->m_pszDebugClassName  = (LPUTF8)pszDebugClassName;
    pNewMD->m_pDebugEEClass      = this;
    pNewMD->m_pDebugMethodTable  = GetMethodTable();

    if (pszDebugMethodSignature == NULL)
        pNewMD->m_pszDebugMethodSignature = FormatSig(pNewMD);
    else
        pNewMD->m_pszDebugMethodSignature = pszDebugMethodSignature;
#endif

    return hr;
}

//
// Used by BuildMethodTable
//
// We should have collected all the method impls. Cycle through them creating the method impl
// structure that holds the information about which slots are overridden.
HRESULT EEClass::PlaceMethodImpls(bmtInternalInfo* bmtInternal,
                                  bmtMethodImplInfo* bmtMethodImpl,
                                  bmtErrorInfo* bmtError, 
                                  bmtInterfaceInfo* bmtInterface, 
                                  bmtVtable* bmtVT)

{
    HRESULT hr = S_OK;

    if(bmtMethodImpl->pIndex == 0) 
        return hr;

    DWORD pIndex = 0;
    MethodDesc* next = bmtMethodImpl->GetBodyMethodDesc(pIndex);
    
    // Allocate some temporary storage. The number of overrides for a single method impl
    // cannot be greater then the number of vtable slots. 
    DWORD* slots = (DWORD*) GetThread()->m_MarshalAlloc.Alloc((bmtVT->dwCurrentVtableSlot) * sizeof(DWORD));
    MethodDesc **replaced = (MethodDesc**) GetThread()->m_MarshalAlloc.Alloc((bmtVT->dwCurrentVtableSlot) * sizeof(MethodDesc*));

    while(next != NULL) {
        DWORD slotIndex = 0;
        MethodDesc* body;

        // The signature for the body of the method impl. We cache the signature until all 
        // the method impl's using the same body are done.
        PCCOR_SIGNATURE pBodySignature = NULL;
        DWORD           cBodySignature = 0;
        
        
        // Get the MethodImpl storage
        _ASSERTE(next->IsMethodImpl());
        MethodImpl* pImpl = MethodImpl::GetMethodImplData(next);

        // The impls are sorted according to the method descs for the body of the method impl.
        // Loop through the impls until the next body is found. When a single body
        // has been done move the slots implemented and method descs replaced into the storage
        // found on the body method desc. 
        do { // collect information until we reach the next body  

            body = next;

            // Get the declaration part of the method impl. It will either be a token
            // (declaration is on this type) or a method desc.
            MethodDesc* pDecl = bmtMethodImpl->GetDeclarationMethodDesc(pIndex);
            if(pDecl == NULL) {

                // The declaration is on this type to get the token.
                mdMethodDef mdef = bmtMethodImpl->GetDeclarationToken(pIndex);
                
                hr = PlaceLocalDeclaration(mdef, 
                                           body,
                                           bmtInternal,
                                           bmtError,
                                           bmtVT,
                                           slots,             // Adds override to the slot and replaced arrays.
                                           replaced,
                                           &slotIndex,        // Increments count
                                           &pBodySignature,   // Fills in the signature
                                           &cBodySignature);
                IfFailRet(hr);
            }
            else {
                if(pDecl->GetClass()->IsInterface()) {
                    hr = PlaceInterfaceDeclaration(pDecl,
                                                   body,
                                                   bmtInternal,
                                                   bmtInterface,
                                                   bmtError,
                                                   bmtVT,
                                                   slots,
                                                   replaced,
                                                   &slotIndex,        // Increments count
                                                   &pBodySignature,   // Fills in the signature
                                                   &cBodySignature);
                    IfFailRet(hr);
                }
                else {
                    hr = PlaceParentDeclaration(pDecl,                                                body,
                                                bmtInternal,
                                                bmtError,
                                                bmtVT,
                                                slots,
                                                replaced,
                                                &slotIndex,        // Increments count
                                                &pBodySignature,   // Fills in the signature
                                                &cBodySignature);
                    IfFailRet(hr);
                }                   
            }

            pIndex++;
            // we hit the end of the list so leave
            if(pIndex == bmtMethodImpl->pIndex) 
                next = NULL;
            else
                next = bmtMethodImpl->GetBodyMethodDesc(pIndex);
        
        } while(next == body) ;

        // Use the number of overrides to 
        // push information on to the method desc. We store the slots that
        // are overridden and the method desc that is replaced. That way
        // when derived classes need to determine if the method is to be
        // overridden then it can check the name against the replaced
        // method desc not the bodies name.
        if(slotIndex == 0) {
            bmtError->resIDWhy = IDS_CLASSLOAD_MI_DECLARATIONNOTFOUND;
            bmtError->dMethodDefInError = body->GetMemberDef(); 
            bmtError->szMethodNameForError = NULL;
            IfFailRet(COR_E_TYPELOAD);
        }
        else {
            hr = pImpl->SetSize(GetClassLoader()->GetHighFrequencyHeap(), slotIndex);
            IfFailRet(hr);

            // Gasp we do a bubble sort. Should change this to a qsort..
            for (DWORD i = 0; i < slotIndex; i++) {
                for (DWORD j = i+1; j < slotIndex; j++)
                {
                    if (slots[j] < slots[i])
                    {
                        MethodDesc* mTmp = replaced[i];
                        replaced[i] = replaced[j];
                        replaced[j] = mTmp;

                        DWORD sTmp = slots[i];
                        slots[i] = slots[j];
                        slots[j] = sTmp;
                    }
                }
            }

            // Go and set the method impl
            hr = pImpl->SetData(slots, replaced);
        }
    }  // while(next != NULL) 
    
    return hr;
}

HRESULT EEClass::PlaceLocalDeclaration(mdMethodDef      mdef,
                                       MethodDesc*      body,
                                       bmtInternalInfo* bmtInternal,
                                       bmtErrorInfo*    bmtError, 
                                       bmtVtable*       bmtVT,
                                       DWORD*           slots,
                                       MethodDesc**     replaced,
                                       DWORD*           pSlotIndex,
                                       PCCOR_SIGNATURE* ppBodySignature,
                                       DWORD*           pcBodySignature)
{
    HRESULT hr = S_OK;

    BOOL fVerifySignature = TRUE; // we only need to verify the signature once.
    
    // we search on the token and m_cl
    for(USHORT i = 0; i < bmtVT->dwCurrentVtableSlot; i++) {
        
        // We get the current slot.  Since we are looking for a method declaration 
        // that is on our class we would never match up with a method obtained from 
        // one of our parents or an Interface. 
        MethodDesc* pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[i]);

        // This entry may have been replaced in a base class so get the original
        // method desc for this location
        MethodDesc* pRealDesc;
        GetRealMethodImpl(pMD, i, &pRealDesc);
        
        // If we get a null then we have already replaced this one. We can't check it
        // so we will just by by-pass this. 
        if(pRealDesc->GetMemberDef() == mdef)  
        {
            
            // Make sure we have not overridding another method impl
            if(pMD != body && pMD->IsMethodImpl() && pMD->GetMethodTable() == NULL) {
                bmtError->resIDWhy = IDS_CLASSLOAD_MI_MULTIPLEOVERRIDES;
                bmtError->dMethodDefInError = pMD->GetMemberDef(); 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }
            
            // We are not allowed to implement another method impl
            if(pRealDesc->IsMethodImpl()) {
                bmtError->resIDWhy = IDS_CLASSLOAD_MI_OVERRIDEIMPL;
                bmtError->dMethodDefInError = pMD->GetMemberDef(); 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }


            // Compare the signature for the token in the specified scope
            if(fVerifySignature) {
                // If we have not got the method impl signature go get it now
                if(*ppBodySignature == NULL) {
                    *ppBodySignature = 
                        bmtInternal->pInternalImport->GetSigOfMethodDef(body->GetMemberDef(),
                                                                        pcBodySignature);
                }
                
                PCCOR_SIGNATURE pMethodDefSignature = NULL;
                DWORD           cMethodDefSignature = 0;
                pMethodDefSignature = 
                    bmtInternal->pInternalImport->GetSigOfMethodDef(mdef,
                                                                    &cMethodDefSignature);
                
                // If they do not match then we are trying to implement
                // a method with a body where the signatures do not match
                if(!MetaSig::CompareMethodSigs(*ppBodySignature,
                                               *pcBodySignature,
                                               bmtInternal->pModule,
                                               pMethodDefSignature,
                                               cMethodDefSignature,
                                               bmtInternal->pModule))
                {
                    bmtError->resIDWhy = IDS_CLASSLOAD_MI_BADSIGNATURE;
                    bmtError->dMethodDefInError = mdef; 
                    bmtError->szMethodNameForError = NULL;
                    IfFailRet(COR_E_TYPELOAD);
                }
                
                fVerifySignature = FALSE;
            }
            
            
            // If the body has not been placed then place it here. We do not
            // place bodies for method impl's until we find a spot for them.
            if(body->GetSlot() == (USHORT) -1) {
                body->SetSlot(i);
            }
            
            // We implement this slot, record it
            slots[*pSlotIndex] = i;
            replaced[*pSlotIndex] = pRealDesc;
            bmtVT->pVtable[i] = (SLOT) body->GetPreStubAddr();
            
            // increment the counter 
            (*pSlotIndex)++;
        }
        // Reset the hr from the GetRealMethodImpl()
        hr = S_OK;
    }

    return hr;
}

HRESULT EEClass::PlaceInterfaceDeclaration(MethodDesc*       pDecl,
                                           MethodDesc*       pImplBody,
                                           bmtInternalInfo*  bmtInternal,
                                           bmtInterfaceInfo* bmtInterface, 
                                           bmtErrorInfo*     bmtError, 
                                           bmtVtable*        bmtVT,
                                           DWORD*            slots,
                                           MethodDesc**      replaced,
                                           DWORD*            pSlotIndex,
                                           PCCOR_SIGNATURE*  ppBodySignature,
                                           DWORD*            pcBodySignature)
{
    HRESULT hr = S_OK;
    // the fact that an interface only shows up once in the vtable
    // When we are looking for a method desc then the declaration is on
    // some class or interface that this class implements. The declaration
    // will either be to an interface or to a class. If it is to a
    // interface then we need to search for that interface. From that
    // slot number of the method in the interface we can calculate the offset 
    // into our vtable. If it is to a class it must be a subclass. This uses
    // the fact that an interface only shows up once in the vtable.
    
    EEClass* declClass = pDecl->GetClass();
    

    BOOL fInterfaceFound = FALSE;
    // Check our vtable for entries that we are suppose to override. 
    // Since this is an external method we must also check the inteface map.
    // We want to replace any interface methods even if they have been replaced
    // by a base class. 
    for(USHORT i = 0; i < m_wNumInterfaces; i++) 
    {
        MethodTable* pMT;
        EEClass *   pInterface;
        
        pMT = bmtInterface->pInterfaceMap[i].m_pMethodTable;
        pInterface = pMT->GetClass();
        
        // If this is the same interface
        if(pInterface == declClass) 
        {

            // We found an interface so no error
            fInterfaceFound = TRUE;

            // Find out where the interface map is set on our vtable
            USHORT dwStartingSlot = (USHORT) bmtInterface->pInterfaceMap[i].m_wStartSlot;

            // We need to duplicate the interface to avoid copies. Currently, interfaces
            // do not overlap so we just need to check to see if there is a non-duplicated
            // MD. If there is then the interface shares it with the class which means
            // we need to copy the whole interface
            WORD wSlot;
            for(wSlot = dwStartingSlot; wSlot < pInterface->GetNumVtableSlots()+dwStartingSlot; wSlot++) {
                MethodDesc* pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[wSlot]);
                if(pMD->GetSlot() == wSlot)
                    break;
            }
            
            if(wSlot < pInterface->GetNumVtableSlots()+dwStartingSlot) {

                // Check to see if we have allocated the temporay array of starting values.
                // This array is used to backpatch entries to the original location. These 
                // values are never used but will cause problems later when we finish 
                // laying out the method table.
                if(bmtInterface->pdwOriginalStart == NULL) {
                    Thread *pThread = GetThread();
                    _ASSERTE(pThread != NULL && "We could never have gotten this far without GetThread() returning a thread");
                    bmtInterface->pdwOriginalStart = (DWORD*) pThread->m_MarshalAlloc.Alloc(sizeof(DWORD) * bmtInterface->dwMaxExpandedInterfaces);
                    memset(bmtInterface->pdwOriginalStart, 0, sizeof(DWORD)*bmtInterface->dwMaxExpandedInterfaces);
                }
                    
                _ASSERTE(bmtInterface->pInterfaceMap[i].m_wStartSlot != (WORD) 0 && "We assume that an interface does not start at position 0");
                _ASSERTE(bmtInterface->pdwOriginalStart[i] == 0 && "We should not move an interface twice"); 
                bmtInterface->pdwOriginalStart[i] = bmtInterface->pInterfaceMap[i].m_wStartSlot;

                // The interface now starts at the end of the map.
                bmtInterface->pInterfaceMap[i].m_wStartSlot = (WORD) bmtVT->dwCurrentVtableSlot;
                for(WORD d = dwStartingSlot; d < pInterface->GetNumVtableSlots()+dwStartingSlot; d++) {
                    // Copy the MD
                    MethodDesc* pMDCopy = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[d]);
                    bmtVT->pVtable[bmtVT->dwCurrentVtableSlot++] = (SLOT) pMDCopy->GetPreStubAddr();
#ifdef _DEBUG
                    g_dupMethods++;
#endif              
                    pMDCopy->SetDuplicate();
                    IncrementNumVtableSlots();
                }

                // Reset the starting slot to the known value
                dwStartingSlot = (USHORT) bmtInterface->pInterfaceMap[i].m_wStartSlot;
            }
                
            // We found an interface so no error
            fInterfaceFound = TRUE;

            
            // Make sure we have placed the interface map.
            _ASSERTE(dwStartingSlot != -1); 
            
            // Get the Slot location of the method desc.
            USHORT dwMySlot = pDecl->GetSlot() + dwStartingSlot;
            _ASSERTE(dwMySlot < bmtVT->dwCurrentVtableSlot);
            
            // Get our current method desc for this slot
            MethodDesc* pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[dwMySlot]);
            
#if 0   //@todo CTS : need to check for multiple methodimpls to the same methoddef scenario
            // Make sure we are not overridding another method impl
            if(pMD != pImplBody && pMD->IsMethodImpl() && pMD->GetMethodTable() == NULL) {
                 bmtError->resIDWhy = IDS_CLASSLOAD_MI_MULTIPLEOVERRIDES;
                 bmtError->dMethodDefInError = pMD->GetMemberDef(); 
                 bmtError->szMethodNameForError = NULL;
                 IfFailRet(COR_E_TYPELOAD);
             }
#endif
            
            // Get the real method desc. This method may have been overridden
            // by another method impl higher up the class heir.
            MethodDesc* pRealDesc;
            pInterface->GetRealMethodImpl(pDecl, dwMySlot, &pRealDesc);
            
            // Make sure we have not overriden this entry
            if(pRealDesc->IsMethodImpl()) {
                 bmtError->resIDWhy = IDS_CLASSLOAD_MI_OVERRIDEIMPL;
                 bmtError->dMethodDefInError = pMD->GetMemberDef(); 
                 bmtError->szMethodNameForError = NULL;
                 IfFailRet(COR_E_TYPELOAD);
            }
            
            // If we have not got the method impl signature go get it now. It is cached
            // in our caller
            if(*ppBodySignature == NULL) {
                *ppBodySignature = 
                    bmtInternal->pInternalImport->GetSigOfMethodDef(pImplBody->GetMemberDef(),
                                                                    pcBodySignature);
            }
            
            // Verify the signatures match
            PCCOR_SIGNATURE pDeclarationSignature = NULL;
            DWORD           cDeclarationSignature = 0;
            
            pRealDesc->GetSig(&pDeclarationSignature,
                              &cDeclarationSignature);
            
            // If they do not match then we are trying to implement
            // a method with a body where the signatures do not match
            if(!MetaSig::CompareMethodSigs(*ppBodySignature,
                                           *pcBodySignature,
                                           bmtInternal->pModule,
                                           pDeclarationSignature,
                                           cDeclarationSignature,
                                           pRealDesc->GetModule()))
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_MI_BADSIGNATURE;
                bmtError->dMethodDefInError = pImplBody->GetMemberDef(); 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }
            
            // If the body has not been placed then place it now.
            if(pImplBody->GetSlot() == (USHORT) -1) {
                pImplBody->SetSlot(dwMySlot);
            }
            
            // Store away the values
            slots[*pSlotIndex] = dwMySlot;
            replaced[*pSlotIndex] = pRealDesc;
            bmtVT->pVtable[dwMySlot] = (SLOT) pImplBody->GetPreStubAddr();
            
            // We are now a duplicate in an interface
            pImplBody->SetDuplicate();

            // increment the counter 
            (*pSlotIndex)++;

            // if we have moved the interface we need to back patch the original location
            // if we had left an interface place holder.
            if(bmtInterface->pdwOriginalStart && bmtInterface->pdwOriginalStart[i] != 0) {
                USHORT slot = (USHORT) bmtInterface->pdwOriginalStart[i] + pDecl->GetSlot();
                MethodDesc* pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[slot]);
                if(pMD->GetMethodTable() && pMD->IsInterface())
                    bmtVT->pVtable[slot] = (SLOT) pImplBody->GetPreStubAddr();
            }
            break;
        }
    }

    if(fInterfaceFound == FALSE)
    {
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_NOTIMPLEMENTED;
        bmtError->dMethodDefInError = NULL; 
        bmtError->szMethodNameForError = pDecl->GetName();
        IfFailRet(COR_E_TYPELOAD);
    }
    
    return hr;
}

HRESULT EEClass::PlaceParentDeclaration(MethodDesc*       pDecl,
                                        MethodDesc*       pImplBody,
                                        bmtInternalInfo*  bmtInternal,
                                        bmtErrorInfo*     bmtError, 
                                        bmtVtable*        bmtVT,
                                        DWORD*            slots,
                                        MethodDesc**      replaced,
                                        DWORD*            pSlotIndex,
                                        PCCOR_SIGNATURE*  ppBodySignature,
                                        DWORD*            pcBodySignature)
{
    HRESULT hr = S_OK;

    BOOL fVerifySignature = TRUE; // we only need to verify the signature once.
    
    // Verify that the class of the declaration is in our heirarchy
    EEClass* declType = pDecl->GetClass();
    EEClass* pParent = GetParentClass();
    while(pParent != NULL) {
        if(declType == pParent) 
            break;
        pParent = pParent->GetParentClass();
    }
    if(pParent == NULL) {
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_NOTIMPLEMENTED;
        bmtError->dMethodDefInError = NULL; 
        bmtError->szMethodNameForError = pDecl->GetName();
        IfFailRet(COR_E_TYPELOAD);
    }
    
    // Compare the signature for the token in the specified scope
    // If we have not got the method impl signature go get it now
    if(*ppBodySignature == NULL) {
        *ppBodySignature = 
            bmtInternal->pInternalImport->GetSigOfMethodDef(pImplBody->GetMemberDef(),
                                                            pcBodySignature);
    }
    
    PCCOR_SIGNATURE pDeclarationSignature = NULL;
    DWORD           cDeclarationSignature = 0;
    pDecl->GetSig(&pDeclarationSignature,
                  &cDeclarationSignature);
    
    // If they do not match then we are trying to implement
    // a method with a body where the signatures do not match
    if(!MetaSig::CompareMethodSigs(*ppBodySignature,
                                   *pcBodySignature,
                                   bmtInternal->pModule,
                                   pDeclarationSignature,
                                   cDeclarationSignature,
                                   pDecl->GetModule()))
    {
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_BADSIGNATURE;
        bmtError->dMethodDefInError = pImplBody->GetMemberDef(); 
        bmtError->szMethodNameForError = NULL;
        IfFailRet(COR_E_TYPELOAD);
    }
    
    // We get the method from the parents slot. We will replace the method that is currently
    // defined in that slot and any duplicates for that method desc. 
    USHORT dwSlot = pDecl->GetSlot();
    MethodDesc* pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[dwSlot]);
    
    // Make sure we are not overridding another method impl
    if(pMD != pImplBody && pMD->IsMethodImpl() && pMD->GetMethodTable() == NULL)
    {
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_MULTIPLEOVERRIDES;
        bmtError->dMethodDefInError = pMD->GetMemberDef(); 
        bmtError->szMethodNameForError = NULL;
        IfFailRet(COR_E_TYPELOAD);
    }
            
    // Get the real method desc (a base class may have overridden the method
    // with a method impl)
    MethodDesc* pReplaceDesc;
    GetRealMethodImpl(pMD, dwSlot, &pReplaceDesc);

    // Make sure we have not overriden this entry if it was declared within our own
    // class. It is perfectly legitimate to override an inherited method.
    if(pReplaceDesc->IsMethodImpl() && pReplaceDesc->GetMethodTable() == NULL)
    {
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_OVERRIDEIMPL;
        bmtError->dMethodDefInError = pMD->GetMemberDef(); 
        bmtError->szMethodNameForError = NULL;
        IfFailRet(COR_E_TYPELOAD);
    }

    DWORD dwAttr = pReplaceDesc->GetAttrs();
    if(IsMdFinal(dwAttr))
    {
        //_ASSERTE(!"MethodImpl Decl may have been overridden by a final method");
        bmtError->resIDWhy = IDS_CLASSLOAD_MI_FINAL_DECL;                        
        bmtError->dMethodDefInError = pReplaceDesc->GetMemberDef();
        bmtError->szMethodNameForError = NULL;
        IfFailRet(COR_E_TYPELOAD);
    }
    
    // If the body has not been placed then place it here
    if(pImplBody->GetSlot() == (USHORT) -1)
        pImplBody->SetSlot(dwSlot);

    slots[*pSlotIndex] = dwSlot;
    replaced[*pSlotIndex] = pReplaceDesc;
    bmtVT->pVtable[dwSlot] = (SLOT) pImplBody->GetPreStubAddr();
    
    // increment the counter 
    (*pSlotIndex)++;
    
    // we search for all duplicates
    for(USHORT i = dwSlot+1; i < bmtVT->dwCurrentVtableSlot; i++)
    {
        pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[i]);

        MethodDesc* pRealDesc;
        hr = GetRealMethodImpl(pMD, i, &pRealDesc);

        if(pRealDesc == pReplaceDesc) 
        {
            // We do not want to override a body to another method impl
            if(pRealDesc->IsMethodImpl())
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_MI_OVERRIDEIMPL;
                bmtError->dMethodDefInError = pMD->GetMemberDef(); 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }

            // Make sure we are not overridding another method impl
            if(pMD != pImplBody && pMD->IsMethodImpl() && pMD->GetMethodTable() == NULL)
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_MI_MULTIPLEOVERRIDES;
                bmtError->dMethodDefInError = pMD->GetMemberDef(); 
                bmtError->szMethodNameForError = NULL;
                IfFailRet(COR_E_TYPELOAD);
            }
        
            slots[*pSlotIndex] = i;
            replaced[*pSlotIndex] = pRealDesc;
            bmtVT->pVtable[i] = (SLOT) pImplBody->GetPreStubAddr();

            // increment the counter 
            (*pSlotIndex)++;
        }

        // Clean up possible S_FALSE from GetRealMethodImpl
        hr = S_OK;
    }

    return hr;
}

HRESULT EEClass::GetRealMethodImpl(MethodDesc* pMD,
                                   DWORD dwVtableSlot,
                                   MethodDesc** ppResult)
{
    _ASSERTE(ppResult);
    if(pMD->IsMethodImpl()) {
        // If we are overriding ourselves then something is 
        // really messed up.

        MethodImpl* data = MethodImpl::GetMethodImplData(pMD);
        _ASSERTE(data && "This method should be a method impl");

        // Get the real method desc that was already overridden 
        *ppResult = data->FindMethodDesc(dwVtableSlot, pMD);
        return S_FALSE;
    }
    else {
        *ppResult = pMD;
        return S_OK;
    }
}

//
// Used by BuildMethodTable
//
// If we're a value class, we want to create duplicate slots and MethodDescs for all methods in the vtable
// section (i.e. not privates or statics).
//

HRESULT EEClass::DuplicateValueClassSlots(bmtMetaDataInfo* bmtMetaData, bmtMethAndFieldDescs* bmtMFDescs, bmtInternalInfo* bmtInternal, bmtVtable* bmtVT)
{
    HRESULT hr = S_OK;
    DWORD i;

    
    // If we're a value class, we want to create duplicate slots and MethodDescs for all methods in the vtable
    // section (i.e. not privates or statics).

    // TODO: we duplicate every instance method.  The Vtable is really not used (except for inherited and
    // interface part), so we could shrink the table substantially.
    if (IsValueClass())
    {
        for (i = 0; i < bmtMetaData->cMethods; i++)
        {
            MethodDesc *pMD;
            MethodDesc *pNewMD;
            DWORD       dwAttrs;
            DWORD       Classification;


            pMD = bmtMFDescs->ppMethodDescList[i];
            if (pMD == NULL)
                continue;

            dwAttrs = bmtMetaData->pMethodAttrs[i];
            Classification = bmtMetaData->pMethodClassifications[i];
            DWORD type = bmtMetaData->pMethodType[i];
            DWORD impl = bmtMetaData->pMethodImpl[i];

            if (IsMdStatic(dwAttrs) ||
                !IsMdVirtual(dwAttrs) ||
                IsMdRTSpecialName(dwAttrs))
                continue;
            
            bmtTokenRangeNode *pTR = GetTokenRange(bmtMetaData->pMethods[i], 
                                                   &(bmtMetaData->ranges[type][impl]));
            _ASSERTE(pTR->cMethods != 0);;

            bmtMethodDescSet *set = &bmtMFDescs->sets[type][impl];

            pNewMD = set->pChunkList[pTR->dwCurrentChunk]->GetMethodDescAt(pTR->dwCurrentIndex);
            
            memcpy(pNewMD, pMD, 
                   set->pChunkList[pTR->dwCurrentChunk]->GetMethodDescSize() 
                   - METHOD_PREPAD);

            pNewMD->SetChunkIndex(pTR->dwCurrentIndex, Classification);
            pNewMD->SetMemberDef(pMD->GetMemberDef());

                    // Update counters to prepare for next method desc allocation.
            pTR->dwCurrentIndex++;
            if (pTR->dwCurrentIndex == MethodDescChunk::GetMaxMethodDescs(Classification))
            {
                pTR->dwCurrentChunk++;
                pTR->dwCurrentIndex = 0;
            }

            bmtMFDescs->ppUnboxMethodDescList[i] = pNewMD;

            pNewMD->m_wSlotNumber = (WORD) bmtVT->dwCurrentNonVtableSlot;

            emitStubCall(pNewMD, (BYTE*)(ThePreStub()->GetEntryPoint()));

            // Indicate that this method takes a BOXed this pointer.
            pMD->SetRVA(METHOD_MAX_RVA);

            bmtVT->pNonVtable[ bmtVT->dwCurrentNonVtableSlot ] = (SLOT) pNewMD; // not pre-stub addr, refer to statics above
            bmtVT->dwCurrentNonVtableSlot++;
        }
    }


    return hr;
}

//
// Used by BuildMethodTable
//
//
// If we are a class, then there may be some unplaced vtable methods (which are by definition
// interface methods, otherwise they'd already have been placed).  Place as many unplaced methods
// as possible, in the order preferred by interfaces.  However, do not allow any duplicates - once
// a method has been placed, it cannot be placed again - if we are unable to neatly place an interface,
// create duplicate slots for it starting at dwCurrentDuplicateVtableSlot.  Fill out the interface
// map for all interfaces as they are placed.
//
// If we are an interface, then all methods are already placed.  Fill out the interface map for
// interfaces as they are placed.
//

HRESULT EEClass::PlaceVtableMethods(bmtInterfaceInfo* bmtInterface, 
                                    bmtVtable* bmtVT, 
                                    bmtMetaDataInfo* bmtMetaData, 
                                    bmtInternalInfo* bmtInternal, 
                                    bmtErrorInfo* bmtError, 
                                    bmtProperties* bmtProp, 
                                    bmtMethAndFieldDescs* bmtMFDescs)
{
    HRESULT hr = S_OK;
    DWORD i;
    BOOL fParentInterface;

    for (bmtInterface->dwCurInterface = 0; 
         bmtInterface->dwCurInterface < m_wNumInterfaces; 
         bmtInterface->dwCurInterface++)
    {
        MethodTable* pMT;
        EEClass *   pInterface;
        DWORD       dwCurInterfaceMethod;

        fParentInterface = FALSE;
        // The interface we are attempting to place
        pMT = bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_pMethodTable;
        pInterface = pMT->GetClass();

        if((bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wFlags & 
            InterfaceInfo_t::interface_declared_on_class) &&
           !pInterface->IsExternallyVisible() &&
           pInterface->GetAssembly() != bmtInternal->pModule->GetAssembly())
        {
            if (!Security::CanSkipVerification(GetAssembly())) {
                bmtError->resIDWhy = IDS_CLASSLOAD_GENERIC;
                IfFailRet(COR_E_TYPELOAD);
            }
        }


        // Did we place this interface already due to the parent class's interface placement?
        if (bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wStartSlot != (WORD) -1) {
            // If we have declared it then we re-lay it out
            if(bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wFlags & 
               InterfaceInfo_t::interface_declared_on_class) 
            {
                fParentInterface = TRUE;
                // If the interface has a folded method from a base class we need to unfold the
                // interface
                WORD wSlot = bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wStartSlot;
                for(WORD j = 0; j < pInterface->GetNumVtableSlots(); j++) {
                    MethodDesc* pMD = GetUnknownMethodDescForSlotAddress(bmtVT->pVtable[j+wSlot]);
                    if(pMD->GetSlot() == j+wSlot) {
                        bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wStartSlot = (WORD) -1;
                        fParentInterface = FALSE;
                        break;
                    }
                }
            }
            else
                continue;
        }

        if (pInterface->GetNumVtableSlots() == 0)
        {
            // no calls can be made to this interface anyway
            // so initialize the slot number to 0
            bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wStartSlot = (WORD) 0;
            continue;
        }


        // If this interface has not been given a starting position do that now.
        if(!fParentInterface) 
            bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wStartSlot = (WORD) bmtVT->dwCurrentVtableSlot;

        // For each method declared in this interface
        for (dwCurInterfaceMethod = 0; dwCurInterfaceMethod < pInterface->GetNumVtableSlots(); dwCurInterfaceMethod++)
        {
            DWORD       dwMemberAttrs;

            // See if we have info gathered while placing members
            if (bmtInterface->pppInterfaceImplementingMD[bmtInterface->dwCurInterface] && bmtInterface->pppInterfaceImplementingMD[bmtInterface->dwCurInterface][dwCurInterfaceMethod] != NULL)
            {
                bmtInterface->ppInterfaceMethodDescList[dwCurInterfaceMethod] = bmtInterface->pppInterfaceImplementingMD[bmtInterface->dwCurInterface][dwCurInterfaceMethod];
                continue;
            }

            MethodDesc *pInterfaceMD            =  pMT->GetClass()->GetMethodDescForSlot(dwCurInterfaceMethod);
            _ASSERTE(pInterfaceMD  != NULL);

            LPCUTF8     pszInterfaceMethodName  = pInterfaceMD->GetNameOnNonArrayClass();
            PCCOR_SIGNATURE pInterfaceMethodSig;
            DWORD       cInterfaceMethodSig;

            pInterfaceMD->GetSig(&pInterfaceMethodSig, &cInterfaceMethodSig);

            // Try to find the method explicitly declared in our class
            for (i = 0; i < bmtMetaData->cMethods; i++)
            {
                // look for interface method candidates only
                dwMemberAttrs = bmtMetaData->pMethodAttrs[i];
                
                if (IsMdVirtual(dwMemberAttrs) && IsMdPublic(dwMemberAttrs))
                {
                    LPCUTF8     pszMemberName;

                    pszMemberName = bmtMetaData->pstrMethodName[i];

#ifdef _DEBUG
                    if(m_fDebuggingClass && g_pConfig->ShouldBreakOnMethod(pszMemberName))
                        _ASSERTE(!"BreakOnMethodName");
#endif
                    if (pszMemberName == NULL)
                    {
                        IfFailRet(COR_E_TYPELOAD);
                    }

                    if (strcmp(pszMemberName,pszInterfaceMethodName) == 0)
                    {
                        PCCOR_SIGNATURE pMemberSignature;
                        DWORD       cMemberSignature;

                        _ASSERTE(TypeFromToken(bmtMetaData->pMethods[i]) == mdtMethodDef);
                        pMemberSignature = bmtInternal->pInternalImport->GetSigOfMethodDef(
                            bmtMetaData->pMethods[i],
                            &cMemberSignature
                        );

                        if (MetaSig::CompareMethodSigs(
                            pMemberSignature,
                            cMemberSignature,
                            bmtInternal->pModule,
                            pInterfaceMethodSig,
                            cInterfaceMethodSig,
                            pInterfaceMD->GetModule()))
                        {
                            break;
                        }
                    }
                }
            } // end ... try to find method

            _ASSERTE(dwCurInterfaceMethod < bmtInterface->dwLargestInterfaceSize);

            DWORD dwHashName         = HashStringA(pszInterfaceMethodName);

            if (i >= bmtMetaData->cMethods)
            {
                // if this interface has been layed out by our parent then
                // we do not need to define a new method desc for it
                if(fParentInterface) 
                {
                    bmtInterface->ppInterfaceMethodDescList[dwCurInterfaceMethod] = NULL;
                }
                else 
                {
                    // We will use the interface implemenation if we do not find one in the 
                    // parent. It will have to be overriden by the a method impl unless the 
                    // class is abstract or it is a special COM type class.
                    
                    MethodDesc* pParentMD = NULL;
                    if(GetParentClass()) 
                    {
                        // Check the parent class
                        if (CouldMethodExistInClass(GetParentClass(), pszInterfaceMethodName, dwHashName)) {
#ifdef _DEBUG
                            if(m_fDebuggingClass && g_pConfig->ShouldBreakOnMethod(pszInterfaceMethodName))
                                _ASSERTE(!"BreakOnMethodName");
#endif

                            pParentMD = 
                                GetParentClass()->FindMethod(pszInterfaceMethodName,
                                                           pInterfaceMethodSig,
                                                           cInterfaceMethodSig,
                                                             pInterfaceMD->GetModule(),
                                                             mdPublic | mdVirtual);
                        }
                    }
                    // make sure we do a better back patching for these methods
                    if(pParentMD) {
                        //_ASSERTE(IsMdVirtual(pParentMD->GetAttrs()));
                        bmtInterface->ppInterfaceMethodDescList[dwCurInterfaceMethod] = pParentMD;
                    }
                    else {
                        bmtInterface->ppInterfaceMethodDescList[dwCurInterfaceMethod] = pInterfaceMD;
                        // Hash that a method with this name exists in this class
                        // Note that ctors and static ctors are not added to the table
                        DWORD dwHashName = HashStringA(pInterfaceMD->GetNameOnNonArrayClass());
                        DWORD dwMethodHashBit = dwHashName % METHOD_HASH_BITS;
                        m_MethodHash[dwMethodHashBit >> 3] |= (1 << (dwMethodHashBit & 7));
                    }
                }
            }
            else
            {
                // Found as declared method in class. If the interface was layed out by the parent we 
                // will be overridding their slot so our method counts do not increase. We will fold
                // our method into our parent's interface if we have not been placed.
                if(fParentInterface) 
                {
                    WORD dwSlot = (WORD) (bmtInterface->pInterfaceMap[bmtInterface->dwCurInterface].m_wStartSlot + dwCurInterfaceMethod);
                    _ASSERTE(bmtVT->dwCurrentVtableSlot > dwSlot);
                    MethodDesc *pMD = bmtMFDescs->ppMethodDescList[i];
                    _ASSERTE(pMD && "Missing MethodDesc for declared method in class.");
                    if(pMD->m_wSlotNumber == (WORD) -1)
                    {
                        pMD->m_wSlotNumber = dwSlot;
                    }
                    else 
                    {
                        pMD->SetDuplicate();
#ifdef _DEBUG
                        g_dupMethods++;
#endif
                    }
                    
                    bmtVT->pVtable[dwSlot] = (SLOT) pMD->GetPreStubAddr();
                    _ASSERTE( bmtVT->pVtable[dwSlot] != NULL);
                    bmtInterface->ppInterfaceMethodDescList[dwCurInterfaceMethod] = NULL;
                }
                else {
                    bmtInterface->ppInterfaceMethodDescList[dwCurInterfaceMethod] = (MethodDesc*)(bmtMFDescs->ppMethodDescList[i]);
                }
            }
        }

        for (i = 0; i < pInterface->GetNumVtableSlots(); i++)
        {
            // The entry can be null if the interface was previously
            // laid out by a parent and we did not have a method
            // that subclassed the interface.
            if(bmtInterface->ppInterfaceMethodDescList[i] != NULL) 
            {
                // Get the MethodDesc which was allocated for the method
                MethodDesc *pMD;
                
                pMD = bmtInterface->ppInterfaceMethodDescList[i];
                
                if (pMD->m_wSlotNumber == (WORD) -1)
                {
                    pMD->m_wSlotNumber = (WORD) bmtVT->dwCurrentVtableSlot;
                }
                else
                {
                    // duplicate method, mark the method as so
                    pMD->SetDuplicate();
#ifdef _DEBUG
                    g_dupMethods++;
#endif
                }
                
                _ASSERTE( bmtVT->pVtable[ bmtVT->dwCurrentVtableSlot ] == NULL);
                
                bmtVT->pVtable[bmtVT->dwCurrentVtableSlot++] = (SLOT) pMD->GetPreStubAddr();
                _ASSERTE( bmtVT->pVtable[(bmtVT->dwCurrentVtableSlot - 1)] != NULL);
                IncrementNumVtableSlots();
            }
        }
    }

    return hr;
}


//
// Used by BuildMethodTable
//
// Place static fields
//

HRESULT EEClass::PlaceStaticFields(bmtVtable* bmtVT, bmtFieldPlacement* bmtFP, bmtEnumMethAndFields* bmtEnumMF)
{
    HRESULT hr = S_OK;
    DWORD i;

     //===============================================================
    // BEGIN: Place static fields
    //===============================================================

    BOOL shared = IsShared();

    DWORD   dwCumulativeStaticFieldPos;
    // If stored in the method table, static fields start after the end of the vtable
    if (shared)
        dwCumulativeStaticFieldPos = 0;
    else
        dwCumulativeStaticFieldPos = bmtVT->dwCurrentNonVtableSlot*sizeof(SLOT);

    //
    // Place gc refs and value types first, as they need to have handles created for them.
    // (Placing them together allows us to easily create the handles when Restoring the class, 
    // and when initializing new DLS for the class.)
    //

    DWORD   dwCumulativeStaticGCFieldPos;
    dwCumulativeStaticGCFieldPos = dwCumulativeStaticFieldPos;
    dwCumulativeStaticFieldPos += bmtFP->NumStaticGCPointerFields << LOG2PTR;
    bmtFP->NumStaticFieldsOfSize[LOG2PTR] -= bmtFP->NumStaticGCPointerFields;

    // @todo: pad to alignment, if we other fields which are > ptr size.

    // Place fields, largest first
    for (i = MAX_LOG2_PRIMITIVE_FIELD_SIZE; (signed long) i >= 0; i--)
    {
        DWORD dwFieldSize = (1 << i);

        // Fields of this size start at the next available location
        bmtFP->StaticFieldStart[i] = dwCumulativeStaticFieldPos;
        dwCumulativeStaticFieldPos += (bmtFP->NumStaticFieldsOfSize[i] << i);

        // Reset counters for the loop after this one
        bmtFP->NumStaticFieldsOfSize[i]    = 0;
    }

    if (dwCumulativeStaticFieldPos > FIELD_OFFSET_LAST_REAL_OFFSET) 
        IfFailRet(COR_E_TYPELOAD);

    m_wNumHandleStatics = 0;

    // Place static fields
    for (i = 0; i < bmtEnumMF->dwNumStaticFields; i++)
    {
        DWORD dwIndex       = bmtEnumMF->dwNumInstanceFields+i; // index in the FieldDesc list
        DWORD dwFieldSize   = (DWORD)(size_t)m_pFieldDescList[dwIndex].m_pMTOfEnclosingClass; // log2(field size)
        DWORD dwOffset      = (DWORD) m_pFieldDescList[dwIndex].m_dwOffset; // offset or type of field
            
        switch (dwOffset)
        {
        case FIELD_OFFSET_UNPLACED_GC_PTR:
        case FIELD_OFFSET_VALUE_CLASS:
            m_pFieldDescList[dwIndex].SetOffset(dwCumulativeStaticGCFieldPos);
            dwCumulativeStaticGCFieldPos += 1<<LOG2PTR; 
            m_wNumHandleStatics++;
            break;

        case FIELD_OFFSET_UNPLACED:
            m_pFieldDescList[dwIndex].SetOffset(bmtFP->StaticFieldStart[dwFieldSize] + (bmtFP->NumStaticFieldsOfSize[dwFieldSize] << dwFieldSize));
            bmtFP->NumStaticFieldsOfSize[dwFieldSize]++;

        default:
            // RVA field
            break;
        }
    }

    if (shared)
    {
        bmtVT->dwStaticFieldBytes = dwCumulativeStaticFieldPos;
        bmtVT->dwStaticGCFieldBytes = dwCumulativeStaticGCFieldPos;
    }
    else
    {
        bmtVT->dwStaticFieldBytes = dwCumulativeStaticFieldPos - bmtVT->dwCurrentNonVtableSlot*sizeof(SLOT);
        bmtVT->dwStaticGCFieldBytes = dwCumulativeStaticGCFieldPos - bmtVT->dwCurrentNonVtableSlot*sizeof(SLOT);
    }

    //===============================================================
    // END: Place static fields
    //===============================================================

    return hr;
}

//
// Used by BuildMethodTable
//
// Place instance fields
//

HRESULT EEClass::PlaceInstanceFields(bmtFieldPlacement* bmtFP, bmtEnumMethAndFields* bmtEnumMF,
                                     bmtParentInfo* bmtParent, bmtErrorInfo *bmtError,
                                     EEClass*** pByValueClassCache)
{
    HRESULT hr = S_OK;
    DWORD i;

        //===============================================================
        // BEGIN: Place instance fields
        //===============================================================

        DWORD   dwCumulativeInstanceFieldPos;
        
        // Instance fields start right after the parent
        dwCumulativeInstanceFieldPos    = (GetParentClass() != NULL) ? GetParentClass()->m_dwNumInstanceFieldBytes : 0;

        // The parent may have a number of field bytes that is not DWORD aligned, so use 2 byte and 1 byte
        // fields to pad out to the next DWORD if we can.
        // @TODO: When GC pads on QWORD boundaries, look at doing the same
        if (dwCumulativeInstanceFieldPos & 1)
        {
            if (bmtFP->NumInstanceFieldsOfSize[0] > 0)
            {
                // Place the first field of size 1
                m_pFieldDescList[ bmtFP->FirstInstanceFieldOfSize[0] ].SetOffset(dwCumulativeInstanceFieldPos);
                dwCumulativeInstanceFieldPos++;

                // We've placed this field now, so there is now one less of this size field to place
                // Update FirstInstanceFieldOfSize[0] to point to the next such field
                if (--bmtFP->NumInstanceFieldsOfSize[0] > 0)
                {
                    // Search for next field of size 1
                    for (i = bmtFP->FirstInstanceFieldOfSize[0]+1; i < bmtEnumMF->dwNumInstanceFields; i++)
                    {
                        // The log of the field size is stored in the method table
                        if (m_pFieldDescList[i].m_pMTOfEnclosingClass == (MethodTable *) 0)
                        {
                            bmtFP->FirstInstanceFieldOfSize[0] = i;
                            break;
                        }
                    }

                    _ASSERTE(i < bmtEnumMF->dwNumInstanceFields);
                }
            }
        }

        // If we're word aligned, but not dword aligned
        if ((dwCumulativeInstanceFieldPos & 3) == 2)
        {
            // Try to place a WORD field
            // @TODO: Better to place a USHORT field or two BYTE fields?
            if (bmtFP->NumInstanceFieldsOfSize[1] > 0)
            {
                // Place the first field of size 2
                m_pFieldDescList[ bmtFP->FirstInstanceFieldOfSize[1] ].SetOffset(dwCumulativeInstanceFieldPos);
                dwCumulativeInstanceFieldPos += 2;

                // We've placed this field now, so there is now one less of this size field to place
                // Don't bother to update FirstInstanceOfFieldSize[1], since we don't use that array any
                // more - we're done aligning
                bmtFP->NumInstanceFieldsOfSize[1]--;
            }
            else if (bmtFP->NumInstanceFieldsOfSize[0] >= 2)
            {
                // Place two fields of size 1
                m_pFieldDescList[ bmtFP->FirstInstanceFieldOfSize[0] ].SetOffset(dwCumulativeInstanceFieldPos);
                dwCumulativeInstanceFieldPos++;

                // We've placed this field now, so there is now one less of this size field to place
                bmtFP->NumInstanceFieldsOfSize[0]--;

                // Find next field of this size
                // Don't bother to update FirstInstanceOfFieldSize[0], since we don't use that array any
                // more - we're done aligning
                for (i = bmtFP->FirstInstanceFieldOfSize[0]+1; i < bmtEnumMF->dwNumInstanceFields; i++)
                {
                    // The log of the field size is stored in the method table
                    // Since we're continuing a progressive search through the list, we know we won't
                    // be placing an already-placed field
                    if (m_pFieldDescList[i].m_pMTOfEnclosingClass == (MethodTable *) 0)
                    {
                        // Place field #2
                        m_pFieldDescList[ i ].SetOffset(dwCumulativeInstanceFieldPos);
                        dwCumulativeInstanceFieldPos++;

                        bmtFP->NumInstanceFieldsOfSize[0]--;
                        break;
                    }
                }

                _ASSERTE(i < bmtEnumMF->dwNumInstanceFields);
            }
        }

        // Align instance fields on a DWORD boundary if we aren't already
        // Static fields are auto-aligned, since they appear after the vtable
        if (dwCumulativeInstanceFieldPos & 3)
            dwCumulativeInstanceFieldPos = (dwCumulativeInstanceFieldPos+3) & (~3);

        // Place fields, largest first
        for (i = MAX_LOG2_PRIMITIVE_FIELD_SIZE; (signed long) i >= 0; i--)
        {
            DWORD dwFieldSize = (1 << i);

            // Fields of this size start at the next available location
            bmtFP->InstanceFieldStart[i] = dwCumulativeInstanceFieldPos;
            dwCumulativeInstanceFieldPos += (bmtFP->NumInstanceFieldsOfSize[i] << i);

            // Reset counters for the loop after this one
            bmtFP->NumInstanceFieldsOfSize[i]  = 0;
        }


        // Make corrections to reserve space for GC Pointer Fields
        //
        // The GC Pointers simply take up the top part of the region associated
        // with fields of that size (GC pointers can be 64 bit on certain systems)
        if (bmtFP->NumInstanceGCPointerFields)
        {
            bmtFP->GCPointerFieldStart = bmtFP->InstanceFieldStart[LOG2SLOT];
            bmtFP->InstanceFieldStart[LOG2SLOT] = bmtFP->InstanceFieldStart[LOG2SLOT] + (bmtFP->NumInstanceGCPointerFields << LOG2SLOT);
            bmtFP->NumInstanceGCPointerFields = 0;     // reset to zero here, counts up as pointer slots are assigned below
        }

        // Place instance fields - be careful not to place any already-placed fields
        for (i = 0; i < bmtEnumMF->dwNumInstanceFields; i++)
        {
            DWORD dwFieldSize   = (DWORD)(size_t)m_pFieldDescList[i].m_pMTOfEnclosingClass;
            DWORD dwOffset;

            dwOffset = m_pFieldDescList[i].GetOffset();

            // Don't place already-placed fields
            if ((dwOffset == FIELD_OFFSET_UNPLACED || dwOffset == FIELD_OFFSET_UNPLACED_GC_PTR || dwOffset == FIELD_OFFSET_VALUE_CLASS))
            {
                if (dwOffset == FIELD_OFFSET_UNPLACED_GC_PTR)
                {
                    m_pFieldDescList[i].SetOffset(bmtFP->GCPointerFieldStart + (bmtFP->NumInstanceGCPointerFields << LOG2SLOT));
                    bmtFP->NumInstanceGCPointerFields++;
                }
                else if (m_pFieldDescList[i].IsByValue() == FALSE) // it's a regular field
                {
                    m_pFieldDescList[i].SetOffset(bmtFP->InstanceFieldStart[dwFieldSize] + (bmtFP->NumInstanceFieldsOfSize[dwFieldSize] << dwFieldSize));
                    bmtFP->NumInstanceFieldsOfSize[dwFieldSize]++;
                }
            }
        }

        // Save Number of pointer series
        if (bmtFP->NumInstanceGCPointerFields)
            m_wNumGCPointerSeries = bmtParent->NumParentPointerSeries + 1;
        else
            m_wNumGCPointerSeries = bmtParent->NumParentPointerSeries;

        // Place by value class fields last
        // Update the number of GC pointer series
        for (i = 0; i < bmtEnumMF->dwNumInstanceFields; i++)
        {
            if (m_pFieldDescList[i].IsByValue())
            {
                _ASSERTE(*pByValueClassCache != NULL);

                EEClass *pByValueClass = (*pByValueClassCache)[i];

                    // value classes could have GC pointers in them, which need to be DWORD aligned
                    // so do this if it has not been done already
                if (dwCumulativeInstanceFieldPos & 3)
                    dwCumulativeInstanceFieldPos = (dwCumulativeInstanceFieldPos+3) & (~3);

                m_pFieldDescList[i].SetOffset(dwCumulativeInstanceFieldPos);
                dwCumulativeInstanceFieldPos += pByValueClass->GetAlignedNumInstanceFieldBytes();

                // Add pointer series for by-value classes
                m_wNumGCPointerSeries += pByValueClass->m_wNumGCPointerSeries;
            }
        }

            // Can be unaligned
        m_dwNumInstanceFieldBytes = dwCumulativeInstanceFieldPos;

        if (IsValueClass()) 
        {
                // The JITs like to copy full machine words, so if the size bigger 
                // than a void* round it up
            if(m_dwNumInstanceFieldBytes > sizeof(void*) / 2)
                m_dwNumInstanceFieldBytes = (m_dwNumInstanceFieldBytes + sizeof(void*)-1) & ~(sizeof(void*)-1);         

                 // Like C++ we enforce that there can be no 0 length structures.
                // Thus for a value class with no fields, we 'pad' the length to be 1
            else if (m_dwNumInstanceFieldBytes == 0)
                m_dwNumInstanceFieldBytes++;
        }

        if (m_dwNumInstanceFieldBytes > FIELD_OFFSET_LAST_REAL_OFFSET) {
            bmtError->resIDWhy = IDS_CLASSLOAD_FIELDTOOLARGE;
            IfFailRet(COR_E_TYPELOAD);
        }

        //===============================================================
        // END: Place instance fields
        //===============================================================
    
    return hr;
}

// this accesses the field size which is temporarily stored in m_pMTOfEnclosingClass
// during class loading. Don't use any other time
DWORD EEClass::GetFieldSize(FieldDesc *pFD)
{
        // We should only be calling this while this class is being built. 
    _ASSERTE(m_pMethodTable == 0);
    _ASSERTE(! pFD->IsByValue() || HasExplicitFieldOffsetLayout());

    if (pFD->IsByValue())
        return (DWORD)(size_t)(pFD->m_pMTOfEnclosingClass);
    return (1 << (DWORD)(size_t)(pFD->m_pMTOfEnclosingClass));
}

// make sure that no object fields are overlapped incorrectly and define the
// GC pointer series for the class. We are assuming that this class will always be laid out within
// its enclosing class by the compiler in such a way that offset 0 will be the correct alignment
// for object ref fields so we don't need to try to align it
HRESULT EEClass::HandleExplicitLayout(bmtMetaDataInfo *bmtMetaData, bmtMethAndFieldDescs *bmtMFDescs, EEClass **pByValueClassCache, bmtInternalInfo* bmtInternal, bmtGCSeries *pGCSeries, bmtErrorInfo *bmtError)
{
    // need to calculate instance size as can't use nativeSize or anything else that
    // has been previously calculated.
    UINT instanceSliceSize = 0;
    BOOL fVerifiable = TRUE;
    BOOL fOverLayed = FALSE;
    HRESULT hr = S_OK;

    for (UINT i=0; i < bmtMetaData->cFields; i++) {
        FieldDesc *pFD = bmtMFDescs->ppFieldDescList[i];
        if (!pFD)
            continue;
        if (pFD->IsStatic())
            continue;
        UINT fieldExtent = pFD->GetOffset() + GetFieldSize(pFD);
        if (fieldExtent > instanceSliceSize)
            instanceSliceSize = fieldExtent;
    }

    char *pFieldLayout = (char*)alloca(instanceSliceSize);
    for (i=0; i < instanceSliceSize; i++)
        pFieldLayout[i] = empty;

    // go through each field and look for invalid layout
    // verify that every OREF is on a valid alignment
    // verify that only OREFs overlap
    char emptyObject[4] = {empty, empty, empty, empty};
    char isObject[4] = {oref, oref, oref, oref};

    UINT badOffset = 0;
    int  firstOverlay = -1;
    FieldDesc *pFD = NULL;
    for (i=0; i < bmtMetaData->cFields; i++) {
        pFD = bmtMFDescs->ppFieldDescList[i];
        if (!pFD)
            continue;
        if (pFD->IsStatic())
            continue;
        if (CorTypeInfo::IsObjRef(pFD->GetFieldType())) {
            if (pFD->GetOffset() & ((ULONG)sizeof(OBJECTREF) - 1)) {
                badOffset = pFD->GetOffset();
                break;        
            }
            // check if overlaps another object
            if (memcmp((void *)&pFieldLayout[pFD->GetOffset()], (void *)&isObject, sizeof(isObject)) == 0) {
                fVerifiable = FALSE;
                fOverLayed = TRUE;
                if(firstOverlay == -1) firstOverlay = pFD->GetOffset();
                continue;
            }
            // check if is empty at this point
            if (memcmp((void *)&pFieldLayout[pFD->GetOffset()], (void *)&emptyObject, sizeof(emptyObject)) == 0) {
                memset((void *)&pFieldLayout[pFD->GetOffset()], oref, sizeof(isObject));
                continue;
            }
            badOffset = pFD->GetOffset();
            break;
            // anything else is an error
        } else {
            UINT fieldSize;
            if (pFD->IsByValue()) {
                EEClass *pByValue = pByValueClassCache[i];
                if (pByValue->GetMethodTable()->ContainsPointers()) {
                    if ((pFD->GetOffset() & ((ULONG)sizeof(void*) - 1)) == 0)
                    {
                        hr = pByValue->CheckValueClassLayout(&pFieldLayout[pFD->GetOffset()], pFD->GetOffset(), &fVerifiable);
                        if(SUCCEEDED(hr)) {
                            if(hr == S_FALSE)
                                fOverLayed = TRUE;
                            // see if this overlays other 
                            continue;
                        }
                    }
                    // anything else is an error
                    badOffset = pFD->GetOffset();
                    break;
                }
                // no pointers so fall through to do standard checking
                fieldSize = pByValue->m_dwNumInstanceFieldBytes;
            } else {
                // field size temporarily stored in pMT field
                fieldSize = GetFieldSize(pFD);
            }
            // look for any orefs under this field
            char *loc;
            if ((loc = (char*)memchr((void*)&pFieldLayout[pFD->GetOffset()], oref, fieldSize)) == NULL) {
                // If we have a nonoref in the range then we are doing an overlay
                if( memchr((void*)&pFieldLayout[pFD->GetOffset()], nonoref, fieldSize))
                    fOverLayed = TRUE;
                memset((void*)&pFieldLayout[pFD->GetOffset()], nonoref, fieldSize);
                continue;
            }
            badOffset = (UINT)(loc - pFieldLayout);
            break;
            // anything else is an error
        }
    }
    if (i < bmtMetaData->cFields) {
        IfFailRet(PostFieldLayoutError(GetCl(),
                                       bmtInternal->pModule,
                                       badOffset,
                                       IDS_CLASSLOAD_EXPLICIT_LAYOUT,
                                       bmtError->pThrowable));
    }

    if(!fVerifiable) {
        BEGIN_ENSURE_COOPERATIVE_GC();
        if (!Security::CanSkipVerification(GetAssembly())) {
            hr =  PostFieldLayoutError(GetCl(),
                                       bmtInternal->pModule,
                                       (DWORD) firstOverlay,
                                       IDS_CLASSLOAD_UNVERIFIABLE_FIELD_LAYOUT,
                                       bmtError->pThrowable);
        }
        END_ENSURE_COOPERATIVE_GC();
        IfFailRet(hr);
    }

    if(fOverLayed)
        SetHasOverLayedFields();

    hr = FindPointerSeriesExplicit(instanceSliceSize, pFieldLayout, pGCSeries);

    // Fixup the offset to include parent as current offsets are relative to instance slice
    // Could do this earlier, but it's just easier to assume instance relative for most
    // of the earlier calculations

    // Instance fields start right after the parent
    UINT dwInstanceSliceOffset    = InstanceSliceOffsetForExplicit(pGCSeries->numSeries != 0);

    // Set the total size 
    m_dwNumInstanceFieldBytes = GetLayoutInfo()->m_cbNativeSize;
    if (m_dwNumInstanceFieldBytes < (dwInstanceSliceOffset + instanceSliceSize))
        IfFailRet(COR_E_TYPELOAD);

    for (i=0; i < bmtMetaData->cFields; i++) {
        FieldDesc *pFD = bmtMFDescs->ppFieldDescList[i];
        if (!pFD)
            continue;
        if (pFD->IsStatic())
            continue;
        IfFailRet(pFD->SetOffset(pFD->GetOffset() + dwInstanceSliceOffset));
    }
    return hr;
}

// make sure that no object fields are overlapped incorrectly, returns S_FALSE if there overlap
// but nothing illegal, S_OK if there is no overlap
HRESULT EEClass::CheckValueClassLayout(char *pFieldLayout, UINT fieldOffset, BOOL* pfVerifiable)
{
    HRESULT hr = S_OK;
    // Build a layout of the value class. Don't know the sizes of all the fields easily, but
    // do know a) vc is already consistent so don't need to check it's overlaps and
    // b) size and location of all objectrefs. So build it by setting all non-oref 
    // then fill in the orefs later
    UINT fieldSize = GetNumInstanceFieldBytes();
    char *vcLayout = (char*)alloca(fieldSize);
    memset((void*)vcLayout, nonoref, fieldSize);
    // use pointer series to locate the orefs
    _ASSERTE(m_wNumGCPointerSeries > 0);
    CGCDescSeries *pSeries = ((CGCDesc*) GetMethodTable())->GetLowestSeries();

    for (UINT j = 0; j < m_wNumGCPointerSeries; j++)
    {
        _ASSERTE(pSeries <= CGCDesc::GetCGCDescFromMT(GetMethodTable())->GetHighestSeries());

        memset((void*)&vcLayout[pSeries->GetSeriesOffset()-sizeof(Object)], oref, pSeries->GetSeriesSize() + GetMethodTable()->GetBaseSize());
        pSeries++;
    }

    // if there are orefs in the current layout, we have to go the slow way and 
    // compare each element. If is ok, then can just copy the vc layout onto it
    char *loc;
    if ((loc = (char*)memchr((void*)pFieldLayout, oref, fieldSize)) != NULL) {
        for (UINT i=0; i < fieldSize; i++) {
            if (vcLayout[i] == oref) {
                if (pFieldLayout[i] == nonoref) 
                    return COR_E_TYPELOAD;
                else {
                    if(pFieldLayout[i] == nonoref)
                        hr = S_FALSE;
                    *pfVerifiable = FALSE;
                }
            } else if (vcLayout[i] == nonoref) {
                if (pFieldLayout[i] == oref)
                    return COR_E_TYPELOAD;
                else if(pFieldLayout[i] == nonoref) {
                    // We are overlapping another field
                    hr = S_FALSE;
                }
            }
        }
    }
    else {
        // Are we overlapping another field
        if(memchr((void*)pFieldLayout, nonoref, fieldSize))
            hr = S_FALSE;
    }

    // so either no orefs in the base or all checks out ok
    memcpy((void*)pFieldLayout, (void*)vcLayout, fieldSize);
    return S_OK;
}

HRESULT EEClass::FindPointerSeriesExplicit(UINT instanceSliceSize, char *pFieldLayout, bmtGCSeries *pGCSeries)
{
    THROWSCOMPLUSEXCEPTION();

    // allocate a structure to track the series. We know that the worst case is a oref-non-oref-non 
    // so would the number of series is total instance size div 2 div size of oref.
    // But watch out for the case where we have e.g. an instanceSlizeSize of 4.
    DWORD sz = (instanceSliceSize + (2 * sizeof(OBJECTREF)) - 1);
    pGCSeries->pSeries = new (throws) bmtGCSeries::Series[sz/2/sizeof(OBJECTREF)];

    char *loc = pFieldLayout;
    char *layoutEnd = pFieldLayout + instanceSliceSize;
    while (loc < layoutEnd) {
        loc = (char*)memchr((void*)loc, oref, layoutEnd-loc);
        if (!loc) 
            break;
        char *cur = loc;
        while(*cur == oref)
            cur++;
        // so we have a GC series at loc for cur-loc bytes
        pGCSeries->pSeries[pGCSeries->numSeries].offset = (DWORD)(loc - pFieldLayout);
        pGCSeries->pSeries[pGCSeries->numSeries].len = (DWORD)(cur - loc);
        pGCSeries->numSeries++;
        loc = cur;
    }

    m_wNumGCPointerSeries = pGCSeries->numSeries + (GetParentClass() ? GetParentClass()->m_wNumGCPointerSeries : 0);
    return S_OK;
}

HRESULT EEClass::HandleGCForExplicitLayout(bmtGCSeries *pGCSeries)
{
    if (! pGCSeries->numSeries)
    {
        delete [] pGCSeries->pSeries;
        pGCSeries->pSeries = NULL;

        return S_OK;
    }

    m_pMethodTable->SetContainsPointers();

    // Copy the pointer series map from the parent
    CGCDesc::Init( (PVOID) m_pMethodTable, m_wNumGCPointerSeries );
    if (GetParentClass() && (GetParentClass()->m_wNumGCPointerSeries > 0))
    {
        UINT ParentGCSize = CGCDesc::ComputeSize(GetParentClass()->m_wNumGCPointerSeries);
        memcpy( (PVOID) (((BYTE*) m_pMethodTable) - ParentGCSize),  (PVOID) (((BYTE*) GetParentClass()->m_pMethodTable) - ParentGCSize), ParentGCSize - sizeof(UINT) );

    }

    // Build the pointer series map for this pointers in this instance
    CGCDescSeries *pSeries = ((CGCDesc*)m_pMethodTable)->GetLowestSeries();
    for (UINT i=0; i < pGCSeries->numSeries; i++) {
        // See gcdesc.h for an explanation of why we adjust by subtracting BaseSize
        _ASSERTE(pSeries <= CGCDesc::GetCGCDescFromMT(m_pMethodTable)->GetHighestSeries());

        pSeries->SetSeriesSize( pGCSeries->pSeries[i].len - m_pMethodTable->m_BaseSize );
        pSeries->SetSeriesOffset(pGCSeries->pSeries[i].offset + sizeof(Object) + InstanceSliceOffsetForExplicit(TRUE));
        pSeries++;
    }
    delete [] pGCSeries->pSeries;
    pGCSeries->pSeries = NULL;

    return S_OK;
}


//
// Used by BuildMethodTable
//
// Setup the method table
//

HRESULT EEClass::SetupMethodTable(bmtVtable* bmtVT, 
                                  bmtInterfaceInfo* bmtInterface, 
                                  bmtInternalInfo* bmtInternal, 
                                  bmtProperties* bmtProp, 
                                  bmtMethAndFieldDescs* bmtMFDescs, 
                                  bmtEnumMethAndFields* bmtEnumMF, 
                                  bmtErrorInfo* bmtError, 
                                  bmtMetaDataInfo* bmtMetaData, 
                                  bmtParentInfo* bmtParent)
{
    HRESULT hr = S_OK;
    DWORD i;
    BOOL fEnC = bmtInternal->pModule->IsEditAndContinue();

    BOOL bHasDynamicInterfaceMap = bmtInterface->dwMaxExpandedInterfaces > 0 &&
                                bmtProp->fIsComObjectType && 
                                (GetParentClass() != g_pObjectClass->GetClass());

    // Now setup the method table
    // interface map is allocated along with the method table
    m_pMethodTable = MethodTable::AllocateNewMT(
        bmtVT->dwCurrentNonVtableSlot,
        bmtVT->dwStaticFieldBytes,
        m_wNumGCPointerSeries ? CGCDesc::ComputeSize(m_wNumGCPointerSeries) : 0,
        bmtInterface->dwInterfaceMapSize,
        GetClassLoader(),
        IsInterface(),
        bHasDynamicInterfaceMap
    );
    if (m_pMethodTable == NULL)
    {
        IfFailRet(E_OUTOFMEMORY);
    }

    m_pMethodTable->m_pEEClass  = this;
    m_pMethodTable->m_pModule   = bmtInternal->pModule;
    m_pMethodTable->m_wFlags   &= 0xFFFF;   // clear flags without touching m_ComponentSize
    m_pMethodTable->m_NormType = ELEMENT_TYPE_CLASS;

    // @todo: SetupMethodTable is thread-safe, yes? It's gotta be, since we're
    // setting m_pMethodTable...
    if (fEnC)
    {
        EditAndContinueModule *pEACM = (EditAndContinueModule*)m_pMethodTable->m_pModule;

        SIZE_T newSize = sizeof(SLOT)*ENC_EXTRA_SLOT_COUNT;
        // It's very important that we use here the same heap used in MethodTable::new, so
        // that the memory ends up soon after the VTable of the MethodTable
        WS_PERF_SET_HEAP(HIGH_FREQ_HEAP);    
        const BYTE *start = (const BYTE *)GetClassLoader()->GetHighFrequencyHeap()->AllocMem(newSize);
        WS_PERF_UPDATE_DETAIL("MethodTable:new:HighFreq", newSize, (void *)start);
        if (start != NULL)
        {
            const BYTE *end = start + newSize; //this is 1 beyond the valid memory
            
            // Drop return value on floor - if this fails, we simply won't be able
            // to use the extra slots.
            LOG((LF_CORDB, LL_INFO100000, "EEC::SMT:Added (0x%x,0x%x) to ranges for later SLOT use!\n",
                start, end));
            _ASSERTE(pEACM->m_pRangeList);
            pEACM->m_pRangeList->AddRange(start, 
                                          end,
                                          (void *)start);
        }                                          
    }

    if (IsShared())
        m_pMethodTable->SetShared();
    
    if (IsValueClass()) 
    {
        m_pMethodTable->m_NormType = ELEMENT_TYPE_VALUETYPE;
        LPCUTF8 name, nameSpace;
        if (IsEnum()) 
        {
            if (GetNumInstanceFields() != 1 || 
                !CorTypeInfo::IsPrimitiveType(m_pFieldDescList->GetFieldType()))
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_BAD_FIELD;
                bmtError->dMethodDefInError = mdMethodDefNil;
                bmtError->szMethodNameForError = "Enum does not have exactly one instance field of a primitive type";
                IfFailRet(COR_E_TYPELOAD);
            }
            _ASSERTE(!m_pFieldDescList->IsStatic());
            m_pMethodTable->m_NormType = m_pFieldDescList->GetFieldType();
        }
        else if (!IsNested())
        {
                // Check if it is a primitive type or other special type
            if (bmtInternal->pModule->IsSystemClasses())    // we are in mscorlib
            {
                bmtInternal->pModule->GetMDImport()->GetNameOfTypeDef(GetCl(), &name, &nameSpace);
                if (strcmp(nameSpace, "System") == 0) {
                    m_pMethodTable->m_NormType = CorTypeInfo::FindPrimitiveType(nameSpace, name);
                    if (m_pMethodTable->m_NormType == ELEMENT_TYPE_END)
                    {
                        m_pMethodTable->m_NormType = ELEMENT_TYPE_VALUETYPE;

                        if ((strcmp(name, g_RuntimeTypeHandleName) == 0)   || 
                            (strcmp(name, g_RuntimeMethodHandleName) == 0) || 
                            (strcmp(name, g_RuntimeFieldHandleName) == 0)  || 
                            (strcmp(name, g_RuntimeArgumentHandleName) == 0))
                        {

                            // TODO: ultimately I want all value classes that look like an I
                            // to be mapped to ELEMENT_TYPE_I, however for now we just do
                            // the ones above. -vancem
                            m_pMethodTable->m_NormType = ELEMENT_TYPE_I;
                        }

                        // Mark the special types that have embeded stack poitners in them
                        if (strcmp(name, "ArgIterator") == 0 || strcmp(name, "RuntimeArgumentHandle") == 0) 
                            m_VMFlags |= VMFLAG_CONTAINS_STACK_PTR;
                    }
                    else {
                        m_VMFlags |= VMFLAG_TRUEPRIMITIVE;
                        if (m_pMethodTable->m_NormType == ELEMENT_TYPE_TYPEDBYREF)
                            m_VMFlags |= VMFLAG_CONTAINS_STACK_PTR;
                    }
                }
            }
        }
    }

    if (bmtProp->fSparse)
        m_pMethodTable->SetSparse();

    m_pMethodTable->m_wCCtorSlot = bmtVT->wCCtorSlot;
    m_pMethodTable->m_wDefaultCtorSlot = bmtVT->wDefaultCtorSlot;

    // Push pointer to method table into the head of each of the method desc
    // chunks we allocated earlier, so that method descs can map back to method
    // tables.
    for (DWORD impl=0; impl<METHOD_IMPL_COUNT; impl++)
        for (DWORD type=0; type<METHOD_TYPE_COUNT; type++)
        {
            bmtMethodDescSet *set = &bmtMFDescs->sets[type][impl];
            for (i=0; i<set->dwChunks; i++)
                set->pChunkList[i]->SetMethodTable(m_pMethodTable);
        }

#ifdef _DEBUG
    for (i = 0; i < bmtMetaData->cMethods; i++) {
        if (bmtMFDescs->ppMethodDescList[i] != NULL) {
            bmtMFDescs->ppMethodDescList[i]->m_pDebugMethodTable = m_pMethodTable;
            bmtMFDescs->ppMethodDescList[i]->m_pszDebugMethodSignature = FormatSig(bmtMFDescs->ppMethodDescList[i]);
        }
    }
    if (bmtMFDescs->ppUnboxMethodDescList != NULL) {
        for (i = 0; i < bmtMetaData->cMethods; i++) {
            if (bmtMFDescs->ppUnboxMethodDescList[i] != NULL) {
                bmtMFDescs->ppUnboxMethodDescList[i]->m_pDebugMethodTable = m_pMethodTable;
                bmtMFDescs->ppUnboxMethodDescList[i]->m_pszDebugMethodSignature = FormatSig(bmtMFDescs->ppUnboxMethodDescList[i]);
            }
        }
    }
    for (i = 0; i < bmtEnumMF->dwNumDeclaredMethods; i++) {
        bmtParent->ppParentMethodDescBuf[i*2+1]->m_pDebugMethodTable = m_pMethodTable;
        bmtParent->ppParentMethodDescBuf[i*2+1]->m_pszDebugMethodSignature = FormatSig(bmtParent->ppParentMethodDescBuf[i*2+1]);
    }
#endif

    // Note that for value classes, the following calculation is only appropriate
    // when the instance is in its "boxed" state.
    if (!IsInterface())
    {
        m_pMethodTable->m_BaseSize = MAX(m_dwNumInstanceFieldBytes + ObjSizeOf(Object), MIN_OBJECT_SIZE);
        m_pMethodTable->m_BaseSize = (m_pMethodTable->m_BaseSize + 3) & ~3;  // m_BaseSize must be dword aligned 
        m_pMethodTable->m_ComponentSize = 0;
        if (bmtProp->fIsComObjectType)
        {
            //propagate the com specific info
            m_pMethodTable->SetComObjectType();
        }
    }
    else
    {
        // If this is an interface then we need to set the ComInterfaceType to
        // -1 to indicate we have not yet determined the interface type.
        m_pMethodTable->SetComInterfaceType((CorIfaceAttr)-1);

        // If this is a special COM event interface, then mark the MT as such.
        if (bmtProp->fComEventItfType)
        {
            m_pMethodTable->SetComEventItfType();
        }
    }

    if (HasLayout())
    {
        m_pMethodTable->SetNativeSize(GetLayoutInfo()->GetNativeSize());
    }

    if (m_VMFlags & VMFLAG_ISBLOBCLASS)
    {
        m_pMethodTable->SetNativeSize(m_dwNumInstanceFieldBytes);
    }

    // copy onto the real vtable (methods only)
    memcpy(GetVtable(), bmtVT->pVtable, bmtVT->dwCurrentNonVtableSlot * sizeof(SLOT));

    // TODO change this soon: rajak
    BOOL fCheckForMissingMethod = (!bmtProp->fIsComObjectType && !IsAbstract() && !IsInterface());

    // Propagate inheritance
    for (i = 0; i < bmtVT->dwCurrentVtableSlot; i++)
    {
        // For now only propagate inheritance for method desc that are not interface MD's. 
        // This is not sufficient but InterfaceImpl's will complete the picture.
        MethodDesc* pMD = GetUnknownMethodDescForSlot(i);
        if (pMD == NULL) 
        {
            _ASSERTE(!"Could not resolve MethodDesc Slot!");
            IfFailRet(COR_E_TYPELOAD);
        }

        if(!pMD->IsInterface() && pMD->GetSlot() != i) 
        {
            GetVtable()[i] = GetVtable()[ pMD->GetSlot() ];
            pMD = GetUnknownMethodDescForSlot(i);
        }

        if (fCheckForMissingMethod)
        {
            if (pMD->IsInterface() || pMD->IsAbstract())
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_NOTIMPLEMENTED;
                bmtError->dMethodDefInError = pMD->GetMemberDef();
                bmtError->szMethodNameForError = pMD->GetNameOnNonArrayClass();
                IfFailRet(COR_E_TYPELOAD);
            }
                // we check earlier to make certain only abstract methods have RVA != 0
            _ASSERTE(!(pMD->GetModule()->IsPEFile() && pMD->IsIL() && pMD->GetRVA() == 0));
        }
    } 


#ifdef _DEBUG
    for (i = 0; i < bmtVT->dwCurrentNonVtableSlot; i++)
    {
        _ASSERTE(bmtVT->pVtable[i] != NULL);
    }
#endif

    // Set all field slots to point to the newly created MethodTable
    for (i = 0; i < (bmtEnumMF->dwNumStaticFields + bmtEnumMF->dwNumInstanceFields); i++)
    {
        m_pFieldDescList[i].m_pMTOfEnclosingClass = m_pMethodTable;
    }

    // Zero-init all static fields.  J++ does not generate class initialisers if all you are doing
    // is setting fields to zero.
    memset((SLOT *) GetVtable() + bmtVT->dwCurrentNonVtableSlot, 0, bmtVT->dwStaticFieldBytes);

    _ASSERTE(bmtInterface->dwInterfaceMapSize < 0xffff);
    m_wNumInterfaces = (WORD)bmtInterface->dwInterfaceMapSize;
    // Now create our real interface map now that we know how big it should be
    if (bmtInterface->dwInterfaceMapSize == 0)
    {
        bmtInterface->pInterfaces = NULL;
    }
    else
    {
        bmtInterface->pInterfaces = m_pMethodTable->GetInterfaceMap();

        _ASSERTE(bmtInterface->pInterfaces  != NULL);

        // Copy from temporary interface map
        memcpy(bmtInterface->pInterfaces, bmtInterface->pInterfaceMap, bmtInterface->dwInterfaceMapSize * sizeof(InterfaceInfo_t));

        if (!IsInterface())
        {
            hr = m_pMethodTable->InitInterfaceVTableMap();
        }
//#endif
    

    }

    // for ComObject types, i.e. if the class extends from a COM Imported
    // class
    // make sure any interface implementated by the COM Imported class
    // is overridden fully, (OR) not overridden at all..
    if (bmtProp->fIsComObjectType)
    {
        BOOL fSuccess = TRUE;
        if (bmtInterface->dwInterfaceMapSize != 0)
        {
            for (unsigned i = 0; i < bmtInterface->dwInterfaceMapSize; i++)
            {
                MethodTable* pIntfMT = bmtInterface->pInterfaceMap[i].m_pMethodTable;
                EEClass* pIntfClass = pIntfMT->GetClass();
                if (pIntfClass->GetNumVtableSlots() != 0)
                {                    
                    WORD startSlot =  bmtInterface->pInterfaceMap[i].m_wStartSlot;
                    BOOL hasComImportMethod = FALSE;
                    BOOL hasManagedMethod = FALSE;
                    
                    for (int j = startSlot;j <(pIntfClass->GetNumVtableSlots()+startSlot); j++)
                    {
                        // either all the methods should be complus-call or none 
                        // should be
                        MethodDesc* pClsMD = GetUnknownMethodDescForSlot(j);      

                        if (pClsMD->GetMethodTable()->IsInterface() || pClsMD->GetClass()->IsComImport())
                        {
                            // this is a ComImported method.. i.e. the calls will go
                            // to COM
                            hasComImportMethod = TRUE;
                        }
                        else
                        {
                            hasManagedMethod = TRUE;
                        }

                        fSuccess = (hasComImportMethod ^ hasManagedMethod);

                        if (fSuccess == FALSE)
                        {
                            bmtError->resIDWhy = IDS_EE_BAD_COMEXTENDS_CLASS;
                            bmtError->dMethodDefInError = pClsMD->GetMemberDef();
                            bmtError->szMethodNameForError = pClsMD->GetNameOnNonArrayClass();
                            IfFailRet(COR_E_TYPELOAD);
                        }
                    }                        
                }
            }            
        }
    }

    // For COM event interfaces, we need to make sure that all the methods are
    // methods to add or remove events. This means that they all need to take
    // a delegate derived class and have a void return type.
    if (bmtProp->fComEventItfType)
    {
        // COM event interfaces had better be interfaces.
        _ASSERTE(IsInterface());

        // Go through all the methods and 
        for (int i = 0; i < GetNumVtableSlots(); i++)
        {
            MethodDesc* pMD = GetUnknownMethodDescForSlot(i);
            _ASSERTE(pMD);

            MetaSig Sig(pMD->GetSig(), pMD->GetModule());
            if (Sig.GetReturnType() != ELEMENT_TYPE_VOID || 
                Sig.NumFixedArgs() != 1 ||
                Sig.NextArg() != ELEMENT_TYPE_CLASS || 
                !Sig.GetTypeHandle().CanCastTo(TypeHandle(g_pDelegateClass)))
            {
                bmtError->resIDWhy = IDS_EE_BAD_COMEVENTITF_CLASS;
                bmtError->dMethodDefInError = pMD->GetMemberDef();
                bmtError->szMethodNameForError = pMD->GetNameOnNonArrayClass();
                IfFailRet(COR_E_TYPELOAD);
            }
        }
    }

    return hr;
}


HRESULT EEClass::CheckForRemotingProxyAttrib(bmtInternalInfo *bmtInternal, bmtProperties* bmtProp)
{
    BEGIN_ENSURE_COOPERATIVE_GC();

    // See if our parent class has a proxy attribute
    EEClass *pParent = GetParentClass();
    _ASSERTE(g_pObjectClass != NULL);

    if (!pParent->HasRemotingProxyAttribute())
    {
        // Call the metadata api to look for a proxy attribute on this type
        // Note: the api does not check for inherited attributes

        // Set the flag is the type has a non-default proxy attribute
        if (COMCustomAttribute::IsDefined(
            bmtInternal->pModule,
            m_cl,
            TypeHandle(CRemotingServices::GetProxyAttributeClass())))
        {
            m_VMFlags |= VMFLAG_REMOTING_PROXY_ATTRIBUTE;
        }
    }
    else
    {
        // parent has proxyAttribute ... mark this class as having one too!
        m_VMFlags |= VMFLAG_REMOTING_PROXY_ATTRIBUTE;
    }

    END_ENSURE_COOPERATIVE_GC();
    return S_OK;
}


HRESULT EEClass::CheckForValueType(bmtErrorInfo* bmtError)
{
    HRESULT hr = S_OK;

    if(g_pValueTypeClass != NULL && GetParentClass() == g_pValueTypeClass->GetClass()) {
        // There is one exception to the rule that you are a value class
        // if you inherit from g_pValueTypeClass, namely System.Enum.
        // we detect that we are System.Enum because g_pEnumClass has
        // not been set
        if (g_pEnumClass != NULL)
        {
            SetValueClass();
            /*
            if(!IsTdSealed(m_dwAttrClass))
            {
                _ASSERTE(!"Non-sealed Value Type");
                bmtError->resIDWhy = IDS_CLASSLOAD_GENERIC;
                hr = E_FAIL;
            }
            */
        }
        else
            _ASSERTE(strncmp(m_szDebugClassName, g_EnumClassName, strlen(g_EnumClassName)) == 0);
    }

    return hr;
}

HRESULT EEClass::CheckForEnumType(bmtErrorInfo* bmtError)
{
    HRESULT hr = S_OK;

    if(g_pEnumClass != NULL && GetParentClass() == g_pEnumClass->GetClass()) {
        // Enums are also value classes, so set both bits.
        SetValueClass();
        SetEnum();
        /*
        if(!IsTdSealed(m_dwAttrClass))
        {
            _ASSERTE(!"Non-sealed Enum");
            bmtError->resIDWhy = IDS_CLASSLOAD_GENERIC;
            hr = E_FAIL;
        }
        */
    }

    return hr;
}


//
// Used by BuildMethodTable
//
// Set the contextful or marshaledbyref flag on the attributes of the class
//
HRESULT EEClass::CheckForSpecialTypes(bmtInternalInfo *bmtInternal, bmtProperties *bmtProp)
{
    Module *pModule = bmtInternal->pModule;
    IMDInternalImport *pMDImport = pModule->GetMDImport();

    // Check to see if this type is a managed standard interface. All the managed
    // standard interfaces live in mscorlib.dll so checking for that first
    // makes the strcmp that comes afterwards acceptable.
    if (IsInterface() && pModule->IsSystem())
    {
        LPCUTF8 pszClassName;
        LPCUTF8 pszClassNamespace;
        pMDImport->GetNameOfTypeDef(GetCl(), &pszClassName, &pszClassNamespace);   
        if (pszClassName && pszClassNamespace)
        {
            LPUTF8      pszFullyQualifiedName = NULL;
            MAKE_FULLY_QUALIFIED_NAME(pszFullyQualifiedName, pszClassNamespace, pszClassName);

            // This is just to give us a scope to break out of.
            do 
            {

#define MNGSTDITF_BEGIN_INTERFACE(FriendlyName, strMngItfName, strUCOMMngItfName, strCustomMarshalerName, strCustomMarshalerCookie, strManagedViewName, NativeItfIID, bCanCastOnNativeItfQI) \
                if (strcmp(strMngItfName, pszFullyQualifiedName) == 0) \
                { \
                    bmtProp->fIsMngStandardItf = TRUE; \
                    break; \
                }

#define MNGSTDITF_DEFINE_METH_IMPL(FriendlyName, ECallMethName, MethName, MethSig)

#define MNGSTDITF_END_INTERFACE(FriendlyName) 

#include "MngStdItfList.h"

#undef MNGSTDITF_BEGIN_INTERFACE
#undef MNGSTDITF_DEFINE_METH_IMPL
#undef MNGSTDITF_END_INTERFACE

            } while (FALSE);
        }       
    }

    // Check to see if the type is a COM event interface.
    if(IsInterface())
    {
        const BYTE *pVal;
        ULONG cbVal;

        HRESULT hr = pMDImport->GetCustomAttributeByName(GetCl(), INTEROP_COMEVENTINTERFACE_TYPE, (const void**)&pVal, &cbVal);
        if (hr == S_OK)
        {
            bmtProp->fComEventItfType = TRUE;
        }
    }

    return S_OK;
}


//
// Used by BuildMethodTable
//
// Set the contextful or marshaledbyref flag on the attributes of the class
//

HRESULT EEClass::SetContextfulOrByRef(bmtInternalInfo *bmtInternal)
{
    _ASSERTE(bmtInternal);

    // @TODO: This should be done by the compiler ultimately
    // Check whether these classes are the root classes of contextful
    // and marshalbyref classes i.e. System.ContextBoundObject and 
    // System.MarshalByRefObject respectively.

    // Extract the class name            
    LPCUTF8 pszClassName = NULL;
    LPCUTF8 pszNameSpace = NULL;
    bmtInternal->pModule->GetMDImport()->GetNameOfTypeDef(GetCl(), &pszClassName, &pszNameSpace);
    DefineFullyQualifiedNameForClass();
    if (FAILED(StoreFullyQualifiedName(_szclsname_,MAX_CLASSNAME_LENGTH,pszNameSpace,pszClassName)))
        return COR_E_TYPELOAD;

    // Compare
    if(0 == strcmp(g_ContextBoundObjectClassName, _szclsname_))
        // Set the contextful and marshalbyref flag
        SetContextful();

    else if(0 == strcmp(g_MarshalByRefObjectClassName, _szclsname_))
        // Set the marshalbyref flag
        SetMarshaledByRef();

    else
    {
        // First check whether the parent class is contextful or 
        // marshalbyref
        EEClass* pParent = GetParentClass();
        if(pParent)
        {
            if(pParent->IsContextful())
                // Set the contextful and marshalbyref flag
                SetContextful();                 

            else if (pParent->IsMarshaledByRef()) 
                // Set the marshalbyref flag
                SetMarshaledByRef();
        }
    }

    return S_OK;
}

void EEClass::GetPredefinedAgility(Module *pModule, mdTypeDef td, 
                                   BOOL *pfIsAgile, BOOL *pfCheckAgile)
{
    //
    // There are 4 settings possible:
    // IsAgile  CheckAgile
    // F        F               (default)   Use normal type logic to determine agility
    // T        F               "Proxy"     Treated as agile even though may not be.
    // F        T               "Maybe"     Not agile, but specific instances can be made agile.
    // T        T               "Force"     All instances are forced agile, even though not typesafe.
    //
    // Also, note that object arrays of agile or maybe agile types are made maybe agile.
    //

    static struct PredefinedAgility 
    { 
        const char  *name;
        BOOL        isAgile;
        BOOL        checkAgile;
    } 
    agility[] = 
    {
        // The Thread and its LocalDataStore leak across context boundaries.
        // We manage the leaks manually
        // @todo: stop doing this
        { g_ThreadClassName,                    TRUE,   FALSE },
        { g_LocalDataStoreClassName,            TRUE,   FALSE },

        // The SharedStatics class is a container for process-wide data
        { g_SharedStaticsClassName,             FALSE,  TRUE },

        // Make all containers maybe agile
        { "System.Collections.*",               FALSE,  TRUE },

        // Make all globalization objects agile
        // We have CultureInfo objects on thread.  Because threads leak across
        // app domains, we have to be prepared for CultureInfo to leak across.
        // CultureInfo exposes all of the other globalization objects, so we
        // just make the entire namespace app domain agile.
        { "System.Globalization.*",             FALSE,  TRUE },

        // Remoting structures for legally smuggling messages across app domains
        { "System.Runtime.Remoting.Messaging.SmuggledMethodCallMessage", FALSE,  TRUE },
        { "System.Runtime.Remoting.Messaging.SmuggledMethodReturnMessage", FALSE,  TRUE },
        { "System.Runtime.Remoting.Messaging.SmuggledObjRef", FALSE, TRUE},
        { "System.Runtime.Remoting.ObjRef", FALSE,  TRUE },
        { "System.Runtime.Remoting.ChannelInfo", FALSE,  TRUE },
    
        // Remoting cached data structures are all in mscorlib
        { "System.Runtime.Remoting.Metadata.RemotingCachedData",       FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.RemotingMethodCachedData", FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.RemotingTypeCachedData", FALSE,  TRUE },        
        { "System.Reflection.MemberInfo",                        FALSE,  TRUE },
        { "System.Type",                                         FALSE,  TRUE },
        { "System.RuntimeType",                                  FALSE,  TRUE },
        { "System.Reflection.ConstructorInfo",                   FALSE,  TRUE },
        { "System.Reflection.RuntimeConstructorInfo",            FALSE,  TRUE },
        { "System.Reflection.EventInfo",                         FALSE,  TRUE },
        { "System.Reflection.RuntimeEventInfo",                  FALSE,  TRUE },
        { "System.Reflection.FieldInfo",                         FALSE,  TRUE },
        { "System.Reflection.RuntimeFieldInfo",                  FALSE,  TRUE },
        { "System.Reflection.RuntimeMethodBase",                 FALSE,  TRUE },
        { "System.Reflection.RuntimeMethodInfo",                 FALSE,  TRUE },
        { "System.Reflection.PropertyInfo",                      FALSE,  TRUE },
        { "System.Reflection.RuntimePropertyInfo",               FALSE,  TRUE },
        { "System.Reflection.ParameterInfo",                     FALSE,  TRUE },
        //{ "System.Runtime.Remoting.Activation.ActivationAttributeStack", FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.SoapAttribute",      FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.SoapFieldAttribute", FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.SoapMethodAttribute",FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.SoapParameterAttribute", FALSE,  TRUE },
        { "System.Runtime.Remoting.Metadata.SoapTypeAttribute",  FALSE,  TRUE },
        { "System.Reflection.Cache.InternalCache",               FALSE,  TRUE },
        { "System.Reflection.Cache.InternalCacheItem",           FALSE,  TRUE },

        // LogSwitches are agile even though we can't prove it
        // @todo: do they need really to be?
        { "System.Diagnostics.LogSwitch",       FALSE,  TRUE },

        // There is a process global PermissionTokenFactory
        { "System.Security.PermissionToken",        FALSE,  TRUE },
        { "System.Security.PermissionTokenFactory", FALSE,  TRUE },

        // Mark all the exceptions we throw agile.  This makes
        // most BVTs pass even though exceptions leak
        //
        // Note that making exception checked automatically 
        // makes a bunch of subclasses checked as well.
        //
        // Pre-allocated exceptions
        { "System.Exception",                   FALSE,  TRUE },
        { "System.OutOfMemoryException",        FALSE,  TRUE },
        { "System.StackOverflowException",      FALSE,  TRUE },
        { "System.ExecutionEngineException",    FALSE,  TRUE },

        // Reflection objects may be agile - specifically for
        // shared & system domain objects.
        //
        // @todo: currently appdomain based reflection objects
        // are global too.

        // ReflectionMethodName is agile, but we can't prove 
        // it at load time.
        { g_ReflectionMethodName,               TRUE,   TRUE },

        // ReflectionParamInfoName contains an object referece
        // for default value. 
        { g_ReflectionParamInfoName,            FALSE,  TRUE },

    // BinaryFormatter smuggles these across appdomains. 
    { "System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap", TRUE, FALSE},
    { "System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped", TRUE, FALSE},

        NULL
    };

    if (pModule == SystemDomain::SystemModule())
    {
        while (TRUE)
        {
        LPCUTF8 pszName;
        LPCUTF8 pszNamespace;
            HRESULT     hr;
            mdTypeDef   tdEnclosing;

        pModule->GetMDImport()->GetNameOfTypeDef(td, &pszName, &pszNamespace);
    
        PredefinedAgility *p = agility;
        while (p->name != NULL)
        {
            SIZE_T length = strlen(pszNamespace);
            if (strncmp(pszNamespace, p->name, length) == 0
                && (strcmp(pszName, p->name + length + 1) == 0
                    || strcmp("*", p->name + length + 1) == 0))
            {
                *pfIsAgile = p->isAgile;
                *pfCheckAgile = p->checkAgile;
                return;
            }

            p++;
        }

            // Perhaps we have a nested type like 'bucket' that is supposed to be
            // agile or checked agile by virtue of being enclosed in a type like
            // hashtable, which is itself inside "System.Collections".
            tdEnclosing = mdTypeDefNil;
            hr = pModule->GetMDImport()->GetNestedClassProps(td, &tdEnclosing);
            if (SUCCEEDED(hr))
            {
                _ASSERTE(tdEnclosing != td && TypeFromToken(tdEnclosing) == mdtTypeDef);
                td = tdEnclosing;
            }
            else
                break;
        }
    }

    *pfIsAgile = FALSE;
    *pfCheckAgile = FALSE;
}

#if CHECK_APP_DOMAIN_LEAKS
HRESULT EEClass::SetAppDomainAgileAttribute(BOOL fForceSet)
{
    //
    // The most general case for provably a agile class is
    // (1) No instance fields of non-sealed or non-agile types
    // (2) Class is in system domain (its type must be not unloadable 
    //      & loaded in all app domains)
    // (3) The class can't have a finalizer
    // (4) The class can't be a COMClass
    // 

    _ASSERTE(!IsAppDomainAgilityDone());

    HRESULT hr = S_OK;
    BOOL    fCheckAgile     = FALSE;
    BOOL    fAgile          = FALSE;
    BOOL    fFieldsAgile    = TRUE;

    if (!GetModule()->IsSystem())
    {
        //
        // No types outside of the system domain can even think about
        // being agile
        //

        goto exit;
    }

    if (m_pMethodTable->IsComObjectType())
    {
        // 
        // No COM type is agile, as there is domain specific stuff in the sync block
        //

        goto exit;
    }

    if (m_pMethodTable->IsInterface())
    {
        // 
        // Don't mark interfaces agile
        //

        goto exit;
    }

    //
    // See if we need agile checking in the class
    //

    GetPredefinedAgility(GetModule(), m_cl,
                         &fAgile, &fCheckAgile);

    if (m_pMethodTable->HasFinalizer())
    {
        if (!fAgile && !fCheckAgile)
        {
            //
            // If we're finalizable, we need domain affinity.  Otherwise, we may appear
            // to a particular app domain not to call the finalizer (since it may run
            // in a different domain.)
            //
            // Note: do not change this assumption. The eager finalizaton code for
            // appdomain unloading assumes that no obects other than those in mscorlib
            // can be agile and finalizable (jenh)
            //
            goto exit;
        }
        else
        {
            // Note that a finalizable object will be considered potentially agile if it has one of the two
            // predefined agility bits set. This will cause an assert in the eager finalization code if you add 
            // a finalizer to such a class - we don't want to have them as we can't run them eagerly and running
            // them after we've cleared the roots/handles means it can't do much safely. Right now thread is the 
            // only one we allow. If you need to add a finalizer to an object with predefined agility, talk to jenh.
            _ASSERTE(g_pThreadClass == NULL || m_pMethodTable->IsAgileAndFinalizable());
        }
    }

    //
    // Now see if the type is "naturally agile" - that is, it's type structure
    // guarantees agility.
    //

    if (GetParentClass() != NULL)
    {
        //
        // Make sure our parent was computed.  This should only happen
        // when we are prejitting - otherwise it is computed for each
        // class as its loaded.
        //

        _ASSERTE(GetParentClass()->IsAppDomainAgilityDone());

        if (!GetParentClass()->IsAppDomainAgile())
        {
            fFieldsAgile = FALSE;
            if (fCheckAgile)
                _ASSERTE(GetParentClass()->IsCheckAppDomainAgile());
        }
        
        //
        // To save having to list a lot of trivial (layout-wise) subclasses, 
        // automatically check a subclass if its parent is checked and
        // it introduces no new fields.
        //
        
        if (!fCheckAgile
            && GetParentClass()->IsCheckAppDomainAgile()
            && GetNumInstanceFields() == GetParentClass()->GetNumInstanceFields())
            fCheckAgile = TRUE;
    }

    WORD nFields = GetNumInstanceFields()
        - (GetParentClass() == NULL ? 0 : GetParentClass()->GetNumInstanceFields());

#if 0
    FieldDesc **ppFDRefSelf = (FieldDesc **) new (nothrow) FieldDesc* [nFields];
    if (ppFDRefSelf == NULL) {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    for (int i = 0; i < nFields; i ++) {
        ppFDRefSelf[i] = NULL;
    }
    WORD nSavedFDs = 0;
#endif

    if (fFieldsAgile || fCheckAgile)
    {
        FieldDesc *pFD = m_pFieldDescList;
        FieldDesc *pFDEnd = pFD + nFields;
        while (pFD < pFDEnd)
        {
            switch (pFD->GetFieldType())
            {
            case ELEMENT_TYPE_CLASS:
                {
                    //
                    // There is a bit of a problem in computing the classes which are naturally agile - 
                    // we don't want to load types of non-value type fields.  So for now we'll 
                    // err on the side of conservatism and not allow any non-value type fields other than
                    // the forced agile types listed above.
                    //

                    PCCOR_SIGNATURE pSig;
                    DWORD           cSig;
                    pFD->GetSig(&pSig, &cSig);

                    FieldSig sig(pSig, GetModule());
                    SigPointer sigPtr = sig.GetProps();
                    CorElementType type = sigPtr.GetElemType();

                    //
                    // Don't worry about strings
                    //

                    if (type == ELEMENT_TYPE_STRING)
                        break;

                    // Find our field's token so we can proceed cautiously
                    mdToken token = mdTokenNil;

                    if (type == ELEMENT_TYPE_CLASS)
                        token = sigPtr.GetToken();

                    // 
                    // First, a special check to see if the field is of our own type.
                    //

                    if (token == GetCl() && (GetAttrClass() & tdSealed))
                        break;

                    //
                    // Now, look for the field's TypeHandle.  
                    // 
                    // @todo: there is some ifdef'd code here to to load the type if it's 
                    // not already loading.  This code has synchronization problems, as well
                    // as triggering more aggressive loading than normal.  So it's disabled
                    // for now.
                    // 

                    TypeHandle th;
#if 0
                    if (TypeFromToken(token) == mdTypeDef
                        && GetClassLoader()->FindUnresolvedClass(GetModule, token) == NULL)
                        th = pFD->LoadType();
                    else
#endif
                        th = pFD->FindType();

                    //
                    // See if the referenced type is agile.  Note that there is a reasonable
                    // chance that the type hasn't been loaded yet.  If this is the case,
                    // we just have to assume that it's not agile, since we can't trigger
                    // extra loads here (for fear of circular recursion.)  
                    // 
                    // If you have an agile class which runs into this problem, you can solve it by 
                    // setting the type manually to be agile.
                    //

                    if (th.IsNull()
                        || !th.IsAppDomainAgile()
                        || (th.IsUnsharedMT() 
                            && (th.AsClass()->GetAttrClass() & tdSealed) == 0))
                    {
                        //
                        // Treat the field as non-agile.
                        //

                        fFieldsAgile = FALSE;
                        if (fCheckAgile)
                            pFD->SetDangerousAppDomainAgileField();
                    }
                }

                break;

            case ELEMENT_TYPE_VALUETYPE:
                {
                    TypeHandle th = pFD->LoadType();
                    _ASSERTE(!th.IsNull());

                    if (!th.IsAppDomainAgile())
                    {
                        fFieldsAgile = FALSE;
                        if (fCheckAgile)
                            pFD->SetDangerousAppDomainAgileField();
                    }
                }

                break;

            default:
                break;
            }

            pFD++;
        }
    }

    if (fFieldsAgile || fAgile)
        SetAppDomainAgile();

    if (fCheckAgile && !fFieldsAgile)
        SetCheckAppDomainAgile();

#if 0
    if (fFieldsAgile || fAgile){
        for (i = 0; i < nSavedFDs; i ++) {
            ppFDRefSelf[i]->SetDangerousAppDomainAgileField();
        }
    }

    delete [] ppFDRefSelf;
#endif

exit:
    SetAppDomainAgilityDone();

    return hr;
}
#endif

void EEClass::SetCCWAppDomainAgileAttribute()
{
    mdTypeDef td = m_cl;

    static struct CCWAgility 
    { 
        const char  *name;
    } 
    agility[] = 
    {
        { "System.RuntimeType"                                          },
        { "System.Reflection.RuntimeConstructorInfo"                    },
        { "System.Reflection.RuntimeEventInfo"                          },
        { "System.Reflection.RuntimeFieldInfo"                          },
        { "System.Reflection.RuntimeMethodBase"                         },
        { "System.Reflection.RuntimeMethodInfo"                         },
        { "System.Reflection.RuntimePropertyInfo"                       },
        { "System.Reflection.ParameterInfo"                             },
        { g_ReflectionMethodName                                        },
        { g_ReflectionParamInfoName                                     },
        NULL
    };

    if (GetModule() == SystemDomain::SystemModule())
    {
        while (TRUE)
        {
            LPCUTF8 pszName;
            LPCUTF8 pszNamespace;
            HRESULT     hr;
            mdTypeDef   tdEnclosing;

            GetModule()->GetMDImport()->GetNameOfTypeDef(td, &pszName, &pszNamespace);
        
            CCWAgility *p = agility;
            while (p->name != NULL)
            {
                SIZE_T length = strlen(pszNamespace);
                if (strncmp(pszNamespace, p->name, length) == 0
                    && (strcmp(pszName, p->name + length + 1) == 0
                        || strcmp("*", p->name + length + 1) == 0))
                {
                    SetCCWAppDomainAgile();
                    return;
                }

                p++;
            }

            // Perhaps we have a nested type like 'bucket' that is supposed to be
            // agile or checked agile by virtue of being enclosed in a type like
            // hashtable, which is itself inside "System.Collections".
            tdEnclosing = mdTypeDefNil;
            hr = GetModule()->GetMDImport()->GetNestedClassProps(td, &tdEnclosing);
            if (SUCCEEDED(hr))
            {
                _ASSERTE(tdEnclosing != td && TypeFromToken(tdEnclosing) == mdtTypeDef);
                td = tdEnclosing;
            }
            else
                break;
        }
    }
}

OBJECTREF MethodTable::GetObjCreateDelegate()
{
    _ASSERT(!IsInterface());
    if (m_ohDelegate)
        return ObjectFromHandle(m_ohDelegate);
    else
        return NULL;
}

void MethodTable::SetObjCreateDelegate(OBJECTREF orDelegate)
{
    if (m_ohDelegate)
        StoreObjectInHandle(m_ohDelegate, orDelegate);
    else
        m_ohDelegate = GetAppDomain()->CreateHandle(orDelegate);
}


HRESULT MethodTable::InitInterfaceVTableMap()
{    
    _ASSERTE(!IsInterface());

    LPVOID *pInterfaceVTableMap;
    
    BaseDomain* pDomain = GetModule()->GetDomain();
    // HACKKK COUGH UGGH
    // We currently can only have one "shared" vtable map mgr 
    // - so use the system domain for all shared classes
    if (pDomain == SharedDomain::GetDomain())
        pDomain = SystemDomain::System();

    DWORD count = m_wNumInterface + GetNumDynamicallyAddedInterfaces();

    if (count > 0)
    {
        pInterfaceVTableMap = pDomain->GetInterfaceVTableMapMgr().
          GetInterfaceVTableMap(m_pIMap, this, count);

        if (pInterfaceVTableMap == NULL)
            return E_FAIL;

        m_pInterfaceVTableMap = pInterfaceVTableMap;
    }

    return S_OK;
}

InterfaceInfo_t* MethodTable::GetDynamicallyAddedInterfaceMap()
{
    VALIDATE_INTERFACE_MAP(this);

    // Only extensible RCW's have dynamically added interfaces.
    if (!HasDynamicInterfaceMap())
        return NULL;

    #ifdef _DEBUG
        return GetNumDynamicallyAddedInterfaces() ? &m_pIMap[m_wNumInterface] : NULL;
    #else
        return &m_pIMap[m_wNumInterface];
    #endif
}

unsigned MethodTable::GetNumDynamicallyAddedInterfaces()
{
    VALIDATE_INTERFACE_MAP(this);

    // Only extensible RCW's have dynamically added interfaces.
    if (!HasDynamicInterfaceMap())
        return 0;

    return *(((DWORD *)m_pIMap) - 1);
}

InterfaceInfo_t* MethodTable::FindDynamicallyAddedInterface(MethodTable *pInterface)
{
    _ASSERTE(IsRestored());

    // Only extensible RCW's have dynamically added interfaces.
    if (!HasDynamicInterfaceMap())
        return NULL;

    int cDynInterfaces = GetNumDynamicallyAddedInterfaces();
    InterfaceInfo_t *pDynItfMap = GetDynamicallyAddedInterfaceMap();

    for (int i = 0; i < cDynInterfaces; i++)
    {
        if (pDynItfMap[i].m_pMethodTable == pInterface)
            return &pDynItfMap[i];
    }

    return NULL;
}

void MethodTable::AddDynamicInterface(MethodTable *pItfMT)
{
    THROWSCOMPLUSEXCEPTION();

    HRESULT hr;

    _ASSERTE(IsRestored());

    // This should never be called on for a type that is not an extensible RCW.
    _ASSERT(HasDynamicInterfaceMap());

    int NumDynAddedInterfaces = GetNumDynamicallyAddedInterfaces();
    int TotalNumInterfaces = GetNumInterfaces() + NumDynAddedInterfaces;
    InterfaceInfo_t *pNewItfMap = NULL;
    int AllocSize =  sizeof(DWORD) + sizeof(InterfaceInfo_t) * (TotalNumInterfaces + 1);

#ifdef _DEBUG
    // Add space for the dummy entry that precedes the interface map.
    AllocSize += sizeof(InterfaceInfo_t);
#endif

    // Allocate the new interface table adding one for the new interface and one
    // more for the dummy slot before the start of the table..
    WS_PERF_SET_HEAP(HIGH_FREQ_HEAP);    
    pNewItfMap = (InterfaceInfo_t*)GetClass()->GetClassLoader()->GetHighFrequencyHeap()->AllocMem(AllocSize);
    if (!pNewItfMap)
    {
        ComPlusWrapperCache::GetComPlusWrapperCache()->UNLOCK();
        COMPlusThrowOM();
    }
    WS_PERF_UPDATE_DETAIL("ComPlusWrapper:GrowInterfaceMap:HighFreq", AllocSize, pNewItfMap);

#ifdef _DEBUG
    // Fill in the dummy entry that precedes the interface map.
    pNewItfMap[0].m_wStartSlot = 0xCDCD;
    pNewItfMap[0].m_wFlags = 0xCDCD;
    pNewItfMap[0].m_pMethodTable = (MethodTable *)((sizeof(int *) == 4)?0xCDCDCDCDL:0xCDCDCDCDCDCDCDCD);
    pNewItfMap = (InterfaceInfo_t*)(((BYTE *)pNewItfMap) + sizeof(InterfaceInfo_t) + sizeof(DWORD));
#else
    pNewItfMap = (InterfaceInfo_t*)(((BYTE *)pNewItfMap) + sizeof(DWORD));
#endif

    // Copy the old map into the new one.
    memcpy(pNewItfMap, m_pIMap, TotalNumInterfaces * sizeof(InterfaceInfo_t));

    // Add the new interface at the end of the map.
    pNewItfMap[TotalNumInterfaces].m_wStartSlot = (WORD) -1;
    pNewItfMap[TotalNumInterfaces].m_wFlags = 0;
    pNewItfMap[TotalNumInterfaces].m_pMethodTable = pItfMT;

        // Update the count of dynamically added interfaces.
        *(((DWORD *)pNewItfMap) - 1) = NumDynAddedInterfaces + 1;

    // Switch the old interface map with the new one.
    m_pIMap = pNewItfMap;

    // Re layout the interface vtable map.
    hr = InitInterfaceVTableMap();
    if (FAILED(hr))
    {
        ComPlusWrapperCache::GetComPlusWrapperCache()->UNLOCK();
        COMPlusThrowHR(hr);
    }

    // Log the fact that we leaked the interface vtable map.
#ifdef _DEBUG
    LOG((LF_INTEROP, LL_EVERYTHING,
        "Extensible RCW %s being cast to interface %s caused an interface vtable map leak", 
        GetClass()->m_szDebugClassName, pItfMT->GetClass()->m_szDebugClassName));
#else
    LOG((LF_INTEROP, LL_EVERYTHING,
        "Extensible RCW being cast to an interface caused an interface vtable map leak")); 
#endif
}

#ifdef DEBUGGING_SUPPORTED
//
// Debugger notification
//

void EEClass::NotifyDebuggerLoad()
{
    if (!CORDebuggerAttached())
        return;

    NotifyDebuggerAttach(NULL, FALSE);
}

BOOL EEClass::NotifyDebuggerAttach(AppDomain *pDomain, BOOL attaching)
{
    return g_pDebugInterface->LoadClass(
        this, m_cl, GetModule(), pDomain, GetAssembly()->IsSystem(), attaching);
}

void EEClass::NotifyDebuggerDetach(AppDomain *pDomain)
{
    if (!pDomain->IsDebuggerAttached())
        return;

    g_pDebugInterface->UnloadClass(m_cl, GetModule(), pDomain, FALSE);
}
#endif // DEBUGGING_SUPPORTED

//
// Used by BuildMethodTable
//
// Perform relevant GC calculations for value classes
//

HRESULT EEClass::HandleGCForValueClasses(bmtFieldPlacement* bmtFP, bmtEnumMethAndFields* bmtEnumMF, EEClass*** pByValueClassCache)
{
    HRESULT hr = S_OK;
    DWORD i, j;
    
    // Note that for value classes, the following calculation is only appropriate
    // when the instance is in its "boxed" state.
    if (m_wNumGCPointerSeries > 0)
    {
        CGCDescSeries *pSeries;
        CGCDescSeries *pHighest;

        m_pMethodTable->SetContainsPointers();

        // Copy the pointer series map from the parent
        CGCDesc::Init( (PVOID) m_pMethodTable, m_wNumGCPointerSeries );
        if (GetParentClass() && (GetParentClass()->m_wNumGCPointerSeries > 0))
        {
            DWORD ParentGCSize = CGCDesc::ComputeSize(GetParentClass()->m_wNumGCPointerSeries);
            memcpy( (PVOID) (((BYTE*) m_pMethodTable) - ParentGCSize),  (PVOID) (((BYTE*) GetParentClass()->m_pMethodTable) - ParentGCSize), ParentGCSize - sizeof(DWORD) );

        }

        // Build the pointer series map for this pointers in this instance
        pSeries = ((CGCDesc*)m_pMethodTable)->GetLowestSeries();
        if (bmtFP->NumInstanceGCPointerFields)
        {
            // See gcdesc.h for an explanation of why we adjust by subtracting BaseSize
            pSeries->SetSeriesSize( (bmtFP->NumInstanceGCPointerFields * sizeof(OBJECTREF)) - m_pMethodTable->GetBaseSize());
            pSeries->SetSeriesOffset(bmtFP->GCPointerFieldStart+sizeof(Object));
            pSeries++;
        }

        // Insert GC info for fields which are by-value classes
        for (i = 0; i < bmtEnumMF->dwNumInstanceFields; i++)
        {
            if (m_pFieldDescList[i].IsByValue())
            {
                EEClass     *pByValueClass = (*pByValueClassCache)[i];
                MethodTable *pByValueMT = pByValueClass->GetMethodTable();
                CGCDescSeries *pByValueSeries;

                // The by value class may have more than one pointer series
                DWORD       dwNumByValueSeries = pByValueClass->m_wNumGCPointerSeries;

                if (dwNumByValueSeries > 0)
                {
                    // Offset of the by value class in the class we are building, does NOT include Object
                    DWORD       dwCurrentOffset = m_pFieldDescList[i].GetOffset();

                    pByValueSeries = ((CGCDesc*) pByValueMT)->GetLowestSeries();

                    for (j = 0; j < dwNumByValueSeries; j++)
                    {
                        DWORD dwSeriesSize;
                        DWORD dwSeriesOffset;

                        _ASSERTE(pSeries <= CGCDesc::GetCGCDescFromMT(m_pMethodTable)->GetHighestSeries());

                        dwSeriesSize = pByValueSeries->GetSeriesSize();

                        // Add back the base size of the by value class, since it's being transplanted to this class
                        dwSeriesSize += pByValueMT->GetBaseSize();

                        // Subtract the base size of the class we're building
                        dwSeriesSize -= m_pMethodTable->GetBaseSize();

                        // Set current series we're building
                        pSeries->SetSeriesSize(dwSeriesSize);

                        // Get offset into the value class of the first pointer field (includes a +Object)
                        dwSeriesOffset = pByValueSeries->GetSeriesOffset();

                        // Add it to the offset of the by value class in our class
                        dwSeriesOffset += dwCurrentOffset;

                        pSeries->SetSeriesOffset(dwSeriesOffset); // Offset of field
                        pSeries++;
                        pByValueSeries++;
                    }
                }
            }
        }

        // Adjust the inherited series - since the base size has increased by "# new field instance bytes", we need to
        // subtract that from all the series (since the series always has BaseSize subtracted for it - see gcdesc.h)
        pHighest = CGCDesc::GetCGCDescFromMT(m_pMethodTable)->GetHighestSeries();
        while (pSeries <= pHighest)
        {
            _ASSERTE( GetParentClass() );
            pSeries->SetSeriesSize( pSeries->GetSeriesSize() - (GetMethodTable()->GetBaseSize() - GetParentClass()->GetMethodTable()->GetBaseSize()) );
            pSeries++;
        }

        _ASSERTE(pSeries-1 <= CGCDesc::GetCGCDescFromMT(m_pMethodTable)->GetHighestSeries());
    }


    return hr;
}

//
// Used by BuildMethodTable
//
// Create handles for the static fields that contain object references 
// and allocate the ones that are value classes.
//

HRESULT EEClass::CreateHandlesForStaticFields(bmtEnumMethAndFields* bmtEnumMF, bmtInternalInfo* bmtInternal, EEClass*** pByValueClassCache, bmtVtable *bmtVT, bmtErrorInfo* bmtError)
{
    HRESULT hr = S_OK;
    DWORD i;
    
    // Create handles for the static fields that contain object references 
    // and allocate the ones that are value classes.
    if (bmtEnumMF->dwNumStaticObjRefFields > 0)
    {
        if (!IsShared())
        {
            BEGIN_ENSURE_COOPERATIVE_GC();

            int ipObjRefs = 0;

            // Retrieve the object ref pointers from the app domain.
            OBJECTREF **apObjRefs = new OBJECTREF*[bmtEnumMF->dwNumStaticObjRefFields];


            // Reserve some object ref pointers.
            ((AppDomain*)bmtInternal->pModule->GetDomain())->
              AllocateStaticFieldObjRefPtrs(bmtEnumMF->dwNumStaticObjRefFields, apObjRefs);

            for (i = 0; i < bmtEnumMF->dwNumStaticFields; i++)
            {
                DWORD dwIndex       = bmtEnumMF->dwNumInstanceFields + i; // index in the FieldDesc list
                FieldDesc *pField = &m_pFieldDescList[dwIndex];

                if (pField->IsSpecialStatic())
                    continue;

                // to a boxed version of the value class.  This allows the standard GC
                // algorithm to take care of internal pointers in the value class.
                if (pField->IsByValue())
                {
                    _ASSERTE(*pByValueClassCache);
                    EEClass *pByValueClass = (*pByValueClassCache)[dwIndex];

                    OBJECTREF obj = NULL;
// @todo IA64 - Determine why the compiler doesn't like this try/catch
#ifndef _IA64_
                    COMPLUS_TRY 
                      {
#endif // !_IA64_
                          obj = AllocateObject(pByValueClass->GetMethodTable());
#ifndef _IA64_
                      } 
                    COMPLUS_CATCH
                      {
                          hr = COR_E_TYPELOAD;
                          UpdateThrowable(bmtError->pThrowable);
                          break;
                      }
                    COMPLUS_END_CATCH
#endif !_IA64_

                    SetObjectReference( apObjRefs[ipObjRefs], obj, 
                                        (AppDomain*) bmtInternal->pModule->GetDomain() );

                    // initialize static addres with object ref to boxed value type
                    void *pStaticAddress = (void*)((BYTE*)pField->GetBase() + pField->GetOffset()); 
                    *(void**)pStaticAddress = (void*)apObjRefs[ipObjRefs++];
                }
                else if (m_pFieldDescList[dwIndex].GetFieldType() == ELEMENT_TYPE_CLASS)
                {
                    // initialize static addres with object ref
                    void *pStaticAddress = (void*)((BYTE*)pField->GetBase() + pField->GetOffset()); 
                    *(void**)pStaticAddress = (void*)apObjRefs[ipObjRefs++];
                }
            }

            delete []apObjRefs;

            END_ENSURE_COOPERATIVE_GC();
        }
        else
        {
            // 
            // For shared classes, we don't allocate any handles 
            // in the method table (since statics live in DLS), 
            // but we do store information about what handles need to be
            // allocated later on.  This information goes where the
            // statics themselves (in non-shared types) would go.
            // This allows us to later initialize the DLS version of the
            // statics without bringing the FieldDescs into the working set.
            //
            
            FieldDesc *pField = m_pFieldDescList + bmtEnumMF->dwNumInstanceFields;
            FieldDesc *pFieldEnd = pField + bmtEnumMF->dwNumStaticFields;
            for (; pField < pFieldEnd; pField++)
            {
                _ASSERTE(pField->IsStatic());

                if(!pField->IsSpecialStatic()) {
                    MethodTable *pMT;
                    void *addr;
                    switch (pField->GetFieldType())
                    {
                    case ELEMENT_TYPE_CLASS:
                        addr = (BYTE *) GetMethodTable()->m_Vtable + 
                            bmtVT->dwCurrentNonVtableSlot*sizeof(SLOT*) + pField->GetOffset();
                        *(MethodTable**)addr = (MethodTable *) NULL;
                        break;
                        
                    case ELEMENT_TYPE_VALUETYPE:
                        pMT = (*pByValueClassCache)[pField - m_pFieldDescList]->GetMethodTable();
                        _ASSERTE(pMT->IsValueClass());
                        addr = (BYTE *) GetMethodTable()->m_Vtable + 
                            bmtVT->dwCurrentNonVtableSlot*sizeof(SLOT*) + pField->GetOffset();
                        *(MethodTable**)addr = pMT;
                        break;
                        
                    default:
                        break;
                    }
                }
            }
        }
    }

    return hr;
}

//
// Used by BuildMethodTable
//
// If we have a non-interface class, then do inheritance security
// checks on it. The check starts by checking for inheritance
// permission demands on the current class. If these first checks
// succeeded, then the cached declared method list is scanned for
// methods that have inheritance permission demands.
//

HRESULT EEClass::VerifyInheritanceSecurity(bmtInternalInfo* bmtInternal, bmtErrorInfo* bmtError, bmtParentInfo* bmtParent, bmtEnumMethAndFields* bmtEnumMF)
{
    HRESULT hr = S_OK;

    // If we have a non-interface class, then do inheritance security
    // checks on it. The check starts by checking for inheritance
    // permission demands on the current class. If these first checks
    // succeeded, then the cached declared method list is scanned for
    // methods that have inheritance permission demands.
    if (!IsInterface() && (bmtInternal->pModule->IsSystemClasses() == FALSE) &&
        Security::IsSecurityOn())
    {
        //We need to disable preemptive GC if there's any chance that it could still be
        //active.  The inheritance checks might allocate objects.
        BEGIN_ENSURE_COOPERATIVE_GC();

        //@ASSUMPTION: The current class has been resolved to the point that
        // we can construct a reflection object on the class or its methods.
        // This is required for the security checks.

        // Check the entire parent chain for inheritance permission demands.
        EEClass *pParentClass = GetParentClass();
        while (pParentClass != NULL)
        {
            if (pParentClass->RequiresInheritanceCheck() &&
                ! Security::ClassInheritanceCheck(this, pParentClass, bmtError->pThrowable) )
            {
                bmtError->resIDWhy = IDS_CLASSLOAD_INHERITANCECHECK;
                IfFailGoto(COR_E_TYPELOAD, reenable_gc);
            }

            pParentClass = pParentClass->GetParentClass();
        }


        if (GetParentClass() != NULL)
        {
            bmtParent->ppParentMethodDescBufPtr = bmtParent->ppParentMethodDescBuf;
            for (DWORD i = 0; i < bmtEnumMF->dwNumDeclaredMethods; i++)
            {
                // Check the entire chain of overridden methods for
                // inheritance permission demands.
                MethodDesc *pParent = *(bmtParent->ppParentMethodDescBufPtr++);
                MethodDesc *pMethod = *(bmtParent->ppParentMethodDescBufPtr++);

                _ASSERTE(pMethod != NULL);

                if (pParent != NULL)
                {
                    // Get the name and signature for the method so
                    // we can find the new parent method desc.
                    DWORD       dwSlot;

                    dwSlot = pParent->GetSlot();

#ifdef _DEBUG
                    LPCUTF8     szName;
                    PCCOR_SIGNATURE pSignature;
                    DWORD       cSignature;
                    szName = bmtInternal->pInternalImport->GetNameOfMethodDef(pMethod->GetMemberDef());
                    
                    if (szName == NULL)
                    {
                        _ASSERTE(0);
                        IfFailGoto(COR_E_TYPELOAD, reenable_gc);
                    }
                    
                    pSignature = bmtInternal->pInternalImport->GetSigOfMethodDef(
                        pMethod->GetMemberDef(),
                        &cSignature);
#endif

                    do
                    {
                        if (pParent->RequiresInheritanceCheck() &&
                            ! Security::MethodInheritanceCheck(pMethod, pParent, bmtError->pThrowable) )
                        {
                            bmtError->resIDWhy = IDS_CLASSLOAD_INHERITANCECHECK;
                            IfFailGoto(COR_E_TYPELOAD, reenable_gc);
                        }

                        if (pParent->ParentRequiresInheritanceCheck())
                        {
                            EEClass *pParentClass = pParent->GetClass()->GetParentClass();

                            // Find this method in the parent.
                            // If it does exist in the parent, it would be at the same vtable slot.
                            if (dwSlot >= GetParentClass()->GetNumVtableSlots())
                            {
                                // Parent does not have this many vtable slots, so it doesn't exist there
                                pParent = NULL;
                            }
                            else
                            {
                                // It is in the vtable of the parent
                                pParent = pParentClass->GetUnknownMethodDescForSlot(dwSlot);
                                _ASSERTE(pParent != NULL);

#ifdef _DEBUG
                                _ASSERTE(pParent == pParentClass->FindMethod(
                                    szName,
                                    pSignature,
                                    cSignature,
                                    bmtInternal->pModule,
                                    mdTokenNil
                                    ));
#endif
                            }
                        }
                        else
                        {
                            pParent = NULL;
                        }
                    } while (pParent != NULL);
                }
            }
        }
reenable_gc:
        END_ENSURE_COOPERATIVE_GC();

        if (FAILED(hr)){
            return hr;
        }
    }


    return hr;
}

//
// Used by BuildMethodTable
//
// Now that the class is ready, fill out the RID maps
//

HRESULT EEClass::FillRIDMaps(bmtMethAndFieldDescs* bmtMFDescs, bmtMetaDataInfo* bmtMetaData, bmtInternalInfo* bmtInternal)
{
    HRESULT hr = S_OK;
    DWORD i;

    // Now that the class is ready, fill out the RID maps
    if (bmtMFDescs->ppUnboxMethodDescList != NULL)
    {
        // We're a value class
        // Make sure to add the unboxed version to the RID map
        for (i = 0; i < bmtMetaData->cMethods; i++)
        {
            if (bmtMFDescs->ppUnboxMethodDescList[i] != NULL)
                (void) bmtInternal->pModule->StoreMethodDef(bmtMetaData->pMethods[i],
                                                            bmtMFDescs->ppUnboxMethodDescList[i]);
            else
                (void) bmtInternal->pModule->StoreMethodDef(bmtMetaData->pMethods[i],
                                                            bmtMFDescs->ppMethodDescList[i]);
        }
    }
    else
    {
        // Not a value class
        for (i = 0; i < bmtMetaData->cMethods; i++)
        {
            (void) bmtInternal->pModule->StoreMethodDef(bmtMetaData->pMethods[i],
                                                        bmtMFDescs->ppMethodDescList[i]);
        }
    }

    for (i = 0; i < bmtMetaData->cFields; i++)
    {
        (void) bmtInternal->pModule->StoreFieldDef(bmtMetaData->pFields[i],
                                                    bmtMFDescs->ppFieldDescList[i]);
    }

    return hr;
}


MethodDesc* EEClass::GetMethodDescForSlot(DWORD slot)
{
    _ASSERTE(!IsThunking());
    return(GetUnknownMethodDescForSlot(slot));
}

/* Given the value class method, find the unboxing Stub for the given method */
MethodDesc* EEClass::GetUnboxingMethodDescForValueClassMethod(MethodDesc *pMD)
{
    _ASSERTE(IsValueClass());
    _ASSERTE(!pMD->IsUnboxingStub());

    for (int i = GetNumVtableSlots() - 1; i >= 0; i--) {
        // Get the MethodDesc for current method
        MethodDesc* pCurMethod = GetUnknownMethodDescForSlot(i);
        if (pCurMethod && pCurMethod->IsUnboxingStub()) {
            if ((pCurMethod->GetMemberDef() == pMD->GetMemberDef())  &&
                (pCurMethod->GetModule() == pMD->GetModule())) {
                return pCurMethod;
            }
        }
    }

    return NULL;
}

/* Given the unboxing value class method, find the non-unboxing method */
MethodDesc* EEClass::GetMethodDescForUnboxingValueClassMethod(MethodDesc *pMD)
{
    _ASSERTE(IsValueClass());
    _ASSERTE(pMD->IsUnboxingStub());

    for (int i = m_wNumMethodSlots - 1; i >= GetNumVtableSlots(); i--) {
        // Get the MethodDesc for current method
        MethodDesc* pCurMethod = GetUnknownMethodDescForSlot(i);
        if (pCurMethod && !pCurMethod->IsUnboxingStub()) {
            if ((pCurMethod->GetMemberDef() == pMD->GetMemberDef())  &&
                (pCurMethod->GetModule() == pMD->GetModule())) {
                return pCurMethod;
            }
        }
    }

    return NULL;
}

SLOT EEClass::GetFixedUpSlot(DWORD slot)
{
    _ASSERTE(slot >= 0);

    SLOT *s = m_pMethodTable->GetVtable();

    SLOT addr = s[slot];

    // 
    // Make sure we're not pointing to a jump target
    //

    if (GetModule()->IsJumpTargetTableEntry(addr))
        return GetModule()->FixupInheritedSlot(GetMethodTable(), slot);
    else
        return addr;
}

MethodDesc* EEClass::GetUnknownMethodDescForSlot(DWORD slot)
{
    _ASSERTE(slot >= 0);
        // DO: Removed because reflection can reflect on this
    //_ASSERTE(!IsThunking());

    return GetUnknownMethodDescForSlotAddress(GetFixedUpSlot(slot));
}


MethodDesc* EEClass::GetUnknownMethodDescForSlotAddress(SLOT addr)
{
    IJitManager * pJM = ExecutionManager::FindJitMan(addr);

    if (pJM)
        // Since we are walking in the class these should be methods so the cast should be valid
        return (MethodDesc*)pJM->JitCode2MethodDesc(addr);

    const BYTE *addrOfCode = (const BYTE*)(addr);
    if (UpdateableMethodStubManager::CheckIsStub(addrOfCode, &addrOfCode)) {
        pJM = ExecutionManager::FindJitMan((SLOT)addrOfCode);
        _ASSERTE(pJM);
        return (MethodDesc*)pJM->JitCode2MethodDesc((SLOT)addrOfCode);
    }

    // Is it an FCALL? 
    MethodDesc* ret = MapTargetBackToMethod((VOID*) addr);
    if (ret != 0) {
        _ASSERTE(ret->GetUnsafeAddrofCode() == addrOfCode);
        return(ret);
    }
    
    ret = (MethodDesc*) (addrOfCode + METHOD_CALL_PRESTUB_SIZE);
    _ASSERTE(ret->m_pDebugMethodTable == NULL || ret->m_pDebugEEClass == ret->m_pDebugMethodTable->GetClass());
    return(ret);
}

DWORD  MethodTable::GetStaticSize()
{
    DWORD count = (DWORD)((BYTE*) m_pIMap - (BYTE*) &m_Vtable[m_cbSlots]);

#ifdef _DEBUG
    count -= sizeof(InterfaceInfo_t);
    if (HasDynamicInterfaceMap())
        count -= sizeof(DWORD);
#endif

    return count;
}

// Notice whether this class requires finalization
void MethodTable::MaybeSetHasFinalizer()
{
    _ASSERTE(!HasFinalizer());      // one shot

    // This method is called after we've built the MethodTable.  Since we always
    // load parents before children, this also guarantees that g_pObjectClass is
    // loaded (though the variable may not have been initialized yet if we are
    // just finishing the load of "Object".
    if (g_pObjectClass && !IsInterface() && !IsValueClass())
    {
        WORD    slot = s_FinalizerMD->GetSlot();

        // Structs and other objects not derived from Object will get marked as
        // having a finalizer, if they have sufficient virtual methods.  This will
        // only be an issue if they can be allocated in the GC heap (which will
        // cause all sorts of other problems).
        //
        // We are careful to check that we have a method that is distinct from both
        // the JITted and unJITted (prestub) addresses of Object's Finalizer.
        if ((GetClass()->GetNumVtableSlots() >= slot) &&
            (GetVtable() [slot] != s_FinalizerMD->GetPreStubAddr()) &&
            (GetVtable() [slot] != s_FinalizerMD->GetAddrofCode()))
        {
            m_wFlags |= enum_flag_HasFinalizer;
        }
    }
}


// From the GC finalizer thread, invoke the Finalize() method on an object.
void MethodTable::CallFinalizer(Object *obj)
{
    COMPLUS_TRY
    {
        // There's no reason to actually set up a frame here.  If we crawl out of the
        // Finalize() method on this thread, we will see FRAME_TOP which indicates
        // that the crawl should terminate.  This is analogous to how KickOffThread()
        // starts new threads in the runtime.
        __try
        {
            SLOT funcPtr = obj->GetMethodTable()->GetVtable() [s_FinalizerMD->GetSlot()];

#ifdef DEBUGGING_SUPPORTED
            if (CORDebuggerTraceCall())
                g_pDebugInterface->TraceCall((const BYTE *) funcPtr);

#endif // DEBUGGING_SUPPORTED

#ifdef _X86_
            INSTALL_COMPLUS_EXCEPTION_HANDLER();
            __asm
            {
                mov     ecx, [obj]
                call    [funcPtr]
                INDEBUG(nop)            // Mark the fact that we can call managed code
            }
            UNINSTALL_COMPLUS_EXCEPTION_HANDLER();
#else
            INT64 arg = (INT64)obj;
            s_FinalizerMD->Call(&arg);
#endif
        } 
        __except(ThreadBaseExceptionFilter(GetExceptionInformation(),
                                           GetThread(),
                                           FinalizerThread)) 
        {
            _ASSERTE(!"ThreadBaseExceptionFilter returned EXCEPTION_EXECUTE_HANDLER");
        }
    }
    COMPLUS_CATCH
    {
        // quietly swallow all errors
        Thread* pCurThread = GetThread(); 
        _ASSERTE(GCHeap::GetFinalizerThread() == pCurThread);
        if (pCurThread->IsAbortRequested())
            pCurThread->UserResetAbort();
    }
    COMPLUS_END_CATCH
}


// Set up the system to support finalization
void MethodTable::InitForFinalization()
{
    _ASSERTE(s_FinalizerMD == 0);

    s_FinalizerMD = g_Mscorlib.GetMethod(METHOD__OBJECT__FINALIZE);
}


// Release resources associated with supporting finalization
#ifdef SHOULD_WE_CLEANUP
void MethodTable::TerminateForFinalization()
{
    s_FinalizerMD = 0;
}
#endif /* SHOULD_WE_CLEANUP */


//
// Finds a method by name and signature, where scope is the scope in which the signature is defined.
//
MethodDesc *EEClass::FindMethod(LPCUTF8 pszName, 
                                PCCOR_SIGNATURE pSignature, 
                                DWORD cSignature, 
                                Module* pModule, 
                                DWORD requiredAttributes,
                                MethodTable *pDefMT, 
                                BOOL bCaseSensitive, 
                                TypeHandle typeHnd)
{
    signed long i;

    _ASSERTE(!IsThunking());

    // Retrive the right comparition function to use.
    UTF8StringCompareFuncPtr StrCompFunc = bCaseSensitive ? strcmp : _stricmp;

        // shared method tables (arrays) need to pass instantiation information too
    TypeHandle  typeVarsBuff;
    TypeHandle* typeVars = 0;
    if (IsArrayClass() && !typeHnd.IsNull()) {
        typeVarsBuff = typeHnd.AsTypeDesc()->GetTypeParam();
        typeVars = &typeVarsBuff;
    }

    // Statistically it's most likely for a method to be found in non-vtable portion of this class's members, then in the
    // vtable of this class's declared members, then in the inherited portion of the vtable, so we search backwards.

    // For value classes, if it's a value class method, we want to return the duplicated MethodDesc, not the one in the vtable
    // section.  We'll find the one in the duplicate section before the one in the vtable section, so we're ok.

    // Search non-vtable portion of this class first
    if (pDefMT)
    {
        for (i = m_wNumMethodSlots-1; i >= 0; i--)
        {
            MethodDesc *pCurMethod = GetUnknownMethodDescForSlot(i);
            if (!pCurMethod)
                continue;

            if (pCurMethod->IsMethodImpl())
            {
                MethodImpl* data = MethodImpl::GetMethodImplData(pCurMethod);
                _ASSERTE(data && "This method should be a method impl");

                MethodDesc **apImplementedMDs = data->GetImplementedMDs();
                DWORD *aSlots = data->GetSlots();
                for (DWORD iMethImpl = 0; iMethImpl < data->GetSize(); iMethImpl++)
                {
                    MethodDesc *pCurImplMD = apImplementedMDs[iMethImpl];

                    // Prejitted images may leave NULL in this table if
                    // the methoddesc is declared in another module.
                    // In this case we need to manually compute & restore it
                    // from the slot number.

                    if (pCurImplMD == NULL)
                        pCurImplMD = data->RestoreSlot(iMethImpl, GetMethodTable()); 

                    if (pCurImplMD->GetMethodTable() == pDefMT && StrCompFunc(pszName, pCurImplMD->GetName((USHORT) aSlots[iMethImpl])) == 0)
                    {
                        PCCOR_SIGNATURE pCurMethodSig;
                        DWORD       cCurMethodSig;

                        pCurImplMD->GetSig(&pCurMethodSig, &cCurMethodSig);
                        
                        if (MetaSig::CompareMethodSigs(pSignature, cSignature, pModule, 
                                                       pCurMethodSig, cCurMethodSig, 
                                                       pCurImplMD->GetModule(), typeVars) &&
                            (IsNilToken(requiredAttributes) || 
                             (requiredAttributes & pCurMethod->GetAttrs()) == requiredAttributes))
                            return pCurMethod;
                    }
                }
            }
            else
            {
                PCCOR_SIGNATURE pCurMethodSig;
                DWORD       cCurMethodSig;

                if (StrCompFunc(pszName, pCurMethod->GetName((USHORT) i)) == 0)
                {
                    pCurMethod->GetSig(&pCurMethodSig, &cCurMethodSig);

                    // Not in vtable section, so don't worry about value classes
                    if (MetaSig::CompareMethodSigs(pSignature, cSignature, pModule, pCurMethodSig, cCurMethodSig, pCurMethod->GetModule(), typeVars) &&
                        (IsNilToken(requiredAttributes) || 
                         (requiredAttributes & pCurMethod->GetAttrs()) == requiredAttributes))
                        return pCurMethod;
                }
            }
        }
    }
    else
    {
        for (i = m_wNumMethodSlots-1; i >= 0; i--)
        {
            MethodDesc *pCurMethod = GetUnknownMethodDescForSlot(i);

            if ((pCurMethod != NULL) && (StrCompFunc(pszName, pCurMethod->GetName((USHORT) i)) == 0))
            {
                PCCOR_SIGNATURE pCurMethodSig;
                DWORD       cCurMethodSig;

                pCurMethod->GetSig(&pCurMethodSig, &cCurMethodSig);

                // Not in vtable section, so don't worry about value classes
                if (MetaSig::CompareMethodSigs(pSignature, cSignature, pModule, pCurMethodSig, cCurMethodSig, pCurMethod->GetModule(), typeVars) &&
                    (IsNilToken(requiredAttributes) || 
                     (requiredAttributes & pCurMethod->GetAttrs()) == requiredAttributes))
                    return pCurMethod;
            }
        }
    }

    if (IsValueClass()) {
            // we don't allow inheritance on value type (yet)
        _ASSERTE(!GetParentClass() || !GetParentClass()->IsValueClass());
        return NULL;
    }

    // Recurse up the hierarchy if the method was not found.
    //@todo: This routine might be factored slightly to improve perf.
    _ASSERTE(IsRestored());

    if (GetParentClass() != NULL)
    {
        MethodDesc *md = GetParentClass()->FindMethod(pszName, pSignature, cSignature, pModule,
                                                      requiredAttributes, NULL, bCaseSensitive, typeHnd);
        
        // Don't inherit constructors from parent classes.  It is important to forbid this,
        // because the JIT needs to get the class handle from the memberRef, and when the
        // constructor is inherited, the JIT will get the class handle for the parent class
        // (and not allocate enough space, etc.).  See bug #50035 for details.
        if (md)
        {
            _ASSERTE(strcmp(pszName, md->GetName()) == 0);
            if (IsMdInstanceInitializer(md->GetAttrs(), pszName))
            {
                md = NULL;
            }
        }

        return md;
    }

    return NULL;
}

//
// Are more optimised case if we are an interface - we know that the vtable won't be pointing to JITd code
// EXCEPT when it's a <clinit>
//
MethodDesc *EEClass::InterfaceFindMethod(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, DWORD *slotNum, BOOL bCaseSensitive)
{
    DWORD i;
    SLOT* s = m_pMethodTable->GetVtable();

    _ASSERTE(!IsThunking());

    // Retrive the right comparition function to use.
    UTF8StringCompareFuncPtr StrCompFunc = bCaseSensitive ? strcmp : _stricmp;

    // This cannot be a clinit
    for (i = 0; i < GetNumVtableSlots(); i++)
    {
        MethodDesc *pCurMethod = (MethodDesc*) (((BYTE*)s[i]) + METHOD_CALL_PRESTUB_SIZE);

        _ASSERTE(pCurMethod != NULL);

        if (StrCompFunc(pszName, pCurMethod->GetNameOnNonArrayClass()) == 0)
        {
            PCCOR_SIGNATURE pCurMethodSig;
            DWORD       cCurMethodSig;

            pCurMethod->GetSig(&pCurMethodSig, &cCurMethodSig);

            if (MetaSig::CompareMethodSigs(pSignature, cSignature, pModule, pCurMethodSig, cCurMethodSig, pCurMethod->GetModule()))
            {
                *slotNum = i;
                return pCurMethod;
            }
        }
    }

    // One can be a clinit
    for (i = GetNumVtableSlots(); i < m_wNumMethodSlots; i++)
    {
        MethodDesc *pCurMethod = (MethodDesc*) GetUnknownMethodDescForSlot(i);

        _ASSERTE(pCurMethod != NULL);

        if (StrCompFunc(pszName, pCurMethod->GetNameOnNonArrayClass()) == 0)
        {
            PCCOR_SIGNATURE pCurMethodSig;
            DWORD       cCurMethodSig;

            pCurMethod->GetSig(&pCurMethodSig, &cCurMethodSig);

            if (MetaSig::CompareMethodSigs(pSignature, cSignature, pModule, pCurMethodSig, cCurMethodSig, pCurMethod->GetModule()))
            {
                *slotNum = i;
                return pCurMethod;
            }
        }
    }

    return NULL;
}


MethodDesc *EEClass::FindMethod(LPCUTF8 pwzName, LPHARDCODEDMETASIG pwzSignature, MethodTable *pDefMT, BOOL bCaseSensitive)
{
    PCCOR_SIGNATURE pBinarySig;
    ULONG       cbBinarySigLength;

    _ASSERTE(!IsThunking());

    if (FAILED(pwzSignature->GetBinaryForm(&pBinarySig, &cbBinarySigLength )))
    {
        return NULL;
    }

    return FindMethod(pwzName, pBinarySig, cbBinarySigLength, SystemDomain::SystemModule(), 
                      mdTokenNil, pDefMT, bCaseSensitive);
}


MethodDesc *EEClass::FindMethod(mdMethodDef mb)
{
    _ASSERTE(!IsThunking());

    // We have the EEClass (this) and so lets just look this up in the ridmap.
    MethodDesc *pDatum = NULL;

    if (TypeFromToken(mb) == mdtMemberRef)
        pDatum = GetModule()->LookupMemberRefAsMethod(mb);
    else
        pDatum = GetModule()->LookupMethodDef(mb);

    if (pDatum != NULL)
        pDatum->GetMethodTable()->CheckRestore();

    if (pDatum != NULL)
        return pDatum;
    else
        return NULL;
}


MethodDesc *EEClass::FindPropertyMethod(LPCUTF8 pszName, EnumPropertyMethods Method, BOOL bCaseSensitive)
{
    _ASSERTE(!IsThunking());
    _ASSERTE(!IsArrayClass());

    // @TODO (DM): Retrieve the property setter from the metadata.

    // Retrive the right comparition function to use.
    UTF8StringCompareFuncPtr StrCompFunc = bCaseSensitive ? strcmp : _stricmp;

    // The format strings for the getter and setter. These must stay in synch with the 
    // EnumPropertyMethods enum defined in class.h
    static LPCUTF8 aFormatStrings[] = 
    {
        "get_%s",
        "set_%s"
    };

    LPUTF8 strMethName = (LPUTF8)_alloca(strlen(pszName) + strlen(aFormatStrings[Method]) + 1);
    sprintf(strMethName, aFormatStrings[Method], pszName);

    // Scan all classes in the hierarchy, starting at the current class and
    // moving back up towards the base. This is necessary since non-virtual
    // properties won't be copied down into the method table for derived
    // classes.
    for (EEClass *pClass = this; pClass; pClass = pClass->GetParentClass())
    {
        for (int i = pClass->m_wNumMethodSlots-1; i >= 0; i--)
        {
            MethodDesc *pCurMethod = pClass->GetUnknownMethodDescForSlot(i);
            if ((pCurMethod != NULL) && (StrCompFunc(strMethName, pCurMethod->GetNameOnNonArrayClass()) == 0))
                return pCurMethod;
        }
    }

    return NULL;
}


MethodDesc *EEClass::FindEventMethod(LPCUTF8 pszName, EnumEventMethods Method, BOOL bCaseSensitive)
{
    _ASSERTE(!IsThunking());
    _ASSERTE(!IsArrayClass());

    // @TODO (DM): Retrieve the property setter from the metadata.

    // Retrive the right comparition function to use.
    UTF8StringCompareFuncPtr StrCompFunc = bCaseSensitive ? strcmp : _stricmp;

    // The format strings for the getter and setter. These must stay in synch with the 
    // EnumPropertyMethods enum defined in class.h
    static LPCUTF8 aFormatStrings[] = 
    {
        "add_%s",
        "remove_%s",
        "raise_%s"
    };

    LPUTF8 strMethName = (LPUTF8)_alloca(strlen(pszName) + strlen(aFormatStrings[Method]) + 1);
    sprintf(strMethName, aFormatStrings[Method], pszName);

    // Scan all classes in the hierarchy, starting at the current class and
    // moving back up towards the base. This is necessary since non-virtual
    // event methods won't be copied down into the method table for derived
    // classes.
    for (EEClass *pClass = this; pClass; pClass = pClass->GetParentClass())
    {
        for (int i = pClass->m_wNumMethodSlots-1; i >= 0; i--)
        {
            MethodDesc *pCurMethod = pClass->GetUnknownMethodDescForSlot(i);
            if ((pCurMethod != NULL) && (StrCompFunc(strMethName, pCurMethod->GetNameOnNonArrayClass()) == 0))
                return pCurMethod;
        }
    }

    return NULL;
}


MethodDesc *EEClass::FindMethodByName(LPCUTF8 pszName, BOOL bCaseSensitive)
{
    _ASSERTE(!IsThunking());
    _ASSERTE(!IsArrayClass());

    // Retrive the right comparition function to use.
    UTF8StringCompareFuncPtr StrCompFunc = bCaseSensitive ? strcmp : _stricmp;

    // Scan all classes in the hierarchy, starting at the current class and
    // moving back up towards the base. 
    for (EEClass *pClass = this; pClass; pClass = pClass->m_pParentClass)
    {
        for (int i = pClass->m_wNumMethodSlots-1; i >= 0; i--)
        {
            MethodDesc *pCurMethod = pClass->GetUnknownMethodDescForSlot(i);
            if ((pCurMethod != NULL) && (StrCompFunc(pszName, pCurMethod->GetName((USHORT) i)) == 0))
                return pCurMethod;
        }
    }

    return NULL;

}


FieldDesc *EEClass::FindField(LPCUTF8 pszName, LPHARDCODEDMETASIG pszSignature, BOOL bCaseSensitive)
{
    PCCOR_SIGNATURE pBinarySig;
    ULONG       cbBinarySigLength;

    // The following assert is very important, but we need to special case it enough
    // to allow us access to the legitimate fields of a context proxy object.
    _ASSERTE(!IsThunking() ||
             !strcmp(pszName, "actualObject") ||
             !strcmp(pszName, "contextID") ||
             !strcmp(pszName, "_rp") ||
             !strcmp(pszName, "_stubData") ||
             !strcmp(pszName, "_pMT") ||
             !strcmp(pszName, "_pInterfaceMT") || 
             !strcmp(pszName, "_stub"));

    if (FAILED(pszSignature->GetBinaryForm(&pBinarySig, &cbBinarySigLength)))
    {
        return NULL;
    }

    return FindField(pszName, pBinarySig, cbBinarySigLength, SystemDomain::SystemModule(), bCaseSensitive);
}


FieldDesc *EEClass::FindField_Int(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, BOOL bCaseSensitive)
{
    DWORD       i;
    DWORD       dwFieldDescsToScan;
    IMDInternalImport *pInternalImport = GetMDImport(); // All explicitly declared fields in this class will have the same scope

    _ASSERTE(IsRestored());

    // Retrive the right comparition function to use.
    UTF8StringCompareFuncPtr StrCompFunc = bCaseSensitive ? strcmp : _stricmp;

    // The following assert is very important, but we need to special case it enough
    // to allow us access to the legitimate fields of a context proxy object.
    _ASSERTE(!IsThunking() ||
             !strcmp(pszName, "actualObject") ||
             !strcmp(pszName, "contextID") ||
             !strcmp(pszName, "_rp") ||
             !strcmp(pszName, "_stubData") ||
             !strcmp(pszName, "_pMT") ||
             !strcmp(pszName, "_pInterfaceMT") ||
             !strcmp(pszName, "_stub") );

    // Array classes don't have fields, and don't have metadata
    if (IsArrayClass())
        return NULL;

    // Scan the FieldDescs of this class
    if (GetParentClass() != NULL)
        dwFieldDescsToScan = m_wNumInstanceFields - GetParentClass()->m_wNumInstanceFields + m_wNumStaticFields;
    else
        dwFieldDescsToScan = m_wNumInstanceFields + m_wNumStaticFields;

    for (i = 0; i < dwFieldDescsToScan; i++)
    {
        LPCUTF8     szMemberName;
        FieldDesc * pFD = &m_pFieldDescList[i];
        mdFieldDef  mdField = pFD->GetMemberDef();

        // Check is valid FieldDesc, and not some random memory
        _ASSERTE(pFD->GetMethodTableOfEnclosingClass()->GetClass()->GetMethodTable() ==
                 pFD->GetMethodTableOfEnclosingClass());

        szMemberName = pInternalImport->GetNameOfFieldDef(mdField);

        if (StrCompFunc(szMemberName, pszName) == 0)
        {
            PCCOR_SIGNATURE pMemberSig;
            DWORD       cMemberSig;

            pMemberSig = pInternalImport->GetSigOfFieldDef(
                mdField,
                &cMemberSig
            );

            if (MetaSig::CompareFieldSigs(
                pMemberSig,
                cMemberSig,
                GetModule(),
                pSignature,
                cSignature,
                pModule))
            {
                return pFD;
            }
        }
    }

    return NULL;
}


FieldDesc *EEClass::FindFieldInherited(LPCUTF8 pzName, LPHARDCODEDMETASIG pzSignature, BOOL bCaseSensitive)
{
    PCCOR_SIGNATURE pBinarySig;
    ULONG       cbBinarySigLength;

    _ASSERTE(!IsThunking());

    if (FAILED(pzSignature->GetBinaryForm(&pBinarySig, &cbBinarySigLength )))
    {
        return NULL;
    }

    return FindFieldInherited(pzName, pBinarySig, cbBinarySigLength, 
                              SystemDomain::SystemModule(), bCaseSensitive);
}


FieldDesc *EEClass::FindFieldInherited(LPCUTF8 pszName, PCCOR_SIGNATURE pSignature, DWORD cSignature, Module* pModule, BOOL bCaseSensitive)
{
    EEClass     *pClass = this;
    FieldDesc   *pFD;

    _ASSERTE(IsRestored());

    // The following assert is very important, but we need to special case it enough
    // to allow us access to the legitimate fields of a context proxy object.
    _ASSERTE(!IsThunking() ||
             !strcmp(pszName, "actualObject") ||
             !strcmp(pszName, "contextID") ||
             !strcmp(pszName, "_rp") ||
             !strcmp(pszName, "_stubData") ||
             !strcmp(pszName, "_pMT") ||
             !strcmp(pszName, "_pInterfaceMT") ||
             !strcmp(pszName, "_stub"));

    while (pClass != NULL)
    {
        pFD = pClass->FindField_Int(pszName, pSignature, cSignature, pModule, bCaseSensitive);
        if (pFD != NULL)
            return pFD;

        pClass = pClass->GetParentClass();
    }
    return NULL;
}


MethodDesc *EEClass::FindConstructor(LPHARDCODEDMETASIG pwzSignature)
{
    PCCOR_SIGNATURE pBinarySig;
    ULONG       cbBinarySigLength;

    if (FAILED(pwzSignature->GetBinaryForm(&pBinarySig, &cbBinarySigLength )))
    {
        return NULL;
    }

    return FindConstructor(pBinarySig, cbBinarySigLength, SystemDomain::SystemModule());
}


MethodDesc *EEClass::FindConstructor(PCCOR_SIGNATURE pSignature,DWORD cSignature, Module* pModule)
{
    SLOT *      pVtable;
    DWORD       i;

    //_ASSERTE(!IsThunking());

    // Array classes don't have metadata
    if (IsArrayClass())
        return NULL;

    pVtable = GetVtable();
    DWORD dwCurMethodAttrs;
    for (i = GetNumVtableSlots(); i < m_wNumMethodSlots; i++)
    {
        PCCOR_SIGNATURE pCurMethodSig;
        DWORD       cCurMethodSig;
        MethodDesc *pCurMethod = GetUnknownMethodDescForSlot(i);
        if (pCurMethod == NULL)
            continue;

        dwCurMethodAttrs = pCurMethod->GetAttrs();
        if(!IsMdRTSpecialName(dwCurMethodAttrs))
            continue;

        // Don't want class initializers.
        if (IsMdStatic(dwCurMethodAttrs))
            continue;

        // Find only the constructor for for this object
        _ASSERTE(pCurMethod->GetMethodTable() == this->GetMethodTable());

        pCurMethod->GetSig(&pCurMethodSig, &cCurMethodSig);
        if (MetaSig::CompareMethodSigs(pSignature, cSignature, pModule, pCurMethodSig, cCurMethodSig, pCurMethod->GetModule()))
            return pCurMethod;
    }

    return NULL;
}

void EEClass::SetupCoClassAttribInfo()
{
    THROWSCOMPLUSEXCEPTION();

    if(IsComClassInterface() == 0)
        return;
    
    _ASSERTE(IsInterface());
    TypeHandle CoClassType;
    AppDomain *pCurrDomain = SystemDomain::GetCurrentDomain();
    OBJECTREF pThrowable = NULL;
    const BYTE *pVal = NULL;
    ULONG cbVal = 0;
    ULONG cbcb = 0;
    ULONG cbStr = 0;
    CQuickArray<CHAR> qbClassName;

    HRESULT hr = GetMDImport()->GetCustomAttributeByName(GetCl(), "System.Runtime.InteropServices.CoClassAttribute" , (const void**)&pVal, &cbVal);
    if (hr == S_OK)
    {
        BEGIN_ENSURE_COOPERATIVE_GC();
        // Skip the CA type prefix.
        pVal += 2;

        // Retrieve the COM source interface class name.
        cbcb = CorSigUncompressData((PCCOR_SIGNATURE)pVal, (ULONG*)&cbStr);
        pVal += cbcb;

        // Copy the name to a temporary buffer and NULL terminate it.
        IfFailThrow(qbClassName.ReSize(cbStr + 1));
        memcpyNoGCRefs(qbClassName.Ptr(), pVal, cbStr);
        qbClassName[cbStr] = 0;
        pVal += cbStr;

        // Try to load the class using its name as a fully qualified name. If that fails, 
        // then we try to load it in the assembly of the current class.
        GCPROTECT_BEGIN(pThrowable);
        {
            CoClassType = pCurrDomain->FindAssemblyQualifiedTypeHandle(qbClassName.Ptr(), true, GetAssembly(), NULL, &pThrowable);
            if (CoClassType.IsNull())
                COMPlusThrow(pThrowable);
        }
        GCPROTECT_END();
        END_ENSURE_COOPERATIVE_GC();

        // Set the source interface and event provider classes.
        m_pCoClassForIntf = CoClassType.GetClass();        
    }
}

void EEClass::GetCoClassAttribInfo()
{
    const BYTE *pVal = NULL;
    ULONG cbVal = 0;

    // Retrieve the CoClassAttribute CA.
    HRESULT hr = GetMDImport()->GetCustomAttributeByName(GetCl(), INTEROP_COCLASS_TYPE, (const void**)&pVal, &cbVal);
    if (hr == S_OK)
        SetIsComClassInterface();
}

void EEClass::GetEventInterfaceInfo(EEClass **ppSrcItfClass, EEClass **ppEvProvClass)
{
    THROWSCOMPLUSEXCEPTION();

    TypeHandle EventProvType;
    TypeHandle SrcItfType;
    AppDomain *pCurrDomain = SystemDomain::GetCurrentDomain();
    OBJECTREF pThrowable = NULL;
    const BYTE *pVal = NULL;
    ULONG cbVal = 0;
    ULONG cbcb = 0;
    ULONG cbStr = 0;
    CQuickArray<CHAR> qbClassName;

    // Retrieve the ComEventProviderAttribute CA.
    HRESULT hr = GetMDImport()->GetCustomAttributeByName(GetCl(), INTEROP_COMEVENTINTERFACE_TYPE, (const void**)&pVal, &cbVal);
    _ASSERTE(hr == S_OK);

    // Skip the CA type prefix.
    pVal += 2;

    // Retrieve the COM source interface class name.
    cbcb = CorSigUncompressData((PCCOR_SIGNATURE)pVal, (ULONG*)&cbStr);
    pVal += cbcb;

    // Copy the name to a temporary buffer and NULL terminate it.
    IfFailThrow(qbClassName.ReSize(cbStr + 1));
    memcpyNoGCRefs(qbClassName.Ptr(), pVal, cbStr);
    qbClassName[cbStr] = 0;
    pVal += cbStr;

    // Try to load the class using its name as a fully qualified name. If that fails, 
    // then we try to load it in the assembly of the current class.
    GCPROTECT_BEGIN(pThrowable);
    {
        SrcItfType = pCurrDomain->FindAssemblyQualifiedTypeHandle(qbClassName.Ptr(), true, GetAssembly(), NULL, &pThrowable);
        if (SrcItfType.IsNull())
            COMPlusThrow(pThrowable);
    }
    GCPROTECT_END();

    // Retrieve the COM event provider class name.
    cbcb = CorSigUncompressData((PCCOR_SIGNATURE)pVal, (ULONG*)&cbStr);
    pVal += cbcb;

    // Copy the name to a temporary buffer and NULL terminate it.
    IfFailThrow(qbClassName.ReSize(cbStr + 1));
    memcpyNoGCRefs(qbClassName.Ptr(), pVal, cbStr);
    qbClassName[cbStr] = 0;
    pVal += cbStr;

    // Try to load the class using its name as a fully qualified name. If that fails, 
    // then we try to load it in the assembly of the current class.
    GCPROTECT_BEGIN(pThrowable);
    {
        EventProvType = pCurrDomain->FindAssemblyQualifiedTypeHandle(qbClassName.Ptr(), true, GetAssembly(), NULL, &pThrowable);
        if (EventProvType.IsNull())
            COMPlusThrow(pThrowable);
    }
    GCPROTECT_END();

    // Set the source interface and event provider classes.
    *ppSrcItfClass = SrcItfType.GetClass();
    *ppEvProvClass = EventProvType.GetClass();
}


// We find a lot of information from the VTable.  But sometimes the VTable is a
// thunking layer rather than the true type's VTable.  For instance, context
// proxies use a single VTable for proxies to all the types we've loaded.
// The following service adjusts a EEClass based on the supplied instance.  As
// we add new thunking layers, we just need to teach this service how to navigate
// through them.
EEClass *EEClass::AdjustForThunking(OBJECTREF or)
{
    EEClass *pClass = this;

    _ASSERTE((or->GetClass() == this) ||
             or->GetClass()->IsThunking());

    if (IsThunking())
    {
        if(GetMethodTable()->IsTransparentProxyType())
        {
            pClass = CTPMethodTable::GetClassBeingProxied(or);
        }
        else
        {
            pClass = or->GetClass();
        }
        _ASSERTE(!pClass->IsThunking());
    }

    return pClass;
}

EEClass *EEClass::GetDefItfForComClassItf()
{
    _ASSERTE(IsComClassInterface());

    if (GetMethodTable()->GetNumInterfaces() > 0)
    {
        // The COM class interface uses the normal scheme which is to have no 
        // methods and to implement default interface and optionnally the 
        // default source interface. In this scheme, the first implemented
        // interface is the default interface which we return.
        _ASSERTE(GetMethodTable()->GetInterfaceMap());
        return GetMethodTable()->GetInterfaceMap()[0].m_pMethodTable->GetClass();
    }
    else
    {
        // The COM class interface has the methods directly on the itself.
        // Because of this we need to consider it to be the default interface.
        return this;
    }
}

MethodTable *MethodTable::AdjustForThunking(OBJECTREF or)
{
    MethodTable *pMT = this;

    _ASSERTE(or->GetMethodTable() == this);

    if (IsThunking())
    {
        if(IsTransparentProxyType())
        {
            pMT = CTPMethodTable::GetClassBeingProxied(or)->GetMethodTable();
        }
        else
        {
            pMT = or->GetMethodTable();
        }
        _ASSERTE(!pMT->IsThunking());
    }
    return pMT;
}


//
// Helper routines for the macros defined at the top of this class.
// You probably should not use these functions directly.
//

LPUTF8 EEClass::_GetFullyQualifiedNameForClassNestedAware(LPUTF8 buf, DWORD dwBuffer)
{
    LPCUTF8 pszNamespace;
    LPCUTF8 pszName;
    mdTypeDef mdEncl;
    IMDInternalImport *pImport;
    CQuickBytes       qb;

    pszName = GetFullyQualifiedNameInfo(&pszNamespace);
    if (pszName == NULL)
        return NULL;

    pImport = this->GetModule()->GetMDImport();
    mdEncl = this->GetCl();
    DWORD dwAttr;
    this->GetMDImport()->GetTypeDefProps(this->GetCl(), &dwAttr, NULL);
    if (IsTdNested(dwAttr))
    {   // Build the nesting chain.
        while (SUCCEEDED(pImport->GetNestedClassProps(mdEncl, &mdEncl))) {
            CQuickBytes qb2;
            CQuickBytes qb3;
            LPCUTF8 szEnclName;
            LPCUTF8 szEnclNameSpace;
            pImport->GetNameOfTypeDef(mdEncl,
                                      &szEnclName,
                                      &szEnclNameSpace);

            ns::MakePath(qb2, szEnclNameSpace, szEnclName);
            ns::MakeNestedTypeName(qb3, (LPCUTF8) qb2.Ptr(), pszName);
            
            // @todo: this should be a SIZE_T
            SIZE_T sLen = strlen((LPCUTF8) qb3.Ptr()) + 1;
            strncpy((LPUTF8) qb.Alloc(sLen), (LPCUTF8) qb3.Ptr(), sLen);
            pszName = (LPCUTF8) qb.Ptr();
        }
    }

    if (FAILED(StoreFullyQualifiedName(buf, dwBuffer, pszNamespace, pszName)))
        return NULL;
    return buf;
}

LPWSTR EEClass::_GetFullyQualifiedNameForClassNestedAware(LPWSTR buf, DWORD dwBuffer)
{
    CQuickSTR szBuffer;
    if (FAILED(szBuffer.ReSize(dwBuffer)))
        return NULL;

    _GetFullyQualifiedNameForClassNestedAware(szBuffer.Ptr(), dwBuffer);

    if(!WszMultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, szBuffer.Ptr(), -1, buf, dwBuffer))
        return NULL; 

    return buf;
}


LPUTF8 EEClass::_GetFullyQualifiedNameForClass(LPUTF8 buf, DWORD dwBuffer)
{
    if (IsArrayClass())
    {
        ArrayClass *pArrayClass = (ArrayClass*)this;

        TypeDesc::ConstructName(GetMethodTable()->GetNormCorElementType(), 
                                pArrayClass->GetElementTypeHandle(), 
                                pArrayClass->GetRank(),
                                buf, dwBuffer);
        
        return buf;
    }
    else if (!IsNilToken(m_cl))
    {
        LPCUTF8 szNamespace;
        LPCUTF8 szName;
        GetMDImport()->GetNameOfTypeDef(m_cl, &szName, &szNamespace);

        if (FAILED(StoreFullyQualifiedName(buf, dwBuffer, szNamespace, szName)))
            return NULL;
    }
    else
        return NULL;

    return buf;
}

LPWSTR EEClass::_GetFullyQualifiedNameForClass(LPWSTR buf, DWORD dwBuffer)
{
    CQuickSTR szBuffer;
    if (FAILED(szBuffer.ReSize(dwBuffer)))
        return NULL;

    _GetFullyQualifiedNameForClass(szBuffer.Ptr(), dwBuffer);

    if(!WszMultiByteToWideChar(CP_UTF8, 0, szBuffer.Ptr(), -1, buf, dwBuffer))
        return NULL; 

    return buf;
}

//
// Gets the namespace and class name for the class.  The namespace
// can legitimately come back NULL, however a return value of NULL indicates
// an error.
//
// NOTE: this used to return array class names, which were sometimes squirreled away by the
// class loader hash table.  It's been removed because it wasted space and was basically broken
// in general (sometimes wasn't set, sometimes set wrong).  If you need array class names, 
// use GetFullyQualifiedNameForClass instead.
//
LPCUTF8 EEClass::GetFullyQualifiedNameInfo(LPCUTF8 *ppszNamespace)
{
    if (IsArrayClass())
    {

        *ppszNamespace = NULL;
        return NULL;
    }
    else
    {   
        LPCUTF8 szName; 
        GetMDImport()->GetNameOfTypeDef(m_cl, &szName, ppszNamespace);  
        return szName;  
    }   
}

// Store a fully qualified namespace and name in the supplied buffer (of size cBuffer).
HRESULT EEClass::StoreFullyQualifiedName(
    LPUTF8  pszFullyQualifiedName,
    DWORD   cBuffer,
    LPCUTF8 pszNamespace,
    LPCUTF8 pszName
)
{
    if (ns::MakePath(pszFullyQualifiedName, (int) cBuffer, pszNamespace, pszName))
        return S_OK;
    else
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
}


// Store a fully qualified namespace and name in the supplied buffer (of size cBuffer).
HRESULT EEClass::StoreFullyQualifiedName(
    LPWSTR pszFullyQualifiedName,
    DWORD   cBuffer,
    LPCUTF8 pszNamespace,
    LPCUTF8 pszName
)
{
    if (ns::MakePath(pszFullyQualifiedName, (int) cBuffer, pszNamespace, pszName))
        return S_OK;
    else
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
}


//
// Used for static analysis - therefore, "this" can be an interface
//
BOOL EEClass::StaticSupportsInterface(MethodTable *pInterfaceMT)
{
    _ASSERTE(pInterfaceMT->GetClass()->IsInterface());
    _ASSERTE(!IsThunking());

    _ASSERTE(IsRestored());

    // Check to see if the current class is for the interface passed in.
    if (GetMethodTable() == pInterfaceMT)
        return TRUE;

    // Check to see if the static class definition indicates we implement the interface.
    InterfaceInfo_t *pInterfaces = GetInterfaceMap();
    for (WORD i = 0; i < GetMethodTable()->m_wNumInterface; i++)
    {
        if (pInterfaces[i].m_pMethodTable == pInterfaceMT)
            return TRUE;
    }

    return FALSE;
}


BOOL EEClass::SupportsInterface(OBJECTREF pObj, MethodTable* pInterfaceMT)
{
    _ASSERTE(pInterfaceMT->GetClass()->IsInterface());
    _ASSERTE((pObj->GetClass() == this) || pObj->GetClass()->IsThunking());

    _ASSERTE(IsRestored());

    // Check to see if the static class definition indicates we implement the interface.
    InterfaceInfo_t* pIntf = FindInterface(pInterfaceMT);
    if (pIntf != NULL)
        return TRUE;

    // It is important to give internal context boundaries priority over COM boundaries.
    // Start by checking if we are thunking and if we are delegate the call to the real class.
    EEClass *cls = AdjustForThunking(pObj);
    if (cls != this)
        return cls->SupportsInterface(pObj, pInterfaceMT);
    
    // If this is a COM object, the static class definition might not be complete so we need
    // to check if the COM object implements the interface.
    if (GetMethodTable()->IsComObjectType())
        return ComObject::SupportsInterface(pObj, pInterfaceMT);

    return FALSE;
}


// Version of SupportsInterface that only deals with classic COM instances that
// are not being thunked.
BOOL EEClass::ComObjectSupportsInterface(OBJECTREF pObj, MethodTable* pInterfaceMT)
{
    _ASSERTE(pInterfaceMT->GetClass()->IsInterface());
    _ASSERTE(GetMethodTable()->IsComObjectType());
    _ASSERTE(pObj->GetClass() == this);

    _ASSERTE(IsRestored());

    // Check to see if the static class definition indicates we implement the interface.
    InterfaceInfo_t* pIntf = FindInterface(pInterfaceMT);
    if (pIntf != NULL)
        return TRUE;

    // Since this is a COM object the static class definition might not be complete so we need
    // to check if the COM object implements the interface.
    return ComObject::SupportsInterface(pObj, pInterfaceMT);
}

void EEClass::DebugRecursivelyDumpInstanceFields(LPCUTF8 pszClassName, BOOL debug)
{
    CQuickBytes qb;
    const int nLen = MAX_CLASSNAME_LENGTH + 20;
    LPWSTR buff = (LPWSTR) qb.Alloc( nLen * sizeof(WCHAR));
    if( buff == NULL)
         return;
    
    DWORD cParentInstanceFields;
    DWORD i;

    _ASSERTE(IsRestored());

    if (GetParentClass() != NULL)
    {
        cParentInstanceFields = GetParentClass()->m_wNumInstanceFields;
        DefineFullyQualifiedNameForClass();
        LPCUTF8 name = GetFullyQualifiedNameForClass(GetParentClass());  
        GetParentClass()->DebugRecursivelyDumpInstanceFields(name, debug);
    }
    else
    {
        cParentInstanceFields = 0;
    }

    // Are there any new instance fields declared by this class?
    if (m_wNumInstanceFields > cParentInstanceFields)
    {
        // Display them
        if(debug) {
            _snwprintf(buff, nLen - 1, L"%lS:\n", pszClassName);
            buff[nLen - 1] = L'\0';
            WszOutputDebugString(buff);
        }
        else {
             LOG((LF_ALWAYS, LL_ALWAYS, "%ls:\n", pszClassName));
        }

        for (i = 0; i < (m_wNumInstanceFields-cParentInstanceFields); i++)
        {
            FieldDesc *pFD = &m_pFieldDescList[i];
            // printf("offset %s%3d %s\n", pFD->IsByValue() ? "byvalue " : "", pFD->GetOffset(), pFD->GetName());
            if(debug) {
                _snwprintf(buff, nLen - 1, L"offset %3d %S\n", pFD->GetOffset(), pFD->GetName());
                buff[nLen - 1] = L'\0';
                WszOutputDebugString(buff);
            }
            else {
                LOG((LF_ALWAYS, LL_ALWAYS, "offset %3d %s\n", pFD->GetOffset(), pFD->GetName()));
            }
        }
    }
}

void EEClass::DebugDumpFieldLayout(LPCUTF8 pszClassName, BOOL debug)
{
    CQuickBytes qb;
    const int nLen = MAX_CLASSNAME_LENGTH + 40;    
    LPWSTR buff = (LPWSTR) qb.Alloc(nLen * sizeof(WCHAR));
    if( buff == NULL)
        return;
    
    DWORD   i;
    DWORD   cParentInstanceFields;

    _ASSERTE(IsRestored());

    if (m_wNumStaticFields == 0 && m_wNumInstanceFields == 0)
        return;

    if (GetParentClass() != NULL)
        cParentInstanceFields = GetParentClass()->m_wNumInstanceFields;
    else
        cParentInstanceFields = 0;

    if(debug) {
        _snwprintf(buff, nLen - 1, L"Field layout for '%S':\n\n", pszClassName);
       buff[nLen -1] = L'\0';
        WszOutputDebugString(buff);
    }
    else {
        LOG((LF_ALWAYS, LL_ALWAYS, "Field layout for '%s':\n\n", pszClassName));
    }

    if (m_wNumStaticFields > 0)
    {
        if(debug) {
            WszOutputDebugString(L"Static fields (stored at vtable offsets)\n");
            WszOutputDebugString(L"----------------------------------------\n");
        }
        else {
            LOG((LF_ALWAYS, LL_ALWAYS, "Static fields (stored at vtable offsets)\n"));
            LOG((LF_ALWAYS, LL_ALWAYS, "----------------------------------------\n"));
        }

        for (i = 0; i < m_wNumStaticFields; i++)
        {
            FieldDesc *pFD = &m_pFieldDescList[(m_wNumInstanceFields-cParentInstanceFields) + i];
            if(debug) {
                _snwprintf(buff, nLen - 1, L"offset %3d %S\n", pFD->GetOffset(), pFD->GetName());
                buff[nLen -1] = L'\0';
                WszOutputDebugString(buff);
        }
            else {
                LOG((LF_ALWAYS, LL_ALWAYS, "offset %3d %s\n", pFD->GetOffset(), pFD->GetName()));
    }
        }
    }

    if (m_wNumInstanceFields > 0)
    {
        if (m_wNumStaticFields) {
            if(debug) {
                WszOutputDebugString(L"\n");
            }
            else {
                LOG((LF_ALWAYS, LL_ALWAYS, "\n"));
            }
        }

        if(debug) {
            WszOutputDebugString(L"Instance fields\n");
            WszOutputDebugString(L"---------------\n");
        }
        else {
            LOG((LF_ALWAYS, LL_ALWAYS, "Instance fields\n"));
            LOG((LF_ALWAYS, LL_ALWAYS, "---------------\n"));
        }

        DebugRecursivelyDumpInstanceFields(pszClassName, debug);
    }

    if(debug) {
        WszOutputDebugString(L"\n");
    }
    else {
        LOG((LF_ALWAYS, LL_ALWAYS, "\n"));
    }
}

void EEClass::DebugDumpVtable(LPCUTF8 pszClassName, BOOL debug)
{
    DWORD   i;
    CQuickBytes qb;
    const int nLen = MAX_CLASSNAME_LENGTH *2 + 100;        
    LPWSTR buff = (LPWSTR) qb.Alloc(nLen * sizeof(WCHAR));
    if( buff == NULL)
        return;
    
    if(debug) {
        _snwprintf(buff, nLen - 1, L"Vtable (with interface dupes) for '%S':\n", pszClassName);
        buff[nLen - 1] = L'\0';
#ifdef _DEBUG
        _snwprintf(&buff[wcslen(buff)], nLen -wcslen(buff) -1, L"Total duplicate slots = %d\n", g_dupMethods);
        buff[nLen - 1] = L'\0';
#endif
        WszOutputDebugString(buff);
    }
    else {
        LOG((LF_ALWAYS, LL_ALWAYS, "Vtable (with interface dupes) for '%s':\n", pszClassName));
        LOG((LF_ALWAYS, LL_ALWAYS, "Total duplicate slots = %d\n", g_dupMethods));
    }


    for (i = 0; i < m_wNumMethodSlots; i++)
    {
        MethodDesc *pMD = GetUnknownMethodDescForSlot(i);
        {
            LPCUTF8      pszName = pMD->GetName((USHORT) i);

            DWORD       dwAttrs = pMD->GetAttrs();

            if(debug) {
                DefineFullyQualifiedNameForClass();
                LPCUTF8 name = GetFullyQualifiedNameForClass(pMD->GetClass());  
                _snwprintf(buff, nLen -1,
                         L"slot %2d: %S::%S%S  0x%X (slot = %2d)\n",
                         i,
                         name,
                         pszName,
                         IsMdFinal(dwAttrs) ? " (final)" : "",
                         pMD->GetAddrofCode(),
                         pMD->GetSlot()
                         );
                 buff[nLen - 1] = L'\0';
                WszOutputDebugString(buff);
            }
            else {
                LOG((LF_ALWAYS, LL_ALWAYS, 
                     "slot %2d: %s::%s%s  0x%X (slot = %2d)\n",
                     i,
                     pMD->GetClass()->m_szDebugClassName,
                     pszName,
                     IsMdFinal(dwAttrs) ? " (final)" : "",
                     pMD->GetAddrofCode(),
                     pMD->GetSlot()
                     ));
    }
        }
        if (i == (DWORD)(GetNumVtableSlots()-1)) {
            if(debug) 
                WszOutputDebugString(L"<-- vtable ends here\n");
            else {
                LOG((LF_ALWAYS, LL_ALWAYS, "<-- vtable ends here\n"));
            }
        }

    }

    if (m_wNumInterfaces > 0)
    {
        if(debug)
            WszOutputDebugString(L"Interface map:\n");
        else {
            LOG((LF_ALWAYS, LL_ALWAYS, "Interface map:\n"));
        }
        if (!IsInterface())
        {
            for (i = 0; i < m_wNumInterfaces; i++)
            {
                _ASSERTE(GetInterfaceMap()[i].m_wStartSlot != (WORD) -1);
                
                if(debug) {
                    DefineFullyQualifiedNameForClass();
                    LPCUTF8 name =  GetFullyQualifiedNameForClass(GetInterfaceMap()[i].m_pMethodTable->GetClass());  
                    _snwprintf(buff, nLen -1,
                             L"slot %2d %S %d\n",
                             GetInterfaceMap()[i].m_wStartSlot,
                             name,
                             GetInterfaceMap()[i].m_pMethodTable->GetInterfaceMethodSlots()
                             );
                    buff[nLen - 1] = L'\0';
                    WszOutputDebugString(buff);
                }
                else {
                    LOG((LF_ALWAYS, LL_ALWAYS, 
                       "slot %2d %s %d\n",
                       GetInterfaceMap()[i].m_wStartSlot,
                       GetInterfaceMap()[i].m_pMethodTable->GetClass()->m_szDebugClassName,
                       GetInterfaceMap()[i].m_pMethodTable->GetInterfaceMethodSlots()
                         ));
                }
            }
        }
    }

    if(debug)
        WszOutputDebugString(L"\n");
    else {
        LOG((LF_ALWAYS, LL_ALWAYS, "\n"));
    }
}

void EEClass::DebugDumpGCDesc(LPCUTF8 pszClassName, BOOL debug)
{
    CQuickBytes qb;
    const int nLen = MAX_CLASSNAME_LENGTH  + 100;            
    LPWSTR buff = (LPWSTR) qb.Alloc(nLen * sizeof(WCHAR));
    if( buff == NULL)
        return;

    if(debug) {
        _snwprintf(buff, nLen - 1, L"GC description for '%S':\n\n", pszClassName);
        buff[nLen -1]= L'\0';
        WszOutputDebugString(buff);
    }
    else {
        LOG((LF_ALWAYS, LL_ALWAYS, "GC description for '%s':\n\n", pszClassName));
    }

    if (GetMethodTable()->ContainsPointers())
    {
        CGCDescSeries *pSeries;
        CGCDescSeries *pHighest;

        if(debug)
            WszOutputDebugString(L"GCDesc:\n");
        else {
            LOG((LF_ALWAYS, LL_ALWAYS, "GCDesc:\n"));
        }

        pSeries  = CGCDesc::GetCGCDescFromMT(GetMethodTable())->GetLowestSeries();
        pHighest = CGCDesc::GetCGCDescFromMT(GetMethodTable())->GetHighestSeries();

        while (pSeries <= pHighest)
        {
            if(debug) {
                _snwprintf(buff, nLen - 1, L"   offset %5d (%d w/o Object), size %5d (%5d w/o BaseSize subtr)\n",
                pSeries->GetSeriesOffset(),
                pSeries->GetSeriesOffset() - sizeof(Object),
                pSeries->GetSeriesSize(),
                pSeries->GetSeriesSize() + GetMethodTable()->GetBaseSize()
            );
                buff[nLen - 1] = L'\0';
                WszOutputDebugString(buff);
            }
            else {
                LOG((LF_ALWAYS, LL_ALWAYS, "   offset %5d (%d w/o Object), size %5d (%5d w/o BaseSize subtr)\n",
                     pSeries->GetSeriesOffset(),
                     pSeries->GetSeriesOffset() - sizeof(Object),
                     pSeries->GetSeriesSize(),
                     pSeries->GetSeriesSize() + GetMethodTable()->GetBaseSize()
                     ));
            }
            pSeries++;
        }


        if(debug)
            WszOutputDebugString(L"\n");
        else {
            LOG((LF_ALWAYS, LL_ALWAYS, "\n"));
        }
    }
}

InterfaceInfo_t* EEClass::FindInterface(MethodTable *pInterface)
{
    // verify the interface map is valid
    _ASSERTE(GetInterfaceMap() == m_pMethodTable->GetInterfaceMap());
    _ASSERTE(!IsThunking());

    return m_pMethodTable->FindInterface(pInterface);
}

InterfaceInfo_t* MethodTable::FindInterface(MethodTable *pInterface)
{
    // we can't be an interface ourselves
    _ASSERTE(GetClass()->IsInterface() == FALSE);

    // class we are looking up should be an interface
    _ASSERTE(pInterface->GetClass()->IsInterface() != FALSE);
    _ASSERTE(!IsThunking());

    // We need to be restored so we can compare interface IDs if necessary
    _ASSERTE(IsRestored() || GetClass()->IsRestoring());
    _ASSERTE(pInterface->IsRestored());

    for (DWORD i = 0; i < m_wNumInterface; i++)
    {
        if (m_pIMap[i].m_pMethodTable == pInterface)
        {
            // Extensible RCW's need to be handled specially because they can have interfaces 
            // in their map that are added at runtime. These interfaces will have a start offset 
            // of -1 to indicate this. We cannot take for granted that every instance of this 
            // COM object has this interface so FindInterface on these interfaces is made to fail.
            //
            // However, we are only considering the statically available slots here
            // (m_wNumInterface doesn't contain the dynamic slots), so we can safely
            // ignore this detail.
            _ASSERTE(m_pIMap[i].m_wStartSlot != (WORD) -1);
            return &m_pIMap[i];
        }
    }

    return NULL;
}

MethodDesc *MethodTable::GetMethodDescForInterfaceMethod(MethodDesc *pInterfaceMD)
{
    MethodTable *pInterfaceMT = pInterfaceMD->GetMethodTable();

    _ASSERTE(pInterfaceMT->IsInterface());
    _ASSERTE(FindInterface(pInterfaceMT) != NULL);

    SLOT pCallAddress = ((SLOT **) m_pInterfaceVTableMap)[pInterfaceMT->GetClass()->GetInterfaceId()][pInterfaceMD->GetSlot()];
    
    MethodDesc *pMD = EEClass::GetUnknownMethodDescForSlotAddress(pCallAddress);

    return pMD;
}

//--------------------------------------------------------------------
// Reorders argument from the Interpreter operand stack (operands
// are pushed right->left which each argument occupying 64 bits)
// into WIL format (right->left, variable-sized arguments.)
//
// Parameters:
//    pSig         - The method signature
//    psrc         - Points to first byte *after* the arguments
//    pdst         - Points to first byte *after* the allocated
//                   stack space.
//--------------------------------------------------------------------
extern "C" VOID __stdcall ArgFiller_WilDefault(BOOL fIsStatic,PCCOR_SIGNATURE pSig, Module *pmodule, BYTE *psrc, BYTE *pdst)
{
    BEGINFORBIDGC();

    UINT32 n = MetaSig::SizeOfVirtualFixedArgStack(pmodule,pSig,fIsStatic);

    pdst -= n;
    psrc -= n;
    memcpy(pdst, psrc, n);

    ENDFORBIDGC();
}

#ifdef _X86_

//--------------------------------------------------------------------
// Stack-allocates the memory needed to hold the arguments for a
// EE->Method call where the method's calling convention is
// Wil. This function has to be in assembly because it needs
// complete control over the stack pointer.
//
// Once it has allocated the space, it invokes the ArgFillter_Pascal
// to fill in the arguments.
//--------------------------------------------------------------------
static
__declspec(naked)
INT64 __cdecl CallWorker_WilDefault(const BYTE  *pStubTarget, // [ecx+4]
                                UINT32       numArgSlots,     // [ecx+8]
                                PCCOR_SIGNATURE  pSig,        // [ecx+12]
                                Module      *pModule,         // [ecx+16]
                                const BYTE  *pArgsEnd,        // [ecx+20]
                                BOOL         fIsStatic)       // [ecx+24]
{
    __asm{

        mov     ecx, esp        ;; will use ecx as "ebp" pointer
        mov     eax, [ecx+8]    ;; get "numArgSlots"
        shl     eax, 2          ;; slots -> bytes
        sub     esp, eax        ;; allocate space for arguments

        push    ecx             ;; need to save ecx across call
        push    ecx             ;;    push "pDstEnd" as argument
        push    dword ptr [ecx+20] ;; push "pArgsEnd" as argument
        push    dword ptr [ecx+16] ;; push "pmodule" as argument
        push    dword ptr [ecx+12] ;; push "pSig" as argument
        push    dword ptr [ecx+24] ;; push "fIsStatic" as argument
        call    ArgFiller_WilDefault ;; call function to fill argument array
        pop     ecx             ;; restore ecx
        call    [ecx+4]         ;; call the stub (which also pops the args)
        retn                    ;; return

    }
}


#endif //X86



#ifdef _X86_

//------------------------------------------------------------------------------
// This helper routine enregisters the appropriate arguments and makes the actual call.
//------------------------------------------------------------------------------

__declspec(naked)
INT64 
#ifdef _DEBUG
              CallDescrWorkerInternal
#else
              CallDescrWorker
#endif
                             (LPVOID                   pSrcEnd,             //[edx+0]
                              UINT32                   numStackSlots,       //[edx+4]
                              const ArgumentRegisters *pArgumentRegisters,  //[edx+8]
                              LPVOID                   pTarget              //[edx+12]
                             )
{
    __asm {  
        push    ebp
        mov     ebp, esp
 
        mov     eax, pSrcEnd                   // copy the stack  
        mov     ecx, numStackSlots    
        test    ecx, ecx 
        jz      donestack 
        sub     eax,4 
        push    dword ptr [eax] 
        dec     ecx 
        jz      donestack 
        sub     eax,4 
        push    dword ptr [eax] 
        dec     ecx 
        jz      donestack 
    stackloop: 
        sub     eax,4 
        push    dword ptr [eax] 
        dec     ecx 
        jnz     stackloop 
    donestack:

            // Now, we must push each field of the ArgumentRegister structure.
        mov     eax, pArgumentRegisters

    #define DEFINE_ARGUMENT_REGISTER_BACKWARD_WITH_OFFSET(regname,ofs) \
        mov regname, dword ptr [eax+ofs]
    #include "eecallconv.h"

        call pTarget
        INDEBUG(nop)                // This is a tag that we use in an assert.  Fcalls expect to
                                    // be called from Jitted code or from certain blessed call sites like
                                    // this one.  (See HelperMethodFrame::InsureInit)
        leave
        ret 16
    }
}

#ifdef _DEBUG
INT64 CallDescrWorker
                             (LPVOID                   pSrcEnd,             //[edx+0]
                              UINT32                   numStackSlots,       //[edx+4]
                              const ArgumentRegisters *pArgumentRegisters,  //[edx+8]
                              LPVOID                   pTarget              //[edx+12]
                             )
{
    INT64 retValue;

    // Save a copy of dangerousObjRefs in table.
    Thread* curThread;
    unsigned ObjRefTable[OBJREF_TABSIZE];
    
    curThread = GetThread();

    if (curThread)
        memcpy(ObjRefTable, curThread->dangerousObjRefs,
               sizeof(curThread->dangerousObjRefs));
    
    if (curThread)
        curThread->SetReadyForSuspension ();

    _ASSERTE(curThread->PreemptiveGCDisabled());  // Jitted code expects to be in cooperative mode
    
    retValue = CallDescrWorkerInternal (pSrcEnd, numStackSlots, pArgumentRegisters, pTarget);

    // Restore dangerousObjRefs when we return back to EE after call
    if (curThread)
        memcpy(curThread->dangerousObjRefs, ObjRefTable,
               sizeof(curThread->dangerousObjRefs));

    TRIGGERSGC ();

    ENABLESTRESSHEAP ();

    return retValue;
}
#endif

#else // !_X86_
#ifndef _IA64_
INT64 __cdecl CallDescrWorker(LPVOID                   pSrcEnd,             //[edx+0]
                              UINT32                   numStackSlots,       //[edx+4]
                              const ArgumentRegisters *pArgumentRegisters,  //[edx+8]
                              LPVOID                   pTarget              //[edx+12]
                             )
{
    _ASSERTE(!"@TODO non-X86, non-IA64 - CallDescrWorker (Class.cpp)");
    return 0;
}
#endif // !_IA64_
#endif // !_X86_

BOOL EEClass::CheckRestore()
{
    if (!IsRestored())
    {
        THROWSCOMPLUSEXCEPTION();

        _ASSERTE(GetClassLoader());

        BEGIN_ENSURE_COOPERATIVE_GC();
        OBJECTREF pThrowable = NULL;
        GCPROTECT_BEGIN(pThrowable);

        NameHandle name(GetModule(), m_cl);
        TypeHandle th = GetClassLoader()->LoadTypeHandle(&name, &pThrowable);
        if (th.IsNull())
            COMPlusThrow(pThrowable);

        GCPROTECT_END();
        END_ENSURE_COOPERATIVE_GC();

        if (IsInited())
            return TRUE;
    }

    return FALSE;
}

void MethodTable::InstantiateStaticHandles(OBJECTREF **pHandles, BOOL fTokens)
{
    if (GetClass()->GetNumHandleStatics() == 0)
        return;

    MethodTable **pPointers = (MethodTable**)(m_Vtable + GetClass()->GetNumMethodSlots());
    MethodTable **pPointersEnd = pPointers + GetClass()->GetNumHandleStatics();

    BEGIN_ENSURE_COOPERATIVE_GC();

    // Retrieve the object ref pointers from the app domain.
    OBJECTREF **apObjRefs = new OBJECTREF*[GetClass()->GetNumHandleStatics()];

    //
    // For shared classes, handles should get allocated in the current app domain.
    // For all others, allocate in the same domain as the class.
    //

    AppDomain *pDomain;
    if (IsShared())
        pDomain = ::GetAppDomain();
    else
        pDomain = (AppDomain*) GetModule()->GetDomain();

    // Reserve some object ref pointers.
    pDomain->AllocateStaticFieldObjRefPtrs(GetClass()->GetNumHandleStatics(), apObjRefs);
    OBJECTREF **pHandle = apObjRefs;
    while (pPointers < pPointersEnd)
    {
        if (*pPointers != NULL)
        {
            OBJECTREF obj = NULL;
            MethodTable *pMT;
            if (fTokens)
            {
                DWORD rva = * (DWORD*) pPointers;

                Module *pContainingModule = GetModule()->GetBlobModule(rva);

                //
                // A value type may have static members of its own type;
                // we need to treat this as a special case to avoid 
                // circular loading dependencies.
                //

                TypeHandle typeHnd = CEECompileInfo::DecodeClass(pContainingModule, 
                                                                 GetModule()->GetZapBase() + rva,
                                                                 TRUE);
                    pMT = typeHnd.GetMethodTable();

                if (pMT != this)
                    pMT->CheckRestore();
            }
            else
                pMT = (MethodTable*)*pPointers;
            obj = AllocateObject(pMT);
            SetObjectReference( *pHandle, obj, pDomain );
            *pHandles++ = *pHandle++;
        }
        else 
        {
            *pHandles++ = *pHandle++;
        }

        pPointers++;
    }
    delete []apObjRefs;

    END_ENSURE_COOPERATIVE_GC();
}

void MethodTable::FixupStaticMethodTables()
{
    size_t *blobs = (size_t*)(m_Vtable + GetClass()->GetNumMethodSlots());
    size_t *blobsEnd = blobs + GetClass()->GetNumHandleStatics();

    while (blobs < blobsEnd)
    {
        DWORD rva = (DWORD)(size_t)*blobs;  //@todo WIN64 - is it correct to assume that these blobs will initially contain rva's that we later replce with addresses?

        if (rva != NULL)
        {
            Module *pContainingModule = GetModule()->GetBlobModule(rva);

            //
            // A value type may have static members of its own type;
            // we need to treat this as a special case to avoid 
            // circular loading dependencies.
            //

            TypeHandle typeHnd = CEECompileInfo::DecodeClass(pContainingModule, 
                                                             GetModule()->GetZapBase() + rva,
                                                             TRUE);
            MethodTable *pMT = typeHnd.GetMethodTable();

            if (pMT != this)
                pMT->CheckRestore();

            *blobs = (size_t) pMT;
        }

        blobs++;
    }
}

void EEClass::Restore()

{
    THROWSCOMPLUSEXCEPTION();


    MethodTable *pMT = GetMethodTable();

    STRESS_LOG1(LF_ZAP, LL_INFO10000, "EEClass::Restore: Restoring type %xT\n", pMT);
    LOG((LF_ZAP, LL_INFO10000, 
         "ZAP: Restoring class %s at 0x%x/0x%x.\n", 
         m_szDebugClassName, this, pMT));


    //
    // Set RESTORING flag so we can detect recursive restores
    // (this is currently only used in asserts)
    //

    m_VMFlags |= VMFLAG_RESTORING;


    //
    // Restore parent class
    //

    m_SiblingsChain = m_ChildrenChain = 0;


    if (m_pParentClass != NULL)
    {
        DWORD rva = (DWORD)(size_t)m_pParentClass;  //@todo WIN64 - is it safe to assume that parentclass initially contains an rva that we later replace with an address?
        Module *pContainingModule = GetModule()->GetBlobModule(rva);
        TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                      GetModule()->GetZapBase() + rva);
        m_pParentClass = type.AsClass();
    }

    //
    // Restore interface classes
    //

    InterfaceInfo_t *pInterfaceMap = GetInterfaceMap();
    InterfaceInfo_t *pInterfaceMapEnd = pInterfaceMap + GetNumInterfaces();
    while (pInterfaceMap < pInterfaceMapEnd)
    {
        DWORD rva = (DWORD)(size_t) pInterfaceMap->m_pMethodTable;  //@todo WIN64 - is it safe to assume the m_pMethodTable initially contains an rva and we will later replace it with an address?
        Module *pContainingModule = GetModule()->GetBlobModule(rva);
        TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                      GetModule()->GetZapBase() + rva);
        pInterfaceMap->m_pMethodTable = type.AsMethodTable();

        pInterfaceMap++;
    }
    
    // 
    // Init m_pInterfaceVTableMap
    //

    if (!IsInterface())
    {
        //
        // Set up the interface vtable map, or
        // if we are a com object with zero interfaces, 
        // use the global one.
        //

        pMT->InitInterfaceVTableMap();
        if (pMT->IsComObjectType())
            pMT->SetComObjectType();
    }
    else
    {
        // 
        // Assign an interface ID
        //

        UINT32 id = AssignInterfaceId();



        //
        // Set up our entry in the global interface vtable
        // 

        if (IsSharedInterface())
        {
            // need to copy this to all the appdomains interface managers
            SystemDomain::PropogateSharedInterface(id,
                                                   GetMethodTable()->GetVtable());
        }
        else
        {
            GetModule()->GetDomain()->
              GetInterfaceVTableMapMgr().GetAddrOfGlobalTableForComWrappers()[id] 
              = (LPVOID)(pMT->GetVtable());
        }
    }

        // If we have any thread local statics, our class needs an index, allocate it now.
    if (m_wThreadStaticsSize > 0)

    {
        if(IsShared())
            m_wThreadStaticOffset = (WORD)BaseDomain::IncSharedTLSOffset();
        else 
            m_wThreadStaticOffset = (WORD)GetDomain()->IncUnsharedTLSOffset();
    }

        // same for context local statics 
    if (m_wContextStaticsSize > 0)
    {
        if(IsShared())
            m_wContextStaticOffset = (WORD)BaseDomain::IncSharedCLSOffset();
        else 
            m_wContextStaticOffset = (WORD)GetDomain()->IncUnsharedCLSOffset();
    }


    //
    // Map our system interfaces into the current app domain for COM interop
    //

    MapSystemInterfaces();

    //
    // If the type is not a value class, then store under IID map.
    // 

    if (!IsValueClass())
        GetClassLoader()->InsertClassForCLSID(this);

#if CHECK_APP_DOMAIN_LEAKS

    // 
    // Figure out if we're domain agile.. Need to do this before we start
    // allocating objects of the type (which could happen in InstantiateStaticHandles)
    // because need to determine agility prior to setting the appdomain. 
    // 

    if (g_pConfig->AppDomainLeaks())
        _ASSERTE(IsAppDomainAgilityDone());

#endif

    //
    // Allocate handles for statics
    // 

    if (IsShared())
        GetMethodTable()->FixupStaticMethodTables();
    else
        GetMethodTable()->InstantiateStaticHandles((OBJECTREF**)(pMT->m_Vtable 
                                                                 + m_wNumMethodSlots), TRUE);

    //
    // Restore field marshaler vptrs
    // 

    if (HasLayout())
    {
        EEClassLayoutInfo *pInfo = &((LayoutEEClass*)this)->m_LayoutInfo;

        
        FieldMarshaler *pFM = pInfo->m_pFieldMarshalers;
        FieldMarshaler *pFMEnd = (FieldMarshaler*) ((BYTE *)pFM + pInfo->m_numCTMFields*MAXFIELDMARSHALERSIZE);
        while (pFM < pFMEnd)
        {
            FieldMarshaler::RestoreConstruct(pMT, (void*)pFM, GetModule());
            ((BYTE*&)pFM) += MAXFIELDMARSHALERSIZE;
        }
    }

    if (m_pParentClass != NULL)
        m_pParentClass->NoticeSubtype(this);


    GetMethodTable()->SetClassRestored();

    if (IsInited())
    {
        //
        // Clear the method table's flag.
        //

        GetMethodTable()->SetClassInited();
    }
}

/*
//void EEClass::Restore()
void MethodTable::Restore()
{
    THROWSCOMPLUSEXCEPTION();
    EEClass* pCl = NULL;

#ifdef _DEBUG
    pCl = GetClass();
    LOG((LF_ZAP, LL_INFO10000, 
         "ZAP: Restoring class %s at 0x%x/0x%x.\n", 
         pCl->m_szDebugClassName, pCl, this));
#endif // _DEBUG

    //
    // Set RESTORING flag so we can detect recursive restores
    // (this is currently only used in asserts)
    //

    pCl = GetClass();
    pCl->SetVMFlags(pCl->GetVMFlags() | VMFLAG_RESTORING);

    //
    // Restore parent class
    //

   // pCl->SetSiblingsChain (0);
   // pCl->SetChildrenChain (0);

    if (GetParentClass() != NULL)
    {
        DWORD rva = (DWORD)(size_t)GetParentClass();  //@todo WIN64 - is it safe to assume that parentclass initially contains an rva that we later replace with an address?
        Module *pContainingModule = GetModule()->GetBlobModule(rva);
        TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                      GetModule()->GetZapBase() + rva);
        SetParentMT (type.AsMethodTable());
    }

    //
    // Restore interface classes
    //

    InterfaceInfo_t *pInterfaceMap = GetInterfaceMap();
    InterfaceInfo_t *pInterfaceMapEnd = pInterfaceMap + GetNumInterfaces();
    while (pInterfaceMap < pInterfaceMapEnd)
    {
        DWORD rva = (DWORD)(size_t) pInterfaceMap->m_pMethodTable;  //@todo WIN64 - is it safe to assume the m_pMethodTable initially contains an rva and we will later replace it with an address?
        Module *pContainingModule = GetModule()->GetBlobModule(rva);
        TypeHandle type = CEECompileInfo::DecodeClass(pContainingModule, 
                                                      GetModule()->GetZapBase() + rva);
        pInterfaceMap->m_pMethodTable = type.AsMethodTable();

        pInterfaceMap++;
    }
    
    // 
    // Init m_pInterfaceVTableMap
    //

    if (!IsInterface())
    {
        //
        // Set up the interface vtable map, or
        // if we are a c